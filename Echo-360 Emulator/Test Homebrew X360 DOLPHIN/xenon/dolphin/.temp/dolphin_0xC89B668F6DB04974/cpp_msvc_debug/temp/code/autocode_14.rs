#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 820EAC5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAC5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAC5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAC5C);
		  /* 820EAC5Ch */ case    0:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820EAC5Ch case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820EAC5Ch case    0:*/		return 0x820EAC60;
		  /* 820EAC60h */ case    1:  		/* lwzx R10, <#[R11 + R29]> */
		/* 820EAC60h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820EAC60h case    1:*/		return 0x820EAC64;
		  /* 820EAC64h */ case    2:  		/* cntlzw R10, R10 */
		/* 820EAC64h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 820EAC64h case    2:*/		return 0x820EAC68;
		  /* 820EAC68h */ case    3:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 820EAC68h case    3:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 820EAC68h case    3:*/		return 0x820EAC6C;
		  /* 820EAC6Ch */ case    4:  		/* stwx R10, <#[R11 + R29]> */
		/* 820EAC6Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820EAC6Ch case    4:*/		return 0x820EAC70;
	}
	return 0x820EAC70;
} // Block from 820EAC5Ch-820EAC70h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EAC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAC70);
		  /* 820EAC70h */ case    0:  		/* lwz R11, <#[R31 + 256]> */
		/* 820EAC70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000100) );
		/* 820EAC70h case    0:*/		return 0x820EAC74;
		  /* 820EAC74h */ case    1:  		/* addi R11, R11, 1 */
		/* 820EAC74h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EAC74h case    1:*/		return 0x820EAC78;
		  /* 820EAC78h */ case    2:  		/* stw R11, <#[R31 + 256]> */
		/* 820EAC78h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000100) );
		/* 820EAC78h case    2:*/		return 0x820EAC7C;
		  /* 820EAC7Ch */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 820EAC7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820EAC7Ch case    3:*/		return 0x820EAC80;
		  /* 820EAC80h */ case    4:  		/* lwz R10, <#[R31 + 256]> */
		/* 820EAC80h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000100) );
		/* 820EAC80h case    4:*/		return 0x820EAC84;
		  /* 820EAC84h */ case    5:  		/* cmplw CR6, R10, R11 */
		/* 820EAC84h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820EAC84h case    5:*/		return 0x820EAC88;
		  /* 820EAC88h */ case    6:  		/* bc 12, CR6_LT, -532 */
		/* 820EAC88h case    6:*/		if ( regs.CR[6].lt ) { return 0x820EAA74;  }
		/* 820EAC88h case    6:*/		return 0x820EAC8C;
	}
	return 0x820EAC8C;
} // Block from 820EAC70h-820EAC8Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EAC8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAC8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAC8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAC8C);
		  /* 820EAC8Ch */ case    0:  		/* li R3, 0 */
		/* 820EAC8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EAC8Ch case    0:*/		return 0x820EAC90;
	}
	return 0x820EAC90;
} // Block from 820EAC8Ch-820EAC90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EAC90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAC90);
		  /* 820EAC90h */ case    0:  		/* addi R1, R1, 176 */
		/* 820EAC90h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820EAC90h case    0:*/		return 0x820EAC94;
		  /* 820EAC94h */ case    1:  		/* b -367112 */
		/* 820EAC94h case    1:*/		return 0x8209128C;
		/* 820EAC94h case    1:*/		return 0x820EAC98;
	}
	return 0x820EAC98;
} // Block from 820EAC90h-820EAC98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EAC98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAC98);
		  /* 820EAC98h */ case    0:  		/* mfspr R12, LR */
		/* 820EAC98h case    0:*/		regs.R12 = regs.LR;
		/* 820EAC98h case    0:*/		return 0x820EAC9C;
		  /* 820EAC9Ch */ case    1:  		/* bl -367200 */
		/* 820EAC9Ch case    1:*/		regs.LR = 0x820EACA0; return 0x8209123C;
		/* 820EAC9Ch case    1:*/		return 0x820EACA0;
		  /* 820EACA0h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820EACA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820EACA0h case    2:*/		return 0x820EACA4;
		  /* 820EACA4h */ case    3:  		/* lwz R11, <#[R6 + 48]> */
		/* 820EACA4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000030) );
		/* 820EACA4h case    3:*/		return 0x820EACA8;
		  /* 820EACA8h */ case    4:  		/* mr R28, R3 */
		/* 820EACA8h case    4:*/		regs.R28 = regs.R3;
		/* 820EACA8h case    4:*/		return 0x820EACAC;
		  /* 820EACACh */ case    5:  		/* mr R24, R5 */
		/* 820EACACh case    5:*/		regs.R24 = regs.R5;
		/* 820EACACh case    5:*/		return 0x820EACB0;
		  /* 820EACB0h */ case    6:  		/* mr R25, R6 */
		/* 820EACB0h case    6:*/		regs.R25 = regs.R6;
		/* 820EACB0h case    6:*/		return 0x820EACB4;
		  /* 820EACB4h */ case    7:  		/* mr R21, R7 */
		/* 820EACB4h case    7:*/		regs.R21 = regs.R7;
		/* 820EACB4h case    7:*/		return 0x820EACB8;
		  /* 820EACB8h */ case    8:  		/* cmpwi CR6, R11, -1 */
		/* 820EACB8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EACB8h case    8:*/		return 0x820EACBC;
		  /* 820EACBCh */ case    9:  		/* bc 4, CR6_EQ, 812 */
		/* 820EACBCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x820EAFE8;  }
		/* 820EACBCh case    9:*/		return 0x820EACC0;
		  /* 820EACC0h */ case   10:  		/* lwz R11, <#[R6 + 4]> */
		/* 820EACC0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 820EACC0h case   10:*/		return 0x820EACC4;
		  /* 820EACC4h */ case   11:  		/* lwz R10, <#[R3 + 16]> */
		/* 820EACC4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 820EACC4h case   11:*/		return 0x820EACC8;
		  /* 820EACC8h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EACC8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EACC8h case   12:*/		return 0x820EACCC;
		  /* 820EACCCh */ case   13:  		/* lwzx R31, <#[R10 + R11]> */
		/* 820EACCCh case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EACCCh case   13:*/		return 0x820EACD0;
		  /* 820EACD0h */ case   14:  		/* lwz R11, <#[R31 + 4]> */
		/* 820EACD0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820EACD0h case   14:*/		return 0x820EACD4;
		  /* 820EACD4h */ case   15:  		/* rlwinm. R10, R11, 0, 20, 20 */
		/* 820EACD4h case   15:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R11);
		/* 820EACD4h case   15:*/		return 0x820EACD8;
		  /* 820EACD8h */ case   16:  		/* bc 12, CR0_EQ, 8 */
		/* 820EACD8h case   16:*/		if ( regs.CR[0].eq ) { return 0x820EACE0;  }
		/* 820EACD8h case   16:*/		return 0x820EACDC;
		  /* 820EACDCh */ case   17:  		/* lwz R4, <#[R31]> */
		/* 820EACDCh case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820EACDCh case   17:*/		return 0x820EACE0;
	}
	return 0x820EACE0;
} // Block from 820EAC98h-820EACE0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820EACE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EACE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EACE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EACE0);
		  /* 820EACE0h */ case    0:  		/* or R11, R11, R24 */
		/* 820EACE0h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R24);
		/* 820EACE0h case    0:*/		return 0x820EACE4;
		  /* 820EACE4h */ case    1:  		/* li R7, 4 */
		/* 820EACE4h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 820EACE4h case    1:*/		return 0x820EACE8;
		  /* 820EACE8h */ case    2:  		/* li R6, -1 */
		/* 820EACE8h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820EACE8h case    2:*/		return 0x820EACEC;
		  /* 820EACECh */ case    3:  		/* ori R5, R11, 64 */
		/* 820EACECh case    3:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R11,0x40);
		/* 820EACECh case    3:*/		return 0x820EACF0;
		  /* 820EACF0h */ case    4:  		/* mr R3, R28 */
		/* 820EACF0h case    4:*/		regs.R3 = regs.R28;
		/* 820EACF0h case    4:*/		return 0x820EACF4;
		  /* 820EACF4h */ case    5:  		/* bl 74900 */
		/* 820EACF4h case    5:*/		regs.LR = 0x820EACF8; return 0x820FD188;
		/* 820EACF4h case    5:*/		return 0x820EACF8;
		  /* 820EACF8h */ case    6:  		/* mr R27, R3 */
		/* 820EACF8h case    6:*/		regs.R27 = regs.R3;
		/* 820EACF8h case    6:*/		return 0x820EACFC;
		  /* 820EACFCh */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 820EACFCh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820EACFCh case    7:*/		return 0x820EAD00;
		  /* 820EAD00h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 820EAD00h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820EAD10;  }
		/* 820EAD00h case    8:*/		return 0x820EAD04;
		  /* 820EAD04h */ case    9:  		/* lis R3, -32761 */
		/* 820EAD04h case    9:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820EAD04h case    9:*/		return 0x820EAD08;
		  /* 820EAD08h */ case   10:  		/* ori R3, R3, 14 */
		/* 820EAD08h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820EAD08h case   10:*/		return 0x820EAD0C;
		  /* 820EAD0Ch */ case   11:  		/* b 744 */
		/* 820EAD0Ch case   11:*/		return 0x820EAFF4;
		/* 820EAD0Ch case   11:*/		return 0x820EAD10;
	}
	return 0x820EAD10;
} // Block from 820EACE0h-820EAD10h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820EAD10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAD10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAD10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAD10);
		  /* 820EAD10h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820EAD10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820EAD10h case    0:*/		return 0x820EAD14;
		  /* 820EAD14h */ case    1:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820EAD14h case    1:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820EAD14h case    1:*/		return 0x820EAD18;
	}
	return 0x820EAD18;
} // Block from 820EAD10h-820EAD18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EAD18h
// Function '?MatchLRP2@CShaderProgram@D3DXShader@@IAAJH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAD18);
		  /* 820EAD18h */ case    0:  		/* bc 12, CR0_EQ, 112 */
		/* 820EAD18h case    0:*/		if ( regs.CR[0].eq ) { return 0x820EAD88;  }
		/* 820EAD18h case    0:*/		return 0x820EAD1C;
		  /* 820EAD1Ch */ case    1:  		/* lwz R10, <#[R25 + 60]> */
		/* 820EAD1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x0000003C) );
		/* 820EAD1Ch case    1:*/		return 0x820EAD20;
		  /* 820EAD20h */ case    2:  		/* li R11, 1 */
		/* 820EAD20h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820EAD20h case    2:*/		return 0x820EAD24;
		  /* 820EAD24h */ case    3:  		/* rlwinm. R10, R10, 0, 12, 12 */
		/* 820EAD24h case    3:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R10,regs.R10);
		/* 820EAD24h case    3:*/		return 0x820EAD28;
		  /* 820EAD28h */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 820EAD28h case    4:*/		if ( regs.CR[0].eq ) { return 0x820EAD30;  }
		/* 820EAD28h case    4:*/		return 0x820EAD2C;
		  /* 820EAD2Ch */ case    5:  		/* li R11, -1 */
		/* 820EAD2Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820EAD2Ch case    5:*/		return 0x820EAD30;
	}
	return 0x820EAD30;
} // Block from 820EAD18h-820EAD30h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EAD30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAD30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAD30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAD30);
		  /* 820EAD30h */ case    0:  		/* extsw R11, R11 */
		/* 820EAD30h case    0:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 820EAD30h case    0:*/		return 0x820EAD34;
		  /* 820EAD34h */ case    1:  		/* lfd FR0, <#[R25 + 32]> */
		/* 820EAD34h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R25 + 0x00000020) );
		/* 820EAD34h case    1:*/		return 0x820EAD38;
		  /* 820EAD38h */ case    2:  		/* li R6, 0 */
		/* 820EAD38h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820EAD38h case    2:*/		return 0x820EAD3C;
		  /* 820EAD3Ch */ case    3:  		/* lwz R5, <#[R25 + 100]> */
		/* 820EAD3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R25 + 0x00000064) );
		/* 820EAD3Ch case    3:*/		return 0x820EAD40;
		  /* 820EAD40h */ case    4:  		/* std R11, <#[R1 + 80]> */
		/* 820EAD40h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820EAD40h case    4:*/		return 0x820EAD44;
		  /* 820EAD44h */ case    5:  		/* lfd FR13, <#[R1 + 80]> */
		/* 820EAD44h case    5:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 820EAD44h case    5:*/		return 0x820EAD48;
		  /* 820EAD48h */ case    6:  		/* fcfid FR13, FR13 */
		/* 820EAD48h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 820EAD48h case    6:*/		return 0x820EAD4C;
		  /* 820EAD4Ch */ case    7:  		/* mr R4, R27 */
		/* 820EAD4Ch case    7:*/		regs.R4 = regs.R27;
		/* 820EAD4Ch case    7:*/		return 0x820EAD50;
		  /* 820EAD50h */ case    8:  		/* mr R3, R28 */
		/* 820EAD50h case    8:*/		regs.R3 = regs.R28;
		/* 820EAD50h case    8:*/		return 0x820EAD54;
		  /* 820EAD54h */ case    9:  		/* fmul FR1, FR0, FR13 */
		/* 820EAD54h case    9:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR0,regs.FR13);
		/* 820EAD54h case    9:*/		return 0x820EAD58;
		  /* 820EAD58h */ case   10:  		/* bl 74960 */
		/* 820EAD58h case   10:*/		regs.LR = 0x820EAD5C; return 0x820FD228;
		/* 820EAD58h case   10:*/		return 0x820EAD5C;
		  /* 820EAD5Ch */ case   11:  		/* stw R3, <#[R25 + 48]> */
		/* 820EAD5Ch case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R25 + 0x00000030) );
		/* 820EAD5Ch case   11:*/		return 0x820EAD60;
		  /* 820EAD60h */ case   12:  		/* cmpwi CR6, R3, -1 */
		/* 820EAD60h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820EAD60h case   12:*/		return 0x820EAD64;
		  /* 820EAD64h */ case   13:  		/* bc 12, CR6_EQ, -96 */
		/* 820EAD64h case   13:*/		if ( regs.CR[6].eq ) { return 0x820EAD04;  }
		/* 820EAD64h case   13:*/		return 0x820EAD68;
		  /* 820EAD68h */ case   14:  		/* stw R3, <#[R21]> */
		/* 820EAD68h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R21 + 0x00000000) );
		/* 820EAD68h case   14:*/		return 0x820EAD6C;
		  /* 820EAD6Ch */ case   15:  		/* mr R4, R25 */
		/* 820EAD6Ch case   15:*/		regs.R4 = regs.R25;
		/* 820EAD6Ch case   15:*/		return 0x820EAD70;
		  /* 820EAD70h */ case   16:  		/* lwz R11, <#[R28 + 20]> */
		/* 820EAD70h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 820EAD70h case   16:*/		return 0x820EAD74;
		  /* 820EAD74h */ case   17:  		/* lwz R10, <#[R25 + 48]> */
		/* 820EAD74h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000030) );
		/* 820EAD74h case   17:*/		return 0x820EAD78;
		  /* 820EAD78h */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EAD78h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EAD78h case   18:*/		return 0x820EAD7C;
		  /* 820EAD7Ch */ case   19:  		/* lwzx R3, <#[R11 + R10]> */
		/* 820EAD7Ch case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EAD7Ch case   19:*/		return 0x820EAD80;
		  /* 820EAD80h */ case   20:  		/* bl 73504 */
		/* 820EAD80h case   20:*/		regs.LR = 0x820EAD84; return 0x820FCCA0;
		/* 820EAD80h case   20:*/		return 0x820EAD84;
		  /* 820EAD84h */ case   21:  		/* b 620 */
		/* 820EAD84h case   21:*/		return 0x820EAFF0;
		/* 820EAD84h case   21:*/		return 0x820EAD88;
	}
	return 0x820EAD88;
} // Block from 820EAD30h-820EAD88h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820EAD88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAD88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAD88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAD88);
		  /* 820EAD88h */ case    0:  		/* lwz R22, <#[R28 + 8]> */
		/* 820EAD88h case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R28 + 0x00000008) );
		/* 820EAD88h case    0:*/		return 0x820EAD8C;
		  /* 820EAD8Ch */ case    1:  		/* li R26, 0 */
		/* 820EAD8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820EAD8Ch case    1:*/		return 0x820EAD90;
		  /* 820EAD90h */ case    2:  		/* li R29, 0 */
		/* 820EAD90h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820EAD90h case    2:*/		return 0x820EAD94;
		  /* 820EAD94h */ case    3:  		/* cmplwi CR6, R22, 0 */
		/* 820EAD94h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820EAD94h case    3:*/		return 0x820EAD98;
		  /* 820EAD98h */ case    4:  		/* bc 12, CR6_EQ, 180 */
		/* 820EAD98h case    4:*/		if ( regs.CR[6].eq ) { return 0x820EAE4C;  }
		/* 820EAD98h case    4:*/		return 0x820EAD9C;
		  /* 820EAD9Ch */ case    5:  		/* li R30, 0 */
		/* 820EAD9Ch case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820EAD9Ch case    5:*/		return 0x820EADA0;
		  /* 820EADA0h */ case    6:  		/* lwz R11, <#[R28 + 20]> */
		/* 820EADA0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 820EADA0h case    6:*/		return 0x820EADA4;
		  /* 820EADA4h */ case    7:  		/* lwz R10, <#[R25 + 4]> */
		/* 820EADA4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820EADA4h case    7:*/		return 0x820EADA8;
		  /* 820EADA8h */ case    8:  		/* lwzx R31, <#[R30 + R11]> */
		/* 820EADA8h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820EADA8h case    8:*/		return 0x820EADAC;
		  /* 820EADACh */ case    9:  		/* lwz R11, <#[R31 + 4]> */
		/* 820EADACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820EADACh case    9:*/		return 0x820EADB0;
		  /* 820EADB0h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820EADB0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EADB0h case   10:*/		return 0x820EADB4;
		  /* 820EADB4h */ case   11:  		/* bc 4, CR6_EQ, 40 */
		/* 820EADB4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820EADDC;  }
		/* 820EADB4h case   11:*/		return 0x820EADB8;
		  /* 820EADB8h */ case   12:  		/* lwz R11, <#[R31 + 96]> */
		/* 820EADB8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 820EADB8h case   12:*/		return 0x820EADBC;
		  /* 820EADBCh */ case   13:  		/* lwz R10, <#[R25 + 96]> */
		/* 820EADBCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000060) );
		/* 820EADBCh case   13:*/		return 0x820EADC0;
		  /* 820EADC0h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 820EADC0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EADC0h case   14:*/		return 0x820EADC4;
		  /* 820EADC4h */ case   15:  		/* bc 4, CR6_EQ, 24 */
		/* 820EADC4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820EADDC;  }
		/* 820EADC4h case   15:*/		return 0x820EADC8;
		  /* 820EADC8h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 820EADC8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EADC8h case   16:*/		return 0x820EADCC;
		  /* 820EADCCh */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 820EADCCh case   17:*/		if ( regs.CR[6].eq ) { return 0x820EADDC;  }
		/* 820EADCCh case   17:*/		return 0x820EADD0;
		  /* 820EADD0h */ case   18:  		/* lwz R11, <#[R31 + 8]> */
		/* 820EADD0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820EADD0h case   18:*/		return 0x820EADD4;
		  /* 820EADD4h */ case   19:  		/* cmpwi CR6, R11, -1 */
		/* 820EADD4h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EADD4h case   19:*/		return 0x820EADD8;
		  /* 820EADD8h */ case   20:  		/* bc 12, CR6_EQ, 12 */
		/* 820EADD8h case   20:*/		if ( regs.CR[6].eq ) { return 0x820EADE4;  }
		/* 820EADD8h case   20:*/		return 0x820EADDC;
	}
	return 0x820EADDC;
} // Block from 820EAD88h-820EADDCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 820EADDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EADDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EADDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EADDC);
		  /* 820EADDCh */ case    0:  		/* cmplw CR6, R25, R31 */
		/* 820EADDCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R31);
		/* 820EADDCh case    0:*/		return 0x820EADE0;
		  /* 820EADE0h */ case    1:  		/* bc 4, CR6_EQ, 92 */
		/* 820EADE0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EAE3C;  }
		/* 820EADE0h case    1:*/		return 0x820EADE4;
	}
	return 0x820EADE4;
} // Block from 820EADDCh-820EADE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EADE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EADE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EADE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EADE4);
		  /* 820EADE4h */ case    0:  		/* li R6, 0 */
		/* 820EADE4h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820EADE4h case    0:*/		return 0x820EADE8;
		  /* 820EADE8h */ case    1:  		/* lfd FR1, <#[R31 + 32]> */
		/* 820EADE8h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R31 + 0x00000020) );
		/* 820EADE8h case    1:*/		return 0x820EADEC;
		  /* 820EADECh */ case    2:  		/* mr R4, R27 */
		/* 820EADECh case    2:*/		regs.R4 = regs.R27;
		/* 820EADECh case    2:*/		return 0x820EADF0;
		  /* 820EADF0h */ case    3:  		/* lwz R5, <#[R31 + 100]> */
		/* 820EADF0h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000064) );
		/* 820EADF0h case    3:*/		return 0x820EADF4;
		  /* 820EADF4h */ case    4:  		/* mr R3, R28 */
		/* 820EADF4h case    4:*/		regs.R3 = regs.R28;
		/* 820EADF4h case    4:*/		return 0x820EADF8;
		  /* 820EADF8h */ case    5:  		/* bl 74800 */
		/* 820EADF8h case    5:*/		regs.LR = 0x820EADFC; return 0x820FD228;
		/* 820EADF8h case    5:*/		return 0x820EADFC;
		  /* 820EADFCh */ case    6:  		/* stw R3, <#[R31 + 48]> */
		/* 820EADFCh case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 820EADFCh case    6:*/		return 0x820EAE00;
		  /* 820EAE00h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 820EAE00h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820EAE00h case    7:*/		return 0x820EAE04;
		  /* 820EAE04h */ case    8:  		/* bc 12, CR6_EQ, -256 */
		/* 820EAE04h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EAD04;  }
		/* 820EAE04h case    8:*/		return 0x820EAE08;
		  /* 820EAE08h */ case    9:  		/* lwz R11, <#[R28 + 20]> */
		/* 820EAE08h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 820EAE08h case    9:*/		return 0x820EAE0C;
		  /* 820EAE0Ch */ case   10:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820EAE0Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820EAE0Ch case   10:*/		return 0x820EAE10;
		  /* 820EAE10h */ case   11:  		/* mr R4, R31 */
		/* 820EAE10h case   11:*/		regs.R4 = regs.R31;
		/* 820EAE10h case   11:*/		return 0x820EAE14;
		  /* 820EAE14h */ case   12:  		/* lwzx R23, <#[R10 + R11]> */
		/* 820EAE14h case   12:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EAE14h case   12:*/		return 0x820EAE18;
		  /* 820EAE18h */ case   13:  		/* mr R3, R23 */
		/* 820EAE18h case   13:*/		regs.R3 = regs.R23;
		/* 820EAE18h case   13:*/		return 0x820EAE1C;
		  /* 820EAE1Ch */ case   14:  		/* bl 73348 */
		/* 820EAE1Ch case   14:*/		regs.LR = 0x820EAE20; return 0x820FCCA0;
		/* 820EAE1Ch case   14:*/		return 0x820EAE20;
		  /* 820EAE20h */ case   15:  		/* lwz R11, <#[R23 + 100]> */
		/* 820EAE20h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000064) );
		/* 820EAE20h case   15:*/		return 0x820EAE24;
		  /* 820EAE24h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EAE24h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EAE24h case   16:*/		return 0x820EAE28;
		  /* 820EAE28h */ case   17:  		/* stw R11, <#[R23 + 112]> */
		/* 820EAE28h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000070) );
		/* 820EAE28h case   17:*/		return 0x820EAE2C;
		  /* 820EAE2Ch */ case   18:  		/* lwz R11, <#[R31 + 68]> */
		/* 820EAE2Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820EAE2Ch case   18:*/		return 0x820EAE30;
		  /* 820EAE30h */ case   19:  		/* cmpwi CR6, R11, -1 */
		/* 820EAE30h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EAE30h case   19:*/		return 0x820EAE34;
		  /* 820EAE34h */ case   20:  		/* bc 12, CR6_EQ, 8 */
		/* 820EAE34h case   20:*/		if ( regs.CR[6].eq ) { return 0x820EAE3C;  }
		/* 820EAE34h case   20:*/		return 0x820EAE38;
		  /* 820EAE38h */ case   21:  		/* li R26, 1 */
		/* 820EAE38h case   21:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 820EAE38h case   21:*/		return 0x820EAE3C;
	}
	return 0x820EAE3C;
} // Block from 820EADE4h-820EAE3Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 820EAE3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAE3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAE3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAE3C);
		  /* 820EAE3Ch */ case    0:  		/* addi R29, R29, 1 */
		/* 820EAE3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820EAE3Ch case    0:*/		return 0x820EAE40;
		  /* 820EAE40h */ case    1:  		/* addi R30, R30, 4 */
		/* 820EAE40h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820EAE40h case    1:*/		return 0x820EAE44;
		  /* 820EAE44h */ case    2:  		/* cmplw CR6, R29, R22 */
		/* 820EAE44h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R22);
		/* 820EAE44h case    2:*/		return 0x820EAE48;
		  /* 820EAE48h */ case    3:  		/* bc 12, CR6_LT, -168 */
		/* 820EAE48h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EADA0;  }
		/* 820EAE48h case    3:*/		return 0x820EAE4C;
	}
	return 0x820EAE4C;
} // Block from 820EAE3Ch-820EAE4Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EAE4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAE4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAE4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAE4C);
		  /* 820EAE4Ch */ case    0:  		/* lwz R11, <#[R28 + 228]> */
		/* 820EAE4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 820EAE4Ch case    0:*/		return 0x820EAE50;
		  /* 820EAE50h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820EAE50h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EAE50h case    1:*/		return 0x820EAE54;
		  /* 820EAE54h */ case    2:  		/* bc 12, CR6_EQ, 404 */
		/* 820EAE54h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EAFE8;  }
		/* 820EAE54h case    2:*/		return 0x820EAE58;
		  /* 820EAE58h */ case    3:  		/* cmpwi CR6, R26, 0 */
		/* 820EAE58h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 820EAE58h case    3:*/		return 0x820EAE5C;
		  /* 820EAE5Ch */ case    4:  		/* bc 12, CR6_EQ, 396 */
		/* 820EAE5Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820EAFE8;  }
		/* 820EAE5Ch case    4:*/		return 0x820EAE60;
		  /* 820EAE60h */ case    5:  		/* rlwinm. R10, R24, 0, 18, 18 */
		/* 820EAE60h case    5:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R10,regs.R24);
		/* 820EAE60h case    5:*/		return 0x820EAE64;
		  /* 820EAE64h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 820EAE64h case    6:*/		if ( regs.CR[0].eq ) { return 0x820EAE70;  }
		/* 820EAE64h case    6:*/		return 0x820EAE68;
		  /* 820EAE68h */ case    7:  		/* lwz R23, <#[R11 + 180]> */
		/* 820EAE68h case    7:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x000000B4) );
		/* 820EAE68h case    7:*/		return 0x820EAE6C;
		  /* 820EAE6Ch */ case    8:  		/* b 8 */
		/* 820EAE6Ch case    8:*/		return 0x820EAE74;
		/* 820EAE6Ch case    8:*/		return 0x820EAE70;
	}
	return 0x820EAE70;
} // Block from 820EAE4Ch-820EAE70h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820EAE70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAE70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAE70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAE70);
		  /* 820EAE70h */ case    0:  		/* lwz R23, <#[R11 + 184]> */
		/* 820EAE70h case    0:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x000000B8) );
		/* 820EAE70h case    0:*/		return 0x820EAE74;
	}
	return 0x820EAE74;
} // Block from 820EAE70h-820EAE74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EAE74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAE74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAE74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAE74);
		  /* 820EAE74h */ case    0:  		/* cmpwi CR6, R23, -1 */
		/* 820EAE74h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0xFFFFFFFF);
		/* 820EAE74h case    0:*/		return 0x820EAE78;
		  /* 820EAE78h */ case    1:  		/* bc 12, CR6_EQ, -372 */
		/* 820EAE78h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EAD04;  }
		/* 820EAE78h case    1:*/		return 0x820EAE7C;
		  /* 820EAE7Ch */ case    2:  		/* li R24, 0 */
		/* 820EAE7Ch case    2:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820EAE7Ch case    2:*/		return 0x820EAE80;
		  /* 820EAE80h */ case    3:  		/* cmplwi CR6, R22, 0 */
		/* 820EAE80h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820EAE80h case    3:*/		return 0x820EAE84;
		  /* 820EAE84h */ case    4:  		/* bc 12, CR6_EQ, 356 */
		/* 820EAE84h case    4:*/		if ( regs.CR[6].eq ) { return 0x820EAFE8;  }
		/* 820EAE84h case    4:*/		return 0x820EAE88;
		  /* 820EAE88h */ case    5:  		/* li R26, 0 */
		/* 820EAE88h case    5:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820EAE88h case    5:*/		return 0x820EAE8C;
		  /* 820EAE8Ch */ case    6:  		/* lwz R11, <#[R28 + 20]> */
		/* 820EAE8Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 820EAE8Ch case    6:*/		return 0x820EAE90;
		  /* 820EAE90h */ case    7:  		/* lwz R10, <#[R25 + 4]> */
		/* 820EAE90h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820EAE90h case    7:*/		return 0x820EAE94;
		  /* 820EAE94h */ case    8:  		/* lwzx R29, <#[R26 + R11]> */
		/* 820EAE94h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 820EAE94h case    8:*/		return 0x820EAE98;
		  /* 820EAE98h */ case    9:  		/* lwz R11, <#[R29 + 4]> */
		/* 820EAE98h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820EAE98h case    9:*/		return 0x820EAE9C;
		  /* 820EAE9Ch */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820EAE9Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EAE9Ch case   10:*/		return 0x820EAEA0;
		  /* 820EAEA0h */ case   11:  		/* bc 4, CR6_EQ, 40 */
		/* 820EAEA0h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820EAEC8;  }
		/* 820EAEA0h case   11:*/		return 0x820EAEA4;
		  /* 820EAEA4h */ case   12:  		/* lwz R11, <#[R29 + 96]> */
		/* 820EAEA4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000060) );
		/* 820EAEA4h case   12:*/		return 0x820EAEA8;
		  /* 820EAEA8h */ case   13:  		/* lwz R10, <#[R25 + 96]> */
		/* 820EAEA8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000060) );
		/* 820EAEA8h case   13:*/		return 0x820EAEAC;
		  /* 820EAEACh */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 820EAEACh case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EAEACh case   14:*/		return 0x820EAEB0;
		  /* 820EAEB0h */ case   15:  		/* bc 4, CR6_EQ, 24 */
		/* 820EAEB0h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820EAEC8;  }
		/* 820EAEB0h case   15:*/		return 0x820EAEB4;
		  /* 820EAEB4h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 820EAEB4h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EAEB4h case   16:*/		return 0x820EAEB8;
		  /* 820EAEB8h */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 820EAEB8h case   17:*/		if ( regs.CR[6].eq ) { return 0x820EAEC8;  }
		/* 820EAEB8h case   17:*/		return 0x820EAEBC;
		  /* 820EAEBCh */ case   18:  		/* lwz R11, <#[R29 + 8]> */
		/* 820EAEBCh case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820EAEBCh case   18:*/		return 0x820EAEC0;
		  /* 820EAEC0h */ case   19:  		/* cmpwi CR6, R11, -1 */
		/* 820EAEC0h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EAEC0h case   19:*/		return 0x820EAEC4;
		  /* 820EAEC4h */ case   20:  		/* bc 12, CR6_EQ, 12 */
		/* 820EAEC4h case   20:*/		if ( regs.CR[6].eq ) { return 0x820EAED0;  }
		/* 820EAEC4h case   20:*/		return 0x820EAEC8;
	}
	return 0x820EAEC8;
} // Block from 820EAE74h-820EAEC8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820EAEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAEC8);
		  /* 820EAEC8h */ case    0:  		/* cmplw CR6, R25, R29 */
		/* 820EAEC8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R29);
		/* 820EAEC8h case    0:*/		return 0x820EAECC;
		  /* 820EAECCh */ case    1:  		/* bc 4, CR6_EQ, 268 */
		/* 820EAECCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EAFD8;  }
		/* 820EAECCh case    1:*/		return 0x820EAED0;
	}
	return 0x820EAED0;
} // Block from 820EAEC8h-820EAED0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EAED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAED0);
		  /* 820EAED0h */ case    0:  		/* li R6, 0 */
		/* 820EAED0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820EAED0h case    0:*/		return 0x820EAED4;
		  /* 820EAED4h */ case    1:  		/* lfd FR1, <#[R29 + 32]> */
		/* 820EAED4h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R29 + 0x00000020) );
		/* 820EAED4h case    1:*/		return 0x820EAED8;
		  /* 820EAED8h */ case    2:  		/* mr R4, R23 */
		/* 820EAED8h case    2:*/		regs.R4 = regs.R23;
		/* 820EAED8h case    2:*/		return 0x820EAEDC;
		  /* 820EAEDCh */ case    3:  		/* lwz R5, <#[R29 + 100]> */
		/* 820EAEDCh case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x00000064) );
		/* 820EAEDCh case    3:*/		return 0x820EAEE0;
		  /* 820EAEE0h */ case    4:  		/* lwz R3, <#[R28 + 228]> */
		/* 820EAEE0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x000000E4) );
		/* 820EAEE0h case    4:*/		return 0x820EAEE4;
		  /* 820EAEE4h */ case    5:  		/* bl 74564 */
		/* 820EAEE4h case    5:*/		regs.LR = 0x820EAEE8; return 0x820FD228;
		/* 820EAEE4h case    5:*/		return 0x820EAEE8;
		  /* 820EAEE8h */ case    6:  		/* mr R27, R3 */
		/* 820EAEE8h case    6:*/		regs.R27 = regs.R3;
		/* 820EAEE8h case    6:*/		return 0x820EAEEC;
		  /* 820EAEECh */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 820EAEECh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820EAEECh case    7:*/		return 0x820EAEF0;
		  /* 820EAEF0h */ case    8:  		/* bc 12, CR6_EQ, -492 */
		/* 820EAEF0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EAD04;  }
		/* 820EAEF0h case    8:*/		return 0x820EAEF4;
		  /* 820EAEF4h */ case    9:  		/* lwz R7, <#[R29 + 68]> */
		/* 820EAEF4h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R29 + 0x00000044) );
		/* 820EAEF4h case    9:*/		return 0x820EAEF8;
		  /* 820EAEF8h */ case   10:  		/* cmpwi CR6, R7, -1 */
		/* 820EAEF8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 820EAEF8h case   10:*/		return 0x820EAEFC;
		  /* 820EAEFCh */ case   11:  		/* bc 12, CR6_EQ, 220 */
		/* 820EAEFCh case   11:*/		if ( regs.CR[6].eq ) { return 0x820EAFD8;  }
		/* 820EAEFCh case   11:*/		return 0x820EAF00;
		  /* 820EAF00h */ case   12:  		/* lwz R3, <#[R28 + 228]> */
		/* 820EAF00h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x000000E4) );
		/* 820EAF00h case   12:*/		return 0x820EAF04;
		  /* 820EAF04h */ case   13:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 820EAF04h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820EAF04h case   13:*/		return 0x820EAF08;
		  /* 820EAF08h */ case   14:  		/* lwz R10, <#[R3 + 20]> */
		/* 820EAF08h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 820EAF08h case   14:*/		return 0x820EAF0C;
		  /* 820EAF0Ch */ case   15:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EAF0Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EAF0Ch case   15:*/		return 0x820EAF10;
		  /* 820EAF10h */ case   16:  		/* lwz R11, <#[R11 + 72]> */
		/* 820EAF10h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 820EAF10h case   16:*/		return 0x820EAF14;
		  /* 820EAF14h */ case   17:  		/* cmpwi CR6, R11, -1 */
		/* 820EAF14h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EAF14h case   17:*/		return 0x820EAF18;
		  /* 820EAF18h */ case   18:  		/* bc 12, CR6_EQ, 192 */
		/* 820EAF18h case   18:*/		if ( regs.CR[6].eq ) { return 0x820EAFD8;  }
		/* 820EAF18h case   18:*/		return 0x820EAF1C;
		  /* 820EAF1Ch */ case   19:  		/* lwz R10, <#[R3 + 24]> */
		/* 820EAF1Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820EAF1Ch case   19:*/		return 0x820EAF20;
		  /* 820EAF20h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EAF20h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EAF20h case   20:*/		return 0x820EAF24;
		  /* 820EAF24h */ case   21:  		/* lis R9, 4096 */
		/* 820EAF24h case   21:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 820EAF24h case   21:*/		return 0x820EAF28;
		  /* 820EAF28h */ case   22:  		/* lwzx R31, <#[R10 + R11]> */
		/* 820EAF28h case   22:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EAF28h case   22:*/		return 0x820EAF2C;
		  /* 820EAF2Ch */ case   23:  		/* lwz R11, <#[R31]> */
		/* 820EAF2Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EAF2Ch case   23:*/		return 0x820EAF30;
		  /* 820EAF30h */ case   24:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820EAF30h case   24:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820EAF30h case   24:*/		return 0x820EAF34;
		  /* 820EAF34h */ case   25:  		/* cmplw CR6, R11, R9 */
		/* 820EAF34h case   25:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820EAF34h case   25:*/		return 0x820EAF38;
		  /* 820EAF38h */ case   26:  		/* bc 4, CR6_EQ, 160 */
		/* 820EAF38h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820EAFD8;  }
		/* 820EAF38h case   26:*/		return 0x820EAF3C;
		  /* 820EAF3Ch */ case   27:  		/* lwz R8, <#[R31 + 12]> */
		/* 820EAF3Ch case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 820EAF3Ch case   27:*/		return 0x820EAF40;
		  /* 820EAF40h */ case   28:  		/* li R10, 0 */
		/* 820EAF40h case   28:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820EAF40h case   28:*/		return 0x820EAF44;
		  /* 820EAF44h */ case   29:  		/* cmplwi CR6, R8, 0 */
		/* 820EAF44h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820EAF44h case   29:*/		return 0x820EAF48;
		  /* 820EAF48h */ case   30:  		/* bc 12, CR6_EQ, 40 */
		/* 820EAF48h case   30:*/		if ( regs.CR[6].eq ) { return 0x820EAF70;  }
		/* 820EAF48h case   30:*/		return 0x820EAF4C;
		  /* 820EAF4Ch */ case   31:  		/* lwz R9, <#[R31 + 16]> */
		/* 820EAF4Ch case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820EAF4Ch case   31:*/		return 0x820EAF50;
		  /* 820EAF50h */ case   32:  		/* li R11, 0 */
		/* 820EAF50h case   32:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820EAF50h case   32:*/		return 0x820EAF54;
		  /* 820EAF54h */ case   33:  		/* lwzx R6, <#[R11 + R9]> */
		/* 820EAF54h case   33:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EAF54h case   33:*/		return 0x820EAF58;
		  /* 820EAF58h */ case   34:  		/* cmplw CR6, R6, R7 */
		/* 820EAF58h case   34:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 820EAF58h case   34:*/		return 0x820EAF5C;
		  /* 820EAF5Ch */ case   35:  		/* bc 12, CR6_EQ, 20 */
		/* 820EAF5Ch case   35:*/		if ( regs.CR[6].eq ) { return 0x820EAF70;  }
		/* 820EAF5Ch case   35:*/		return 0x820EAF60;
		  /* 820EAF60h */ case   36:  		/* addi R10, R10, 1 */
		/* 820EAF60h case   36:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EAF60h case   36:*/		return 0x820EAF64;
		  /* 820EAF64h */ case   37:  		/* addi R11, R11, 4 */
		/* 820EAF64h case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EAF64h case   37:*/		return 0x820EAF68;
		  /* 820EAF68h */ case   38:  		/* cmplw CR6, R10, R8 */
		/* 820EAF68h case   38:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820EAF68h case   38:*/		return 0x820EAF6C;
		  /* 820EAF6Ch */ case   39:  		/* bc 12, CR6_LT, -24 */
		/* 820EAF6Ch case   39:*/		if ( regs.CR[6].lt ) { return 0x820EAF54;  }
		/* 820EAF6Ch case   39:*/		return 0x820EAF70;
	}
	return 0x820EAF70;
} // Block from 820EAED0h-820EAF70h (40 instructions)

//////////////////////////////////////////////////////
// Block at 820EAF70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAF70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAF70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAF70);
		  /* 820EAF70h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820EAF70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820EAF70h case    0:*/		return 0x820EAF74;
		  /* 820EAF74h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EAF74h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EAF74h case    1:*/		return 0x820EAF78;
		  /* 820EAF78h */ case    2:  		/* lis R4, 4096 */
		/* 820EAF78h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x1000);
		/* 820EAF78h case    2:*/		return 0x820EAF7C;
		  /* 820EAF7Ch */ case    3:  		/* li R6, 1 */
		/* 820EAF7Ch case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820EAF7Ch case    3:*/		return 0x820EAF80;
		  /* 820EAF80h */ case    4:  		/* li R5, 1 */
		/* 820EAF80h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820EAF80h case    4:*/		return 0x820EAF84;
		  /* 820EAF84h */ case    5:  		/* ori R4, R4, 1 */
		/* 820EAF84h case    5:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820EAF84h case    5:*/		return 0x820EAF88;
		  /* 820EAF88h */ case    6:  		/* lwzx R30, <#[R10 + R11]> */
		/* 820EAF88h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EAF88h case    6:*/		return 0x820EAF8C;
		  /* 820EAF8Ch */ case    7:  		/* bl 74556 */
		/* 820EAF8Ch case    7:*/		regs.LR = 0x820EAF90; return 0x820FD2C8;
		/* 820EAF8Ch case    7:*/		return 0x820EAF90;
		  /* 820EAF90h */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 820EAF90h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820EAF90h case    8:*/		return 0x820EAF94;
		  /* 820EAF94h */ case    9:  		/* bc 12, CR6_EQ, -656 */
		/* 820EAF94h case    9:*/		if ( regs.CR[6].eq ) { return 0x820EAD04;  }
		/* 820EAF94h case    9:*/		return 0x820EAF98;
		  /* 820EAF98h */ case   10:  		/* lwz R11, <#[R28 + 228]> */
		/* 820EAF98h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 820EAF98h case   10:*/		return 0x820EAF9C;
		  /* 820EAF9Ch */ case   11:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820EAF9Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820EAF9Ch case   11:*/		return 0x820EAFA0;
		  /* 820EAFA0h */ case   12:  		/* mr R4, R31 */
		/* 820EAFA0h case   12:*/		regs.R4 = regs.R31;
		/* 820EAFA0h case   12:*/		return 0x820EAFA4;
		  /* 820EAFA4h */ case   13:  		/* lwz R11, <#[R11 + 24]> */
		/* 820EAFA4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820EAFA4h case   13:*/		return 0x820EAFA8;
		  /* 820EAFA8h */ case   14:  		/* lwzx R31, <#[R11 + R10]> */
		/* 820EAFA8h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EAFA8h case   14:*/		return 0x820EAFAC;
		  /* 820EAFACh */ case   15:  		/* mr R3, R31 */
		/* 820EAFACh case   15:*/		regs.R3 = regs.R31;
		/* 820EAFACh case   15:*/		return 0x820EAFB0;
		  /* 820EAFB0h */ case   16:  		/* bl 69440 */
		/* 820EAFB0h case   16:*/		regs.LR = 0x820EAFB4; return 0x820FBEF0;
		/* 820EAFB0h case   16:*/		return 0x820EAFB4;
		  /* 820EAFB4h */ case   17:  		/* lwz R11, <#[R31 + 16]> */
		/* 820EAFB4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820EAFB4h case   17:*/		return 0x820EAFB8;
		  /* 820EAFB8h */ case   18:  		/* stw R27, <#[R11]> */
		/* 820EAFB8h case   18:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 820EAFB8h case   18:*/		return 0x820EAFBC;
		  /* 820EAFBCh */ case   19:  		/* lwz R11, <#[R31 + 8]> */
		/* 820EAFBCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820EAFBCh case   19:*/		return 0x820EAFC0;
		  /* 820EAFC0h */ case   20:  		/* stw R30, <#[R11]> */
		/* 820EAFC0h case   20:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820EAFC0h case   20:*/		return 0x820EAFC4;
		  /* 820EAFC4h */ case   21:  		/* lwz R11, <#[R28 + 20]> */
		/* 820EAFC4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 820EAFC4h case   21:*/		return 0x820EAFC8;
		  /* 820EAFC8h */ case   22:  		/* lwz R10, <#[R29 + 48]> */
		/* 820EAFC8h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000030) );
		/* 820EAFC8h case   22:*/		return 0x820EAFCC;
		  /* 820EAFCCh */ case   23:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EAFCCh case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EAFCCh case   23:*/		return 0x820EAFD0;
		  /* 820EAFD0h */ case   24:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820EAFD0h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EAFD0h case   24:*/		return 0x820EAFD4;
		  /* 820EAFD4h */ case   25:  		/* stw R27, <#[R11 + 68]> */
		/* 820EAFD4h case   25:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000044) );
		/* 820EAFD4h case   25:*/		return 0x820EAFD8;
	}
	return 0x820EAFD8;
} // Block from 820EAF70h-820EAFD8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820EAFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAFD8);
		  /* 820EAFD8h */ case    0:  		/* addi R24, R24, 1 */
		/* 820EAFD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 820EAFD8h case    0:*/		return 0x820EAFDC;
		  /* 820EAFDCh */ case    1:  		/* addi R26, R26, 4 */
		/* 820EAFDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 820EAFDCh case    1:*/		return 0x820EAFE0;
		  /* 820EAFE0h */ case    2:  		/* cmplw CR6, R24, R22 */
		/* 820EAFE0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R22);
		/* 820EAFE0h case    2:*/		return 0x820EAFE4;
		  /* 820EAFE4h */ case    3:  		/* bc 12, CR6_LT, -344 */
		/* 820EAFE4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EAE8C;  }
		/* 820EAFE4h case    3:*/		return 0x820EAFE8;
	}
	return 0x820EAFE8;
} // Block from 820EAFD8h-820EAFE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EAFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAFE8);
		  /* 820EAFE8h */ case    0:  		/* lwz R11, <#[R25 + 48]> */
		/* 820EAFE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000030) );
		/* 820EAFE8h case    0:*/		return 0x820EAFEC;
		  /* 820EAFECh */ case    1:  		/* stw R11, <#[R21]> */
		/* 820EAFECh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820EAFECh case    1:*/		return 0x820EAFF0;
	}
	return 0x820EAFF0;
} // Block from 820EAFE8h-820EAFF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EAFF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAFF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAFF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAFF0);
		  /* 820EAFF0h */ case    0:  		/* li R3, 0 */
		/* 820EAFF0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EAFF0h case    0:*/		return 0x820EAFF4;
	}
	return 0x820EAFF4;
} // Block from 820EAFF0h-820EAFF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EAFF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EAFF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EAFF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EAFF4);
		  /* 820EAFF4h */ case    0:  		/* addi R1, R1, 192 */
		/* 820EAFF4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820EAFF4h case    0:*/		return 0x820EAFF8;
		  /* 820EAFF8h */ case    1:  		/* b -367980 */
		/* 820EAFF8h case    1:*/		return 0x8209128C;
		/* 820EAFF8h case    1:*/		return 0x820EAFFC;
		  /* 820EAFFCh */ case    2:  		/* nop */
		/* 820EAFFCh case    2:*/		cpu::op::nop();
		/* 820EAFFCh case    2:*/		return 0x820EB000;
		  /* 820EB000h */ case    3:  		/* lwz R10, <#[R3 + 24]> */
		/* 820EB000h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820EB000h case    3:*/		return 0x820EB004;
		  /* 820EB004h */ case    4:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 820EB004h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 820EB004h case    4:*/		return 0x820EB008;
		  /* 820EB008h */ case    5:  		/* cmplw CR6, R4, R5 */
		/* 820EB008h case    5:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 820EB008h case    5:*/		return 0x820EB00C;
		  /* 820EB00Ch */ case    6:  		/* lwzx R9, <#[R11 + R10]> */
		/* 820EB00Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EB00Ch case    6:*/		return 0x820EB010;
		  /* 820EB010h */ case    7:  		/* bc 4, CR6_GT, 48 */
		/* 820EB010h case    7:*/		if ( !regs.CR[6].gt ) { return 0x820EB040;  }
		/* 820EB010h case    7:*/		return 0x820EB014;
		  /* 820EB014h */ case    8:  		/* cmplw CR6, R5, R4 */
		/* 820EB014h case    8:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 820EB014h case    8:*/		return 0x820EB018;
		  /* 820EB018h */ case    9:  		/* bc 4, CR6_LT, 80 */
		/* 820EB018h case    9:*/		if ( !regs.CR[6].lt ) { return 0x820EB068;  }
		/* 820EB018h case    9:*/		return 0x820EB01C;
		  /* 820EB01Ch */ case   10:  		/* subf R10, R5, R4 */
		/* 820EB01Ch case   10:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R5,regs.R4);
		/* 820EB01Ch case   10:*/		return 0x820EB020;
		  /* 820EB020h */ case   11:  		/* mtspr CTR, R10 */
		/* 820EB020h case   11:*/		regs.CTR = regs.R10;
		/* 820EB020h case   11:*/		return 0x820EB024;
		  /* 820EB024h */ case   12:  		/* lwz R10, <#[R3 + 24]> */
		/* 820EB024h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820EB024h case   12:*/		return 0x820EB028;
		  /* 820EB028h */ case   13:  		/* add R10, R11, R10 */
		/* 820EB028h case   13:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820EB028h case   13:*/		return 0x820EB02C;
		  /* 820EB02Ch */ case   14:  		/* addi R11, R11, 4 */
		/* 820EB02Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EB02Ch case   14:*/		return 0x820EB030;
		  /* 820EB030h */ case   15:  		/* lwz R8, <#[R10 + 4]> */
		/* 820EB030h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 820EB030h case   15:*/		return 0x820EB034;
		  /* 820EB034h */ case   16:  		/* stw R8, <#[R10]> */
		/* 820EB034h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820EB034h case   16:*/		return 0x820EB038;
		  /* 820EB038h */ case   17:  		/* bc 16, CR0_LT, -20 */
		/* 820EB038h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EB024;  }
		/* 820EB038h case   17:*/		return 0x820EB03C;
		  /* 820EB03Ch */ case   18:  		/* b 44 */
		/* 820EB03Ch case   18:*/		return 0x820EB068;
		/* 820EB03Ch case   18:*/		return 0x820EB040;
	}
	return 0x820EB040;
} // Block from 820EAFF4h-820EB040h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820EB040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB040);
		  /* 820EB040h */ case    0:  		/* cmplw CR6, R5, R4 */
		/* 820EB040h case    0:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 820EB040h case    0:*/		return 0x820EB044;
		  /* 820EB044h */ case    1:  		/* bc 4, CR6_GT, 36 */
		/* 820EB044h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820EB068;  }
		/* 820EB044h case    1:*/		return 0x820EB048;
		  /* 820EB048h */ case    2:  		/* subf R10, R4, R5 */
		/* 820EB048h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R4,regs.R5);
		/* 820EB048h case    2:*/		return 0x820EB04C;
		  /* 820EB04Ch */ case    3:  		/* mtspr CTR, R10 */
		/* 820EB04Ch case    3:*/		regs.CTR = regs.R10;
		/* 820EB04Ch case    3:*/		return 0x820EB050;
		  /* 820EB050h */ case    4:  		/* lwz R10, <#[R3 + 24]> */
		/* 820EB050h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820EB050h case    4:*/		return 0x820EB054;
		  /* 820EB054h */ case    5:  		/* add R10, R11, R10 */
		/* 820EB054h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820EB054h case    5:*/		return 0x820EB058;
		  /* 820EB058h */ case    6:  		/* addi R11, R11, -4 */
		/* 820EB058h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820EB058h case    6:*/		return 0x820EB05C;
		  /* 820EB05Ch */ case    7:  		/* lwz R8, <#[R10 - 4]> */
		/* 820EB05Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 820EB05Ch case    7:*/		return 0x820EB060;
		  /* 820EB060h */ case    8:  		/* stw R8, <#[R10]> */
		/* 820EB060h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820EB060h case    8:*/		return 0x820EB064;
		  /* 820EB064h */ case    9:  		/* bc 16, CR0_LT, -20 */
		/* 820EB064h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EB050;  }
		/* 820EB064h case    9:*/		return 0x820EB068;
	}
	return 0x820EB068;
} // Block from 820EB040h-820EB068h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EB068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB068);
		  /* 820EB068h */ case    0:  		/* lwz R11, <#[R3 + 24]> */
		/* 820EB068h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820EB068h case    0:*/		return 0x820EB06C;
		  /* 820EB06Ch */ case    1:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 820EB06Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 820EB06Ch case    1:*/		return 0x820EB070;
		  /* 820EB070h */ case    2:  		/* li R3, 0 */
		/* 820EB070h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EB070h case    2:*/		return 0x820EB074;
		  /* 820EB074h */ case    3:  		/* stwx R9, <#[R10 + R11]> */
		/* 820EB074h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EB074h case    3:*/		return 0x820EB078;
		  /* 820EB078h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820EB078h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820EB078h case    4:*/		return 0x820EB07C;
	}
	return 0x820EB07C;
} // Block from 820EB068h-820EB07Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EB07Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB07C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB07C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB07C);
		  /* 820EB07Ch */ case    0:  		/* nop */
		/* 820EB07Ch case    0:*/		cpu::op::nop();
		/* 820EB07Ch case    0:*/		return 0x820EB080;
		  /* 820EB080h */ case    1:  		/* lis R11, 29520 */
		/* 820EB080h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0x7350);
		/* 820EB080h case    1:*/		return 0x820EB084;
		  /* 820EB084h */ case    2:  		/* cmplw CR6, R3, R11 */
		/* 820EB084h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820EB084h case    2:*/		return 0x820EB088;
		  /* 820EB088h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 820EB088h case    3:*/		if ( regs.CR[6].eq ) { return 0x820EB0C0;  }
		/* 820EB088h case    3:*/		return 0x820EB08C;
		  /* 820EB08Ch */ case    4:  		/* lis R11, 29536 */
		/* 820EB08Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0x7360);
		/* 820EB08Ch case    4:*/		return 0x820EB090;
		  /* 820EB090h */ case    5:  		/* cmplw CR6, R3, R11 */
		/* 820EB090h case    5:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820EB090h case    5:*/		return 0x820EB094;
		  /* 820EB094h */ case    6:  		/* bc 12, CR6_EQ, 44 */
		/* 820EB094h case    6:*/		if ( regs.CR[6].eq ) { return 0x820EB0C0;  }
		/* 820EB094h case    6:*/		return 0x820EB098;
		  /* 820EB098h */ case    7:  		/* lis R11, 29552 */
		/* 820EB098h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0x7370);
		/* 820EB098h case    7:*/		return 0x820EB09C;
		  /* 820EB09Ch */ case    8:  		/* cmplw CR6, R3, R11 */
		/* 820EB09Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820EB09Ch case    8:*/		return 0x820EB0A0;
		  /* 820EB0A0h */ case    9:  		/* bc 12, CR6_EQ, 32 */
		/* 820EB0A0h case    9:*/		if ( regs.CR[6].eq ) { return 0x820EB0C0;  }
		/* 820EB0A0h case    9:*/		return 0x820EB0A4;
		  /* 820EB0A4h */ case   10:  		/* lis R11, 29568 */
		/* 820EB0A4h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0x7380);
		/* 820EB0A4h case   10:*/		return 0x820EB0A8;
		  /* 820EB0A8h */ case   11:  		/* cmplw CR6, R3, R11 */
		/* 820EB0A8h case   11:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820EB0A8h case   11:*/		return 0x820EB0AC;
		  /* 820EB0ACh */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 820EB0ACh case   12:*/		if ( regs.CR[6].eq ) { return 0x820EB0C0;  }
		/* 820EB0ACh case   12:*/		return 0x820EB0B0;
		  /* 820EB0B0h */ case   13:  		/* lis R11, 4336 */
		/* 820EB0B0h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0x10F0);
		/* 820EB0B0h case   13:*/		return 0x820EB0B4;
		  /* 820EB0B4h */ case   14:  		/* cmplw CR6, R3, R11 */
		/* 820EB0B4h case   14:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820EB0B4h case   14:*/		return 0x820EB0B8;
		  /* 820EB0B8h */ case   15:  		/* li R3, 0 */
		/* 820EB0B8h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EB0B8h case   15:*/		return 0x820EB0BC;
		  /* 820EB0BCh */ case   16:  		/* bclr 4, CR6_EQ */
		/* 820EB0BCh case   16:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820EB0BCh case   16:*/		return 0x820EB0C0;
	}
	return 0x820EB0C0;
} // Block from 820EB07Ch-820EB0C0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820EB0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB0C0);
		  /* 820EB0C0h */ case    0:  		/* li R3, 1 */
		/* 820EB0C0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820EB0C0h case    0:*/		return 0x820EB0C4;
		  /* 820EB0C4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820EB0C4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820EB0C4h case    1:*/		return 0x820EB0C8;
	}
	return 0x820EB0C8;
} // Block from 820EB0C0h-820EB0C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EB0C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB0C8);
		  /* 820EB0C8h */ case    0:  		/* lis R11, 29808 */
		/* 820EB0C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x7470);
		/* 820EB0C8h case    0:*/		return 0x820EB0CC;
		  /* 820EB0CCh */ case    1:  		/* cmplw CR6, R3, R11 */
		/* 820EB0CCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820EB0CCh case    1:*/		return 0x820EB0D0;
		  /* 820EB0D0h */ case    2:  		/* bc 12, CR6_EQ, 56 */
		/* 820EB0D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EB108;  }
		/* 820EB0D0h case    2:*/		return 0x820EB0D4;
		  /* 820EB0D4h */ case    3:  		/* lis R11, 29792 */
		/* 820EB0D4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x7460);
		/* 820EB0D4h case    3:*/		return 0x820EB0D8;
		  /* 820EB0D8h */ case    4:  		/* cmplw CR6, R3, R11 */
		/* 820EB0D8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820EB0D8h case    4:*/		return 0x820EB0DC;
		  /* 820EB0DCh */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 820EB0DCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820EB108;  }
		/* 820EB0DCh case    5:*/		return 0x820EB0E0;
		  /* 820EB0E0h */ case    6:  		/* lis R11, 29760 */
		/* 820EB0E0h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0x7440);
		/* 820EB0E0h case    6:*/		return 0x820EB0E4;
		  /* 820EB0E4h */ case    7:  		/* cmplw CR6, R3, R11 */
		/* 820EB0E4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820EB0E4h case    7:*/		return 0x820EB0E8;
		  /* 820EB0E8h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 820EB0E8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EB108;  }
		/* 820EB0E8h case    8:*/		return 0x820EB0EC;
		  /* 820EB0ECh */ case    9:  		/* lis R11, 29776 */
		/* 820EB0ECh case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0x7450);
		/* 820EB0ECh case    9:*/		return 0x820EB0F0;
		  /* 820EB0F0h */ case   10:  		/* cmplw CR6, R3, R11 */
		/* 820EB0F0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820EB0F0h case   10:*/		return 0x820EB0F4;
		  /* 820EB0F4h */ case   11:  		/* bc 12, CR6_EQ, 20 */
		/* 820EB0F4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820EB108;  }
		/* 820EB0F4h case   11:*/		return 0x820EB0F8;
		  /* 820EB0F8h */ case   12:  		/* lis R11, 29744 */
		/* 820EB0F8h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0x7430);
		/* 820EB0F8h case   12:*/		return 0x820EB0FC;
		  /* 820EB0FCh */ case   13:  		/* cmplw CR6, R3, R11 */
		/* 820EB0FCh case   13:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820EB0FCh case   13:*/		return 0x820EB100;
		  /* 820EB100h */ case   14:  		/* li R3, 0 */
		/* 820EB100h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EB100h case   14:*/		return 0x820EB104;
		  /* 820EB104h */ case   15:  		/* bclr 4, CR6_EQ */
		/* 820EB104h case   15:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820EB104h case   15:*/		return 0x820EB108;
	}
	return 0x820EB108;
} // Block from 820EB0C8h-820EB108h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820EB108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB108);
		  /* 820EB108h */ case    0:  		/* li R3, 1 */
		/* 820EB108h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820EB108h case    0:*/		return 0x820EB10C;
		  /* 820EB10Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820EB10Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820EB10Ch case    1:*/		return 0x820EB110;
	}
	return 0x820EB110;
} // Block from 820EB108h-820EB110h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EB110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB110);
		  /* 820EB110h */ case    0:  		/* mfspr R12, LR */
		/* 820EB110h case    0:*/		regs.R12 = regs.LR;
		/* 820EB110h case    0:*/		return 0x820EB114;
		  /* 820EB114h */ case    1:  		/* bl -368340 */
		/* 820EB114h case    1:*/		regs.LR = 0x820EB118; return 0x82091240;
		/* 820EB114h case    1:*/		return 0x820EB118;
		  /* 820EB118h */ case    2:  		/* stfd FR31, <#[R1 - 96]> */
		/* 820EB118h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 820EB118h case    2:*/		return 0x820EB11C;
		  /* 820EB11Ch */ case    3:  		/* stwu R1, <#[R1 - 176]> */
		/* 820EB11Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820EB11Ch case    3:*/		return 0x820EB120;
		  /* 820EB120h */ case    4:  		/* lwz R11, <#[R4]> */
		/* 820EB120h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820EB120h case    4:*/		return 0x820EB124;
		  /* 820EB124h */ case    5:  		/* mr R27, R3 */
		/* 820EB124h case    5:*/		regs.R27 = regs.R3;
		/* 820EB124h case    5:*/		return 0x820EB128;
		  /* 820EB128h */ case    6:  		/* mr R26, R4 */
		/* 820EB128h case    6:*/		regs.R26 = regs.R4;
		/* 820EB128h case    6:*/		return 0x820EB12C;
		  /* 820EB12Ch */ case    7:  		/* mr R22, R5 */
		/* 820EB12Ch case    7:*/		regs.R22 = regs.R5;
		/* 820EB12Ch case    7:*/		return 0x820EB130;
		  /* 820EB130h */ case    8:  		/* li R23, 0 */
		/* 820EB130h case    8:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820EB130h case    8:*/		return 0x820EB134;
		  /* 820EB134h */ case    9:  		/* cmpwi CR6, R5, 0 */
		/* 820EB134h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 820EB134h case    9:*/		return 0x820EB138;
		  /* 820EB138h */ case   10:  		/* rlwinm R25, R11, 0, 0, 11 */
		/* 820EB138h case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R25,regs.R11);
		/* 820EB138h case   10:*/		return 0x820EB13C;
		  /* 820EB13Ch */ case   11:  		/* rlwinm R28, R11, 0, 12, 31 */
		/* 820EB13Ch case   11:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R11);
		/* 820EB13Ch case   11:*/		return 0x820EB140;
		  /* 820EB140h */ case   12:  		/* lis R24, 4336 */
		/* 820EB140h case   12:*/		cpu::op::lis<0>(regs,&regs.R24,0x10F0);
		/* 820EB140h case   12:*/		return 0x820EB144;
		  /* 820EB144h */ case   13:  		/* bc 12, CR6_EQ, 316 */
		/* 820EB144h case   13:*/		if ( regs.CR[6].eq ) { return 0x820EB280;  }
		/* 820EB144h case   13:*/		return 0x820EB148;
		  /* 820EB148h */ case   14:  		/* cmplw CR6, R25, R24 */
		/* 820EB148h case   14:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R24);
		/* 820EB148h case   14:*/		return 0x820EB14C;
		  /* 820EB14Ch */ case   15:  		/* bc 12, CR6_EQ, 108 */
		/* 820EB14Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820EB1B8;  }
		/* 820EB14Ch case   15:*/		return 0x820EB150;
		  /* 820EB150h */ case   16:  		/* lis R11, 29520 */
		/* 820EB150h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0x7350);
		/* 820EB150h case   16:*/		return 0x820EB154;
		  /* 820EB154h */ case   17:  		/* cmplw CR6, R25, R11 */
		/* 820EB154h case   17:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 820EB154h case   17:*/		return 0x820EB158;
		  /* 820EB158h */ case   18:  		/* bc 12, CR6_EQ, 84 */
		/* 820EB158h case   18:*/		if ( regs.CR[6].eq ) { return 0x820EB1AC;  }
		/* 820EB158h case   18:*/		return 0x820EB15C;
		  /* 820EB15Ch */ case   19:  		/* lis R11, 29536 */
		/* 820EB15Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0x7360);
		/* 820EB15Ch case   19:*/		return 0x820EB160;
		  /* 820EB160h */ case   20:  		/* cmplw CR6, R25, R11 */
		/* 820EB160h case   20:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 820EB160h case   20:*/		return 0x820EB164;
		  /* 820EB164h */ case   21:  		/* bc 12, CR6_EQ, 60 */
		/* 820EB164h case   21:*/		if ( regs.CR[6].eq ) { return 0x820EB1A0;  }
		/* 820EB164h case   21:*/		return 0x820EB168;
		  /* 820EB168h */ case   22:  		/* lis R11, 29552 */
		/* 820EB168h case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0x7370);
		/* 820EB168h case   22:*/		return 0x820EB16C;
		  /* 820EB16Ch */ case   23:  		/* cmplw CR6, R25, R11 */
		/* 820EB16Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 820EB16Ch case   23:*/		return 0x820EB170;
		  /* 820EB170h */ case   24:  		/* bc 12, CR6_EQ, 36 */
		/* 820EB170h case   24:*/		if ( regs.CR[6].eq ) { return 0x820EB194;  }
		/* 820EB170h case   24:*/		return 0x820EB174;
		  /* 820EB174h */ case   25:  		/* lis R11, 29568 */
		/* 820EB174h case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0x7380);
		/* 820EB174h case   25:*/		return 0x820EB178;
		  /* 820EB178h */ case   26:  		/* cmplw CR6, R25, R11 */
		/* 820EB178h case   26:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 820EB178h case   26:*/		return 0x820EB17C;
		  /* 820EB17Ch */ case   27:  		/* bc 12, CR6_EQ, 12 */
		/* 820EB17Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x820EB188;  }
		/* 820EB17Ch case   27:*/		return 0x820EB180;
		  /* 820EB180h */ case   28:  		/* li R3, 0 */
		/* 820EB180h case   28:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EB180h case   28:*/		return 0x820EB184;
		  /* 820EB184h */ case   29:  		/* b 1044 */
		/* 820EB184h case   29:*/		return 0x820EB598;
		/* 820EB184h case   29:*/		return 0x820EB188;
	}
	return 0x820EB188;
} // Block from 820EB110h-820EB188h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820EB188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB188);
		  /* 820EB188h */ case    0:  		/* rlwinm R11, R28, 0, 12, 31 */
		/* 820EB188h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R28);
		/* 820EB188h case    0:*/		return 0x820EB18C;
		  /* 820EB18Ch */ case    1:  		/* oris R30, R11, 29632 */
		/* 820EB18Ch case    1:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0x73C0);
		/* 820EB18Ch case    1:*/		return 0x820EB190;
		  /* 820EB190h */ case    2:  		/* b 544 */
		/* 820EB190h case    2:*/		return 0x820EB3B0;
		/* 820EB190h case    2:*/		return 0x820EB194;
	}
	return 0x820EB194;
} // Block from 820EB188h-820EB194h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EB194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB194);
		  /* 820EB194h */ case    0:  		/* rlwinm R11, R28, 0, 12, 31 */
		/* 820EB194h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R28);
		/* 820EB194h case    0:*/		return 0x820EB198;
		  /* 820EB198h */ case    1:  		/* oris R30, R11, 29616 */
		/* 820EB198h case    1:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0x73B0);
		/* 820EB198h case    1:*/		return 0x820EB19C;
		  /* 820EB19Ch */ case    2:  		/* b 532 */
		/* 820EB19Ch case    2:*/		return 0x820EB3B0;
		/* 820EB19Ch case    2:*/		return 0x820EB1A0;
	}
	return 0x820EB1A0;
} // Block from 820EB194h-820EB1A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EB1A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB1A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB1A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB1A0);
		  /* 820EB1A0h */ case    0:  		/* rlwinm R11, R28, 0, 12, 31 */
		/* 820EB1A0h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R28);
		/* 820EB1A0h case    0:*/		return 0x820EB1A4;
		  /* 820EB1A4h */ case    1:  		/* oris R30, R11, 29600 */
		/* 820EB1A4h case    1:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0x73A0);
		/* 820EB1A4h case    1:*/		return 0x820EB1A8;
		  /* 820EB1A8h */ case    2:  		/* b 520 */
		/* 820EB1A8h case    2:*/		return 0x820EB3B0;
		/* 820EB1A8h case    2:*/		return 0x820EB1AC;
	}
	return 0x820EB1AC;
} // Block from 820EB1A0h-820EB1ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EB1ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB1AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB1AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB1AC);
		  /* 820EB1ACh */ case    0:  		/* rlwinm R11, R28, 0, 12, 31 */
		/* 820EB1ACh case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R28);
		/* 820EB1ACh case    0:*/		return 0x820EB1B0;
		  /* 820EB1B0h */ case    1:  		/* oris R30, R11, 29584 */
		/* 820EB1B0h case    1:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0x7390);
		/* 820EB1B0h case    1:*/		return 0x820EB1B4;
		  /* 820EB1B4h */ case    2:  		/* b 508 */
		/* 820EB1B4h case    2:*/		return 0x820EB3B0;
		/* 820EB1B4h case    2:*/		return 0x820EB1B8;
	}
	return 0x820EB1B8;
} // Block from 820EB1ACh-820EB1B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EB1B8h
// Function '?Scan@CShaderProgram@D3DXShader@@IAAJPAIPAHIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB1B8);
		  /* 820EB1B8h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 820EB1B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820EB1B8h case    0:*/		return 0x820EB1BC;
		  /* 820EB1BCh */ case    1:  		/* rlwinm R29, R28, 0, 12, 31 */
		/* 820EB1BCh case    1:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R29,regs.R28);
		/* 820EB1BCh case    1:*/		return 0x820EB1C0;
		  /* 820EB1C0h */ case    2:  		/* lwz R10, <#[R27 + 20]> */
		/* 820EB1C0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 820EB1C0h case    2:*/		return 0x820EB1C4;
		  /* 820EB1C4h */ case    3:  		/* lwz R9, <#[R27 + 16]> */
		/* 820EB1C4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000010) );
		/* 820EB1C4h case    3:*/		return 0x820EB1C8;
		  /* 820EB1C8h */ case    4:  		/* oris R30, R29, 29440 */
		/* 820EB1C8h case    4:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R29,0x7300);
		/* 820EB1C8h case    4:*/		return 0x820EB1CC;
		  /* 820EB1CCh */ case    5:  		/* lwz R11, <#[R11]> */
		/* 820EB1CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820EB1CCh case    5:*/		return 0x820EB1D0;
		  /* 820EB1D0h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EB1D0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EB1D0h case    6:*/		return 0x820EB1D4;
		  /* 820EB1D4h */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EB1D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EB1D4h case    7:*/		return 0x820EB1D8;
		  /* 820EB1D8h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 820EB1D8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820EB1D8h case    8:*/		return 0x820EB1DC;
		  /* 820EB1DCh */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EB1DCh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EB1DCh case    9:*/		return 0x820EB1E0;
		  /* 820EB1E0h */ case   10:  		/* lwzx R31, <#[R11 + R9]> */
		/* 820EB1E0h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EB1E0h case   10:*/		return 0x820EB1E4;
		  /* 820EB1E4h */ case   11:  		/* lwz R11, <#[R31 + 4]> */
		/* 820EB1E4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820EB1E4h case   11:*/		return 0x820EB1E8;
		  /* 820EB1E8h */ case   12:  		/* andi. R11, R11, 520 */
		/* 820EB1E8h case   12:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x208);
		/* 820EB1E8h case   12:*/		return 0x820EB1EC;
		  /* 820EB1ECh */ case   13:  		/* cmplwi CR0, R11, 0 */
		/* 820EB1ECh case   13:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820EB1ECh case   13:*/		return 0x820EB1F0;
		  /* 820EB1F0h */ case   14:  		/* bc 12, CR0_EQ, 136 */
		/* 820EB1F0h case   14:*/		if ( regs.CR[0].eq ) { return 0x820EB278;  }
		/* 820EB1F0h case   14:*/		return 0x820EB1F4;
		  /* 820EB1F4h */ case   15:  		/* lwz R3, <#[R31]> */
		/* 820EB1F4h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820EB1F4h case   15:*/		return 0x820EB1F8;
		  /* 820EB1F8h */ case   16:  		/* cmplwi CR6, R3, 0 */
		/* 820EB1F8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820EB1F8h case   16:*/		return 0x820EB1FC;
		  /* 820EB1FCh */ case   17:  		/* bc 12, CR6_EQ, 92 */
		/* 820EB1FCh case   17:*/		if ( regs.CR[6].eq ) { return 0x820EB258;  }
		/* 820EB1FCh case   17:*/		return 0x820EB200;
		  /* 820EB200h */ case   18:  		/* li R4, 105 */
		/* 820EB200h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x69);
		/* 820EB200h case   18:*/		return 0x820EB204;
		  /* 820EB204h */ case   19:  		/* bl 1559676 */
		/* 820EB204h case   19:*/		regs.LR = 0x820EB208; return 0x82267E80;
		/* 820EB204h case   19:*/		return 0x820EB208;
		  /* 820EB208h */ case   20:  		/* cmplwi CR0, R3, 0 */
		/* 820EB208h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EB208h case   20:*/		return 0x820EB20C;
		  /* 820EB20Ch */ case   21:  		/* bc 4, CR0_EQ, 76 */
		/* 820EB20Ch case   21:*/		if ( !regs.CR[0].eq ) { return 0x820EB258;  }
		/* 820EB20Ch case   21:*/		return 0x820EB210;
		  /* 820EB210h */ case   22:  		/* li R4, 73 */
		/* 820EB210h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x49);
		/* 820EB210h case   22:*/		return 0x820EB214;
		  /* 820EB214h */ case   23:  		/* lwz R3, <#[R31]> */
		/* 820EB214h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820EB214h case   23:*/		return 0x820EB218;
		  /* 820EB218h */ case   24:  		/* bl 1559656 */
		/* 820EB218h case   24:*/		regs.LR = 0x820EB21C; return 0x82267E80;
		/* 820EB218h case   24:*/		return 0x820EB21C;
		  /* 820EB21Ch */ case   25:  		/* cmplwi CR0, R3, 0 */
		/* 820EB21Ch case   25:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EB21Ch case   25:*/		return 0x820EB220;
		  /* 820EB220h */ case   26:  		/* bc 4, CR0_EQ, 56 */
		/* 820EB220h case   26:*/		if ( !regs.CR[0].eq ) { return 0x820EB258;  }
		/* 820EB220h case   26:*/		return 0x820EB224;
		  /* 820EB224h */ case   27:  		/* li R4, 98 */
		/* 820EB224h case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x62);
		/* 820EB224h case   27:*/		return 0x820EB228;
		  /* 820EB228h */ case   28:  		/* lwz R3, <#[R31]> */
		/* 820EB228h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820EB228h case   28:*/		return 0x820EB22C;
		  /* 820EB22Ch */ case   29:  		/* bl 1559636 */
		/* 820EB22Ch case   29:*/		regs.LR = 0x820EB230; return 0x82267E80;
		/* 820EB22Ch case   29:*/		return 0x820EB230;
		  /* 820EB230h */ case   30:  		/* cmplwi CR0, R3, 0 */
		/* 820EB230h case   30:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EB230h case   30:*/		return 0x820EB234;
		  /* 820EB234h */ case   31:  		/* bc 4, CR0_EQ, 36 */
		/* 820EB234h case   31:*/		if ( !regs.CR[0].eq ) { return 0x820EB258;  }
		/* 820EB234h case   31:*/		return 0x820EB238;
		  /* 820EB238h */ case   32:  		/* li R4, 66 */
		/* 820EB238h case   32:*/		cpu::op::li<0>(regs,&regs.R4,0x42);
		/* 820EB238h case   32:*/		return 0x820EB23C;
		  /* 820EB23Ch */ case   33:  		/* lwz R3, <#[R31]> */
		/* 820EB23Ch case   33:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820EB23Ch case   33:*/		return 0x820EB240;
		  /* 820EB240h */ case   34:  		/* bl 1559616 */
		/* 820EB240h case   34:*/		regs.LR = 0x820EB244; return 0x82267E80;
		/* 820EB240h case   34:*/		return 0x820EB244;
		  /* 820EB244h */ case   35:  		/* cmplwi CR0, R3, 0 */
		/* 820EB244h case   35:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EB244h case   35:*/		return 0x820EB248;
		  /* 820EB248h */ case   36:  		/* bc 4, CR0_EQ, 16 */
		/* 820EB248h case   36:*/		if ( !regs.CR[0].eq ) { return 0x820EB258;  }
		/* 820EB248h case   36:*/		return 0x820EB24C;
		  /* 820EB24Ch */ case   37:  		/* lwz R11, <#[R31 + 4]> */
		/* 820EB24Ch case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820EB24Ch case   37:*/		return 0x820EB250;
		  /* 820EB250h */ case   38:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 820EB250h case   38:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 820EB250h case   38:*/		return 0x820EB254;
		  /* 820EB254h */ case   39:  		/* bc 4, CR0_EQ, 36 */
		/* 820EB254h case   39:*/		if ( !regs.CR[0].eq ) { return 0x820EB278;  }
		/* 820EB254h case   39:*/		return 0x820EB258;
	}
	return 0x820EB258;
} // Block from 820EB1B8h-820EB258h (40 instructions)

//////////////////////////////////////////////////////
// Block at 820EB258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB258);
		  /* 820EB258h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 820EB258h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820EB258h case    0:*/		return 0x820EB25C;
		  /* 820EB25Ch */ case    1:  		/* lwz R10, <#[R27 + 20]> */
		/* 820EB25Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 820EB25Ch case    1:*/		return 0x820EB260;
		  /* 820EB260h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 820EB260h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820EB260h case    2:*/		return 0x820EB264;
		  /* 820EB264h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EB264h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EB264h case    3:*/		return 0x820EB268;
		  /* 820EB268h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EB268h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EB268h case    4:*/		return 0x820EB26C;
		  /* 820EB26Ch */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 820EB26Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820EB26Ch case    5:*/		return 0x820EB270;
		  /* 820EB270h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 820EB270h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EB270h case    6:*/		return 0x820EB274;
		  /* 820EB274h */ case    7:  		/* bc 12, CR6_EQ, 316 */
		/* 820EB274h case    7:*/		if ( regs.CR[6].eq ) { return 0x820EB3B0;  }
		/* 820EB274h case    7:*/		return 0x820EB278;
	}
	return 0x820EB278;
} // Block from 820EB258h-820EB278h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EB278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB278);
		  /* 820EB278h */ case    0:  		/* oris R30, R29, 29616 */
		/* 820EB278h case    0:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R29,0x73B0);
		/* 820EB278h case    0:*/		return 0x820EB27C;
		  /* 820EB27Ch */ case    1:  		/* b 304 */
		/* 820EB27Ch case    1:*/		return 0x820EB3AC;
		/* 820EB27Ch case    1:*/		return 0x820EB280;
	}
	return 0x820EB280;
} // Block from 820EB278h-820EB280h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EB280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB280);
		  /* 820EB280h */ case    0:  		/* cmplw CR6, R25, R24 */
		/* 820EB280h case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R24);
		/* 820EB280h case    0:*/		return 0x820EB284;
		  /* 820EB284h */ case    1:  		/* bc 12, CR6_EQ, 100 */
		/* 820EB284h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EB2E8;  }
		/* 820EB284h case    1:*/		return 0x820EB288;
		  /* 820EB288h */ case    2:  		/* lis R11, 29520 */
		/* 820EB288h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x7350);
		/* 820EB288h case    2:*/		return 0x820EB28C;
		  /* 820EB28Ch */ case    3:  		/* cmplw CR6, R25, R11 */
		/* 820EB28Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 820EB28Ch case    3:*/		return 0x820EB290;
		  /* 820EB290h */ case    4:  		/* bc 12, CR6_EQ, 76 */
		/* 820EB290h case    4:*/		if ( regs.CR[6].eq ) { return 0x820EB2DC;  }
		/* 820EB290h case    4:*/		return 0x820EB294;
		  /* 820EB294h */ case    5:  		/* lis R11, 29536 */
		/* 820EB294h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0x7360);
		/* 820EB294h case    5:*/		return 0x820EB298;
		  /* 820EB298h */ case    6:  		/* cmplw CR6, R25, R11 */
		/* 820EB298h case    6:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 820EB298h case    6:*/		return 0x820EB29C;
		  /* 820EB29Ch */ case    7:  		/* bc 12, CR6_EQ, 52 */
		/* 820EB29Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820EB2D0;  }
		/* 820EB29Ch case    7:*/		return 0x820EB2A0;
		  /* 820EB2A0h */ case    8:  		/* lis R11, 29552 */
		/* 820EB2A0h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0x7370);
		/* 820EB2A0h case    8:*/		return 0x820EB2A4;
		  /* 820EB2A4h */ case    9:  		/* cmplw CR6, R25, R11 */
		/* 820EB2A4h case    9:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 820EB2A4h case    9:*/		return 0x820EB2A8;
		  /* 820EB2A8h */ case   10:  		/* bc 12, CR6_EQ, 28 */
		/* 820EB2A8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820EB2C4;  }
		/* 820EB2A8h case   10:*/		return 0x820EB2AC;
		  /* 820EB2ACh */ case   11:  		/* lis R11, 29568 */
		/* 820EB2ACh case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0x7380);
		/* 820EB2ACh case   11:*/		return 0x820EB2B0;
		  /* 820EB2B0h */ case   12:  		/* cmplw CR6, R25, R11 */
		/* 820EB2B0h case   12:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 820EB2B0h case   12:*/		return 0x820EB2B4;
		  /* 820EB2B4h */ case   13:  		/* bc 4, CR6_EQ, -308 */
		/* 820EB2B4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820EB180;  }
		/* 820EB2B4h case   13:*/		return 0x820EB2B8;
		  /* 820EB2B8h */ case   14:  		/* rlwinm R11, R28, 0, 12, 31 */
		/* 820EB2B8h case   14:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R28);
		/* 820EB2B8h case   14:*/		return 0x820EB2BC;
		  /* 820EB2BCh */ case   15:  		/* oris R30, R11, 29696 */
		/* 820EB2BCh case   15:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0x7400);
		/* 820EB2BCh case   15:*/		return 0x820EB2C0;
		  /* 820EB2C0h */ case   16:  		/* b 240 */
		/* 820EB2C0h case   16:*/		return 0x820EB3B0;
		/* 820EB2C0h case   16:*/		return 0x820EB2C4;
	}
	return 0x820EB2C4;
} // Block from 820EB280h-820EB2C4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820EB2C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB2C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB2C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB2C4);
		  /* 820EB2C4h */ case    0:  		/* rlwinm R11, R28, 0, 12, 31 */
		/* 820EB2C4h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R28);
		/* 820EB2C4h case    0:*/		return 0x820EB2C8;
		  /* 820EB2C8h */ case    1:  		/* oris R30, R11, 29680 */
		/* 820EB2C8h case    1:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0x73F0);
		/* 820EB2C8h case    1:*/		return 0x820EB2CC;
		  /* 820EB2CCh */ case    2:  		/* b 228 */
		/* 820EB2CCh case    2:*/		return 0x820EB3B0;
		/* 820EB2CCh case    2:*/		return 0x820EB2D0;
	}
	return 0x820EB2D0;
} // Block from 820EB2C4h-820EB2D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EB2D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB2D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB2D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB2D0);
		  /* 820EB2D0h */ case    0:  		/* rlwinm R11, R28, 0, 12, 31 */
		/* 820EB2D0h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R28);
		/* 820EB2D0h case    0:*/		return 0x820EB2D4;
		  /* 820EB2D4h */ case    1:  		/* oris R30, R11, 29664 */
		/* 820EB2D4h case    1:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0x73E0);
		/* 820EB2D4h case    1:*/		return 0x820EB2D8;
		  /* 820EB2D8h */ case    2:  		/* b 216 */
		/* 820EB2D8h case    2:*/		return 0x820EB3B0;
		/* 820EB2D8h case    2:*/		return 0x820EB2DC;
	}
	return 0x820EB2DC;
} // Block from 820EB2D0h-820EB2DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EB2DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB2DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB2DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB2DC);
		  /* 820EB2DCh */ case    0:  		/* rlwinm R11, R28, 0, 12, 31 */
		/* 820EB2DCh case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R28);
		/* 820EB2DCh case    0:*/		return 0x820EB2E0;
		  /* 820EB2E0h */ case    1:  		/* oris R30, R11, 29648 */
		/* 820EB2E0h case    1:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0x73D0);
		/* 820EB2E0h case    1:*/		return 0x820EB2E4;
		  /* 820EB2E4h */ case    2:  		/* b 204 */
		/* 820EB2E4h case    2:*/		return 0x820EB3B0;
		/* 820EB2E4h case    2:*/		return 0x820EB2E8;
	}
	return 0x820EB2E8;
} // Block from 820EB2DCh-820EB2E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EB2E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB2E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB2E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB2E8);
		  /* 820EB2E8h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 820EB2E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820EB2E8h case    0:*/		return 0x820EB2EC;
		  /* 820EB2ECh */ case    1:  		/* rlwinm R29, R28, 0, 12, 31 */
		/* 820EB2ECh case    1:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R29,regs.R28);
		/* 820EB2ECh case    1:*/		return 0x820EB2F0;
		  /* 820EB2F0h */ case    2:  		/* lwz R10, <#[R27 + 20]> */
		/* 820EB2F0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 820EB2F0h case    2:*/		return 0x820EB2F4;
		  /* 820EB2F4h */ case    3:  		/* lwz R9, <#[R27 + 16]> */
		/* 820EB2F4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000010) );
		/* 820EB2F4h case    3:*/		return 0x820EB2F8;
		  /* 820EB2F8h */ case    4:  		/* oris R30, R29, 29456 */
		/* 820EB2F8h case    4:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R29,0x7310);
		/* 820EB2F8h case    4:*/		return 0x820EB2FC;
		  /* 820EB2FCh */ case    5:  		/* lwz R11, <#[R11]> */
		/* 820EB2FCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820EB2FCh case    5:*/		return 0x820EB300;
		  /* 820EB300h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EB300h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EB300h case    6:*/		return 0x820EB304;
		  /* 820EB304h */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EB304h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EB304h case    7:*/		return 0x820EB308;
		  /* 820EB308h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 820EB308h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820EB308h case    8:*/		return 0x820EB30C;
		  /* 820EB30Ch */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EB30Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EB30Ch case    9:*/		return 0x820EB310;
		  /* 820EB310h */ case   10:  		/* lwzx R31, <#[R11 + R9]> */
		/* 820EB310h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EB310h case   10:*/		return 0x820EB314;
		  /* 820EB314h */ case   11:  		/* lwz R11, <#[R31 + 4]> */
		/* 820EB314h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820EB314h case   11:*/		return 0x820EB318;
		  /* 820EB318h */ case   12:  		/* andi. R11, R11, 520 */
		/* 820EB318h case   12:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x208);
		/* 820EB318h case   12:*/		return 0x820EB31C;
		  /* 820EB31Ch */ case   13:  		/* cmplwi CR0, R11, 0 */
		/* 820EB31Ch case   13:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820EB31Ch case   13:*/		return 0x820EB320;
		  /* 820EB320h */ case   14:  		/* bc 12, CR0_EQ, 136 */
		/* 820EB320h case   14:*/		if ( regs.CR[0].eq ) { return 0x820EB3A8;  }
		/* 820EB320h case   14:*/		return 0x820EB324;
		  /* 820EB324h */ case   15:  		/* lwz R3, <#[R31]> */
		/* 820EB324h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820EB324h case   15:*/		return 0x820EB328;
		  /* 820EB328h */ case   16:  		/* cmplwi CR6, R3, 0 */
		/* 820EB328h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820EB328h case   16:*/		return 0x820EB32C;
		  /* 820EB32Ch */ case   17:  		/* bc 12, CR6_EQ, 92 */
		/* 820EB32Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x820EB388;  }
		/* 820EB32Ch case   17:*/		return 0x820EB330;
		  /* 820EB330h */ case   18:  		/* li R4, 105 */
		/* 820EB330h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x69);
		/* 820EB330h case   18:*/		return 0x820EB334;
		  /* 820EB334h */ case   19:  		/* bl 1559372 */
		/* 820EB334h case   19:*/		regs.LR = 0x820EB338; return 0x82267E80;
		/* 820EB334h case   19:*/		return 0x820EB338;
		  /* 820EB338h */ case   20:  		/* cmplwi CR0, R3, 0 */
		/* 820EB338h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EB338h case   20:*/		return 0x820EB33C;
		  /* 820EB33Ch */ case   21:  		/* bc 4, CR0_EQ, 76 */
		/* 820EB33Ch case   21:*/		if ( !regs.CR[0].eq ) { return 0x820EB388;  }
		/* 820EB33Ch case   21:*/		return 0x820EB340;
		  /* 820EB340h */ case   22:  		/* li R4, 73 */
		/* 820EB340h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x49);
		/* 820EB340h case   22:*/		return 0x820EB344;
		  /* 820EB344h */ case   23:  		/* lwz R3, <#[R31]> */
		/* 820EB344h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820EB344h case   23:*/		return 0x820EB348;
		  /* 820EB348h */ case   24:  		/* bl 1559352 */
		/* 820EB348h case   24:*/		regs.LR = 0x820EB34C; return 0x82267E80;
		/* 820EB348h case   24:*/		return 0x820EB34C;
		  /* 820EB34Ch */ case   25:  		/* cmplwi CR0, R3, 0 */
		/* 820EB34Ch case   25:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EB34Ch case   25:*/		return 0x820EB350;
		  /* 820EB350h */ case   26:  		/* bc 4, CR0_EQ, 56 */
		/* 820EB350h case   26:*/		if ( !regs.CR[0].eq ) { return 0x820EB388;  }
		/* 820EB350h case   26:*/		return 0x820EB354;
		  /* 820EB354h */ case   27:  		/* li R4, 98 */
		/* 820EB354h case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x62);
		/* 820EB354h case   27:*/		return 0x820EB358;
		  /* 820EB358h */ case   28:  		/* lwz R3, <#[R31]> */
		/* 820EB358h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820EB358h case   28:*/		return 0x820EB35C;
		  /* 820EB35Ch */ case   29:  		/* bl 1559332 */
		/* 820EB35Ch case   29:*/		regs.LR = 0x820EB360; return 0x82267E80;
		/* 820EB35Ch case   29:*/		return 0x820EB360;
		  /* 820EB360h */ case   30:  		/* cmplwi CR0, R3, 0 */
		/* 820EB360h case   30:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EB360h case   30:*/		return 0x820EB364;
		  /* 820EB364h */ case   31:  		/* bc 4, CR0_EQ, 36 */
		/* 820EB364h case   31:*/		if ( !regs.CR[0].eq ) { return 0x820EB388;  }
		/* 820EB364h case   31:*/		return 0x820EB368;
		  /* 820EB368h */ case   32:  		/* li R4, 66 */
		/* 820EB368h case   32:*/		cpu::op::li<0>(regs,&regs.R4,0x42);
		/* 820EB368h case   32:*/		return 0x820EB36C;
		  /* 820EB36Ch */ case   33:  		/* lwz R3, <#[R31]> */
		/* 820EB36Ch case   33:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820EB36Ch case   33:*/		return 0x820EB370;
		  /* 820EB370h */ case   34:  		/* bl 1559312 */
		/* 820EB370h case   34:*/		regs.LR = 0x820EB374; return 0x82267E80;
		/* 820EB370h case   34:*/		return 0x820EB374;
		  /* 820EB374h */ case   35:  		/* cmplwi CR0, R3, 0 */
		/* 820EB374h case   35:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EB374h case   35:*/		return 0x820EB378;
		  /* 820EB378h */ case   36:  		/* bc 4, CR0_EQ, 16 */
		/* 820EB378h case   36:*/		if ( !regs.CR[0].eq ) { return 0x820EB388;  }
		/* 820EB378h case   36:*/		return 0x820EB37C;
		  /* 820EB37Ch */ case   37:  		/* lwz R11, <#[R31 + 4]> */
		/* 820EB37Ch case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820EB37Ch case   37:*/		return 0x820EB380;
		  /* 820EB380h */ case   38:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 820EB380h case   38:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 820EB380h case   38:*/		return 0x820EB384;
		  /* 820EB384h */ case   39:  		/* bc 4, CR0_EQ, 36 */
		/* 820EB384h case   39:*/		if ( !regs.CR[0].eq ) { return 0x820EB3A8;  }
		/* 820EB384h case   39:*/		return 0x820EB388;
	}
	return 0x820EB388;
} // Block from 820EB2E8h-820EB388h (40 instructions)

//////////////////////////////////////////////////////
// Block at 820EB388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB388);
		  /* 820EB388h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 820EB388h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820EB388h case    0:*/		return 0x820EB38C;
		  /* 820EB38Ch */ case    1:  		/* lwz R10, <#[R27 + 20]> */
		/* 820EB38Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 820EB38Ch case    1:*/		return 0x820EB390;
		  /* 820EB390h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 820EB390h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820EB390h case    2:*/		return 0x820EB394;
		  /* 820EB394h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EB394h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EB394h case    3:*/		return 0x820EB398;
		  /* 820EB398h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EB398h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EB398h case    4:*/		return 0x820EB39C;
		  /* 820EB39Ch */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 820EB39Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820EB39Ch case    5:*/		return 0x820EB3A0;
		  /* 820EB3A0h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 820EB3A0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EB3A0h case    6:*/		return 0x820EB3A4;
		  /* 820EB3A4h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820EB3A4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820EB3B0;  }
		/* 820EB3A4h case    7:*/		return 0x820EB3A8;
	}
	return 0x820EB3A8;
} // Block from 820EB388h-820EB3A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EB3A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB3A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB3A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB3A8);
		  /* 820EB3A8h */ case    0:  		/* oris R30, R29, 29680 */
		/* 820EB3A8h case    0:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R29,0x73F0);
		/* 820EB3A8h case    0:*/		return 0x820EB3AC;
	}
	return 0x820EB3AC;
} // Block from 820EB3A8h-820EB3ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EB3ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB3AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB3AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB3AC);
		  /* 820EB3ACh */ case    0:  		/* li R23, 1 */
		/* 820EB3ACh case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 820EB3ACh case    0:*/		return 0x820EB3B0;
	}
	return 0x820EB3B0;
} // Block from 820EB3ACh-820EB3B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EB3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB3B0);
		  /* 820EB3B0h */ case    0:  		/* li R3, 116 */
		/* 820EB3B0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 820EB3B0h case    0:*/		return 0x820EB3B4;
		  /* 820EB3B4h */ case    1:  		/* bl 70116 */
		/* 820EB3B4h case    1:*/		regs.LR = 0x820EB3B8; return 0x820FC598;
		/* 820EB3B4h case    1:*/		return 0x820EB3B8;
		  /* 820EB3B8h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820EB3B8h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EB3B8h case    2:*/		return 0x820EB3BC;
		  /* 820EB3BCh */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820EB3BCh case    3:*/		if ( regs.CR[0].eq ) { return 0x820EB3CC;  }
		/* 820EB3BCh case    3:*/		return 0x820EB3C0;
		  /* 820EB3C0h */ case    4:  		/* bl 68320 */
		/* 820EB3C0h case    4:*/		regs.LR = 0x820EB3C4; return 0x820FBEA0;
		/* 820EB3C0h case    4:*/		return 0x820EB3C4;
		  /* 820EB3C4h */ case    5:  		/* mr R31, R3 */
		/* 820EB3C4h case    5:*/		regs.R31 = regs.R3;
		/* 820EB3C4h case    5:*/		return 0x820EB3C8;
		  /* 820EB3C8h */ case    6:  		/* b 8 */
		/* 820EB3C8h case    6:*/		return 0x820EB3D0;
		/* 820EB3C8h case    6:*/		return 0x820EB3CC;
	}
	return 0x820EB3CC;
} // Block from 820EB3B0h-820EB3CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EB3CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB3CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB3CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB3CC);
		  /* 820EB3CCh */ case    0:  		/* li R31, 0 */
		/* 820EB3CCh case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820EB3CCh case    0:*/		return 0x820EB3D0;
	}
	return 0x820EB3D0;
} // Block from 820EB3CCh-820EB3D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EB3D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB3D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB3D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB3D0);
		  /* 820EB3D0h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820EB3D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820EB3D0h case    0:*/		return 0x820EB3D4;
		  /* 820EB3D4h */ case    1:  		/* bc 12, CR6_EQ, -596 */
		/* 820EB3D4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EB180;  }
		/* 820EB3D4h case    1:*/		return 0x820EB3D8;
		  /* 820EB3D8h */ case    2:  		/* cmplw CR6, R25, R24 */
		/* 820EB3D8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R24);
		/* 820EB3D8h case    2:*/		return 0x820EB3DC;
		  /* 820EB3DCh */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 820EB3DCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820EB3F4;  }
		/* 820EB3DCh case    3:*/		return 0x820EB3E0;
		  /* 820EB3E0h */ case    4:  		/* cmpwi CR6, R23, 0 */
		/* 820EB3E0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 820EB3E0h case    4:*/		return 0x820EB3E4;
		  /* 820EB3E4h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 820EB3E4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820EB3F4;  }
		/* 820EB3E4h case    5:*/		return 0x820EB3E8;
		  /* 820EB3E8h */ case    6:  		/* mr R6, R28 */
		/* 820EB3E8h case    6:*/		regs.R6 = regs.R28;
		/* 820EB3E8h case    6:*/		return 0x820EB3EC;
		  /* 820EB3ECh */ case    7:  		/* mr R5, R28 */
		/* 820EB3ECh case    7:*/		regs.R5 = regs.R28;
		/* 820EB3ECh case    7:*/		return 0x820EB3F0;
		  /* 820EB3F0h */ case    8:  		/* b 12 */
		/* 820EB3F0h case    8:*/		return 0x820EB3FC;
		/* 820EB3F0h case    8:*/		return 0x820EB3F4;
	}
	return 0x820EB3F4;
} // Block from 820EB3D0h-820EB3F4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820EB3F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB3F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB3F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB3F4);
		  /* 820EB3F4h */ case    0:  		/* mr R6, R28 */
		/* 820EB3F4h case    0:*/		regs.R6 = regs.R28;
		/* 820EB3F4h case    0:*/		return 0x820EB3F8;
		  /* 820EB3F8h */ case    1:  		/* rlwinm R5, R28, 1, 0, 30 */
		/* 820EB3F8h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R5,regs.R28);
		/* 820EB3F8h case    1:*/		return 0x820EB3FC;
	}
	return 0x820EB3FC;
} // Block from 820EB3F4h-820EB3FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EB3FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB3FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB3FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB3FC);
		  /* 820EB3FCh */ case    0:  		/* li R7, 0 */
		/* 820EB3FCh case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820EB3FCh case    0:*/		return 0x820EB400;
		  /* 820EB400h */ case    1:  		/* mr R4, R30 */
		/* 820EB400h case    1:*/		regs.R4 = regs.R30;
		/* 820EB400h case    1:*/		return 0x820EB404;
		  /* 820EB404h */ case    2:  		/* mr R3, R31 */
		/* 820EB404h case    2:*/		regs.R3 = regs.R31;
		/* 820EB404h case    2:*/		return 0x820EB408;
		  /* 820EB408h */ case    3:  		/* bl 70184 */
		/* 820EB408h case    3:*/		regs.LR = 0x820EB40C; return 0x820FC630;
		/* 820EB408h case    3:*/		return 0x820EB40C;
		  /* 820EB40Ch */ case    4:  		/* cmpwi CR6, R3, 0 */
		/* 820EB40Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820EB40Ch case    4:*/		return 0x820EB410;
		  /* 820EB410h */ case    5:  		/* mr R3, R31 */
		/* 820EB410h case    5:*/		regs.R3 = regs.R31;
		/* 820EB410h case    5:*/		return 0x820EB414;
		  /* 820EB414h */ case    6:  		/* bc 4, CR6_LT, 20 */
		/* 820EB414h case    6:*/		if ( !regs.CR[6].lt ) { return 0x820EB428;  }
		/* 820EB414h case    6:*/		return 0x820EB418;
		  /* 820EB418h */ case    7:  		/* bl 1253288 */
		/* 820EB418h case    7:*/		regs.LR = 0x820EB41C; return 0x8221D3C0;
		/* 820EB418h case    7:*/		return 0x820EB41C;
		  /* 820EB41Ch */ case    8:  		/* mr R3, R31 */
		/* 820EB41Ch case    8:*/		regs.R3 = regs.R31;
		/* 820EB41Ch case    8:*/		return 0x820EB420;
		  /* 820EB420h */ case    9:  		/* bl 70096 */
		/* 820EB420h case    9:*/		regs.LR = 0x820EB424; return 0x820FC5F0;
		/* 820EB420h case    9:*/		return 0x820EB424;
		  /* 820EB424h */ case   10:  		/* b -676 */
		/* 820EB424h case   10:*/		return 0x820EB180;
		/* 820EB424h case   10:*/		return 0x820EB428;
	}
	return 0x820EB428;
} // Block from 820EB3FCh-820EB428h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820EB428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB428);
		  /* 820EB428h */ case    0:  		/* mr R4, R26 */
		/* 820EB428h case    0:*/		regs.R4 = regs.R26;
		/* 820EB428h case    0:*/		return 0x820EB42C;
		  /* 820EB42Ch */ case    1:  		/* bl 68292 */
		/* 820EB42Ch case    1:*/		regs.LR = 0x820EB430; return 0x820FBEF0;
		/* 820EB42Ch case    1:*/		return 0x820EB430;
		  /* 820EB430h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820EB430h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EB430h case    2:*/		return 0x820EB434;
		  /* 820EB434h */ case    3:  		/* bc 4, CR0_LT, 12 */
		/* 820EB434h case    3:*/		if ( !regs.CR[0].lt ) { return 0x820EB440;  }
		/* 820EB434h case    3:*/		return 0x820EB438;
	}
	return 0x820EB438;
} // Block from 820EB428h-820EB438h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EB438h
// Function '?RFC_Convert@CShaderProgram@D3DXShader@@AAAJPBDKPAVCArgument@2@PAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB438);
		  /* 820EB438h */ case    0:  		/* mr R3, R31 */
		/* 820EB438h case    0:*/		regs.R3 = regs.R31;
		/* 820EB438h case    0:*/		return 0x820EB43C;
		  /* 820EB43Ch */ case    1:  		/* b -36 */
		/* 820EB43Ch case    1:*/		return 0x820EB418;
		/* 820EB43Ch case    1:*/		return 0x820EB440;
	}
	return 0x820EB440;
} // Block from 820EB438h-820EB440h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EB440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB440);
		  /* 820EB440h */ case    0:  		/* lis R11, -32256 */
		/* 820EB440h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820EB440h case    0:*/		return 0x820EB444;
		  /* 820EB444h */ case    1:  		/* cmpwi CR6, R22, 0 */
		/* 820EB444h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 820EB444h case    1:*/		return 0x820EB448;
		  /* 820EB448h */ case    2:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 820EB448h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 820EB448h case    2:*/		return 0x820EB44C;
		  /* 820EB44Ch */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 820EB44Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820EB468;  }
		/* 820EB44Ch case    3:*/		return 0x820EB450;
		  /* 820EB450h */ case    4:  		/* lwz R11, <#[R26 + 12]> */
		/* 820EB450h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 820EB450h case    4:*/		return 0x820EB454;
		  /* 820EB454h */ case    5:  		/* lwz R4, <#[R26 + 16]> */
		/* 820EB454h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000010) );
		/* 820EB454h case    5:*/		return 0x820EB458;
		  /* 820EB458h */ case    6:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820EB458h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820EB458h case    6:*/		return 0x820EB45C;
		  /* 820EB45Ch */ case    7:  		/* lwz R3, <#[R31 + 16]> */
		/* 820EB45Ch case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820EB45Ch case    7:*/		return 0x820EB460;
		  /* 820EB460h */ case    8:  		/* bl -367280 */
		/* 820EB460h case    8:*/		regs.LR = 0x820EB464; return 0x820919B0;
		/* 820EB460h case    8:*/		return 0x820EB464;
		  /* 820EB464h */ case    9:  		/* b 104 */
		/* 820EB464h case    9:*/		return 0x820EB4CC;
		/* 820EB464h case    9:*/		return 0x820EB468;
	}
	return 0x820EB468;
} // Block from 820EB440h-820EB468h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EB468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB468);
		  /* 820EB468h */ case    0:  		/* li R6, 0 */
		/* 820EB468h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820EB468h case    0:*/		return 0x820EB46C;
		  /* 820EB46Ch */ case    1:  		/* lwz R4, <#[R27 + 168]> */
		/* 820EB46Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x000000A8) );
		/* 820EB46Ch case    1:*/		return 0x820EB470;
		  /* 820EB470h */ case    2:  		/* li R5, 0 */
		/* 820EB470h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EB470h case    2:*/		return 0x820EB474;
		  /* 820EB474h */ case    3:  		/* fmr FR1, FR31 */
		/* 820EB474h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820EB474h case    3:*/		return 0x820EB478;
		  /* 820EB478h */ case    4:  		/* mr R3, R27 */
		/* 820EB478h case    4:*/		regs.R3 = regs.R27;
		/* 820EB478h case    4:*/		return 0x820EB47C;
		  /* 820EB47Ch */ case    5:  		/* bl 73132 */
		/* 820EB47Ch case    5:*/		regs.LR = 0x820EB480; return 0x820FD228;
		/* 820EB47Ch case    5:*/		return 0x820EB480;
		  /* 820EB480h */ case    6:  		/* lwz R11, <#[R31 + 16]> */
		/* 820EB480h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820EB480h case    6:*/		return 0x820EB484;
		  /* 820EB484h */ case    7:  		/* stw R3, <#[R11]> */
		/* 820EB484h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 820EB484h case    7:*/		return 0x820EB488;
		  /* 820EB488h */ case    8:  		/* lwz R11, <#[R31 + 16]> */
		/* 820EB488h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820EB488h case    8:*/		return 0x820EB48C;
		  /* 820EB48Ch */ case    9:  		/* lwz R11, <#[R11]> */
		/* 820EB48Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820EB48Ch case    9:*/		return 0x820EB490;
		  /* 820EB490h */ case   10:  		/* cmpwi CR6, R11, -1 */
		/* 820EB490h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EB490h case   10:*/		return 0x820EB494;
		  /* 820EB494h */ case   11:  		/* bc 12, CR6_EQ, -788 */
		/* 820EB494h case   11:*/		if ( regs.CR[6].eq ) { return 0x820EB180;  }
		/* 820EB494h case   11:*/		return 0x820EB498;
		  /* 820EB498h */ case   12:  		/* lwz R11, <#[R26 + 16]> */
		/* 820EB498h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820EB498h case   12:*/		return 0x820EB49C;
		  /* 820EB49Ch */ case   13:  		/* lwz R10, <#[R31 + 16]> */
		/* 820EB49Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820EB49Ch case   13:*/		return 0x820EB4A0;
		  /* 820EB4A0h */ case   14:  		/* lwz R9, <#[R27 + 20]> */
		/* 820EB4A0h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 820EB4A0h case   14:*/		return 0x820EB4A4;
		  /* 820EB4A4h */ case   15:  		/* lwz R11, <#[R11]> */
		/* 820EB4A4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820EB4A4h case   15:*/		return 0x820EB4A8;
		  /* 820EB4A8h */ case   16:  		/* lwz R10, <#[R10]> */
		/* 820EB4A8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820EB4A8h case   16:*/		return 0x820EB4AC;
		  /* 820EB4ACh */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EB4ACh case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EB4ACh case   17:*/		return 0x820EB4B0;
		  /* 820EB4B0h */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EB4B0h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EB4B0h case   18:*/		return 0x820EB4B4;
		  /* 820EB4B4h */ case   19:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820EB4B4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EB4B4h case   19:*/		return 0x820EB4B8;
		  /* 820EB4B8h */ case   20:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820EB4B8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EB4B8h case   20:*/		return 0x820EB4BC;
		  /* 820EB4BCh */ case   21:  		/* lwz R9, <#[R11 + 24]> */
		/* 820EB4BCh case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000018) );
		/* 820EB4BCh case   21:*/		return 0x820EB4C0;
		  /* 820EB4C0h */ case   22:  		/* stw R9, <#[R10 + 24]> */
		/* 820EB4C0h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000018) );
		/* 820EB4C0h case   22:*/		return 0x820EB4C4;
		  /* 820EB4C4h */ case   23:  		/* lwz R11, <#[R11 + 20]> */
		/* 820EB4C4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820EB4C4h case   23:*/		return 0x820EB4C8;
		  /* 820EB4C8h */ case   24:  		/* stw R11, <#[R10 + 20]> */
		/* 820EB4C8h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 820EB4C8h case   24:*/		return 0x820EB4CC;
	}
	return 0x820EB4CC;
} // Block from 820EB468h-820EB4CCh (25 instructions)

//////////////////////////////////////////////////////
// Block at 820EB4CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB4CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB4CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB4CC);
		  /* 820EB4CCh */ case    0:  		/* lwz R11, <#[R26 + 4]> */
		/* 820EB4CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 820EB4CCh case    0:*/		return 0x820EB4D0;
		  /* 820EB4D0h */ case    1:  		/* lwz R4, <#[R26 + 8]> */
		/* 820EB4D0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000008) );
		/* 820EB4D0h case    1:*/		return 0x820EB4D4;
		  /* 820EB4D4h */ case    2:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820EB4D4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820EB4D4h case    2:*/		return 0x820EB4D8;
		  /* 820EB4D8h */ case    3:  		/* lwz R3, <#[R31 + 8]> */
		/* 820EB4D8h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820EB4D8h case    3:*/		return 0x820EB4DC;
		  /* 820EB4DCh */ case    4:  		/* bl -367404 */
		/* 820EB4DCh case    4:*/		regs.LR = 0x820EB4E0; return 0x820919B0;
		/* 820EB4DCh case    4:*/		return 0x820EB4E0;
		  /* 820EB4E0h */ case    5:  		/* cmpwi CR6, R23, 0 */
		/* 820EB4E0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 820EB4E0h case    5:*/		return 0x820EB4E4;
		  /* 820EB4E4h */ case    6:  		/* bc 12, CR6_EQ, 176 */
		/* 820EB4E4h case    6:*/		if ( regs.CR[6].eq ) { return 0x820EB594;  }
		/* 820EB4E4h case    6:*/		return 0x820EB4E8;
		  /* 820EB4E8h */ case    7:  		/* lwz R11, <#[R27 + 8]> */
		/* 820EB4E8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820EB4E8h case    7:*/		return 0x820EB4EC;
		  /* 820EB4ECh */ case    8:  		/* li R5, 0 */
		/* 820EB4ECh case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EB4ECh case    8:*/		return 0x820EB4F0;
		  /* 820EB4F0h */ case    9:  		/* li R9, 0 */
		/* 820EB4F0h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820EB4F0h case    9:*/		return 0x820EB4F4;
		  /* 820EB4F4h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 820EB4F4h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EB4F4h case   10:*/		return 0x820EB4F8;
		  /* 820EB4F8h */ case   11:  		/* bc 4, CR6_GT, 100 */
		/* 820EB4F8h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820EB55C;  }
		/* 820EB4F8h case   11:*/		return 0x820EB4FC;
		  /* 820EB4FCh */ case   12:  		/* lwz R8, <#[R27 + 20]> */
		/* 820EB4FCh case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000014) );
		/* 820EB4FCh case   12:*/		return 0x820EB500;
		  /* 820EB500h */ case   13:  		/* li R10, 0 */
		/* 820EB500h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820EB500h case   13:*/		return 0x820EB504;
		  /* 820EB504h */ case   14:  		/* lwz R7, <#[R27 + 16]> */
		/* 820EB504h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R27 + 0x00000010) );
		/* 820EB504h case   14:*/		return 0x820EB508;
		  /* 820EB508h */ case   15:  		/* lwzx R11, <#[R10 + R8]> */
		/* 820EB508h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820EB508h case   15:*/		return 0x820EB50C;
		  /* 820EB50Ch */ case   16:  		/* lwz R6, <#[R11 + 4]> */
		/* 820EB50Ch case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 820EB50Ch case   16:*/		return 0x820EB510;
		  /* 820EB510h */ case   17:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820EB510h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820EB510h case   17:*/		return 0x820EB514;
		  /* 820EB514h */ case   18:  		/* lwzx R6, <#[R6 + R7]> */
		/* 820EB514h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 820EB514h case   18:*/		return 0x820EB518;
		  /* 820EB518h */ case   19:  		/* lwz R6, <#[R6 + 4]> */
		/* 820EB518h case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820EB518h case   19:*/		return 0x820EB51C;
		  /* 820EB51Ch */ case   20:  		/* rlwinm. R6, R6, 0, 23, 23 */
		/* 820EB51Ch case   20:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R6,regs.R6);
		/* 820EB51Ch case   20:*/		return 0x820EB520;
		  /* 820EB520h */ case   21:  		/* bc 12, CR0_EQ, 32 */
		/* 820EB520h case   21:*/		if ( regs.CR[0].eq ) { return 0x820EB540;  }
		/* 820EB520h case   21:*/		return 0x820EB524;
		  /* 820EB524h */ case   22:  		/* lfd FR0, <#[R11 + 32]> */
		/* 820EB524h case   22:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 820EB524h case   22:*/		return 0x820EB528;
		  /* 820EB528h */ case   23:  		/* fcmpu CR6, FR0, FR31 */
		/* 820EB528h case   23:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820EB528h case   23:*/		return 0x820EB52C;
		  /* 820EB52Ch */ case   24:  		/* bc 12, CR6_EQ, 44 */
		/* 820EB52Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x820EB558;  }
		/* 820EB52Ch case   24:*/		return 0x820EB530;
		  /* 820EB530h */ case   25:  		/* lwz R11, <#[R11 + 12]> */
		/* 820EB530h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820EB530h case   25:*/		return 0x820EB534;
		  /* 820EB534h */ case   26:  		/* cmplw CR6, R11, R5 */
		/* 820EB534h case   26:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 820EB534h case   26:*/		return 0x820EB538;
		  /* 820EB538h */ case   27:  		/* bc 12, CR6_LT, 8 */
		/* 820EB538h case   27:*/		if ( regs.CR[6].lt ) { return 0x820EB540;  }
		/* 820EB538h case   27:*/		return 0x820EB53C;
		  /* 820EB53Ch */ case   28:  		/* addi R5, R11, 1 */
		/* 820EB53Ch case   28:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 820EB53Ch case   28:*/		return 0x820EB540;
	}
	return 0x820EB540;
} // Block from 820EB4CCh-820EB540h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820EB540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB540);
		  /* 820EB540h */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 820EB540h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820EB540h case    0:*/		return 0x820EB544;
		  /* 820EB544h */ case    1:  		/* addi R9, R9, 1 */
		/* 820EB544h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820EB544h case    1:*/		return 0x820EB548;
		  /* 820EB548h */ case    2:  		/* addi R10, R10, 4 */
		/* 820EB548h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EB548h case    2:*/		return 0x820EB54C;
		  /* 820EB54Ch */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 820EB54Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820EB54Ch case    3:*/		return 0x820EB550;
		  /* 820EB550h */ case    4:  		/* bc 12, CR6_LT, -72 */
		/* 820EB550h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EB508;  }
		/* 820EB550h case    4:*/		return 0x820EB554;
		  /* 820EB554h */ case    5:  		/* b 8 */
		/* 820EB554h case    5:*/		return 0x820EB55C;
		/* 820EB554h case    5:*/		return 0x820EB558;
	}
	return 0x820EB558;
} // Block from 820EB540h-820EB558h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EB558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB558);
		  /* 820EB558h */ case    0:  		/* stw R9, <#[R27 + 396]> */
		/* 820EB558h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R27 + 0x0000018C) );
		/* 820EB558h case    0:*/		return 0x820EB55C;
	}
	return 0x820EB55C;
} // Block from 820EB558h-820EB55Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EB55Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB55C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB55C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB55C);
		  /* 820EB55Ch */ case    0:  		/* lwz R11, <#[R27 + 396]> */
		/* 820EB55Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000018C) );
		/* 820EB55Ch case    0:*/		return 0x820EB560;
		  /* 820EB560h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820EB560h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EB560h case    1:*/		return 0x820EB564;
		  /* 820EB564h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 820EB564h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820EB580;  }
		/* 820EB564h case    2:*/		return 0x820EB568;
		  /* 820EB568h */ case    3:  		/* li R6, 0 */
		/* 820EB568h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820EB568h case    3:*/		return 0x820EB56C;
		  /* 820EB56Ch */ case    4:  		/* lwz R4, <#[R27 + 120]> */
		/* 820EB56Ch case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000078) );
		/* 820EB56Ch case    4:*/		return 0x820EB570;
		  /* 820EB570h */ case    5:  		/* mr R3, R27 */
		/* 820EB570h case    5:*/		regs.R3 = regs.R27;
		/* 820EB570h case    5:*/		return 0x820EB574;
		  /* 820EB574h */ case    6:  		/* fmr FR1, FR31 */
		/* 820EB574h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820EB574h case    6:*/		return 0x820EB578;
		  /* 820EB578h */ case    7:  		/* bl 72880 */
		/* 820EB578h case    7:*/		regs.LR = 0x820EB57C; return 0x820FD228;
		/* 820EB578h case    7:*/		return 0x820EB57C;
		  /* 820EB57Ch */ case    8:  		/* stw R3, <#[R27 + 396]> */
		/* 820EB57Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x0000018C) );
		/* 820EB57Ch case    8:*/		return 0x820EB580;
	}
	return 0x820EB580;
} // Block from 820EB55Ch-820EB580h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820EB580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB580);
		  /* 820EB580h */ case    0:  		/* lwz R11, <#[R27 + 396]> */
		/* 820EB580h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000018C) );
		/* 820EB580h case    0:*/		return 0x820EB584;
		  /* 820EB584h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820EB584h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EB584h case    1:*/		return 0x820EB588;
		  /* 820EB588h */ case    2:  		/* bc 12, CR6_EQ, -336 */
		/* 820EB588h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EB438;  }
		/* 820EB588h case    2:*/		return 0x820EB58C;
		  /* 820EB58Ch */ case    3:  		/* lwz R10, <#[R31 + 8]> */
		/* 820EB58Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820EB58Ch case    3:*/		return 0x820EB590;
		  /* 820EB590h */ case    4:  		/* stw R11, <#[R10 + 4]> */
		/* 820EB590h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820EB590h case    4:*/		return 0x820EB594;
	}
	return 0x820EB594;
} // Block from 820EB580h-820EB594h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EB594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB594);
		  /* 820EB594h */ case    0:  		/* mr R3, R31 */
		/* 820EB594h case    0:*/		regs.R3 = regs.R31;
		/* 820EB594h case    0:*/		return 0x820EB598;
	}
	return 0x820EB598;
} // Block from 820EB594h-820EB598h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EB598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB598);
		  /* 820EB598h */ case    0:  		/* addi R1, R1, 176 */
		/* 820EB598h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820EB598h case    0:*/		return 0x820EB59C;
		  /* 820EB59Ch */ case    1:  		/* lfd FR31, <#[R1 - 96]> */
		/* 820EB59Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 820EB59Ch case    1:*/		return 0x820EB5A0;
		  /* 820EB5A0h */ case    2:  		/* b -369424 */
		/* 820EB5A0h case    2:*/		return 0x82091290;
		/* 820EB5A0h case    2:*/		return 0x820EB5A4;
		  /* 820EB5A4h */ case    3:  		/* nop */
		/* 820EB5A4h case    3:*/		cpu::op::nop();
		/* 820EB5A4h case    3:*/		return 0x820EB5A8;
	}
	return 0x820EB5A8;
} // Block from 820EB598h-820EB5A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EB5A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB5A8);
		  /* 820EB5A8h */ case    0:  		/* mfspr R12, LR */
		/* 820EB5A8h case    0:*/		regs.R12 = regs.LR;
		/* 820EB5A8h case    0:*/		return 0x820EB5AC;
		  /* 820EB5ACh */ case    1:  		/* bl -369508 */
		/* 820EB5ACh case    1:*/		regs.LR = 0x820EB5B0; return 0x82091248;
		/* 820EB5ACh case    1:*/		return 0x820EB5B0;
		  /* 820EB5B0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820EB5B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820EB5B0h case    2:*/		return 0x820EB5B4;
		  /* 820EB5B4h */ case    3:  		/* mr R29, R3 */
		/* 820EB5B4h case    3:*/		regs.R29 = regs.R3;
		/* 820EB5B4h case    3:*/		return 0x820EB5B8;
		  /* 820EB5B8h */ case    4:  		/* lwz R11, <#[R29 + 12]> */
		/* 820EB5B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 820EB5B8h case    4:*/		return 0x820EB5BC;
		  /* 820EB5BCh */ case    5:  		/* li R24, 0 */
		/* 820EB5BCh case    5:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820EB5BCh case    5:*/		return 0x820EB5C0;
		  /* 820EB5C0h */ case    6:  		/* li R27, 0 */
		/* 820EB5C0h case    6:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820EB5C0h case    6:*/		return 0x820EB5C4;
		  /* 820EB5C4h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820EB5C4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EB5C4h case    7:*/		return 0x820EB5C8;
		  /* 820EB5C8h */ case    8:  		/* bc 4, CR6_GT, 416 */
		/* 820EB5C8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820EB768;  }
		/* 820EB5C8h case    8:*/		return 0x820EB5CC;
		  /* 820EB5CCh */ case    9:  		/* li R25, 0 */
		/* 820EB5CCh case    9:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820EB5CCh case    9:*/		return 0x820EB5D0;
		  /* 820EB5D0h */ case   10:  		/* lwz R11, <#[R29 + 24]> */
		/* 820EB5D0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820EB5D0h case   10:*/		return 0x820EB5D4;
		  /* 820EB5D4h */ case   11:  		/* lwzx R3, <#[R25 + R11]> */
		/* 820EB5D4h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + regs.R11 + 0x00000000) );
		/* 820EB5D4h case   11:*/		return 0x820EB5D8;
		  /* 820EB5D8h */ case   12:  		/* bl 68672 */
		/* 820EB5D8h case   12:*/		regs.LR = 0x820EB5DC; return 0x820FC218;
		/* 820EB5D8h case   12:*/		return 0x820EB5DC;
		  /* 820EB5DCh */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820EB5DCh case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EB5DCh case   13:*/		return 0x820EB5E0;
		  /* 820EB5E0h */ case   14:  		/* bc 12, CR0_EQ, 364 */
		/* 820EB5E0h case   14:*/		if ( regs.CR[0].eq ) { return 0x820EB74C;  }
		/* 820EB5E0h case   14:*/		return 0x820EB5E4;
		  /* 820EB5E4h */ case   15:  		/* lwz R10, <#[R29 + 12]> */
		/* 820EB5E4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 820EB5E4h case   15:*/		return 0x820EB5E8;
		  /* 820EB5E8h */ case   16:  		/* addi R11, R27, 1 */
		/* 820EB5E8h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x1);
		/* 820EB5E8h case   16:*/		return 0x820EB5EC;
		  /* 820EB5ECh */ case   17:  		/* li R26, 1 */
		/* 820EB5ECh case   17:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 820EB5ECh case   17:*/		return 0x820EB5F0;
		  /* 820EB5F0h */ case   18:  		/* mr R28, R11 */
		/* 820EB5F0h case   18:*/		regs.R28 = regs.R11;
		/* 820EB5F0h case   18:*/		return 0x820EB5F4;
		  /* 820EB5F4h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820EB5F4h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EB5F4h case   19:*/		return 0x820EB5F8;
		  /* 820EB5F8h */ case   20:  		/* bc 4, CR6_LT, 260 */
		/* 820EB5F8h case   20:*/		if ( !regs.CR[6].lt ) { return 0x820EB6FC;  }
		/* 820EB5F8h case   20:*/		return 0x820EB5FC;
		  /* 820EB5FCh */ case   21:  		/* addi R30, R25, 4 */
		/* 820EB5FCh case   21:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R25,0x4);
		/* 820EB5FCh case   21:*/		return 0x820EB600;
		  /* 820EB600h */ case   22:  		/* lwz R11, <#[R29 + 24]> */
		/* 820EB600h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820EB600h case   22:*/		return 0x820EB604;
		  /* 820EB604h */ case   23:  		/* lwzx R31, <#[R30 + R11]> */
		/* 820EB604h case   23:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820EB604h case   23:*/		return 0x820EB608;
		  /* 820EB608h */ case   24:  		/* mr R3, R31 */
		/* 820EB608h case   24:*/		regs.R3 = regs.R31;
		/* 820EB608h case   24:*/		return 0x820EB60C;
		  /* 820EB60Ch */ case   25:  		/* bl 68716 */
		/* 820EB60Ch case   25:*/		regs.LR = 0x820EB610; return 0x820FC278;
		/* 820EB60Ch case   25:*/		return 0x820EB610;
		  /* 820EB610h */ case   26:  		/* cmpwi CR0, R3, 0 */
		/* 820EB610h case   26:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EB610h case   26:*/		return 0x820EB614;
		  /* 820EB614h */ case   27:  		/* bc 4, CR0_EQ, 224 */
		/* 820EB614h case   27:*/		if ( !regs.CR[0].eq ) { return 0x820EB6F4;  }
		/* 820EB614h case   27:*/		return 0x820EB618;
		  /* 820EB618h */ case   28:  		/* lwz R11, <#[R31]> */
		/* 820EB618h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EB618h case   28:*/		return 0x820EB61C;
		  /* 820EB61Ch */ case   29:  		/* lis R10, 4096 */
		/* 820EB61Ch case   29:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 820EB61Ch case   29:*/		return 0x820EB620;
		  /* 820EB620h */ case   30:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820EB620h case   30:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820EB620h case   30:*/		return 0x820EB624;
		  /* 820EB624h */ case   31:  		/* cmplw CR6, R11, R10 */
		/* 820EB624h case   31:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EB624h case   31:*/		return 0x820EB628;
		  /* 820EB628h */ case   32:  		/* bc 4, CR6_EQ, 200 */
		/* 820EB628h case   32:*/		if ( !regs.CR[6].eq ) { return 0x820EB6F0;  }
		/* 820EB628h case   32:*/		return 0x820EB62C;
		  /* 820EB62Ch */ case   33:  		/* lwz R4, <#[R31 + 12]> */
		/* 820EB62Ch case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 820EB62Ch case   33:*/		return 0x820EB630;
		  /* 820EB630h */ case   34:  		/* li R5, 0 */
		/* 820EB630h case   34:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EB630h case   34:*/		return 0x820EB634;
		  /* 820EB634h */ case   35:  		/* cmplwi CR6, R4, 0 */
		/* 820EB634h case   35:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820EB634h case   35:*/		return 0x820EB638;
		  /* 820EB638h */ case   36:  		/* bc 12, CR6_EQ, 160 */
		/* 820EB638h case   36:*/		if ( regs.CR[6].eq ) { return 0x820EB6D8;  }
		/* 820EB638h case   36:*/		return 0x820EB63C;
		  /* 820EB63Ch */ case   37:  		/* lwz R7, <#[R31 + 16]> */
		/* 820EB63Ch case   37:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 820EB63Ch case   37:*/		return 0x820EB640;
		  /* 820EB640h */ case   38:  		/* li R9, 0 */
		/* 820EB640h case   38:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820EB640h case   38:*/		return 0x820EB644;
		  /* 820EB644h */ case   39:  		/* lwz R6, <#[R31 + 8]> */
		/* 820EB644h case   39:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 820EB644h case   39:*/		return 0x820EB648;
		  /* 820EB648h */ case   40:  		/* lwz R8, <#[R29 + 20]> */
		/* 820EB648h case   40:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000014) );
		/* 820EB648h case   40:*/		return 0x820EB64C;
		  /* 820EB64Ch */ case   41:  		/* lwzx R11, <#[R9 + R7]> */
		/* 820EB64Ch case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820EB64Ch case   41:*/		return 0x820EB650;
		  /* 820EB650h */ case   42:  		/* lwzx R10, <#[R9 + R6]> */
		/* 820EB650h case   42:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 820EB650h case   42:*/		return 0x820EB654;
		  /* 820EB654h */ case   43:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EB654h case   43:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EB654h case   43:*/		return 0x820EB658;
		  /* 820EB658h */ case   44:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EB658h case   44:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EB658h case   44:*/		return 0x820EB65C;
		  /* 820EB65Ch */ case   45:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820EB65Ch case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820EB65Ch case   45:*/		return 0x820EB660;
		  /* 820EB660h */ case   46:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820EB660h case   46:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820EB660h case   46:*/		return 0x820EB664;
		  /* 820EB664h */ case   47:  		/* lwz R3, <#[R11 + 56]> */
		/* 820EB664h case   47:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000038) );
		/* 820EB664h case   47:*/		return 0x820EB668;
		  /* 820EB668h */ case   48:  		/* lwz R31, <#[R10 + 56]> */
		/* 820EB668h case   48:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000038) );
		/* 820EB668h case   48:*/		return 0x820EB66C;
		  /* 820EB66Ch */ case   49:  		/* cmplw CR6, R3, R31 */
		/* 820EB66Ch case   49:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R31);
		/* 820EB66Ch case   49:*/		return 0x820EB670;
		  /* 820EB670h */ case   50:  		/* bc 4, CR6_EQ, 84 */
		/* 820EB670h case   50:*/		if ( !regs.CR[6].eq ) { return 0x820EB6C4;  }
		/* 820EB670h case   50:*/		return 0x820EB674;
		  /* 820EB674h */ case   51:  		/* lwz R3, <#[R11 + 60]> */
		/* 820EB674h case   51:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000003C) );
		/* 820EB674h case   51:*/		return 0x820EB678;
		  /* 820EB678h */ case   52:  		/* lwz R31, <#[R10 + 60]> */
		/* 820EB678h case   52:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x0000003C) );
		/* 820EB678h case   52:*/		return 0x820EB67C;
		  /* 820EB67Ch */ case   53:  		/* cmplw CR6, R3, R31 */
		/* 820EB67Ch case   53:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R31);
		/* 820EB67Ch case   53:*/		return 0x820EB680;
		  /* 820EB680h */ case   54:  		/* bc 4, CR6_EQ, 68 */
		/* 820EB680h case   54:*/		if ( !regs.CR[6].eq ) { return 0x820EB6C4;  }
		/* 820EB680h case   54:*/		return 0x820EB684;
		  /* 820EB684h */ case   55:  		/* lwz R3, <#[R11 + 4]> */
		/* 820EB684h case   55:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 820EB684h case   55:*/		return 0x820EB688;
		  /* 820EB688h */ case   56:  		/* lwz R31, <#[R10 + 4]> */
		/* 820EB688h case   56:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 820EB688h case   56:*/		return 0x820EB68C;
		  /* 820EB68Ch */ case   57:  		/* cmplw CR6, R3, R31 */
		/* 820EB68Ch case   57:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R31);
		/* 820EB68Ch case   57:*/		return 0x820EB690;
		  /* 820EB690h */ case   58:  		/* bc 4, CR6_EQ, 52 */
		/* 820EB690h case   58:*/		if ( !regs.CR[6].eq ) { return 0x820EB6C4;  }
		/* 820EB690h case   58:*/		return 0x820EB694;
		  /* 820EB694h */ case   59:  		/* lwz R3, <#[R11 + 12]> */
		/* 820EB694h case   59:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 820EB694h case   59:*/		return 0x820EB698;
		  /* 820EB698h */ case   60:  		/* lwz R31, <#[R10 + 12]> */
		/* 820EB698h case   60:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x0000000C) );
		/* 820EB698h case   60:*/		return 0x820EB69C;
		  /* 820EB69Ch */ case   61:  		/* cmplw CR6, R3, R31 */
		/* 820EB69Ch case   61:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R31);
		/* 820EB69Ch case   61:*/		return 0x820EB6A0;
		  /* 820EB6A0h */ case   62:  		/* bc 4, CR6_EQ, 36 */
		/* 820EB6A0h case   62:*/		if ( !regs.CR[6].eq ) { return 0x820EB6C4;  }
		/* 820EB6A0h case   62:*/		return 0x820EB6A4;
		  /* 820EB6A4h */ case   63:  		/* lwz R3, <#[R11 + 8]> */
		/* 820EB6A4h case   63:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000008) );
		/* 820EB6A4h case   63:*/		return 0x820EB6A8;
		  /* 820EB6A8h */ case   64:  		/* lwz R31, <#[R10 + 8]> */
		/* 820EB6A8h case   64:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000008) );
		/* 820EB6A8h case   64:*/		return 0x820EB6AC;
		  /* 820EB6ACh */ case   65:  		/* cmplw CR6, R3, R31 */
		/* 820EB6ACh case   65:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R31);
		/* 820EB6ACh case   65:*/		return 0x820EB6B0;
		  /* 820EB6B0h */ case   66:  		/* bc 4, CR6_EQ, 20 */
		/* 820EB6B0h case   66:*/		if ( !regs.CR[6].eq ) { return 0x820EB6C4;  }
		/* 820EB6B0h case   66:*/		return 0x820EB6B4;
		  /* 820EB6B4h */ case   67:  		/* lwz R11, <#[R11 + 16]> */
		/* 820EB6B4h case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820EB6B4h case   67:*/		return 0x820EB6B8;
		  /* 820EB6B8h */ case   68:  		/* lwz R10, <#[R10 + 16]> */
		/* 820EB6B8h case   68:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820EB6B8h case   68:*/		return 0x820EB6BC;
		  /* 820EB6BCh */ case   69:  		/* cmplw CR6, R11, R10 */
		/* 820EB6BCh case   69:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EB6BCh case   69:*/		return 0x820EB6C0;
		  /* 820EB6C0h */ case   70:  		/* bc 12, CR6_EQ, 8 */
		/* 820EB6C0h case   70:*/		if ( regs.CR[6].eq ) { return 0x820EB6C8;  }
		/* 820EB6C0h case   70:*/		return 0x820EB6C4;
	}
	return 0x820EB6C4;
} // Block from 820EB5A8h-820EB6C4h (71 instructions)

//////////////////////////////////////////////////////
// Block at 820EB6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB6C4);
		  /* 820EB6C4h */ case    0:  		/* li R26, 0 */
		/* 820EB6C4h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820EB6C4h case    0:*/		return 0x820EB6C8;
	}
	return 0x820EB6C8;
} // Block from 820EB6C4h-820EB6C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EB6C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB6C8);
		  /* 820EB6C8h */ case    0:  		/* addi R5, R5, 1 */
		/* 820EB6C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820EB6C8h case    0:*/		return 0x820EB6CC;
		  /* 820EB6CCh */ case    1:  		/* addi R9, R9, 4 */
		/* 820EB6CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820EB6CCh case    1:*/		return 0x820EB6D0;
		  /* 820EB6D0h */ case    2:  		/* cmplw CR6, R5, R4 */
		/* 820EB6D0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 820EB6D0h case    2:*/		return 0x820EB6D4;
		  /* 820EB6D4h */ case    3:  		/* bc 12, CR6_LT, -136 */
		/* 820EB6D4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EB64C;  }
		/* 820EB6D4h case    3:*/		return 0x820EB6D8;
	}
	return 0x820EB6D8;
} // Block from 820EB6C8h-820EB6D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EB6D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB6D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB6D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB6D8);
		  /* 820EB6D8h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 820EB6D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 820EB6D8h case    0:*/		return 0x820EB6DC;
		  /* 820EB6DCh */ case    1:  		/* addi R28, R28, 1 */
		/* 820EB6DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820EB6DCh case    1:*/		return 0x820EB6E0;
		  /* 820EB6E0h */ case    2:  		/* addi R30, R30, 4 */
		/* 820EB6E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820EB6E0h case    2:*/		return 0x820EB6E4;
		  /* 820EB6E4h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 820EB6E4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820EB6E4h case    3:*/		return 0x820EB6E8;
		  /* 820EB6E8h */ case    4:  		/* bc 12, CR6_LT, -232 */
		/* 820EB6E8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EB600;  }
		/* 820EB6E8h case    4:*/		return 0x820EB6EC;
		  /* 820EB6ECh */ case    5:  		/* b 8 */
		/* 820EB6ECh case    5:*/		return 0x820EB6F4;
		/* 820EB6ECh case    5:*/		return 0x820EB6F0;
	}
	return 0x820EB6F0;
} // Block from 820EB6D8h-820EB6F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EB6F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB6F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB6F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB6F0);
		  /* 820EB6F0h */ case    0:  		/* li R26, 0 */
		/* 820EB6F0h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820EB6F0h case    0:*/		return 0x820EB6F4;
	}
	return 0x820EB6F4;
} // Block from 820EB6F0h-820EB6F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EB6F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB6F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB6F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB6F4);
		  /* 820EB6F4h */ case    0:  		/* cmpwi CR6, R26, 0 */
		/* 820EB6F4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 820EB6F4h case    0:*/		return 0x820EB6F8;
		  /* 820EB6F8h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 820EB6F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EB74C;  }
		/* 820EB6F8h case    1:*/		return 0x820EB6FC;
	}
	return 0x820EB6FC;
} // Block from 820EB6F4h-820EB6FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EB6FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB6FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB6FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB6FC);
		  /* 820EB6FCh */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 820EB6FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 820EB6FCh case    0:*/		return 0x820EB700;
		  /* 820EB700h */ case    1:  		/* li R24, 1 */
		/* 820EB700h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 820EB700h case    1:*/		return 0x820EB704;
		  /* 820EB704h */ case    2:  		/* mr R30, R27 */
		/* 820EB704h case    2:*/		regs.R30 = regs.R27;
		/* 820EB704h case    2:*/		return 0x820EB708;
		  /* 820EB708h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 820EB708h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820EB708h case    3:*/		return 0x820EB70C;
		  /* 820EB70Ch */ case    4:  		/* bc 4, CR6_LT, 64 */
		/* 820EB70Ch case    4:*/		if ( !regs.CR[6].lt ) { return 0x820EB74C;  }
		/* 820EB70Ch case    4:*/		return 0x820EB710;
		  /* 820EB710h */ case    5:  		/* mr R31, R25 */
		/* 820EB710h case    5:*/		regs.R31 = regs.R25;
		/* 820EB710h case    5:*/		return 0x820EB714;
		  /* 820EB714h */ case    6:  		/* lwz R11, <#[R29 + 24]> */
		/* 820EB714h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820EB714h case    6:*/		return 0x820EB718;
		  /* 820EB718h */ case    7:  		/* lwzx R3, <#[R31 + R11]> */
		/* 820EB718h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820EB718h case    7:*/		return 0x820EB71C;
		  /* 820EB71Ch */ case    8:  		/* bl 68444 */
		/* 820EB71Ch case    8:*/		regs.LR = 0x820EB720; return 0x820FC278;
		/* 820EB71Ch case    8:*/		return 0x820EB720;
		  /* 820EB720h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820EB720h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EB720h case    9:*/		return 0x820EB724;
		  /* 820EB724h */ case   10:  		/* bc 4, CR0_EQ, 40 */
		/* 820EB724h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820EB74C;  }
		/* 820EB724h case   10:*/		return 0x820EB728;
		  /* 820EB728h */ case   11:  		/* lwz R11, <#[R29 + 24]> */
		/* 820EB728h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820EB728h case   11:*/		return 0x820EB72C;
		  /* 820EB72Ch */ case   12:  		/* li R10, 0 */
		/* 820EB72Ch case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820EB72Ch case   12:*/		return 0x820EB730;
		  /* 820EB730h */ case   13:  		/* addi R30, R30, 1 */
		/* 820EB730h case   13:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820EB730h case   13:*/		return 0x820EB734;
		  /* 820EB734h */ case   14:  		/* lwzx R11, <#[R31 + R11]> */
		/* 820EB734h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820EB734h case   14:*/		return 0x820EB738;
		  /* 820EB738h */ case   15:  		/* addi R31, R31, 4 */
		/* 820EB738h case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820EB738h case   15:*/		return 0x820EB73C;
		  /* 820EB73Ch */ case   16:  		/* stw R10, <#[R11]> */
		/* 820EB73Ch case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820EB73Ch case   16:*/		return 0x820EB740;
		  /* 820EB740h */ case   17:  		/* lwz R11, <#[R29 + 12]> */
		/* 820EB740h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 820EB740h case   17:*/		return 0x820EB744;
		  /* 820EB744h */ case   18:  		/* cmplw CR6, R30, R11 */
		/* 820EB744h case   18:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820EB744h case   18:*/		return 0x820EB748;
		  /* 820EB748h */ case   19:  		/* bc 12, CR6_LT, -52 */
		/* 820EB748h case   19:*/		if ( regs.CR[6].lt ) { return 0x820EB714;  }
		/* 820EB748h case   19:*/		return 0x820EB74C;
	}
	return 0x820EB74C;
} // Block from 820EB6FCh-820EB74Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820EB74Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB74C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB74C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB74C);
		  /* 820EB74Ch */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 820EB74Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 820EB74Ch case    0:*/		return 0x820EB750;
		  /* 820EB750h */ case    1:  		/* addi R27, R27, 1 */
		/* 820EB750h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820EB750h case    1:*/		return 0x820EB754;
		  /* 820EB754h */ case    2:  		/* addi R25, R25, 4 */
		/* 820EB754h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 820EB754h case    2:*/		return 0x820EB758;
		  /* 820EB758h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 820EB758h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820EB758h case    3:*/		return 0x820EB75C;
		  /* 820EB75Ch */ case    4:  		/* bc 12, CR6_LT, -396 */
		/* 820EB75Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820EB5D0;  }
		/* 820EB75Ch case    4:*/		return 0x820EB760;
		  /* 820EB760h */ case    5:  		/* cmpwi CR6, R24, 0 */
		/* 820EB760h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 820EB760h case    5:*/		return 0x820EB764;
		  /* 820EB764h */ case    6:  		/* bc 4, CR6_EQ, -428 */
		/* 820EB764h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820EB5B8;  }
		/* 820EB764h case    6:*/		return 0x820EB768;
	}
	return 0x820EB768;
} // Block from 820EB74Ch-820EB768h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EB768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB768);
		  /* 820EB768h */ case    0:  		/* li R3, 0 */
		/* 820EB768h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EB768h case    0:*/		return 0x820EB76C;
		  /* 820EB76Ch */ case    1:  		/* addi R1, R1, 160 */
		/* 820EB76Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820EB76Ch case    1:*/		return 0x820EB770;
		  /* 820EB770h */ case    2:  		/* b -369880 */
		/* 820EB770h case    2:*/		return 0x82091298;
		/* 820EB770h case    2:*/		return 0x820EB774;
		  /* 820EB774h */ case    3:  		/* nop */
		/* 820EB774h case    3:*/		cpu::op::nop();
		/* 820EB774h case    3:*/		return 0x820EB778;
	}
	return 0x820EB778;
} // Block from 820EB768h-820EB778h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EB778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB778);
		  /* 820EB778h */ case    0:  		/* mfspr R12, LR */
		/* 820EB778h case    0:*/		regs.R12 = regs.LR;
		/* 820EB778h case    0:*/		return 0x820EB77C;
		  /* 820EB77Ch */ case    1:  		/* bl -370012 */
		/* 820EB77Ch case    1:*/		regs.LR = 0x820EB780; return 0x82091220;
		/* 820EB77Ch case    1:*/		return 0x820EB780;
		  /* 820EB780h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 820EB780h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820EB780h case    2:*/		return 0x820EB784;
		  /* 820EB784h */ case    3:  		/* stwu R1, <#[R1 - 2352]> */
		/* 820EB784h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF6D0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF6D0);
		/* 820EB784h case    3:*/		return 0x820EB788;
		  /* 820EB788h */ case    4:  		/* lwz R22, <#[R6]> */
		/* 820EB788h case    4:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R6 + 0x00000000) );
		/* 820EB788h case    4:*/		return 0x820EB78C;
		  /* 820EB78Ch */ case    5:  		/* mr R24, R3 */
		/* 820EB78Ch case    5:*/		regs.R24 = regs.R3;
		/* 820EB78Ch case    5:*/		return 0x820EB790;
		  /* 820EB790h */ case    6:  		/* mr R14, R4 */
		/* 820EB790h case    6:*/		regs.R14 = regs.R4;
		/* 820EB790h case    6:*/		return 0x820EB794;
		  /* 820EB794h */ case    7:  		/* stw R6, <#[R1 + 2396]> */
		/* 820EB794h case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000095C) );
		/* 820EB794h case    7:*/		return 0x820EB798;
		  /* 820EB798h */ case    8:  		/* mr R18, R5 */
		/* 820EB798h case    8:*/		regs.R18 = regs.R5;
		/* 820EB798h case    8:*/		return 0x820EB79C;
		  /* 820EB79Ch */ case    9:  		/* mr R25, R6 */
		/* 820EB79Ch case    9:*/		regs.R25 = regs.R6;
		/* 820EB79Ch case    9:*/		return 0x820EB7A0;
	}
	return 0x820EB7A0;
} // Block from 820EB778h-820EB7A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EB7A0h
// Function '?Reschedule_Exchange@CShaderProgram@D3DXShader@@AAAJII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB7A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB7A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB7A0);
		  /* 820EB7A0h */ case    0:  		/* mr R17, R7 */
		/* 820EB7A0h case    0:*/		regs.R17 = regs.R7;
		/* 820EB7A0h case    0:*/		return 0x820EB7A4;
		  /* 820EB7A4h */ case    1:  		/* mr R16, R8 */
		/* 820EB7A4h case    1:*/		regs.R16 = regs.R8;
		/* 820EB7A4h case    1:*/		return 0x820EB7A8;
		  /* 820EB7A8h */ case    2:  		/* mr R20, R9 */
		/* 820EB7A8h case    2:*/		regs.R20 = regs.R9;
		/* 820EB7A8h case    2:*/		return 0x820EB7AC;
		  /* 820EB7ACh */ case    3:  		/* mr R19, R10 */
		/* 820EB7ACh case    3:*/		regs.R19 = regs.R10;
		/* 820EB7ACh case    3:*/		return 0x820EB7B0;
		  /* 820EB7B0h */ case    4:  		/* cmplw CR6, R22, R10 */
		/* 820EB7B0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R10);
		/* 820EB7B0h case    4:*/		return 0x820EB7B4;
		  /* 820EB7B4h */ case    5:  		/* bc 4, CR6_LT, 3168 */
		/* 820EB7B4h case    5:*/		if ( !regs.CR[6].lt ) { return 0x820EC414;  }
		/* 820EB7B4h case    5:*/		return 0x820EB7B8;
		  /* 820EB7B8h */ case    6:  		/* lis R11, -32256 */
		/* 820EB7B8h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820EB7B8h case    6:*/		return 0x820EB7BC;
		  /* 820EB7BCh */ case    7:  		/* li R21, 0 */
		/* 820EB7BCh case    7:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 820EB7BCh case    7:*/		return 0x820EB7C0;
		  /* 820EB7C0h */ case    8:  		/* li R15, 1 */
		/* 820EB7C0h case    8:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 820EB7C0h case    8:*/		return 0x820EB7C4;
		  /* 820EB7C4h */ case    9:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 820EB7C4h case    9:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 820EB7C4h case    9:*/		return 0x820EB7C8;
		  /* 820EB7C8h */ case   10:  		/* lwz R11, <#[R24 + 24]> */
		/* 820EB7C8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000018) );
		/* 820EB7C8h case   10:*/		return 0x820EB7CC;
		  /* 820EB7CCh */ case   11:  		/* rlwinm R8, R22, 2, 0, 29 */
		/* 820EB7CCh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R22);
		/* 820EB7CCh case   11:*/		return 0x820EB7D0;
		  /* 820EB7D0h */ case   12:  		/* lwz R10, <#[R1 + 2436]> */
		/* 820EB7D0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000984) );
		/* 820EB7D0h case   12:*/		return 0x820EB7D4;
		  /* 820EB7D4h */ case   13:  		/* lwz R9, <#[R1 + 2444]> */
		/* 820EB7D4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000098C) );
		/* 820EB7D4h case   13:*/		return 0x820EB7D8;
		  /* 820EB7D8h */ case   14:  		/* lwzx R26, <#[R8 + R11]> */
		/* 820EB7D8h case   14:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820EB7D8h case   14:*/		return 0x820EB7DC;
		  /* 820EB7DCh */ case   15:  		/* lwz R11, <#[R26]> */
		/* 820EB7DCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820EB7DCh case   15:*/		return 0x820EB7E0;
		  /* 820EB7E0h */ case   16:  		/* lwz R5, <#[R26 + 12]> */
		/* 820EB7E0h case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x0000000C) );
		/* 820EB7E0h case   16:*/		return 0x820EB7E4;
		  /* 820EB7E4h */ case   17:  		/* rlwinm R28, R11, 0, 0, 11 */
		/* 820EB7E4h case   17:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R28,regs.R11);
		/* 820EB7E4h case   17:*/		return 0x820EB7E8;
		  /* 820EB7E8h */ case   18:  		/* rlwinm R23, R11, 0, 12, 31 */
		/* 820EB7E8h case   18:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R23,regs.R11);
		/* 820EB7E8h case   18:*/		return 0x820EB7EC;
		  /* 820EB7ECh */ case   19:  		/* cmplwi CR6, R5, 0 */
		/* 820EB7ECh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820EB7ECh case   19:*/		return 0x820EB7F0;
		  /* 820EB7F0h */ case   20:  		/* bc 12, CR6_EQ, 2896 */
		/* 820EB7F0h case   20:*/		if ( regs.CR[6].eq ) { return 0x820EC340;  }
		/* 820EB7F0h case   20:*/		return 0x820EB7F4;
		  /* 820EB7F4h */ case   21:  		/* lwz R31, <#[R26 + 16]> */
		/* 820EB7F4h case   21:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000010) );
		/* 820EB7F4h case   21:*/		return 0x820EB7F8;
		  /* 820EB7F8h */ case   22:  		/* lwz R11, <#[R24 + 20]> */
		/* 820EB7F8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 820EB7F8h case   22:*/		return 0x820EB7FC;
		  /* 820EB7FCh */ case   23:  		/* lwz R8, <#[R31]> */
		/* 820EB7FCh case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 820EB7FCh case   23:*/		return 0x820EB800;
		  /* 820EB800h */ case   24:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820EB800h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820EB800h case   24:*/		return 0x820EB804;
		  /* 820EB804h */ case   25:  		/* lwzx R27, <#[R8 + R11]> */
		/* 820EB804h case   25:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820EB804h case   25:*/		return 0x820EB808;
		  /* 820EB808h */ case   26:  		/* lwz R11, <#[R27 + 20]> */
		/* 820EB808h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 820EB808h case   26:*/		return 0x820EB80C;
		  /* 820EB80Ch */ case   27:  		/* cmplw CR6, R11, R14 */
		/* 820EB80Ch case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 820EB80Ch case   27:*/		return 0x820EB810;
		  /* 820EB810h */ case   28:  		/* bc 4, CR6_EQ, 2004 */
		/* 820EB810h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820EBFE4;  }
		/* 820EB810h case   28:*/		return 0x820EB814;
		  /* 820EB814h */ case   29:  		/* cmpwi CR6, R9, 0 */
		/* 820EB814h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820EB814h case   29:*/		return 0x820EB818;
		  /* 820EB818h */ case   30:  		/* bc 12, CR6_EQ, 16 */
		/* 820EB818h case   30:*/		if ( regs.CR[6].eq ) { return 0x820EB828;  }
		/* 820EB818h case   30:*/		return 0x820EB81C;
		  /* 820EB81Ch */ case   31:  		/* lis R11, 4384 */
		/* 820EB81Ch case   31:*/		cpu::op::lis<0>(regs,&regs.R11,0x1120);
		/* 820EB81Ch case   31:*/		return 0x820EB820;
	}
	return 0x820EB820;
} // Block from 820EB7A0h-820EB820h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820EB820h
// Function '?IsIf@D3DXShader@@YAHI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB820);
		  /* 820EB820h */ case    0:  		/* cmplw CR6, R28, R11 */
		/* 820EB820h case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820EB820h case    0:*/		return 0x820EB824;
		  /* 820EB824h */ case    1:  		/* bc 4, CR6_EQ, 2828 */
		/* 820EB824h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EC330;  }
		/* 820EB824h case    1:*/		return 0x820EB828;
	}
	return 0x820EB828;
} // Block from 820EB820h-820EB828h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EB828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB828);
		  /* 820EB828h */ case    0:  		/* mr R29, R10 */
		/* 820EB828h case    0:*/		regs.R29 = regs.R10;
		/* 820EB828h case    0:*/		return 0x820EB82C;
		  /* 820EB82Ch */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 820EB82Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820EB82Ch case    1:*/		return 0x820EB830;
		  /* 820EB830h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820EB830h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EB848;  }
		/* 820EB830h case    2:*/		return 0x820EB834;
		  /* 820EB834h */ case    3:  		/* lwz R11, <#[R27 + 24]> */
		/* 820EB834h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 820EB834h case    3:*/		return 0x820EB838;
		  /* 820EB838h */ case    4:  		/* subf R11, R11, R18 */
		/* 820EB838h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R18);
		/* 820EB838h case    4:*/		return 0x820EB83C;
		  /* 820EB83Ch */ case    5:  		/* addic R11, R11, -1 */
		/* 820EB83Ch case    5:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820EB83Ch case    5:*/		return 0x820EB840;
		  /* 820EB840h */ case    6:  		/* subfe R11, R11, R11 */
		/* 820EB840h case    6:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820EB840h case    6:*/		return 0x820EB844;
		  /* 820EB844h */ case    7:  		/* and R29, R11, R29 */
		/* 820EB844h case    7:*/		cpu::op::and<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 820EB844h case    7:*/		return 0x820EB848;
	}
	return 0x820EB848;
} // Block from 820EB828h-820EB848h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EB848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB848);
		  /* 820EB848h */ case    0:  		/* mr R3, R28 */
		/* 820EB848h case    0:*/		regs.R3 = regs.R28;
		/* 820EB848h case    0:*/		return 0x820EB84C;
		  /* 820EB84Ch */ case    1:  		/* bl -1996 */
		/* 820EB84Ch case    1:*/		regs.LR = 0x820EB850; return 0x820EB080;
		/* 820EB84Ch case    1:*/		return 0x820EB850;
		  /* 820EB850h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820EB850h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EB850h case    2:*/		return 0x820EB854;
		  /* 820EB854h */ case    3:  		/* bc 12, CR0_EQ, 548 */
		/* 820EB854h case    3:*/		if ( regs.CR[0].eq ) { return 0x820EBA78;  }
		/* 820EB854h case    3:*/		return 0x820EB858;
		  /* 820EB858h */ case    4:  		/* cmplwi CR6, R23, 1 */
		/* 820EB858h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000001);
		/* 820EB858h case    4:*/		return 0x820EB85C;
		  /* 820EB85Ch */ case    5:  		/* bc 4, CR6_EQ, 2824 */
		/* 820EB85Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820EC364;  }
		/* 820EB85Ch case    5:*/		return 0x820EB860;
		  /* 820EB860h */ case    6:  		/* cmpwi CR6, R29, 0 */
		/* 820EB860h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820EB860h case    6:*/		return 0x820EB864;
		  /* 820EB864h */ case    7:  		/* bc 12, CR6_EQ, 44 */
		/* 820EB864h case    7:*/		if ( regs.CR[6].eq ) { return 0x820EB890;  }
		/* 820EB864h case    7:*/		return 0x820EB868;
	}
	return 0x820EB868;
} // Block from 820EB848h-820EB868h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EB868h
// Function '?IsBreak@D3DXShader@@YAHI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB868);
		  /* 820EB868h */ case    0:  		/* li R5, 1 */
		/* 820EB868h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820EB868h case    0:*/		return 0x820EB86C;
		  /* 820EB86Ch */ case    1:  		/* mr R4, R26 */
		/* 820EB86Ch case    1:*/		regs.R4 = regs.R26;
		/* 820EB86Ch case    1:*/		return 0x820EB870;
		  /* 820EB870h */ case    2:  		/* mr R3, R24 */
		/* 820EB870h case    2:*/		regs.R3 = regs.R24;
		/* 820EB870h case    2:*/		return 0x820EB874;
		  /* 820EB874h */ case    3:  		/* bl -1892 */
		/* 820EB874h case    3:*/		regs.LR = 0x820EB878; return 0x820EB110;
		/* 820EB874h case    3:*/		return 0x820EB878;
		  /* 820EB878h */ case    4:  		/* or. R4, R3, R3 */
		/* 820EB878h case    4:*/		cpu::op::or<1>(regs,&regs.R4,regs.R3,regs.R3);
		/* 820EB878h case    4:*/		return 0x820EB87C;
		  /* 820EB87Ch */ case    5:  		/* bc 12, CR0_EQ, 2808 */
		/* 820EB87Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820EC374;  }
		/* 820EB87Ch case    5:*/		return 0x820EB880;
		  /* 820EB880h */ case    6:  		/* mr R3, R24 */
		/* 820EB880h case    6:*/		regs.R3 = regs.R24;
		/* 820EB880h case    6:*/		return 0x820EB884;
		  /* 820EB884h */ case    7:  		/* bl 71732 */
		/* 820EB884h case    7:*/		regs.LR = 0x820EB888; return 0x820FD0B8;
		/* 820EB884h case    7:*/		return 0x820EB888;
		  /* 820EB888h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820EB888h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EB888h case    8:*/		return 0x820EB88C;
		  /* 820EB88Ch */ case    9:  		/* bc 12, CR0_LT, 2956 */
		/* 820EB88Ch case    9:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EB88Ch case    9:*/		return 0x820EB890;
	}
	return 0x820EB890;
} // Block from 820EB868h-820EB890h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EB890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB890);
		  /* 820EB890h */ case    0:  		/* stw R21, <#[R1 + 128]> */
		/* 820EB890h case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000080) );
		/* 820EB890h case    0:*/		return 0x820EB894;
		  /* 820EB894h */ case    1:  		/* addi R31, R22, 1 */
		/* 820EB894h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R22,0x1);
		/* 820EB894h case    1:*/		return 0x820EB898;
		  /* 820EB898h */ case    2:  		/* stw R21, <#[R1 + 112]> */
		/* 820EB898h case    2:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000070) );
		/* 820EB898h case    2:*/		return 0x820EB89C;
		  /* 820EB89Ch */ case    3:  		/* mr R10, R19 */
		/* 820EB89Ch case    3:*/		regs.R10 = regs.R19;
		/* 820EB89Ch case    3:*/		return 0x820EB8A0;
		  /* 820EB8A0h */ case    4:  		/* lwz R11, <#[R26 + 16]> */
		/* 820EB8A0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820EB8A0h case    4:*/		return 0x820EB8A4;
		  /* 820EB8A4h */ case    5:  		/* addi R9, R1, 112 */
		/* 820EB8A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820EB8A4h case    5:*/		return 0x820EB8A8;
		  /* 820EB8A8h */ case    6:  		/* stw R31, <#[R1 + 116]> */
		/* 820EB8A8h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000074) );
		/* 820EB8A8h case    6:*/		return 0x820EB8AC;
		  /* 820EB8ACh */ case    7:  		/* addi R8, R1, 656 */
		/* 820EB8ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x290);
		/* 820EB8ACh case    7:*/		return 0x820EB8B0;
	}
	return 0x820EB8B0;
} // Block from 820EB890h-820EB8B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EB8B0h
// Function '?NewAndIf@CShaderProgram@D3DXShader@@IAAPAVCInstruction@2@PAV32@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB8B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB8B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB8B0);
		  /* 820EB8B0h */ case    0:  		/* addi R7, R1, 144 */
		/* 820EB8B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x90);
		/* 820EB8B0h case    0:*/		return 0x820EB8B4;
		  /* 820EB8B4h */ case    1:  		/* stw R29, <#[R1 + 84]> */
		/* 820EB8B4h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 820EB8B4h case    1:*/		return 0x820EB8B8;
		  /* 820EB8B8h */ case    2:  		/* addi R6, R1, 116 */
		/* 820EB8B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x74);
		/* 820EB8B8h case    2:*/		return 0x820EB8BC;
		  /* 820EB8BCh */ case    3:  		/* stw R21, <#[R1 + 108]> */
		/* 820EB8BCh case    3:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000006C) );
		/* 820EB8BCh case    3:*/		return 0x820EB8C0;
		  /* 820EB8C0h */ case    4:  		/* li R5, 1 */
		/* 820EB8C0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820EB8C0h case    4:*/		return 0x820EB8C4;
		  /* 820EB8C4h */ case    5:  		/* stw R21, <#[R1 + 100]> */
		/* 820EB8C4h case    5:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 820EB8C4h case    5:*/		return 0x820EB8C8;
		  /* 820EB8C8h */ case    6:  		/* mr R3, R24 */
		/* 820EB8C8h case    6:*/		regs.R3 = regs.R24;
		/* 820EB8C8h case    6:*/		return 0x820EB8CC;
		  /* 820EB8CCh */ case    7:  		/* stw R21, <#[R1 + 92]> */
		/* 820EB8CCh case    7:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000005C) );
		/* 820EB8CCh case    7:*/		return 0x820EB8D0;
		  /* 820EB8D0h */ case    8:  		/* lwz R4, <#[R11]> */
		/* 820EB8D0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820EB8D0h case    8:*/		return 0x820EB8D4;
		  /* 820EB8D4h */ case    9:  		/* bl -348 */
		/* 820EB8D4h case    9:*/		regs.LR = 0x820EB8D8; return 0x820EB778;
		/* 820EB8D4h case    9:*/		return 0x820EB8D8;
		  /* 820EB8D8h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820EB8D8h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EB8D8h case   10:*/		return 0x820EB8DC;
		  /* 820EB8DCh */ case   11:  		/* bc 12, CR0_LT, 2876 */
		/* 820EB8DCh case   11:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EB8DCh case   11:*/		return 0x820EB8E0;
		  /* 820EB8E0h */ case   12:  		/* cmpwi CR6, R29, 0 */
		/* 820EB8E0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820EB8E0h case   12:*/		return 0x820EB8E4;
		  /* 820EB8E4h */ case   13:  		/* bc 12, CR6_EQ, 44 */
		/* 820EB8E4h case   13:*/		if ( regs.CR[6].eq ) { return 0x820EB910;  }
		/* 820EB8E4h case   13:*/		return 0x820EB8E8;
		  /* 820EB8E8h */ case   14:  		/* li R5, 0 */
		/* 820EB8E8h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EB8E8h case   14:*/		return 0x820EB8EC;
		  /* 820EB8ECh */ case   15:  		/* mr R4, R26 */
		/* 820EB8ECh case   15:*/		regs.R4 = regs.R26;
		/* 820EB8ECh case   15:*/		return 0x820EB8F0;
		  /* 820EB8F0h */ case   16:  		/* mr R3, R24 */
		/* 820EB8F0h case   16:*/		regs.R3 = regs.R24;
		/* 820EB8F0h case   16:*/		return 0x820EB8F4;
		  /* 820EB8F4h */ case   17:  		/* bl -2020 */
		/* 820EB8F4h case   17:*/		regs.LR = 0x820EB8F8; return 0x820EB110;
		/* 820EB8F4h case   17:*/		return 0x820EB8F8;
		  /* 820EB8F8h */ case   18:  		/* or. R4, R3, R3 */
		/* 820EB8F8h case   18:*/		cpu::op::or<1>(regs,&regs.R4,regs.R3,regs.R3);
		/* 820EB8F8h case   18:*/		return 0x820EB8FC;
		  /* 820EB8FCh */ case   19:  		/* bc 12, CR0_EQ, 2680 */
		/* 820EB8FCh case   19:*/		if ( regs.CR[0].eq ) { return 0x820EC374;  }
		/* 820EB8FCh case   19:*/		return 0x820EB900;
		  /* 820EB900h */ case   20:  		/* mr R3, R24 */
		/* 820EB900h case   20:*/		regs.R3 = regs.R24;
		/* 820EB900h case   20:*/		return 0x820EB904;
		  /* 820EB904h */ case   21:  		/* bl 71604 */
		/* 820EB904h case   21:*/		regs.LR = 0x820EB908; return 0x820FD0B8;
		/* 820EB904h case   21:*/		return 0x820EB908;
		  /* 820EB908h */ case   22:  		/* cmpwi CR0, R3, 0 */
		/* 820EB908h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EB908h case   22:*/		return 0x820EB90C;
		  /* 820EB90Ch */ case   23:  		/* bc 12, CR0_LT, 2828 */
		/* 820EB90Ch case   23:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EB90Ch case   23:*/		return 0x820EB910;
	}
	return 0x820EB910;
} // Block from 820EB8B0h-820EB910h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820EB910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB910);
		  /* 820EB910h */ case    0:  		/* lwz R11, <#[R26 + 16]> */
		/* 820EB910h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820EB910h case    0:*/		return 0x820EB914;
		  /* 820EB914h */ case    1:  		/* mr R10, R19 */
		/* 820EB914h case    1:*/		regs.R10 = regs.R19;
		/* 820EB914h case    1:*/		return 0x820EB918;
		  /* 820EB918h */ case    2:  		/* stw R31, <#[R1 + 116]> */
		/* 820EB918h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000074) );
		/* 820EB918h case    2:*/		return 0x820EB91C;
		  /* 820EB91Ch */ case    3:  		/* addi R9, R1, 128 */
		/* 820EB91Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 820EB91Ch case    3:*/		return 0x820EB920;
		  /* 820EB920h */ case    4:  		/* stw R21, <#[R1 + 108]> */
		/* 820EB920h case    4:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000006C) );
		/* 820EB920h case    4:*/		return 0x820EB924;
		  /* 820EB924h */ case    5:  		/* addi R8, R1, 1168 */
		/* 820EB924h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x490);
		/* 820EB924h case    5:*/		return 0x820EB928;
		  /* 820EB928h */ case    6:  		/* stw R21, <#[R1 + 100]> */
		/* 820EB928h case    6:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 820EB928h case    6:*/		return 0x820EB92C;
		  /* 820EB92Ch */ case    7:  		/* addi R7, R1, 1680 */
		/* 820EB92Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x690);
		/* 820EB92Ch case    7:*/		return 0x820EB930;
		  /* 820EB930h */ case    8:  		/* stw R21, <#[R1 + 92]> */
		/* 820EB930h case    8:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000005C) );
		/* 820EB930h case    8:*/		return 0x820EB934;
		  /* 820EB934h */ case    9:  		/* addi R6, R1, 116 */
		/* 820EB934h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x74);
		/* 820EB934h case    9:*/		return 0x820EB938;
		  /* 820EB938h */ case   10:  		/* lwz R4, <#[R11]> */
		/* 820EB938h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820EB938h case   10:*/		return 0x820EB93C;
		  /* 820EB93Ch */ case   11:  		/* li R5, 0 */
		/* 820EB93Ch case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EB93Ch case   11:*/		return 0x820EB940;
		  /* 820EB940h */ case   12:  		/* stw R29, <#[R1 + 84]> */
		/* 820EB940h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 820EB940h case   12:*/		return 0x820EB944;
		  /* 820EB944h */ case   13:  		/* mr R3, R24 */
		/* 820EB944h case   13:*/		regs.R3 = regs.R24;
		/* 820EB944h case   13:*/		return 0x820EB948;
		  /* 820EB948h */ case   14:  		/* bl -464 */
		/* 820EB948h case   14:*/		regs.LR = 0x820EB94C; return 0x820EB778;
		/* 820EB948h case   14:*/		return 0x820EB94C;
		  /* 820EB94Ch */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820EB94Ch case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EB94Ch case   15:*/		return 0x820EB950;
		  /* 820EB950h */ case   16:  		/* bc 12, CR0_LT, 2760 */
		/* 820EB950h case   16:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EB950h case   16:*/		return 0x820EB954;
		  /* 820EB954h */ case   17:  		/* cmpwi CR6, R29, 0 */
		/* 820EB954h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820EB954h case   17:*/		return 0x820EB958;
		  /* 820EB958h */ case   18:  		/* bc 12, CR6_EQ, 272 */
		/* 820EB958h case   18:*/		if ( regs.CR[6].eq ) { return 0x820EBA68;  }
		/* 820EB958h case   18:*/		return 0x820EB95C;
		  /* 820EB95Ch */ case   19:  		/* lwz R11, <#[R1 + 112]> */
		/* 820EB95Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820EB95Ch case   19:*/		return 0x820EB960;
		  /* 820EB960h */ case   20:  		/* mr R9, R15 */
		/* 820EB960h case   20:*/		regs.R9 = regs.R15;
		/* 820EB960h case   20:*/		return 0x820EB964;
		  /* 820EB964h */ case   21:  		/* lwz R10, <#[R1 + 128]> */
		/* 820EB964h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 820EB964h case   21:*/		return 0x820EB968;
		  /* 820EB968h */ case   22:  		/* cmplw CR6, R11, R10 */
		/* 820EB968h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EB968h case   22:*/		return 0x820EB96C;
		  /* 820EB96Ch */ case   23:  		/* bc 4, CR6_EQ, 2580 */
		/* 820EB96Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x820EC380;  }
		/* 820EB96Ch case   23:*/		return 0x820EB970;
		  /* 820EB970h */ case   24:  		/* cmplwi CR6, R10, 0 */
		/* 820EB970h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820EB970h case   24:*/		return 0x820EB974;
		  /* 820EB974h */ case   25:  		/* bc 12, CR6_EQ, 60 */
		/* 820EB974h case   25:*/		if ( regs.CR[6].eq ) { return 0x820EB9B0;  }
		/* 820EB974h case   25:*/		return 0x820EB978;
		  /* 820EB978h */ case   26:  		/* mr R11, R21 */
		/* 820EB978h case   26:*/		regs.R11 = regs.R21;
		/* 820EB978h case   26:*/		return 0x820EB97C;
		  /* 820EB97Ch */ case   27:  		/* mtspr CTR, R10 */
		/* 820EB97Ch case   27:*/		regs.CTR = regs.R10;
		/* 820EB97Ch case   27:*/		return 0x820EB980;
		  /* 820EB980h */ case   28:  		/* addi R10, R1, 1168 */
		/* 820EB980h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x490);
		/* 820EB980h case   28:*/		return 0x820EB984;
		  /* 820EB984h */ case   29:  		/* addi R8, R1, 656 */
		/* 820EB984h case   29:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x290);
		/* 820EB984h case   29:*/		return 0x820EB988;
		  /* 820EB988h */ case   30:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820EB988h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EB988h case   30:*/		return 0x820EB98C;
		  /* 820EB98Ch */ case   31:  		/* lwzx R8, <#[R11 + R8]> */
		/* 820EB98Ch case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820EB98Ch case   31:*/		return 0x820EB990;
		  /* 820EB990h */ case   32:  		/* addi R11, R11, 4 */
		/* 820EB990h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EB990h case   32:*/		return 0x820EB994;
		  /* 820EB994h */ case   33:  		/* subf R10, R10, R8 */
		/* 820EB994h case   33:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820EB994h case   33:*/		return 0x820EB998;
		  /* 820EB998h */ case   34:  		/* addic R10, R10, -1 */
		/* 820EB998h case   34:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820EB998h case   34:*/		return 0x820EB99C;
		  /* 820EB99Ch */ case   35:  		/* subfe R10, R10, R10 */
		/* 820EB99Ch case   35:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820EB99Ch case   35:*/		return 0x820EB9A0;
		  /* 820EB9A0h */ case   36:  		/* and R9, R10, R9 */
		/* 820EB9A0h case   36:*/		cpu::op::and<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820EB9A0h case   36:*/		return 0x820EB9A4;
		  /* 820EB9A4h */ case   37:  		/* bc 16, CR0_LT, -36 */
		/* 820EB9A4h case   37:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EB980;  }
		/* 820EB9A4h case   37:*/		return 0x820EB9A8;
		  /* 820EB9A8h */ case   38:  		/* cmpwi CR6, R9, 0 */
		/* 820EB9A8h case   38:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820EB9A8h case   38:*/		return 0x820EB9AC;
		  /* 820EB9ACh */ case   39:  		/* bc 12, CR6_EQ, 2516 */
		/* 820EB9ACh case   39:*/		if ( regs.CR[6].eq ) { return 0x820EC380;  }
		/* 820EB9ACh case   39:*/		return 0x820EB9B0;
	}
	return 0x820EB9B0;
} // Block from 820EB910h-820EB9B0h (40 instructions)

//////////////////////////////////////////////////////
// Block at 820EB9B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB9B0);
		  /* 820EB9B0h */ case    0:  		/* li R3, 116 */
		/* 820EB9B0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 820EB9B0h case    0:*/		return 0x820EB9B4;
		  /* 820EB9B4h */ case    1:  		/* bl 68580 */
		/* 820EB9B4h case    1:*/		regs.LR = 0x820EB9B8; return 0x820FC598;
		/* 820EB9B4h case    1:*/		return 0x820EB9B8;
		  /* 820EB9B8h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820EB9B8h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EB9B8h case    2:*/		return 0x820EB9BC;
		  /* 820EB9BCh */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820EB9BCh case    3:*/		if ( regs.CR[0].eq ) { return 0x820EB9CC;  }
		/* 820EB9BCh case    3:*/		return 0x820EB9C0;
		  /* 820EB9C0h */ case    4:  		/* bl 66784 */
		/* 820EB9C0h case    4:*/		regs.LR = 0x820EB9C4; return 0x820FBEA0;
		/* 820EB9C0h case    4:*/		return 0x820EB9C4;
		  /* 820EB9C4h */ case    5:  		/* mr R31, R3 */
		/* 820EB9C4h case    5:*/		regs.R31 = regs.R3;
		/* 820EB9C4h case    5:*/		return 0x820EB9C8;
		  /* 820EB9C8h */ case    6:  		/* b 8 */
		/* 820EB9C8h case    6:*/		return 0x820EB9D0;
		/* 820EB9C8h case    6:*/		return 0x820EB9CC;
	}
	return 0x820EB9CC;
} // Block from 820EB9B0h-820EB9CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EB9CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB9CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB9CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB9CC);
		  /* 820EB9CCh */ case    0:  		/* mr R31, R21 */
		/* 820EB9CCh case    0:*/		regs.R31 = regs.R21;
		/* 820EB9CCh case    0:*/		return 0x820EB9D0;
	}
	return 0x820EB9D0;
} // Block from 820EB9CCh-820EB9D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EB9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EB9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EB9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EB9D0);
		  /* 820EB9D0h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820EB9D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820EB9D0h case    0:*/		return 0x820EB9D4;
		  /* 820EB9D4h */ case    1:  		/* bc 12, CR6_EQ, 2464 */
		/* 820EB9D4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC374;  }
		/* 820EB9D4h case    1:*/		return 0x820EB9D8;
		  /* 820EB9D8h */ case    2:  		/* lwz R6, <#[R1 + 128]> */
		/* 820EB9D8h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 820EB9D8h case    2:*/		return 0x820EB9DC;
		  /* 820EB9DCh */ case    3:  		/* li R11, 461 */
		/* 820EB9DCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1CD);
		/* 820EB9DCh case    3:*/		return 0x820EB9E0;
		  /* 820EB9E0h */ case    4:  		/* li R7, 0 */
		/* 820EB9E0h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820EB9E0h case    4:*/		return 0x820EB9E4;
		  /* 820EB9E4h */ case    5:  		/* mr R4, R6 */
		/* 820EB9E4h case    5:*/		regs.R4 = regs.R6;
		/* 820EB9E4h case    5:*/		return 0x820EB9E8;
		  /* 820EB9E8h */ case    6:  		/* rlwinm R5, R6, 1, 0, 30 */
		/* 820EB9E8h case    6:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R5,regs.R6);
		/* 820EB9E8h case    6:*/		return 0x820EB9EC;
		  /* 820EB9ECh */ case    7:  		/* rlwimi R4, R11, 22, 0, 11 */
		/* 820EB9ECh case    7:*/		cpu::op::rlwimi<0,22,0,11>(regs,&regs.R4,regs.R11);
		/* 820EB9ECh case    7:*/		return 0x820EB9F0;
		  /* 820EB9F0h */ case    8:  		/* mr R3, R31 */
		/* 820EB9F0h case    8:*/		regs.R3 = regs.R31;
		/* 820EB9F0h case    8:*/		return 0x820EB9F4;
		  /* 820EB9F4h */ case    9:  		/* bl 68668 */
		/* 820EB9F4h case    9:*/		regs.LR = 0x820EB9F8; return 0x820FC630;
		/* 820EB9F4h case    9:*/		return 0x820EB9F8;
		  /* 820EB9F8h */ case   10:  		/* or. R30, R3, R3 */
		/* 820EB9F8h case   10:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820EB9F8h case   10:*/		return 0x820EB9FC;
		  /* 820EB9FCh */ case   11:  		/* mr R3, R31 */
		/* 820EB9FCh case   11:*/		regs.R3 = regs.R31;
		/* 820EB9FCh case   11:*/		return 0x820EBA00;
		  /* 820EBA00h */ case   12:  		/* bc 12, CR0_LT, 2452 */
		/* 820EBA00h case   12:*/		if ( regs.CR[0].lt ) { return 0x820EC394;  }
		/* 820EBA00h case   12:*/		return 0x820EBA04;
		  /* 820EBA04h */ case   13:  		/* mr R4, R26 */
		/* 820EBA04h case   13:*/		regs.R4 = regs.R26;
		/* 820EBA04h case   13:*/		return 0x820EBA08;
		  /* 820EBA08h */ case   14:  		/* bl 66792 */
		/* 820EBA08h case   14:*/		regs.LR = 0x820EBA0C; return 0x820FBEF0;
		/* 820EBA08h case   14:*/		return 0x820EBA0C;
		  /* 820EBA0Ch */ case   15:  		/* or. R30, R3, R3 */
		/* 820EBA0Ch case   15:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820EBA0Ch case   15:*/		return 0x820EBA10;
		  /* 820EBA10h */ case   16:  		/* bc 12, CR0_LT, 2432 */
		/* 820EBA10h case   16:*/		if ( regs.CR[0].lt ) { return 0x820EC390;  }
		/* 820EBA10h case   16:*/		return 0x820EBA14;
		  /* 820EBA14h */ case   17:  		/* lwz R11, <#[R1 + 112]> */
		/* 820EBA14h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820EBA14h case   17:*/		return 0x820EBA18;
		  /* 820EBA18h */ case   18:  		/* addi R4, R1, 1168 */
		/* 820EBA18h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x490);
		/* 820EBA18h case   18:*/		return 0x820EBA1C;
		  /* 820EBA1Ch */ case   19:  		/* lwz R3, <#[R31 + 16]> */
		/* 820EBA1Ch case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820EBA1Ch case   19:*/		return 0x820EBA20;
		  /* 820EBA20h */ case   20:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820EBA20h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820EBA20h case   20:*/		return 0x820EBA24;
		  /* 820EBA24h */ case   21:  		/* bl -368756 */
		/* 820EBA24h case   21:*/		regs.LR = 0x820EBA28; return 0x820919B0;
		/* 820EBA24h case   21:*/		return 0x820EBA28;
		  /* 820EBA28h */ case   22:  		/* lwz R11, <#[R1 + 112]> */
		/* 820EBA28h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820EBA28h case   22:*/		return 0x820EBA2C;
		  /* 820EBA2Ch */ case   23:  		/* addi R4, R1, 144 */
		/* 820EBA2Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 820EBA2Ch case   23:*/		return 0x820EBA30;
		  /* 820EBA30h */ case   24:  		/* lwz R3, <#[R31 + 8]> */
		/* 820EBA30h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820EBA30h case   24:*/		return 0x820EBA34;
		  /* 820EBA34h */ case   25:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820EBA34h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820EBA34h case   25:*/		return 0x820EBA38;
		  /* 820EBA38h */ case   26:  		/* bl -368776 */
		/* 820EBA38h case   26:*/		regs.LR = 0x820EBA3C; return 0x820919B0;
		/* 820EBA38h case   26:*/		return 0x820EBA3C;
		  /* 820EBA3Ch */ case   27:  		/* lwz R10, <#[R1 + 112]> */
		/* 820EBA3Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 820EBA3Ch case   27:*/		return 0x820EBA40;
		  /* 820EBA40h */ case   28:  		/* lwz R11, <#[R31 + 8]> */
		/* 820EBA40h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820EBA40h case   28:*/		return 0x820EBA44;
		  /* 820EBA44h */ case   29:  		/* addi R4, R1, 1680 */
		/* 820EBA44h case   29:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x690);
		/* 820EBA44h case   29:*/		return 0x820EBA48;
		  /* 820EBA48h */ case   30:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 820EBA48h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 820EBA48h case   30:*/		return 0x820EBA4C;
		  /* 820EBA4Ch */ case   31:  		/* add R3, R5, R11 */
		/* 820EBA4Ch case   31:*/		cpu::op::add<0>(regs,&regs.R3,regs.R5,regs.R11);
		/* 820EBA4Ch case   31:*/		return 0x820EBA50;
		  /* 820EBA50h */ case   32:  		/* bl -368800 */
		/* 820EBA50h case   32:*/		regs.LR = 0x820EBA54; return 0x820919B0;
		/* 820EBA50h case   32:*/		return 0x820EBA54;
		  /* 820EBA54h */ case   33:  		/* mr R4, R31 */
		/* 820EBA54h case   33:*/		regs.R4 = regs.R31;
		/* 820EBA54h case   33:*/		return 0x820EBA58;
		  /* 820EBA58h */ case   34:  		/* mr R3, R24 */
		/* 820EBA58h case   34:*/		regs.R3 = regs.R24;
		/* 820EBA58h case   34:*/		return 0x820EBA5C;
		  /* 820EBA5Ch */ case   35:  		/* bl 71260 */
		/* 820EBA5Ch case   35:*/		regs.LR = 0x820EBA60; return 0x820FD0B8;
		/* 820EBA5Ch case   35:*/		return 0x820EBA60;
		  /* 820EBA60h */ case   36:  		/* cmpwi CR0, R3, 0 */
		/* 820EBA60h case   36:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBA60h case   36:*/		return 0x820EBA64;
		  /* 820EBA64h */ case   37:  		/* bc 12, CR0_LT, 2484 */
		/* 820EBA64h case   37:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBA64h case   37:*/		return 0x820EBA68;
	}
	return 0x820EBA68;
} // Block from 820EB9D0h-820EBA68h (38 instructions)

//////////////////////////////////////////////////////
// Block at 820EBA68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBA68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBA68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBA68);
		  /* 820EBA68h */ case    0:  		/* lwz R11, <#[R24 + 116]> */
		/* 820EBA68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000074) );
		/* 820EBA68h case    0:*/		return 0x820EBA6C;
		  /* 820EBA6Ch */ case    1:  		/* lwz R22, <#[R1 + 116]> */
		/* 820EBA6Ch case    1:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000074) );
		/* 820EBA6Ch case    1:*/		return 0x820EBA70;
		  /* 820EBA70h */ case    2:  		/* stw R11, <#[R27 + 4]> */
		/* 820EBA70h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 820EBA70h case    2:*/		return 0x820EBA74;
		  /* 820EBA74h */ case    3:  		/* b 2240 */
		/* 820EBA74h case    3:*/		return 0x820EC334;
		/* 820EBA74h case    3:*/		return 0x820EBA78;
	}
	return 0x820EBA78;
} // Block from 820EBA68h-820EBA78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EBA78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBA78);
		  /* 820EBA78h */ case    0:  		/* mr R3, R28 */
		/* 820EBA78h case    0:*/		regs.R3 = regs.R28;
		/* 820EBA78h case    0:*/		return 0x820EBA7C;
		  /* 820EBA7Ch */ case    1:  		/* bl -2484 */
		/* 820EBA7Ch case    1:*/		regs.LR = 0x820EBA80; return 0x820EB0C8;
		/* 820EBA7Ch case    1:*/		return 0x820EBA80;
		  /* 820EBA80h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820EBA80h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBA80h case    2:*/		return 0x820EBA84;
		  /* 820EBA84h */ case    3:  		/* bc 12, CR0_EQ, 580 */
		/* 820EBA84h case    3:*/		if ( regs.CR[0].eq ) { return 0x820EBCC8;  }
		/* 820EBA84h case    3:*/		return 0x820EBA88;
		  /* 820EBA88h */ case    4:  		/* addi R28, R22, 1 */
		/* 820EBA88h case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R22,0x1);
		/* 820EBA88h case    4:*/		return 0x820EBA8C;
		  /* 820EBA8Ch */ case    5:  		/* stw R21, <#[R1 + 112]> */
		/* 820EBA8Ch case    5:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000070) );
		/* 820EBA8Ch case    5:*/		return 0x820EBA90;
		  /* 820EBA90h */ case    6:  		/* cmpwi CR6, R29, 0 */
		/* 820EBA90h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820EBA90h case    6:*/		return 0x820EBA94;
		  /* 820EBA94h */ case    7:  		/* stw R28, <#[R1 + 120]> */
		/* 820EBA94h case    7:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000078) );
		/* 820EBA94h case    7:*/		return 0x820EBA98;
		  /* 820EBA98h */ case    8:  		/* bc 12, CR6_EQ, 484 */
		/* 820EBA98h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EBC7C;  }
		/* 820EBA98h case    8:*/		return 0x820EBA9C;
		  /* 820EBA9Ch */ case    9:  		/* li R3, 116 */
		/* 820EBA9Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 820EBA9Ch case    9:*/		return 0x820EBAA0;
		  /* 820EBAA0h */ case   10:  		/* bl 68344 */
		/* 820EBAA0h case   10:*/		regs.LR = 0x820EBAA4; return 0x820FC598;
		/* 820EBAA0h case   10:*/		return 0x820EBAA4;
		  /* 820EBAA4h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820EBAA4h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EBAA4h case   11:*/		return 0x820EBAA8;
		  /* 820EBAA8h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 820EBAA8h case   12:*/		if ( regs.CR[0].eq ) { return 0x820EBAB8;  }
		/* 820EBAA8h case   12:*/		return 0x820EBAAC;
		  /* 820EBAACh */ case   13:  		/* bl 66548 */
		/* 820EBAACh case   13:*/		regs.LR = 0x820EBAB0; return 0x820FBEA0;
		/* 820EBAACh case   13:*/		return 0x820EBAB0;
		  /* 820EBAB0h */ case   14:  		/* mr R30, R3 */
		/* 820EBAB0h case   14:*/		regs.R30 = regs.R3;
		/* 820EBAB0h case   14:*/		return 0x820EBAB4;
		  /* 820EBAB4h */ case   15:  		/* b 8 */
		/* 820EBAB4h case   15:*/		return 0x820EBABC;
		/* 820EBAB4h case   15:*/		return 0x820EBAB8;
	}
	return 0x820EBAB8;
} // Block from 820EBA78h-820EBAB8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820EBAB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBAB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBAB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBAB8);
		  /* 820EBAB8h */ case    0:  		/* mr R30, R21 */
		/* 820EBAB8h case    0:*/		regs.R30 = regs.R21;
		/* 820EBAB8h case    0:*/		return 0x820EBABC;
	}
	return 0x820EBABC;
} // Block from 820EBAB8h-820EBABCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EBABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBABC);
		  /* 820EBABCh */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820EBABCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820EBABCh case    0:*/		return 0x820EBAC0;
		  /* 820EBAC0h */ case    1:  		/* bc 12, CR6_EQ, 2228 */
		/* 820EBAC0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC374;  }
		/* 820EBAC0h case    1:*/		return 0x820EBAC4;
		  /* 820EBAC4h */ case    2:  		/* mr R4, R26 */
		/* 820EBAC4h case    2:*/		regs.R4 = regs.R26;
		/* 820EBAC4h case    2:*/		return 0x820EBAC8;
		  /* 820EBAC8h */ case    3:  		/* mr R3, R30 */
		/* 820EBAC8h case    3:*/		regs.R3 = regs.R30;
		/* 820EBAC8h case    3:*/		return 0x820EBACC;
		  /* 820EBACCh */ case    4:  		/* bl 69252 */
		/* 820EBACCh case    4:*/		regs.LR = 0x820EBAD0; return 0x820FC950;
		/* 820EBACCh case    4:*/		return 0x820EBAD0;
		  /* 820EBAD0h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820EBAD0h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBAD0h case    5:*/		return 0x820EBAD4;
		  /* 820EBAD4h */ case    6:  		/* bc 12, CR0_LT, 2372 */
		/* 820EBAD4h case    6:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBAD4h case    6:*/		return 0x820EBAD8;
		  /* 820EBAD8h */ case    7:  		/* lwz R11, <#[R26]> */
		/* 820EBAD8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820EBAD8h case    7:*/		return 0x820EBADC;
		  /* 820EBADCh */ case    8:  		/* lis R10, 29760 */
		/* 820EBADCh case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x7440);
		/* 820EBADCh case    8:*/		return 0x820EBAE0;
		  /* 820EBAE0h */ case    9:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820EBAE0h case    9:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820EBAE0h case    9:*/		return 0x820EBAE4;
		  /* 820EBAE4h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820EBAE4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EBAE4h case   10:*/		return 0x820EBAE8;
		  /* 820EBAE8h */ case   11:  		/* bc 12, CR6_EQ, 64 */
		/* 820EBAE8h case   11:*/		if ( regs.CR[6].eq ) { return 0x820EBB28;  }
		/* 820EBAE8h case   11:*/		return 0x820EBAEC;
		  /* 820EBAECh */ case   12:  		/* lis R10, 29776 */
		/* 820EBAECh case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x7450);
		/* 820EBAECh case   12:*/		return 0x820EBAF0;
		  /* 820EBAF0h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820EBAF0h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EBAF0h case   13:*/		return 0x820EBAF4;
		  /* 820EBAF4h */ case   14:  		/* bc 12, CR6_EQ, 44 */
		/* 820EBAF4h case   14:*/		if ( regs.CR[6].eq ) { return 0x820EBB20;  }
		/* 820EBAF4h case   14:*/		return 0x820EBAF8;
		  /* 820EBAF8h */ case   15:  		/* lis R10, 29792 */
		/* 820EBAF8h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x7460);
		/* 820EBAF8h case   15:*/		return 0x820EBAFC;
		  /* 820EBAFCh */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820EBAFCh case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EBAFCh case   16:*/		return 0x820EBB00;
		  /* 820EBB00h */ case   17:  		/* bc 12, CR6_EQ, 24 */
		/* 820EBB00h case   17:*/		if ( regs.CR[6].eq ) { return 0x820EBB18;  }
		/* 820EBB00h case   17:*/		return 0x820EBB04;
		  /* 820EBB04h */ case   18:  		/* lis R10, 29808 */
		/* 820EBB04h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0x7470);
		/* 820EBB04h case   18:*/		return 0x820EBB08;
		  /* 820EBB08h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820EBB08h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EBB08h case   19:*/		return 0x820EBB0C;
		  /* 820EBB0Ch */ case   20:  		/* bc 4, CR6_EQ, 40 */
		/* 820EBB0Ch case   20:*/		if ( !regs.CR[6].eq ) { return 0x820EBB34;  }
		/* 820EBB0Ch case   20:*/		return 0x820EBB10;
		  /* 820EBB10h */ case   21:  		/* lis R11, 29584 */
		/* 820EBB10h case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0x7390);
		/* 820EBB10h case   21:*/		return 0x820EBB14;
		  /* 820EBB14h */ case   22:  		/* b 24 */
		/* 820EBB14h case   22:*/		return 0x820EBB2C;
		/* 820EBB14h case   22:*/		return 0x820EBB18;
	}
	return 0x820EBB18;
} // Block from 820EBABCh-820EBB18h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820EBB18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBB18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBB18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBB18);
		  /* 820EBB18h */ case    0:  		/* lis R11, 29600 */
		/* 820EBB18h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x73A0);
		/* 820EBB18h case    0:*/		return 0x820EBB1C;
		  /* 820EBB1Ch */ case    1:  		/* b 16 */
		/* 820EBB1Ch case    1:*/		return 0x820EBB2C;
		/* 820EBB1Ch case    1:*/		return 0x820EBB20;
	}
	return 0x820EBB20;
} // Block from 820EBB18h-820EBB20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EBB20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBB20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBB20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBB20);
		  /* 820EBB20h */ case    0:  		/* lis R11, 29632 */
		/* 820EBB20h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x73C0);
		/* 820EBB20h case    0:*/		return 0x820EBB24;
		  /* 820EBB24h */ case    1:  		/* b 8 */
		/* 820EBB24h case    1:*/		return 0x820EBB2C;
		/* 820EBB24h case    1:*/		return 0x820EBB28;
	}
	return 0x820EBB28;
} // Block from 820EBB20h-820EBB28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EBB28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBB28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBB28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBB28);
		  /* 820EBB28h */ case    0:  		/* lis R11, 29616 */
		/* 820EBB28h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x73B0);
		/* 820EBB28h case    0:*/		return 0x820EBB2C;
	}
	return 0x820EBB2C;
} // Block from 820EBB28h-820EBB2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EBB2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBB2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBB2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBB2C);
		  /* 820EBB2Ch */ case    0:  		/* ori R11, R11, 1 */
		/* 820EBB2Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EBB2Ch case    0:*/		return 0x820EBB30;
		  /* 820EBB30h */ case    1:  		/* stw R11, <#[R30]> */
		/* 820EBB30h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820EBB30h case    1:*/		return 0x820EBB34;
	}
	return 0x820EBB34;
} // Block from 820EBB2Ch-820EBB34h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EBB34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBB34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBB34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBB34);
		  /* 820EBB34h */ case    0:  		/* mr R4, R26 */
		/* 820EBB34h case    0:*/		regs.R4 = regs.R26;
		/* 820EBB34h case    0:*/		return 0x820EBB38;
		  /* 820EBB38h */ case    1:  		/* mr R3, R30 */
		/* 820EBB38h case    1:*/		regs.R3 = regs.R30;
		/* 820EBB38h case    1:*/		return 0x820EBB3C;
		  /* 820EBB3Ch */ case    2:  		/* bl 66484 */
		/* 820EBB3Ch case    2:*/		regs.LR = 0x820EBB40; return 0x820FBEF0;
		/* 820EBB3Ch case    2:*/		return 0x820EBB40;
		  /* 820EBB40h */ case    3:  		/* mr R4, R30 */
		/* 820EBB40h case    3:*/		regs.R4 = regs.R30;
		/* 820EBB40h case    3:*/		return 0x820EBB44;
		  /* 820EBB44h */ case    4:  		/* mr R3, R24 */
		/* 820EBB44h case    4:*/		regs.R3 = regs.R24;
		/* 820EBB44h case    4:*/		return 0x820EBB48;
		  /* 820EBB48h */ case    5:  		/* bl 71024 */
		/* 820EBB48h case    5:*/		regs.LR = 0x820EBB4C; return 0x820FD0B8;
		/* 820EBB48h case    5:*/		return 0x820EBB4C;
		  /* 820EBB4Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820EBB4Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBB4Ch case    6:*/		return 0x820EBB50;
		  /* 820EBB50h */ case    7:  		/* bc 12, CR0_LT, 2248 */
		/* 820EBB50h case    7:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBB50h case    7:*/		return 0x820EBB54;
		  /* 820EBB54h */ case    8:  		/* lwz R11, <#[R26 + 16]> */
		/* 820EBB54h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820EBB54h case    8:*/		return 0x820EBB58;
		  /* 820EBB58h */ case    9:  		/* mr R10, R19 */
		/* 820EBB58h case    9:*/		regs.R10 = regs.R19;
		/* 820EBB58h case    9:*/		return 0x820EBB5C;
		  /* 820EBB5Ch */ case   10:  		/* stw R21, <#[R1 + 132]> */
		/* 820EBB5Ch case   10:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000084) );
		/* 820EBB5Ch case   10:*/		return 0x820EBB60;
		  /* 820EBB60h */ case   11:  		/* addi R9, R1, 132 */
		/* 820EBB60h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x84);
		/* 820EBB60h case   11:*/		return 0x820EBB64;
		  /* 820EBB64h */ case   12:  		/* stw R29, <#[R1 + 84]> */
		/* 820EBB64h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 820EBB64h case   12:*/		return 0x820EBB68;
		  /* 820EBB68h */ case   13:  		/* addi R8, R1, 1168 */
		/* 820EBB68h case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x490);
		/* 820EBB68h case   13:*/		return 0x820EBB6C;
		  /* 820EBB6Ch */ case   14:  		/* stw R21, <#[R1 + 92]> */
		/* 820EBB6Ch case   14:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000005C) );
		/* 820EBB6Ch case   14:*/		return 0x820EBB70;
		  /* 820EBB70h */ case   15:  		/* addi R7, R1, 1680 */
		/* 820EBB70h case   15:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x690);
		/* 820EBB70h case   15:*/		return 0x820EBB74;
		  /* 820EBB74h */ case   16:  		/* addi R6, R1, 120 */
		/* 820EBB74h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x78);
		/* 820EBB74h case   16:*/		return 0x820EBB78;
		  /* 820EBB78h */ case   17:  		/* lwz R31, <#[R24 + 12]> */
		/* 820EBB78h case   17:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + 0x0000000C) );
		/* 820EBB78h case   17:*/		return 0x820EBB7C;
		  /* 820EBB7Ch */ case   18:  		/* lwz R4, <#[R11]> */
		/* 820EBB7Ch case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820EBB7Ch case   18:*/		return 0x820EBB80;
		  /* 820EBB80h */ case   19:  		/* li R5, 0 */
		/* 820EBB80h case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EBB80h case   19:*/		return 0x820EBB84;
		  /* 820EBB84h */ case   20:  		/* mr R3, R24 */
		/* 820EBB84h case   20:*/		regs.R3 = regs.R24;
		/* 820EBB84h case   20:*/		return 0x820EBB88;
		  /* 820EBB88h */ case   21:  		/* stw R21, <#[R1 + 108]> */
		/* 820EBB88h case   21:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000006C) );
		/* 820EBB88h case   21:*/		return 0x820EBB8C;
		  /* 820EBB8Ch */ case   22:  		/* stw R21, <#[R1 + 100]> */
		/* 820EBB8Ch case   22:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 820EBB8Ch case   22:*/		return 0x820EBB90;
		  /* 820EBB90h */ case   23:  		/* bl -1048 */
		/* 820EBB90h case   23:*/		regs.LR = 0x820EBB94; return 0x820EB778;
		/* 820EBB90h case   23:*/		return 0x820EBB94;
		  /* 820EBB94h */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 820EBB94h case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBB94h case   24:*/		return 0x820EBB98;
		  /* 820EBB98h */ case   25:  		/* bc 12, CR0_LT, 2176 */
		/* 820EBB98h case   25:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBB98h case   25:*/		return 0x820EBB9C;
		  /* 820EBB9Ch */ case   26:  		/* lwz R11, <#[R24 + 12]> */
		/* 820EBB9Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820EBB9Ch case   26:*/		return 0x820EBBA0;
		  /* 820EBBA0h */ case   27:  		/* cmplw CR6, R11, R31 */
		/* 820EBBA0h case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820EBBA0h case   27:*/		return 0x820EBBA4;
		  /* 820EBBA4h */ case   28:  		/* bc 4, CR6_EQ, 32 */
		/* 820EBBA4h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820EBBC4;  }
		/* 820EBBA4h case   28:*/		return 0x820EBBA8;
		  /* 820EBBA8h */ case   29:  		/* mr R4, R26 */
		/* 820EBBA8h case   29:*/		regs.R4 = regs.R26;
		/* 820EBBA8h case   29:*/		return 0x820EBBAC;
		  /* 820EBBACh */ case   30:  		/* mr R3, R24 */
		/* 820EBBACh case   30:*/		regs.R3 = regs.R24;
		/* 820EBBACh case   30:*/		return 0x820EBBB0;
		  /* 820EBBB0h */ case   31:  		/* bl 71864 */
		/* 820EBBB0h case   31:*/		regs.LR = 0x820EBBB4; return 0x820FD468;
		/* 820EBBB0h case   31:*/		return 0x820EBBB4;
		  /* 820EBBB4h */ case   32:  		/* cmpwi CR0, R3, 0 */
		/* 820EBBB4h case   32:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBBB4h case   32:*/		return 0x820EBBB8;
		  /* 820EBBB8h */ case   33:  		/* bc 12, CR0_LT, 2144 */
		/* 820EBBB8h case   33:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBBB8h case   33:*/		return 0x820EBBBC;
		  /* 820EBBBCh */ case   34:  		/* stw R21, <#[R30]> */
		/* 820EBBBCh case   34:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R30 + 0x00000000) );
		/* 820EBBBCh case   34:*/		return 0x820EBBC0;
		  /* 820EBBC0h */ case   35:  		/* b 180 */
		/* 820EBBC0h case   35:*/		return 0x820EBC74;
		/* 820EBBC0h case   35:*/		return 0x820EBBC4;
	}
	return 0x820EBBC4;
} // Block from 820EBB34h-820EBBC4h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820EBBC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBBC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBBC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBBC4);
		  /* 820EBBC4h */ case    0:  		/* li R3, 116 */
		/* 820EBBC4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 820EBBC4h case    0:*/		return 0x820EBBC8;
		  /* 820EBBC8h */ case    1:  		/* bl 68048 */
		/* 820EBBC8h case    1:*/		regs.LR = 0x820EBBCC; return 0x820FC598;
		/* 820EBBC8h case    1:*/		return 0x820EBBCC;
		  /* 820EBBCCh */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820EBBCCh case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EBBCCh case    2:*/		return 0x820EBBD0;
		  /* 820EBBD0h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820EBBD0h case    3:*/		if ( regs.CR[0].eq ) { return 0x820EBBE0;  }
		/* 820EBBD0h case    3:*/		return 0x820EBBD4;
		  /* 820EBBD4h */ case    4:  		/* bl 66252 */
		/* 820EBBD4h case    4:*/		regs.LR = 0x820EBBD8; return 0x820FBEA0;
		/* 820EBBD4h case    4:*/		return 0x820EBBD8;
		  /* 820EBBD8h */ case    5:  		/* mr R31, R3 */
		/* 820EBBD8h case    5:*/		regs.R31 = regs.R3;
		/* 820EBBD8h case    5:*/		return 0x820EBBDC;
		  /* 820EBBDCh */ case    6:  		/* b 8 */
		/* 820EBBDCh case    6:*/		return 0x820EBBE4;
		/* 820EBBDCh case    6:*/		return 0x820EBBE0;
	}
	return 0x820EBBE0;
} // Block from 820EBBC4h-820EBBE0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EBBE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBBE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBBE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBBE0);
		  /* 820EBBE0h */ case    0:  		/* mr R31, R21 */
		/* 820EBBE0h case    0:*/		regs.R31 = regs.R21;
		/* 820EBBE0h case    0:*/		return 0x820EBBE4;
	}
	return 0x820EBBE4;
} // Block from 820EBBE0h-820EBBE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EBBE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBBE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBBE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBBE4);
		  /* 820EBBE4h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820EBBE4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820EBBE4h case    0:*/		return 0x820EBBE8;
		  /* 820EBBE8h */ case    1:  		/* bc 12, CR6_EQ, 1932 */
		/* 820EBBE8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC374;  }
		/* 820EBBE8h case    1:*/		return 0x820EBBEC;
		  /* 820EBBECh */ case    2:  		/* lis R4, 29504 */
		/* 820EBBECh case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x7340);
		/* 820EBBECh case    2:*/		return 0x820EBBF0;
		  /* 820EBBF0h */ case    3:  		/* li R7, 0 */
		/* 820EBBF0h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820EBBF0h case    3:*/		return 0x820EBBF4;
		  /* 820EBBF4h */ case    4:  		/* li R6, 0 */
		/* 820EBBF4h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820EBBF4h case    4:*/		return 0x820EBBF8;
		  /* 820EBBF8h */ case    5:  		/* li R5, 0 */
		/* 820EBBF8h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EBBF8h case    5:*/		return 0x820EBBFC;
		  /* 820EBBFCh */ case    6:  		/* ori R4, R4, 1 */
		/* 820EBBFCh case    6:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820EBBFCh case    6:*/		return 0x820EBC00;
		  /* 820EBC00h */ case    7:  		/* mr R3, R31 */
		/* 820EBC00h case    7:*/		regs.R3 = regs.R31;
		/* 820EBC00h case    7:*/		return 0x820EBC04;
		  /* 820EBC04h */ case    8:  		/* bl 68140 */
		/* 820EBC04h case    8:*/		regs.LR = 0x820EBC08; return 0x820FC630;
		/* 820EBC04h case    8:*/		return 0x820EBC08;
		  /* 820EBC08h */ case    9:  		/* or. R30, R3, R3 */
		/* 820EBC08h case    9:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820EBC08h case    9:*/		return 0x820EBC0C;
		  /* 820EBC0Ch */ case   10:  		/* mr R3, R31 */
		/* 820EBC0Ch case   10:*/		regs.R3 = regs.R31;
		/* 820EBC0Ch case   10:*/		return 0x820EBC10;
		  /* 820EBC10h */ case   11:  		/* bc 12, CR0_LT, 1924 */
		/* 820EBC10h case   11:*/		if ( regs.CR[0].lt ) { return 0x820EC394;  }
		/* 820EBC10h case   11:*/		return 0x820EBC14;
		  /* 820EBC14h */ case   12:  		/* mr R4, R26 */
		/* 820EBC14h case   12:*/		regs.R4 = regs.R26;
		/* 820EBC14h case   12:*/		return 0x820EBC18;
		  /* 820EBC18h */ case   13:  		/* bl 66264 */
		/* 820EBC18h case   13:*/		regs.LR = 0x820EBC1C; return 0x820FBEF0;
		/* 820EBC18h case   13:*/		return 0x820EBC1C;
		  /* 820EBC1Ch */ case   14:  		/* or. R30, R3, R3 */
		/* 820EBC1Ch case   14:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820EBC1Ch case   14:*/		return 0x820EBC20;
		  /* 820EBC20h */ case   15:  		/* bc 12, CR0_LT, 1904 */
		/* 820EBC20h case   15:*/		if ( regs.CR[0].lt ) { return 0x820EC390;  }
		/* 820EBC20h case   15:*/		return 0x820EBC24;
		  /* 820EBC24h */ case   16:  		/* lwz R11, <#[R26 + 16]> */
		/* 820EBC24h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820EBC24h case   16:*/		return 0x820EBC28;
		  /* 820EBC28h */ case   17:  		/* lis R10, 29744 */
		/* 820EBC28h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x7430);
		/* 820EBC28h case   17:*/		return 0x820EBC2C;
		  /* 820EBC2Ch */ case   18:  		/* lwz R9, <#[R31 + 16]> */
		/* 820EBC2Ch case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820EBC2Ch case   18:*/		return 0x820EBC30;
		  /* 820EBC30h */ case   19:  		/* mr R4, R26 */
		/* 820EBC30h case   19:*/		regs.R4 = regs.R26;
		/* 820EBC30h case   19:*/		return 0x820EBC34;
		  /* 820EBC34h */ case   20:  		/* ori R10, R10, 1 */
		/* 820EBC34h case   20:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EBC34h case   20:*/		return 0x820EBC38;
		  /* 820EBC38h */ case   21:  		/* mr R3, R24 */
		/* 820EBC38h case   21:*/		regs.R3 = regs.R24;
		/* 820EBC38h case   21:*/		return 0x820EBC3C;
		  /* 820EBC3Ch */ case   22:  		/* lwz R11, <#[R11]> */
		/* 820EBC3Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820EBC3Ch case   22:*/		return 0x820EBC40;
		  /* 820EBC40h */ case   23:  		/* stw R11, <#[R9]> */
		/* 820EBC40h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820EBC40h case   23:*/		return 0x820EBC44;
		  /* 820EBC44h */ case   24:  		/* stw R10, <#[R26]> */
		/* 820EBC44h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820EBC44h case   24:*/		return 0x820EBC48;
		  /* 820EBC48h */ case   25:  		/* lwz R11, <#[R26 + 8]> */
		/* 820EBC48h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820EBC48h case   25:*/		return 0x820EBC4C;
		  /* 820EBC4Ch */ case   26:  		/* lwz R10, <#[R11]> */
		/* 820EBC4Ch case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820EBC4Ch case   26:*/		return 0x820EBC50;
		  /* 820EBC50h */ case   27:  		/* stw R10, <#[R11 + 4]> */
		/* 820EBC50h case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820EBC50h case   27:*/		return 0x820EBC54;
		  /* 820EBC54h */ case   28:  		/* bl 71700 */
		/* 820EBC54h case   28:*/		regs.LR = 0x820EBC58; return 0x820FD468;
		/* 820EBC54h case   28:*/		return 0x820EBC58;
		  /* 820EBC58h */ case   29:  		/* cmpwi CR0, R3, 0 */
		/* 820EBC58h case   29:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBC58h case   29:*/		return 0x820EBC5C;
		  /* 820EBC5Ch */ case   30:  		/* bc 12, CR0_LT, 1980 */
		/* 820EBC5Ch case   30:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBC5Ch case   30:*/		return 0x820EBC60;
		  /* 820EBC60h */ case   31:  		/* mr R4, R31 */
		/* 820EBC60h case   31:*/		regs.R4 = regs.R31;
		/* 820EBC60h case   31:*/		return 0x820EBC64;
		  /* 820EBC64h */ case   32:  		/* mr R3, R24 */
		/* 820EBC64h case   32:*/		regs.R3 = regs.R24;
		/* 820EBC64h case   32:*/		return 0x820EBC68;
		  /* 820EBC68h */ case   33:  		/* bl 70736 */
		/* 820EBC68h case   33:*/		regs.LR = 0x820EBC6C; return 0x820FD0B8;
		/* 820EBC68h case   33:*/		return 0x820EBC6C;
		  /* 820EBC6Ch */ case   34:  		/* cmpwi CR0, R3, 0 */
		/* 820EBC6Ch case   34:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBC6Ch case   34:*/		return 0x820EBC70;
		  /* 820EBC70h */ case   35:  		/* bc 12, CR0_LT, 1960 */
		/* 820EBC70h case   35:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBC70h case   35:*/		return 0x820EBC74;
	}
	return 0x820EBC74;
} // Block from 820EBBE4h-820EBC74h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820EBC74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBC74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBC74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBC74);
		  /* 820EBC74h */ case    0:  		/* lwz R11, <#[R24 + 116]> */
		/* 820EBC74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000074) );
		/* 820EBC74h case    0:*/		return 0x820EBC78;
		  /* 820EBC78h */ case    1:  		/* stw R11, <#[R27 + 4]> */
		/* 820EBC78h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 820EBC78h case    1:*/		return 0x820EBC7C;
	}
	return 0x820EBC7C;
} // Block from 820EBC74h-820EBC7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EBC7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBC7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBC7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBC7C);
		  /* 820EBC7Ch */ case    0:  		/* stw R28, <#[R1 + 120]> */
		/* 820EBC7Ch case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000078) );
		/* 820EBC7Ch case    0:*/		return 0x820EBC80;
		  /* 820EBC80h */ case    1:  		/* mr R10, R19 */
		/* 820EBC80h case    1:*/		regs.R10 = regs.R19;
		/* 820EBC80h case    1:*/		return 0x820EBC84;
		  /* 820EBC84h */ case    2:  		/* stw R21, <#[R1 + 100]> */
		/* 820EBC84h case    2:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 820EBC84h case    2:*/		return 0x820EBC88;
		  /* 820EBC88h */ case    3:  		/* addi R9, R1, 112 */
		/* 820EBC88h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820EBC88h case    3:*/		return 0x820EBC8C;
		  /* 820EBC8Ch */ case    4:  		/* stw R21, <#[R1 + 92]> */
		/* 820EBC8Ch case    4:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000005C) );
		/* 820EBC8Ch case    4:*/		return 0x820EBC90;
		  /* 820EBC90h */ case    5:  		/* addi R8, R1, 656 */
		/* 820EBC90h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x290);
		/* 820EBC90h case    5:*/		return 0x820EBC94;
		  /* 820EBC94h */ case    6:  		/* stw R29, <#[R1 + 84]> */
		/* 820EBC94h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 820EBC94h case    6:*/		return 0x820EBC98;
		  /* 820EBC98h */ case    7:  		/* addi R7, R1, 144 */
		/* 820EBC98h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x90);
		/* 820EBC98h case    7:*/		return 0x820EBC9C;
		  /* 820EBC9Ch */ case    8:  		/* stw R21, <#[R1 + 108]> */
		/* 820EBC9Ch case    8:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000006C) );
		/* 820EBC9Ch case    8:*/		return 0x820EBCA0;
		  /* 820EBCA0h */ case    9:  		/* addi R6, R1, 120 */
		/* 820EBCA0h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x78);
		/* 820EBCA0h case    9:*/		return 0x820EBCA4;
		  /* 820EBCA4h */ case   10:  		/* lwz R11, <#[R26 + 16]> */
		/* 820EBCA4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820EBCA4h case   10:*/		return 0x820EBCA8;
		  /* 820EBCA8h */ case   11:  		/* li R5, 1 */
		/* 820EBCA8h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820EBCA8h case   11:*/		return 0x820EBCAC;
		  /* 820EBCACh */ case   12:  		/* mr R3, R24 */
		/* 820EBCACh case   12:*/		regs.R3 = regs.R24;
		/* 820EBCACh case   12:*/		return 0x820EBCB0;
		  /* 820EBCB0h */ case   13:  		/* lwz R4, <#[R11]> */
		/* 820EBCB0h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820EBCB0h case   13:*/		return 0x820EBCB4;
		  /* 820EBCB4h */ case   14:  		/* bl -1340 */
		/* 820EBCB4h case   14:*/		regs.LR = 0x820EBCB8; return 0x820EB778;
		/* 820EBCB4h case   14:*/		return 0x820EBCB8;
		  /* 820EBCB8h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820EBCB8h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBCB8h case   15:*/		return 0x820EBCBC;
		  /* 820EBCBCh */ case   16:  		/* bc 12, CR0_LT, 1884 */
		/* 820EBCBCh case   16:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBCBCh case   16:*/		return 0x820EBCC0;
		  /* 820EBCC0h */ case   17:  		/* lwz R22, <#[R1 + 120]> */
		/* 820EBCC0h case   17:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000078) );
		/* 820EBCC0h case   17:*/		return 0x820EBCC4;
		  /* 820EBCC4h */ case   18:  		/* b 1648 */
		/* 820EBCC4h case   18:*/		return 0x820EC334;
		/* 820EBCC4h case   18:*/		return 0x820EBCC8;
	}
	return 0x820EBCC8;
} // Block from 820EBC7Ch-820EBCC8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820EBCC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBCC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBCC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBCC8);
		  /* 820EBCC8h */ case    0:  		/* lis R30, 4368 */
		/* 820EBCC8h case    0:*/		cpu::op::lis<0>(regs,&regs.R30,0x1110);
		/* 820EBCC8h case    0:*/		return 0x820EBCCC;
		  /* 820EBCCCh */ case    1:  		/* cmplw CR6, R28, R30 */
		/* 820EBCCCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R30);
		/* 820EBCCCh case    1:*/		return 0x820EBCD0;
		  /* 820EBCD0h */ case    2:  		/* bc 12, CR6_EQ, 368 */
		/* 820EBCD0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EBE40;  }
		/* 820EBCD0h case    2:*/		return 0x820EBCD4;
		  /* 820EBCD4h */ case    3:  		/* lis R11, 29712 */
		/* 820EBCD4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x7410);
		/* 820EBCD4h case    3:*/		return 0x820EBCD8;
		  /* 820EBCD8h */ case    4:  		/* cmplw CR6, R28, R11 */
		/* 820EBCD8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820EBCD8h case    4:*/		return 0x820EBCDC;
		  /* 820EBCDCh */ case    5:  		/* bc 12, CR6_EQ, 356 */
		/* 820EBCDCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820EBE40;  }
		/* 820EBCDCh case    5:*/		return 0x820EBCE0;
		  /* 820EBCE0h */ case    6:  		/* lis R11, 4384 */
		/* 820EBCE0h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0x1120);
		/* 820EBCE0h case    6:*/		return 0x820EBCE4;
		  /* 820EBCE4h */ case    7:  		/* cmplw CR6, R28, R11 */
		/* 820EBCE4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820EBCE4h case    7:*/		return 0x820EBCE8;
		  /* 820EBCE8h */ case    8:  		/* bc 4, CR6_EQ, 104 */
		/* 820EBCE8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820EBD50;  }
		/* 820EBCE8h case    8:*/		return 0x820EBCEC;
		  /* 820EBCECh */ case    9:  		/* cmpwi CR6, R29, 0 */
		/* 820EBCECh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820EBCECh case    9:*/		return 0x820EBCF0;
		  /* 820EBCF0h */ case   10:  		/* bc 12, CR6_EQ, 1600 */
		/* 820EBCF0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820EC330;  }
		/* 820EBCF0h case   10:*/		return 0x820EBCF4;
		  /* 820EBCF4h */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820EBCF4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820EBCF4h case   11:*/		return 0x820EBCF8;
		  /* 820EBCF8h */ case   12:  		/* bc 12, CR6_EQ, 1592 */
		/* 820EBCF8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820EC330;  }
		/* 820EBCF8h case   12:*/		return 0x820EBCFC;
		  /* 820EBCFCh */ case   13:  		/* cmplwi CR6, R23, 0 */
		/* 820EBCFCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820EBCFCh case   13:*/		return 0x820EBD00;
		  /* 820EBD00h */ case   14:  		/* bc 12, CR6_EQ, 56 */
		/* 820EBD00h case   14:*/		if ( regs.CR[6].eq ) { return 0x820EBD38;  }
		/* 820EBD00h case   14:*/		return 0x820EBD04;
		  /* 820EBD04h */ case   15:  		/* mr R11, R21 */
		/* 820EBD04h case   15:*/		regs.R11 = regs.R21;
		/* 820EBD04h case   15:*/		return 0x820EBD08;
		  /* 820EBD08h */ case   16:  		/* mtspr CTR, R23 */
		/* 820EBD08h case   16:*/		regs.CTR = regs.R23;
		/* 820EBD08h case   16:*/		return 0x820EBD0C;
		  /* 820EBD0Ch */ case   17:  		/* lwz R10, <#[R26 + 16]> */
		/* 820EBD0Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 820EBD0Ch case   17:*/		return 0x820EBD10;
		  /* 820EBD10h */ case   18:  		/* lwz R9, <#[R24 + 20]> */
		/* 820EBD10h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000014) );
		/* 820EBD10h case   18:*/		return 0x820EBD14;
		  /* 820EBD14h */ case   19:  		/* lwz R8, <#[R1 + 2460]> */
		/* 820EBD14h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000099C) );
		/* 820EBD14h case   19:*/		return 0x820EBD18;
		  /* 820EBD18h */ case   20:  		/* lwz R7, <#[R1 + 2452]> */
		/* 820EBD18h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000994) );
		/* 820EBD18h case   20:*/		return 0x820EBD1C;
		  /* 820EBD1Ch */ case   21:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820EBD1Ch case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EBD1Ch case   21:*/		return 0x820EBD20;
		  /* 820EBD20h */ case   22:  		/* addi R11, R11, 4 */
		/* 820EBD20h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EBD20h case   22:*/		return 0x820EBD24;
		  /* 820EBD24h */ case   23:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EBD24h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EBD24h case   23:*/		return 0x820EBD28;
		  /* 820EBD28h */ case   24:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820EBD28h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EBD28h case   24:*/		return 0x820EBD2C;
		  /* 820EBD2Ch */ case   25:  		/* stw R8, <#[R10 + 52]> */
		/* 820EBD2Ch case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000034) );
		/* 820EBD2Ch case   25:*/		return 0x820EBD30;
		  /* 820EBD30h */ case   26:  		/* stw R7, <#[R10 + 48]> */
		/* 820EBD30h case   26:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000030) );
		/* 820EBD30h case   26:*/		return 0x820EBD34;
		  /* 820EBD34h */ case   27:  		/* bc 16, CR0_LT, -40 */
		/* 820EBD34h case   27:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EBD0C;  }
		/* 820EBD34h case   27:*/		return 0x820EBD38;
	}
	return 0x820EBD38;
} // Block from 820EBCC8h-820EBD38h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820EBD38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBD38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBD38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBD38);
		  /* 820EBD38h */ case    0:  		/* mr R4, R26 */
		/* 820EBD38h case    0:*/		regs.R4 = regs.R26;
		/* 820EBD38h case    0:*/		return 0x820EBD3C;
		  /* 820EBD3Ch */ case    1:  		/* mr R3, R24 */
		/* 820EBD3Ch case    1:*/		regs.R3 = regs.R24;
		/* 820EBD3Ch case    1:*/		return 0x820EBD40;
		  /* 820EBD40h */ case    2:  		/* bl 71464 */
		/* 820EBD40h case    2:*/		regs.LR = 0x820EBD44; return 0x820FD468;
		/* 820EBD40h case    2:*/		return 0x820EBD44;
		  /* 820EBD44h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820EBD44h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBD44h case    3:*/		return 0x820EBD48;
	}
	return 0x820EBD48;
} // Block from 820EBD38h-820EBD48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EBD48h
// Function '?CompactEndIfs@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBD48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBD48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBD48);
		  /* 820EBD48h */ case    0:  		/* bc 12, CR0_LT, 1744 */
		/* 820EBD48h case    0:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBD48h case    0:*/		return 0x820EBD4C;
		  /* 820EBD4Ch */ case    1:  		/* b 1508 */
		/* 820EBD4Ch case    1:*/		return 0x820EC330;
		/* 820EBD4Ch case    1:*/		return 0x820EBD50;
	}
	return 0x820EBD50;
} // Block from 820EBD48h-820EBD50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EBD50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBD50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBD50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBD50);
		  /* 820EBD50h */ case    0:  		/* lis R11, 4096 */
		/* 820EBD50h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x1000);
		/* 820EBD50h case    0:*/		return 0x820EBD54;
		  /* 820EBD54h */ case    1:  		/* cmplw CR6, R28, R11 */
		/* 820EBD54h case    1:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820EBD54h case    1:*/		return 0x820EBD58;
		  /* 820EBD58h */ case    2:  		/* bc 4, CR6_EQ, 208 */
		/* 820EBD58h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820EBE28;  }
		/* 820EBD58h case    2:*/		return 0x820EBD5C;
		  /* 820EBD5Ch */ case    3:  		/* cmpwi CR6, R10, 0 */
		/* 820EBD5Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820EBD5Ch case    3:*/		return 0x820EBD60;
		  /* 820EBD60h */ case    4:  		/* bc 12, CR6_EQ, 1488 */
		/* 820EBD60h case    4:*/		if ( regs.CR[6].eq ) { return 0x820EC330;  }
		/* 820EBD60h case    4:*/		return 0x820EBD64;
		  /* 820EBD64h */ case    5:  		/* lwz R11, <#[R27 + 24]> */
		/* 820EBD64h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 820EBD64h case    5:*/		return 0x820EBD68;
		  /* 820EBD68h */ case    6:  		/* cmplw CR6, R11, R18 */
		/* 820EBD68h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R18);
		/* 820EBD68h case    6:*/		return 0x820EBD6C;
		  /* 820EBD6Ch */ case    7:  		/* bc 4, CR6_EQ, 1476 */
		/* 820EBD6Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820EC330;  }
		/* 820EBD6Ch case    7:*/		return 0x820EBD70;
		  /* 820EBD70h */ case    8:  		/* mr R6, R21 */
		/* 820EBD70h case    8:*/		regs.R6 = regs.R21;
		/* 820EBD70h case    8:*/		return 0x820EBD74;
		  /* 820EBD74h */ case    9:  		/* cmplwi CR6, R5, 0 */
		/* 820EBD74h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820EBD74h case    9:*/		return 0x820EBD78;
		  /* 820EBD78h */ case   10:  		/* bc 12, CR6_EQ, 164 */
		/* 820EBD78h case   10:*/		if ( regs.CR[6].eq ) { return 0x820EBE1C;  }
		/* 820EBD78h case   10:*/		return 0x820EBD7C;
		  /* 820EBD7Ch */ case   11:  		/* lwz R7, <#[R26 + 8]> */
		/* 820EBD7Ch case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000008) );
		/* 820EBD7Ch case   11:*/		return 0x820EBD80;
		  /* 820EBD80h */ case   12:  		/* mr R9, R21 */
		/* 820EBD80h case   12:*/		regs.R9 = regs.R21;
		/* 820EBD80h case   12:*/		return 0x820EBD84;
		  /* 820EBD84h */ case   13:  		/* lwz R8, <#[R24 + 20]> */
		/* 820EBD84h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R24 + 0x00000014) );
		/* 820EBD84h case   13:*/		return 0x820EBD88;
		  /* 820EBD88h */ case   14:  		/* lwzx R11, <#[R9 + R7]> */
		/* 820EBD88h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820EBD88h case   14:*/		return 0x820EBD8C;
		  /* 820EBD8Ch */ case   15:  		/* lwzx R10, <#[R9 + R31]> */
		/* 820EBD8Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R31 + 0x00000000) );
		/* 820EBD8Ch case   15:*/		return 0x820EBD90;
		  /* 820EBD90h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EBD90h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EBD90h case   16:*/		return 0x820EBD94;
		  /* 820EBD94h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EBD94h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EBD94h case   17:*/		return 0x820EBD98;
		  /* 820EBD98h */ case   18:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820EBD98h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820EBD98h case   18:*/		return 0x820EBD9C;
		  /* 820EBD9Ch */ case   19:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820EBD9Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820EBD9Ch case   19:*/		return 0x820EBDA0;
		  /* 820EBDA0h */ case   20:  		/* lwz R4, <#[R11 + 4]> */
		/* 820EBDA0h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 820EBDA0h case   20:*/		return 0x820EBDA4;
		  /* 820EBDA4h */ case   21:  		/* lwz R3, <#[R10 + 4]> */
		/* 820EBDA4h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000004) );
		/* 820EBDA4h case   21:*/		return 0x820EBDA8;
		  /* 820EBDA8h */ case   22:  		/* cmplw CR6, R3, R4 */
		/* 820EBDA8h case   22:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 820EBDA8h case   22:*/		return 0x820EBDAC;
		  /* 820EBDACh */ case   23:  		/* bc 4, CR6_EQ, 112 */
		/* 820EBDACh case   23:*/		if ( !regs.CR[6].eq ) { return 0x820EBE1C;  }
		/* 820EBDACh case   23:*/		return 0x820EBDB0;
		  /* 820EBDB0h */ case   24:  		/* lwz R4, <#[R10 + 8]> */
		/* 820EBDB0h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000008) );
		/* 820EBDB0h case   24:*/		return 0x820EBDB4;
		  /* 820EBDB4h */ case   25:  		/* lwz R3, <#[R11 + 8]> */
		/* 820EBDB4h case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000008) );
		/* 820EBDB4h case   25:*/		return 0x820EBDB8;
		  /* 820EBDB8h */ case   26:  		/* cmplw CR6, R4, R3 */
		/* 820EBDB8h case   26:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 820EBDB8h case   26:*/		return 0x820EBDBC;
		  /* 820EBDBCh */ case   27:  		/* bc 4, CR6_EQ, 96 */
		/* 820EBDBCh case   27:*/		if ( !regs.CR[6].eq ) { return 0x820EBE1C;  }
		/* 820EBDBCh case   27:*/		return 0x820EBDC0;
		  /* 820EBDC0h */ case   28:  		/* lwz R4, <#[R10 + 12]> */
		/* 820EBDC0h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000000C) );
		/* 820EBDC0h case   28:*/		return 0x820EBDC4;
		  /* 820EBDC4h */ case   29:  		/* lwz R3, <#[R11 + 12]> */
		/* 820EBDC4h case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 820EBDC4h case   29:*/		return 0x820EBDC8;
		  /* 820EBDC8h */ case   30:  		/* cmplw CR6, R4, R3 */
		/* 820EBDC8h case   30:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 820EBDC8h case   30:*/		return 0x820EBDCC;
		  /* 820EBDCCh */ case   31:  		/* bc 4, CR6_EQ, 80 */
		/* 820EBDCCh case   31:*/		if ( !regs.CR[6].eq ) { return 0x820EBE1C;  }
		/* 820EBDCCh case   31:*/		return 0x820EBDD0;
		  /* 820EBDD0h */ case   32:  		/* lwz R4, <#[R10 + 16]> */
		/* 820EBDD0h case   32:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 820EBDD0h case   32:*/		return 0x820EBDD4;
		  /* 820EBDD4h */ case   33:  		/* lwz R3, <#[R11 + 16]> */
		/* 820EBDD4h case   33:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000010) );
		/* 820EBDD4h case   33:*/		return 0x820EBDD8;
		  /* 820EBDD8h */ case   34:  		/* cmplw CR6, R4, R3 */
		/* 820EBDD8h case   34:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 820EBDD8h case   34:*/		return 0x820EBDDC;
		  /* 820EBDDCh */ case   35:  		/* bc 4, CR6_EQ, 64 */
		/* 820EBDDCh case   35:*/		if ( !regs.CR[6].eq ) { return 0x820EBE1C;  }
		/* 820EBDDCh case   35:*/		return 0x820EBDE0;
		  /* 820EBDE0h */ case   36:  		/* lwz R4, <#[R10 + 60]> */
		/* 820EBDE0h case   36:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000003C) );
		/* 820EBDE0h case   36:*/		return 0x820EBDE4;
		  /* 820EBDE4h */ case   37:  		/* lwz R11, <#[R11 + 60]> */
		/* 820EBDE4h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820EBDE4h case   37:*/		return 0x820EBDE8;
		  /* 820EBDE8h */ case   38:  		/* cmplw CR6, R4, R11 */
		/* 820EBDE8h case   38:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820EBDE8h case   38:*/		return 0x820EBDEC;
		  /* 820EBDECh */ case   39:  		/* bc 4, CR6_EQ, 48 */
		/* 820EBDECh case   39:*/		if ( !regs.CR[6].eq ) { return 0x820EBE1C;  }
		/* 820EBDECh case   39:*/		return 0x820EBDF0;
		  /* 820EBDF0h */ case   40:  		/* lwz R11, <#[R24 + 204]> */
		/* 820EBDF0h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x000000CC) );
		/* 820EBDF0h case   40:*/		return 0x820EBDF4;
		  /* 820EBDF4h */ case   41:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820EBDF4h case   41:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820EBDF4h case   41:*/		return 0x820EBDF8;
		  /* 820EBDF8h */ case   42:  		/* bc 12, CR0_EQ, 16 */
		/* 820EBDF8h case   42:*/		if ( regs.CR[0].eq ) { return 0x820EBE08;  }
		/* 820EBDF8h case   42:*/		return 0x820EBDFC;
		  /* 820EBDFCh */ case   43:  		/* lwz R11, <#[R10 + 96]> */
		/* 820EBDFCh case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000060) );
		/* 820EBDFCh case   43:*/		return 0x820EBE00;
		  /* 820EBE00h */ case   44:  		/* cmplwi CR6, R11, 0 */
		/* 820EBE00h case   44:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EBE00h case   44:*/		return 0x820EBE04;
		  /* 820EBE04h */ case   45:  		/* bc 4, CR6_EQ, 24 */
		/* 820EBE04h case   45:*/		if ( !regs.CR[6].eq ) { return 0x820EBE1C;  }
		/* 820EBE04h case   45:*/		return 0x820EBE08;
	}
	return 0x820EBE08;
} // Block from 820EBD50h-820EBE08h (46 instructions)

//////////////////////////////////////////////////////
// Block at 820EBE08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBE08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBE08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBE08);
		  /* 820EBE08h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 820EBE08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 820EBE08h case    0:*/		return 0x820EBE0C;
		  /* 820EBE0Ch */ case    1:  		/* addi R6, R6, 1 */
		/* 820EBE0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820EBE0Ch case    1:*/		return 0x820EBE10;
		  /* 820EBE10h */ case    2:  		/* addi R9, R9, 4 */
		/* 820EBE10h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820EBE10h case    2:*/		return 0x820EBE14;
		  /* 820EBE14h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 820EBE14h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820EBE14h case    3:*/		return 0x820EBE18;
		  /* 820EBE18h */ case    4:  		/* bc 12, CR6_LT, -144 */
		/* 820EBE18h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EBD88;  }
		/* 820EBE18h case    4:*/		return 0x820EBE1C;
	}
	return 0x820EBE1C;
} // Block from 820EBE08h-820EBE1Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EBE1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBE1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBE1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBE1C);
		  /* 820EBE1Ch */ case    0:  		/* cmplw CR6, R6, R5 */
		/* 820EBE1Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 820EBE1Ch case    0:*/		return 0x820EBE20;
		  /* 820EBE20h */ case    1:  		/* bc 12, CR6_EQ, 1296 */
		/* 820EBE20h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC330;  }
		/* 820EBE20h case    1:*/		return 0x820EBE24;
		  /* 820EBE24h */ case    2:  		/* b -236 */
		/* 820EBE24h case    2:*/		return 0x820EBD38;
		/* 820EBE24h case    2:*/		return 0x820EBE28;
	}
	return 0x820EBE28;
} // Block from 820EBE1Ch-820EBE28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EBE28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBE28);
		  /* 820EBE28h */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 820EBE28h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820EBE28h case    0:*/		return 0x820EBE2C;
		  /* 820EBE2Ch */ case    1:  		/* bc 12, CR6_EQ, 1284 */
		/* 820EBE2Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC330;  }
		/* 820EBE2Ch case    1:*/		return 0x820EBE30;
		  /* 820EBE30h */ case    2:  		/* lwz R11, <#[R27 + 24]> */
		/* 820EBE30h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 820EBE30h case    2:*/		return 0x820EBE34;
		  /* 820EBE34h */ case    3:  		/* cmplw CR6, R11, R18 */
		/* 820EBE34h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R18);
		/* 820EBE34h case    3:*/		return 0x820EBE38;
		  /* 820EBE38h */ case    4:  		/* bc 4, CR6_EQ, 1272 */
		/* 820EBE38h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820EC330;  }
		/* 820EBE38h case    4:*/		return 0x820EBE3C;
		  /* 820EBE3Ch */ case    5:  		/* b -260 */
		/* 820EBE3Ch case    5:*/		return 0x820EBD38;
		/* 820EBE3Ch case    5:*/		return 0x820EBE40;
	}
	return 0x820EBE40;
} // Block from 820EBE28h-820EBE40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EBE40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBE40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBE40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBE40);
		  /* 820EBE40h */ case    0:  		/* stw R21, <#[R1 + 112]> */
		/* 820EBE40h case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000070) );
		/* 820EBE40h case    0:*/		return 0x820EBE44;
		  /* 820EBE44h */ case    1:  		/* addi R31, R22, 1 */
		/* 820EBE44h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R22,0x1);
		/* 820EBE44h case    1:*/		return 0x820EBE48;
		  /* 820EBE48h */ case    2:  		/* lwz R11, <#[R26 + 16]> */
		/* 820EBE48h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820EBE48h case    2:*/		return 0x820EBE4C;
		  /* 820EBE4Ch */ case    3:  		/* mr R10, R19 */
		/* 820EBE4Ch case    3:*/		regs.R10 = regs.R19;
		/* 820EBE4Ch case    3:*/		return 0x820EBE50;
		  /* 820EBE50h */ case    4:  		/* stw R31, <#[R1 + 124]> */
		/* 820EBE50h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000007C) );
		/* 820EBE50h case    4:*/		return 0x820EBE54;
		  /* 820EBE54h */ case    5:  		/* addi R9, R1, 112 */
		/* 820EBE54h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820EBE54h case    5:*/		return 0x820EBE58;
		  /* 820EBE58h */ case    6:  		/* stw R29, <#[R1 + 84]> */
		/* 820EBE58h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 820EBE58h case    6:*/		return 0x820EBE5C;
		  /* 820EBE5Ch */ case    7:  		/* addi R8, R1, 656 */
		/* 820EBE5Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x290);
		/* 820EBE5Ch case    7:*/		return 0x820EBE60;
		  /* 820EBE60h */ case    8:  		/* stw R14, <#[R1 + 100]> */
		/* 820EBE60h case    8:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000064) );
		/* 820EBE60h case    8:*/		return 0x820EBE64;
		  /* 820EBE64h */ case    9:  		/* addi R7, R1, 144 */
		/* 820EBE64h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x90);
		/* 820EBE64h case    9:*/		return 0x820EBE68;
		  /* 820EBE68h */ case   10:  		/* stw R15, <#[R1 + 92]> */
		/* 820EBE68h case   10:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x0000005C) );
		/* 820EBE68h case   10:*/		return 0x820EBE6C;
		  /* 820EBE6Ch */ case   11:  		/* addi R6, R1, 124 */
		/* 820EBE6Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x7C);
		/* 820EBE6Ch case   11:*/		return 0x820EBE70;
		  /* 820EBE70h */ case   12:  		/* li R5, 1 */
		/* 820EBE70h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820EBE70h case   12:*/		return 0x820EBE74;
		  /* 820EBE74h */ case   13:  		/* stw R18, <#[R1 + 108]> */
		/* 820EBE74h case   13:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x0000006C) );
		/* 820EBE74h case   13:*/		return 0x820EBE78;
		  /* 820EBE78h */ case   14:  		/* mr R3, R24 */
		/* 820EBE78h case   14:*/		regs.R3 = regs.R24;
		/* 820EBE78h case   14:*/		return 0x820EBE7C;
		  /* 820EBE7Ch */ case   15:  		/* lwz R4, <#[R11]> */
		/* 820EBE7Ch case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820EBE7Ch case   15:*/		return 0x820EBE80;
		  /* 820EBE80h */ case   16:  		/* bl -1800 */
		/* 820EBE80h case   16:*/		regs.LR = 0x820EBE84; return 0x820EB778;
		/* 820EBE80h case   16:*/		return 0x820EBE84;
		  /* 820EBE84h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820EBE84h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBE84h case   17:*/		return 0x820EBE88;
		  /* 820EBE88h */ case   18:  		/* bc 12, CR0_LT, 1424 */
		/* 820EBE88h case   18:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBE88h case   18:*/		return 0x820EBE8C;
		  /* 820EBE8Ch */ case   19:  		/* cmpwi CR6, R29, 0 */
		/* 820EBE8Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820EBE8Ch case   19:*/		return 0x820EBE90;
		  /* 820EBE90h */ case   20:  		/* bc 12, CR6_EQ, 76 */
		/* 820EBE90h case   20:*/		if ( regs.CR[6].eq ) { return 0x820EBEDC;  }
		/* 820EBE90h case   20:*/		return 0x820EBE94;
		  /* 820EBE94h */ case   21:  		/* cmplw CR6, R28, R30 */
		/* 820EBE94h case   21:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R30);
		/* 820EBE94h case   21:*/		return 0x820EBE98;
		  /* 820EBE98h */ case   22:  		/* mr R4, R26 */
		/* 820EBE98h case   22:*/		regs.R4 = regs.R26;
		/* 820EBE98h case   22:*/		return 0x820EBE9C;
		  /* 820EBE9Ch */ case   23:  		/* mr R3, R24 */
		/* 820EBE9Ch case   23:*/		regs.R3 = regs.R24;
		/* 820EBE9Ch case   23:*/		return 0x820EBEA0;
		  /* 820EBEA0h */ case   24:  		/* bc 4, CR6_EQ, 40 */
		/* 820EBEA0h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820EBEC8;  }
		/* 820EBEA0h case   24:*/		return 0x820EBEA4;
		  /* 820EBEA4h */ case   25:  		/* rlwinm R30, R23, 0, 12, 31 */
		/* 820EBEA4h case   25:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R23);
		/* 820EBEA4h case   25:*/		return 0x820EBEA8;
		  /* 820EBEA8h */ case   26:  		/* oris R11, R30, 29728 */
		/* 820EBEA8h case   26:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R30,0x7420);
		/* 820EBEA8h case   26:*/		return 0x820EBEAC;
		  /* 820EBEACh */ case   27:  		/* stw R11, <#[R26]> */
		/* 820EBEACh case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820EBEACh case   27:*/		return 0x820EBEB0;
		  /* 820EBEB0h */ case   28:  		/* bl 71096 */
		/* 820EBEB0h case   28:*/		regs.LR = 0x820EBEB4; return 0x820FD468;
		/* 820EBEB0h case   28:*/		return 0x820EBEB4;
		  /* 820EBEB4h */ case   29:  		/* cmpwi CR0, R3, 0 */
		/* 820EBEB4h case   29:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBEB4h case   29:*/		return 0x820EBEB8;
		  /* 820EBEB8h */ case   30:  		/* bc 12, CR0_LT, 1376 */
		/* 820EBEB8h case   30:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBEB8h case   30:*/		return 0x820EBEBC;
		  /* 820EBEBCh */ case   31:  		/* oris R11, R30, 4368 */
		/* 820EBEBCh case   31:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R30,0x1110);
		/* 820EBEBCh case   31:*/		return 0x820EBEC0;
		  /* 820EBEC0h */ case   32:  		/* stw R11, <#[R26]> */
		/* 820EBEC0h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820EBEC0h case   32:*/		return 0x820EBEC4;
		  /* 820EBEC4h */ case   33:  		/* b 16 */
		/* 820EBEC4h case   33:*/		return 0x820EBED4;
		/* 820EBEC4h case   33:*/		return 0x820EBEC8;
	}
	return 0x820EBEC8;
} // Block from 820EBE40h-820EBEC8h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820EBEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBEC8);
		  /* 820EBEC8h */ case    0:  		/* bl 71072 */
		/* 820EBEC8h case    0:*/		regs.LR = 0x820EBECC; return 0x820FD468;
		/* 820EBEC8h case    0:*/		return 0x820EBECC;
		  /* 820EBECCh */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 820EBECCh case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBECCh case    1:*/		return 0x820EBED0;
		  /* 820EBED0h */ case    2:  		/* bc 12, CR0_LT, 1352 */
		/* 820EBED0h case    2:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBED0h case    2:*/		return 0x820EBED4;
	}
	return 0x820EBED4;
} // Block from 820EBEC8h-820EBED4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EBED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBED4);
		  /* 820EBED4h */ case    0:  		/* lwz R11, <#[R24 + 116]> */
		/* 820EBED4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000074) );
		/* 820EBED4h case    0:*/		return 0x820EBED8;
		  /* 820EBED8h */ case    1:  		/* stw R11, <#[R27 + 4]> */
		/* 820EBED8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 820EBED8h case    1:*/		return 0x820EBEDC;
	}
	return 0x820EBEDC;
} // Block from 820EBED4h-820EBEDCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EBEDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBEDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBEDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBEDC);
		  /* 820EBEDCh */ case    0:  		/* stw R31, <#[R1 + 124]> */
		/* 820EBEDCh case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000007C) );
		/* 820EBEDCh case    0:*/		return 0x820EBEE0;
		  /* 820EBEE0h */ case    1:  		/* mr R10, R19 */
		/* 820EBEE0h case    1:*/		regs.R10 = regs.R19;
		/* 820EBEE0h case    1:*/		return 0x820EBEE4;
		  /* 820EBEE4h */ case    2:  		/* stw R29, <#[R1 + 84]> */
		/* 820EBEE4h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 820EBEE4h case    2:*/		return 0x820EBEE8;
		  /* 820EBEE8h */ case    3:  		/* addi R9, R1, 112 */
		/* 820EBEE8h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820EBEE8h case    3:*/		return 0x820EBEEC;
		  /* 820EBEECh */ case    4:  		/* stw R21, <#[R1 + 100]> */
		/* 820EBEECh case    4:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 820EBEECh case    4:*/		return 0x820EBEF0;
		  /* 820EBEF0h */ case    5:  		/* addi R8, R1, 656 */
		/* 820EBEF0h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x290);
		/* 820EBEF0h case    5:*/		return 0x820EBEF4;
		  /* 820EBEF4h */ case    6:  		/* stw R21, <#[R1 + 92]> */
		/* 820EBEF4h case    6:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000005C) );
		/* 820EBEF4h case    6:*/		return 0x820EBEF8;
		  /* 820EBEF8h */ case    7:  		/* addi R7, R1, 144 */
		/* 820EBEF8h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x90);
		/* 820EBEF8h case    7:*/		return 0x820EBEFC;
		  /* 820EBEFCh */ case    8:  		/* stw R21, <#[R1 + 108]> */
		/* 820EBEFCh case    8:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000006C) );
		/* 820EBEFCh case    8:*/		return 0x820EBF00;
		  /* 820EBF00h */ case    9:  		/* addi R6, R1, 124 */
		/* 820EBF00h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x7C);
		/* 820EBF00h case    9:*/		return 0x820EBF04;
		  /* 820EBF04h */ case   10:  		/* lwz R11, <#[R26 + 16]> */
		/* 820EBF04h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820EBF04h case   10:*/		return 0x820EBF08;
		  /* 820EBF08h */ case   11:  		/* li R5, 1 */
		/* 820EBF08h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820EBF08h case   11:*/		return 0x820EBF0C;
		  /* 820EBF0Ch */ case   12:  		/* mr R3, R24 */
		/* 820EBF0Ch case   12:*/		regs.R3 = regs.R24;
		/* 820EBF0Ch case   12:*/		return 0x820EBF10;
		  /* 820EBF10h */ case   13:  		/* lwz R4, <#[R11]> */
		/* 820EBF10h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820EBF10h case   13:*/		return 0x820EBF14;
		  /* 820EBF14h */ case   14:  		/* bl -1948 */
		/* 820EBF14h case   14:*/		regs.LR = 0x820EBF18; return 0x820EB778;
		/* 820EBF14h case   14:*/		return 0x820EBF18;
	}
	return 0x820EBF18;
} // Block from 820EBEDCh-820EBF18h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820EBF18h
// Function '?GroupIfs@CShaderProgram@D3DXShader@@IAAJIIPAI000IHHII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBF18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBF18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBF18);
		  /* 820EBF18h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820EBF18h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBF18h case    0:*/		return 0x820EBF1C;
		  /* 820EBF1Ch */ case    1:  		/* bc 12, CR0_LT, 1276 */
		/* 820EBF1Ch case    1:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBF1Ch case    1:*/		return 0x820EBF20;
		  /* 820EBF20h */ case    2:  		/* cmpwi CR6, R29, 0 */
		/* 820EBF20h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820EBF20h case    2:*/		return 0x820EBF24;
		  /* 820EBF24h */ case    3:  		/* bc 12, CR6_EQ, 184 */
		/* 820EBF24h case    3:*/		if ( regs.CR[6].eq ) { return 0x820EBFDC;  }
		/* 820EBF24h case    3:*/		return 0x820EBF28;
		  /* 820EBF28h */ case    4:  		/* li R6, 0 */
		/* 820EBF28h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820EBF28h case    4:*/		return 0x820EBF2C;
		  /* 820EBF2Ch */ case    5:  		/* lwz R4, <#[R24 + 168]> */
		/* 820EBF2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R24 + 0x000000A8) );
		/* 820EBF2Ch case    5:*/		return 0x820EBF30;
		  /* 820EBF30h */ case    6:  		/* li R5, 0 */
		/* 820EBF30h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EBF30h case    6:*/		return 0x820EBF34;
		  /* 820EBF34h */ case    7:  		/* fmr FR1, FR31 */
		/* 820EBF34h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820EBF34h case    7:*/		return 0x820EBF38;
		  /* 820EBF38h */ case    8:  		/* mr R3, R24 */
		/* 820EBF38h case    8:*/		regs.R3 = regs.R24;
		/* 820EBF38h case    8:*/		return 0x820EBF3C;
		  /* 820EBF3Ch */ case    9:  		/* bl 70380 */
		/* 820EBF3Ch case    9:*/		regs.LR = 0x820EBF40; return 0x820FD228;
		/* 820EBF3Ch case    9:*/		return 0x820EBF40;
		  /* 820EBF40h */ case   10:  		/* mr R29, R3 */
		/* 820EBF40h case   10:*/		regs.R29 = regs.R3;
		/* 820EBF40h case   10:*/		return 0x820EBF44;
		  /* 820EBF44h */ case   11:  		/* cmpwi CR6, R3, -1 */
		/* 820EBF44h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820EBF44h case   11:*/		return 0x820EBF48;
		  /* 820EBF48h */ case   12:  		/* bc 12, CR6_EQ, 1068 */
		/* 820EBF48h case   12:*/		if ( regs.CR[6].eq ) { return 0x820EC374;  }
		/* 820EBF48h case   12:*/		return 0x820EBF4C;
		  /* 820EBF4Ch */ case   13:  		/* li R3, 116 */
		/* 820EBF4Ch case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 820EBF4Ch case   13:*/		return 0x820EBF50;
		  /* 820EBF50h */ case   14:  		/* bl 67144 */
		/* 820EBF50h case   14:*/		regs.LR = 0x820EBF54; return 0x820FC598;
		/* 820EBF50h case   14:*/		return 0x820EBF54;
		  /* 820EBF54h */ case   15:  		/* cmplwi CR0, R3, 0 */
		/* 820EBF54h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EBF54h case   15:*/		return 0x820EBF58;
		  /* 820EBF58h */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 820EBF58h case   16:*/		if ( regs.CR[0].eq ) { return 0x820EBF68;  }
		/* 820EBF58h case   16:*/		return 0x820EBF5C;
		  /* 820EBF5Ch */ case   17:  		/* bl 65348 */
		/* 820EBF5Ch case   17:*/		regs.LR = 0x820EBF60; return 0x820FBEA0;
		/* 820EBF5Ch case   17:*/		return 0x820EBF60;
		  /* 820EBF60h */ case   18:  		/* mr R31, R3 */
		/* 820EBF60h case   18:*/		regs.R31 = regs.R3;
		/* 820EBF60h case   18:*/		return 0x820EBF64;
		  /* 820EBF64h */ case   19:  		/* b 8 */
		/* 820EBF64h case   19:*/		return 0x820EBF6C;
		/* 820EBF64h case   19:*/		return 0x820EBF68;
	}
	return 0x820EBF68;
} // Block from 820EBF18h-820EBF68h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820EBF68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBF68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBF68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBF68);
		  /* 820EBF68h */ case    0:  		/* mr R31, R21 */
		/* 820EBF68h case    0:*/		regs.R31 = regs.R21;
		/* 820EBF68h case    0:*/		return 0x820EBF6C;
	}
	return 0x820EBF6C;
} // Block from 820EBF68h-820EBF6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EBF6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBF6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBF6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBF6C);
		  /* 820EBF6Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820EBF6Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820EBF6Ch case    0:*/		return 0x820EBF70;
		  /* 820EBF70h */ case    1:  		/* bc 12, CR6_EQ, 1028 */
		/* 820EBF70h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC374;  }
		/* 820EBF70h case    1:*/		return 0x820EBF74;
		  /* 820EBF74h */ case    2:  		/* lis R11, 4368 */
		/* 820EBF74h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x1110);
		/* 820EBF74h case    2:*/		return 0x820EBF78;
		  /* 820EBF78h */ case    3:  		/* li R7, 0 */
		/* 820EBF78h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820EBF78h case    3:*/		return 0x820EBF7C;
		  /* 820EBF7Ch */ case    4:  		/* cmplw CR6, R28, R11 */
		/* 820EBF7Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820EBF7Ch case    4:*/		return 0x820EBF80;
		  /* 820EBF80h */ case    5:  		/* li R6, 1 */
		/* 820EBF80h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820EBF80h case    5:*/		return 0x820EBF84;
		  /* 820EBF84h */ case    6:  		/* li R5, 0 */
		/* 820EBF84h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EBF84h case    6:*/		return 0x820EBF88;
		  /* 820EBF88h */ case    7:  		/* mr R3, R31 */
		/* 820EBF88h case    7:*/		regs.R3 = regs.R31;
		/* 820EBF88h case    7:*/		return 0x820EBF8C;
		  /* 820EBF8Ch */ case    8:  		/* lis R4, 29872 */
		/* 820EBF8Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x74B0);
		/* 820EBF8Ch case    8:*/		return 0x820EBF90;
		  /* 820EBF90h */ case    9:  		/* bc 12, CR6_EQ, 8 */
		/* 820EBF90h case    9:*/		if ( regs.CR[6].eq ) { return 0x820EBF98;  }
		/* 820EBF90h case    9:*/		return 0x820EBF94;
		  /* 820EBF94h */ case   10:  		/* lis R4, 29856 */
		/* 820EBF94h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x74A0);
		/* 820EBF94h case   10:*/		return 0x820EBF98;
	}
	return 0x820EBF98;
} // Block from 820EBF6Ch-820EBF98h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820EBF98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBF98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBF98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBF98);
		  /* 820EBF98h */ case    0:  		/* ori R4, R4, 1 */
		/* 820EBF98h case    0:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820EBF98h case    0:*/		return 0x820EBF9C;
		  /* 820EBF9Ch */ case    1:  		/* bl 67220 */
		/* 820EBF9Ch case    1:*/		regs.LR = 0x820EBFA0; return 0x820FC630;
		/* 820EBF9Ch case    1:*/		return 0x820EBFA0;
		  /* 820EBFA0h */ case    2:  		/* mr R30, R3 */
		/* 820EBFA0h case    2:*/		regs.R30 = regs.R3;
		/* 820EBFA0h case    2:*/		return 0x820EBFA4;
		  /* 820EBFA4h */ case    3:  		/* cmpwi CR6, R3, 0 */
		/* 820EBFA4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820EBFA4h case    3:*/		return 0x820EBFA8;
		  /* 820EBFA8h */ case    4:  		/* mr R3, R31 */
		/* 820EBFA8h case    4:*/		regs.R3 = regs.R31;
		/* 820EBFA8h case    4:*/		return 0x820EBFAC;
		  /* 820EBFACh */ case    5:  		/* bc 12, CR6_LT, 1000 */
		/* 820EBFACh case    5:*/		if ( regs.CR[6].lt ) { return 0x820EC394;  }
		/* 820EBFACh case    5:*/		return 0x820EBFB0;
		  /* 820EBFB0h */ case    6:  		/* mr R4, R26 */
		/* 820EBFB0h case    6:*/		regs.R4 = regs.R26;
		/* 820EBFB0h case    6:*/		return 0x820EBFB4;
		  /* 820EBFB4h */ case    7:  		/* bl 65340 */
		/* 820EBFB4h case    7:*/		regs.LR = 0x820EBFB8; return 0x820FBEF0;
		/* 820EBFB4h case    7:*/		return 0x820EBFB8;
		  /* 820EBFB8h */ case    8:  		/* or. R30, R3, R3 */
		/* 820EBFB8h case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820EBFB8h case    8:*/		return 0x820EBFBC;
		  /* 820EBFBCh */ case    9:  		/* bc 12, CR0_LT, 980 */
		/* 820EBFBCh case    9:*/		if ( regs.CR[0].lt ) { return 0x820EC390;  }
		/* 820EBFBCh case    9:*/		return 0x820EBFC0;
		  /* 820EBFC0h */ case   10:  		/* lwz R11, <#[R31 + 16]> */
		/* 820EBFC0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820EBFC0h case   10:*/		return 0x820EBFC4;
		  /* 820EBFC4h */ case   11:  		/* mr R4, R31 */
		/* 820EBFC4h case   11:*/		regs.R4 = regs.R31;
		/* 820EBFC4h case   11:*/		return 0x820EBFC8;
		  /* 820EBFC8h */ case   12:  		/* mr R3, R24 */
		/* 820EBFC8h case   12:*/		regs.R3 = regs.R24;
		/* 820EBFC8h case   12:*/		return 0x820EBFCC;
		  /* 820EBFCCh */ case   13:  		/* stw R29, <#[R11]> */
		/* 820EBFCCh case   13:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 820EBFCCh case   13:*/		return 0x820EBFD0;
		  /* 820EBFD0h */ case   14:  		/* bl 69864 */
		/* 820EBFD0h case   14:*/		regs.LR = 0x820EBFD4; return 0x820FD0B8;
		/* 820EBFD0h case   14:*/		return 0x820EBFD4;
		  /* 820EBFD4h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820EBFD4h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EBFD4h case   15:*/		return 0x820EBFD8;
		  /* 820EBFD8h */ case   16:  		/* bc 12, CR0_LT, 1088 */
		/* 820EBFD8h case   16:*/		if ( regs.CR[0].lt ) { return 0x820EC418;  }
		/* 820EBFD8h case   16:*/		return 0x820EBFDC;
	}
	return 0x820EBFDC;
} // Block from 820EBF98h-820EBFDCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820EBFDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBFDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBFDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBFDC);
		  /* 820EBFDCh */ case    0:  		/* lwz R22, <#[R1 + 124]> */
		/* 820EBFDCh case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x0000007C) );
		/* 820EBFDCh case    0:*/		return 0x820EBFE0;
		  /* 820EBFE0h */ case    1:  		/* b 852 */
		/* 820EBFE0h case    1:*/		return 0x820EC334;
		/* 820EBFE0h case    1:*/		return 0x820EBFE4;
	}
	return 0x820EBFE4;
} // Block from 820EBFDCh-820EBFE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EBFE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EBFE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EBFE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EBFE4);
		  /* 820EBFE4h */ case    0:  		/* lis R11, 8304 */
		/* 820EBFE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x2070);
		/* 820EBFE4h case    0:*/		return 0x820EBFE8;
		  /* 820EBFE8h */ case    1:  		/* cmplw CR6, R28, R11 */
		/* 820EBFE8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820EBFE8h case    1:*/		return 0x820EBFEC;
		  /* 820EBFECh */ case    2:  		/* bc 4, CR6_EQ, 1060 */
		/* 820EBFECh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820EC410;  }
		/* 820EBFECh case    2:*/		return 0x820EBFF0;
		  /* 820EBFF0h */ case    3:  		/* cmpwi CR6, R9, 0 */
		/* 820EBFF0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820EBFF0h case    3:*/		return 0x820EBFF4;
		  /* 820EBFF4h */ case    4:  		/* bc 4, CR6_EQ, 828 */
		/* 820EBFF4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820EC330;  }
		/* 820EBFF4h case    4:*/		return 0x820EBFF8;
		  /* 820EBFF8h */ case    5:  		/* lwz R6, <#[R26 + 8]> */
		/* 820EBFF8h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000008) );
		/* 820EBFF8h case    5:*/		return 0x820EBFFC;
		  /* 820EBFFCh */ case    6:  		/* rlwinm R25, R23, 2, 0, 29 */
		/* 820EBFFCh case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R25,regs.R23);
		/* 820EBFFCh case    6:*/		return 0x820EC000;
		  /* 820EC000h */ case    7:  		/* lwz R11, <#[R24 + 20]> */
		/* 820EC000h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 820EC000h case    7:*/		return 0x820EC004;
		  /* 820EC004h */ case    8:  		/* lwz R10, <#[R6]> */
		/* 820EC004h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 820EC004h case    8:*/		return 0x820EC008;
		  /* 820EC008h */ case    9:  		/* lwzx R9, <#[R25 + R6]> */
		/* 820EC008h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + regs.R6 + 0x00000000) );
		/* 820EC008h case    9:*/		return 0x820EC00C;
		  /* 820EC00Ch */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EC00Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EC00Ch case   10:*/		return 0x820EC010;
		  /* 820EC010h */ case   11:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820EC010h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820EC010h case   11:*/		return 0x820EC014;
		  /* 820EC014h */ case   12:  		/* lwzx R30, <#[R10 + R11]> */
		/* 820EC014h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EC014h case   12:*/		return 0x820EC018;
		  /* 820EC018h */ case   13:  		/* lwzx R10, <#[R9 + R11]> */
		/* 820EC018h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820EC018h case   13:*/		return 0x820EC01C;
		  /* 820EC01Ch */ case   14:  		/* lwz R11, <#[R30 + 20]> */
		/* 820EC01Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820EC01Ch case   14:*/		return 0x820EC020;
		  /* 820EC020h */ case   15:  		/* lwz R10, <#[R10 + 20]> */
		/* 820EC020h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820EC020h case   15:*/		return 0x820EC024;
		  /* 820EC024h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820EC024h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EC024h case   16:*/		return 0x820EC028;
		  /* 820EC028h */ case   17:  		/* bc 4, CR6_EQ, 896 */
		/* 820EC028h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820EC3A8;  }
		/* 820EC028h case   17:*/		return 0x820EC02C;
		  /* 820EC02Ch */ case   18:  		/* cmplwi CR6, R17, 0 */
		/* 820EC02Ch case   18:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 820EC02Ch case   18:*/		return 0x820EC030;
		  /* 820EC030h */ case   19:  		/* bc 12, CR6_EQ, 976 */
		/* 820EC030h case   19:*/		if ( regs.CR[6].eq ) { return 0x820EC400;  }
		/* 820EC030h case   19:*/		return 0x820EC034;
		  /* 820EC034h */ case   20:  		/* cmplwi CR6, R16, 0 */
		/* 820EC034h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 820EC034h case   20:*/		return 0x820EC038;
		  /* 820EC038h */ case   21:  		/* bc 12, CR6_EQ, 968 */
		/* 820EC038h case   21:*/		if ( regs.CR[6].eq ) { return 0x820EC400;  }
		/* 820EC038h case   21:*/		return 0x820EC03C;
		  /* 820EC03Ch */ case   22:  		/* cmplwi CR6, R20, 0 */
		/* 820EC03Ch case   22:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 820EC03Ch case   22:*/		return 0x820EC040;
		  /* 820EC040h */ case   23:  		/* bc 12, CR6_EQ, 960 */
		/* 820EC040h case   23:*/		if ( regs.CR[6].eq ) { return 0x820EC400;  }
		/* 820EC040h case   23:*/		return 0x820EC044;
		  /* 820EC044h */ case   24:  		/* cmplw CR6, R11, R14 */
		/* 820EC044h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 820EC044h case   24:*/		return 0x820EC048;
		  /* 820EC048h */ case   25:  		/* bc 4, CR6_EQ, 880 */
		/* 820EC048h case   25:*/		if ( !regs.CR[6].eq ) { return 0x820EC3B8;  }
		/* 820EC048h case   25:*/		return 0x820EC04C;
		  /* 820EC04Ch */ case   26:  		/* lwz R11, <#[R1 + 2436]> */
		/* 820EC04Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000984) );
		/* 820EC04Ch case   26:*/		return 0x820EC050;
		  /* 820EC050h */ case   27:  		/* cmpwi CR6, R11, 0 */
		/* 820EC050h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820EC050h case   27:*/		return 0x820EC054;
		  /* 820EC054h */ case   28:  		/* bc 12, CR6_EQ, 728 */
		/* 820EC054h case   28:*/		if ( regs.CR[6].eq ) { return 0x820EC32C;  }
		/* 820EC054h case   28:*/		return 0x820EC058;
		  /* 820EC058h */ case   29:  		/* lwz R11, <#[R30 + 24]> */
		/* 820EC058h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820EC058h case   29:*/		return 0x820EC05C;
		  /* 820EC05Ch */ case   30:  		/* mr R4, R15 */
		/* 820EC05Ch case   30:*/		regs.R4 = regs.R15;
		/* 820EC05Ch case   30:*/		return 0x820EC060;
		  /* 820EC060h */ case   31:  		/* mr R5, R21 */
		/* 820EC060h case   31:*/		regs.R5 = regs.R21;
		/* 820EC060h case   31:*/		return 0x820EC064;
		  /* 820EC064h */ case   32:  		/* cmplw CR6, R11, R18 */
		/* 820EC064h case   32:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R18);
		/* 820EC064h case   32:*/		return 0x820EC068;
		  /* 820EC068h */ case   33:  		/* bc 12, CR6_EQ, 8 */
		/* 820EC068h case   33:*/		if ( regs.CR[6].eq ) { return 0x820EC070;  }
		/* 820EC068h case   33:*/		return 0x820EC06C;
		  /* 820EC06Ch */ case   34:  		/* mr R5, R23 */
		/* 820EC06Ch case   34:*/		regs.R5 = regs.R23;
		/* 820EC06Ch case   34:*/		return 0x820EC070;
	}
	return 0x820EC070;
} // Block from 820EBFE4h-820EC070h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820EC070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC070);
		  /* 820EC070h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 820EC070h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820EC070h case    0:*/		return 0x820EC074;
		  /* 820EC074h */ case    1:  		/* bc 12, CR6_EQ, 140 */
		/* 820EC074h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC100;  }
		/* 820EC074h case    1:*/		return 0x820EC078;
		  /* 820EC078h */ case    2:  		/* lwz R9, <#[R24 + 20]> */
		/* 820EC078h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000014) );
		/* 820EC078h case    2:*/		return 0x820EC07C;
		  /* 820EC07Ch */ case    3:  		/* mr R8, R21 */
		/* 820EC07Ch case    3:*/		regs.R8 = regs.R21;
		/* 820EC07Ch case    3:*/		return 0x820EC080;
		  /* 820EC080h */ case    4:  		/* mtspr CTR, R23 */
		/* 820EC080h case    4:*/		regs.CTR = regs.R23;
		/* 820EC080h case    4:*/		return 0x820EC084;
		  /* 820EC084h */ case    5:  		/* rlwinm R7, R5, 2, 0, 29 */
		/* 820EC084h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R5);
		/* 820EC084h case    5:*/		return 0x820EC088;
		  /* 820EC088h */ case    6:  		/* lwzx R11, <#[R8 + R31]> */
		/* 820EC088h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R31 + 0x00000000) );
		/* 820EC088h case    6:*/		return 0x820EC08C;
		  /* 820EC08Ch */ case    7:  		/* lwzx R10, <#[R7 + R6]> */
		/* 820EC08Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 820EC08Ch case    7:*/		return 0x820EC090;
		  /* 820EC090h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EC090h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EC090h case    8:*/		return 0x820EC094;
		  /* 820EC094h */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EC094h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EC094h case    9:*/		return 0x820EC098;
		  /* 820EC098h */ case   10:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820EC098h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EC098h case   10:*/		return 0x820EC09C;
		  /* 820EC09Ch */ case   11:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820EC09Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EC09Ch case   11:*/		return 0x820EC0A0;
		  /* 820EC0A0h */ case   12:  		/* lwz R3, <#[R11 + 12]> */
		/* 820EC0A0h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 820EC0A0h case   12:*/		return 0x820EC0A4;
		  /* 820EC0A4h */ case   13:  		/* lwz R29, <#[R10 + 12]> */
		/* 820EC0A4h case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x0000000C) );
		/* 820EC0A4h case   13:*/		return 0x820EC0A8;
		  /* 820EC0A8h */ case   14:  		/* cmplw CR6, R3, R29 */
		/* 820EC0A8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R29);
		/* 820EC0A8h case   14:*/		return 0x820EC0AC;
		  /* 820EC0ACh */ case   15:  		/* bc 4, CR6_EQ, 68 */
		/* 820EC0ACh case   15:*/		if ( !regs.CR[6].eq ) { return 0x820EC0F0;  }
		/* 820EC0ACh case   15:*/		return 0x820EC0B0;
		  /* 820EC0B0h */ case   16:  		/* lwz R3, <#[R11 + 16]> */
		/* 820EC0B0h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000010) );
		/* 820EC0B0h case   16:*/		return 0x820EC0B4;
		  /* 820EC0B4h */ case   17:  		/* lwz R29, <#[R10 + 16]> */
		/* 820EC0B4h case   17:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000010) );
		/* 820EC0B4h case   17:*/		return 0x820EC0B8;
		  /* 820EC0B8h */ case   18:  		/* cmplw CR6, R3, R29 */
		/* 820EC0B8h case   18:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R29);
		/* 820EC0B8h case   18:*/		return 0x820EC0BC;
		  /* 820EC0BCh */ case   19:  		/* bc 4, CR6_EQ, 52 */
		/* 820EC0BCh case   19:*/		if ( !regs.CR[6].eq ) { return 0x820EC0F0;  }
		/* 820EC0BCh case   19:*/		return 0x820EC0C0;
		  /* 820EC0C0h */ case   20:  		/* lwz R3, <#[R11 + 8]> */
		/* 820EC0C0h case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000008) );
		/* 820EC0C0h case   20:*/		return 0x820EC0C4;
		  /* 820EC0C4h */ case   21:  		/* lwz R29, <#[R10 + 8]> */
		/* 820EC0C4h case   21:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000008) );
		/* 820EC0C4h case   21:*/		return 0x820EC0C8;
		  /* 820EC0C8h */ case   22:  		/* cmplw CR6, R3, R29 */
		/* 820EC0C8h case   22:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R29);
		/* 820EC0C8h case   22:*/		return 0x820EC0CC;
		  /* 820EC0CCh */ case   23:  		/* bc 4, CR6_EQ, 36 */
		/* 820EC0CCh case   23:*/		if ( !regs.CR[6].eq ) { return 0x820EC0F0;  }
		/* 820EC0CCh case   23:*/		return 0x820EC0D0;
		  /* 820EC0D0h */ case   24:  		/* lwz R3, <#[R11 + 4]> */
		/* 820EC0D0h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 820EC0D0h case   24:*/		return 0x820EC0D4;
		  /* 820EC0D4h */ case   25:  		/* lwz R29, <#[R10 + 4]> */
		/* 820EC0D4h case   25:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000004) );
		/* 820EC0D4h case   25:*/		return 0x820EC0D8;
		  /* 820EC0D8h */ case   26:  		/* cmplw CR6, R3, R29 */
		/* 820EC0D8h case   26:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R29);
		/* 820EC0D8h case   26:*/		return 0x820EC0DC;
		  /* 820EC0DCh */ case   27:  		/* bc 4, CR6_EQ, 20 */
		/* 820EC0DCh case   27:*/		if ( !regs.CR[6].eq ) { return 0x820EC0F0;  }
		/* 820EC0DCh case   27:*/		return 0x820EC0E0;
		  /* 820EC0E0h */ case   28:  		/* lwz R11, <#[R11 + 60]> */
		/* 820EC0E0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820EC0E0h case   28:*/		return 0x820EC0E4;
		  /* 820EC0E4h */ case   29:  		/* lwz R10, <#[R10 + 60]> */
		/* 820EC0E4h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000003C) );
		/* 820EC0E4h case   29:*/		return 0x820EC0E8;
		  /* 820EC0E8h */ case   30:  		/* cmplw CR6, R11, R10 */
		/* 820EC0E8h case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EC0E8h case   30:*/		return 0x820EC0EC;
		  /* 820EC0ECh */ case   31:  		/* bc 12, CR6_EQ, 8 */
		/* 820EC0ECh case   31:*/		if ( regs.CR[6].eq ) { return 0x820EC0F4;  }
		/* 820EC0ECh case   31:*/		return 0x820EC0F0;
	}
	return 0x820EC0F0;
} // Block from 820EC070h-820EC0F0h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820EC0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC0F0);
		  /* 820EC0F0h */ case    0:  		/* mr R4, R21 */
		/* 820EC0F0h case    0:*/		regs.R4 = regs.R21;
		/* 820EC0F0h case    0:*/		return 0x820EC0F4;
	}
	return 0x820EC0F4;
} // Block from 820EC0F0h-820EC0F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC0F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC0F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC0F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC0F4);
		  /* 820EC0F4h */ case    0:  		/* addi R8, R8, 4 */
		/* 820EC0F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820EC0F4h case    0:*/		return 0x820EC0F8;
		  /* 820EC0F8h */ case    1:  		/* addi R7, R7, 4 */
		/* 820EC0F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820EC0F8h case    1:*/		return 0x820EC0FC;
		  /* 820EC0FCh */ case    2:  		/* bc 16, CR0_LT, -116 */
		/* 820EC0FCh case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EC088;  }
		/* 820EC0FCh case    2:*/		return 0x820EC100;
	}
	return 0x820EC100;
} // Block from 820EC0F4h-820EC100h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EC100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC100);
		  /* 820EC100h */ case    0:  		/* lwz R11, <#[R20]> */
		/* 820EC100h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 820EC100h case    0:*/		return 0x820EC104;
		  /* 820EC104h */ case    1:  		/* add R11, R11, R23 */
		/* 820EC104h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R23);
		/* 820EC104h case    1:*/		return 0x820EC108;
		  /* 820EC108h */ case    2:  		/* cmplwi CR6, R11, 128 */
		/* 820EC108h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 820EC108h case    2:*/		return 0x820EC10C;
		  /* 820EC10Ch */ case    3:  		/* bc 4, CR6_LT, 696 */
		/* 820EC10Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x820EC3C4;  }
		/* 820EC10Ch case    3:*/		return 0x820EC110;
		  /* 820EC110h */ case    4:  		/* cmpwi CR6, R4, 0 */
		/* 820EC110h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 820EC110h case    4:*/		return 0x820EC114;
		  /* 820EC114h */ case    5:  		/* bc 12, CR6_EQ, 96 */
		/* 820EC114h case    5:*/		if ( regs.CR[6].eq ) { return 0x820EC174;  }
		/* 820EC114h case    5:*/		return 0x820EC118;
		  /* 820EC118h */ case    6:  		/* mr R11, R21 */
		/* 820EC118h case    6:*/		regs.R11 = regs.R21;
		/* 820EC118h case    6:*/		return 0x820EC11C;
		  /* 820EC11Ch */ case    7:  		/* cmplwi CR6, R23, 0 */
		/* 820EC11Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820EC11Ch case    7:*/		return 0x820EC120;
		  /* 820EC120h */ case    8:  		/* bc 12, CR6_EQ, 512 */
		/* 820EC120h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EC320;  }
		/* 820EC120h case    8:*/		return 0x820EC124;
		  /* 820EC124h */ case    9:  		/* mr R9, R21 */
		/* 820EC124h case    9:*/		regs.R9 = regs.R21;
		/* 820EC124h case    9:*/		return 0x820EC128;
		  /* 820EC128h */ case   10:  		/* mtspr CTR, R23 */
		/* 820EC128h case   10:*/		regs.CTR = regs.R23;
		/* 820EC128h case   10:*/		return 0x820EC12C;
		  /* 820EC12Ch */ case   11:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 820EC12Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 820EC12Ch case   11:*/		return 0x820EC130;
		  /* 820EC130h */ case   12:  		/* lwz R8, <#[R20]> */
		/* 820EC130h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R20 + 0x00000000) );
		/* 820EC130h case   12:*/		return 0x820EC134;
		  /* 820EC134h */ case   13:  		/* lwz R7, <#[R26 + 8]> */
		/* 820EC134h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000008) );
		/* 820EC134h case   13:*/		return 0x820EC138;
		  /* 820EC138h */ case   14:  		/* add R8, R8, R11 */
		/* 820EC138h case   14:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 820EC138h case   14:*/		return 0x820EC13C;
		  /* 820EC13Ch */ case   15:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820EC13Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820EC13Ch case   15:*/		return 0x820EC140;
		  /* 820EC140h */ case   16:  		/* lwzx R7, <#[R7 + R10]> */
		/* 820EC140h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820EC140h case   16:*/		return 0x820EC144;
		  /* 820EC144h */ case   17:  		/* addi R10, R10, 4 */
		/* 820EC144h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EC144h case   17:*/		return 0x820EC148;
		  /* 820EC148h */ case   18:  		/* stwx R7, <#[R8 + R17]> */
		/* 820EC148h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + regs.R17 + 0x00000000) );
		/* 820EC148h case   18:*/		return 0x820EC14C;
		  /* 820EC14Ch */ case   19:  		/* lwz R8, <#[R20]> */
		/* 820EC14Ch case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R20 + 0x00000000) );
		/* 820EC14Ch case   19:*/		return 0x820EC150;
		  /* 820EC150h */ case   20:  		/* lwz R7, <#[R26 + 16]> */
		/* 820EC150h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000010) );
		/* 820EC150h case   20:*/		return 0x820EC154;
		  /* 820EC154h */ case   21:  		/* add R8, R8, R11 */
		/* 820EC154h case   21:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 820EC154h case   21:*/		return 0x820EC158;
		  /* 820EC158h */ case   22:  		/* addi R11, R11, 1 */
		/* 820EC158h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EC158h case   22:*/		return 0x820EC15C;
		  /* 820EC15Ch */ case   23:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820EC15Ch case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820EC15Ch case   23:*/		return 0x820EC160;
		  /* 820EC160h */ case   24:  		/* lwzx R7, <#[R9 + R7]> */
		/* 820EC160h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820EC160h case   24:*/		return 0x820EC164;
		  /* 820EC164h */ case   25:  		/* addi R9, R9, 4 */
		/* 820EC164h case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820EC164h case   25:*/		return 0x820EC168;
		  /* 820EC168h */ case   26:  		/* stwx R7, <#[R8 + R16]> */
		/* 820EC168h case   26:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + regs.R16 + 0x00000000) );
		/* 820EC168h case   26:*/		return 0x820EC16C;
		  /* 820EC16Ch */ case   27:  		/* bc 16, CR0_LT, -60 */
		/* 820EC16Ch case   27:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EC130;  }
		/* 820EC16Ch case   27:*/		return 0x820EC170;
		  /* 820EC170h */ case   28:  		/* b 432 */
		/* 820EC170h case   28:*/		return 0x820EC320;
		/* 820EC170h case   28:*/		return 0x820EC174;
	}
	return 0x820EC174;
} // Block from 820EC100h-820EC174h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820EC174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC174);
		  /* 820EC174h */ case    0:  		/* li R3, 116 */
		/* 820EC174h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 820EC174h case    0:*/		return 0x820EC178;
		  /* 820EC178h */ case    1:  		/* bl 66592 */
		/* 820EC178h case    1:*/		regs.LR = 0x820EC17C; return 0x820FC598;
		/* 820EC178h case    1:*/		return 0x820EC17C;
		  /* 820EC17Ch */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820EC17Ch case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EC17Ch case    2:*/		return 0x820EC180;
		  /* 820EC180h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820EC180h case    3:*/		if ( regs.CR[0].eq ) { return 0x820EC190;  }
		/* 820EC180h case    3:*/		return 0x820EC184;
		  /* 820EC184h */ case    4:  		/* bl 64796 */
		/* 820EC184h case    4:*/		regs.LR = 0x820EC188; return 0x820FBEA0;
		/* 820EC184h case    4:*/		return 0x820EC188;
		  /* 820EC188h */ case    5:  		/* mr R29, R3 */
		/* 820EC188h case    5:*/		regs.R29 = regs.R3;
		/* 820EC188h case    5:*/		return 0x820EC18C;
		  /* 820EC18Ch */ case    6:  		/* b 8 */
		/* 820EC18Ch case    6:*/		return 0x820EC194;
		/* 820EC18Ch case    6:*/		return 0x820EC190;
	}
	return 0x820EC190;
} // Block from 820EC174h-820EC190h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EC190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC190);
		  /* 820EC190h */ case    0:  		/* mr R29, R21 */
		/* 820EC190h case    0:*/		regs.R29 = regs.R21;
		/* 820EC190h case    0:*/		return 0x820EC194;
	}
	return 0x820EC194;
} // Block from 820EC190h-820EC194h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC194);
		  /* 820EC194h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820EC194h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820EC194h case    0:*/		return 0x820EC198;
		  /* 820EC198h */ case    1:  		/* bc 12, CR6_EQ, 476 */
		/* 820EC198h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC374;  }
		/* 820EC198h case    1:*/		return 0x820EC19C;
		  /* 820EC19Ch */ case    2:  		/* mr R4, R23 */
		/* 820EC19Ch case    2:*/		regs.R4 = regs.R23;
		/* 820EC19Ch case    2:*/		return 0x820EC1A0;
		  /* 820EC1A0h */ case    3:  		/* li R7, 0 */
		/* 820EC1A0h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820EC1A0h case    3:*/		return 0x820EC1A4;
		  /* 820EC1A4h */ case    4:  		/* rlwimi R4, R15, 28, 0, 11 */
		/* 820EC1A4h case    4:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R15);
		/* 820EC1A4h case    4:*/		return 0x820EC1A8;
		  /* 820EC1A8h */ case    5:  		/* mr R6, R23 */
		/* 820EC1A8h case    5:*/		regs.R6 = regs.R23;
		/* 820EC1A8h case    5:*/		return 0x820EC1AC;
		  /* 820EC1ACh */ case    6:  		/* mr R5, R23 */
		/* 820EC1ACh case    6:*/		regs.R5 = regs.R23;
		/* 820EC1ACh case    6:*/		return 0x820EC1B0;
		  /* 820EC1B0h */ case    7:  		/* mr R3, R29 */
		/* 820EC1B0h case    7:*/		regs.R3 = regs.R29;
		/* 820EC1B0h case    7:*/		return 0x820EC1B4;
		  /* 820EC1B4h */ case    8:  		/* bl 66684 */
		/* 820EC1B4h case    8:*/		regs.LR = 0x820EC1B8; return 0x820FC630;
		/* 820EC1B4h case    8:*/		return 0x820EC1B8;
		  /* 820EC1B8h */ case    9:  		/* or. R31, R3, R3 */
		/* 820EC1B8h case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820EC1B8h case    9:*/		return 0x820EC1BC;
		  /* 820EC1BCh */ case   10:  		/* mr R3, R29 */
		/* 820EC1BCh case   10:*/		regs.R3 = regs.R29;
		/* 820EC1BCh case   10:*/		return 0x820EC1C0;
		  /* 820EC1C0h */ case   11:  		/* bc 12, CR0_LT, 536 */
		/* 820EC1C0h case   11:*/		if ( regs.CR[0].lt ) { return 0x820EC3D8;  }
		/* 820EC1C0h case   11:*/		return 0x820EC1C4;
		  /* 820EC1C4h */ case   12:  		/* mr R4, R26 */
		/* 820EC1C4h case   12:*/		regs.R4 = regs.R26;
		/* 820EC1C4h case   12:*/		return 0x820EC1C8;
		  /* 820EC1C8h */ case   13:  		/* bl 64808 */
		/* 820EC1C8h case   13:*/		regs.LR = 0x820EC1CC; return 0x820FBEF0;
		/* 820EC1C8h case   13:*/		return 0x820EC1CC;
		  /* 820EC1CCh */ case   14:  		/* or. R31, R3, R3 */
		/* 820EC1CCh case   14:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820EC1CCh case   14:*/		return 0x820EC1D0;
		  /* 820EC1D0h */ case   15:  		/* bc 12, CR0_LT, 516 */
		/* 820EC1D0h case   15:*/		if ( regs.CR[0].lt ) { return 0x820EC3D4;  }
		/* 820EC1D0h case   15:*/		return 0x820EC1D4;
		  /* 820EC1D4h */ case   16:  		/* mr R4, R29 */
		/* 820EC1D4h case   16:*/		regs.R4 = regs.R29;
		/* 820EC1D4h case   16:*/		return 0x820EC1D8;
		  /* 820EC1D8h */ case   17:  		/* mr R3, R24 */
		/* 820EC1D8h case   17:*/		regs.R3 = regs.R24;
		/* 820EC1D8h case   17:*/		return 0x820EC1DC;
		  /* 820EC1DCh */ case   18:  		/* bl 69340 */
		/* 820EC1DCh case   18:*/		regs.LR = 0x820EC1E0; return 0x820FD0B8;
		/* 820EC1DCh case   18:*/		return 0x820EC1E0;
		  /* 820EC1E0h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820EC1E0h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EC1E0h case   19:*/		return 0x820EC1E4;
		  /* 820EC1E4h */ case   20:  		/* bc 12, CR0_LT, 520 */
		/* 820EC1E4h case   20:*/		if ( regs.CR[0].lt ) { return 0x820EC3EC;  }
		/* 820EC1E4h case   20:*/		return 0x820EC1E8;
		  /* 820EC1E8h */ case   21:  		/* lwz R11, <#[R30 + 24]> */
		/* 820EC1E8h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820EC1E8h case   21:*/		return 0x820EC1EC;
		  /* 820EC1ECh */ case   22:  		/* mr R5, R25 */
		/* 820EC1ECh case   22:*/		regs.R5 = regs.R25;
		/* 820EC1ECh case   22:*/		return 0x820EC1F0;
		  /* 820EC1F0h */ case   23:  		/* lwz R3, <#[R29 + 8]> */
		/* 820EC1F0h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 820EC1F0h case   23:*/		return 0x820EC1F4;
		  /* 820EC1F4h */ case   24:  		/* cmplw CR6, R11, R18 */
		/* 820EC1F4h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R18);
		/* 820EC1F4h case   24:*/		return 0x820EC1F8;
		  /* 820EC1F8h */ case   25:  		/* bc 4, CR6_EQ, 12 */
		/* 820EC1F8h case   25:*/		if ( !regs.CR[6].eq ) { return 0x820EC204;  }
		/* 820EC1F8h case   25:*/		return 0x820EC1FC;
		  /* 820EC1FCh */ case   26:  		/* lwz R4, <#[R26 + 8]> */
		/* 820EC1FCh case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000008) );
		/* 820EC1FCh case   26:*/		return 0x820EC200;
		  /* 820EC200h */ case   27:  		/* b 12 */
		/* 820EC200h case   27:*/		return 0x820EC20C;
		/* 820EC200h case   27:*/		return 0x820EC204;
	}
	return 0x820EC204;
} // Block from 820EC194h-820EC204h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820EC204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC204);
		  /* 820EC204h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 820EC204h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820EC204h case    0:*/		return 0x820EC208;
		  /* 820EC208h */ case    1:  		/* add R4, R11, R25 */
		/* 820EC208h case    1:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R25);
		/* 820EC208h case    1:*/		return 0x820EC20C;
	}
	return 0x820EC20C;
} // Block from 820EC204h-820EC20Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EC20Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC20C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC20C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC20C);
		  /* 820EC20Ch */ case    0:  		/* bl -370780 */
		/* 820EC20Ch case    0:*/		regs.LR = 0x820EC210; return 0x820919B0;
		/* 820EC20Ch case    0:*/		return 0x820EC210;
		  /* 820EC210h */ case    1:  		/* mr R30, R21 */
		/* 820EC210h case    1:*/		regs.R30 = regs.R21;
		/* 820EC210h case    1:*/		return 0x820EC214;
		  /* 820EC214h */ case    2:  		/* cmplwi CR6, R23, 0 */
		/* 820EC214h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820EC214h case    2:*/		return 0x820EC218;
		  /* 820EC218h */ case    3:  		/* bc 12, CR6_EQ, 264 */
		/* 820EC218h case    3:*/		if ( regs.CR[6].eq ) { return 0x820EC320;  }
		/* 820EC218h case    3:*/		return 0x820EC21C;
		  /* 820EC21Ch */ case    4:  		/* mr R31, R21 */
		/* 820EC21Ch case    4:*/		regs.R31 = regs.R21;
		/* 820EC21Ch case    4:*/		return 0x820EC220;
		  /* 820EC220h */ case    5:  		/* li R6, 0 */
		/* 820EC220h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820EC220h case    5:*/		return 0x820EC224;
		  /* 820EC224h */ case    6:  		/* lwz R4, <#[R24 + 136]> */
		/* 820EC224h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R24 + 0x00000088) );
		/* 820EC224h case    6:*/		return 0x820EC228;
		  /* 820EC228h */ case    7:  		/* li R5, 0 */
		/* 820EC228h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EC228h case    7:*/		return 0x820EC22C;
		  /* 820EC22Ch */ case    8:  		/* fmr FR1, FR31 */
		/* 820EC22Ch case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820EC22Ch case    8:*/		return 0x820EC230;
		  /* 820EC230h */ case    9:  		/* mr R3, R24 */
		/* 820EC230h case    9:*/		regs.R3 = regs.R24;
		/* 820EC230h case    9:*/		return 0x820EC234;
		  /* 820EC234h */ case   10:  		/* bl 69620 */
		/* 820EC234h case   10:*/		regs.LR = 0x820EC238; return 0x820FD228;
		/* 820EC234h case   10:*/		return 0x820EC238;
		  /* 820EC238h */ case   11:  		/* lwz R11, <#[R20]> */
		/* 820EC238h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 820EC238h case   11:*/		return 0x820EC23C;
		  /* 820EC23Ch */ case   12:  		/* add R11, R11, R30 */
		/* 820EC23Ch case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820EC23Ch case   12:*/		return 0x820EC240;
		  /* 820EC240h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EC240h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EC240h case   13:*/		return 0x820EC244;
		  /* 820EC244h */ case   14:  		/* stwx R3, <#[R11 + R17]> */
		/* 820EC244h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R17 + 0x00000000) );
		/* 820EC244h case   14:*/		return 0x820EC248;
		  /* 820EC248h */ case   15:  		/* lwz R11, <#[R20]> */
		/* 820EC248h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 820EC248h case   15:*/		return 0x820EC24C;
		  /* 820EC24Ch */ case   16:  		/* add R11, R11, R30 */
		/* 820EC24Ch case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820EC24Ch case   16:*/		return 0x820EC250;
		  /* 820EC250h */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EC250h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EC250h case   17:*/		return 0x820EC254;
		  /* 820EC254h */ case   18:  		/* lwzx R11, <#[R11 + R17]> */
		/* 820EC254h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R17 + 0x00000000) );
		/* 820EC254h case   18:*/		return 0x820EC258;
		  /* 820EC258h */ case   19:  		/* cmpwi CR6, R11, -1 */
		/* 820EC258h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EC258h case   19:*/		return 0x820EC25C;
		  /* 820EC25Ch */ case   20:  		/* bc 12, CR6_EQ, 408 */
		/* 820EC25Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x820EC3F4;  }
		/* 820EC25Ch case   20:*/		return 0x820EC260;
		  /* 820EC260h */ case   21:  		/* lwz R10, <#[R26 + 16]> */
		/* 820EC260h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 820EC260h case   21:*/		return 0x820EC264;
		  /* 820EC264h */ case   22:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EC264h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EC264h case   22:*/		return 0x820EC268;
		  /* 820EC268h */ case   23:  		/* lwz R9, <#[R24 + 20]> */
		/* 820EC268h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000014) );
		/* 820EC268h case   23:*/		return 0x820EC26C;
		  /* 820EC26Ch */ case   24:  		/* lwzx R10, <#[R10 + R31]> */
		/* 820EC26Ch case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820EC26Ch case   24:*/		return 0x820EC270;
		  /* 820EC270h */ case   25:  		/* lwzx R28, <#[R11 + R9]> */
		/* 820EC270h case   25:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EC270h case   25:*/		return 0x820EC274;
		  /* 820EC274h */ case   26:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 820EC274h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 820EC274h case   26:*/		return 0x820EC278;
		  /* 820EC278h */ case   27:  		/* mr R3, R28 */
		/* 820EC278h case   27:*/		regs.R3 = regs.R28;
		/* 820EC278h case   27:*/		return 0x820EC27C;
		  /* 820EC27Ch */ case   28:  		/* lwzx R27, <#[R11 + R9]> */
		/* 820EC27Ch case   28:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EC27Ch case   28:*/		return 0x820EC280;
		  /* 820EC280h */ case   29:  		/* mr R4, R27 */
		/* 820EC280h case   29:*/		regs.R4 = regs.R27;
		/* 820EC280h case   29:*/		return 0x820EC284;
		  /* 820EC284h */ case   30:  		/* bl 67876 */
		/* 820EC284h case   30:*/		regs.LR = 0x820EC288; return 0x820FCBA8;
		/* 820EC284h case   30:*/		return 0x820EC288;
		  /* 820EC288h */ case   31:  		/* cmpwi CR0, R3, 0 */
		/* 820EC288h case   31:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EC288h case   31:*/		return 0x820EC28C;
		  /* 820EC28Ch */ case   32:  		/* bc 12, CR0_LT, 360 */
		/* 820EC28Ch case   32:*/		if ( regs.CR[0].lt ) { return 0x820EC3F4;  }
		/* 820EC28Ch case   32:*/		return 0x820EC290;
		  /* 820EC290h */ case   33:  		/* mr R4, R27 */
		/* 820EC290h case   33:*/		regs.R4 = regs.R27;
		/* 820EC290h case   33:*/		return 0x820EC294;
		  /* 820EC294h */ case   34:  		/* mr R3, R28 */
		/* 820EC294h case   34:*/		regs.R3 = regs.R28;
		/* 820EC294h case   34:*/		return 0x820EC298;
		  /* 820EC298h */ case   35:  		/* bl 68104 */
		/* 820EC298h case   35:*/		regs.LR = 0x820EC29C; return 0x820FCCA0;
		/* 820EC298h case   35:*/		return 0x820EC29C;
		  /* 820EC29Ch */ case   36:  		/* cmpwi CR0, R3, 0 */
		/* 820EC29Ch case   36:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EC29Ch case   36:*/		return 0x820EC2A0;
		  /* 820EC2A0h */ case   37:  		/* bc 12, CR0_LT, 340 */
		/* 820EC2A0h case   37:*/		if ( regs.CR[0].lt ) { return 0x820EC3F4;  }
		/* 820EC2A0h case   37:*/		return 0x820EC2A4;
		  /* 820EC2A4h */ case   38:  		/* lwz R11, <#[R20]> */
		/* 820EC2A4h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 820EC2A4h case   38:*/		return 0x820EC2A8;
		  /* 820EC2A8h */ case   39:  		/* lwz R10, <#[R29 + 16]> */
		/* 820EC2A8h case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 820EC2A8h case   39:*/		return 0x820EC2AC;
		  /* 820EC2ACh */ case   40:  		/* add R11, R11, R30 */
		/* 820EC2ACh case   40:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820EC2ACh case   40:*/		return 0x820EC2B0;
		  /* 820EC2B0h */ case   41:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EC2B0h case   41:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EC2B0h case   41:*/		return 0x820EC2B4;
		  /* 820EC2B4h */ case   42:  		/* lwzx R11, <#[R11 + R17]> */
		/* 820EC2B4h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R17 + 0x00000000) );
		/* 820EC2B4h case   42:*/		return 0x820EC2B8;
		  /* 820EC2B8h */ case   43:  		/* stwx R11, <#[R10 + R31]> */
		/* 820EC2B8h case   43:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820EC2B8h case   43:*/		return 0x820EC2BC;
		  /* 820EC2BCh */ case   44:  		/* lwz R11, <#[R20]> */
		/* 820EC2BCh case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 820EC2BCh case   44:*/		return 0x820EC2C0;
		  /* 820EC2C0h */ case   45:  		/* add R11, R11, R30 */
		/* 820EC2C0h case   45:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820EC2C0h case   45:*/		return 0x820EC2C4;
		  /* 820EC2C4h */ case   46:  		/* lwz R10, <#[R26 + 16]> */
		/* 820EC2C4h case   46:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 820EC2C4h case   46:*/		return 0x820EC2C8;
		  /* 820EC2C8h */ case   47:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EC2C8h case   47:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EC2C8h case   47:*/		return 0x820EC2CC;
		  /* 820EC2CCh */ case   48:  		/* lwzx R10, <#[R10 + R31]> */
		/* 820EC2CCh case   48:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820EC2CCh case   48:*/		return 0x820EC2D0;
		  /* 820EC2D0h */ case   49:  		/* stwx R10, <#[R11 + R16]> */
		/* 820EC2D0h case   49:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R16 + 0x00000000) );
		/* 820EC2D0h case   49:*/		return 0x820EC2D4;
		  /* 820EC2D4h */ case   50:  		/* lwz R11, <#[R26 + 8]> */
		/* 820EC2D4h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820EC2D4h case   50:*/		return 0x820EC2D8;
		  /* 820EC2D8h */ case   51:  		/* lwz R9, <#[R24 + 20]> */
		/* 820EC2D8h case   51:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000014) );
		/* 820EC2D8h case   51:*/		return 0x820EC2DC;
		  /* 820EC2DCh */ case   52:  		/* lwzx R10, <#[R11 + R31]> */
		/* 820EC2DCh case   52:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820EC2DCh case   52:*/		return 0x820EC2E0;
		  /* 820EC2E0h */ case   53:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 820EC2E0h case   53:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 820EC2E0h case   53:*/		return 0x820EC2E4;
		  /* 820EC2E4h */ case   54:  		/* lwzx R9, <#[R8 + R9]> */
		/* 820EC2E4h case   54:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820EC2E4h case   54:*/		return 0x820EC2E8;
		  /* 820EC2E8h */ case   55:  		/* lwz R9, <#[R9 + 24]> */
		/* 820EC2E8h case   55:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 820EC2E8h case   55:*/		return 0x820EC2EC;
		  /* 820EC2ECh */ case   56:  		/* cmplw CR6, R9, R18 */
		/* 820EC2ECh case   56:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R18);
		/* 820EC2ECh case   56:*/		return 0x820EC2F0;
		  /* 820EC2F0h */ case   57:  		/* bc 4, CR6_EQ, 16 */
		/* 820EC2F0h case   57:*/		if ( !regs.CR[6].eq ) { return 0x820EC300;  }
		/* 820EC2F0h case   57:*/		return 0x820EC2F4;
		  /* 820EC2F4h */ case   58:  		/* lwz R11, <#[R29 + 8]> */
		/* 820EC2F4h case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820EC2F4h case   58:*/		return 0x820EC2F8;
		  /* 820EC2F8h */ case   59:  		/* stwx R10, <#[R31 + R11]> */
		/* 820EC2F8h case   59:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820EC2F8h case   59:*/		return 0x820EC2FC;
		  /* 820EC2FCh */ case   60:  		/* b 16 */
		/* 820EC2FCh case   60:*/		return 0x820EC30C;
		/* 820EC2FCh case   60:*/		return 0x820EC300;
	}
	return 0x820EC300;
} // Block from 820EC20Ch-820EC300h (61 instructions)

//////////////////////////////////////////////////////
// Block at 820EC300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC300);
		  /* 820EC300h */ case    0:  		/* lwz R10, <#[R29 + 8]> */
		/* 820EC300h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 820EC300h case    0:*/		return 0x820EC304;
		  /* 820EC304h */ case    1:  		/* lwzx R11, <#[R11 + R25]> */
		/* 820EC304h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 820EC304h case    1:*/		return 0x820EC308;
		  /* 820EC308h */ case    2:  		/* stwx R11, <#[R31 + R10]> */
		/* 820EC308h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 820EC308h case    2:*/		return 0x820EC30C;
	}
	return 0x820EC30C;
} // Block from 820EC300h-820EC30Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EC30Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC30C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC30C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC30C);
		  /* 820EC30Ch */ case    0:  		/* addi R30, R30, 1 */
		/* 820EC30Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820EC30Ch case    0:*/		return 0x820EC310;
		  /* 820EC310h */ case    1:  		/* addi R31, R31, 4 */
		/* 820EC310h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820EC310h case    1:*/		return 0x820EC314;
		  /* 820EC314h */ case    2:  		/* addi R25, R25, 4 */
		/* 820EC314h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 820EC314h case    2:*/		return 0x820EC318;
		  /* 820EC318h */ case    3:  		/* cmplw CR6, R30, R23 */
		/* 820EC318h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R23);
		/* 820EC318h case    3:*/		return 0x820EC31C;
		  /* 820EC31Ch */ case    4:  		/* bc 12, CR6_LT, -252 */
		/* 820EC31Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820EC220;  }
		/* 820EC31Ch case    4:*/		return 0x820EC320;
	}
	return 0x820EC320;
} // Block from 820EC30Ch-820EC320h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EC320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC320);
		  /* 820EC320h */ case    0:  		/* lwz R11, <#[R20]> */
		/* 820EC320h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 820EC320h case    0:*/		return 0x820EC324;
		  /* 820EC324h */ case    1:  		/* add R11, R11, R23 */
		/* 820EC324h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R23);
		/* 820EC324h case    1:*/		return 0x820EC328;
		  /* 820EC328h */ case    2:  		/* stw R11, <#[R20]> */
		/* 820EC328h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 820EC328h case    2:*/		return 0x820EC32C;
	}
	return 0x820EC32C;
} // Block from 820EC320h-820EC32Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EC32Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC32C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC32C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC32C);
		  /* 820EC32Ch */ case    0:  		/* lwz R25, <#[R1 + 2396]> */
		/* 820EC32Ch case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x0000095C) );
		/* 820EC32Ch case    0:*/		return 0x820EC330;
	}
	return 0x820EC330;
} // Block from 820EC32Ch-820EC330h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC330);
		  /* 820EC330h */ case    0:  		/* addi R22, R22, 1 */
		/* 820EC330h case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 820EC330h case    0:*/		return 0x820EC334;
	}
	return 0x820EC334;
} // Block from 820EC330h-820EC334h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC334);
		  /* 820EC334h */ case    0:  		/* cmplw CR6, R22, R19 */
		/* 820EC334h case    0:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R19);
		/* 820EC334h case    0:*/		return 0x820EC338;
		  /* 820EC338h */ case    1:  		/* bc 4, CR6_LT, 220 */
		/* 820EC338h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820EC414;  }
		/* 820EC338h case    1:*/		return 0x820EC33C;
		  /* 820EC33Ch */ case    2:  		/* b -2932 */
		/* 820EC33Ch case    2:*/		return 0x820EB7C8;
		/* 820EC33Ch case    2:*/		return 0x820EC340;
	}
	return 0x820EC340;
} // Block from 820EC334h-820EC340h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EC340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC340);
		  /* 820EC340h */ case    0:  		/* lis R11, -32254 */
		/* 820EC340h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EC340h case    0:*/		return 0x820EC344;
		  /* 820EC344h */ case    1:  		/* li R5, 4831 */
		/* 820EC344h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x12DF);
		/* 820EC344h case    1:*/		return 0x820EC348;
		  /* 820EC348h */ case    2:  		/* addi R6, R11, -17984 */
		/* 820EC348h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB9C0);
		/* 820EC348h case    2:*/		return 0x820EC34C;
		  /* 820EC34Ch */ case    3:  		/* mr R3, R24 */
		/* 820EC34Ch case    3:*/		regs.R3 = regs.R24;
		/* 820EC34Ch case    3:*/		return 0x820EC350;
		  /* 820EC350h */ case    4:  		/* lwz R4, <#[R26 + 60]> */
		/* 820EC350h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x0000003C) );
		/* 820EC350h case    4:*/		return 0x820EC354;
		  /* 820EC354h */ case    5:  		/* bl 140252 */
		/* 820EC354h case    5:*/		regs.LR = 0x820EC358; return 0x8210E730;
		/* 820EC354h case    5:*/		return 0x820EC358;
		  /* 820EC358h */ case    6:  		/* lis R3, -32768 */
		/* 820EC358h case    6:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820EC358h case    6:*/		return 0x820EC35C;
		  /* 820EC35Ch */ case    7:  		/* ori R3, R3, 16389 */
		/* 820EC35Ch case    7:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820EC35Ch case    7:*/		return 0x820EC360;
		  /* 820EC360h */ case    8:  		/* b 184 */
		/* 820EC360h case    8:*/		return 0x820EC418;
		/* 820EC360h case    8:*/		return 0x820EC364;
	}
	return 0x820EC364;
} // Block from 820EC340h-820EC364h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820EC364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC364);
		  /* 820EC364h */ case    0:  		/* lis R11, -32254 */
		/* 820EC364h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EC364h case    0:*/		return 0x820EC368;
		  /* 820EC368h */ case    1:  		/* li R5, 4832 */
		/* 820EC368h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x12E0);
		/* 820EC368h case    1:*/		return 0x820EC36C;
		  /* 820EC36Ch */ case    2:  		/* addi R6, R11, -18036 */
		/* 820EC36Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB98C);
		/* 820EC36Ch case    2:*/		return 0x820EC370;
		  /* 820EC370h */ case    3:  		/* b -36 */
		/* 820EC370h case    3:*/		return 0x820EC34C;
		/* 820EC370h case    3:*/		return 0x820EC374;
	}
	return 0x820EC374;
} // Block from 820EC364h-820EC374h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EC374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC374);
		  /* 820EC374h */ case    0:  		/* lis R3, -32761 */
		/* 820EC374h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820EC374h case    0:*/		return 0x820EC378;
		  /* 820EC378h */ case    1:  		/* ori R3, R3, 14 */
		/* 820EC378h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820EC378h case    1:*/		return 0x820EC37C;
		  /* 820EC37Ch */ case    2:  		/* b 156 */
		/* 820EC37Ch case    2:*/		return 0x820EC418;
		/* 820EC37Ch case    2:*/		return 0x820EC380;
	}
	return 0x820EC380;
} // Block from 820EC374h-820EC380h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EC380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC380);
		  /* 820EC380h */ case    0:  		/* lis R11, -32254 */
		/* 820EC380h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EC380h case    0:*/		return 0x820EC384;
		  /* 820EC384h */ case    1:  		/* li R5, 4833 */
		/* 820EC384h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x12E1);
		/* 820EC384h case    1:*/		return 0x820EC388;
		  /* 820EC388h */ case    2:  		/* addi R6, R11, -18068 */
		/* 820EC388h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB96C);
		/* 820EC388h case    2:*/		return 0x820EC38C;
		  /* 820EC38Ch */ case    3:  		/* b -64 */
		/* 820EC38Ch case    3:*/		return 0x820EC34C;
		/* 820EC38Ch case    3:*/		return 0x820EC390;
	}
	return 0x820EC390;
} // Block from 820EC380h-820EC390h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EC390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC390);
		  /* 820EC390h */ case    0:  		/* mr R3, R31 */
		/* 820EC390h case    0:*/		regs.R3 = regs.R31;
		/* 820EC390h case    0:*/		return 0x820EC394;
	}
	return 0x820EC394;
} // Block from 820EC390h-820EC394h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC394);
		  /* 820EC394h */ case    0:  		/* bl 1249324 */
		/* 820EC394h case    0:*/		regs.LR = 0x820EC398; return 0x8221D3C0;
		/* 820EC394h case    0:*/		return 0x820EC398;
		  /* 820EC398h */ case    1:  		/* mr R3, R31 */
		/* 820EC398h case    1:*/		regs.R3 = regs.R31;
		/* 820EC398h case    1:*/		return 0x820EC39C;
		  /* 820EC39Ch */ case    2:  		/* bl 66132 */
		/* 820EC39Ch case    2:*/		regs.LR = 0x820EC3A0; return 0x820FC5F0;
		/* 820EC39Ch case    2:*/		return 0x820EC3A0;
		  /* 820EC3A0h */ case    3:  		/* mr R3, R30 */
		/* 820EC3A0h case    3:*/		regs.R3 = regs.R30;
		/* 820EC3A0h case    3:*/		return 0x820EC3A4;
		  /* 820EC3A4h */ case    4:  		/* b 116 */
		/* 820EC3A4h case    4:*/		return 0x820EC418;
		/* 820EC3A4h case    4:*/		return 0x820EC3A8;
	}
	return 0x820EC3A8;
} // Block from 820EC394h-820EC3A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EC3A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC3A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC3A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC3A8);
		  /* 820EC3A8h */ case    0:  		/* lis R11, -32254 */
		/* 820EC3A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EC3A8h case    0:*/		return 0x820EC3AC;
		  /* 820EC3ACh */ case    1:  		/* li R5, 4832 */
		/* 820EC3ACh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x12E0);
		/* 820EC3ACh case    1:*/		return 0x820EC3B0;
		  /* 820EC3B0h */ case    2:  		/* addi R6, R11, -18128 */
		/* 820EC3B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB930);
		/* 820EC3B0h case    2:*/		return 0x820EC3B4;
		  /* 820EC3B4h */ case    3:  		/* b -104 */
		/* 820EC3B4h case    3:*/		return 0x820EC34C;
		/* 820EC3B4h case    3:*/		return 0x820EC3B8;
	}
	return 0x820EC3B8;
} // Block from 820EC3A8h-820EC3B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EC3B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC3B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC3B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC3B8);
		  /* 820EC3B8h */ case    0:  		/* lwz R11, <#[R1 + 2396]> */
		/* 820EC3B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000095C) );
		/* 820EC3B8h case    0:*/		return 0x820EC3BC;
		  /* 820EC3BCh */ case    1:  		/* stw R22, <#[R11]> */
		/* 820EC3BCh case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000000) );
		/* 820EC3BCh case    1:*/		return 0x820EC3C0;
		  /* 820EC3C0h */ case    2:  		/* b 84 */
		/* 820EC3C0h case    2:*/		return 0x820EC414;
		/* 820EC3C0h case    2:*/		return 0x820EC3C4;
	}
	return 0x820EC3C4;
} // Block from 820EC3B8h-820EC3C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EC3C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC3C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC3C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC3C4);
		  /* 820EC3C4h */ case    0:  		/* lis R11, -32254 */
		/* 820EC3C4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EC3C4h case    0:*/		return 0x820EC3C8;
		  /* 820EC3C8h */ case    1:  		/* li R5, 4500 */
		/* 820EC3C8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x1194);
		/* 820EC3C8h case    1:*/		return 0x820EC3CC;
		  /* 820EC3CCh */ case    2:  		/* addi R6, R11, -18160 */
		/* 820EC3CCh case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB910);
		/* 820EC3CCh case    2:*/		return 0x820EC3D0;
		  /* 820EC3D0h */ case    3:  		/* b -132 */
		/* 820EC3D0h case    3:*/		return 0x820EC34C;
		/* 820EC3D0h case    3:*/		return 0x820EC3D4;
	}
	return 0x820EC3D4;
} // Block from 820EC3C4h-820EC3D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EC3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC3D4);
		  /* 820EC3D4h */ case    0:  		/* mr R3, R29 */
		/* 820EC3D4h case    0:*/		regs.R3 = regs.R29;
		/* 820EC3D4h case    0:*/		return 0x820EC3D8;
	}
	return 0x820EC3D8;
} // Block from 820EC3D4h-820EC3D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC3D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC3D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC3D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC3D8);
		  /* 820EC3D8h */ case    0:  		/* bl 1249256 */
		/* 820EC3D8h case    0:*/		regs.LR = 0x820EC3DC; return 0x8221D3C0;
		/* 820EC3D8h case    0:*/		return 0x820EC3DC;
		  /* 820EC3DCh */ case    1:  		/* mr R3, R29 */
		/* 820EC3DCh case    1:*/		regs.R3 = regs.R29;
		/* 820EC3DCh case    1:*/		return 0x820EC3E0;
		  /* 820EC3E0h */ case    2:  		/* bl 66064 */
		/* 820EC3E0h case    2:*/		regs.LR = 0x820EC3E4; return 0x820FC5F0;
		/* 820EC3E0h case    2:*/		return 0x820EC3E4;
		  /* 820EC3E4h */ case    3:  		/* mr R3, R31 */
		/* 820EC3E4h case    3:*/		regs.R3 = regs.R31;
		/* 820EC3E4h case    3:*/		return 0x820EC3E8;
		  /* 820EC3E8h */ case    4:  		/* b 48 */
		/* 820EC3E8h case    4:*/		return 0x820EC418;
		/* 820EC3E8h case    4:*/		return 0x820EC3EC;
	}
	return 0x820EC3EC;
} // Block from 820EC3D8h-820EC3ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EC3ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC3EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC3EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC3EC);
		  /* 820EC3ECh */ case    0:  		/* mr R31, R3 */
		/* 820EC3ECh case    0:*/		regs.R31 = regs.R3;
		/* 820EC3ECh case    0:*/		return 0x820EC3F0;
		  /* 820EC3F0h */ case    1:  		/* b -28 */
		/* 820EC3F0h case    1:*/		return 0x820EC3D4;
		/* 820EC3F0h case    1:*/		return 0x820EC3F4;
	}
	return 0x820EC3F4;
} // Block from 820EC3ECh-820EC3F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EC3F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC3F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC3F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC3F4);
		  /* 820EC3F4h */ case    0:  		/* lis R31, -32761 */
		/* 820EC3F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820EC3F4h case    0:*/		return 0x820EC3F8;
		  /* 820EC3F8h */ case    1:  		/* ori R31, R31, 14 */
		/* 820EC3F8h case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820EC3F8h case    1:*/		return 0x820EC3FC;
		  /* 820EC3FCh */ case    2:  		/* b -40 */
		/* 820EC3FCh case    2:*/		return 0x820EC3D4;
		/* 820EC3FCh case    2:*/		return 0x820EC400;
	}
	return 0x820EC400;
} // Block from 820EC3F4h-820EC400h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EC400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC400);
		  /* 820EC400h */ case    0:  		/* lis R11, -32254 */
		/* 820EC400h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EC400h case    0:*/		return 0x820EC404;
		  /* 820EC404h */ case    1:  		/* li R5, 4833 */
		/* 820EC404h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x12E1);
		/* 820EC404h case    1:*/		return 0x820EC408;
		  /* 820EC408h */ case    2:  		/* addi R6, R11, -18200 */
		/* 820EC408h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB8E8);
		/* 820EC408h case    2:*/		return 0x820EC40C;
		  /* 820EC40Ch */ case    3:  		/* b -192 */
		/* 820EC40Ch case    3:*/		return 0x820EC34C;
		/* 820EC40Ch case    3:*/		return 0x820EC410;
	}
	return 0x820EC410;
} // Block from 820EC400h-820EC410h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EC410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC410);
		  /* 820EC410h */ case    0:  		/* stw R22, <#[R25]> */
		/* 820EC410h case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R25 + 0x00000000) );
		/* 820EC410h case    0:*/		return 0x820EC414;
	}
	return 0x820EC414;
} // Block from 820EC410h-820EC414h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC414);
		  /* 820EC414h */ case    0:  		/* li R3, 0 */
		/* 820EC414h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EC414h case    0:*/		return 0x820EC418;
	}
	return 0x820EC418;
} // Block from 820EC414h-820EC418h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC418);
		  /* 820EC418h */ case    0:  		/* addi R1, R1, 2352 */
		/* 820EC418h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x930);
		/* 820EC418h case    0:*/		return 0x820EC41C;
		  /* 820EC41Ch */ case    1:  		/* lfd FR31, <#[R1 - 160]> */
		/* 820EC41Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820EC41Ch case    1:*/		return 0x820EC420;
		  /* 820EC420h */ case    2:  		/* b -373168 */
		/* 820EC420h case    2:*/		return 0x82091270;
		/* 820EC420h case    2:*/		return 0x820EC424;
		  /* 820EC424h */ case    3:  		/* nop */
		/* 820EC424h case    3:*/		cpu::op::nop();
		/* 820EC424h case    3:*/		return 0x820EC428;
	}
	return 0x820EC428;
} // Block from 820EC418h-820EC428h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EC428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC428);
		  /* 820EC428h */ case    0:  		/* mfspr R12, LR */
		/* 820EC428h case    0:*/		regs.R12 = regs.LR;
		/* 820EC428h case    0:*/		return 0x820EC42C;
		  /* 820EC42Ch */ case    1:  		/* bl -373220 */
		/* 820EC42Ch case    1:*/		regs.LR = 0x820EC430; return 0x82091248;
		/* 820EC42Ch case    1:*/		return 0x820EC430;
		  /* 820EC430h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820EC430h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820EC430h case    2:*/		return 0x820EC434;
		  /* 820EC434h */ case    3:  		/* lwz R11, <#[R5 + 16]> */
		/* 820EC434h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000010) );
		/* 820EC434h case    3:*/		return 0x820EC438;
		  /* 820EC438h */ case    4:  		/* mr R27, R5 */
		/* 820EC438h case    4:*/		regs.R27 = regs.R5;
		/* 820EC438h case    4:*/		return 0x820EC43C;
		  /* 820EC43Ch */ case    5:  		/* lwz R10, <#[R3 + 20]> */
		/* 820EC43Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 820EC43Ch case    5:*/		return 0x820EC440;
		  /* 820EC440h */ case    6:  		/* mr R24, R6 */
		/* 820EC440h case    6:*/		regs.R24 = regs.R6;
		/* 820EC440h case    6:*/		return 0x820EC444;
		  /* 820EC444h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820EC444h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820EC444h case    7:*/		return 0x820EC448;
		  /* 820EC448h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EC448h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EC448h case    8:*/		return 0x820EC44C;
		  /* 820EC44Ch */ case    9:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EC44Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EC44Ch case    9:*/		return 0x820EC450;
		  /* 820EC450h */ case   10:  		/* lwz R25, <#[R11 + 84]> */
		/* 820EC450h case   10:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x00000054) );
		/* 820EC450h case   10:*/		return 0x820EC454;
		  /* 820EC454h */ case   11:  		/* lwz R29, <#[R11 + 72]> */
		/* 820EC454h case   11:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000048) );
		/* 820EC454h case   11:*/		return 0x820EC458;
		  /* 820EC458h */ case   12:  		/* cmpwi CR6, R25, -1 */
		/* 820EC458h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R25,0xFFFFFFFF);
		/* 820EC458h case   12:*/		return 0x820EC45C;
		  /* 820EC45Ch */ case   13:  		/* bc 12, CR6_EQ, 664 */
		/* 820EC45Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820EC6F4;  }
		/* 820EC45Ch case   13:*/		return 0x820EC460;
		  /* 820EC460h */ case   14:  		/* lwz R30, <#[R5 + 4]> */
		/* 820EC460h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R5 + 0x00000004) );
		/* 820EC460h case   14:*/		return 0x820EC464;
		  /* 820EC464h */ case   15:  		/* li R31, 0 */
		/* 820EC464h case   15:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820EC464h case   15:*/		return 0x820EC468;
		  /* 820EC468h */ case   16:  		/* cmplwi CR6, R30, 0 */
		/* 820EC468h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820EC468h case   16:*/		return 0x820EC46C;
		  /* 820EC46Ch */ case   17:  		/* bc 12, CR6_EQ, 80 */
		/* 820EC46Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x820EC4BC;  }
		/* 820EC46Ch case   17:*/		return 0x820EC470;
		  /* 820EC470h */ case   18:  		/* lwz R9, <#[R5 + 8]> */
		/* 820EC470h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000008) );
		/* 820EC470h case   18:*/		return 0x820EC474;
		  /* 820EC474h */ case   19:  		/* li R11, 0 */
		/* 820EC474h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820EC474h case   19:*/		return 0x820EC478;
		  /* 820EC478h */ case   20:  		/* lwz R5, <#[R3 + 136]> */
		/* 820EC478h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000088) );
		/* 820EC478h case   20:*/		return 0x820EC47C;
		  /* 820EC47Ch */ case   21:  		/* rlwinm R6, R10, 0, 0, 31 */
		/* 820EC47Ch case   21:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R6,regs.R10);
		/* 820EC47Ch case   21:*/		return 0x820EC480;
		  /* 820EC480h */ case   22:  		/* lwzx R10, <#[R11 + R9]> */
		/* 820EC480h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EC480h case   22:*/		return 0x820EC484;
		  /* 820EC484h */ case   23:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EC484h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EC484h case   23:*/		return 0x820EC488;
		  /* 820EC488h */ case   24:  		/* lwzx R10, <#[R10 + R6]> */
		/* 820EC488h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 820EC488h case   24:*/		return 0x820EC48C;
		  /* 820EC48Ch */ case   25:  		/* lwz R28, <#[R10 + 4]> */
		/* 820EC48Ch case   25:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + 0x00000004) );
		/* 820EC48Ch case   25:*/		return 0x820EC490;
		  /* 820EC490h */ case   26:  		/* cmplw CR6, R5, R28 */
		/* 820EC490h case   26:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R28);
		/* 820EC490h case   26:*/		return 0x820EC494;
		  /* 820EC494h */ case   27:  		/* bc 4, CR6_EQ, 24 */
		/* 820EC494h case   27:*/		if ( !regs.CR[6].eq ) { return 0x820EC4AC;  }
		/* 820EC494h case   27:*/		return 0x820EC498;
		  /* 820EC498h */ case   28:  		/* lwz R10, <#[R10 + 80]> */
		/* 820EC498h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000050) );
		/* 820EC498h case   28:*/		return 0x820EC49C;
		  /* 820EC49Ch */ case   29:  		/* cmplw CR6, R10, R29 */
		/* 820EC49Ch case   29:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 820EC49Ch case   29:*/		return 0x820EC4A0;
		  /* 820EC4A0h */ case   30:  		/* bc 4, CR6_GT, 12 */
		/* 820EC4A0h case   30:*/		if ( !regs.CR[6].gt ) { return 0x820EC4AC;  }
		/* 820EC4A0h case   30:*/		return 0x820EC4A4;
		  /* 820EC4A4h */ case   31:  		/* cmplw CR6, R10, R25 */
		/* 820EC4A4h case   31:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R25);
		/* 820EC4A4h case   31:*/		return 0x820EC4A8;
		  /* 820EC4A8h */ case   32:  		/* bc 12, CR6_LT, 588 */
		/* 820EC4A8h case   32:*/		if ( regs.CR[6].lt ) { return 0x820EC6F4;  }
		/* 820EC4A8h case   32:*/		return 0x820EC4AC;
	}
	return 0x820EC4AC;
} // Block from 820EC428h-820EC4ACh (33 instructions)

//////////////////////////////////////////////////////
// Block at 820EC4ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC4AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC4AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC4AC);
		  /* 820EC4ACh */ case    0:  		/* addi R31, R31, 1 */
		/* 820EC4ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820EC4ACh case    0:*/		return 0x820EC4B0;
		  /* 820EC4B0h */ case    1:  		/* addi R11, R11, 4 */
		/* 820EC4B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EC4B0h case    1:*/		return 0x820EC4B4;
		  /* 820EC4B4h */ case    2:  		/* cmplw CR6, R31, R30 */
		/* 820EC4B4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 820EC4B4h case    2:*/		return 0x820EC4B8;
		  /* 820EC4B8h */ case    3:  		/* bc 12, CR6_LT, -56 */
		/* 820EC4B8h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EC480;  }
		/* 820EC4B8h case    3:*/		return 0x820EC4BC;
	}
	return 0x820EC4BC;
} // Block from 820EC4ACh-820EC4BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EC4BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC4BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC4BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC4BC);
		  /* 820EC4BCh */ case    0:  		/* lwz R11, <#[R3 + 24]> */
		/* 820EC4BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820EC4BCh case    0:*/		return 0x820EC4C0;
		  /* 820EC4C0h */ case    1:  		/* rlwinm R10, R25, 2, 0, 29 */
		/* 820EC4C0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R25);
		/* 820EC4C0h case    1:*/		return 0x820EC4C4;
		  /* 820EC4C4h */ case    2:  		/* lwzx R26, <#[R10 + R11]> */
		/* 820EC4C4h case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EC4C4h case    2:*/		return 0x820EC4C8;
		  /* 820EC4C8h */ case    3:  		/* lwz R30, <#[R26]> */
		/* 820EC4C8h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000000) );
		/* 820EC4C8h case    3:*/		return 0x820EC4CC;
		  /* 820EC4CCh */ case    4:  		/* cmplw CR6, R4, R30 */
		/* 820EC4CCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R30);
		/* 820EC4CCh case    4:*/		return 0x820EC4D0;
		  /* 820EC4D0h */ case    5:  		/* bc 4, CR6_EQ, 548 */
		/* 820EC4D0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820EC6F4;  }
		/* 820EC4D0h case    5:*/		return 0x820EC4D4;
		  /* 820EC4D4h */ case    6:  		/* lwz R31, <#[R27 + 12]> */
		/* 820EC4D4h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R27 + 0x0000000C) );
		/* 820EC4D4h case    6:*/		return 0x820EC4D8;
		  /* 820EC4D8h */ case    7:  		/* li R5, 0 */
		/* 820EC4D8h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EC4D8h case    7:*/		return 0x820EC4DC;
		  /* 820EC4DCh */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 820EC4DCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820EC4DCh case    8:*/		return 0x820EC4E0;
		  /* 820EC4E0h */ case    9:  		/* bc 12, CR6_EQ, 104 */
		/* 820EC4E0h case    9:*/		if ( regs.CR[6].eq ) { return 0x820EC548;  }
		/* 820EC4E0h case    9:*/		return 0x820EC4E4;
		  /* 820EC4E4h */ case   10:  		/* lwz R9, <#[R27 + 16]> */
		/* 820EC4E4h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000010) );
		/* 820EC4E4h case   10:*/		return 0x820EC4E8;
		  /* 820EC4E8h */ case   11:  		/* li R10, 0 */
		/* 820EC4E8h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820EC4E8h case   11:*/		return 0x820EC4EC;
		  /* 820EC4ECh */ case   12:  		/* lwz R6, <#[R3 + 20]> */
		/* 820EC4ECh case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000014) );
		/* 820EC4ECh case   12:*/		return 0x820EC4F0;
		  /* 820EC4F0h */ case   13:  		/* lwzx R11, <#[R10 + R9]> */
		/* 820EC4F0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EC4F0h case   13:*/		return 0x820EC4F4;
		  /* 820EC4F4h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EC4F4h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EC4F4h case   14:*/		return 0x820EC4F8;
		  /* 820EC4F8h */ case   15:  		/* lwzx R11, <#[R11 + R6]> */
		/* 820EC4F8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 820EC4F8h case   15:*/		return 0x820EC4FC;
		  /* 820EC4FCh */ case   16:  		/* lwz R28, <#[R11 + 84]> */
		/* 820EC4FCh case   16:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000054) );
		/* 820EC4FCh case   16:*/		return 0x820EC500;
		  /* 820EC500h */ case   17:  		/* cmplw CR6, R28, R25 */
		/* 820EC500h case   17:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R25);
		/* 820EC500h case   17:*/		return 0x820EC504;
		  /* 820EC504h */ case   18:  		/* bc 4, CR6_EQ, 496 */
		/* 820EC504h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820EC6F4;  }
		/* 820EC504h case   18:*/		return 0x820EC508;
		  /* 820EC508h */ case   19:  		/* lwz R28, <#[R11 + 88]> */
		/* 820EC508h case   19:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000058) );
		/* 820EC508h case   19:*/		return 0x820EC50C;
		  /* 820EC50Ch */ case   20:  		/* cmplw CR6, R28, R25 */
		/* 820EC50Ch case   20:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R25);
		/* 820EC50Ch case   20:*/		return 0x820EC510;
		  /* 820EC510h */ case   21:  		/* bc 4, CR6_EQ, 484 */
		/* 820EC510h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820EC6F4;  }
		/* 820EC510h case   21:*/		return 0x820EC514;
		  /* 820EC514h */ case   22:  		/* lwz R11, <#[R11 + 92]> */
		/* 820EC514h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000005C) );
		/* 820EC514h case   22:*/		return 0x820EC518;
		  /* 820EC518h */ case   23:  		/* cmplwi CR6, R31, 1 */
		/* 820EC518h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000001);
		/* 820EC518h case   23:*/		return 0x820EC51C;
		  /* 820EC51Ch */ case   24:  		/* bc 4, CR6_EQ, 20 */
		/* 820EC51Ch case   24:*/		if ( !regs.CR[6].eq ) { return 0x820EC530;  }
		/* 820EC51Ch case   24:*/		return 0x820EC520;
		  /* 820EC520h */ case   25:  		/* rlwinm R28, R4, 0, 12, 31 */
		/* 820EC520h case   25:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R4);
		/* 820EC520h case   25:*/		return 0x820EC524;
		  /* 820EC524h */ case   26:  		/* mullw R28, R28, R8 */
		/* 820EC524h case   26:*/		cpu::op::mullw<0>(regs,&regs.R28,regs.R28,regs.R8);
		/* 820EC524h case   26:*/		return 0x820EC528;
		  /* 820EC528h */ case   27:  		/* cmplw CR6, R11, R28 */
		/* 820EC528h case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 820EC528h case   27:*/		return 0x820EC52C;
		  /* 820EC52Ch */ case   28:  		/* b 8 */
		/* 820EC52Ch case   28:*/		return 0x820EC534;
		/* 820EC52Ch case   28:*/		return 0x820EC530;
	}
	return 0x820EC530;
} // Block from 820EC4BCh-820EC530h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820EC530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC530);
		  /* 820EC530h */ case    0:  		/* cmplw CR6, R11, R8 */
		/* 820EC530h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820EC530h case    0:*/		return 0x820EC534;
	}
	return 0x820EC534;
} // Block from 820EC530h-820EC534h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC534);
		  /* 820EC534h */ case    0:  		/* bc 4, CR6_EQ, 448 */
		/* 820EC534h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820EC6F4;  }
		/* 820EC534h case    0:*/		return 0x820EC538;
		  /* 820EC538h */ case    1:  		/* addi R5, R5, 1 */
		/* 820EC538h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820EC538h case    1:*/		return 0x820EC53C;
		  /* 820EC53Ch */ case    2:  		/* addi R10, R10, 4 */
		/* 820EC53Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EC53Ch case    2:*/		return 0x820EC540;
		  /* 820EC540h */ case    3:  		/* cmplw CR6, R5, R31 */
		/* 820EC540h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R31);
		/* 820EC540h case    3:*/		return 0x820EC544;
		  /* 820EC544h */ case    4:  		/* bc 12, CR6_LT, -84 */
		/* 820EC544h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EC4F0;  }
		/* 820EC544h case    4:*/		return 0x820EC548;
	}
	return 0x820EC548;
} // Block from 820EC534h-820EC548h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EC548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC548);
		  /* 820EC548h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 820EC548h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 820EC548h case    0:*/		return 0x820EC54C;
		  /* 820EC54Ch */ case    1:  		/* rlwinm R28, R30, 0, 12, 31 */
		/* 820EC54Ch case    1:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R30);
		/* 820EC54Ch case    1:*/		return 0x820EC550;
		  /* 820EC550h */ case    2:  		/* cmplw CR6, R11, R28 */
		/* 820EC550h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 820EC550h case    2:*/		return 0x820EC554;
		  /* 820EC554h */ case    3:  		/* bc 4, CR6_EQ, 416 */
		/* 820EC554h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820EC6F4;  }
		/* 820EC554h case    3:*/		return 0x820EC558;
		  /* 820EC558h */ case    4:  		/* lwz R6, <#[R26 + 4]> */
		/* 820EC558h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000004) );
		/* 820EC558h case    4:*/		return 0x820EC55C;
		  /* 820EC55Ch */ case    5:  		/* mullw R11, R28, R7 */
		/* 820EC55Ch case    5:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R28,regs.R7);
		/* 820EC55Ch case    5:*/		return 0x820EC560;
		  /* 820EC560h */ case    6:  		/* cmplw CR6, R6, R11 */
		/* 820EC560h case    6:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820EC560h case    6:*/		return 0x820EC564;
		  /* 820EC564h */ case    7:  		/* bc 12, CR6_GT, 400 */
		/* 820EC564h case    7:*/		if ( regs.CR[6].gt ) { return 0x820EC6F4;  }
		/* 820EC564h case    7:*/		return 0x820EC568;
		  /* 820EC568h */ case    8:  		/* li R5, 0 */
		/* 820EC568h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EC568h case    8:*/		return 0x820EC56C;
		  /* 820EC56Ch */ case    9:  		/* cmplwi CR6, R6, 0 */
		/* 820EC56Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820EC56Ch case    9:*/		return 0x820EC570;
		  /* 820EC570h */ case   10:  		/* bc 12, CR6_EQ, 72 */
		/* 820EC570h case   10:*/		if ( regs.CR[6].eq ) { return 0x820EC5B8;  }
		/* 820EC570h case   10:*/		return 0x820EC574;
		  /* 820EC574h */ case   11:  		/* lwz R9, <#[R26 + 8]> */
		/* 820EC574h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000008) );
		/* 820EC574h case   11:*/		return 0x820EC578;
		  /* 820EC578h */ case   12:  		/* li R11, 0 */
		/* 820EC578h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820EC578h case   12:*/		return 0x820EC57C;
		  /* 820EC57Ch */ case   13:  		/* lwz R8, <#[R3 + 20]> */
		/* 820EC57Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 820EC57Ch case   13:*/		return 0x820EC580;
		  /* 820EC580h */ case   14:  		/* lwz R7, <#[R3 + 136]> */
		/* 820EC580h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000088) );
		/* 820EC580h case   14:*/		return 0x820EC584;
		  /* 820EC584h */ case   15:  		/* lwzx R10, <#[R11 + R9]> */
		/* 820EC584h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EC584h case   15:*/		return 0x820EC588;
		  /* 820EC588h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EC588h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EC588h case   16:*/		return 0x820EC58C;
		  /* 820EC58Ch */ case   17:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820EC58Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820EC58Ch case   17:*/		return 0x820EC590;
		  /* 820EC590h */ case   18:  		/* lwz R4, <#[R10 + 4]> */
		/* 820EC590h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 820EC590h case   18:*/		return 0x820EC594;
		  /* 820EC594h */ case   19:  		/* cmplw CR6, R7, R4 */
		/* 820EC594h case   19:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 820EC594h case   19:*/		return 0x820EC598;
		  /* 820EC598h */ case   20:  		/* bc 4, CR6_EQ, 16 */
		/* 820EC598h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820EC5A8;  }
		/* 820EC598h case   20:*/		return 0x820EC59C;
		  /* 820EC59Ch */ case   21:  		/* lwz R10, <#[R10 + 72]> */
		/* 820EC59Ch case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 820EC59Ch case   21:*/		return 0x820EC5A0;
		  /* 820EC5A0h */ case   22:  		/* cmplw CR6, R10, R29 */
		/* 820EC5A0h case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 820EC5A0h case   22:*/		return 0x820EC5A4;
		  /* 820EC5A4h */ case   23:  		/* bc 12, CR6_GT, 336 */
		/* 820EC5A4h case   23:*/		if ( regs.CR[6].gt ) { return 0x820EC6F4;  }
		/* 820EC5A4h case   23:*/		return 0x820EC5A8;
	}
	return 0x820EC5A8;
} // Block from 820EC548h-820EC5A8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820EC5A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC5A8);
		  /* 820EC5A8h */ case    0:  		/* addi R5, R5, 1 */
		/* 820EC5A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820EC5A8h case    0:*/		return 0x820EC5AC;
		  /* 820EC5ACh */ case    1:  		/* addi R11, R11, 4 */
		/* 820EC5ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EC5ACh case    1:*/		return 0x820EC5B0;
		  /* 820EC5B0h */ case    2:  		/* cmplw CR6, R5, R6 */
		/* 820EC5B0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 820EC5B0h case    2:*/		return 0x820EC5B4;
		  /* 820EC5B4h */ case    3:  		/* bc 12, CR6_LT, -48 */
		/* 820EC5B4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EC584;  }
		/* 820EC5B4h case    3:*/		return 0x820EC5B8;
	}
	return 0x820EC5B8;
} // Block from 820EC5A8h-820EC5B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EC5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC5B8);
		  /* 820EC5B8h */ case    0:  		/* li R10, 0 */
		/* 820EC5B8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820EC5B8h case    0:*/		return 0x820EC5BC;
		  /* 820EC5BCh */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 820EC5BCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820EC5BCh case    1:*/		return 0x820EC5C0;
		  /* 820EC5C0h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 820EC5C0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EC5F0;  }
		/* 820EC5C0h case    2:*/		return 0x820EC5C4;
		  /* 820EC5C4h */ case    3:  		/* lwz R8, <#[R27 + 16]> */
		/* 820EC5C4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000010) );
		/* 820EC5C4h case    3:*/		return 0x820EC5C8;
		  /* 820EC5C8h */ case    4:  		/* li R11, 0 */
		/* 820EC5C8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820EC5C8h case    4:*/		return 0x820EC5CC;
		  /* 820EC5CCh */ case    5:  		/* lwz R9, <#[R26 + 8]> */
		/* 820EC5CCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000008) );
		/* 820EC5CCh case    5:*/		return 0x820EC5D0;
		  /* 820EC5D0h */ case    6:  		/* lwz R8, <#[R8]> */
		/* 820EC5D0h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 820EC5D0h case    6:*/		return 0x820EC5D4;
		  /* 820EC5D4h */ case    7:  		/* lwzx R7, <#[R11 + R9]> */
		/* 820EC5D4h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EC5D4h case    7:*/		return 0x820EC5D8;
		  /* 820EC5D8h */ case    8:  		/* cmplw CR6, R7, R8 */
		/* 820EC5D8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 820EC5D8h case    8:*/		return 0x820EC5DC;
		  /* 820EC5DCh */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 820EC5DCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820EC5F0;  }
		/* 820EC5DCh case    9:*/		return 0x820EC5E0;
		  /* 820EC5E0h */ case   10:  		/* addi R10, R10, 1 */
		/* 820EC5E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EC5E0h case   10:*/		return 0x820EC5E4;
		  /* 820EC5E4h */ case   11:  		/* addi R11, R11, 4 */
		/* 820EC5E4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EC5E4h case   11:*/		return 0x820EC5E8;
		  /* 820EC5E8h */ case   12:  		/* cmplw CR6, R10, R6 */
		/* 820EC5E8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 820EC5E8h case   12:*/		return 0x820EC5EC;
		  /* 820EC5ECh */ case   13:  		/* bc 12, CR6_LT, -24 */
		/* 820EC5ECh case   13:*/		if ( regs.CR[6].lt ) { return 0x820EC5D4;  }
		/* 820EC5ECh case   13:*/		return 0x820EC5F0;
	}
	return 0x820EC5F0;
} // Block from 820EC5B8h-820EC5F0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820EC5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC5F0);
		  /* 820EC5F0h */ case    0:  		/* cmplw CR6, R10, R6 */
		/* 820EC5F0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 820EC5F0h case    0:*/		return 0x820EC5F4;
		  /* 820EC5F4h */ case    1:  		/* bc 12, CR6_EQ, 256 */
		/* 820EC5F4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC6F4;  }
		/* 820EC5F4h case    1:*/		return 0x820EC5F8;
		  /* 820EC5F8h */ case    2:  		/* cmplw CR6, R10, R28 */
		/* 820EC5F8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 820EC5F8h case    2:*/		return 0x820EC5FC;
		  /* 820EC5FCh */ case    3:  		/* bc 12, CR6_LT, 60 */
		/* 820EC5FCh case    3:*/		if ( regs.CR[6].lt ) { return 0x820EC638;  }
		/* 820EC5FCh case    3:*/		return 0x820EC600;
		  /* 820EC600h */ case    4:  		/* cmplwi CR6, R28, 0 */
		/* 820EC600h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EC600h case    4:*/		return 0x820EC604;
		  /* 820EC604h */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 820EC604h case    5:*/		if ( regs.CR[6].eq ) { return 0x820EC638;  }
		/* 820EC604h case    5:*/		return 0x820EC608;
		  /* 820EC608h */ case    6:  		/* mtspr CTR, R28 */
		/* 820EC608h case    6:*/		regs.CTR = regs.R28;
		/* 820EC608h case    6:*/		return 0x820EC60C;
		  /* 820EC60Ch */ case    7:  		/* li R11, 0 */
		/* 820EC60Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820EC60Ch case    7:*/		return 0x820EC610;
		  /* 820EC610h */ case    8:  		/* rlwinm R10, R28, 2, 0, 29 */
		/* 820EC610h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R28);
		/* 820EC610h case    8:*/		return 0x820EC614;
		  /* 820EC614h */ case    9:  		/* lwz R9, <#[R26 + 8]> */
		/* 820EC614h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000008) );
		/* 820EC614h case    9:*/		return 0x820EC618;
		  /* 820EC618h */ case   10:  		/* lwzx R8, <#[R10 + R9]> */
		/* 820EC618h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EC618h case   10:*/		return 0x820EC61C;
		  /* 820EC61Ch */ case   11:  		/* lwzx R7, <#[R11 + R9]> */
		/* 820EC61Ch case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EC61Ch case   11:*/		return 0x820EC620;
		  /* 820EC620h */ case   12:  		/* stwx R8, <#[R11 + R9]> */
		/* 820EC620h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EC620h case   12:*/		return 0x820EC624;
		  /* 820EC624h */ case   13:  		/* addi R11, R11, 4 */
		/* 820EC624h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EC624h case   13:*/		return 0x820EC628;
		  /* 820EC628h */ case   14:  		/* lwz R9, <#[R26 + 8]> */
		/* 820EC628h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000008) );
		/* 820EC628h case   14:*/		return 0x820EC62C;
		  /* 820EC62Ch */ case   15:  		/* stwx R7, <#[R10 + R9]> */
		/* 820EC62Ch case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EC62Ch case   15:*/		return 0x820EC630;
		  /* 820EC630h */ case   16:  		/* addi R10, R10, 4 */
		/* 820EC630h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EC630h case   16:*/		return 0x820EC634;
		  /* 820EC634h */ case   17:  		/* bc 16, CR0_LT, -32 */
		/* 820EC634h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EC614;  }
		/* 820EC634h case   17:*/		return 0x820EC638;
	}
	return 0x820EC638;
} // Block from 820EC5F0h-820EC638h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820EC638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC638);
		  /* 820EC638h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 820EC638h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 820EC638h case    0:*/		return 0x820EC63C;
		  /* 820EC63Ch */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 820EC63Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820EC63Ch case    1:*/		return 0x820EC640;
		  /* 820EC640h */ case    2:  		/* bc 4, CR6_GT, 160 */
		/* 820EC640h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820EC6E0;  }
		/* 820EC640h case    2:*/		return 0x820EC644;
		  /* 820EC644h */ case    3:  		/* lwz R10, <#[R27 + 4]> */
		/* 820EC644h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000004) );
		/* 820EC644h case    3:*/		return 0x820EC648;
		  /* 820EC648h */ case    4:  		/* lwz R11, <#[R27 + 8]> */
		/* 820EC648h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820EC648h case    4:*/		return 0x820EC64C;
		  /* 820EC64Ch */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EC64Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EC64Ch case    5:*/		return 0x820EC650;
		  /* 820EC650h */ case    6:  		/* mr R31, R11 */
		/* 820EC650h case    6:*/		regs.R31 = regs.R11;
		/* 820EC650h case    6:*/		return 0x820EC654;
		  /* 820EC654h */ case    7:  		/* add R30, R10, R11 */
		/* 820EC654h case    7:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 820EC654h case    7:*/		return 0x820EC658;
		  /* 820EC658h */ case    8:  		/* cmplw CR6, R11, R30 */
		/* 820EC658h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820EC658h case    8:*/		return 0x820EC65C;
		  /* 820EC65Ch */ case    9:  		/* bc 4, CR6_LT, 132 */
		/* 820EC65Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x820EC6E0;  }
		/* 820EC65Ch case    9:*/		return 0x820EC660;
		  /* 820EC660h */ case   10:  		/* rlwinm R29, R28, 2, 0, 29 */
		/* 820EC660h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R28);
		/* 820EC660h case   10:*/		return 0x820EC664;
		  /* 820EC664h */ case   11:  		/* cmplwi CR6, R28, 0 */
		/* 820EC664h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EC664h case   11:*/		return 0x820EC668;
		  /* 820EC668h */ case   12:  		/* bc 12, CR6_EQ, 92 */
		/* 820EC668h case   12:*/		if ( regs.CR[6].eq ) { return 0x820EC6C4;  }
		/* 820EC668h case   12:*/		return 0x820EC66C;
		  /* 820EC66Ch */ case   13:  		/* lwz R11, <#[R26 + 8]> */
		/* 820EC66Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820EC66Ch case   13:*/		return 0x820EC670;
		  /* 820EC670h */ case   14:  		/* mr R9, R31 */
		/* 820EC670h case   14:*/		regs.R9 = regs.R31;
		/* 820EC670h case   14:*/		return 0x820EC674;
		  /* 820EC674h */ case   15:  		/* lwz R6, <#[R27 + 16]> */
		/* 820EC674h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R27 + 0x00000010) );
		/* 820EC674h case   15:*/		return 0x820EC678;
		  /* 820EC678h */ case   16:  		/* mtspr CTR, R28 */
		/* 820EC678h case   16:*/		regs.CTR = regs.R28;
		/* 820EC678h case   16:*/		return 0x820EC67C;
		  /* 820EC67Ch */ case   17:  		/* subf R7, R31, R11 */
		/* 820EC67Ch case   17:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R31,regs.R11);
		/* 820EC67Ch case   17:*/		return 0x820EC680;
		  /* 820EC680h */ case   18:  		/* lwzx R8, <#[R7 + R9]> */
		/* 820EC680h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 820EC680h case   18:*/		return 0x820EC684;
		  /* 820EC684h */ case   19:  		/* li R10, 0 */
		/* 820EC684h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820EC684h case   19:*/		return 0x820EC688;
		  /* 820EC688h */ case   20:  		/* li R11, 0 */
		/* 820EC688h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820EC688h case   20:*/		return 0x820EC68C;
		  /* 820EC68Ch */ case   21:  		/* lwzx R5, <#[R11 + R6]> */
		/* 820EC68Ch case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 820EC68Ch case   21:*/		return 0x820EC690;
		  /* 820EC690h */ case   22:  		/* cmplw CR6, R5, R8 */
		/* 820EC690h case   22:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R8);
		/* 820EC690h case   22:*/		return 0x820EC694;
		  /* 820EC694h */ case   23:  		/* bc 12, CR6_EQ, 24 */
		/* 820EC694h case   23:*/		if ( regs.CR[6].eq ) { return 0x820EC6AC;  }
		/* 820EC694h case   23:*/		return 0x820EC698;
		  /* 820EC698h */ case   24:  		/* addi R10, R10, 1 */
		/* 820EC698h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EC698h case   24:*/		return 0x820EC69C;
		  /* 820EC69Ch */ case   25:  		/* addi R11, R11, 4 */
		/* 820EC69Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EC69Ch case   25:*/		return 0x820EC6A0;
		  /* 820EC6A0h */ case   26:  		/* cmplw CR6, R10, R28 */
		/* 820EC6A0h case   26:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 820EC6A0h case   26:*/		return 0x820EC6A4;
		  /* 820EC6A4h */ case   27:  		/* bc 12, CR6_LT, -24 */
		/* 820EC6A4h case   27:*/		if ( regs.CR[6].lt ) { return 0x820EC68C;  }
		/* 820EC6A4h case   27:*/		return 0x820EC6A8;
		  /* 820EC6A8h */ case   28:  		/* b 20 */
		/* 820EC6A8h case   28:*/		return 0x820EC6BC;
		/* 820EC6A8h case   28:*/		return 0x820EC6AC;
	}
	return 0x820EC6AC;
} // Block from 820EC638h-820EC6ACh (29 instructions)

//////////////////////////////////////////////////////
// Block at 820EC6ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC6AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC6AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC6AC);
		  /* 820EC6ACh */ case    0:  		/* lwz R11, <#[R9]> */
		/* 820EC6ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820EC6ACh case    0:*/		return 0x820EC6B0;
		  /* 820EC6B0h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EC6B0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EC6B0h case    1:*/		return 0x820EC6B4;
		  /* 820EC6B4h */ case    2:  		/* addi R8, R1, 80 */
		/* 820EC6B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 820EC6B4h case    2:*/		return 0x820EC6B8;
		  /* 820EC6B8h */ case    3:  		/* stwx R11, <#[R10 + R8]> */
		/* 820EC6B8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820EC6B8h case    3:*/		return 0x820EC6BC;
	}
	return 0x820EC6BC;
} // Block from 820EC6ACh-820EC6BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EC6BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC6BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC6BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC6BC);
		  /* 820EC6BCh */ case    0:  		/* addi R9, R9, 4 */
		/* 820EC6BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820EC6BCh case    0:*/		return 0x820EC6C0;
		  /* 820EC6C0h */ case    1:  		/* bc 16, CR0_LT, -64 */
		/* 820EC6C0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EC680;  }
		/* 820EC6C0h case    1:*/		return 0x820EC6C4;
	}
	return 0x820EC6C4;
} // Block from 820EC6BCh-820EC6C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EC6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC6C4);
		  /* 820EC6C4h */ case    0:  		/* mr R5, R29 */
		/* 820EC6C4h case    0:*/		regs.R5 = regs.R29;
		/* 820EC6C4h case    0:*/		return 0x820EC6C8;
		  /* 820EC6C8h */ case    1:  		/* addi R4, R1, 80 */
		/* 820EC6C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820EC6C8h case    1:*/		return 0x820EC6CC;
		  /* 820EC6CCh */ case    2:  		/* mr R3, R31 */
		/* 820EC6CCh case    2:*/		regs.R3 = regs.R31;
		/* 820EC6CCh case    2:*/		return 0x820EC6D0;
		  /* 820EC6D0h */ case    3:  		/* bl -372000 */
		/* 820EC6D0h case    3:*/		regs.LR = 0x820EC6D4; return 0x820919B0;
		/* 820EC6D0h case    3:*/		return 0x820EC6D4;
		  /* 820EC6D4h */ case    4:  		/* add R31, R29, R31 */
		/* 820EC6D4h case    4:*/		cpu::op::add<0>(regs,&regs.R31,regs.R29,regs.R31);
		/* 820EC6D4h case    4:*/		return 0x820EC6D8;
		  /* 820EC6D8h */ case    5:  		/* cmplw CR6, R31, R30 */
		/* 820EC6D8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 820EC6D8h case    5:*/		return 0x820EC6DC;
		  /* 820EC6DCh */ case    6:  		/* bc 12, CR6_LT, -120 */
		/* 820EC6DCh case    6:*/		if ( regs.CR[6].lt ) { return 0x820EC664;  }
		/* 820EC6DCh case    6:*/		return 0x820EC6E0;
	}
	return 0x820EC6E0;
} // Block from 820EC6C4h-820EC6E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EC6E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC6E0);
		  /* 820EC6E0h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 820EC6E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820EC6E0h case    0:*/		return 0x820EC6E4;
		  /* 820EC6E4h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820EC6E4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC6EC;  }
		/* 820EC6E4h case    1:*/		return 0x820EC6E8;
		  /* 820EC6E8h */ case    2:  		/* stw R25, <#[R24]> */
		/* 820EC6E8h case    2:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R24 + 0x00000000) );
		/* 820EC6E8h case    2:*/		return 0x820EC6EC;
	}
	return 0x820EC6EC;
} // Block from 820EC6E0h-820EC6ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EC6ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC6EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC6EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC6EC);
		  /* 820EC6ECh */ case    0:  		/* mr R3, R26 */
		/* 820EC6ECh case    0:*/		regs.R3 = regs.R26;
		/* 820EC6ECh case    0:*/		return 0x820EC6F0;
		  /* 820EC6F0h */ case    1:  		/* b 8 */
		/* 820EC6F0h case    1:*/		return 0x820EC6F8;
		/* 820EC6F0h case    1:*/		return 0x820EC6F4;
	}
	return 0x820EC6F4;
} // Block from 820EC6ECh-820EC6F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EC6F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC6F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC6F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC6F4);
		  /* 820EC6F4h */ case    0:  		/* li R3, 0 */
		/* 820EC6F4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EC6F4h case    0:*/		return 0x820EC6F8;
	}
	return 0x820EC6F8;
} // Block from 820EC6F4h-820EC6F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC6F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC6F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC6F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC6F8);
		  /* 820EC6F8h */ case    0:  		/* addi R1, R1, 176 */
		/* 820EC6F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820EC6F8h case    0:*/		return 0x820EC6FC;
		  /* 820EC6FCh */ case    1:  		/* b -373860 */
		/* 820EC6FCh case    1:*/		return 0x82091298;
		/* 820EC6FCh case    1:*/		return 0x820EC700;
	}
	return 0x820EC700;
} // Block from 820EC6F8h-820EC700h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EC700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC700);
		  /* 820EC700h */ case    0:  		/* mfspr R12, LR */
		/* 820EC700h case    0:*/		regs.R12 = regs.LR;
		/* 820EC700h case    0:*/		return 0x820EC704;
		  /* 820EC704h */ case    1:  		/* bl -373964 */
		/* 820EC704h case    1:*/		regs.LR = 0x820EC708; return 0x82091238;
		/* 820EC704h case    1:*/		return 0x820EC708;
		  /* 820EC708h */ case    2:  		/* lwz R11, <#[R5]> */
		/* 820EC708h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820EC708h case    2:*/		return 0x820EC70C;
		  /* 820EC70Ch */ case    3:  		/* rlwinm. R28, R11, 0, 12, 31 */
		/* 820EC70Ch case    3:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R28,regs.R11);
		/* 820EC70Ch case    3:*/		return 0x820EC710;
		  /* 820EC710h */ case    4:  		/* bc 12, CR0_EQ, 600 */
		/* 820EC710h case    4:*/		if ( regs.CR[0].eq ) { return 0x820EC968;  }
		/* 820EC710h case    4:*/		return 0x820EC714;
		  /* 820EC714h */ case    5:  		/* lwz R11, <#[R5 + 4]> */
		/* 820EC714h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 820EC714h case    5:*/		return 0x820EC718;
		  /* 820EC718h */ case    6:  		/* li R26, 0 */
		/* 820EC718h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820EC718h case    6:*/		return 0x820EC71C;
		  /* 820EC71Ch */ case    7:  		/* twi 6, R28, 0 */
		/* 820EC71Ch case    7:*/		cpu::op::tw<6>(regs, 0x820EC71C, regs.R28, 0x00000000);
		/* 820EC71Ch case    7:*/		return 0x820EC720;
		  /* 820EC720h */ case    8:  		/* divwu. R21, R11, R28 */
		/* 820EC720h case    8:*/		cpu::op::divwu<1>(regs,&regs.R21,regs.R11,regs.R28);
		/* 820EC720h case    8:*/		return 0x820EC724;
		  /* 820EC724h */ case    9:  		/* bc 12, CR0_EQ, 536 */
		/* 820EC724h case    9:*/		if ( regs.CR[0].eq ) { return 0x820EC93C;  }
		/* 820EC724h case    9:*/		return 0x820EC728;
		  /* 820EC728h */ case   10:  		/* mr R25, R26 */
		/* 820EC728h case   10:*/		regs.R25 = regs.R26;
		/* 820EC728h case   10:*/		return 0x820EC72C;
		  /* 820EC72Ch */ case   11:  		/* mr R29, R6 */
		/* 820EC72Ch case   11:*/		regs.R29 = regs.R6;
		/* 820EC72Ch case   11:*/		return 0x820EC730;
		  /* 820EC730h */ case   12:  		/* mr R24, R26 */
		/* 820EC730h case   12:*/		regs.R24 = regs.R26;
		/* 820EC730h case   12:*/		return 0x820EC734;
		  /* 820EC734h */ case   13:  		/* rlwinm R22, R28, 2, 0, 29 */
		/* 820EC734h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R22,regs.R28);
		/* 820EC734h case   13:*/		return 0x820EC738;
		  /* 820EC738h */ case   14:  		/* mr R23, R21 */
		/* 820EC738h case   14:*/		regs.R23 = regs.R21;
		/* 820EC738h case   14:*/		return 0x820EC73C;
		  /* 820EC73Ch */ case   15:  		/* lwz R11, <#[R5 + 8]> */
		/* 820EC73Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 820EC73Ch case   15:*/		return 0x820EC740;
		  /* 820EC740h */ case   16:  		/* lwz R10, <#[R3 + 20]> */
		/* 820EC740h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 820EC740h case   16:*/		return 0x820EC744;
		  /* 820EC744h */ case   17:  		/* lwzx R11, <#[R11 + R24]> */
		/* 820EC744h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 820EC744h case   17:*/		return 0x820EC748;
		  /* 820EC748h */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EC748h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EC748h case   18:*/		return 0x820EC74C;
		  /* 820EC74Ch */ case   19:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EC74Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EC74Ch case   19:*/		return 0x820EC750;
		  /* 820EC750h */ case   20:  		/* lwz R8, <#[R11 + 72]> */
		/* 820EC750h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000048) );
		/* 820EC750h case   20:*/		return 0x820EC754;
		  /* 820EC754h */ case   21:  		/* lwz R31, <#[R11 + 84]> */
		/* 820EC754h case   21:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000054) );
		/* 820EC754h case   21:*/		return 0x820EC758;
		  /* 820EC758h */ case   22:  		/* cmpwi CR6, R8, -1 */
		/* 820EC758h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 820EC758h case   22:*/		return 0x820EC75C;
		  /* 820EC75Ch */ case   23:  		/* bc 12, CR6_EQ, 456 */
		/* 820EC75Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x820EC924;  }
		/* 820EC75Ch case   23:*/		return 0x820EC760;
		  /* 820EC760h */ case   24:  		/* lwz R11, <#[R3 + 24]> */
		/* 820EC760h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820EC760h case   24:*/		return 0x820EC764;
		  /* 820EC764h */ case   25:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 820EC764h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 820EC764h case   25:*/		return 0x820EC768;
		  /* 820EC768h */ case   26:  		/* mr R9, R26 */
		/* 820EC768h case   26:*/		regs.R9 = regs.R26;
		/* 820EC768h case   26:*/		return 0x820EC76C;
		  /* 820EC76Ch */ case   27:  		/* cmplwi CR6, R28, 0 */
		/* 820EC76Ch case   27:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EC76Ch case   27:*/		return 0x820EC770;
		  /* 820EC770h */ case   28:  		/* lwzx R27, <#[R10 + R11]> */
		/* 820EC770h case   28:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EC770h case   28:*/		return 0x820EC774;
		  /* 820EC774h */ case   29:  		/* stw R27, <#[R29]> */
		/* 820EC774h case   29:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R29 + 0x00000000) );
		/* 820EC774h case   29:*/		return 0x820EC778;
		  /* 820EC778h */ case   30:  		/* bc 12, CR6_EQ, 124 */
		/* 820EC778h case   30:*/		if ( regs.CR[6].eq ) { return 0x820EC7F4;  }
		/* 820EC778h case   30:*/		return 0x820EC77C;
		  /* 820EC77Ch */ case   31:  		/* mtspr CTR, R28 */
		/* 820EC77Ch case   31:*/		regs.CTR = regs.R28;
		/* 820EC77Ch case   31:*/		return 0x820EC780;
		  /* 820EC780h */ case   32:  		/* add R11, R25, R9 */
		/* 820EC780h case   32:*/		cpu::op::add<0>(regs,&regs.R11,regs.R25,regs.R9);
		/* 820EC780h case   32:*/		return 0x820EC784;
		  /* 820EC784h */ case   33:  		/* lwz R10, <#[R5 + 8]> */
		/* 820EC784h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000008) );
		/* 820EC784h case   33:*/		return 0x820EC788;
		  /* 820EC788h */ case   34:  		/* lwz R30, <#[R3 + 20]> */
		/* 820EC788h case   34:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000014) );
		/* 820EC788h case   34:*/		return 0x820EC78C;
		  /* 820EC78Ch */ case   35:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EC78Ch case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EC78Ch case   35:*/		return 0x820EC790;
		  /* 820EC790h */ case   36:  		/* lwz R20, <#[R3 + 136]> */
		/* 820EC790h case   36:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R3 + 0x00000088) );
		/* 820EC790h case   36:*/		return 0x820EC794;
		  /* 820EC794h */ case   37:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EC794h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EC794h case   37:*/		return 0x820EC798;
		  /* 820EC798h */ case   38:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EC798h case   38:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EC798h case   38:*/		return 0x820EC79C;
		  /* 820EC79Ch */ case   39:  		/* lwzx R10, <#[R11 + R30]> */
		/* 820EC79Ch case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820EC79Ch case   39:*/		return 0x820EC7A0;
		  /* 820EC7A0h */ case   40:  		/* lwz R11, <#[R10 + 4]> */
		/* 820EC7A0h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820EC7A0h case   40:*/		return 0x820EC7A4;
		  /* 820EC7A4h */ case   41:  		/* cmplw CR6, R20, R11 */
		/* 820EC7A4h case   41:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R11);
		/* 820EC7A4h case   41:*/		return 0x820EC7A8;
		  /* 820EC7A8h */ case   42:  		/* bc 12, CR6_EQ, 8 */
		/* 820EC7A8h case   42:*/		if ( regs.CR[6].eq ) { return 0x820EC7B0;  }
		/* 820EC7A8h case   42:*/		return 0x820EC7AC;
		  /* 820EC7ACh */ case   43:  		/* stw R26, <#[R29]> */
		/* 820EC7ACh case   43:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R29 + 0x00000000) );
		/* 820EC7ACh case   43:*/		return 0x820EC7B0;
	}
	return 0x820EC7B0;
} // Block from 820EC700h-820EC7B0h (44 instructions)

//////////////////////////////////////////////////////
// Block at 820EC7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC7B0);
		  /* 820EC7B0h */ case    0:  		/* lwz R11, <#[R10 + 60]> */
		/* 820EC7B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000003C) );
		/* 820EC7B0h case    0:*/		return 0x820EC7B4;
		  /* 820EC7B4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820EC7B4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EC7B4h case    1:*/		return 0x820EC7B8;
		  /* 820EC7B8h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820EC7B8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EC7C0;  }
		/* 820EC7B8h case    2:*/		return 0x820EC7BC;
		  /* 820EC7BCh */ case    3:  		/* stw R26, <#[R29]> */
		/* 820EC7BCh case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R29 + 0x00000000) );
		/* 820EC7BCh case    3:*/		return 0x820EC7C0;
	}
	return 0x820EC7C0;
} // Block from 820EC7B0h-820EC7C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EC7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC7C0);
		  /* 820EC7C0h */ case    0:  		/* lwz R11, <#[R10 + 80]> */
		/* 820EC7C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000050) );
		/* 820EC7C0h case    0:*/		return 0x820EC7C4;
		  /* 820EC7C4h */ case    1:  		/* cmplw CR6, R11, R8 */
		/* 820EC7C4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820EC7C4h case    1:*/		return 0x820EC7C8;
		  /* 820EC7C8h */ case    2:  		/* bc 4, CR6_GT, 16 */
		/* 820EC7C8h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820EC7D8;  }
		/* 820EC7C8h case    2:*/		return 0x820EC7CC;
		  /* 820EC7CCh */ case    3:  		/* cmplw CR6, R11, R31 */
		/* 820EC7CCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820EC7CCh case    3:*/		return 0x820EC7D0;
		  /* 820EC7D0h */ case    4:  		/* bc 4, CR6_LT, 8 */
		/* 820EC7D0h case    4:*/		if ( !regs.CR[6].lt ) { return 0x820EC7D8;  }
		/* 820EC7D0h case    4:*/		return 0x820EC7D4;
		  /* 820EC7D4h */ case    5:  		/* stw R26, <#[R29]> */
		/* 820EC7D4h case    5:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R29 + 0x00000000) );
		/* 820EC7D4h case    5:*/		return 0x820EC7D8;
	}
	return 0x820EC7D8;
} // Block from 820EC7C0h-820EC7D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EC7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC7D8);
		  /* 820EC7D8h */ case    0:  		/* lwz R11, <#[R10 + 84]> */
		/* 820EC7D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000054) );
		/* 820EC7D8h case    0:*/		return 0x820EC7DC;
		  /* 820EC7DCh */ case    1:  		/* lwz R10, <#[R10 + 88]> */
		/* 820EC7DCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000058) );
		/* 820EC7DCh case    1:*/		return 0x820EC7E0;
		  /* 820EC7E0h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820EC7E0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EC7E0h case    2:*/		return 0x820EC7E4;
		  /* 820EC7E4h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 820EC7E4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820EC7EC;  }
		/* 820EC7E4h case    3:*/		return 0x820EC7E8;
		  /* 820EC7E8h */ case    4:  		/* stw R26, <#[R29]> */
		/* 820EC7E8h case    4:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R29 + 0x00000000) );
		/* 820EC7E8h case    4:*/		return 0x820EC7EC;
	}
	return 0x820EC7EC;
} // Block from 820EC7D8h-820EC7ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EC7ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC7EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC7EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC7EC);
		  /* 820EC7ECh */ case    0:  		/* addi R9, R9, 1 */
		/* 820EC7ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820EC7ECh case    0:*/		return 0x820EC7F0;
		  /* 820EC7F0h */ case    1:  		/* bc 16, CR0_LT, -112 */
		/* 820EC7F0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EC780;  }
		/* 820EC7F0h case    1:*/		return 0x820EC7F4;
	}
	return 0x820EC7F4;
} // Block from 820EC7ECh-820EC7F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EC7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC7F4);
		  /* 820EC7F4h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 820EC7F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820EC7F4h case    0:*/		return 0x820EC7F8;
		  /* 820EC7F8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820EC7F8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EC7F8h case    1:*/		return 0x820EC7FC;
		  /* 820EC7FCh */ case    2:  		/* bc 12, CR6_EQ, 300 */
		/* 820EC7FCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820EC928;  }
		/* 820EC7FCh case    2:*/		return 0x820EC800;
		  /* 820EC800h */ case    3:  		/* lwz R11, <#[R27]> */
		/* 820EC800h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820EC800h case    3:*/		return 0x820EC804;
		  /* 820EC804h */ case    4:  		/* cmplw CR6, R4, R11 */
		/* 820EC804h case    4:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820EC804h case    4:*/		return 0x820EC808;
		  /* 820EC808h */ case    5:  		/* bc 4, CR6_EQ, 284 */
		/* 820EC808h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820EC924;  }
		/* 820EC808h case    5:*/		return 0x820EC80C;
		  /* 820EC80Ch */ case    6:  		/* mr R11, R26 */
		/* 820EC80Ch case    6:*/		regs.R11 = regs.R26;
		/* 820EC80Ch case    6:*/		return 0x820EC810;
		  /* 820EC810h */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 820EC810h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EC810h case    7:*/		return 0x820EC814;
		  /* 820EC814h */ case    8:  		/* bc 12, CR6_EQ, 60 */
		/* 820EC814h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EC850;  }
		/* 820EC814h case    8:*/		return 0x820EC818;
		  /* 820EC818h */ case    9:  		/* mtspr CTR, R28 */
		/* 820EC818h case    9:*/		regs.CTR = regs.R28;
		/* 820EC818h case    9:*/		return 0x820EC81C;
		  /* 820EC81Ch */ case   10:  		/* add R10, R25, R11 */
		/* 820EC81Ch case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R25,regs.R11);
		/* 820EC81Ch case   10:*/		return 0x820EC820;
		  /* 820EC820h */ case   11:  		/* lwz R9, <#[R5 + 8]> */
		/* 820EC820h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000008) );
		/* 820EC820h case   11:*/		return 0x820EC824;
		  /* 820EC824h */ case   12:  		/* lwz R31, <#[R3 + 20]> */
		/* 820EC824h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000014) );
		/* 820EC824h case   12:*/		return 0x820EC828;
		  /* 820EC828h */ case   13:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EC828h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EC828h case   13:*/		return 0x820EC82C;
		  /* 820EC82Ch */ case   14:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820EC82Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EC82Ch case   14:*/		return 0x820EC830;
		  /* 820EC830h */ case   15:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EC830h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EC830h case   15:*/		return 0x820EC834;
		  /* 820EC834h */ case   16:  		/* lwzx R10, <#[R10 + R31]> */
		/* 820EC834h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820EC834h case   16:*/		return 0x820EC838;
		  /* 820EC838h */ case   17:  		/* lwz R10, <#[R10 + 72]> */
		/* 820EC838h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 820EC838h case   17:*/		return 0x820EC83C;
		  /* 820EC83Ch */ case   18:  		/* cmplw CR6, R10, R8 */
		/* 820EC83Ch case   18:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820EC83Ch case   18:*/		return 0x820EC840;
		  /* 820EC840h */ case   19:  		/* bc 12, CR6_EQ, 8 */
		/* 820EC840h case   19:*/		if ( regs.CR[6].eq ) { return 0x820EC848;  }
		/* 820EC840h case   19:*/		return 0x820EC844;
		  /* 820EC844h */ case   20:  		/* stw R26, <#[R29]> */
		/* 820EC844h case   20:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R29 + 0x00000000) );
		/* 820EC844h case   20:*/		return 0x820EC848;
	}
	return 0x820EC848;
} // Block from 820EC7F4h-820EC848h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820EC848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC848);
		  /* 820EC848h */ case    0:  		/* addi R11, R11, 1 */
		/* 820EC848h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EC848h case    0:*/		return 0x820EC84C;
		  /* 820EC84Ch */ case    1:  		/* bc 16, CR0_LT, -48 */
		/* 820EC84Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EC81C;  }
		/* 820EC84Ch case    1:*/		return 0x820EC850;
	}
	return 0x820EC850;
} // Block from 820EC848h-820EC850h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EC850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC850);
		  /* 820EC850h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 820EC850h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820EC850h case    0:*/		return 0x820EC854;
		  /* 820EC854h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820EC854h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EC854h case    1:*/		return 0x820EC858;
		  /* 820EC858h */ case    2:  		/* bc 12, CR6_EQ, 208 */
		/* 820EC858h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EC928;  }
		/* 820EC858h case    2:*/		return 0x820EC85C;
		  /* 820EC85Ch */ case    3:  		/* lwz R11, <#[R27]> */
		/* 820EC85Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820EC85Ch case    3:*/		return 0x820EC860;
		  /* 820EC860h */ case    4:  		/* lwz R30, <#[R27 + 12]> */
		/* 820EC860h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x0000000C) );
		/* 820EC860h case    4:*/		return 0x820EC864;
		  /* 820EC864h */ case    5:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 820EC864h case    5:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 820EC864h case    5:*/		return 0x820EC868;
		  /* 820EC868h */ case    6:  		/* cmplw CR6, R30, R11 */
		/* 820EC868h case    6:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820EC868h case    6:*/		return 0x820EC86C;
		  /* 820EC86Ch */ case    7:  		/* bc 4, CR6_EQ, 184 */
		/* 820EC86Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820EC924;  }
		/* 820EC86Ch case    7:*/		return 0x820EC870;
		  /* 820EC870h */ case    8:  		/* lwz R10, <#[R27 + 4]> */
		/* 820EC870h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000004) );
		/* 820EC870h case    8:*/		return 0x820EC874;
		  /* 820EC874h */ case    9:  		/* mullw R11, R11, R7 */
		/* 820EC874h case    9:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 820EC874h case    9:*/		return 0x820EC878;
		  /* 820EC878h */ case   10:  		/* cmplw CR6, R10, R11 */
		/* 820EC878h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820EC878h case   10:*/		return 0x820EC87C;
		  /* 820EC87Ch */ case   11:  		/* bc 12, CR6_GT, 168 */
		/* 820EC87Ch case   11:*/		if ( regs.CR[6].gt ) { return 0x820EC924;  }
		/* 820EC87Ch case   11:*/		return 0x820EC880;
		  /* 820EC880h */ case   12:  		/* lwz R31, <#[R5 + 4]> */
		/* 820EC880h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + 0x00000004) );
		/* 820EC880h case   12:*/		return 0x820EC884;
		  /* 820EC884h */ case   13:  		/* mr R10, R26 */
		/* 820EC884h case   13:*/		regs.R10 = regs.R26;
		/* 820EC884h case   13:*/		return 0x820EC888;
		  /* 820EC888h */ case   14:  		/* cmplwi CR6, R31, 0 */
		/* 820EC888h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820EC888h case   14:*/		return 0x820EC88C;
		  /* 820EC88Ch */ case   15:  		/* bc 12, CR6_EQ, 48 */
		/* 820EC88Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820EC8BC;  }
		/* 820EC88Ch case   15:*/		return 0x820EC890;
		  /* 820EC890h */ case   16:  		/* lwz R8, <#[R27 + 16]> */
		/* 820EC890h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000010) );
		/* 820EC890h case   16:*/		return 0x820EC894;
		  /* 820EC894h */ case   17:  		/* mr R11, R26 */
		/* 820EC894h case   17:*/		regs.R11 = regs.R26;
		/* 820EC894h case   17:*/		return 0x820EC898;
		  /* 820EC898h */ case   18:  		/* lwz R9, <#[R5 + 8]> */
		/* 820EC898h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000008) );
		/* 820EC898h case   18:*/		return 0x820EC89C;
		  /* 820EC89Ch */ case   19:  		/* lwz R8, <#[R8]> */
		/* 820EC89Ch case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 820EC89Ch case   19:*/		return 0x820EC8A0;
		  /* 820EC8A0h */ case   20:  		/* lwzx R20, <#[R11 + R9]> */
		/* 820EC8A0h case   20:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EC8A0h case   20:*/		return 0x820EC8A4;
		  /* 820EC8A4h */ case   21:  		/* cmplw CR6, R20, R8 */
		/* 820EC8A4h case   21:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R8);
		/* 820EC8A4h case   21:*/		return 0x820EC8A8;
		  /* 820EC8A8h */ case   22:  		/* bc 12, CR6_EQ, 20 */
		/* 820EC8A8h case   22:*/		if ( regs.CR[6].eq ) { return 0x820EC8BC;  }
		/* 820EC8A8h case   22:*/		return 0x820EC8AC;
		  /* 820EC8ACh */ case   23:  		/* addi R10, R10, 1 */
		/* 820EC8ACh case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EC8ACh case   23:*/		return 0x820EC8B0;
		  /* 820EC8B0h */ case   24:  		/* addi R11, R11, 4 */
		/* 820EC8B0h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EC8B0h case   24:*/		return 0x820EC8B4;
		  /* 820EC8B4h */ case   25:  		/* cmplw CR6, R10, R31 */
		/* 820EC8B4h case   25:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 820EC8B4h case   25:*/		return 0x820EC8B8;
		  /* 820EC8B8h */ case   26:  		/* bc 12, CR6_LT, -24 */
		/* 820EC8B8h case   26:*/		if ( regs.CR[6].lt ) { return 0x820EC8A0;  }
		/* 820EC8B8h case   26:*/		return 0x820EC8BC;
	}
	return 0x820EC8BC;
} // Block from 820EC850h-820EC8BCh (27 instructions)

//////////////////////////////////////////////////////
// Block at 820EC8BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC8BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC8BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC8BC);
		  /* 820EC8BCh */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 820EC8BCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 820EC8BCh case    0:*/		return 0x820EC8C0;
		  /* 820EC8C0h */ case    1:  		/* bc 12, CR6_EQ, 100 */
		/* 820EC8C0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC924;  }
		/* 820EC8C0h case    1:*/		return 0x820EC8C4;
		  /* 820EC8C4h */ case    2:  		/* cmplwi CR6, R30, 1 */
		/* 820EC8C4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000001);
		/* 820EC8C4h case    2:*/		return 0x820EC8C8;
		  /* 820EC8C8h */ case    3:  		/* bc 4, CR6_GT, 96 */
		/* 820EC8C8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820EC928;  }
		/* 820EC8C8h case    3:*/		return 0x820EC8CC;
		  /* 820EC8CCh */ case    4:  		/* cmplw CR6, R30, R28 */
		/* 820EC8CCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 820EC8CCh case    4:*/		return 0x820EC8D0;
		  /* 820EC8D0h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 820EC8D0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820EC8E0;  }
		/* 820EC8D0h case    5:*/		return 0x820EC8D4;
		  /* 820EC8D4h */ case    6:  		/* add R11, R10, R28 */
		/* 820EC8D4h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R28);
		/* 820EC8D4h case    6:*/		return 0x820EC8D8;
		  /* 820EC8D8h */ case    7:  		/* cmplw CR6, R11, R31 */
		/* 820EC8D8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820EC8D8h case    7:*/		return 0x820EC8DC;
		  /* 820EC8DCh */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 820EC8DCh case    8:*/		if ( !regs.CR[6].gt ) { return 0x820EC8E4;  }
		/* 820EC8DCh case    8:*/		return 0x820EC8E0;
	}
	return 0x820EC8E0;
} // Block from 820EC8BCh-820EC8E0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820EC8E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC8E0);
		  /* 820EC8E0h */ case    0:  		/* stw R26, <#[R29]> */
		/* 820EC8E0h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R29 + 0x00000000) );
		/* 820EC8E0h case    0:*/		return 0x820EC8E4;
	}
	return 0x820EC8E4;
} // Block from 820EC8E0h-820EC8E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC8E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC8E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC8E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC8E4);
		  /* 820EC8E4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820EC8E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EC8E4h case    0:*/		return 0x820EC8E8;
		  /* 820EC8E8h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820EC8E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EC928;  }
		/* 820EC8E8h case    1:*/		return 0x820EC8EC;
		  /* 820EC8ECh */ case    2:  		/* mtspr CTR, R28 */
		/* 820EC8ECh case    2:*/		regs.CTR = regs.R28;
		/* 820EC8ECh case    2:*/		return 0x820EC8F0;
		  /* 820EC8F0h */ case    3:  		/* mr R11, R26 */
		/* 820EC8F0h case    3:*/		regs.R11 = regs.R26;
		/* 820EC8F0h case    3:*/		return 0x820EC8F4;
		  /* 820EC8F4h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EC8F4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EC8F4h case    4:*/		return 0x820EC8F8;
		  /* 820EC8F8h */ case    5:  		/* lwz R9, <#[R5 + 8]> */
		/* 820EC8F8h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000008) );
		/* 820EC8F8h case    5:*/		return 0x820EC8FC;
		  /* 820EC8FCh */ case    6:  		/* lwz R8, <#[R27 + 16]> */
		/* 820EC8FCh case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000010) );
		/* 820EC8FCh case    6:*/		return 0x820EC900;
		  /* 820EC900h */ case    7:  		/* lwzx R9, <#[R9 + R10]> */
		/* 820EC900h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820EC900h case    7:*/		return 0x820EC904;
		  /* 820EC904h */ case    8:  		/* lwzx R8, <#[R11 + R8]> */
		/* 820EC904h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820EC904h case    8:*/		return 0x820EC908;
		  /* 820EC908h */ case    9:  		/* cmplw CR6, R8, R9 */
		/* 820EC908h case    9:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820EC908h case    9:*/		return 0x820EC90C;
		  /* 820EC90Ch */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 820EC90Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820EC914;  }
		/* 820EC90Ch case   10:*/		return 0x820EC910;
		  /* 820EC910h */ case   11:  		/* stw R26, <#[R29]> */
		/* 820EC910h case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R29 + 0x00000000) );
		/* 820EC910h case   11:*/		return 0x820EC914;
	}
	return 0x820EC914;
} // Block from 820EC8E4h-820EC914h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820EC914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC914);
		  /* 820EC914h */ case    0:  		/* addi R11, R11, 4 */
		/* 820EC914h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EC914h case    0:*/		return 0x820EC918;
		  /* 820EC918h */ case    1:  		/* addi R10, R10, 4 */
		/* 820EC918h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EC918h case    1:*/		return 0x820EC91C;
		  /* 820EC91Ch */ case    2:  		/* bc 16, CR0_LT, -36 */
		/* 820EC91Ch case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EC8F8;  }
		/* 820EC91Ch case    2:*/		return 0x820EC920;
		  /* 820EC920h */ case    3:  		/* b 8 */
		/* 820EC920h case    3:*/		return 0x820EC928;
		/* 820EC920h case    3:*/		return 0x820EC924;
	}
	return 0x820EC924;
} // Block from 820EC914h-820EC924h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EC924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC924);
		  /* 820EC924h */ case    0:  		/* stw R26, <#[R29]> */
		/* 820EC924h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R29 + 0x00000000) );
		/* 820EC924h case    0:*/		return 0x820EC928;
	}
	return 0x820EC928;
} // Block from 820EC924h-820EC928h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC928);
		  /* 820EC928h */ case    0:  		/* addic. R23, R23, -1 */
		/* 820EC928h case    0:*/		cpu::op::addic<1>(regs,&regs.R23,regs.R23,0xFFFFFFFF);
		/* 820EC928h case    0:*/		return 0x820EC92C;
		  /* 820EC92Ch */ case    1:  		/* add R25, R25, R28 */
		/* 820EC92Ch case    1:*/		cpu::op::add<0>(regs,&regs.R25,regs.R25,regs.R28);
		/* 820EC92Ch case    1:*/		return 0x820EC930;
		  /* 820EC930h */ case    2:  		/* add R24, R22, R24 */
		/* 820EC930h case    2:*/		cpu::op::add<0>(regs,&regs.R24,regs.R22,regs.R24);
		/* 820EC930h case    2:*/		return 0x820EC934;
		  /* 820EC934h */ case    3:  		/* addi R29, R29, 4 */
		/* 820EC934h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820EC934h case    3:*/		return 0x820EC938;
		  /* 820EC938h */ case    4:  		/* bc 4, CR0_EQ, -508 */
		/* 820EC938h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820EC73C;  }
		/* 820EC938h case    4:*/		return 0x820EC93C;
	}
	return 0x820EC93C;
} // Block from 820EC928h-820EC93Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EC93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC93C);
		  /* 820EC93Ch */ case    0:  		/* mr R11, R26 */
		/* 820EC93Ch case    0:*/		regs.R11 = regs.R26;
		/* 820EC93Ch case    0:*/		return 0x820EC940;
		  /* 820EC940h */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 820EC940h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820EC940h case    1:*/		return 0x820EC944;
		  /* 820EC944h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820EC944h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EC968;  }
		/* 820EC944h case    2:*/		return 0x820EC948;
		  /* 820EC948h */ case    3:  		/* mr R10, R6 */
		/* 820EC948h case    3:*/		regs.R10 = regs.R6;
		/* 820EC948h case    3:*/		return 0x820EC94C;
		  /* 820EC94Ch */ case    4:  		/* lwz R9, <#[R10]> */
		/* 820EC94Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820EC94Ch case    4:*/		return 0x820EC950;
		  /* 820EC950h */ case    5:  		/* cmplwi CR6, R9, 0 */
		/* 820EC950h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820EC950h case    5:*/		return 0x820EC954;
		  /* 820EC954h */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 820EC954h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820EC970;  }
		/* 820EC954h case    6:*/		return 0x820EC958;
		  /* 820EC958h */ case    7:  		/* addi R11, R11, 1 */
		/* 820EC958h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EC958h case    7:*/		return 0x820EC95C;
		  /* 820EC95Ch */ case    8:  		/* addi R10, R10, 4 */
		/* 820EC95Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EC95Ch case    8:*/		return 0x820EC960;
		  /* 820EC960h */ case    9:  		/* cmplw CR6, R11, R21 */
		/* 820EC960h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 820EC960h case    9:*/		return 0x820EC964;
		  /* 820EC964h */ case   10:  		/* bc 12, CR6_LT, -24 */
		/* 820EC964h case   10:*/		if ( regs.CR[6].lt ) { return 0x820EC94C;  }
		/* 820EC964h case   10:*/		return 0x820EC968;
	}
	return 0x820EC968;
} // Block from 820EC93Ch-820EC968h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820EC968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC968);
		  /* 820EC968h */ case    0:  		/* li R3, 1 */
		/* 820EC968h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820EC968h case    0:*/		return 0x820EC96C;
		  /* 820EC96Ch */ case    1:  		/* b -374500 */
		/* 820EC96Ch case    1:*/		return 0x82091288;
		/* 820EC96Ch case    1:*/		return 0x820EC970;
	}
	return 0x820EC970;
} // Block from 820EC968h-820EC970h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EC970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC970);
		  /* 820EC970h */ case    0:  		/* li R3, 0 */
		/* 820EC970h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EC970h case    0:*/		return 0x820EC974;
		  /* 820EC974h */ case    1:  		/* b -8 */
		/* 820EC974h case    1:*/		return 0x820EC96C;
		/* 820EC974h case    1:*/		return 0x820EC978;
	}
	return 0x820EC978;
} // Block from 820EC970h-820EC978h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EC978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC978);
		  /* 820EC978h */ case    0:  		/* mfspr R12, LR */
		/* 820EC978h case    0:*/		regs.R12 = regs.LR;
		/* 820EC978h case    0:*/		return 0x820EC97C;
		  /* 820EC97Ch */ case    1:  		/* bl -374576 */
		/* 820EC97Ch case    1:*/		regs.LR = 0x820EC980; return 0x8209124C;
		/* 820EC97Ch case    1:*/		return 0x820EC980;
		  /* 820EC980h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820EC980h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820EC980h case    2:*/		return 0x820EC984;
		  /* 820EC984h */ case    3:  		/* mr R29, R3 */
		/* 820EC984h case    3:*/		regs.R29 = regs.R3;
		/* 820EC984h case    3:*/		return 0x820EC988;
		  /* 820EC988h */ case    4:  		/* li R3, 116 */
		/* 820EC988h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 820EC988h case    4:*/		return 0x820EC98C;
		  /* 820EC98Ch */ case    5:  		/* mr R25, R4 */
		/* 820EC98Ch case    5:*/		regs.R25 = regs.R4;
		/* 820EC98Ch case    5:*/		return 0x820EC990;
		  /* 820EC990h */ case    6:  		/* mr R26, R5 */
		/* 820EC990h case    6:*/		regs.R26 = regs.R5;
		/* 820EC990h case    6:*/		return 0x820EC994;
		  /* 820EC994h */ case    7:  		/* mr R30, R6 */
		/* 820EC994h case    7:*/		regs.R30 = regs.R6;
		/* 820EC994h case    7:*/		return 0x820EC998;
		  /* 820EC998h */ case    8:  		/* bl 64512 */
		/* 820EC998h case    8:*/		regs.LR = 0x820EC99C; return 0x820FC598;
		/* 820EC998h case    8:*/		return 0x820EC99C;
		  /* 820EC99Ch */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820EC99Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EC99Ch case    9:*/		return 0x820EC9A0;
		  /* 820EC9A0h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 820EC9A0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820EC9B0;  }
		/* 820EC9A0h case   10:*/		return 0x820EC9A4;
		  /* 820EC9A4h */ case   11:  		/* bl 62716 */
		/* 820EC9A4h case   11:*/		regs.LR = 0x820EC9A8; return 0x820FBEA0;
		/* 820EC9A4h case   11:*/		return 0x820EC9A8;
		  /* 820EC9A8h */ case   12:  		/* mr R28, R3 */
		/* 820EC9A8h case   12:*/		regs.R28 = regs.R3;
		/* 820EC9A8h case   12:*/		return 0x820EC9AC;
		  /* 820EC9ACh */ case   13:  		/* b 8 */
		/* 820EC9ACh case   13:*/		return 0x820EC9B4;
		/* 820EC9ACh case   13:*/		return 0x820EC9B0;
	}
	return 0x820EC9B0;
} // Block from 820EC978h-820EC9B0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820EC9B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC9B0);
		  /* 820EC9B0h */ case    0:  		/* li R28, 0 */
		/* 820EC9B0h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820EC9B0h case    0:*/		return 0x820EC9B4;
	}
	return 0x820EC9B4;
} // Block from 820EC9B0h-820EC9B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EC9B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC9B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC9B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC9B4);
		  /* 820EC9B4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820EC9B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EC9B4h case    0:*/		return 0x820EC9B8;
		  /* 820EC9B8h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820EC9B8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EC9C8;  }
		/* 820EC9B8h case    1:*/		return 0x820EC9BC;
		  /* 820EC9BCh */ case    2:  		/* lis R31, -32761 */
		/* 820EC9BCh case    2:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820EC9BCh case    2:*/		return 0x820EC9C0;
		  /* 820EC9C0h */ case    3:  		/* ori R31, R31, 14 */
		/* 820EC9C0h case    3:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820EC9C0h case    3:*/		return 0x820EC9C4;
		  /* 820EC9C4h */ case    4:  		/* b 380 */
		/* 820EC9C4h case    4:*/		return 0x820ECB40;
		/* 820EC9C4h case    4:*/		return 0x820EC9C8;
	}
	return 0x820EC9C8;
} // Block from 820EC9B4h-820EC9C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EC9C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EC9C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EC9C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EC9C8);
		  /* 820EC9C8h */ case    0:  		/* li R27, 0 */
		/* 820EC9C8h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820EC9C8h case    0:*/		return 0x820EC9CC;
		  /* 820EC9CCh */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 820EC9CCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820EC9CCh case    1:*/		return 0x820EC9D0;
		  /* 820EC9D0h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 820EC9D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820ECA14;  }
		/* 820EC9D0h case    2:*/		return 0x820EC9D4;
		  /* 820EC9D4h */ case    3:  		/* lwz R9, <#[R29 + 260]> */
		/* 820EC9D4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000104) );
		/* 820EC9D4h case    3:*/		return 0x820EC9D8;
		  /* 820EC9D8h */ case    4:  		/* li R11, 0 */
		/* 820EC9D8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820EC9D8h case    4:*/		return 0x820EC9DC;
		  /* 820EC9DCh */ case    5:  		/* lwz R10, <#[R29 + 20]> */
		/* 820EC9DCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 820EC9DCh case    5:*/		return 0x820EC9E0;
		  /* 820EC9E0h */ case    6:  		/* mtspr CTR, R30 */
		/* 820EC9E0h case    6:*/		regs.CTR = regs.R30;
		/* 820EC9E0h case    6:*/		return 0x820EC9E4;
		  /* 820EC9E4h */ case    7:  		/* lwz R9, <#[R9 + 16]> */
		/* 820EC9E4h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000010) );
		/* 820EC9E4h case    7:*/		return 0x820EC9E8;
		  /* 820EC9E8h */ case    8:  		/* lwzx R8, <#[R11 + R9]> */
		/* 820EC9E8h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EC9E8h case    8:*/		return 0x820EC9EC;
		  /* 820EC9ECh */ case    9:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820EC9ECh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820EC9ECh case    9:*/		return 0x820EC9F0;
		  /* 820EC9F0h */ case   10:  		/* lwzx R8, <#[R8 + R10]> */
		/* 820EC9F0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820EC9F0h case   10:*/		return 0x820EC9F4;
		  /* 820EC9F4h */ case   11:  		/* lwz R8, <#[R8 + 16]> */
		/* 820EC9F4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000010) );
		/* 820EC9F4h case   11:*/		return 0x820EC9F8;
		  /* 820EC9F8h */ case   12:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820EC9F8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820EC9F8h case   12:*/		return 0x820EC9FC;
		  /* 820EC9FCh */ case   13:  		/* lwzx R8, <#[R8 + R25]> */
		/* 820EC9FCh case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R25 + 0x00000000) );
		/* 820EC9FCh case   13:*/		return 0x820ECA00;
		  /* 820ECA00h */ case   14:  		/* cmpwi CR6, R8, -1 */
		/* 820ECA00h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 820ECA00h case   14:*/		return 0x820ECA04;
		  /* 820ECA04h */ case   15:  		/* bc 12, CR6_EQ, 8 */
		/* 820ECA04h case   15:*/		if ( regs.CR[6].eq ) { return 0x820ECA0C;  }
		/* 820ECA04h case   15:*/		return 0x820ECA08;
		  /* 820ECA08h */ case   16:  		/* addi R27, R27, 1 */
		/* 820ECA08h case   16:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820ECA08h case   16:*/		return 0x820ECA0C;
	}
	return 0x820ECA0C;
} // Block from 820EC9C8h-820ECA0Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820ECA0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECA0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECA0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECA0C);
		  /* 820ECA0Ch */ case    0:  		/* addi R11, R11, 4 */
		/* 820ECA0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820ECA0Ch case    0:*/		return 0x820ECA10;
		  /* 820ECA10h */ case    1:  		/* bc 16, CR0_LT, -40 */
		/* 820ECA10h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EC9E8;  }
		/* 820ECA10h case    1:*/		return 0x820ECA14;
	}
	return 0x820ECA14;
} // Block from 820ECA0Ch-820ECA14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECA14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECA14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECA14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECA14);
		  /* 820ECA14h */ case    0:  		/* lwz R11, <#[R29 + 260]> */
		/* 820ECA14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000104) );
		/* 820ECA14h case    0:*/		return 0x820ECA18;
		  /* 820ECA18h */ case    1:  		/* li R7, 0 */
		/* 820ECA18h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820ECA18h case    1:*/		return 0x820ECA1C;
		  /* 820ECA1Ch */ case    2:  		/* mr R6, R27 */
		/* 820ECA1Ch case    2:*/		regs.R6 = regs.R27;
		/* 820ECA1Ch case    2:*/		return 0x820ECA20;
		  /* 820ECA20h */ case    3:  		/* mullw R5, R27, R26 */
		/* 820ECA20h case    3:*/		cpu::op::mullw<0>(regs,&regs.R5,regs.R27,regs.R26);
		/* 820ECA20h case    3:*/		return 0x820ECA24;
		  /* 820ECA24h */ case    4:  		/* lwz R11, <#[R11]> */
		/* 820ECA24h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820ECA24h case    4:*/		return 0x820ECA28;
		  /* 820ECA28h */ case    5:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820ECA28h case    5:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820ECA28h case    5:*/		return 0x820ECA2C;
		  /* 820ECA2Ch */ case    6:  		/* mr R3, R28 */
		/* 820ECA2Ch case    6:*/		regs.R3 = regs.R28;
		/* 820ECA2Ch case    6:*/		return 0x820ECA30;
		  /* 820ECA30h */ case    7:  		/* or R4, R11, R27 */
		/* 820ECA30h case    7:*/		cpu::op::or<0>(regs,&regs.R4,regs.R11,regs.R27);
		/* 820ECA30h case    7:*/		return 0x820ECA34;
		  /* 820ECA34h */ case    8:  		/* bl 64508 */
		/* 820ECA34h case    8:*/		regs.LR = 0x820ECA38; return 0x820FC630;
		/* 820ECA34h case    8:*/		return 0x820ECA38;
		  /* 820ECA38h */ case    9:  		/* or. R31, R3, R3 */
		/* 820ECA38h case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820ECA38h case    9:*/		return 0x820ECA3C;
		  /* 820ECA3Ch */ case   10:  		/* bc 12, CR0_LT, 236 */
		/* 820ECA3Ch case   10:*/		if ( regs.CR[0].lt ) { return 0x820ECB28;  }
		/* 820ECA3Ch case   10:*/		return 0x820ECA40;
		  /* 820ECA40h */ case   11:  		/* mr R3, R28 */
		/* 820ECA40h case   11:*/		regs.R3 = regs.R28;
		/* 820ECA40h case   11:*/		return 0x820ECA44;
		  /* 820ECA44h */ case   12:  		/* lwz R4, <#[R29 + 260]> */
		/* 820ECA44h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000104) );
		/* 820ECA44h case   12:*/		return 0x820ECA48;
		  /* 820ECA48h */ case   13:  		/* bl 62632 */
		/* 820ECA48h case   13:*/		regs.LR = 0x820ECA4C; return 0x820FBEF0;
		/* 820ECA48h case   13:*/		return 0x820ECA4C;
		  /* 820ECA4Ch */ case   14:  		/* or. R31, R3, R3 */
		/* 820ECA4Ch case   14:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820ECA4Ch case   14:*/		return 0x820ECA50;
		  /* 820ECA50h */ case   15:  		/* bc 12, CR0_LT, 216 */
		/* 820ECA50h case   15:*/		if ( regs.CR[0].lt ) { return 0x820ECB28;  }
		/* 820ECA50h case   15:*/		return 0x820ECA54;
		  /* 820ECA54h */ case   16:  		/* li R9, 0 */
		/* 820ECA54h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820ECA54h case   16:*/		return 0x820ECA58;
		  /* 820ECA58h */ case   17:  		/* cmplwi CR6, R26, 0 */
		/* 820ECA58h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820ECA58h case   17:*/		return 0x820ECA5C;
		  /* 820ECA5Ch */ case   18:  		/* bc 12, CR6_EQ, 176 */
		/* 820ECA5Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x820ECB0C;  }
		/* 820ECA5Ch case   18:*/		return 0x820ECA60;
		  /* 820ECA60h */ case   19:  		/* li R6, 0 */
		/* 820ECA60h case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820ECA60h case   19:*/		return 0x820ECA64;
		  /* 820ECA64h */ case   20:  		/* li R7, 0 */
		/* 820ECA64h case   20:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820ECA64h case   20:*/		return 0x820ECA68;
		  /* 820ECA68h */ case   21:  		/* cmplwi CR6, R30, 0 */
		/* 820ECA68h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820ECA68h case   21:*/		return 0x820ECA6C;
		  /* 820ECA6Ch */ case   22:  		/* bc 12, CR6_EQ, 148 */
		/* 820ECA6Ch case   22:*/		if ( regs.CR[6].eq ) { return 0x820ECB00;  }
		/* 820ECA6Ch case   22:*/		return 0x820ECA70;
		  /* 820ECA70h */ case   23:  		/* mtspr CTR, R30 */
		/* 820ECA70h case   23:*/		regs.CTR = regs.R30;
		/* 820ECA70h case   23:*/		return 0x820ECA74;
		  /* 820ECA74h */ case   24:  		/* li R5, 0 */
		/* 820ECA74h case   24:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820ECA74h case   24:*/		return 0x820ECA78;
		  /* 820ECA78h */ case   25:  		/* li R8, 0 */
		/* 820ECA78h case   25:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820ECA78h case   25:*/		return 0x820ECA7C;
		  /* 820ECA7Ch */ case   26:  		/* lwz R10, <#[R29 + 260]> */
		/* 820ECA7Ch case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000104) );
		/* 820ECA7Ch case   26:*/		return 0x820ECA80;
		  /* 820ECA80h */ case   27:  		/* lwz R11, <#[R29 + 20]> */
		/* 820ECA80h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 820ECA80h case   27:*/		return 0x820ECA84;
		  /* 820ECA84h */ case   28:  		/* lwz R4, <#[R10 + 16]> */
		/* 820ECA84h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 820ECA84h case   28:*/		return 0x820ECA88;
		  /* 820ECA88h */ case   29:  		/* lwzx R4, <#[R4 + R8]> */
		/* 820ECA88h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R8 + 0x00000000) );
		/* 820ECA88h case   29:*/		return 0x820ECA8C;
		  /* 820ECA8Ch */ case   30:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 820ECA8Ch case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 820ECA8Ch case   30:*/		return 0x820ECA90;
		  /* 820ECA90h */ case   31:  		/* lwzx R11, <#[R4 + R11]> */
		/* 820ECA90h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 820ECA90h case   31:*/		return 0x820ECA94;
		  /* 820ECA94h */ case   32:  		/* lwz R11, <#[R11 + 16]> */
		/* 820ECA94h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820ECA94h case   32:*/		return 0x820ECA98;
		  /* 820ECA98h */ case   33:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820ECA98h case   33:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820ECA98h case   33:*/		return 0x820ECA9C;
		  /* 820ECA9Ch */ case   34:  		/* lwzx R11, <#[R11 + R25]> */
		/* 820ECA9Ch case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 820ECA9Ch case   34:*/		return 0x820ECAA0;
		  /* 820ECAA0h */ case   35:  		/* cmpwi CR6, R11, -1 */
		/* 820ECAA0h case   35:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820ECAA0h case   35:*/		return 0x820ECAA4;
		  /* 820ECAA4h */ case   36:  		/* bc 12, CR6_EQ, 80 */
		/* 820ECAA4h case   36:*/		if ( regs.CR[6].eq ) { return 0x820ECAF4;  }
		/* 820ECAA4h case   36:*/		return 0x820ECAA8;
		  /* 820ECAA8h */ case   37:  		/* mullw R11, R9, R30 */
		/* 820ECAA8h case   37:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R9,regs.R30);
		/* 820ECAA8h case   37:*/		return 0x820ECAAC;
		  /* 820ECAACh */ case   38:  		/* lwz R10, <#[R10 + 8]> */
		/* 820ECAACh case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820ECAACh case   38:*/		return 0x820ECAB0;
		  /* 820ECAB0h */ case   39:  		/* lwz R4, <#[R28 + 8]> */
		/* 820ECAB0h case   39:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000008) );
		/* 820ECAB0h case   39:*/		return 0x820ECAB4;
		  /* 820ECAB4h */ case   40:  		/* add R3, R11, R7 */
		/* 820ECAB4h case   40:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R7);
		/* 820ECAB4h case   40:*/		return 0x820ECAB8;
		  /* 820ECAB8h */ case   41:  		/* mullw R11, R9, R27 */
		/* 820ECAB8h case   41:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R9,regs.R27);
		/* 820ECAB8h case   41:*/		return 0x820ECABC;
		  /* 820ECABCh */ case   42:  		/* rlwinm R3, R3, 2, 0, 29 */
		/* 820ECABCh case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R3);
		/* 820ECABCh case   42:*/		return 0x820ECAC0;
		  /* 820ECAC0h */ case   43:  		/* add R11, R11, R6 */
		/* 820ECAC0h case   43:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 820ECAC0h case   43:*/		return 0x820ECAC4;
		  /* 820ECAC4h */ case   44:  		/* cmplwi CR6, R9, 0 */
		/* 820ECAC4h case   44:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820ECAC4h case   44:*/		return 0x820ECAC8;
		  /* 820ECAC8h */ case   45:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820ECAC8h case   45:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820ECAC8h case   45:*/		return 0x820ECACC;
		  /* 820ECACCh */ case   46:  		/* lwzx R10, <#[R3 + R10]> */
		/* 820ECACCh case   46:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 820ECACCh case   46:*/		return 0x820ECAD0;
		  /* 820ECAD0h */ case   47:  		/* stwx R10, <#[R11 + R4]> */
		/* 820ECAD0h case   47:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 820ECAD0h case   47:*/		return 0x820ECAD4;
		  /* 820ECAD4h */ case   48:  		/* bc 4, CR6_EQ, 24 */
		/* 820ECAD4h case   48:*/		if ( !regs.CR[6].eq ) { return 0x820ECAEC;  }
		/* 820ECAD4h case   48:*/		return 0x820ECAD8;
		  /* 820ECAD8h */ case   49:  		/* lwz R11, <#[R29 + 260]> */
		/* 820ECAD8h case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000104) );
		/* 820ECAD8h case   49:*/		return 0x820ECADC;
		  /* 820ECADCh */ case   50:  		/* lwz R10, <#[R28 + 16]> */
		/* 820ECADCh case   50:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 820ECADCh case   50:*/		return 0x820ECAE0;
		  /* 820ECAE0h */ case   51:  		/* lwz R11, <#[R11 + 16]> */
		/* 820ECAE0h case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820ECAE0h case   51:*/		return 0x820ECAE4;
		  /* 820ECAE4h */ case   52:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820ECAE4h case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820ECAE4h case   52:*/		return 0x820ECAE8;
		  /* 820ECAE8h */ case   53:  		/* stwx R11, <#[R10 + R5]> */
		/* 820ECAE8h case   53:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820ECAE8h case   53:*/		return 0x820ECAEC;
	}
	return 0x820ECAEC;
} // Block from 820ECA14h-820ECAECh (54 instructions)

//////////////////////////////////////////////////////
// Block at 820ECAECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECAEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECAEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECAEC);
		  /* 820ECAECh */ case    0:  		/* addi R6, R6, 1 */
		/* 820ECAECh case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820ECAECh case    0:*/		return 0x820ECAF0;
		  /* 820ECAF0h */ case    1:  		/* addi R5, R5, 4 */
		/* 820ECAF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 820ECAF0h case    1:*/		return 0x820ECAF4;
	}
	return 0x820ECAF4;
} // Block from 820ECAECh-820ECAF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECAF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECAF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECAF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECAF4);
		  /* 820ECAF4h */ case    0:  		/* addi R7, R7, 1 */
		/* 820ECAF4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820ECAF4h case    0:*/		return 0x820ECAF8;
		  /* 820ECAF8h */ case    1:  		/* addi R8, R8, 4 */
		/* 820ECAF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820ECAF8h case    1:*/		return 0x820ECAFC;
		  /* 820ECAFCh */ case    2:  		/* bc 16, CR0_LT, -128 */
		/* 820ECAFCh case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820ECA7C;  }
		/* 820ECAFCh case    2:*/		return 0x820ECB00;
	}
	return 0x820ECB00;
} // Block from 820ECAF4h-820ECB00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ECB00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECB00);
		  /* 820ECB00h */ case    0:  		/* addi R9, R9, 1 */
		/* 820ECB00h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820ECB00h case    0:*/		return 0x820ECB04;
		  /* 820ECB04h */ case    1:  		/* cmplw CR6, R9, R26 */
		/* 820ECB04h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R26);
		/* 820ECB04h case    1:*/		return 0x820ECB08;
		  /* 820ECB08h */ case    2:  		/* bc 12, CR6_LT, -168 */
		/* 820ECB08h case    2:*/		if ( regs.CR[6].lt ) { return 0x820ECA60;  }
		/* 820ECB08h case    2:*/		return 0x820ECB0C;
	}
	return 0x820ECB0C;
} // Block from 820ECB00h-820ECB0Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ECB0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECB0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECB0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECB0C);
		  /* 820ECB0Ch */ case    0:  		/* mr R4, R28 */
		/* 820ECB0Ch case    0:*/		regs.R4 = regs.R28;
		/* 820ECB0Ch case    0:*/		return 0x820ECB10;
		  /* 820ECB10h */ case    1:  		/* mr R3, R29 */
		/* 820ECB10h case    1:*/		regs.R3 = regs.R29;
		/* 820ECB10h case    1:*/		return 0x820ECB14;
		  /* 820ECB14h */ case    2:  		/* bl 66980 */
		/* 820ECB14h case    2:*/		regs.LR = 0x820ECB18; return 0x820FD0B8;
		/* 820ECB14h case    2:*/		return 0x820ECB18;
		  /* 820ECB18h */ case    3:  		/* or. R31, R3, R3 */
		/* 820ECB18h case    3:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820ECB18h case    3:*/		return 0x820ECB1C;
		  /* 820ECB1Ch */ case    4:  		/* bc 12, CR0_LT, 12 */
		/* 820ECB1Ch case    4:*/		if ( regs.CR[0].lt ) { return 0x820ECB28;  }
		/* 820ECB1Ch case    4:*/		return 0x820ECB20;
		  /* 820ECB20h */ case    5:  		/* li R28, 0 */
		/* 820ECB20h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820ECB20h case    5:*/		return 0x820ECB24;
		  /* 820ECB24h */ case    6:  		/* li R31, 0 */
		/* 820ECB24h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820ECB24h case    6:*/		return 0x820ECB28;
	}
	return 0x820ECB28;
} // Block from 820ECB0Ch-820ECB28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ECB28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECB28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECB28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECB28);
		  /* 820ECB28h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820ECB28h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820ECB28h case    0:*/		return 0x820ECB2C;
		  /* 820ECB2Ch */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820ECB2Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820ECB40;  }
		/* 820ECB2Ch case    1:*/		return 0x820ECB30;
		  /* 820ECB30h */ case    2:  		/* mr R3, R28 */
		/* 820ECB30h case    2:*/		regs.R3 = regs.R28;
		/* 820ECB30h case    2:*/		return 0x820ECB34;
		  /* 820ECB34h */ case    3:  		/* bl 1247372 */
		/* 820ECB34h case    3:*/		regs.LR = 0x820ECB38; return 0x8221D3C0;
		/* 820ECB34h case    3:*/		return 0x820ECB38;
		  /* 820ECB38h */ case    4:  		/* mr R3, R28 */
		/* 820ECB38h case    4:*/		regs.R3 = regs.R28;
		/* 820ECB38h case    4:*/		return 0x820ECB3C;
		  /* 820ECB3Ch */ case    5:  		/* bl 64180 */
		/* 820ECB3Ch case    5:*/		regs.LR = 0x820ECB40; return 0x820FC5F0;
		/* 820ECB3Ch case    5:*/		return 0x820ECB40;
	}
	return 0x820ECB40;
} // Block from 820ECB28h-820ECB40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820ECB40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECB40);
		  /* 820ECB40h */ case    0:  		/* mr R3, R31 */
		/* 820ECB40h case    0:*/		regs.R3 = regs.R31;
		/* 820ECB40h case    0:*/		return 0x820ECB44;
		  /* 820ECB44h */ case    1:  		/* addi R1, R1, 144 */
		/* 820ECB44h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820ECB44h case    1:*/		return 0x820ECB48;
		  /* 820ECB48h */ case    2:  		/* b -374956 */
		/* 820ECB48h case    2:*/		return 0x8209129C;
		/* 820ECB48h case    2:*/		return 0x820ECB4C;
		  /* 820ECB4Ch */ case    3:  		/* nop */
		/* 820ECB4Ch case    3:*/		cpu::op::nop();
		/* 820ECB4Ch case    3:*/		return 0x820ECB50;
		  /* 820ECB50h */ case    4:  		/* lis R9, 1280 */
		/* 820ECB50h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0x500);
		/* 820ECB50h case    4:*/		return 0x820ECB54;
		  /* 820ECB54h */ case    5:  		/* rlwinm R11, R3, 0, 4, 7 */
		/* 820ECB54h case    5:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R11,regs.R3);
		/* 820ECB54h case    5:*/		return 0x820ECB58;
		  /* 820ECB58h */ case    6:  		/* li R10, 0 */
		/* 820ECB58h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820ECB58h case    6:*/		return 0x820ECB5C;
		  /* 820ECB5Ch */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 820ECB5Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820ECB5Ch case    7:*/		return 0x820ECB60;
		  /* 820ECB60h */ case    8:  		/* bc 12, CR6_GT, 112 */
		/* 820ECB60h case    8:*/		if ( regs.CR[6].gt ) { return 0x820ECBD0;  }
		/* 820ECB60h case    8:*/		return 0x820ECB64;
		  /* 820ECB64h */ case    9:  		/* bc 12, CR6_EQ, 100 */
		/* 820ECB64h case    9:*/		if ( regs.CR[6].eq ) { return 0x820ECBC8;  }
		/* 820ECB64h case    9:*/		return 0x820ECB68;
		  /* 820ECB68h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 820ECB68h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820ECB68h case   10:*/		return 0x820ECB6C;
		  /* 820ECB6Ch */ case   11:  		/* bc 12, CR6_EQ, 84 */
		/* 820ECB6Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820ECBC0;  }
		/* 820ECB6Ch case   11:*/		return 0x820ECB70;
		  /* 820ECB70h */ case   12:  		/* lis R8, 256 */
		/* 820ECB70h case   12:*/		cpu::op::lis<0>(regs,&regs.R8,0x100);
		/* 820ECB70h case   12:*/		return 0x820ECB74;
		  /* 820ECB74h */ case   13:  		/* cmplw CR6, R11, R8 */
		/* 820ECB74h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820ECB74h case   13:*/		return 0x820ECB78;
		  /* 820ECB78h */ case   14:  		/* bc 12, CR6_EQ, 64 */
		/* 820ECB78h case   14:*/		if ( regs.CR[6].eq ) { return 0x820ECBB8;  }
		/* 820ECB78h case   14:*/		return 0x820ECB7C;
		  /* 820ECB7Ch */ case   15:  		/* lis R8, 512 */
		/* 820ECB7Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R8,0x200);
		/* 820ECB7Ch case   15:*/		return 0x820ECB80;
		  /* 820ECB80h */ case   16:  		/* cmplw CR6, R11, R8 */
		/* 820ECB80h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820ECB80h case   16:*/		return 0x820ECB84;
		  /* 820ECB84h */ case   17:  		/* bc 12, CR6_EQ, 44 */
		/* 820ECB84h case   17:*/		if ( regs.CR[6].eq ) { return 0x820ECBB0;  }
		/* 820ECB84h case   17:*/		return 0x820ECB88;
		  /* 820ECB88h */ case   18:  		/* lis R8, 768 */
		/* 820ECB88h case   18:*/		cpu::op::lis<0>(regs,&regs.R8,0x300);
		/* 820ECB88h case   18:*/		return 0x820ECB8C;
		  /* 820ECB8Ch */ case   19:  		/* cmplw CR6, R11, R8 */
		/* 820ECB8Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820ECB8Ch case   19:*/		return 0x820ECB90;
		  /* 820ECB90h */ case   20:  		/* bc 12, CR6_EQ, 24 */
		/* 820ECB90h case   20:*/		if ( regs.CR[6].eq ) { return 0x820ECBA8;  }
		/* 820ECB90h case   20:*/		return 0x820ECB94;
		  /* 820ECB94h */ case   21:  		/* lis R8, 1024 */
		/* 820ECB94h case   21:*/		cpu::op::lis<0>(regs,&regs.R8,0x400);
		/* 820ECB94h case   21:*/		return 0x820ECB98;
		  /* 820ECB98h */ case   22:  		/* cmplw CR6, R11, R8 */
		/* 820ECB98h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820ECB98h case   22:*/		return 0x820ECB9C;
		  /* 820ECB9Ch */ case   23:  		/* bc 4, CR6_EQ, 128 */
		/* 820ECB9Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x820ECC1C;  }
		/* 820ECB9Ch case   23:*/		return 0x820ECBA0;
		  /* 820ECBA0h */ case   24:  		/* mr R10, R9 */
		/* 820ECBA0h case   24:*/		regs.R10 = regs.R9;
		/* 820ECBA0h case   24:*/		return 0x820ECBA4;
		  /* 820ECBA4h */ case   25:  		/* b 120 */
		/* 820ECBA4h case   25:*/		return 0x820ECC1C;
		/* 820ECBA4h case   25:*/		return 0x820ECBA8;
	}
	return 0x820ECBA8;
} // Block from 820ECB40h-820ECBA8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820ECBA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECBA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECBA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECBA8);
		  /* 820ECBA8h */ case    0:  		/* lis R10, 512 */
		/* 820ECBA8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 820ECBA8h case    0:*/		return 0x820ECBAC;
		  /* 820ECBACh */ case    1:  		/* b 112 */
		/* 820ECBACh case    1:*/		return 0x820ECC1C;
		/* 820ECBACh case    1:*/		return 0x820ECBB0;
	}
	return 0x820ECBB0;
} // Block from 820ECBA8h-820ECBB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECBB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECBB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECBB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECBB0);
		  /* 820ECBB0h */ case    0:  		/* lis R10, 768 */
		/* 820ECBB0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x300);
		/* 820ECBB0h case    0:*/		return 0x820ECBB4;
		  /* 820ECBB4h */ case    1:  		/* b 104 */
		/* 820ECBB4h case    1:*/		return 0x820ECC1C;
		/* 820ECBB4h case    1:*/		return 0x820ECBB8;
	}
	return 0x820ECBB8;
} // Block from 820ECBB0h-820ECBB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECBB8);
		  /* 820ECBB8h */ case    0:  		/* li R10, 0 */
		/* 820ECBB8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820ECBB8h case    0:*/		return 0x820ECBBC;
		  /* 820ECBBCh */ case    1:  		/* b 96 */
		/* 820ECBBCh case    1:*/		return 0x820ECC1C;
		/* 820ECBBCh case    1:*/		return 0x820ECBC0;
	}
	return 0x820ECBC0;
} // Block from 820ECBB8h-820ECBC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECBC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECBC0);
		  /* 820ECBC0h */ case    0:  		/* lis R10, 256 */
		/* 820ECBC0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x100);
		/* 820ECBC0h case    0:*/		return 0x820ECBC4;
		  /* 820ECBC4h */ case    1:  		/* b 88 */
		/* 820ECBC4h case    1:*/		return 0x820ECC1C;
		/* 820ECBC4h case    1:*/		return 0x820ECBC8;
	}
	return 0x820ECBC8;
} // Block from 820ECBC0h-820ECBC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECBC8h
// Function '?FindMatch@CShaderProgram@D3DXShader@@IAAPAVCInstruction@2@KPAV32@PAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECBC8);
		  /* 820ECBC8h */ case    0:  		/* lis R10, 1024 */
		/* 820ECBC8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x400);
		/* 820ECBC8h case    0:*/		return 0x820ECBCC;
		  /* 820ECBCCh */ case    1:  		/* b 80 */
		/* 820ECBCCh case    1:*/		return 0x820ECC1C;
		/* 820ECBCCh case    1:*/		return 0x820ECBD0;
	}
	return 0x820ECBD0;
} // Block from 820ECBC8h-820ECBD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECBD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECBD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECBD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECBD0);
		  /* 820ECBD0h */ case    0:  		/* lis R9, 1792 */
		/* 820ECBD0h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0x700);
		/* 820ECBD0h case    0:*/		return 0x820ECBD4;
		  /* 820ECBD4h */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 820ECBD4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820ECBD4h case    1:*/		return 0x820ECBD8;
		  /* 820ECBD8h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 820ECBD8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820ECC18;  }
		/* 820ECBD8h case    2:*/		return 0x820ECBDC;
		  /* 820ECBDCh */ case    3:  		/* lis R9, 2048 */
		/* 820ECBDCh case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x800);
		/* 820ECBDCh case    3:*/		return 0x820ECBE0;
		  /* 820ECBE0h */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 820ECBE0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820ECBE0h case    4:*/		return 0x820ECBE4;
		  /* 820ECBE4h */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 820ECBE4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820ECC10;  }
		/* 820ECBE4h case    5:*/		return 0x820ECBE8;
		  /* 820ECBE8h */ case    6:  		/* lis R9, 2816 */
		/* 820ECBE8h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xB00);
		/* 820ECBE8h case    6:*/		return 0x820ECBEC;
		  /* 820ECBECh */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 820ECBECh case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820ECBECh case    7:*/		return 0x820ECBF0;
		  /* 820ECBF0h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 820ECBF0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820ECC08;  }
		/* 820ECBF0h case    8:*/		return 0x820ECBF4;
		  /* 820ECBF4h */ case    9:  		/* lis R9, 3072 */
		/* 820ECBF4h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xC00);
		/* 820ECBF4h case    9:*/		return 0x820ECBF8;
		  /* 820ECBF8h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 820ECBF8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820ECBF8h case   10:*/		return 0x820ECBFC;
		  /* 820ECBFCh */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 820ECBFCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x820ECC1C;  }
		/* 820ECBFCh case   11:*/		return 0x820ECC00;
		  /* 820ECC00h */ case   12:  		/* lis R10, 2816 */
		/* 820ECC00h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xB00);
		/* 820ECC00h case   12:*/		return 0x820ECC04;
		  /* 820ECC04h */ case   13:  		/* b 24 */
		/* 820ECC04h case   13:*/		return 0x820ECC1C;
		/* 820ECC04h case   13:*/		return 0x820ECC08;
	}
	return 0x820ECC08;
} // Block from 820ECBD0h-820ECC08h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ECC08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECC08);
		  /* 820ECC08h */ case    0:  		/* lis R10, 3072 */
		/* 820ECC08h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xC00);
		/* 820ECC08h case    0:*/		return 0x820ECC0C;
		  /* 820ECC0Ch */ case    1:  		/* b 16 */
		/* 820ECC0Ch case    1:*/		return 0x820ECC1C;
		/* 820ECC0Ch case    1:*/		return 0x820ECC10;
	}
	return 0x820ECC10;
} // Block from 820ECC08h-820ECC10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECC10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECC10);
		  /* 820ECC10h */ case    0:  		/* lis R10, 1792 */
		/* 820ECC10h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x700);
		/* 820ECC10h case    0:*/		return 0x820ECC14;
		  /* 820ECC14h */ case    1:  		/* b 8 */
		/* 820ECC14h case    1:*/		return 0x820ECC1C;
		/* 820ECC14h case    1:*/		return 0x820ECC18;
	}
	return 0x820ECC18;
} // Block from 820ECC10h-820ECC18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECC18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECC18);
		  /* 820ECC18h */ case    0:  		/* lis R10, 2048 */
		/* 820ECC18h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x800);
		/* 820ECC18h case    0:*/		return 0x820ECC1C;
	}
	return 0x820ECC1C;
} // Block from 820ECC18h-820ECC1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ECC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECC1C);
		  /* 820ECC1Ch */ case    0:  		/* rlwinm R11, R3, 0, 8, 3 */
		/* 820ECC1Ch case    0:*/		cpu::op::rlwinm<0,0,8,3>(regs,&regs.R11,regs.R3);
		/* 820ECC1Ch case    0:*/		return 0x820ECC20;
		  /* 820ECC20h */ case    1:  		/* or R3, R11, R10 */
		/* 820ECC20h case    1:*/		cpu::op::or<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820ECC20h case    1:*/		return 0x820ECC24;
		  /* 820ECC24h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820ECC24h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820ECC24h case    2:*/		return 0x820ECC28;
	}
	return 0x820ECC28;
} // Block from 820ECC1Ch-820ECC28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ECC28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECC28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECC28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECC28);
		  /* 820ECC28h */ case    0:  		/* mr R3, R4 */
		/* 820ECC28h case    0:*/		regs.R3 = regs.R4;
		/* 820ECC28h case    0:*/		return 0x820ECC2C;
		  /* 820ECC2Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820ECC2Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820ECC2Ch case    1:*/		return 0x820ECC30;
	}
	return 0x820ECC30;
} // Block from 820ECC28h-820ECC30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECC30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECC30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECC30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECC30);
		  /* 820ECC30h */ case    0:  		/* mfspr R12, LR */
		/* 820ECC30h case    0:*/		regs.R12 = regs.LR;
		/* 820ECC30h case    0:*/		return 0x820ECC34;
		  /* 820ECC34h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820ECC34h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820ECC34h case    1:*/		return 0x820ECC38;
		  /* 820ECC38h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820ECC38h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820ECC38h case    2:*/		return 0x820ECC3C;
		  /* 820ECC3Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820ECC3Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820ECC3Ch case    3:*/		return 0x820ECC40;
		  /* 820ECC40h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820ECC40h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820ECC40h case    4:*/		return 0x820ECC44;
		  /* 820ECC44h */ case    5:  		/* mr R31, R3 */
		/* 820ECC44h case    5:*/		regs.R31 = regs.R3;
		/* 820ECC44h case    5:*/		return 0x820ECC48;
		  /* 820ECC48h */ case    6:  		/* b 60 */
		/* 820ECC48h case    6:*/		return 0x820ECC84;
		/* 820ECC48h case    6:*/		return 0x820ECC4C;
		  /* 820ECC4Ch */ case    7:  		/* lwz R11, <#[R31 + 4]> */
		/* 820ECC4Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820ECC4Ch case    7:*/		return 0x820ECC50;
		  /* 820ECC50h */ case    8:  		/* cmpwi CR6, R11, 1 */
		/* 820ECC50h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820ECC50h case    8:*/		return 0x820ECC54;
		  /* 820ECC54h */ case    9:  		/* bc 12, CR6_EQ, 100 */
		/* 820ECC54h case    9:*/		if ( regs.CR[6].eq ) { return 0x820ECCB8;  }
		/* 820ECC54h case    9:*/		return 0x820ECC58;
		  /* 820ECC58h */ case   10:  		/* cmpwi CR6, R11, 6 */
		/* 820ECC58h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820ECC58h case   10:*/		return 0x820ECC5C;
		  /* 820ECC5Ch */ case   11:  		/* bc 12, CR6_EQ, 36 */
		/* 820ECC5Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820ECC80;  }
		/* 820ECC5Ch case   11:*/		return 0x820ECC60;
		  /* 820ECC60h */ case   12:  		/* cmpwi CR6, R11, 8 */
		/* 820ECC60h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 820ECC60h case   12:*/		return 0x820ECC64;
		  /* 820ECC64h */ case   13:  		/* bc 12, CR6_EQ, 64 */
		/* 820ECC64h case   13:*/		if ( regs.CR[6].eq ) { return 0x820ECCA4;  }
		/* 820ECC64h case   13:*/		return 0x820ECC68;
		  /* 820ECC68h */ case   14:  		/* cmpwi CR6, R11, 9 */
		/* 820ECC68h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 820ECC68h case   14:*/		return 0x820ECC6C;
		  /* 820ECC6Ch */ case   15:  		/* bc 12, CR6_EQ, 40 */
		/* 820ECC6Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820ECC94;  }
		/* 820ECC6Ch case   15:*/		return 0x820ECC70;
		  /* 820ECC70h */ case   16:  		/* cmpwi CR6, R11, 11 */
		/* 820ECC70h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820ECC70h case   16:*/		return 0x820ECC74;
		  /* 820ECC74h */ case   17:  		/* bc 4, CR6_EQ, 24 */
		/* 820ECC74h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820ECC8C;  }
		/* 820ECC74h case   17:*/		return 0x820ECC78;
		  /* 820ECC78h */ case   18:  		/* lwz R31, <#[R31 + 48]> */
		/* 820ECC78h case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000030) );
		/* 820ECC78h case   18:*/		return 0x820ECC7C;
		  /* 820ECC7Ch */ case   19:  		/* b 8 */
		/* 820ECC7Ch case   19:*/		return 0x820ECC84;
		/* 820ECC7Ch case   19:*/		return 0x820ECC80;
	}
	return 0x820ECC80;
} // Block from 820ECC30h-820ECC80h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820ECC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECC80);
		  /* 820ECC80h */ case    0:  		/* lwz R31, <#[R31 + 24]> */
		/* 820ECC80h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000018) );
		/* 820ECC80h case    0:*/		return 0x820ECC84;
	}
	return 0x820ECC84;
} // Block from 820ECC80h-820ECC84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ECC84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECC84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECC84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECC84);
		  /* 820ECC84h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820ECC84h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820ECC84h case    0:*/		return 0x820ECC88;
		  /* 820ECC88h */ case    1:  		/* bc 4, CR6_EQ, -60 */
		/* 820ECC88h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820ECC4C;  }
		/* 820ECC88h case    1:*/		return 0x820ECC8C;
	}
	return 0x820ECC8C;
} // Block from 820ECC84h-820ECC8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECC8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECC8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECC8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECC8C);
		  /* 820ECC8Ch */ case    0:  		/* li R3, 0 */
		/* 820ECC8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820ECC8Ch case    0:*/		return 0x820ECC90;
		  /* 820ECC90h */ case    1:  		/* b 64 */
		/* 820ECC90h case    1:*/		return 0x820ECCD0;
		/* 820ECC90h case    1:*/		return 0x820ECC94;
	}
	return 0x820ECC94;
} // Block from 820ECC8Ch-820ECC94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECC94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECC94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECC94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECC94);
		  /* 820ECC94h */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 820ECC94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820ECC94h case    0:*/		return 0x820ECC98;
		  /* 820ECC98h */ case    1:  		/* lwz R10, <#[R31 + 28]> */
		/* 820ECC98h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 820ECC98h case    1:*/		return 0x820ECC9C;
		  /* 820ECC9Ch */ case    2:  		/* mullw R3, R11, R10 */
		/* 820ECC9Ch case    2:*/		cpu::op::mullw<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820ECC9Ch case    2:*/		return 0x820ECCA0;
		  /* 820ECCA0h */ case    3:  		/* b 48 */
		/* 820ECCA0h case    3:*/		return 0x820ECCD0;
		/* 820ECCA0h case    3:*/		return 0x820ECCA4;
	}
	return 0x820ECCA4;
} // Block from 820ECC94h-820ECCA4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ECCA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECCA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECCA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECCA4);
		  /* 820ECCA4h */ case    0:  		/* lwz R3, <#[R31 + 16]> */
		/* 820ECCA4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820ECCA4h case    0:*/		return 0x820ECCA8;
		  /* 820ECCA8h */ case    1:  		/* bl -120 */
		/* 820ECCA8h case    1:*/		regs.LR = 0x820ECCAC; return 0x820ECC30;
		/* 820ECCA8h case    1:*/		return 0x820ECCAC;
		  /* 820ECCACh */ case    2:  		/* lwz R11, <#[R31 + 20]> */
		/* 820ECCACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820ECCACh case    2:*/		return 0x820ECCB0;
		  /* 820ECCB0h */ case    3:  		/* mullw R3, R3, R11 */
		/* 820ECCB0h case    3:*/		cpu::op::mullw<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 820ECCB0h case    3:*/		return 0x820ECCB4;
		  /* 820ECCB4h */ case    4:  		/* b 28 */
		/* 820ECCB4h case    4:*/		return 0x820ECCD0;
		/* 820ECCB4h case    4:*/		return 0x820ECCB8;
	}
	return 0x820ECCB8;
} // Block from 820ECCA4h-820ECCB8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ECCB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECCB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECCB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECCB8);
		  /* 820ECCB8h */ case    0:  		/* lwz R3, <#[R31 + 12]> */
		/* 820ECCB8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 820ECCB8h case    0:*/		return 0x820ECCBC;
		  /* 820ECCBCh */ case    1:  		/* bl -140 */
		/* 820ECCBCh case    1:*/		regs.LR = 0x820ECCC0; return 0x820ECC30;
		/* 820ECCBCh case    1:*/		return 0x820ECCC0;
		  /* 820ECCC0h */ case    2:  		/* mr R30, R3 */
		/* 820ECCC0h case    2:*/		regs.R30 = regs.R3;
		/* 820ECCC0h case    2:*/		return 0x820ECCC4;
		  /* 820ECCC4h */ case    3:  		/* lwz R3, <#[R31 + 8]> */
		/* 820ECCC4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820ECCC4h case    3:*/		return 0x820ECCC8;
		  /* 820ECCC8h */ case    4:  		/* bl -152 */
		/* 820ECCC8h case    4:*/		regs.LR = 0x820ECCCC; return 0x820ECC30;
		/* 820ECCC8h case    4:*/		return 0x820ECCCC;
		  /* 820ECCCCh */ case    5:  		/* add R3, R30, R3 */
		/* 820ECCCCh case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R30,regs.R3);
		/* 820ECCCCh case    5:*/		return 0x820ECCD0;
	}
	return 0x820ECCD0;
} // Block from 820ECCB8h-820ECCD0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820ECCD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECCD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECCD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECCD0);
		  /* 820ECCD0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820ECCD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820ECCD0h case    0:*/		return 0x820ECCD4;
		  /* 820ECCD4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820ECCD4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820ECCD4h case    1:*/		return 0x820ECCD8;
		  /* 820ECCD8h */ case    2:  		/* mtspr LR, R12 */
		/* 820ECCD8h case    2:*/		regs.LR = regs.R12;
		/* 820ECCD8h case    2:*/		return 0x820ECCDC;
		  /* 820ECCDCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820ECCDCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820ECCDCh case    3:*/		return 0x820ECCE0;
		  /* 820ECCE0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820ECCE0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820ECCE0h case    4:*/		return 0x820ECCE4;
		  /* 820ECCE4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820ECCE4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820ECCE4h case    5:*/		return 0x820ECCE8;
	}
	return 0x820ECCE8;
} // Block from 820ECCD0h-820ECCE8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820ECCE8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECCE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECCE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECCE8);
		  /* 820ECCE8h */ case    0:  		/* mfspr R12, LR */
		/* 820ECCE8h case    0:*/		regs.R12 = regs.LR;
		/* 820ECCE8h case    0:*/		return 0x820ECCEC;
		  /* 820ECCECh */ case    1:  		/* bl -375444 */
		/* 820ECCECh case    1:*/		regs.LR = 0x820ECCF0; return 0x82091258;
		/* 820ECCECh case    1:*/		return 0x820ECCF0;
		  /* 820ECCF0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820ECCF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820ECCF0h case    2:*/		return 0x820ECCF4;
		  /* 820ECCF4h */ case    3:  		/* li R10, 0 */
		/* 820ECCF4h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820ECCF4h case    3:*/		return 0x820ECCF8;
		  /* 820ECCF8h */ case    4:  		/* mr R31, R3 */
		/* 820ECCF8h case    4:*/		regs.R31 = regs.R3;
		/* 820ECCF8h case    4:*/		return 0x820ECCFC;
		  /* 820ECCFCh */ case    5:  		/* mr R30, R4 */
		/* 820ECCFCh case    5:*/		regs.R30 = regs.R4;
		/* 820ECCFCh case    5:*/		return 0x820ECD00;
		  /* 820ECD00h */ case    6:  		/* stw R10, <#[R1 + 80]> */
		/* 820ECD00h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820ECD00h case    6:*/		return 0x820ECD04;
		  /* 820ECD04h */ case    7:  		/* mr R29, R5 */
		/* 820ECD04h case    7:*/		regs.R29 = regs.R5;
		/* 820ECD04h case    7:*/		return 0x820ECD08;
		  /* 820ECD08h */ case    8:  		/* stw R10, <#[R1 + 84]> */
		/* 820ECD08h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 820ECD08h case    8:*/		return 0x820ECD0C;
		  /* 820ECD0Ch */ case    9:  		/* mr R28, R6 */
		/* 820ECD0Ch case    9:*/		regs.R28 = regs.R6;
		/* 820ECD0Ch case    9:*/		return 0x820ECD10;
		  /* 820ECD10h */ case   10:  		/* cmplwi CR6, R7, 0 */
		/* 820ECD10h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820ECD10h case   10:*/		return 0x820ECD14;
		  /* 820ECD14h */ case   11:  		/* bc 12, CR6_EQ, 8 */
		/* 820ECD14h case   11:*/		if ( regs.CR[6].eq ) { return 0x820ECD1C;  }
		/* 820ECD14h case   11:*/		return 0x820ECD18;
		  /* 820ECD18h */ case   12:  		/* stw R10, <#[R7]> */
		/* 820ECD18h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 820ECD18h case   12:*/		return 0x820ECD1C;
	}
	return 0x820ECD1C;
} // Block from 820ECCE8h-820ECD1Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820ECD1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECD1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECD1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECD1C);
		  /* 820ECD1Ch */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 820ECD1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820ECD1Ch case    0:*/		return 0x820ECD20;
		  /* 820ECD20h */ case    1:  		/* lwz R9, <#[R31 + 136]> */
		/* 820ECD20h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000088) );
		/* 820ECD20h case    1:*/		return 0x820ECD24;
		  /* 820ECD24h */ case    2:  		/* cmplw CR6, R9, R11 */
		/* 820ECD24h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820ECD24h case    2:*/		return 0x820ECD28;
		  /* 820ECD28h */ case    3:  		/* bc 4, CR6_EQ, 108 */
		/* 820ECD28h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820ECD94;  }
		/* 820ECD28h case    3:*/		return 0x820ECD2C;
		  /* 820ECD2Ch */ case    4:  		/* lwz R11, <#[R30 + 12]> */
		/* 820ECD2Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820ECD2Ch case    4:*/		return 0x820ECD30;
		  /* 820ECD30h */ case    5:  		/* lwz R9, <#[R31 + 44]> */
		/* 820ECD30h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000002C) );
		/* 820ECD30h case    5:*/		return 0x820ECD34;
		  /* 820ECD34h */ case    6:  		/* stw R10, <#[R1 + 80]> */
		/* 820ECD34h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820ECD34h case    6:*/		return 0x820ECD38;
		  /* 820ECD38h */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 820ECD38h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820ECD38h case    7:*/		return 0x820ECD3C;
		  /* 820ECD3Ch */ case    8:  		/* stw R11, <#[R1 + 84]> */
		/* 820ECD3Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ECD3Ch case    8:*/		return 0x820ECD40;
		  /* 820ECD40h */ case    9:  		/* bc 12, CR6_LT, 44 */
		/* 820ECD40h case    9:*/		if ( regs.CR[6].lt ) { return 0x820ECD6C;  }
		/* 820ECD40h case    9:*/		return 0x820ECD44;
		  /* 820ECD44h */ case   10:  		/* lis R10, -32254 */
		/* 820ECD44h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820ECD44h case   10:*/		return 0x820ECD48;
		  /* 820ECD48h */ case   11:  		/* li R5, 4505 */
		/* 820ECD48h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x1199);
		/* 820ECD48h case   11:*/		return 0x820ECD4C;
		  /* 820ECD4Ch */ case   12:  		/* addi R6, R10, -17808 */
		/* 820ECD4Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFBA70);
		/* 820ECD4Ch case   12:*/		return 0x820ECD50;
		  /* 820ECD50h */ case   13:  		/* lwz R11, <#[R31 + 260]> */
		/* 820ECD50h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820ECD50h case   13:*/		return 0x820ECD54;
		  /* 820ECD54h */ case   14:  		/* mr R3, R31 */
		/* 820ECD54h case   14:*/		regs.R3 = regs.R31;
		/* 820ECD54h case   14:*/		return 0x820ECD58;
		  /* 820ECD58h */ case   15:  		/* lwz R4, <#[R11 + 60]> */
		/* 820ECD58h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 820ECD58h case   15:*/		return 0x820ECD5C;
		  /* 820ECD5Ch */ case   16:  		/* bl 137684 */
		/* 820ECD5Ch case   16:*/		regs.LR = 0x820ECD60; return 0x8210E730;
		/* 820ECD5Ch case   16:*/		return 0x820ECD60;
		  /* 820ECD60h */ case   17:  		/* lis R3, -30602 */
		/* 820ECD60h case   17:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820ECD60h case   17:*/		return 0x820ECD64;
		  /* 820ECD64h */ case   18:  		/* ori R3, R3, 2905 */
		/* 820ECD64h case   18:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xB59);
		/* 820ECD64h case   18:*/		return 0x820ECD68;
		  /* 820ECD68h */ case   19:  		/* b 324 */
		/* 820ECD68h case   19:*/		return 0x820ECEAC;
		/* 820ECD68h case   19:*/		return 0x820ECD6C;
	}
	return 0x820ECD6C;
} // Block from 820ECD1Ch-820ECD6Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820ECD6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECD6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECD6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECD6C);
		  /* 820ECD6Ch */ case    0:  		/* lwz R9, <#[R31 + 80]> */
		/* 820ECD6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000050) );
		/* 820ECD6Ch case    0:*/		return 0x820ECD70;
		  /* 820ECD70h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 820ECD70h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820ECD70h case    1:*/		return 0x820ECD74;
		  /* 820ECD74h */ case    2:  		/* bc 12, CR6_EQ, 144 */
		/* 820ECD74h case    2:*/		if ( regs.CR[6].eq ) { return 0x820ECE04;  }
		/* 820ECD74h case    2:*/		return 0x820ECD78;
		  /* 820ECD78h */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 820ECD78h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820ECD78h case    3:*/		return 0x820ECD7C;
		  /* 820ECD7Ch */ case    4:  		/* bc 12, CR6_LT, 136 */
		/* 820ECD7Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820ECE04;  }
		/* 820ECD7Ch case    4:*/		return 0x820ECD80;
		  /* 820ECD80h */ case    5:  		/* subf R11, R9, R11 */
		/* 820ECD80h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820ECD80h case    5:*/		return 0x820ECD84;
		  /* 820ECD84h */ case    6:  		/* li R10, 3 */
		/* 820ECD84h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820ECD84h case    6:*/		return 0x820ECD88;
		  /* 820ECD88h */ case    7:  		/* stw R11, <#[R1 + 84]> */
		/* 820ECD88h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ECD88h case    7:*/		return 0x820ECD8C;
		  /* 820ECD8Ch */ case    8:  		/* stw R10, <#[R1 + 80]> */
		/* 820ECD8Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820ECD8Ch case    8:*/		return 0x820ECD90;
		  /* 820ECD90h */ case    9:  		/* b 116 */
		/* 820ECD90h case    9:*/		return 0x820ECE04;
		/* 820ECD90h case    9:*/		return 0x820ECD94;
	}
	return 0x820ECD94;
} // Block from 820ECD6Ch-820ECD94h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820ECD94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECD94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECD94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECD94);
		  /* 820ECD94h */ case    0:  		/* lwz R10, <#[R31 + 140]> */
		/* 820ECD94h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000008C) );
		/* 820ECD94h case    0:*/		return 0x820ECD98;
		  /* 820ECD98h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 820ECD98h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820ECD98h case    1:*/		return 0x820ECD9C;
		  /* 820ECD9Ch */ case    2:  		/* bc 4, CR6_EQ, 44 */
		/* 820ECD9Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ECDC8;  }
		/* 820ECD9Ch case    2:*/		return 0x820ECDA0;
		  /* 820ECDA0h */ case    3:  		/* lwz R11, <#[R30 + 12]> */
		/* 820ECDA0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820ECDA0h case    3:*/		return 0x820ECDA4;
		  /* 820ECDA4h */ case    4:  		/* li R10, 3 */
		/* 820ECDA4h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820ECDA4h case    4:*/		return 0x820ECDA8;
		  /* 820ECDA8h */ case    5:  		/* stw R10, <#[R1 + 80]> */
		/* 820ECDA8h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820ECDA8h case    5:*/		return 0x820ECDAC;
		  /* 820ECDACh */ case    6:  		/* cmplwi CR6, R11, 1 */
		/* 820ECDACh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820ECDACh case    6:*/		return 0x820ECDB0;
		  /* 820ECDB0h */ case    7:  		/* stw R11, <#[R1 + 84]> */
		/* 820ECDB0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ECDB0h case    7:*/		return 0x820ECDB4;
		  /* 820ECDB4h */ case    8:  		/* bc 12, CR6_LT, 80 */
		/* 820ECDB4h case    8:*/		if ( regs.CR[6].lt ) { return 0x820ECE04;  }
		/* 820ECDB4h case    8:*/		return 0x820ECDB8;
		  /* 820ECDB8h */ case    9:  		/* lis R10, -32254 */
		/* 820ECDB8h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820ECDB8h case    9:*/		return 0x820ECDBC;
		  /* 820ECDBCh */ case   10:  		/* li R5, 4508 */
		/* 820ECDBCh case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x119C);
		/* 820ECDBCh case   10:*/		return 0x820ECDC0;
		  /* 820ECDC0h */ case   11:  		/* addi R6, R10, -17848 */
		/* 820ECDC0h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFBA48);
		/* 820ECDC0h case   11:*/		return 0x820ECDC4;
		  /* 820ECDC4h */ case   12:  		/* b -116 */
		/* 820ECDC4h case   12:*/		return 0x820ECD50;
		/* 820ECDC4h case   12:*/		return 0x820ECDC8;
	}
	return 0x820ECDC8;
} // Block from 820ECD94h-820ECDC8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820ECDC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECDC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECDC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECDC8);
		  /* 820ECDC8h */ case    0:  		/* lwz R10, <#[R31 + 132]> */
		/* 820ECDC8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 820ECDC8h case    0:*/		return 0x820ECDCC;
		  /* 820ECDCCh */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 820ECDCCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820ECDCCh case    1:*/		return 0x820ECDD0;
		  /* 820ECDD0h */ case    2:  		/* bc 4, CR6_EQ, 132 */
		/* 820ECDD0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ECE54;  }
		/* 820ECDD0h case    2:*/		return 0x820ECDD4;
		  /* 820ECDD4h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820ECDD4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820ECDD4h case    3:*/		return 0x820ECDD8;
		  /* 820ECDD8h */ case    4:  		/* addi R6, R1, 80 */
		/* 820ECDD8h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820ECDD8h case    4:*/		return 0x820ECDDC;
		  /* 820ECDDCh */ case    5:  		/* addi R5, R1, 84 */
		/* 820ECDDCh case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820ECDDCh case    5:*/		return 0x820ECDE0;
		  /* 820ECDE0h */ case    6:  		/* mr R4, R30 */
		/* 820ECDE0h case    6:*/		regs.R4 = regs.R30;
		/* 820ECDE0h case    6:*/		return 0x820ECDE4;
		  /* 820ECDE4h */ case    7:  		/* mr R3, R31 */
		/* 820ECDE4h case    7:*/		regs.R3 = regs.R31;
		/* 820ECDE4h case    7:*/		return 0x820ECDE8;
		  /* 820ECDE8h */ case    8:  		/* lwz R11, <#[R11 + 344]> */
		/* 820ECDE8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000158) );
		/* 820ECDE8h case    8:*/		return 0x820ECDEC;
		  /* 820ECDECh */ case    9:  		/* mtspr CTR, R11 */
		/* 820ECDECh case    9:*/		regs.CTR = regs.R11;
		/* 820ECDECh case    9:*/		return 0x820ECDF0;
		  /* 820ECDF0h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820ECDF0h case   10:*/		if ( 1 ) { regs.LR = 0x820ECDF4; return (uint32)regs.CTR; }
		/* 820ECDF0h case   10:*/		return 0x820ECDF4;
		  /* 820ECDF4h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820ECDF4h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820ECDF4h case   11:*/		return 0x820ECDF8;
		  /* 820ECDF8h */ case   12:  		/* bc 12, CR0_LT, 172 */
		/* 820ECDF8h case   12:*/		if ( regs.CR[0].lt ) { return 0x820ECEA4;  }
		/* 820ECDF8h case   12:*/		return 0x820ECDFC;
		  /* 820ECDFCh */ case   13:  		/* lwz R10, <#[R1 + 80]> */
		/* 820ECDFCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820ECDFCh case   13:*/		return 0x820ECE00;
		  /* 820ECE00h */ case   14:  		/* lwz R11, <#[R1 + 84]> */
		/* 820ECE00h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ECE00h case   14:*/		return 0x820ECE04;
	}
	return 0x820ECE04;
} // Block from 820ECDC8h-820ECE04h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820ECE04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECE04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECE04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECE04);
		  /* 820ECE04h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820ECE04h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820ECE04h case    0:*/		return 0x820ECE08;
		  /* 820ECE08h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 820ECE08h case    1:*/		if ( regs.CR[6].eq ) { return 0x820ECE2C;  }
		/* 820ECE08h case    1:*/		return 0x820ECE0C;
		  /* 820ECE0Ch */ case    2:  		/* lis R9, -128 */
		/* 820ECE0Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFF80);
		/* 820ECE0Ch case    2:*/		return 0x820ECE10;
		  /* 820ECE10h */ case    3:  		/* rlwinm R8, R10, 0, 27, 28 */
		/* 820ECE10h case    3:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R8,regs.R10);
		/* 820ECE10h case    3:*/		return 0x820ECE14;
		  /* 820ECE14h */ case    4:  		/* rlwimi R9, R10, 20, 9, 11 */
		/* 820ECE14h case    4:*/		cpu::op::rlwimi<0,20,9,11>(regs,&regs.R9,regs.R10);
		/* 820ECE14h case    4:*/		return 0x820ECE18;
		  /* 820ECE18h */ case    5:  		/* rlwinm R11, R11, 0, 21, 31 */
		/* 820ECE18h case    5:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R11,regs.R11);
		/* 820ECE18h case    5:*/		return 0x820ECE1C;
		  /* 820ECE1Ch */ case    6:  		/* or R10, R9, R8 */
		/* 820ECE1Ch case    6:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R8);
		/* 820ECE1Ch case    6:*/		return 0x820ECE20;
		  /* 820ECE20h */ case    7:  		/* rlwinm R10, R10, 8, 0, 23 */
		/* 820ECE20h case    7:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R10,regs.R10);
		/* 820ECE20h case    7:*/		return 0x820ECE24;
		  /* 820ECE24h */ case    8:  		/* or R11, R10, R11 */
		/* 820ECE24h case    8:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820ECE24h case    8:*/		return 0x820ECE28;
		  /* 820ECE28h */ case    9:  		/* stw R11, <#[R29]> */
		/* 820ECE28h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820ECE28h case    9:*/		return 0x820ECE2C;
	}
	return 0x820ECE2C;
} // Block from 820ECE04h-820ECE2Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820ECE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECE2C);
		  /* 820ECE2Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820ECE2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820ECE2Ch case    0:*/		return 0x820ECE30;
		  /* 820ECE30h */ case    1:  		/* mr R5, R28 */
		/* 820ECE30h case    1:*/		regs.R5 = regs.R28;
		/* 820ECE30h case    1:*/		return 0x820ECE34;
		  /* 820ECE34h */ case    2:  		/* mr R4, R30 */
		/* 820ECE34h case    2:*/		regs.R4 = regs.R30;
		/* 820ECE34h case    2:*/		return 0x820ECE38;
		  /* 820ECE38h */ case    3:  		/* mr R3, R31 */
		/* 820ECE38h case    3:*/		regs.R3 = regs.R31;
		/* 820ECE38h case    3:*/		return 0x820ECE3C;
		  /* 820ECE3Ch */ case    4:  		/* lwz R11, <#[R11 + 336]> */
		/* 820ECE3Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000150) );
		/* 820ECE3Ch case    4:*/		return 0x820ECE40;
		  /* 820ECE40h */ case    5:  		/* mtspr CTR, R11 */
		/* 820ECE40h case    5:*/		regs.CTR = regs.R11;
		/* 820ECE40h case    5:*/		return 0x820ECE44;
		  /* 820ECE44h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820ECE44h case    6:*/		if ( 1 ) { regs.LR = 0x820ECE48; return (uint32)regs.CTR; }
		/* 820ECE44h case    6:*/		return 0x820ECE48;
		  /* 820ECE48h */ case    7:  		/* srawi R11, R3, 31 */
		/* 820ECE48h case    7:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820ECE48h case    7:*/		return 0x820ECE4C;
		  /* 820ECE4Ch */ case    8:  		/* and R3, R11, R3 */
		/* 820ECE4Ch case    8:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820ECE4Ch case    8:*/		return 0x820ECE50;
		  /* 820ECE50h */ case    9:  		/* b 92 */
		/* 820ECE50h case    9:*/		return 0x820ECEAC;
		/* 820ECE50h case    9:*/		return 0x820ECE54;
	}
	return 0x820ECE54;
} // Block from 820ECE2Ch-820ECE54h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820ECE54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECE54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECE54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECE54);
		  /* 820ECE54h */ case    0:  		/* lwz R10, <#[R31 + 144]> */
		/* 820ECE54h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000090) );
		/* 820ECE54h case    0:*/		return 0x820ECE58;
		  /* 820ECE58h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 820ECE58h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820ECE58h case    1:*/		return 0x820ECE5C;
		  /* 820ECE5Ch */ case    2:  		/* bc 4, CR6_EQ, 48 */
		/* 820ECE5Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ECE8C;  }
		/* 820ECE5Ch case    2:*/		return 0x820ECE60;
		  /* 820ECE60h */ case    3:  		/* lwz R11, <#[R30 + 12]> */
		/* 820ECE60h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820ECE60h case    3:*/		return 0x820ECE64;
		  /* 820ECE64h */ case    4:  		/* li R10, 19 */
		/* 820ECE64h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x13);
		/* 820ECE64h case    4:*/		return 0x820ECE68;
		  /* 820ECE68h */ case    5:  		/* lwz R9, <#[R31 + 52]> */
		/* 820ECE68h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000034) );
		/* 820ECE68h case    5:*/		return 0x820ECE6C;
		  /* 820ECE6Ch */ case    6:  		/* stw R10, <#[R1 + 80]> */
		/* 820ECE6Ch case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820ECE6Ch case    6:*/		return 0x820ECE70;
		  /* 820ECE70h */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 820ECE70h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820ECE70h case    7:*/		return 0x820ECE74;
		  /* 820ECE74h */ case    8:  		/* stw R11, <#[R1 + 84]> */
		/* 820ECE74h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ECE74h case    8:*/		return 0x820ECE78;
		  /* 820ECE78h */ case    9:  		/* bc 12, CR6_LT, -116 */
		/* 820ECE78h case    9:*/		if ( regs.CR[6].lt ) { return 0x820ECE04;  }
		/* 820ECE78h case    9:*/		return 0x820ECE7C;
		  /* 820ECE7Ch */ case   10:  		/* lis R10, -32254 */
		/* 820ECE7Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820ECE7Ch case   10:*/		return 0x820ECE80;
		  /* 820ECE80h */ case   11:  		/* li R5, 4549 */
		/* 820ECE80h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x11C5);
		/* 820ECE80h case   11:*/		return 0x820ECE84;
		  /* 820ECE84h */ case   12:  		/* addi R6, R10, -17892 */
		/* 820ECE84h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFBA1C);
		/* 820ECE84h case   12:*/		return 0x820ECE88;
		  /* 820ECE88h */ case   13:  		/* b -312 */
		/* 820ECE88h case   13:*/		return 0x820ECD50;
		/* 820ECE88h case   13:*/		return 0x820ECE8C;
	}
	return 0x820ECE8C;
} // Block from 820ECE54h-820ECE8Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ECE8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECE8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECE8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECE8C);
		  /* 820ECE8Ch */ case    0:  		/* lis R11, -32254 */
		/* 820ECE8Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820ECE8Ch case    0:*/		return 0x820ECE90;
		  /* 820ECE90h */ case    1:  		/* li R5, 0 */
		/* 820ECE90h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820ECE90h case    1:*/		return 0x820ECE94;
		  /* 820ECE94h */ case    2:  		/* addi R6, R11, -17940 */
		/* 820ECE94h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB9EC);
		/* 820ECE94h case    2:*/		return 0x820ECE98;
		  /* 820ECE98h */ case    3:  		/* li R4, 0 */
		/* 820ECE98h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820ECE98h case    3:*/		return 0x820ECE9C;
		  /* 820ECE9Ch */ case    4:  		/* mr R3, R31 */
		/* 820ECE9Ch case    4:*/		regs.R3 = regs.R31;
		/* 820ECE9Ch case    4:*/		return 0x820ECEA0;
	}
	return 0x820ECEA0;
} // Block from 820ECE8Ch-820ECEA0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ECEA0h
// Function '?FindMatchUp@CShaderProgram@D3DXShader@@IAAJKPAVCInstruction@2@PAPAV32@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECEA0);
		  /* 820ECEA0h */ case    0:  		/* bl 137360 */
		/* 820ECEA0h case    0:*/		regs.LR = 0x820ECEA4; return 0x8210E730;
		/* 820ECEA0h case    0:*/		return 0x820ECEA4;
	}
	return 0x820ECEA4;
} // Block from 820ECEA0h-820ECEA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ECEA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECEA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECEA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECEA4);
		  /* 820ECEA4h */ case    0:  		/* lis R3, -32768 */
		/* 820ECEA4h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820ECEA4h case    0:*/		return 0x820ECEA8;
		  /* 820ECEA8h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820ECEA8h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820ECEA8h case    1:*/		return 0x820ECEAC;
	}
	return 0x820ECEAC;
} // Block from 820ECEA4h-820ECEACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECEACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECEAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECEAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECEAC);
		  /* 820ECEACh */ case    0:  		/* addi R1, R1, 128 */
		/* 820ECEACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820ECEACh case    0:*/		return 0x820ECEB0;
		  /* 820ECEB0h */ case    1:  		/* b -375816 */
		/* 820ECEB0h case    1:*/		return 0x820912A8;
		/* 820ECEB0h case    1:*/		return 0x820ECEB4;
		  /* 820ECEB4h */ case    2:  		/* nop */
		/* 820ECEB4h case    2:*/		cpu::op::nop();
		/* 820ECEB4h case    2:*/		return 0x820ECEB8;
	}
	return 0x820ECEB8;
} // Block from 820ECEACh-820ECEB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ECEB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECEB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECEB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECEB8);
		  /* 820ECEB8h */ case    0:  		/* mfspr R12, LR */
		/* 820ECEB8h case    0:*/		regs.R12 = regs.LR;
		/* 820ECEB8h case    0:*/		return 0x820ECEBC;
		  /* 820ECEBCh */ case    1:  		/* bl -375932 */
		/* 820ECEBCh case    1:*/		regs.LR = 0x820ECEC0; return 0x82091240;
		/* 820ECEBCh case    1:*/		return 0x820ECEC0;
		  /* 820ECEC0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820ECEC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820ECEC0h case    2:*/		return 0x820ECEC4;
		  /* 820ECEC4h */ case    3:  		/* lwz R11, <#[R4]> */
		/* 820ECEC4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820ECEC4h case    3:*/		return 0x820ECEC8;
		  /* 820ECEC8h */ case    4:  		/* mr R28, R3 */
		/* 820ECEC8h case    4:*/		regs.R28 = regs.R3;
		/* 820ECEC8h case    4:*/		return 0x820ECECC;
		  /* 820ECECCh */ case    5:  		/* lwz R10, <#[R3 + 20]> */
		/* 820ECECCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 820ECECCh case    5:*/		return 0x820ECED0;
		  /* 820ECED0h */ case    6:  		/* mr R25, R4 */
		/* 820ECED0h case    6:*/		regs.R25 = regs.R4;
		/* 820ECED0h case    6:*/		return 0x820ECED4;
		  /* 820ECED4h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820ECED4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820ECED4h case    7:*/		return 0x820ECED8;
		  /* 820ECED8h */ case    8:  		/* mr R24, R5 */
		/* 820ECED8h case    8:*/		regs.R24 = regs.R5;
		/* 820ECED8h case    8:*/		return 0x820ECEDC;
		  /* 820ECEDCh */ case    9:  		/* mr R22, R6 */
		/* 820ECEDCh case    9:*/		regs.R22 = regs.R6;
		/* 820ECEDCh case    9:*/		return 0x820ECEE0;
		  /* 820ECEE0h */ case   10:  		/* li R26, 0 */
		/* 820ECEE0h case   10:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820ECEE0h case   10:*/		return 0x820ECEE4;
		  /* 820ECEE4h */ case   11:  		/* li R23, 0 */
		/* 820ECEE4h case   11:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820ECEE4h case   11:*/		return 0x820ECEE8;
		  /* 820ECEE8h */ case   12:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820ECEE8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820ECEE8h case   12:*/		return 0x820ECEEC;
		  /* 820ECEECh */ case   13:  		/* lwz R11, <#[R11 + 60]> */
		/* 820ECEECh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820ECEECh case   13:*/		return 0x820ECEF0;
		  /* 820ECEF0h */ case   14:  		/* rlwinm. R10, R11, 0, 21, 21 */
		/* 820ECEF0h case   14:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R11);
		/* 820ECEF0h case   14:*/		return 0x820ECEF4;
		  /* 820ECEF4h */ case   15:  		/* bc 12, CR0_EQ, 12 */
		/* 820ECEF4h case   15:*/		if ( regs.CR[0].eq ) { return 0x820ECF00;  }
		/* 820ECEF4h case   15:*/		return 0x820ECEF8;
		  /* 820ECEF8h */ case   16:  		/* lis R23, 256 */
		/* 820ECEF8h case   16:*/		cpu::op::lis<0>(regs,&regs.R23,0x100);
		/* 820ECEF8h case   16:*/		return 0x820ECEFC;
		  /* 820ECEFCh */ case   17:  		/* b 80 */
		/* 820ECEFCh case   17:*/		return 0x820ECF4C;
		/* 820ECEFCh case   17:*/		return 0x820ECF00;
	}
	return 0x820ECF00;
} // Block from 820ECEB8h-820ECF00h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820ECF00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECF00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECF00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECF00);
		  /* 820ECF00h */ case    0:  		/* rlwinm. R10, R11, 0, 20, 20 */
		/* 820ECF00h case    0:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R11);
		/* 820ECF00h case    0:*/		return 0x820ECF04;
		  /* 820ECF04h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820ECF04h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ECF10;  }
		/* 820ECF04h case    1:*/		return 0x820ECF08;
		  /* 820ECF08h */ case    2:  		/* lis R23, 512 */
		/* 820ECF08h case    2:*/		cpu::op::lis<0>(regs,&regs.R23,0x200);
		/* 820ECF08h case    2:*/		return 0x820ECF0C;
		  /* 820ECF0Ch */ case    3:  		/* b 64 */
		/* 820ECF0Ch case    3:*/		return 0x820ECF4C;
		/* 820ECF0Ch case    3:*/		return 0x820ECF10;
	}
	return 0x820ECF10;
} // Block from 820ECF00h-820ECF10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ECF10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECF10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECF10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECF10);
		  /* 820ECF10h */ case    0:  		/* rlwinm. R10, R11, 0, 19, 19 */
		/* 820ECF10h case    0:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R10,regs.R11);
		/* 820ECF10h case    0:*/		return 0x820ECF14;
		  /* 820ECF14h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820ECF14h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ECF20;  }
		/* 820ECF14h case    1:*/		return 0x820ECF18;
		  /* 820ECF18h */ case    2:  		/* lis R23, 768 */
		/* 820ECF18h case    2:*/		cpu::op::lis<0>(regs,&regs.R23,0x300);
		/* 820ECF18h case    2:*/		return 0x820ECF1C;
		  /* 820ECF1Ch */ case    3:  		/* b 48 */
		/* 820ECF1Ch case    3:*/		return 0x820ECF4C;
		/* 820ECF1Ch case    3:*/		return 0x820ECF20;
	}
	return 0x820ECF20;
} // Block from 820ECF10h-820ECF20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ECF20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECF20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECF20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECF20);
		  /* 820ECF20h */ case    0:  		/* rlwinm. R10, R11, 0, 18, 18 */
		/* 820ECF20h case    0:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R10,regs.R11);
		/* 820ECF20h case    0:*/		return 0x820ECF24;
		  /* 820ECF24h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820ECF24h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ECF30;  }
		/* 820ECF24h case    1:*/		return 0x820ECF28;
		  /* 820ECF28h */ case    2:  		/* lis R23, 3840 */
		/* 820ECF28h case    2:*/		cpu::op::lis<0>(regs,&regs.R23,0xF00);
		/* 820ECF28h case    2:*/		return 0x820ECF2C;
		  /* 820ECF2Ch */ case    3:  		/* b 32 */
		/* 820ECF2Ch case    3:*/		return 0x820ECF4C;
		/* 820ECF2Ch case    3:*/		return 0x820ECF30;
	}
	return 0x820ECF30;
} // Block from 820ECF20h-820ECF30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ECF30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECF30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECF30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECF30);
		  /* 820ECF30h */ case    0:  		/* rlwinm. R10, R11, 0, 17, 17 */
		/* 820ECF30h case    0:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R10,regs.R11);
		/* 820ECF30h case    0:*/		return 0x820ECF34;
		  /* 820ECF34h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820ECF34h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ECF40;  }
		/* 820ECF34h case    1:*/		return 0x820ECF38;
		  /* 820ECF38h */ case    2:  		/* lis R23, 3584 */
		/* 820ECF38h case    2:*/		cpu::op::lis<0>(regs,&regs.R23,0xE00);
		/* 820ECF38h case    2:*/		return 0x820ECF3C;
		  /* 820ECF3Ch */ case    3:  		/* b 16 */
		/* 820ECF3Ch case    3:*/		return 0x820ECF4C;
		/* 820ECF3Ch case    3:*/		return 0x820ECF40;
	}
	return 0x820ECF40;
} // Block from 820ECF30h-820ECF40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ECF40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECF40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECF40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECF40);
		  /* 820ECF40h */ case    0:  		/* rlwinm. R10, R11, 0, 16, 16 */
		/* 820ECF40h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R11);
		/* 820ECF40h case    0:*/		return 0x820ECF44;
		  /* 820ECF44h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 820ECF44h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ECF4C;  }
		/* 820ECF44h case    1:*/		return 0x820ECF48;
		  /* 820ECF48h */ case    2:  		/* lis R23, 3328 */
		/* 820ECF48h case    2:*/		cpu::op::lis<0>(regs,&regs.R23,0xD00);
		/* 820ECF48h case    2:*/		return 0x820ECF4C;
	}
	return 0x820ECF4C;
} // Block from 820ECF40h-820ECF4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ECF4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECF4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECF4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECF4C);
		  /* 820ECF4Ch */ case    0:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 820ECF4Ch case    0:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 820ECF4Ch case    0:*/		return 0x820ECF50;
		  /* 820ECF50h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 820ECF50h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ECF58;  }
		/* 820ECF50h case    1:*/		return 0x820ECF54;
		  /* 820ECF54h */ case    2:  		/* oris R23, R23, 16 */
		/* 820ECF54h case    2:*/		cpu::op::oris<0>(regs,&regs.R23,regs.R23,0x10);
		/* 820ECF54h case    2:*/		return 0x820ECF58;
	}
	return 0x820ECF58;
} // Block from 820ECF4Ch-820ECF58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ECF58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECF58);
		  /* 820ECF58h */ case    0:  		/* cmpwi CR6, R7, 0 */
		/* 820ECF58h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 820ECF58h case    0:*/		return 0x820ECF5C;
		  /* 820ECF5Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820ECF5Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820ECF68;  }
		/* 820ECF5Ch case    1:*/		return 0x820ECF60;
		  /* 820ECF60h */ case    2:  		/* lis R26, 15 */
		/* 820ECF60h case    2:*/		cpu::op::lis<0>(regs,&regs.R26,0xF);
		/* 820ECF60h case    2:*/		return 0x820ECF64;
		  /* 820ECF64h */ case    3:  		/* b 152 */
		/* 820ECF64h case    3:*/		return 0x820ECFFC;
		/* 820ECF64h case    3:*/		return 0x820ECF68;
	}
	return 0x820ECF68;
} // Block from 820ECF58h-820ECF68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ECF68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECF68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECF68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECF68);
		  /* 820ECF68h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 820ECF68h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820ECF68h case    0:*/		return 0x820ECF6C;
		  /* 820ECF6Ch */ case    1:  		/* bc 12, CR6_EQ, 144 */
		/* 820ECF6Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820ECFFC;  }
		/* 820ECF6Ch case    1:*/		return 0x820ECF70;
		  /* 820ECF70h */ case    2:  		/* lis R11, -32254 */
		/* 820ECF70h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820ECF70h case    2:*/		return 0x820ECF74;
		  /* 820ECF74h */ case    3:  		/* mr R30, R25 */
		/* 820ECF74h case    3:*/		regs.R30 = regs.R25;
		/* 820ECF74h case    3:*/		return 0x820ECF78;
		  /* 820ECF78h */ case    4:  		/* mr R29, R24 */
		/* 820ECF78h case    4:*/		regs.R29 = regs.R24;
		/* 820ECF78h case    4:*/		return 0x820ECF7C;
		  /* 820ECF7Ch */ case    5:  		/* addi R27, R11, -31760 */
		/* 820ECF7Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFF83F0);
		/* 820ECF7Ch case    5:*/		return 0x820ECF80;
		  /* 820ECF80h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 820ECF80h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820ECF80h case    6:*/		return 0x820ECF84;
		  /* 820ECF84h */ case    7:  		/* li R31, 0 */
		/* 820ECF84h case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820ECF84h case    7:*/		return 0x820ECF88;
		  /* 820ECF88h */ case    8:  		/* lwz R10, <#[R28 + 20]> */
		/* 820ECF88h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000014) );
		/* 820ECF88h case    8:*/		return 0x820ECF8C;
		  /* 820ECF8Ch */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820ECF8Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820ECF8Ch case    9:*/		return 0x820ECF90;
		  /* 820ECF90h */ case   10:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820ECF90h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820ECF90h case   10:*/		return 0x820ECF94;
		  /* 820ECF94h */ case   11:  		/* lwz R11, <#[R11 + 16]> */
		/* 820ECF94h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820ECF94h case   11:*/		return 0x820ECF98;
		  /* 820ECF98h */ case   12:  		/* cmplwi CR6, R11, 1 */
		/* 820ECF98h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820ECF98h case   12:*/		return 0x820ECF9C;
		  /* 820ECF9Ch */ case   13:  		/* bc 12, CR6_LT, 44 */
		/* 820ECF9Ch case   13:*/		if ( regs.CR[6].lt ) { return 0x820ECFC8;  }
		/* 820ECF9Ch case   13:*/		return 0x820ECFA0;
		  /* 820ECFA0h */ case   14:  		/* bc 12, CR6_EQ, 32 */
		/* 820ECFA0h case   14:*/		if ( regs.CR[6].eq ) { return 0x820ECFC0;  }
		/* 820ECFA0h case   14:*/		return 0x820ECFA4;
		  /* 820ECFA4h */ case   15:  		/* cmplwi CR6, R11, 3 */
		/* 820ECFA4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820ECFA4h case   15:*/		return 0x820ECFA8;
		  /* 820ECFA8h */ case   16:  		/* bc 12, CR6_LT, 16 */
		/* 820ECFA8h case   16:*/		if ( regs.CR[6].lt ) { return 0x820ECFB8;  }
		/* 820ECFA8h case   16:*/		return 0x820ECFAC;
		  /* 820ECFACh */ case   17:  		/* bc 4, CR6_EQ, 32 */
		/* 820ECFACh case   17:*/		if ( !regs.CR[6].eq ) { return 0x820ECFCC;  }
		/* 820ECFACh case   17:*/		return 0x820ECFB0;
		  /* 820ECFB0h */ case   18:  		/* lis R31, 8 */
		/* 820ECFB0h case   18:*/		cpu::op::lis<0>(regs,&regs.R31,0x8);
		/* 820ECFB0h case   18:*/		return 0x820ECFB4;
		  /* 820ECFB4h */ case   19:  		/* b 24 */
		/* 820ECFB4h case   19:*/		return 0x820ECFCC;
		/* 820ECFB4h case   19:*/		return 0x820ECFB8;
	}
	return 0x820ECFB8;
} // Block from 820ECF68h-820ECFB8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820ECFB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECFB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECFB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECFB8);
		  /* 820ECFB8h */ case    0:  		/* lis R31, 4 */
		/* 820ECFB8h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0x4);
		/* 820ECFB8h case    0:*/		return 0x820ECFBC;
		  /* 820ECFBCh */ case    1:  		/* b 16 */
		/* 820ECFBCh case    1:*/		return 0x820ECFCC;
		/* 820ECFBCh case    1:*/		return 0x820ECFC0;
	}
	return 0x820ECFC0;
} // Block from 820ECFB8h-820ECFC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECFC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECFC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECFC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECFC0);
		  /* 820ECFC0h */ case    0:  		/* lis R31, 2 */
		/* 820ECFC0h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0x2);
		/* 820ECFC0h case    0:*/		return 0x820ECFC4;
		  /* 820ECFC4h */ case    1:  		/* b 8 */
		/* 820ECFC4h case    1:*/		return 0x820ECFCC;
		/* 820ECFC4h case    1:*/		return 0x820ECFC8;
	}
	return 0x820ECFC8;
} // Block from 820ECFC0h-820ECFC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ECFC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECFC8);
		  /* 820ECFC8h */ case    0:  		/* lis R31, 1 */
		/* 820ECFC8h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0x1);
		/* 820ECFC8h case    0:*/		return 0x820ECFCC;
	}
	return 0x820ECFCC;
} // Block from 820ECFC8h-820ECFCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ECFCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECFCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECFCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECFCC);
		  /* 820ECFCCh */ case    0:  		/* and. R11, R31, R26 */
		/* 820ECFCCh case    0:*/		cpu::op::and<1>(regs,&regs.R11,regs.R31,regs.R26);
		/* 820ECFCCh case    0:*/		return 0x820ECFD0;
		  /* 820ECFD0h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 820ECFD0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ECFEC;  }
		/* 820ECFD0h case    1:*/		return 0x820ECFD4;
		  /* 820ECFD4h */ case    2:  		/* lwz R11, <#[R28 + 260]> */
		/* 820ECFD4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000104) );
		/* 820ECFD4h case    2:*/		return 0x820ECFD8;
		  /* 820ECFD8h */ case    3:  		/* mr R6, R27 */
		/* 820ECFD8h case    3:*/		regs.R6 = regs.R27;
		/* 820ECFD8h case    3:*/		return 0x820ECFDC;
		  /* 820ECFDCh */ case    4:  		/* li R5, 4821 */
		/* 820ECFDCh case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x12D5);
		/* 820ECFDCh case    4:*/		return 0x820ECFE0;
		  /* 820ECFE0h */ case    5:  		/* mr R3, R28 */
		/* 820ECFE0h case    5:*/		regs.R3 = regs.R28;
		/* 820ECFE0h case    5:*/		return 0x820ECFE4;
		  /* 820ECFE4h */ case    6:  		/* lwz R4, <#[R11 + 60]> */
		/* 820ECFE4h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 820ECFE4h case    6:*/		return 0x820ECFE8;
		  /* 820ECFE8h */ case    7:  		/* bl 137032 */
		/* 820ECFE8h case    7:*/		regs.LR = 0x820ECFEC; return 0x8210E730;
		/* 820ECFE8h case    7:*/		return 0x820ECFEC;
	}
	return 0x820ECFEC;
} // Block from 820ECFCCh-820ECFECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820ECFECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECFEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECFEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECFEC);
		  /* 820ECFECh */ case    0:  		/* addic. R29, R29, -1 */
		/* 820ECFECh case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820ECFECh case    0:*/		return 0x820ECFF0;
		  /* 820ECFF0h */ case    1:  		/* or R26, R31, R26 */
		/* 820ECFF0h case    1:*/		cpu::op::or<0>(regs,&regs.R26,regs.R31,regs.R26);
		/* 820ECFF0h case    1:*/		return 0x820ECFF4;
		  /* 820ECFF4h */ case    2:  		/* addi R30, R30, 4 */
		/* 820ECFF4h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820ECFF4h case    2:*/		return 0x820ECFF8;
		  /* 820ECFF8h */ case    3:  		/* bc 4, CR0_EQ, -120 */
		/* 820ECFF8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820ECF80;  }
		/* 820ECFF8h case    3:*/		return 0x820ECFFC;
	}
	return 0x820ECFFC;
} // Block from 820ECFECh-820ECFFCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ECFFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ECFFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ECFFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ECFFC);
		  /* 820ECFFCh */ case    0:  		/* lwz R11, <#[R28 + 108]> */
		/* 820ECFFCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000006C) );
		/* 820ECFFCh case    0:*/		return 0x820ED000;
		  /* 820ED000h */ case    1:  		/* rlwinm. R11, R11, 0, 24, 24 */
		/* 820ED000h case    1:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R11);
		/* 820ED000h case    1:*/		return 0x820ED004;
		  /* 820ED004h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 820ED004h case    2:*/		if ( regs.CR[0].eq ) { return 0x820ED024;  }
		/* 820ED004h case    2:*/		return 0x820ED008;
		  /* 820ED008h */ case    3:  		/* rlwinm. R11, R26, 0, 12, 12 */
		/* 820ED008h case    3:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R26);
		/* 820ED008h case    3:*/		return 0x820ED00C;
		  /* 820ED00Ch */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 820ED00Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x820ED018;  }
		/* 820ED00Ch case    4:*/		return 0x820ED010;
		  /* 820ED010h */ case    5:  		/* lis R26, 7 */
		/* 820ED010h case    5:*/		cpu::op::lis<0>(regs,&regs.R26,0x7);
		/* 820ED010h case    5:*/		return 0x820ED014;
		  /* 820ED014h */ case    6:  		/* b 16 */
		/* 820ED014h case    6:*/		return 0x820ED024;
		/* 820ED014h case    6:*/		return 0x820ED018;
	}
	return 0x820ED018;
} // Block from 820ECFFCh-820ED018h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ED018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED018);
		  /* 820ED018h */ case    0:  		/* rlwinm. R11, R26, 0, 13, 15 */
		/* 820ED018h case    0:*/		cpu::op::rlwinm<1,0,13,15>(regs,&regs.R11,regs.R26);
		/* 820ED018h case    0:*/		return 0x820ED01C;
		  /* 820ED01Ch */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 820ED01Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820ED024;  }
		/* 820ED01Ch case    1:*/		return 0x820ED020;
		  /* 820ED020h */ case    2:  		/* lis R26, 15 */
		/* 820ED020h case    2:*/		cpu::op::lis<0>(regs,&regs.R26,0xF);
		/* 820ED020h case    2:*/		return 0x820ED024;
	}
	return 0x820ED024;
} // Block from 820ED018h-820ED024h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ED024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED024);
		  /* 820ED024h */ case    0:  		/* lwz R11, <#[R28 + 204]> */
		/* 820ED024h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000CC) );
		/* 820ED024h case    0:*/		return 0x820ED028;
		  /* 820ED028h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820ED028h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820ED028h case    1:*/		return 0x820ED02C;
		  /* 820ED02Ch */ case    2:  		/* bc 12, CR0_EQ, 76 */
		/* 820ED02Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820ED078;  }
		/* 820ED02Ch case    2:*/		return 0x820ED030;
		  /* 820ED030h */ case    3:  		/* lwz R11, <#[R28 + 296]> */
		/* 820ED030h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000128) );
		/* 820ED030h case    3:*/		return 0x820ED034;
		  /* 820ED034h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820ED034h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820ED034h case    4:*/		return 0x820ED038;
		  /* 820ED038h */ case    5:  		/* bc 12, CR6_EQ, 64 */
		/* 820ED038h case    5:*/		if ( regs.CR[6].eq ) { return 0x820ED078;  }
		/* 820ED038h case    5:*/		return 0x820ED03C;
		  /* 820ED03Ch */ case    6:  		/* li R11, 0 */
		/* 820ED03Ch case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820ED03Ch case    6:*/		return 0x820ED040;
		  /* 820ED040h */ case    7:  		/* cmplwi CR6, R24, 0 */
		/* 820ED040h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820ED040h case    7:*/		return 0x820ED044;
		  /* 820ED044h */ case    8:  		/* bc 12, CR6_EQ, 52 */
		/* 820ED044h case    8:*/		if ( regs.CR[6].eq ) { return 0x820ED078;  }
		/* 820ED044h case    8:*/		return 0x820ED048;
		  /* 820ED048h */ case    9:  		/* mtspr CTR, R24 */
		/* 820ED048h case    9:*/		regs.CTR = regs.R24;
		/* 820ED048h case    9:*/		return 0x820ED04C;
		  /* 820ED04Ch */ case   10:  		/* addi R10, R25, -4 */
		/* 820ED04Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R25,0xFFFFFFFC);
		/* 820ED04Ch case   10:*/		return 0x820ED050;
		  /* 820ED050h */ case   11:  		/* lwz R8, <#[R28 + 300]> */
		/* 820ED050h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x0000012C) );
		/* 820ED050h case   11:*/		return 0x820ED054;
		  /* 820ED054h */ case   12:  		/* lwzu R9, <#[R10 + 4]> */
		/* 820ED054h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820ED054h case   12:*/		return 0x820ED058;
		  /* 820ED058h */ case   13:  		/* mulli R8, R8, 6 */
		/* 820ED058h case   13:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R8,0x6);
		/* 820ED058h case   13:*/		return 0x820ED05C;
		  /* 820ED05Ch */ case   14:  		/* lwz R7, <#[R28 + 296]> */
		/* 820ED05Ch case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + 0x00000128) );
		/* 820ED05Ch case   14:*/		return 0x820ED060;
		  /* 820ED060h */ case   15:  		/* add R8, R8, R11 */
		/* 820ED060h case   15:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 820ED060h case   15:*/		return 0x820ED064;
		  /* 820ED064h */ case   16:  		/* addi R11, R11, 1 */
		/* 820ED064h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ED064h case   16:*/		return 0x820ED068;
		  /* 820ED068h */ case   17:  		/* addi R8, R8, -4 */
		/* 820ED068h case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFC);
		/* 820ED068h case   17:*/		return 0x820ED06C;
		  /* 820ED06Ch */ case   18:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820ED06Ch case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820ED06Ch case   18:*/		return 0x820ED070;
		  /* 820ED070h */ case   19:  		/* stwx R9, <#[R8 + R7]> */
		/* 820ED070h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820ED070h case   19:*/		return 0x820ED074;
		  /* 820ED074h */ case   20:  		/* bc 16, CR0_LT, -36 */
		/* 820ED074h case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820ED050;  }
		/* 820ED074h case   20:*/		return 0x820ED078;
	}
	return 0x820ED078;
} // Block from 820ED024h-820ED078h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820ED078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED078);
		  /* 820ED078h */ case    0:  		/* or R11, R23, R26 */
		/* 820ED078h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R23,regs.R26);
		/* 820ED078h case    0:*/		return 0x820ED07C;
		  /* 820ED07Ch */ case    1:  		/* li R3, 0 */
		/* 820ED07Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820ED07Ch case    1:*/		return 0x820ED080;
		  /* 820ED080h */ case    2:  		/* stw R11, <#[R22]> */
		/* 820ED080h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 820ED080h case    2:*/		return 0x820ED084;
		  /* 820ED084h */ case    3:  		/* addi R1, R1, 176 */
		/* 820ED084h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820ED084h case    3:*/		return 0x820ED088;
		  /* 820ED088h */ case    4:  		/* b -376312 */
		/* 820ED088h case    4:*/		return 0x82091290;
		/* 820ED088h case    4:*/		return 0x820ED08C;
		  /* 820ED08Ch */ case    5:  		/* nop */
		/* 820ED08Ch case    5:*/		cpu::op::nop();
		/* 820ED08Ch case    5:*/		return 0x820ED090;
	}
	return 0x820ED090;
} // Block from 820ED078h-820ED090h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820ED090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED090);
		  /* 820ED090h */ case    0:  		/* mfspr R12, LR */
		/* 820ED090h case    0:*/		regs.R12 = regs.LR;
		/* 820ED090h case    0:*/		return 0x820ED094;
		  /* 820ED094h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820ED094h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820ED094h case    1:*/		return 0x820ED098;
		  /* 820ED098h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820ED098h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820ED098h case    2:*/		return 0x820ED09C;
		  /* 820ED09Ch */ case    3:  		/* li R11, 1 */
		/* 820ED09Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820ED09Ch case    3:*/		return 0x820ED0A0;
		  /* 820ED0A0h */ case    4:  		/* stw R11, <#[R6]> */
		/* 820ED0A0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 820ED0A0h case    4:*/		return 0x820ED0A4;
		  /* 820ED0A4h */ case    5:  		/* lwz R11, <#[R4 + 12]> */
		/* 820ED0A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 820ED0A4h case    5:*/		return 0x820ED0A8;
		  /* 820ED0A8h */ case    6:  		/* stw R11, <#[R5]> */
		/* 820ED0A8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820ED0A8h case    6:*/		return 0x820ED0AC;
		  /* 820ED0ACh */ case    7:  		/* lwz R10, <#[R3 + 40]> */
		/* 820ED0ACh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000028) );
		/* 820ED0ACh case    7:*/		return 0x820ED0B0;
		  /* 820ED0B0h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820ED0B0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ED0B0h case    8:*/		return 0x820ED0B4;
		  /* 820ED0B4h */ case    9:  		/* bc 12, CR6_LT, 40 */
		/* 820ED0B4h case    9:*/		if ( regs.CR[6].lt ) { return 0x820ED0DC;  }
		/* 820ED0B4h case    9:*/		return 0x820ED0B8;
		  /* 820ED0B8h */ case   10:  		/* lwz R11, <#[R3 + 260]> */
		/* 820ED0B8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820ED0B8h case   10:*/		return 0x820ED0BC;
		  /* 820ED0BCh */ case   11:  		/* lis R10, -32254 */
		/* 820ED0BCh case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820ED0BCh case   11:*/		return 0x820ED0C0;
		  /* 820ED0C0h */ case   12:  		/* li R5, 4506 */
		/* 820ED0C0h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x119A);
		/* 820ED0C0h case   12:*/		return 0x820ED0C4;
		  /* 820ED0C4h */ case   13:  		/* addi R6, R10, -17768 */
		/* 820ED0C4h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFBA98);
		/* 820ED0C4h case   13:*/		return 0x820ED0C8;
		  /* 820ED0C8h */ case   14:  		/* lwz R4, <#[R11 + 60]> */
		/* 820ED0C8h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 820ED0C8h case   14:*/		return 0x820ED0CC;
		  /* 820ED0CCh */ case   15:  		/* bl 136804 */
		/* 820ED0CCh case   15:*/		regs.LR = 0x820ED0D0; return 0x8210E730;
		/* 820ED0CCh case   15:*/		return 0x820ED0D0;
		  /* 820ED0D0h */ case   16:  		/* lis R3, -32768 */
		/* 820ED0D0h case   16:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820ED0D0h case   16:*/		return 0x820ED0D4;
		  /* 820ED0D4h */ case   17:  		/* ori R3, R3, 16389 */
		/* 820ED0D4h case   17:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820ED0D4h case   17:*/		return 0x820ED0D8;
		  /* 820ED0D8h */ case   18:  		/* b 8 */
		/* 820ED0D8h case   18:*/		return 0x820ED0E0;
		/* 820ED0D8h case   18:*/		return 0x820ED0DC;
	}
	return 0x820ED0DC;
} // Block from 820ED090h-820ED0DCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820ED0DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED0DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED0DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED0DC);
		  /* 820ED0DCh */ case    0:  		/* li R3, 0 */
		/* 820ED0DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820ED0DCh case    0:*/		return 0x820ED0E0;
	}
	return 0x820ED0E0;
} // Block from 820ED0DCh-820ED0E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED0E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED0E0);
		  /* 820ED0E0h */ case    0:  		/* addi R1, R1, 96 */
		/* 820ED0E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820ED0E0h case    0:*/		return 0x820ED0E4;
		  /* 820ED0E4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820ED0E4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820ED0E4h case    1:*/		return 0x820ED0E8;
		  /* 820ED0E8h */ case    2:  		/* mtspr LR, R12 */
		/* 820ED0E8h case    2:*/		regs.LR = regs.R12;
		/* 820ED0E8h case    2:*/		return 0x820ED0EC;
		  /* 820ED0ECh */ case    3:  		/* bclr 20, CR0_LT */
		/* 820ED0ECh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820ED0ECh case    3:*/		return 0x820ED0F0;
	}
	return 0x820ED0F0;
} // Block from 820ED0E0h-820ED0F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ED0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED0F0);
		  /* 820ED0F0h */ case    0:  		/* mfspr R12, LR */
		/* 820ED0F0h case    0:*/		regs.R12 = regs.LR;
		/* 820ED0F0h case    0:*/		return 0x820ED0F4;
		  /* 820ED0F4h */ case    1:  		/* bl -376476 */
		/* 820ED0F4h case    1:*/		regs.LR = 0x820ED0F8; return 0x82091258;
		/* 820ED0F4h case    1:*/		return 0x820ED0F8;
		  /* 820ED0F8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820ED0F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820ED0F8h case    2:*/		return 0x820ED0FC;
		  /* 820ED0FCh */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 820ED0FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820ED0FCh case    3:*/		return 0x820ED100;
		  /* 820ED100h */ case    4:  		/* mr R31, R3 */
		/* 820ED100h case    4:*/		regs.R31 = regs.R3;
		/* 820ED100h case    4:*/		return 0x820ED104;
		  /* 820ED104h */ case    5:  		/* lwz R10, <#[R3 + 16]> */
		/* 820ED104h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 820ED104h case    5:*/		return 0x820ED108;
		  /* 820ED108h */ case    6:  		/* mr R30, R4 */
		/* 820ED108h case    6:*/		regs.R30 = regs.R4;
		/* 820ED108h case    6:*/		return 0x820ED10C;
		  /* 820ED10Ch */ case    7:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 820ED10Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 820ED10Ch case    7:*/		return 0x820ED110;
		  /* 820ED110h */ case    8:  		/* lwz R8, <#[R3 + 136]> */
		/* 820ED110h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000088) );
		/* 820ED110h case    8:*/		return 0x820ED114;
		  /* 820ED114h */ case    9:  		/* mr R29, R5 */
		/* 820ED114h case    9:*/		regs.R29 = regs.R5;
		/* 820ED114h case    9:*/		return 0x820ED118;
	}
	return 0x820ED118;
} // Block from 820ED0F0h-820ED118h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820ED118h
// Function '?BuildInstruction@CShaderProgram@D3DXShader@@IAAJPAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED118);
		  /* 820ED118h */ case    0:  		/* cmplw CR6, R8, R11 */
		/* 820ED118h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820ED118h case    0:*/		return 0x820ED11C;
		  /* 820ED11Ch */ case    1:  		/* mr R28, R6 */
		/* 820ED11Ch case    1:*/		regs.R28 = regs.R6;
		/* 820ED11Ch case    1:*/		return 0x820ED120;
		  /* 820ED120h */ case    2:  		/* lwzx R11, <#[R9 + R10]> */
		/* 820ED120h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820ED120h case    2:*/		return 0x820ED124;
		  /* 820ED124h */ case    3:  		/* bc 4, CR6_EQ, 112 */
		/* 820ED124h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820ED194;  }
		/* 820ED124h case    3:*/		return 0x820ED128;
		  /* 820ED128h */ case    4:  		/* lwz R11, <#[R4 + 12]> */
		/* 820ED128h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 820ED128h case    4:*/		return 0x820ED12C;
		  /* 820ED12Ch */ case    5:  		/* li R9, 0 */
		/* 820ED12Ch case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820ED12Ch case    5:*/		return 0x820ED130;
		  /* 820ED130h */ case    6:  		/* lwz R10, <#[R3 + 44]> */
		/* 820ED130h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000002C) );
		/* 820ED130h case    6:*/		return 0x820ED134;
		  /* 820ED134h */ case    7:  		/* stw R9, <#[R1 + 80]> */
		/* 820ED134h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820ED134h case    7:*/		return 0x820ED138;
		  /* 820ED138h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820ED138h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ED138h case    8:*/		return 0x820ED13C;
		  /* 820ED13Ch */ case    9:  		/* stw R11, <#[R1 + 84]> */
		/* 820ED13Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ED13Ch case    9:*/		return 0x820ED140;
		  /* 820ED140h */ case   10:  		/* bc 12, CR6_LT, 44 */
		/* 820ED140h case   10:*/		if ( regs.CR[6].lt ) { return 0x820ED16C;  }
		/* 820ED140h case   10:*/		return 0x820ED144;
		  /* 820ED144h */ case   11:  		/* lis R10, -32254 */
		/* 820ED144h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820ED144h case   11:*/		return 0x820ED148;
		  /* 820ED148h */ case   12:  		/* addi R6, R10, -17808 */
		/* 820ED148h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFBA70);
		/* 820ED148h case   12:*/		return 0x820ED14C;
		  /* 820ED14Ch */ case   13:  		/* li R5, 4505 */
		/* 820ED14Ch case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x1199);
		/* 820ED14Ch case   13:*/		return 0x820ED150;
		  /* 820ED150h */ case   14:  		/* lwz R11, <#[R31 + 260]> */
		/* 820ED150h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820ED150h case   14:*/		return 0x820ED154;
		  /* 820ED154h */ case   15:  		/* mr R3, R31 */
		/* 820ED154h case   15:*/		regs.R3 = regs.R31;
		/* 820ED154h case   15:*/		return 0x820ED158;
		  /* 820ED158h */ case   16:  		/* lwz R4, <#[R11 + 60]> */
		/* 820ED158h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 820ED158h case   16:*/		return 0x820ED15C;
		  /* 820ED15Ch */ case   17:  		/* bl 136660 */
		/* 820ED15Ch case   17:*/		regs.LR = 0x820ED160; return 0x8210E730;
		/* 820ED15Ch case   17:*/		return 0x820ED160;
		  /* 820ED160h */ case   18:  		/* lis R3, -30602 */
		/* 820ED160h case   18:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820ED160h case   18:*/		return 0x820ED164;
		  /* 820ED164h */ case   19:  		/* ori R3, R3, 2905 */
		/* 820ED164h case   19:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xB59);
		/* 820ED164h case   19:*/		return 0x820ED168;
		  /* 820ED168h */ case   20:  		/* b 856 */
		/* 820ED168h case   20:*/		return 0x820ED4C0;
		/* 820ED168h case   20:*/		return 0x820ED16C;
	}
	return 0x820ED16C;
} // Block from 820ED118h-820ED16Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820ED16Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED16C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED16C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED16C);
		  /* 820ED16Ch */ case    0:  		/* lwz R10, <#[R31 + 80]> */
		/* 820ED16Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 820ED16Ch case    0:*/		return 0x820ED170;
		  /* 820ED170h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820ED170h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820ED170h case    1:*/		return 0x820ED174;
		  /* 820ED174h */ case    2:  		/* bc 12, CR6_EQ, 128 */
		/* 820ED174h case    2:*/		if ( regs.CR[6].eq ) { return 0x820ED1F4;  }
		/* 820ED174h case    2:*/		return 0x820ED178;
		  /* 820ED178h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820ED178h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ED178h case    3:*/		return 0x820ED17C;
		  /* 820ED17Ch */ case    4:  		/* bc 12, CR6_LT, 120 */
		/* 820ED17Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820ED1F4;  }
		/* 820ED17Ch case    4:*/		return 0x820ED180;
		  /* 820ED180h */ case    5:  		/* subf R11, R10, R11 */
		/* 820ED180h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820ED180h case    5:*/		return 0x820ED184;
		  /* 820ED184h */ case    6:  		/* li R9, 3 */
		/* 820ED184h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 820ED184h case    6:*/		return 0x820ED188;
		  /* 820ED188h */ case    7:  		/* stw R11, <#[R1 + 84]> */
		/* 820ED188h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ED188h case    7:*/		return 0x820ED18C;
		  /* 820ED18Ch */ case    8:  		/* stw R9, <#[R1 + 80]> */
		/* 820ED18Ch case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820ED18Ch case    8:*/		return 0x820ED190;
		  /* 820ED190h */ case    9:  		/* b 100 */
		/* 820ED190h case    9:*/		return 0x820ED1F4;
		/* 820ED190h case    9:*/		return 0x820ED194;
	}
	return 0x820ED194;
} // Block from 820ED16Ch-820ED194h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820ED194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED194);
		  /* 820ED194h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 820ED194h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820ED194h case    0:*/		return 0x820ED198;
		  /* 820ED198h */ case    1:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820ED198h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820ED198h case    1:*/		return 0x820ED19C;
		  /* 820ED19Ch */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 820ED19Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820ED1B4;  }
		/* 820ED19Ch case    2:*/		return 0x820ED1A0;
		  /* 820ED1A0h */ case    3:  		/* rlwinm. R9, R11, 0, 29, 29 */
		/* 820ED1A0h case    3:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R11);
		/* 820ED1A0h case    3:*/		return 0x820ED1A4;
		  /* 820ED1A4h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820ED1A4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820ED1B4;  }
		/* 820ED1A4h case    4:*/		return 0x820ED1A8;
		  /* 820ED1A8h */ case    5:  		/* li R9, 15 */
		/* 820ED1A8h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0xF);
		/* 820ED1A8h case    5:*/		return 0x820ED1AC;
		  /* 820ED1ACh */ case    6:  		/* li R11, 0 */
		/* 820ED1ACh case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820ED1ACh case    6:*/		return 0x820ED1B0;
		  /* 820ED1B0h */ case    7:  		/* b 212 */
		/* 820ED1B0h case    7:*/		return 0x820ED284;
		/* 820ED1B0h case    7:*/		return 0x820ED1B4;
	}
	return 0x820ED1B4;
} // Block from 820ED194h-820ED1B4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820ED1B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED1B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED1B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED1B4);
		  /* 820ED1B4h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820ED1B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820ED1B4h case    0:*/		return 0x820ED1B8;
		  /* 820ED1B8h */ case    1:  		/* bc 12, CR6_EQ, 92 */
		/* 820ED1B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820ED214;  }
		/* 820ED1B8h case    1:*/		return 0x820ED1BC;
		  /* 820ED1BCh */ case    2:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 820ED1BCh case    2:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 820ED1BCh case    2:*/		return 0x820ED1C0;
		  /* 820ED1C0h */ case    3:  		/* bc 4, CR0_EQ, 84 */
		/* 820ED1C0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820ED214;  }
		/* 820ED1C0h case    3:*/		return 0x820ED1C4;
		  /* 820ED1C4h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 820ED1C4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820ED1C4h case    4:*/		return 0x820ED1C8;
		  /* 820ED1C8h */ case    5:  		/* addi R6, R1, 80 */
		/* 820ED1C8h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820ED1C8h case    5:*/		return 0x820ED1CC;
		  /* 820ED1CCh */ case    6:  		/* addi R5, R1, 84 */
		/* 820ED1CCh case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820ED1CCh case    6:*/		return 0x820ED1D0;
		  /* 820ED1D0h */ case    7:  		/* mr R4, R30 */
		/* 820ED1D0h case    7:*/		regs.R4 = regs.R30;
		/* 820ED1D0h case    7:*/		return 0x820ED1D4;
		  /* 820ED1D4h */ case    8:  		/* mr R3, R31 */
		/* 820ED1D4h case    8:*/		regs.R3 = regs.R31;
		/* 820ED1D4h case    8:*/		return 0x820ED1D8;
		  /* 820ED1D8h */ case    9:  		/* lwz R11, <#[R11 + 348]> */
		/* 820ED1D8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000015C) );
		/* 820ED1D8h case    9:*/		return 0x820ED1DC;
		  /* 820ED1DCh */ case   10:  		/* mtspr CTR, R11 */
		/* 820ED1DCh case   10:*/		regs.CTR = regs.R11;
		/* 820ED1DCh case   10:*/		return 0x820ED1E0;
		  /* 820ED1E0h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820ED1E0h case   11:*/		if ( 1 ) { regs.LR = 0x820ED1E4; return (uint32)regs.CTR; }
		/* 820ED1E0h case   11:*/		return 0x820ED1E4;
		  /* 820ED1E4h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820ED1E4h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820ED1E4h case   12:*/		return 0x820ED1E8;
		  /* 820ED1E8h */ case   13:  		/* bc 12, CR0_LT, 728 */
		/* 820ED1E8h case   13:*/		if ( regs.CR[0].lt ) { return 0x820ED4C0;  }
		/* 820ED1E8h case   13:*/		return 0x820ED1EC;
		  /* 820ED1ECh */ case   14:  		/* lwz R9, <#[R1 + 80]> */
		/* 820ED1ECh case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820ED1ECh case   14:*/		return 0x820ED1F0;
		  /* 820ED1F0h */ case   15:  		/* lwz R11, <#[R1 + 84]> */
		/* 820ED1F0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ED1F0h case   15:*/		return 0x820ED1F4;
	}
	return 0x820ED1F4;
} // Block from 820ED1B4h-820ED1F4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820ED1F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED1F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED1F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED1F4);
		  /* 820ED1F4h */ case    0:  		/* lwz R10, <#[R30 + 60]> */
		/* 820ED1F4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000003C) );
		/* 820ED1F4h case    0:*/		return 0x820ED1F8;
		  /* 820ED1F8h */ case    1:  		/* lis R7, 16 */
		/* 820ED1F8h case    1:*/		cpu::op::lis<0>(regs,&regs.R7,0x10);
		/* 820ED1F8h case    1:*/		return 0x820ED1FC;
		  /* 820ED1FCh */ case    2:  		/* li R8, 0 */
		/* 820ED1FCh case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820ED1FCh case    2:*/		return 0x820ED200;
		  /* 820ED200h */ case    3:  		/* rlwinm R10, R10, 0, 11, 15 */
		/* 820ED200h case    3:*/		cpu::op::rlwinm<0,0,11,15>(regs,&regs.R10,regs.R10);
		/* 820ED200h case    3:*/		return 0x820ED204;
		  /* 820ED204h */ case    4:  		/* cmplw CR6, R10, R7 */
		/* 820ED204h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820ED204h case    4:*/		return 0x820ED208;
		  /* 820ED208h */ case    5:  		/* bc 4, CR6_EQ, 360 */
		/* 820ED208h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820ED370;  }
		/* 820ED208h case    5:*/		return 0x820ED20C;
		  /* 820ED20Ch */ case    6:  		/* lis R8, 2816 */
		/* 820ED20Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R8,0xB00);
		/* 820ED20Ch case    6:*/		return 0x820ED210;
		  /* 820ED210h */ case    7:  		/* b 528 */
		/* 820ED210h case    7:*/		return 0x820ED420;
		/* 820ED210h case    7:*/		return 0x820ED214;
	}
	return 0x820ED214;
} // Block from 820ED1F4h-820ED214h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820ED214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED214);
		  /* 820ED214h */ case    0:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 820ED214h case    0:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 820ED214h case    0:*/		return 0x820ED218;
		  /* 820ED218h */ case    1:  		/* bc 12, CR0_EQ, 120 */
		/* 820ED218h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ED290;  }
		/* 820ED218h case    1:*/		return 0x820ED21C;
		  /* 820ED21Ch */ case    2:  		/* lis R12, 4 */
		/* 820ED21Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R12,0x4);
		/* 820ED21Ch case    2:*/		return 0x820ED220;
		  /* 820ED220h */ case    3:  		/* ori R12, R12, 8320 */
		/* 820ED220h case    3:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x2080);
		/* 820ED220h case    3:*/		return 0x820ED224;
		  /* 820ED224h */ case    4:  		/* and. R9, R11, R12 */
		/* 820ED224h case    4:*/		cpu::op::and<1>(regs,&regs.R9,regs.R11,regs.R12);
		/* 820ED224h case    4:*/		return 0x820ED228;
		  /* 820ED228h */ case    5:  		/* bc 4, CR0_EQ, 104 */
		/* 820ED228h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820ED290;  }
		/* 820ED228h case    5:*/		return 0x820ED22C;
		  /* 820ED22Ch */ case    6:  		/* lwz R11, <#[R30 + 12]> */
		/* 820ED22Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820ED22Ch case    6:*/		return 0x820ED230;
		  /* 820ED230h */ case    7:  		/* lwz R10, <#[R31 + 56]> */
		/* 820ED230h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 820ED230h case    7:*/		return 0x820ED234;
		  /* 820ED234h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820ED234h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ED234h case    8:*/		return 0x820ED238;
		  /* 820ED238h */ case    9:  		/* stw R11, <#[R1 + 84]> */
		/* 820ED238h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ED238h case    9:*/		return 0x820ED23C;
		  /* 820ED23Ch */ case   10:  		/* bc 12, CR6_LT, 20 */
		/* 820ED23Ch case   10:*/		if ( regs.CR[6].lt ) { return 0x820ED250;  }
		/* 820ED23Ch case   10:*/		return 0x820ED240;
		  /* 820ED240h */ case   11:  		/* lis R10, -32254 */
		/* 820ED240h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820ED240h case   11:*/		return 0x820ED244;
		  /* 820ED244h */ case   12:  		/* li R5, 4507 */
		/* 820ED244h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x119B);
		/* 820ED244h case   12:*/		return 0x820ED248;
		  /* 820ED248h */ case   13:  		/* addi R6, R10, -17512 */
		/* 820ED248h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFBB98);
		/* 820ED248h case   13:*/		return 0x820ED24C;
		  /* 820ED24Ch */ case   14:  		/* b -252 */
		/* 820ED24Ch case   14:*/		return 0x820ED150;
		/* 820ED24Ch case   14:*/		return 0x820ED250;
	}
	return 0x820ED250;
} // Block from 820ED214h-820ED250h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820ED250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED250);
		  /* 820ED250h */ case    0:  		/* cmplwi CR6, R11, 2048 */
		/* 820ED250h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000800);
		/* 820ED250h case    0:*/		return 0x820ED254;
		  /* 820ED254h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 820ED254h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820ED260;  }
		/* 820ED254h case    1:*/		return 0x820ED258;
		  /* 820ED258h */ case    2:  		/* li R9, 2 */
		/* 820ED258h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 820ED258h case    2:*/		return 0x820ED25C;
		  /* 820ED25Ch */ case    3:  		/* b 36 */
		/* 820ED25Ch case    3:*/		return 0x820ED280;
		/* 820ED25Ch case    3:*/		return 0x820ED260;
	}
	return 0x820ED260;
} // Block from 820ED250h-820ED260h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ED260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED260);
		  /* 820ED260h */ case    0:  		/* cmplwi CR6, R11, 4096 */
		/* 820ED260h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001000);
		/* 820ED260h case    0:*/		return 0x820ED264;
		  /* 820ED264h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 820ED264h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820ED270;  }
		/* 820ED264h case    1:*/		return 0x820ED268;
		  /* 820ED268h */ case    2:  		/* li R9, 11 */
		/* 820ED268h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0xB);
		/* 820ED268h case    2:*/		return 0x820ED26C;
		  /* 820ED26Ch */ case    3:  		/* b 20 */
		/* 820ED26Ch case    3:*/		return 0x820ED280;
		/* 820ED26Ch case    3:*/		return 0x820ED270;
	}
	return 0x820ED270;
} // Block from 820ED260h-820ED270h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ED270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED270);
		  /* 820ED270h */ case    0:  		/* li R10, 6144 */
		/* 820ED270h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1800);
		/* 820ED270h case    0:*/		return 0x820ED274;
		  /* 820ED274h */ case    1:  		/* subfc R10, R10, R11 */
		/* 820ED274h case    1:*/		cpu::op::subfc<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820ED274h case    1:*/		return 0x820ED278;
		  /* 820ED278h */ case    2:  		/* subfe R10, R10, R10 */
		/* 820ED278h case    2:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820ED278h case    2:*/		return 0x820ED27C;
		  /* 820ED27Ch */ case    3:  		/* addi R9, R10, 13 */
		/* 820ED27Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xD);
		/* 820ED27Ch case    3:*/		return 0x820ED280;
	}
	return 0x820ED280;
} // Block from 820ED270h-820ED280h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ED280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED280);
		  /* 820ED280h */ case    0:  		/* rlwinm R11, R11, 0, 21, 31 */
		/* 820ED280h case    0:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R11,regs.R11);
		/* 820ED280h case    0:*/		return 0x820ED284;
	}
	return 0x820ED284;
} // Block from 820ED280h-820ED284h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED284);
		  /* 820ED284h */ case    0:  		/* stw R9, <#[R1 + 80]> */
		/* 820ED284h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820ED284h case    0:*/		return 0x820ED288;
		  /* 820ED288h */ case    1:  		/* stw R11, <#[R1 + 84]> */
		/* 820ED288h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ED288h case    1:*/		return 0x820ED28C;
		  /* 820ED28Ch */ case    2:  		/* b -152 */
		/* 820ED28Ch case    2:*/		return 0x820ED1F4;
		/* 820ED28Ch case    2:*/		return 0x820ED290;
	}
	return 0x820ED290;
} // Block from 820ED284h-820ED290h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ED290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED290);
		  /* 820ED290h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820ED290h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820ED290h case    0:*/		return 0x820ED294;
		  /* 820ED294h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820ED294h case    1:*/		if ( regs.CR[6].eq ) { return 0x820ED2D4;  }
		/* 820ED294h case    1:*/		return 0x820ED298;
		  /* 820ED298h */ case    2:  		/* rlwinm. R10, R11, 0, 24, 24 */
		/* 820ED298h case    2:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R11);
		/* 820ED298h case    2:*/		return 0x820ED29C;
		  /* 820ED29Ch */ case    3:  		/* bc 4, CR0_EQ, 56 */
		/* 820ED29Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x820ED2D4;  }
		/* 820ED29Ch case    3:*/		return 0x820ED2A0;
		  /* 820ED2A0h */ case    4:  		/* rlwinm. R10, R11, 0, 18, 18 */
		/* 820ED2A0h case    4:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R10,regs.R11);
		/* 820ED2A0h case    4:*/		return 0x820ED2A4;
		  /* 820ED2A4h */ case    5:  		/* bc 12, CR0_EQ, 48 */
		/* 820ED2A4h case    5:*/		if ( regs.CR[0].eq ) { return 0x820ED2D4;  }
		/* 820ED2A4h case    5:*/		return 0x820ED2A8;
		  /* 820ED2A8h */ case    6:  		/* lwz R11, <#[R30 + 12]> */
		/* 820ED2A8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820ED2A8h case    6:*/		return 0x820ED2AC;
		  /* 820ED2ACh */ case    7:  		/* li R9, 14 */
		/* 820ED2ACh case    7:*/		cpu::op::li<0>(regs,&regs.R9,0xE);
		/* 820ED2ACh case    7:*/		return 0x820ED2B0;
		  /* 820ED2B0h */ case    8:  		/* lwz R10, <#[R31 + 96]> */
		/* 820ED2B0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000060) );
		/* 820ED2B0h case    8:*/		return 0x820ED2B4;
		  /* 820ED2B4h */ case    9:  		/* stw R9, <#[R1 + 80]> */
		/* 820ED2B4h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820ED2B4h case    9:*/		return 0x820ED2B8;
		  /* 820ED2B8h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820ED2B8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ED2B8h case   10:*/		return 0x820ED2BC;
		  /* 820ED2BCh */ case   11:  		/* stw R11, <#[R1 + 84]> */
		/* 820ED2BCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ED2BCh case   11:*/		return 0x820ED2C0;
		  /* 820ED2C0h */ case   12:  		/* bc 12, CR6_LT, -204 */
		/* 820ED2C0h case   12:*/		if ( regs.CR[6].lt ) { return 0x820ED1F4;  }
		/* 820ED2C0h case   12:*/		return 0x820ED2C4;
		  /* 820ED2C4h */ case   13:  		/* lis R10, -32254 */
		/* 820ED2C4h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820ED2C4h case   13:*/		return 0x820ED2C8;
		  /* 820ED2C8h */ case   14:  		/* li R5, 4500 */
		/* 820ED2C8h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x1194);
		/* 820ED2C8h case   14:*/		return 0x820ED2CC;
		  /* 820ED2CCh */ case   15:  		/* addi R6, R10, -17556 */
		/* 820ED2CCh case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFBB6C);
		/* 820ED2CCh case   15:*/		return 0x820ED2D0;
		  /* 820ED2D0h */ case   16:  		/* b -384 */
		/* 820ED2D0h case   16:*/		return 0x820ED150;
		/* 820ED2D0h case   16:*/		return 0x820ED2D4;
	}
	return 0x820ED2D4;
} // Block from 820ED290h-820ED2D4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820ED2D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED2D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED2D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED2D4);
		  /* 820ED2D4h */ case    0:  		/* rlwinm. R10, R11, 0, 24, 24 */
		/* 820ED2D4h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R11);
		/* 820ED2D4h case    0:*/		return 0x820ED2D8;
		  /* 820ED2D8h */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 820ED2D8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ED304;  }
		/* 820ED2D8h case    1:*/		return 0x820ED2DC;
		  /* 820ED2DCh */ case    2:  		/* lwz R11, <#[R30 + 12]> */
		/* 820ED2DCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820ED2DCh case    2:*/		return 0x820ED2E0;
		  /* 820ED2E0h */ case    3:  		/* li R9, 10 */
		/* 820ED2E0h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0xA);
		/* 820ED2E0h case    3:*/		return 0x820ED2E4;
		  /* 820ED2E4h */ case    4:  		/* lwz R10, <#[R31 + 76]> */
		/* 820ED2E4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000004C) );
		/* 820ED2E4h case    4:*/		return 0x820ED2E8;
		  /* 820ED2E8h */ case    5:  		/* stw R9, <#[R1 + 80]> */
		/* 820ED2E8h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820ED2E8h case    5:*/		return 0x820ED2EC;
		  /* 820ED2ECh */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820ED2ECh case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ED2ECh case    6:*/		return 0x820ED2F0;
	}
	return 0x820ED2F0;
} // Block from 820ED2D4h-820ED2F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ED2F0h
// Function '?NegateReg@D3DXShader@@YAKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED2F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED2F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED2F0);
		  /* 820ED2F0h */ case    0:  		/* stw R11, <#[R1 + 84]> */
		/* 820ED2F0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ED2F0h case    0:*/		return 0x820ED2F4;
		  /* 820ED2F4h */ case    1:  		/* bc 12, CR6_LT, -256 */
		/* 820ED2F4h case    1:*/		if ( regs.CR[6].lt ) { return 0x820ED1F4;  }
		/* 820ED2F4h case    1:*/		return 0x820ED2F8;
		  /* 820ED2F8h */ case    2:  		/* lis R10, -32254 */
		/* 820ED2F8h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820ED2F8h case    2:*/		return 0x820ED2FC;
		  /* 820ED2FCh */ case    3:  		/* addi R6, R10, -17596 */
		/* 820ED2FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFBB44);
		/* 820ED2FCh case    3:*/		return 0x820ED300;
		  /* 820ED300h */ case    4:  		/* b -436 */
		/* 820ED300h case    4:*/		return 0x820ED14C;
		/* 820ED300h case    4:*/		return 0x820ED304;
	}
	return 0x820ED304;
} // Block from 820ED2F0h-820ED304h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ED304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED304);
		  /* 820ED304h */ case    0:  		/* rlwinm. R11, R11, 0, 13, 13 */
		/* 820ED304h case    0:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R11);
		/* 820ED304h case    0:*/		return 0x820ED308;
		  /* 820ED308h */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 820ED308h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ED334;  }
		/* 820ED308h case    1:*/		return 0x820ED30C;
		  /* 820ED30Ch */ case    2:  		/* lwz R11, <#[R30 + 12]> */
		/* 820ED30Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820ED30Ch case    2:*/		return 0x820ED310;
		  /* 820ED310h */ case    3:  		/* li R9, 7 */
		/* 820ED310h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x7);
		/* 820ED310h case    3:*/		return 0x820ED314;
		  /* 820ED314h */ case    4:  		/* lwz R10, <#[R31 + 64]> */
		/* 820ED314h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000040) );
		/* 820ED314h case    4:*/		return 0x820ED318;
		  /* 820ED318h */ case    5:  		/* stw R9, <#[R1 + 80]> */
		/* 820ED318h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820ED318h case    5:*/		return 0x820ED31C;
		  /* 820ED31Ch */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820ED31Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ED31Ch case    6:*/		return 0x820ED320;
		  /* 820ED320h */ case    7:  		/* stw R11, <#[R1 + 84]> */
		/* 820ED320h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ED320h case    7:*/		return 0x820ED324;
		  /* 820ED324h */ case    8:  		/* bc 12, CR6_LT, -304 */
		/* 820ED324h case    8:*/		if ( regs.CR[6].lt ) { return 0x820ED1F4;  }
		/* 820ED324h case    8:*/		return 0x820ED328;
		  /* 820ED328h */ case    9:  		/* lis R10, -32254 */
		/* 820ED328h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820ED328h case    9:*/		return 0x820ED32C;
		  /* 820ED32Ch */ case   10:  		/* addi R6, R10, -17636 */
		/* 820ED32Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFBB1C);
		/* 820ED32Ch case   10:*/		return 0x820ED330;
		  /* 820ED330h */ case   11:  		/* b -484 */
		/* 820ED330h case   11:*/		return 0x820ED14C;
		/* 820ED330h case   11:*/		return 0x820ED334;
	}
	return 0x820ED334;
} // Block from 820ED304h-820ED334h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820ED334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED334);
		  /* 820ED334h */ case    0:  		/* lwz R11, <#[R31 + 144]> */
		/* 820ED334h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 820ED334h case    0:*/		return 0x820ED338;
		  /* 820ED338h */ case    1:  		/* lwz R10, <#[R30 + 4]> */
		/* 820ED338h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 820ED338h case    1:*/		return 0x820ED33C;
		  /* 820ED33Ch */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820ED33Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ED33Ch case    2:*/		return 0x820ED340;
		  /* 820ED340h */ case    3:  		/* bc 4, CR6_EQ, 352 */
		/* 820ED340h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820ED4A0;  }
		/* 820ED340h case    3:*/		return 0x820ED344;
		  /* 820ED344h */ case    4:  		/* lwz R11, <#[R30 + 12]> */
		/* 820ED344h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820ED344h case    4:*/		return 0x820ED348;
		  /* 820ED348h */ case    5:  		/* li R9, 19 */
		/* 820ED348h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x13);
		/* 820ED348h case    5:*/		return 0x820ED34C;
		  /* 820ED34Ch */ case    6:  		/* lwz R10, <#[R31 + 52]> */
		/* 820ED34Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000034) );
		/* 820ED34Ch case    6:*/		return 0x820ED350;
		  /* 820ED350h */ case    7:  		/* stw R9, <#[R1 + 80]> */
		/* 820ED350h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820ED350h case    7:*/		return 0x820ED354;
		  /* 820ED354h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820ED354h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ED354h case    8:*/		return 0x820ED358;
		  /* 820ED358h */ case    9:  		/* stw R11, <#[R1 + 84]> */
		/* 820ED358h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820ED358h case    9:*/		return 0x820ED35C;
		  /* 820ED35Ch */ case   10:  		/* bc 12, CR6_LT, -360 */
		/* 820ED35Ch case   10:*/		if ( regs.CR[6].lt ) { return 0x820ED1F4;  }
		/* 820ED35Ch case   10:*/		return 0x820ED360;
		  /* 820ED360h */ case   11:  		/* lis R10, -32254 */
		/* 820ED360h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820ED360h case   11:*/		return 0x820ED364;
		  /* 820ED364h */ case   12:  		/* li R5, 4549 */
		/* 820ED364h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x11C5);
		/* 820ED364h case   12:*/		return 0x820ED368;
		  /* 820ED368h */ case   13:  		/* addi R6, R10, -17892 */
		/* 820ED368h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFBA1C);
		/* 820ED368h case   13:*/		return 0x820ED36C;
		  /* 820ED36Ch */ case   14:  		/* b -540 */
		/* 820ED36Ch case   14:*/		return 0x820ED150;
		/* 820ED36Ch case   14:*/		return 0x820ED370;
	}
	return 0x820ED370;
} // Block from 820ED334h-820ED370h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820ED370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED370);
		  /* 820ED370h */ case    0:  		/* lis R7, 24 */
		/* 820ED370h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x18);
		/* 820ED370h case    0:*/		return 0x820ED374;
		  /* 820ED374h */ case    1:  		/* cmplw CR6, R10, R7 */
		/* 820ED374h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820ED374h case    1:*/		return 0x820ED378;
		  /* 820ED378h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820ED378h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ED384;  }
		/* 820ED378h case    2:*/		return 0x820ED37C;
		  /* 820ED37Ch */ case    3:  		/* lis R8, 3072 */
		/* 820ED37Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0xC00);
		/* 820ED37Ch case    3:*/		return 0x820ED380;
		  /* 820ED380h */ case    4:  		/* b 160 */
		/* 820ED380h case    4:*/		return 0x820ED420;
		/* 820ED380h case    4:*/		return 0x820ED384;
	}
	return 0x820ED384;
} // Block from 820ED370h-820ED384h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ED384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED384);
		  /* 820ED384h */ case    0:  		/* lis R7, 8 */
		/* 820ED384h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x8);
		/* 820ED384h case    0:*/		return 0x820ED388;
		  /* 820ED388h */ case    1:  		/* cmplw CR6, R10, R7 */
		/* 820ED388h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820ED388h case    1:*/		return 0x820ED38C;
		  /* 820ED38Ch */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820ED38Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ED398;  }
		/* 820ED38Ch case    2:*/		return 0x820ED390;
		  /* 820ED390h */ case    3:  		/* lis R8, 256 */
		/* 820ED390h case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0x100);
		/* 820ED390h case    3:*/		return 0x820ED394;
		  /* 820ED394h */ case    4:  		/* b 140 */
		/* 820ED394h case    4:*/		return 0x820ED420;
		/* 820ED394h case    4:*/		return 0x820ED398;
	}
	return 0x820ED398;
} // Block from 820ED384h-820ED398h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ED398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED398);
		  /* 820ED398h */ case    0:  		/* lis R7, 2 */
		/* 820ED398h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x2);
		/* 820ED398h case    0:*/		return 0x820ED39C;
		  /* 820ED39Ch */ case    1:  		/* cmplw CR6, R10, R7 */
		/* 820ED39Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820ED39Ch case    1:*/		return 0x820ED3A0;
		  /* 820ED3A0h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820ED3A0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ED3AC;  }
		/* 820ED3A0h case    2:*/		return 0x820ED3A4;
		  /* 820ED3A4h */ case    3:  		/* lis R8, 512 */
		/* 820ED3A4h case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0x200);
		/* 820ED3A4h case    3:*/		return 0x820ED3A8;
		  /* 820ED3A8h */ case    4:  		/* b 120 */
		/* 820ED3A8h case    4:*/		return 0x820ED420;
		/* 820ED3A8h case    4:*/		return 0x820ED3AC;
	}
	return 0x820ED3AC;
} // Block from 820ED398h-820ED3ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ED3ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED3AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED3AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED3AC);
		  /* 820ED3ACh */ case    0:  		/* lis R7, 10 */
		/* 820ED3ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0xA);
		/* 820ED3ACh case    0:*/		return 0x820ED3B0;
		  /* 820ED3B0h */ case    1:  		/* cmplw CR6, R10, R7 */
		/* 820ED3B0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820ED3B0h case    1:*/		return 0x820ED3B4;
		  /* 820ED3B4h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820ED3B4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ED3C0;  }
		/* 820ED3B4h case    2:*/		return 0x820ED3B8;
		  /* 820ED3B8h */ case    3:  		/* lis R8, 768 */
		/* 820ED3B8h case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0x300);
		/* 820ED3B8h case    3:*/		return 0x820ED3BC;
		  /* 820ED3BCh */ case    4:  		/* b 100 */
		/* 820ED3BCh case    4:*/		return 0x820ED420;
		/* 820ED3BCh case    4:*/		return 0x820ED3C0;
	}
	return 0x820ED3C0;
} // Block from 820ED3ACh-820ED3C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ED3C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED3C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED3C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED3C0);
		  /* 820ED3C0h */ case    0:  		/* lis R7, 6 */
		/* 820ED3C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x6);
		/* 820ED3C0h case    0:*/		return 0x820ED3C4;
		  /* 820ED3C4h */ case    1:  		/* cmplw CR6, R10, R7 */
		/* 820ED3C4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820ED3C4h case    1:*/		return 0x820ED3C8;
	}
	return 0x820ED3C8;
} // Block from 820ED3C0h-820ED3C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ED3C8h
// Function '?CoIssue@CShaderProgram@D3DXShader@@MAAKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED3C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED3C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED3C8);
		  /* 820ED3C8h */ case    0:  		/* bc 4, CR6_EQ, 12 */
		/* 820ED3C8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820ED3D4;  }
		/* 820ED3C8h case    0:*/		return 0x820ED3CC;
		  /* 820ED3CCh */ case    1:  		/* lis R8, 1024 */
		/* 820ED3CCh case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0x400);
		/* 820ED3CCh case    1:*/		return 0x820ED3D0;
	}
	return 0x820ED3D0;
} // Block from 820ED3C8h-820ED3D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ED3D0h
// Function '?TypeSize@D3DXShader@@YAIPAVCNode@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED3D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED3D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED3D0);
		  /* 820ED3D0h */ case    0:  		/* b 80 */
		/* 820ED3D0h case    0:*/		return 0x820ED420;
		/* 820ED3D0h case    0:*/		return 0x820ED3D4;
	}
	return 0x820ED3D4;
} // Block from 820ED3D0h-820ED3D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED3D4);
		  /* 820ED3D4h */ case    0:  		/* lis R7, 14 */
		/* 820ED3D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0xE);
		/* 820ED3D4h case    0:*/		return 0x820ED3D8;
		  /* 820ED3D8h */ case    1:  		/* cmplw CR6, R10, R7 */
		/* 820ED3D8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820ED3D8h case    1:*/		return 0x820ED3DC;
		  /* 820ED3DCh */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820ED3DCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ED3E8;  }
		/* 820ED3DCh case    2:*/		return 0x820ED3E0;
		  /* 820ED3E0h */ case    3:  		/* lis R8, 1280 */
		/* 820ED3E0h case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0x500);
		/* 820ED3E0h case    3:*/		return 0x820ED3E4;
		  /* 820ED3E4h */ case    4:  		/* b 60 */
		/* 820ED3E4h case    4:*/		return 0x820ED420;
		/* 820ED3E4h case    4:*/		return 0x820ED3E8;
	}
	return 0x820ED3E8;
} // Block from 820ED3D4h-820ED3E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ED3E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED3E8);
		  /* 820ED3E8h */ case    0:  		/* lis R7, 1 */
		/* 820ED3E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x1);
		/* 820ED3E8h case    0:*/		return 0x820ED3EC;
		  /* 820ED3ECh */ case    1:  		/* cmplw CR6, R10, R7 */
		/* 820ED3ECh case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820ED3ECh case    1:*/		return 0x820ED3F0;
		  /* 820ED3F0h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820ED3F0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ED3FC;  }
		/* 820ED3F0h case    2:*/		return 0x820ED3F4;
		  /* 820ED3F4h */ case    3:  		/* lis R8, 1536 */
		/* 820ED3F4h case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0x600);
		/* 820ED3F4h case    3:*/		return 0x820ED3F8;
		  /* 820ED3F8h */ case    4:  		/* b 40 */
		/* 820ED3F8h case    4:*/		return 0x820ED420;
		/* 820ED3F8h case    4:*/		return 0x820ED3FC;
	}
	return 0x820ED3FC;
} // Block from 820ED3E8h-820ED3FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ED3FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED3FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED3FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED3FC);
		  /* 820ED3FCh */ case    0:  		/* lis R7, 4 */
		/* 820ED3FCh case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x4);
		/* 820ED3FCh case    0:*/		return 0x820ED400;
		  /* 820ED400h */ case    1:  		/* cmplw CR6, R10, R7 */
		/* 820ED400h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820ED400h case    1:*/		return 0x820ED404;
		  /* 820ED404h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820ED404h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ED410;  }
		/* 820ED404h case    2:*/		return 0x820ED408;
		  /* 820ED408h */ case    3:  		/* lis R8, 1792 */
		/* 820ED408h case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0x700);
		/* 820ED408h case    3:*/		return 0x820ED40C;
		  /* 820ED40Ch */ case    4:  		/* b 20 */
		/* 820ED40Ch case    4:*/		return 0x820ED420;
		/* 820ED40Ch case    4:*/		return 0x820ED410;
	}
	return 0x820ED410;
} // Block from 820ED3FCh-820ED410h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ED410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED410);
		  /* 820ED410h */ case    0:  		/* lis R7, 12 */
		/* 820ED410h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0xC);
		/* 820ED410h case    0:*/		return 0x820ED414;
		  /* 820ED414h */ case    1:  		/* cmplw CR6, R10, R7 */
		/* 820ED414h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820ED414h case    1:*/		return 0x820ED418;
		  /* 820ED418h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820ED418h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ED420;  }
		/* 820ED418h case    2:*/		return 0x820ED41C;
		  /* 820ED41Ch */ case    3:  		/* lis R8, 2048 */
		/* 820ED41Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0x800);
		/* 820ED41Ch case    3:*/		return 0x820ED420;
	}
	return 0x820ED420;
} // Block from 820ED410h-820ED420h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ED420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED420);
		  /* 820ED420h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820ED420h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820ED420h case    0:*/		return 0x820ED424;
		  /* 820ED424h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820ED424h case    1:*/		if ( regs.CR[6].eq ) { return 0x820ED44C;  }
		/* 820ED424h case    1:*/		return 0x820ED428;
		  /* 820ED428h */ case    2:  		/* lis R10, -128 */
		/* 820ED428h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFF80);
		/* 820ED428h case    2:*/		return 0x820ED42C;
		  /* 820ED42Ch */ case    3:  		/* rlwinm R7, R9, 0, 27, 28 */
		/* 820ED42Ch case    3:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R7,regs.R9);
		/* 820ED42Ch case    3:*/		return 0x820ED430;
		  /* 820ED430h */ case    4:  		/* rlwimi R10, R9, 20, 9, 11 */
		/* 820ED430h case    4:*/		cpu::op::rlwimi<0,20,9,11>(regs,&regs.R10,regs.R9);
		/* 820ED430h case    4:*/		return 0x820ED434;
		  /* 820ED434h */ case    5:  		/* rlwinm R11, R11, 0, 21, 31 */
		/* 820ED434h case    5:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R11,regs.R11);
		/* 820ED434h case    5:*/		return 0x820ED438;
		  /* 820ED438h */ case    6:  		/* or R10, R10, R7 */
		/* 820ED438h case    6:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 820ED438h case    6:*/		return 0x820ED43C;
		  /* 820ED43Ch */ case    7:  		/* rlwinm R10, R10, 8, 0, 23 */
		/* 820ED43Ch case    7:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R10,regs.R10);
		/* 820ED43Ch case    7:*/		return 0x820ED440;
		  /* 820ED440h */ case    8:  		/* or R11, R10, R11 */
		/* 820ED440h case    8:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820ED440h case    8:*/		return 0x820ED444;
		  /* 820ED444h */ case    9:  		/* or R11, R11, R8 */
		/* 820ED444h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820ED444h case    9:*/		return 0x820ED448;
		  /* 820ED448h */ case   10:  		/* stw R11, <#[R29]> */
		/* 820ED448h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820ED448h case   10:*/		return 0x820ED44C;
	}
	return 0x820ED44C;
} // Block from 820ED420h-820ED44Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ED44Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED44C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED44C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED44C);
		  /* 820ED44Ch */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820ED44Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820ED44Ch case    0:*/		return 0x820ED450;
		  /* 820ED450h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820ED450h case    1:*/		if ( regs.CR[6].eq ) { return 0x820ED45C;  }
		/* 820ED450h case    1:*/		return 0x820ED454;
		  /* 820ED454h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 820ED454h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820ED454h case    2:*/		return 0x820ED458;
		  /* 820ED458h */ case    3:  		/* stw R11, <#[R28]> */
		/* 820ED458h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820ED458h case    3:*/		return 0x820ED45C;
	}
	return 0x820ED45C;
} // Block from 820ED44Ch-820ED45Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ED45Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED45C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED45C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED45C);
		  /* 820ED45Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 820ED45Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820ED45Ch case    0:*/		return 0x820ED460;
		  /* 820ED460h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820ED460h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820ED460h case    1:*/		return 0x820ED464;
		  /* 820ED464h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 820ED464h case    2:*/		if ( regs.CR[6].eq ) { return 0x820ED498;  }
		/* 820ED464h case    2:*/		return 0x820ED468;
		  /* 820ED468h */ case    3:  		/* lwz R11, <#[R31 + 344]> */
		/* 820ED468h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000158) );
		/* 820ED468h case    3:*/		return 0x820ED46C;
		  /* 820ED46Ch */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820ED46Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ED46Ch case    4:*/		return 0x820ED470;
		  /* 820ED470h */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 820ED470h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820ED48C;  }
		/* 820ED470h case    5:*/		return 0x820ED474;
		  /* 820ED474h */ case    6:  		/* lwz R11, <#[R31 + 260]> */
		/* 820ED474h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820ED474h case    6:*/		return 0x820ED478;
		  /* 820ED478h */ case    7:  		/* lis R10, -32254 */
		/* 820ED478h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820ED478h case    7:*/		return 0x820ED47C;
		  /* 820ED47Ch */ case    8:  		/* li R5, 4511 */
		/* 820ED47Ch case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x119F);
		/* 820ED47Ch case    8:*/		return 0x820ED480;
		  /* 820ED480h */ case    9:  		/* addi R6, R10, -17680 */
		/* 820ED480h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFBAF0);
		/* 820ED480h case    9:*/		return 0x820ED484;
		  /* 820ED484h */ case   10:  		/* lwz R4, <#[R11 + 60]> */
		/* 820ED484h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 820ED484h case   10:*/		return 0x820ED488;
	}
	return 0x820ED488;
} // Block from 820ED45Ch-820ED488h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ED488h
// Function '?DestRegister@CShaderProgram@D3DXShader@@MAAJPAVCArgument@2@PAK1PAH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED488);
		  /* 820ED488h */ case    0:  		/* b 40 */
		/* 820ED488h case    0:*/		return 0x820ED4B0;
		/* 820ED488h case    0:*/		return 0x820ED48C;
	}
	return 0x820ED48C;
} // Block from 820ED488h-820ED48Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED48Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED48C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED48C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED48C);
		  /* 820ED48Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 820ED48Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820ED48Ch case    0:*/		return 0x820ED490;
		  /* 820ED490h */ case    1:  		/* ori R11, R11, 8192 */
		/* 820ED490h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 820ED490h case    1:*/		return 0x820ED494;
		  /* 820ED494h */ case    2:  		/* stw R11, <#[R29]> */
		/* 820ED494h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820ED494h case    2:*/		return 0x820ED498;
	}
	return 0x820ED498;
} // Block from 820ED48Ch-820ED498h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ED498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED498);
		  /* 820ED498h */ case    0:  		/* li R3, 0 */
		/* 820ED498h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820ED498h case    0:*/		return 0x820ED49C;
		  /* 820ED49Ch */ case    1:  		/* b 36 */
		/* 820ED49Ch case    1:*/		return 0x820ED4C0;
		/* 820ED49Ch case    1:*/		return 0x820ED4A0;
	}
	return 0x820ED4A0;
} // Block from 820ED498h-820ED4A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ED4A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED4A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED4A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED4A0);
		  /* 820ED4A0h */ case    0:  		/* lis R11, -32254 */
		/* 820ED4A0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820ED4A0h case    0:*/		return 0x820ED4A4;
		  /* 820ED4A4h */ case    1:  		/* li R5, 0 */
		/* 820ED4A4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820ED4A4h case    1:*/		return 0x820ED4A8;
		  /* 820ED4A8h */ case    2:  		/* addi R6, R11, -17728 */
		/* 820ED4A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBAC0);
		/* 820ED4A8h case    2:*/		return 0x820ED4AC;
		  /* 820ED4ACh */ case    3:  		/* li R4, 0 */
		/* 820ED4ACh case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820ED4ACh case    3:*/		return 0x820ED4B0;
	}
	return 0x820ED4B0;
} // Block from 820ED4A0h-820ED4B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ED4B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED4B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED4B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED4B0);
		  /* 820ED4B0h */ case    0:  		/* mr R3, R31 */
		/* 820ED4B0h case    0:*/		regs.R3 = regs.R31;
		/* 820ED4B0h case    0:*/		return 0x820ED4B4;
		  /* 820ED4B4h */ case    1:  		/* bl 135804 */
		/* 820ED4B4h case    1:*/		regs.LR = 0x820ED4B8; return 0x8210E730;
		/* 820ED4B4h case    1:*/		return 0x820ED4B8;
		  /* 820ED4B8h */ case    2:  		/* lis R3, -32768 */
		/* 820ED4B8h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820ED4B8h case    2:*/		return 0x820ED4BC;
		  /* 820ED4BCh */ case    3:  		/* ori R3, R3, 16389 */
		/* 820ED4BCh case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820ED4BCh case    3:*/		return 0x820ED4C0;
	}
	return 0x820ED4C0;
} // Block from 820ED4B0h-820ED4C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ED4C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED4C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED4C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED4C0);
		  /* 820ED4C0h */ case    0:  		/* addi R1, R1, 128 */
		/* 820ED4C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820ED4C0h case    0:*/		return 0x820ED4C4;
		  /* 820ED4C4h */ case    1:  		/* b -377372 */
		/* 820ED4C4h case    1:*/		return 0x820912A8;
		/* 820ED4C4h case    1:*/		return 0x820ED4C8;
	}
	return 0x820ED4C8;
} // Block from 820ED4C0h-820ED4C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ED4C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED4C8);
		  /* 820ED4C8h */ case    0:  		/* mfspr R12, LR */
		/* 820ED4C8h case    0:*/		regs.R12 = regs.LR;
		/* 820ED4C8h case    0:*/		return 0x820ED4CC;
		  /* 820ED4CCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820ED4CCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820ED4CCh case    1:*/		return 0x820ED4D0;
		  /* 820ED4D0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820ED4D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820ED4D0h case    2:*/		return 0x820ED4D4;
		  /* 820ED4D4h */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 820ED4D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820ED4D4h case    3:*/		return 0x820ED4D8;
		  /* 820ED4D8h */ case    4:  		/* li R7, 0 */
		/* 820ED4D8h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820ED4D8h case    4:*/		return 0x820ED4DC;
		  /* 820ED4DCh */ case    5:  		/* li R9, 0 */
		/* 820ED4DCh case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820ED4DCh case    5:*/		return 0x820ED4E0;
		  /* 820ED4E0h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820ED4E0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820ED4E0h case    6:*/		return 0x820ED4E4;
		  /* 820ED4E4h */ case    7:  		/* bc 4, CR6_GT, 444 */
		/* 820ED4E4h case    7:*/		if ( !regs.CR[6].gt ) { return 0x820ED6A0;  }
		/* 820ED4E4h case    7:*/		return 0x820ED4E8;
		  /* 820ED4E8h */ case    8:  		/* li R8, 0 */
		/* 820ED4E8h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820ED4E8h case    8:*/		return 0x820ED4EC;
		  /* 820ED4ECh */ case    9:  		/* lwz R11, <#[R3 + 24]> */
		/* 820ED4ECh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820ED4ECh case    9:*/		return 0x820ED4F0;
		  /* 820ED4F0h */ case   10:  		/* stw R9, <#[R3 + 256]> */
		/* 820ED4F0h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000100) );
		/* 820ED4F0h case   10:*/		return 0x820ED4F4;
		  /* 820ED4F4h */ case   11:  		/* lwzx R10, <#[R11 + R8]> */
		/* 820ED4F4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820ED4F4h case   11:*/		return 0x820ED4F8;
		  /* 820ED4F8h */ case   12:  		/* stw R10, <#[R3 + 260]> */
		/* 820ED4F8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000104) );
		/* 820ED4F8h case   12:*/		return 0x820ED4FC;
		  /* 820ED4FCh */ case   13:  		/* lwz R11, <#[R10]> */
		/* 820ED4FCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820ED4FCh case   13:*/		return 0x820ED500;
		  /* 820ED500h */ case   14:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 820ED500h case   14:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820ED500h case   14:*/		return 0x820ED504;
		  /* 820ED504h */ case   15:  		/* bc 12, CR0_EQ, 352 */
		/* 820ED504h case   15:*/		if ( regs.CR[0].eq ) { return 0x820ED664;  }
		/* 820ED504h case   15:*/		return 0x820ED508;
		  /* 820ED508h */ case   16:  		/* lwz R6, <#[R10 + 4]> */
		/* 820ED508h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 820ED508h case   16:*/		return 0x820ED50C;
		  /* 820ED50Ch */ case   17:  		/* cmplwi CR6, R6, 0 */
		/* 820ED50Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820ED50Ch case   17:*/		return 0x820ED510;
		  /* 820ED510h */ case   18:  		/* bc 12, CR6_EQ, 340 */
		/* 820ED510h case   18:*/		if ( regs.CR[6].eq ) { return 0x820ED664;  }
		/* 820ED510h case   18:*/		return 0x820ED514;
		  /* 820ED514h */ case   19:  		/* lwz R10, <#[R10 + 8]> */
		/* 820ED514h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820ED514h case   19:*/		return 0x820ED518;
		  /* 820ED518h */ case   20:  		/* lis R6, 24656 */
		/* 820ED518h case   20:*/		cpu::op::lis<0>(regs,&regs.R6,0x6050);
		/* 820ED518h case   20:*/		return 0x820ED51C;
		  /* 820ED51Ch */ case   21:  		/* lwz R5, <#[R3 + 20]> */
		/* 820ED51Ch case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820ED51Ch case   21:*/		return 0x820ED520;
		  /* 820ED520h */ case   22:  		/* cmplw CR6, R11, R6 */
		/* 820ED520h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED520h case   22:*/		return 0x820ED524;
		  /* 820ED524h */ case   23:  		/* lwz R10, <#[R10]> */
		/* 820ED524h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820ED524h case   23:*/		return 0x820ED528;
		  /* 820ED528h */ case   24:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820ED528h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820ED528h case   24:*/		return 0x820ED52C;
		  /* 820ED52Ch */ case   25:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820ED52Ch case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820ED52Ch case   25:*/		return 0x820ED530;
		  /* 820ED530h */ case   26:  		/* bc 12, CR6_EQ, 284 */
		/* 820ED530h case   26:*/		if ( regs.CR[6].eq ) { return 0x820ED64C;  }
		/* 820ED530h case   26:*/		return 0x820ED534;
		  /* 820ED534h */ case   27:  		/* lis R6, 24688 */
		/* 820ED534h case   27:*/		cpu::op::lis<0>(regs,&regs.R6,0x6070);
		/* 820ED534h case   27:*/		return 0x820ED538;
		  /* 820ED538h */ case   28:  		/* cmplw CR6, R11, R6 */
		/* 820ED538h case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED538h case   28:*/		return 0x820ED53C;
		  /* 820ED53Ch */ case   29:  		/* bc 12, CR6_EQ, 272 */
		/* 820ED53Ch case   29:*/		if ( regs.CR[6].eq ) { return 0x820ED64C;  }
		/* 820ED53Ch case   29:*/		return 0x820ED540;
		  /* 820ED540h */ case   30:  		/* lis R6, 24704 */
		/* 820ED540h case   30:*/		cpu::op::lis<0>(regs,&regs.R6,0x6080);
		/* 820ED540h case   30:*/		return 0x820ED544;
		  /* 820ED544h */ case   31:  		/* cmplw CR6, R11, R6 */
		/* 820ED544h case   31:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED544h case   31:*/		return 0x820ED548;
		  /* 820ED548h */ case   32:  		/* bc 12, CR6_EQ, 260 */
		/* 820ED548h case   32:*/		if ( regs.CR[6].eq ) { return 0x820ED64C;  }
		/* 820ED548h case   32:*/		return 0x820ED54C;
		  /* 820ED54Ch */ case   33:  		/* lis R6, 24720 */
		/* 820ED54Ch case   33:*/		cpu::op::lis<0>(regs,&regs.R6,0x6090);
		/* 820ED54Ch case   33:*/		return 0x820ED550;
		  /* 820ED550h */ case   34:  		/* cmplw CR6, R11, R6 */
		/* 820ED550h case   34:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED550h case   34:*/		return 0x820ED554;
		  /* 820ED554h */ case   35:  		/* bc 12, CR6_EQ, 248 */
		/* 820ED554h case   35:*/		if ( regs.CR[6].eq ) { return 0x820ED64C;  }
		/* 820ED554h case   35:*/		return 0x820ED558;
		  /* 820ED558h */ case   36:  		/* lis R6, 24672 */
		/* 820ED558h case   36:*/		cpu::op::lis<0>(regs,&regs.R6,0x6060);
		/* 820ED558h case   36:*/		return 0x820ED55C;
		  /* 820ED55Ch */ case   37:  		/* cmplw CR6, R11, R6 */
		/* 820ED55Ch case   37:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED55Ch case   37:*/		return 0x820ED560;
		  /* 820ED560h */ case   38:  		/* bc 12, CR6_EQ, 236 */
		/* 820ED560h case   38:*/		if ( regs.CR[6].eq ) { return 0x820ED64C;  }
		/* 820ED560h case   38:*/		return 0x820ED564;
		  /* 820ED564h */ case   39:  		/* lis R6, 24576 */
		/* 820ED564h case   39:*/		cpu::op::lis<0>(regs,&regs.R6,0x6000);
		/* 820ED564h case   39:*/		return 0x820ED568;
		  /* 820ED568h */ case   40:  		/* cmplw CR6, R11, R6 */
		/* 820ED568h case   40:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED568h case   40:*/		return 0x820ED56C;
		  /* 820ED56Ch */ case   41:  		/* bc 12, CR6_EQ, 224 */
		/* 820ED56Ch case   41:*/		if ( regs.CR[6].eq ) { return 0x820ED64C;  }
		/* 820ED56Ch case   41:*/		return 0x820ED570;
		  /* 820ED570h */ case   42:  		/* lis R6, 24608 */
		/* 820ED570h case   42:*/		cpu::op::lis<0>(regs,&regs.R6,0x6020);
		/* 820ED570h case   42:*/		return 0x820ED574;
		  /* 820ED574h */ case   43:  		/* cmplw CR6, R11, R6 */
		/* 820ED574h case   43:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED574h case   43:*/		return 0x820ED578;
		  /* 820ED578h */ case   44:  		/* bc 12, CR6_EQ, 212 */
		/* 820ED578h case   44:*/		if ( regs.CR[6].eq ) { return 0x820ED64C;  }
		/* 820ED578h case   44:*/		return 0x820ED57C;
		  /* 820ED57Ch */ case   45:  		/* lis R6, 24624 */
		/* 820ED57Ch case   45:*/		cpu::op::lis<0>(regs,&regs.R6,0x6030);
		/* 820ED57Ch case   45:*/		return 0x820ED580;
		  /* 820ED580h */ case   46:  		/* cmplw CR6, R11, R6 */
		/* 820ED580h case   46:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED580h case   46:*/		return 0x820ED584;
		  /* 820ED584h */ case   47:  		/* bc 12, CR6_EQ, 200 */
		/* 820ED584h case   47:*/		if ( regs.CR[6].eq ) { return 0x820ED64C;  }
		/* 820ED584h case   47:*/		return 0x820ED588;
		  /* 820ED588h */ case   48:  		/* lis R6, 24640 */
		/* 820ED588h case   48:*/		cpu::op::lis<0>(regs,&regs.R6,0x6040);
		/* 820ED588h case   48:*/		return 0x820ED58C;
		  /* 820ED58Ch */ case   49:  		/* cmplw CR6, R11, R6 */
		/* 820ED58Ch case   49:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED58Ch case   49:*/		return 0x820ED590;
		  /* 820ED590h */ case   50:  		/* bc 12, CR6_EQ, 188 */
		/* 820ED590h case   50:*/		if ( regs.CR[6].eq ) { return 0x820ED64C;  }
		/* 820ED590h case   50:*/		return 0x820ED594;
		  /* 820ED594h */ case   51:  		/* lis R6, 24592 */
		/* 820ED594h case   51:*/		cpu::op::lis<0>(regs,&regs.R6,0x6010);
		/* 820ED594h case   51:*/		return 0x820ED598;
		  /* 820ED598h */ case   52:  		/* cmplw CR6, R11, R6 */
		/* 820ED598h case   52:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED598h case   52:*/		return 0x820ED59C;
		  /* 820ED59Ch */ case   53:  		/* bc 12, CR6_EQ, 176 */
		/* 820ED59Ch case   53:*/		if ( regs.CR[6].eq ) { return 0x820ED64C;  }
		/* 820ED59Ch case   53:*/		return 0x820ED5A0;
		  /* 820ED5A0h */ case   54:  		/* lis R6, 24736 */
		/* 820ED5A0h case   54:*/		cpu::op::lis<0>(regs,&regs.R6,0x60A0);
		/* 820ED5A0h case   54:*/		return 0x820ED5A4;
		  /* 820ED5A4h */ case   55:  		/* cmplw CR6, R11, R6 */
		/* 820ED5A4h case   55:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED5A4h case   55:*/		return 0x820ED5A8;
		  /* 820ED5A8h */ case   56:  		/* bc 12, CR6_EQ, 136 */
		/* 820ED5A8h case   56:*/		if ( regs.CR[6].eq ) { return 0x820ED630;  }
		/* 820ED5A8h case   56:*/		return 0x820ED5AC;
		  /* 820ED5ACh */ case   57:  		/* lis R6, 24768 */
		/* 820ED5ACh case   57:*/		cpu::op::lis<0>(regs,&regs.R6,0x60C0);
		/* 820ED5ACh case   57:*/		return 0x820ED5B0;
		  /* 820ED5B0h */ case   58:  		/* cmplw CR6, R11, R6 */
		/* 820ED5B0h case   58:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED5B0h case   58:*/		return 0x820ED5B4;
		  /* 820ED5B4h */ case   59:  		/* bc 12, CR6_EQ, 124 */
		/* 820ED5B4h case   59:*/		if ( regs.CR[6].eq ) { return 0x820ED630;  }
		/* 820ED5B4h case   59:*/		return 0x820ED5B8;
		  /* 820ED5B8h */ case   60:  		/* lis R6, 24784 */
		/* 820ED5B8h case   60:*/		cpu::op::lis<0>(regs,&regs.R6,0x60D0);
		/* 820ED5B8h case   60:*/		return 0x820ED5BC;
		  /* 820ED5BCh */ case   61:  		/* cmplw CR6, R11, R6 */
		/* 820ED5BCh case   61:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED5BCh case   61:*/		return 0x820ED5C0;
		  /* 820ED5C0h */ case   62:  		/* bc 12, CR6_EQ, 112 */
		/* 820ED5C0h case   62:*/		if ( regs.CR[6].eq ) { return 0x820ED630;  }
		/* 820ED5C0h case   62:*/		return 0x820ED5C4;
		  /* 820ED5C4h */ case   63:  		/* lis R6, 24800 */
		/* 820ED5C4h case   63:*/		cpu::op::lis<0>(regs,&regs.R6,0x60E0);
		/* 820ED5C4h case   63:*/		return 0x820ED5C8;
		  /* 820ED5C8h */ case   64:  		/* cmplw CR6, R11, R6 */
		/* 820ED5C8h case   64:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED5C8h case   64:*/		return 0x820ED5CC;
		  /* 820ED5CCh */ case   65:  		/* bc 12, CR6_EQ, 100 */
		/* 820ED5CCh case   65:*/		if ( regs.CR[6].eq ) { return 0x820ED630;  }
		/* 820ED5CCh case   65:*/		return 0x820ED5D0;
		  /* 820ED5D0h */ case   66:  		/* lis R6, 24752 */
		/* 820ED5D0h case   66:*/		cpu::op::lis<0>(regs,&regs.R6,0x60B0);
		/* 820ED5D0h case   66:*/		return 0x820ED5D4;
		  /* 820ED5D4h */ case   67:  		/* cmplw CR6, R11, R6 */
		/* 820ED5D4h case   67:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED5D4h case   67:*/		return 0x820ED5D8;
		  /* 820ED5D8h */ case   68:  		/* bc 12, CR6_EQ, 88 */
		/* 820ED5D8h case   68:*/		if ( regs.CR[6].eq ) { return 0x820ED630;  }
		/* 820ED5D8h case   68:*/		return 0x820ED5DC;
		  /* 820ED5DCh */ case   69:  		/* lis R6, 24816 */
		/* 820ED5DCh case   69:*/		cpu::op::lis<0>(regs,&regs.R6,0x60F0);
		/* 820ED5DCh case   69:*/		return 0x820ED5E0;
		  /* 820ED5E0h */ case   70:  		/* cmplw CR6, R11, R6 */
		/* 820ED5E0h case   70:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED5E0h case   70:*/		return 0x820ED5E4;
		  /* 820ED5E4h */ case   71:  		/* bc 12, CR6_EQ, 52 */
		/* 820ED5E4h case   71:*/		if ( regs.CR[6].eq ) { return 0x820ED618;  }
		/* 820ED5E4h case   71:*/		return 0x820ED5E8;
		  /* 820ED5E8h */ case   72:  		/* lis R6, 24848 */
		/* 820ED5E8h case   72:*/		cpu::op::lis<0>(regs,&regs.R6,0x6110);
		/* 820ED5E8h case   72:*/		return 0x820ED5EC;
		  /* 820ED5ECh */ case   73:  		/* cmplw CR6, R11, R6 */
		/* 820ED5ECh case   73:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED5ECh case   73:*/		return 0x820ED5F0;
		  /* 820ED5F0h */ case   74:  		/* bc 12, CR6_EQ, 40 */
		/* 820ED5F0h case   74:*/		if ( regs.CR[6].eq ) { return 0x820ED618;  }
		/* 820ED5F0h case   74:*/		return 0x820ED5F4;
		  /* 820ED5F4h */ case   75:  		/* lis R6, 24864 */
		/* 820ED5F4h case   75:*/		cpu::op::lis<0>(regs,&regs.R6,0x6120);
		/* 820ED5F4h case   75:*/		return 0x820ED5F8;
		  /* 820ED5F8h */ case   76:  		/* cmplw CR6, R11, R6 */
		/* 820ED5F8h case   76:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED5F8h case   76:*/		return 0x820ED5FC;
		  /* 820ED5FCh */ case   77:  		/* bc 12, CR6_EQ, 28 */
		/* 820ED5FCh case   77:*/		if ( regs.CR[6].eq ) { return 0x820ED618;  }
		/* 820ED5FCh case   77:*/		return 0x820ED600;
		  /* 820ED600h */ case   78:  		/* lis R6, 24880 */
		/* 820ED600h case   78:*/		cpu::op::lis<0>(regs,&regs.R6,0x6130);
		/* 820ED600h case   78:*/		return 0x820ED604;
		  /* 820ED604h */ case   79:  		/* cmplw CR6, R11, R6 */
		/* 820ED604h case   79:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED604h case   79:*/		return 0x820ED608;
		  /* 820ED608h */ case   80:  		/* bc 12, CR6_EQ, 16 */
		/* 820ED608h case   80:*/		if ( regs.CR[6].eq ) { return 0x820ED618;  }
		/* 820ED608h case   80:*/		return 0x820ED60C;
		  /* 820ED60Ch */ case   81:  		/* lis R6, 24832 */
		/* 820ED60Ch case   81:*/		cpu::op::lis<0>(regs,&regs.R6,0x6100);
		/* 820ED60Ch case   81:*/		return 0x820ED610;
		  /* 820ED610h */ case   82:  		/* cmplw CR6, R11, R6 */
		/* 820ED610h case   82:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820ED610h case   82:*/		return 0x820ED614;
		  /* 820ED614h */ case   83:  		/* bc 4, CR6_EQ, 80 */
		/* 820ED614h case   83:*/		if ( !regs.CR[6].eq ) { return 0x820ED664;  }
		/* 820ED614h case   83:*/		return 0x820ED618;
	}
	return 0x820ED618;
} // Block from 820ED4C8h-820ED618h (84 instructions)

//////////////////////////////////////////////////////
// Block at 820ED618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED618);
		  /* 820ED618h */ case    0:  		/* lwz R11, <#[R10 + 60]> */
		/* 820ED618h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000003C) );
		/* 820ED618h case    0:*/		return 0x820ED61C;
		  /* 820ED61Ch */ case    1:  		/* rlwinm. R11, R11, 0, 9, 10 */
		/* 820ED61Ch case    1:*/		cpu::op::rlwinm<1,0,9,10>(regs,&regs.R11,regs.R11);
		/* 820ED61Ch case    1:*/		return 0x820ED620;
		  /* 820ED620h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 820ED620h case    2:*/		if ( regs.CR[0].eq ) { return 0x820ED628;  }
		/* 820ED620h case    2:*/		return 0x820ED624;
		  /* 820ED624h */ case    3:  		/* li R7, 1 */
		/* 820ED624h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820ED624h case    3:*/		return 0x820ED628;
	}
	return 0x820ED628;
} // Block from 820ED618h-820ED628h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ED628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED628);
		  /* 820ED628h */ case    0:  		/* lis R11, 128 */
		/* 820ED628h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x80);
		/* 820ED628h case    0:*/		return 0x820ED62C;
		  /* 820ED62Ch */ case    1:  		/* b 52 */
		/* 820ED62Ch case    1:*/		return 0x820ED660;
		/* 820ED62Ch case    1:*/		return 0x820ED630;
	}
	return 0x820ED630;
} // Block from 820ED628h-820ED630h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ED630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED630);
		  /* 820ED630h */ case    0:  		/* lwz R11, <#[R10 + 60]> */
		/* 820ED630h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000003C) );
		/* 820ED630h case    0:*/		return 0x820ED634;
		  /* 820ED634h */ case    1:  		/* andis. R11, R11, 160 */
		/* 820ED634h case    1:*/		cpu::op::andis<1>(regs,&regs.R11,regs.R11,0xA0);
		/* 820ED634h case    1:*/		return 0x820ED638;
		  /* 820ED638h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 820ED638h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820ED638h case    2:*/		return 0x820ED63C;
		  /* 820ED63Ch */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 820ED63Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820ED644;  }
		/* 820ED63Ch case    3:*/		return 0x820ED640;
		  /* 820ED640h */ case    4:  		/* li R7, 1 */
		/* 820ED640h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820ED640h case    4:*/		return 0x820ED644;
	}
	return 0x820ED644;
} // Block from 820ED630h-820ED644h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ED644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED644);
		  /* 820ED644h */ case    0:  		/* lis R11, 64 */
		/* 820ED644h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x40);
		/* 820ED644h case    0:*/		return 0x820ED648;
		  /* 820ED648h */ case    1:  		/* b 24 */
		/* 820ED648h case    1:*/		return 0x820ED660;
		/* 820ED648h case    1:*/		return 0x820ED64C;
	}
	return 0x820ED64C;
} // Block from 820ED644h-820ED64Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ED64Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED64C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED64C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED64C);
		  /* 820ED64Ch */ case    0:  		/* lwz R11, <#[R10 + 60]> */
		/* 820ED64Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000003C) );
		/* 820ED64Ch case    0:*/		return 0x820ED650;
		  /* 820ED650h */ case    1:  		/* rlwinm. R11, R11, 0, 8, 9 */
		/* 820ED650h case    1:*/		cpu::op::rlwinm<1,0,8,9>(regs,&regs.R11,regs.R11);
		/* 820ED650h case    1:*/		return 0x820ED654;
		  /* 820ED654h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 820ED654h case    2:*/		if ( regs.CR[0].eq ) { return 0x820ED65C;  }
		/* 820ED654h case    2:*/		return 0x820ED658;
	}
	return 0x820ED658;
} // Block from 820ED64Ch-820ED658h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ED658h
// Function '?DestMask@CShaderProgram@D3DXShader@@MAAJPAIIPAKH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED658);
		  /* 820ED658h */ case    0:  		/* li R7, 1 */
		/* 820ED658h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820ED658h case    0:*/		return 0x820ED65C;
	}
	return 0x820ED65C;
} // Block from 820ED658h-820ED65Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED65Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED65C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED65C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED65C);
		  /* 820ED65Ch */ case    0:  		/* lis R11, 32 */
		/* 820ED65Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x20);
		/* 820ED65Ch case    0:*/		return 0x820ED660;
	}
	return 0x820ED660;
} // Block from 820ED65Ch-820ED660h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED660);
		  /* 820ED660h */ case    0:  		/* stw R11, <#[R10 + 60]> */
		/* 820ED660h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000003C) );
		/* 820ED660h case    0:*/		return 0x820ED664;
	}
	return 0x820ED664;
} // Block from 820ED660h-820ED664h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED664);
		  /* 820ED664h */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 820ED664h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820ED664h case    0:*/		return 0x820ED668;
		  /* 820ED668h */ case    1:  		/* addi R9, R9, 1 */
		/* 820ED668h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820ED668h case    1:*/		return 0x820ED66C;
		  /* 820ED66Ch */ case    2:  		/* addi R8, R8, 4 */
		/* 820ED66Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820ED66Ch case    2:*/		return 0x820ED670;
		  /* 820ED670h */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 820ED670h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820ED670h case    3:*/		return 0x820ED674;
		  /* 820ED674h */ case    4:  		/* bc 12, CR6_LT, -392 */
		/* 820ED674h case    4:*/		if ( regs.CR[6].lt ) { return 0x820ED4EC;  }
		/* 820ED674h case    4:*/		return 0x820ED678;
		  /* 820ED678h */ case    5:  		/* cmpwi CR6, R7, 0 */
		/* 820ED678h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 820ED678h case    5:*/		return 0x820ED67C;
		  /* 820ED67Ch */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 820ED67Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820ED6A0;  }
		/* 820ED67Ch case    6:*/		return 0x820ED680;
		  /* 820ED680h */ case    7:  		/* lis R11, -32254 */
		/* 820ED680h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820ED680h case    7:*/		return 0x820ED684;
		  /* 820ED684h */ case    8:  		/* li R5, 4539 */
		/* 820ED684h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x11BB);
		/* 820ED684h case    8:*/		return 0x820ED688;
		  /* 820ED688h */ case    9:  		/* addi R6, R11, -17424 */
		/* 820ED688h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBBF0);
		/* 820ED688h case    9:*/		return 0x820ED68C;
		  /* 820ED68Ch */ case   10:  		/* li R4, 0 */
		/* 820ED68Ch case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820ED68Ch case   10:*/		return 0x820ED690;
		  /* 820ED690h */ case   11:  		/* bl 135328 */
		/* 820ED690h case   11:*/		regs.LR = 0x820ED694; return 0x8210E730;
		/* 820ED690h case   11:*/		return 0x820ED694;
		  /* 820ED694h */ case   12:  		/* lis R3, -32768 */
		/* 820ED694h case   12:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820ED694h case   12:*/		return 0x820ED698;
		  /* 820ED698h */ case   13:  		/* ori R3, R3, 16389 */
		/* 820ED698h case   13:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820ED698h case   13:*/		return 0x820ED69C;
		  /* 820ED69Ch */ case   14:  		/* b 8 */
		/* 820ED69Ch case   14:*/		return 0x820ED6A4;
		/* 820ED69Ch case   14:*/		return 0x820ED6A0;
	}
	return 0x820ED6A0;
} // Block from 820ED664h-820ED6A0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820ED6A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED6A0);
		  /* 820ED6A0h */ case    0:  		/* li R3, 0 */
		/* 820ED6A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820ED6A0h case    0:*/		return 0x820ED6A4;
	}
	return 0x820ED6A4;
} // Block from 820ED6A0h-820ED6A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED6A4);
		  /* 820ED6A4h */ case    0:  		/* addi R1, R1, 96 */
		/* 820ED6A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820ED6A4h case    0:*/		return 0x820ED6A8;
		  /* 820ED6A8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820ED6A8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820ED6A8h case    1:*/		return 0x820ED6AC;
		  /* 820ED6ACh */ case    2:  		/* mtspr LR, R12 */
		/* 820ED6ACh case    2:*/		regs.LR = regs.R12;
		/* 820ED6ACh case    2:*/		return 0x820ED6B0;
		  /* 820ED6B0h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820ED6B0h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820ED6B0h case    3:*/		return 0x820ED6B4;
	}
	return 0x820ED6B4;
} // Block from 820ED6A4h-820ED6B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ED6B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED6B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED6B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED6B4);
		  /* 820ED6B4h */ case    0:  		/* nop */
		/* 820ED6B4h case    0:*/		cpu::op::nop();
		/* 820ED6B4h case    0:*/		return 0x820ED6B8;
	}
	return 0x820ED6B8;
} // Block from 820ED6B4h-820ED6B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED6B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED6B8);
		  /* 820ED6B8h */ case    0:  		/* mfspr R12, LR */
		/* 820ED6B8h case    0:*/		regs.R12 = regs.LR;
		/* 820ED6B8h case    0:*/		return 0x820ED6BC;
		  /* 820ED6BCh */ case    1:  		/* bl -377952 */
		/* 820ED6BCh case    1:*/		regs.LR = 0x820ED6C0; return 0x8209125C;
		/* 820ED6BCh case    1:*/		return 0x820ED6C0;
		  /* 820ED6C0h */ case    2:  		/* lwz R10, <#[R4]> */
		/* 820ED6C0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 820ED6C0h case    2:*/		return 0x820ED6C4;
		  /* 820ED6C4h */ case    3:  		/* li R11, 0 */
		/* 820ED6C4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820ED6C4h case    3:*/		return 0x820ED6C8;
		  /* 820ED6C8h */ case    4:  		/* lwz R30, <#[R3 + 20]> */
		/* 820ED6C8h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000014) );
		/* 820ED6C8h case    4:*/		return 0x820ED6CC;
		  /* 820ED6CCh */ case    5:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 820ED6CCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 820ED6CCh case    5:*/		return 0x820ED6D0;
		  /* 820ED6D0h */ case    6:  		/* lwz R10, <#[R3 + 16]> */
		/* 820ED6D0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 820ED6D0h case    6:*/		return 0x820ED6D4;
		  /* 820ED6D4h */ case    7:  		/* lwzx R31, <#[R30 + R9]> */
		/* 820ED6D4h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 820ED6D4h case    7:*/		return 0x820ED6D8;
		  /* 820ED6D8h */ case    8:  		/* lwz R8, <#[R31 + 4]> */
		/* 820ED6D8h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 820ED6D8h case    8:*/		return 0x820ED6DC;
		  /* 820ED6DCh */ case    9:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820ED6DCh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820ED6DCh case    9:*/		return 0x820ED6E0;
		  /* 820ED6E0h */ case   10:  		/* lwzx R10, <#[R8 + R10]> */
		/* 820ED6E0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820ED6E0h case   10:*/		return 0x820ED6E4;
		  /* 820ED6E4h */ case   11:  		/* lwz R10, <#[R10 + 4]> */
		/* 820ED6E4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820ED6E4h case   11:*/		return 0x820ED6E8;
		  /* 820ED6E8h */ case   12:  		/* rlwinm. R10, R10, 0, 24, 24 */
		/* 820ED6E8h case   12:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R10);
		/* 820ED6E8h case   12:*/		return 0x820ED6EC;
		  /* 820ED6ECh */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 820ED6ECh case   13:*/		if ( regs.CR[0].eq ) { return 0x820ED6FC;  }
		/* 820ED6ECh case   13:*/		return 0x820ED6F0;
		  /* 820ED6F0h */ case   14:  		/* lis R11, 228 */
		/* 820ED6F0h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xE4);
		/* 820ED6F0h case   14:*/		return 0x820ED6F4;
		  /* 820ED6F4h */ case   15:  		/* stw R11, <#[R7]> */
		/* 820ED6F4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 820ED6F4h case   15:*/		return 0x820ED6F8;
		  /* 820ED6F8h */ case   16:  		/* b 360 */
		/* 820ED6F8h case   16:*/		return 0x820ED860;
		/* 820ED6F8h case   16:*/		return 0x820ED6FC;
	}
	return 0x820ED6FC;
} // Block from 820ED6B8h-820ED6FCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820ED6FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED6FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED6FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED6FC);
		  /* 820ED6FCh */ case    0:  		/* rlwinm. R10, R6, 0, 15, 15 */
		/* 820ED6FCh case    0:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R10,regs.R6);
		/* 820ED6FCh case    0:*/		return 0x820ED700;
		  /* 820ED700h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820ED700h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ED710;  }
		/* 820ED700h case    1:*/		return 0x820ED704;
		  /* 820ED704h */ case    2:  		/* li R10, 0 */
		/* 820ED704h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820ED704h case    2:*/		return 0x820ED708;
		  /* 820ED708h */ case    3:  		/* li R11, 1 */
		/* 820ED708h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820ED708h case    3:*/		return 0x820ED70C;
		  /* 820ED70Ch */ case    4:  		/* stw R10, <#[R1 - 64]> */
		/* 820ED70Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 820ED70Ch case    4:*/		return 0x820ED710;
	}
	return 0x820ED710;
} // Block from 820ED6FCh-820ED710h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ED710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED710);
		  /* 820ED710h */ case    0:  		/* rlwinm. R10, R6, 0, 14, 14 */
		/* 820ED710h case    0:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R10,regs.R6);
		/* 820ED710h case    0:*/		return 0x820ED714;
		  /* 820ED714h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820ED714h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ED72C;  }
		/* 820ED714h case    1:*/		return 0x820ED718;
		  /* 820ED718h */ case    2:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 820ED718h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820ED718h case    2:*/		return 0x820ED71C;
		  /* 820ED71Ch */ case    3:  		/* addi R8, R1, -64 */
		/* 820ED71Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFFC0);
		/* 820ED71Ch case    3:*/		return 0x820ED720;
		  /* 820ED720h */ case    4:  		/* li R29, 1 */
		/* 820ED720h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820ED720h case    4:*/		return 0x820ED724;
		  /* 820ED724h */ case    5:  		/* addi R11, R11, 1 */
		/* 820ED724h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ED724h case    5:*/		return 0x820ED728;
		  /* 820ED728h */ case    6:  		/* stwx R29, <#[R10 + R8]> */
		/* 820ED728h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820ED728h case    6:*/		return 0x820ED72C;
	}
	return 0x820ED72C;
} // Block from 820ED710h-820ED72Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ED72Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED72C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED72C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED72C);
		  /* 820ED72Ch */ case    0:  		/* rlwinm. R10, R6, 0, 13, 13 */
		/* 820ED72Ch case    0:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R10,regs.R6);
		/* 820ED72Ch case    0:*/		return 0x820ED730;
		  /* 820ED730h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820ED730h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ED748;  }
		/* 820ED730h case    1:*/		return 0x820ED734;
		  /* 820ED734h */ case    2:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 820ED734h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820ED734h case    2:*/		return 0x820ED738;
		  /* 820ED738h */ case    3:  		/* addi R8, R1, -64 */
		/* 820ED738h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFFC0);
		/* 820ED738h case    3:*/		return 0x820ED73C;
		  /* 820ED73Ch */ case    4:  		/* li R29, 2 */
		/* 820ED73Ch case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x2);
		/* 820ED73Ch case    4:*/		return 0x820ED740;
		  /* 820ED740h */ case    5:  		/* addi R11, R11, 1 */
		/* 820ED740h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ED740h case    5:*/		return 0x820ED744;
		  /* 820ED744h */ case    6:  		/* stwx R29, <#[R10 + R8]> */
		/* 820ED744h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820ED744h case    6:*/		return 0x820ED748;
	}
	return 0x820ED748;
} // Block from 820ED72Ch-820ED748h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ED748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED748);
		  /* 820ED748h */ case    0:  		/* rlwinm. R10, R6, 0, 12, 12 */
		/* 820ED748h case    0:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R10,regs.R6);
		/* 820ED748h case    0:*/		return 0x820ED74C;
		  /* 820ED74Ch */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820ED74Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820ED764;  }
		/* 820ED74Ch case    1:*/		return 0x820ED750;
		  /* 820ED750h */ case    2:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 820ED750h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820ED750h case    2:*/		return 0x820ED754;
		  /* 820ED754h */ case    3:  		/* addi R8, R1, -64 */
		/* 820ED754h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFFC0);
		/* 820ED754h case    3:*/		return 0x820ED758;
		  /* 820ED758h */ case    4:  		/* li R6, 3 */
		/* 820ED758h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 820ED758h case    4:*/		return 0x820ED75C;
		  /* 820ED75Ch */ case    5:  		/* addi R11, R11, 1 */
		/* 820ED75Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ED75Ch case    5:*/		return 0x820ED760;
		  /* 820ED760h */ case    6:  		/* stwx R6, <#[R10 + R8]> */
		/* 820ED760h case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820ED760h case    6:*/		return 0x820ED764;
	}
	return 0x820ED764;
} // Block from 820ED748h-820ED764h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ED764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED764);
		  /* 820ED764h */ case    0:  		/* cmplw CR6, R5, R11 */
		/* 820ED764h case    0:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 820ED764h case    0:*/		return 0x820ED768;
		  /* 820ED768h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 820ED768h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820ED770;  }
		/* 820ED768h case    1:*/		return 0x820ED76C;
		  /* 820ED76Ch */ case    2:  		/* mr R5, R11 */
		/* 820ED76Ch case    2:*/		regs.R5 = regs.R11;
		/* 820ED76Ch case    2:*/		return 0x820ED770;
	}
	return 0x820ED770;
} // Block from 820ED764h-820ED770h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ED770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED770);
		  /* 820ED770h */ case    0:  		/* li R8, 0 */
		/* 820ED770h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820ED770h case    0:*/		return 0x820ED774;
		  /* 820ED774h */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 820ED774h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820ED774h case    1:*/		return 0x820ED778;
		  /* 820ED778h */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 820ED778h case    2:*/		if ( regs.CR[6].eq ) { return 0x820ED7DC;  }
		/* 820ED778h case    2:*/		return 0x820ED77C;
		  /* 820ED77Ch */ case    3:  		/* lwz R10, <#[R3 + 20]> */
		/* 820ED77Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 820ED77Ch case    3:*/		return 0x820ED780;
		  /* 820ED780h */ case    4:  		/* mr R11, R4 */
		/* 820ED780h case    4:*/		regs.R11 = regs.R4;
		/* 820ED780h case    4:*/		return 0x820ED784;
		  /* 820ED784h */ case    5:  		/* lwzx R9, <#[R10 + R9]> */
		/* 820ED784h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820ED784h case    5:*/		return 0x820ED788;
		  /* 820ED788h */ case    6:  		/* lwz R9, <#[R9 + 16]> */
		/* 820ED788h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000010) );
		/* 820ED788h case    6:*/		return 0x820ED78C;
		  /* 820ED78Ch */ case    7:  		/* lwz R6, <#[R11]> */
		/* 820ED78Ch case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820ED78Ch case    7:*/		return 0x820ED790;
		  /* 820ED790h */ case    8:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820ED790h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820ED790h case    8:*/		return 0x820ED794;
		  /* 820ED794h */ case    9:  		/* lwzx R6, <#[R6 + R10]> */
		/* 820ED794h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 820ED794h case    9:*/		return 0x820ED798;
		  /* 820ED798h */ case   10:  		/* lwz R6, <#[R6 + 16]> */
		/* 820ED798h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000010) );
		/* 820ED798h case   10:*/		return 0x820ED79C;
		  /* 820ED79Ch */ case   11:  		/* cmplw CR6, R9, R6 */
		/* 820ED79Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 820ED79Ch case   11:*/		return 0x820ED7A0;
		  /* 820ED7A0h */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 820ED7A0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820ED7B4;  }
		/* 820ED7A0h case   12:*/		return 0x820ED7A4;
		  /* 820ED7A4h */ case   13:  		/* addi R8, R8, 1 */
		/* 820ED7A4h case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820ED7A4h case   13:*/		return 0x820ED7A8;
		  /* 820ED7A8h */ case   14:  		/* addi R11, R11, 4 */
		/* 820ED7A8h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820ED7A8h case   14:*/		return 0x820ED7AC;
		  /* 820ED7ACh */ case   15:  		/* cmplw CR6, R8, R5 */
		/* 820ED7ACh case   15:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R5);
		/* 820ED7ACh case   15:*/		return 0x820ED7B0;
		  /* 820ED7B0h */ case   16:  		/* bc 12, CR6_LT, -36 */
		/* 820ED7B0h case   16:*/		if ( regs.CR[6].lt ) { return 0x820ED78C;  }
		/* 820ED7B0h case   16:*/		return 0x820ED7B4;
	}
	return 0x820ED7B4;
} // Block from 820ED770h-820ED7B4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820ED7B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED7B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED7B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED7B4);
		  /* 820ED7B4h */ case    0:  		/* cmplw CR6, R8, R5 */
		/* 820ED7B4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R5);
		/* 820ED7B4h case    0:*/		return 0x820ED7B8;
		  /* 820ED7B8h */ case    1:  		/* bc 4, CR6_LT, 36 */
		/* 820ED7B8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820ED7DC;  }
		/* 820ED7B8h case    1:*/		return 0x820ED7BC;
		  /* 820ED7BCh */ case    2:  		/* li R10, 4 */
		/* 820ED7BCh case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820ED7BCh case    2:*/		return 0x820ED7C0;
		  /* 820ED7C0h */ case    3:  		/* addi R9, R1, -52 */
		/* 820ED7C0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFFCC);
		/* 820ED7C0h case    3:*/		return 0x820ED7C4;
		  /* 820ED7C4h */ case    4:  		/* li R11, 0 */
		/* 820ED7C4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820ED7C4h case    4:*/		return 0x820ED7C8;
		  /* 820ED7C8h */ case    5:  		/* mtspr CTR, R10 */
		/* 820ED7C8h case    5:*/		regs.CTR = regs.R10;
		/* 820ED7C8h case    5:*/		return 0x820ED7CC;
		  /* 820ED7CCh */ case    6:  		/* stwu R11, <#[R9 + 4]> */
		/* 820ED7CCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820ED7CCh case    6:*/		return 0x820ED7D0;
		  /* 820ED7D0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ED7D0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ED7D0h case    7:*/		return 0x820ED7D4;
		  /* 820ED7D4h */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 820ED7D4h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820ED7CC;  }
		/* 820ED7D4h case    8:*/		return 0x820ED7D8;
		  /* 820ED7D8h */ case    9:  		/* b 28 */
		/* 820ED7D8h case    9:*/		return 0x820ED7F4;
		/* 820ED7D8h case    9:*/		return 0x820ED7DC;
	}
	return 0x820ED7DC;
} // Block from 820ED7B4h-820ED7DCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820ED7DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED7DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED7DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED7DC);
		  /* 820ED7DCh */ case    0:  		/* li R11, 4 */
		/* 820ED7DCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820ED7DCh case    0:*/		return 0x820ED7E0;
		  /* 820ED7E0h */ case    1:  		/* lwz R9, <#[R31 + 16]> */
		/* 820ED7E0h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820ED7E0h case    1:*/		return 0x820ED7E4;
		  /* 820ED7E4h */ case    2:  		/* addi R10, R1, -52 */
		/* 820ED7E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFFCC);
		/* 820ED7E4h case    2:*/		return 0x820ED7E8;
		  /* 820ED7E8h */ case    3:  		/* mtspr CTR, R11 */
		/* 820ED7E8h case    3:*/		regs.CTR = regs.R11;
		/* 820ED7E8h case    3:*/		return 0x820ED7EC;
		  /* 820ED7ECh */ case    4:  		/* stwu R9, <#[R10 + 4]> */
		/* 820ED7ECh case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820ED7ECh case    4:*/		return 0x820ED7F0;
		  /* 820ED7F0h */ case    5:  		/* bc 16, CR0_LT, -4 */
		/* 820ED7F0h case    5:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820ED7EC;  }
		/* 820ED7F0h case    5:*/		return 0x820ED7F4;
	}
	return 0x820ED7F4;
} // Block from 820ED7DCh-820ED7F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820ED7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED7F4);
		  /* 820ED7F4h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820ED7F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820ED7F4h case    0:*/		return 0x820ED7F8;
		  /* 820ED7F8h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 820ED7F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820ED834;  }
		/* 820ED7F8h case    1:*/		return 0x820ED7FC;
		  /* 820ED7FCh */ case    2:  		/* addi R10, R1, -64 */
		/* 820ED7FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFFC0);
		/* 820ED7FCh case    2:*/		return 0x820ED800;
		  /* 820ED800h */ case    3:  		/* mtspr CTR, R5 */
		/* 820ED800h case    3:*/		regs.CTR = regs.R5;
		/* 820ED800h case    3:*/		return 0x820ED804;
		  /* 820ED804h */ case    4:  		/* addi R11, R1, -64 */
		/* 820ED804h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFFC0);
		/* 820ED804h case    4:*/		return 0x820ED808;
		  /* 820ED808h */ case    5:  		/* subf R10, R10, R4 */
		/* 820ED808h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 820ED808h case    5:*/		return 0x820ED80C;
		  /* 820ED80Ch */ case    6:  		/* lwzx R9, <#[R10 + R11]> */
		/* 820ED80Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820ED80Ch case    6:*/		return 0x820ED810;
		  /* 820ED810h */ case    7:  		/* addi R8, R1, -48 */
		/* 820ED810h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFFD0);
		/* 820ED810h case    7:*/		return 0x820ED814;
		  /* 820ED814h */ case    8:  		/* lwz R6, <#[R11]> */
		/* 820ED814h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820ED814h case    8:*/		return 0x820ED818;
		  /* 820ED818h */ case    9:  		/* addi R11, R11, 4 */
		/* 820ED818h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820ED818h case    9:*/		return 0x820ED81C;
		  /* 820ED81Ch */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820ED81Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820ED81Ch case   10:*/		return 0x820ED820;
		  /* 820ED820h */ case   11:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820ED820h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820ED820h case   11:*/		return 0x820ED824;
		  /* 820ED824h */ case   12:  		/* lwzx R9, <#[R9 + R30]> */
		/* 820ED824h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 820ED824h case   12:*/		return 0x820ED828;
		  /* 820ED828h */ case   13:  		/* lwz R9, <#[R9 + 16]> */
		/* 820ED828h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000010) );
		/* 820ED828h case   13:*/		return 0x820ED82C;
		  /* 820ED82Ch */ case   14:  		/* stwx R9, <#[R6 + R8]> */
		/* 820ED82Ch case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820ED82Ch case   14:*/		return 0x820ED830;
	}
	return 0x820ED830;
} // Block from 820ED7F4h-820ED830h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820ED830h
// Function '?FindInput@CShaderProgram@D3DXShader@@MAAJPAVCArgument@2@AAK1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED830);
		  /* 820ED830h */ case    0:  		/* bc 16, CR0_LT, -36 */
		/* 820ED830h case    0:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820ED80C;  }
		/* 820ED830h case    0:*/		return 0x820ED834;
	}
	return 0x820ED834;
} // Block from 820ED830h-820ED834h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED834);
		  /* 820ED834h */ case    0:  		/* li R8, 4 */
		/* 820ED834h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 820ED834h case    0:*/		return 0x820ED838;
		  /* 820ED838h */ case    1:  		/* addi R9, R1, -52 */
		/* 820ED838h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFFCC);
		/* 820ED838h case    1:*/		return 0x820ED83C;
		  /* 820ED83Ch */ case    2:  		/* li R10, 0 */
		/* 820ED83Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820ED83Ch case    2:*/		return 0x820ED840;
		  /* 820ED840h */ case    3:  		/* li R11, 16 */
		/* 820ED840h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 820ED840h case    3:*/		return 0x820ED844;
		  /* 820ED844h */ case    4:  		/* mtspr CTR, R8 */
		/* 820ED844h case    4:*/		regs.CTR = regs.R8;
		/* 820ED844h case    4:*/		return 0x820ED848;
		  /* 820ED848h */ case    5:  		/* lwzu R8, <#[R9 + 4]> */
		/* 820ED848h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820ED848h case    5:*/		return 0x820ED84C;
		  /* 820ED84Ch */ case    6:  		/* slw R8, R8, R11 */
		/* 820ED84Ch case    6:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 820ED84Ch case    6:*/		return 0x820ED850;
		  /* 820ED850h */ case    7:  		/* or R10, R8, R10 */
		/* 820ED850h case    7:*/		cpu::op::or<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 820ED850h case    7:*/		return 0x820ED854;
		  /* 820ED854h */ case    8:  		/* addi R11, R11, 2 */
		/* 820ED854h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820ED854h case    8:*/		return 0x820ED858;
		  /* 820ED858h */ case    9:  		/* bc 16, CR0_LT, -16 */
		/* 820ED858h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820ED848;  }
		/* 820ED858h case    9:*/		return 0x820ED85C;
		  /* 820ED85Ch */ case   10:  		/* stw R10, <#[R7]> */
		/* 820ED85Ch case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 820ED85Ch case   10:*/		return 0x820ED860;
	}
	return 0x820ED860;
} // Block from 820ED834h-820ED860h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ED860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED860);
		  /* 820ED860h */ case    0:  		/* li R3, 0 */
		/* 820ED860h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820ED860h case    0:*/		return 0x820ED864;
		  /* 820ED864h */ case    1:  		/* b -378296 */
		/* 820ED864h case    1:*/		return 0x820912AC;
		/* 820ED864h case    1:*/		return 0x820ED868;
	}
	return 0x820ED868;
} // Block from 820ED860h-820ED868h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ED868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED868);
		  /* 820ED868h */ case    0:  		/* lwz R11, <#[R4 + 20]> */
		/* 820ED868h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 820ED868h case    0:*/		return 0x820ED86C;
		  /* 820ED86Ch */ case    1:  		/* li R10, 0 */
		/* 820ED86Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820ED86Ch case    1:*/		return 0x820ED870;
		  /* 820ED870h */ case    2:  		/* cmpwi CR6, R11, -1 */
		/* 820ED870h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820ED870h case    2:*/		return 0x820ED874;
		  /* 820ED874h */ case    3:  		/* bc 12, CR6_EQ, 124 */
		/* 820ED874h case    3:*/		if ( regs.CR[6].eq ) { return 0x820ED8F0;  }
		/* 820ED874h case    3:*/		return 0x820ED878;
		  /* 820ED878h */ case    4:  		/* lwz R9, <#[R3 + 20]> */
		/* 820ED878h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820ED878h case    4:*/		return 0x820ED87C;
		  /* 820ED87Ch */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820ED87Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820ED87Ch case    5:*/		return 0x820ED880;
		  /* 820ED880h */ case    6:  		/* lwz R8, <#[R3 + 16]> */
		/* 820ED880h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 820ED880h case    6:*/		return 0x820ED884;
		  /* 820ED884h */ case    7:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820ED884h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820ED884h case    7:*/		return 0x820ED888;
		  /* 820ED888h */ case    8:  		/* lwz R9, <#[R11 + 4]> */
		/* 820ED888h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820ED888h case    8:*/		return 0x820ED88C;
		  /* 820ED88Ch */ case    9:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820ED88Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820ED88Ch case    9:*/		return 0x820ED890;
	}
	return 0x820ED890;
} // Block from 820ED868h-820ED890h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820ED890h
// Function '?SrcRegister@CShaderProgram@D3DXShader@@MAAJPAVCArgument@2@PAK1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED890);
		  /* 820ED890h */ case    0:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820ED890h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820ED890h case    0:*/		return 0x820ED894;
		  /* 820ED894h */ case    1:  		/* lwz R9, <#[R9 + 4]> */
		/* 820ED894h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820ED894h case    1:*/		return 0x820ED898;
		  /* 820ED898h */ case    2:  		/* rlwinm. R9, R9, 0, 28, 28 */
		/* 820ED898h case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R9,regs.R9);
		/* 820ED898h case    2:*/		return 0x820ED89C;
		  /* 820ED89Ch */ case    3:  		/* bc 12, CR0_EQ, 84 */
		/* 820ED89Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820ED8F0;  }
		/* 820ED89Ch case    3:*/		return 0x820ED8A0;
		  /* 820ED8A0h */ case    4:  		/* lwz R10, <#[R11 + 12]> */
		/* 820ED8A0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820ED8A0h case    4:*/		return 0x820ED8A4;
		  /* 820ED8A4h */ case    5:  		/* lwz R11, <#[R11 + 16]> */
		/* 820ED8A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820ED8A4h case    5:*/		return 0x820ED8A8;
		  /* 820ED8A8h */ case    6:  		/* rlwinm R10, R10, 0, 21, 31 */
		/* 820ED8A8h case    6:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R10,regs.R10);
		/* 820ED8A8h case    6:*/		return 0x820ED8AC;
		  /* 820ED8ACh */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 820ED8ACh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820ED8ACh case    7:*/		return 0x820ED8B0;
		  /* 820ED8B0h */ case    8:  		/* oris R10, R10, 45056 */
		/* 820ED8B0h case    8:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xB000);
		/* 820ED8B0h case    8:*/		return 0x820ED8B4;
		  /* 820ED8B4h */ case    9:  		/* ori R10, R10, 4096 */
		/* 820ED8B4h case    9:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 820ED8B4h case    9:*/		return 0x820ED8B8;
		  /* 820ED8B8h */ case   10:  		/* bc 12, CR6_LT, 40 */
		/* 820ED8B8h case   10:*/		if ( regs.CR[6].lt ) { return 0x820ED8E0;  }
		/* 820ED8B8h case   10:*/		return 0x820ED8BC;
		  /* 820ED8BCh */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 820ED8BCh case   11:*/		if ( regs.CR[6].eq ) { return 0x820ED8DC;  }
		/* 820ED8BCh case   11:*/		return 0x820ED8C0;
		  /* 820ED8C0h */ case   12:  		/* cmplwi CR6, R11, 3 */
		/* 820ED8C0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820ED8C0h case   12:*/		return 0x820ED8C4;
		  /* 820ED8C4h */ case   13:  		/* bc 12, CR6_LT, 16 */
		/* 820ED8C4h case   13:*/		if ( regs.CR[6].lt ) { return 0x820ED8D4;  }
		/* 820ED8C4h case   13:*/		return 0x820ED8C8;
		  /* 820ED8C8h */ case   14:  		/* bc 4, CR6_EQ, 24 */
		/* 820ED8C8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820ED8E0;  }
		/* 820ED8C8h case   14:*/		return 0x820ED8CC;
		  /* 820ED8CCh */ case   15:  		/* oris R10, R10, 255 */
		/* 820ED8CCh case   15:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xFF);
		/* 820ED8CCh case   15:*/		return 0x820ED8D0;
		  /* 820ED8D0h */ case   16:  		/* b 16 */
		/* 820ED8D0h case   16:*/		return 0x820ED8E0;
		/* 820ED8D0h case   16:*/		return 0x820ED8D4;
	}
	return 0x820ED8D4;
} // Block from 820ED890h-820ED8D4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820ED8D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED8D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED8D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED8D4);
		  /* 820ED8D4h */ case    0:  		/* oris R10, R10, 170 */
		/* 820ED8D4h case    0:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xAA);
		/* 820ED8D4h case    0:*/		return 0x820ED8D8;
		  /* 820ED8D8h */ case    1:  		/* b 8 */
		/* 820ED8D8h case    1:*/		return 0x820ED8E0;
		/* 820ED8D8h case    1:*/		return 0x820ED8DC;
	}
	return 0x820ED8DC;
} // Block from 820ED8D4h-820ED8DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ED8DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED8DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED8DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED8DC);
		  /* 820ED8DCh */ case    0:  		/* oris R10, R10, 85 */
		/* 820ED8DCh case    0:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x55);
		/* 820ED8DCh case    0:*/		return 0x820ED8E0;
	}
	return 0x820ED8E0;
} // Block from 820ED8DCh-820ED8E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED8E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED8E0);
		  /* 820ED8E0h */ case    0:  		/* lwz R11, <#[R4 + 24]> */
		/* 820ED8E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 820ED8E0h case    0:*/		return 0x820ED8E4;
		  /* 820ED8E4h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820ED8E4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ED8E4h case    1:*/		return 0x820ED8E8;
		  /* 820ED8E8h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820ED8E8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ED8F0;  }
		/* 820ED8E8h case    2:*/		return 0x820ED8EC;
		  /* 820ED8ECh */ case    3:  		/* oris R10, R10, 3328 */
		/* 820ED8ECh case    3:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xD00);
		/* 820ED8ECh case    3:*/		return 0x820ED8F0;
	}
	return 0x820ED8F0;
} // Block from 820ED8E0h-820ED8F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ED8F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED8F0);
		  /* 820ED8F0h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820ED8F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820ED8F0h case    0:*/		return 0x820ED8F4;
		  /* 820ED8F4h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820ED8F4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820ED8FC;  }
		/* 820ED8F4h case    1:*/		return 0x820ED8F8;
		  /* 820ED8F8h */ case    2:  		/* stw R10, <#[R5]> */
		/* 820ED8F8h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 820ED8F8h case    2:*/		return 0x820ED8FC;
	}
	return 0x820ED8FC;
} // Block from 820ED8F0h-820ED8FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ED8FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED8FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED8FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED8FC);
		  /* 820ED8FCh */ case    0:  		/* li R3, 0 */
		/* 820ED8FCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820ED8FCh case    0:*/		return 0x820ED900;
		  /* 820ED900h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820ED900h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820ED900h case    1:*/		return 0x820ED904;
	}
	return 0x820ED904;
} // Block from 820ED8FCh-820ED904h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ED904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED904);
		  /* 820ED904h */ case    0:  		/* nop */
		/* 820ED904h case    0:*/		cpu::op::nop();
		/* 820ED904h case    0:*/		return 0x820ED908;
	}
	return 0x820ED908;
} // Block from 820ED904h-820ED908h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED908h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED908);
		  /* 820ED908h */ case    0:  		/* mfspr R12, LR */
		/* 820ED908h case    0:*/		regs.R12 = regs.LR;
		/* 820ED908h case    0:*/		return 0x820ED90C;
		  /* 820ED90Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820ED90Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820ED90Ch case    1:*/		return 0x820ED910;
		  /* 820ED910h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820ED910h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820ED910h case    2:*/		return 0x820ED914;
		  /* 820ED914h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820ED914h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820ED914h case    3:*/		return 0x820ED918;
		  /* 820ED918h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820ED918h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820ED918h case    4:*/		return 0x820ED91C;
		  /* 820ED91Ch */ case    5:  		/* mr R31, R3 */
		/* 820ED91Ch case    5:*/		regs.R31 = regs.R3;
		/* 820ED91Ch case    5:*/		return 0x820ED920;
		  /* 820ED920h */ case    6:  		/* lwz R3, <#[R3 + 436]> */
		/* 820ED920h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000001B4) );
		/* 820ED920h case    6:*/		return 0x820ED924;
		  /* 820ED924h */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 820ED924h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820ED924h case    7:*/		return 0x820ED928;
		  /* 820ED928h */ case    8:  		/* bc 12, CR6_EQ, 132 */
		/* 820ED928h case    8:*/		if ( regs.CR[6].eq ) { return 0x820ED9AC;  }
		/* 820ED928h case    8:*/		return 0x820ED92C;
		  /* 820ED92Ch */ case    9:  		/* lwz R9, <#[R31 + 288]> */
		/* 820ED92Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000120) );
		/* 820ED92Ch case    9:*/		return 0x820ED930;
		  /* 820ED930h */ case   10:  		/* lwz R8, <#[R31 + 276]> */
		/* 820ED930h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000114) );
		/* 820ED930h case   10:*/		return 0x820ED934;
		  /* 820ED934h */ case   11:  		/* cmplw CR6, R9, R8 */
		/* 820ED934h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820ED934h case   11:*/		return 0x820ED938;
		  /* 820ED938h */ case   12:  		/* bc 4, CR6_LT, 116 */
		/* 820ED938h case   12:*/		if ( !regs.CR[6].lt ) { return 0x820ED9AC;  }
		/* 820ED938h case   12:*/		return 0x820ED93C;
		  /* 820ED93Ch */ case   13:  		/* lwz R11, <#[R31 + 212]> */
		/* 820ED93Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000D4) );
		/* 820ED93Ch case   13:*/		return 0x820ED940;
		  /* 820ED940h */ case   14:  		/* cmpwi CR6, R11, 0 */
		/* 820ED940h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ED940h case   14:*/		return 0x820ED944;
		  /* 820ED944h */ case   15:  		/* bc 4, CR6_EQ, 104 */
		/* 820ED944h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820ED9AC;  }
		/* 820ED944h case   15:*/		return 0x820ED948;
		  /* 820ED948h */ case   16:  		/* lwz R11, <#[R31 + 260]> */
		/* 820ED948h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820ED948h case   16:*/		return 0x820ED94C;
		  /* 820ED94Ch */ case   17:  		/* li R4, 0 */
		/* 820ED94Ch case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820ED94Ch case   17:*/		return 0x820ED950;
		  /* 820ED950h */ case   18:  		/* li R5, 0 */
		/* 820ED950h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820ED950h case   18:*/		return 0x820ED954;
		  /* 820ED954h */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 820ED954h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820ED954h case   19:*/		return 0x820ED958;
		  /* 820ED958h */ case   20:  		/* bc 12, CR6_EQ, 40 */
		/* 820ED958h case   20:*/		if ( regs.CR[6].eq ) { return 0x820ED980;  }
		/* 820ED958h case   20:*/		return 0x820ED95C;
		  /* 820ED95Ch */ case   21:  		/* lwz R10, <#[R11 + 60]> */
		/* 820ED95Ch case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 820ED95Ch case   21:*/		return 0x820ED960;
		  /* 820ED960h */ case   22:  		/* cmplwi CR6, R10, 0 */
		/* 820ED960h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820ED960h case   22:*/		return 0x820ED964;
		  /* 820ED964h */ case   23:  		/* bc 12, CR6_EQ, 28 */
		/* 820ED964h case   23:*/		if ( regs.CR[6].eq ) { return 0x820ED980;  }
		/* 820ED964h case   23:*/		return 0x820ED968;
		  /* 820ED968h */ case   24:  		/* lwz R10, <#[R10 + 4]> */
		/* 820ED968h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820ED968h case   24:*/		return 0x820ED96C;
		  /* 820ED96Ch */ case   25:  		/* cmpwi CR6, R10, 14 */
		/* 820ED96Ch case   25:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000E);
		/* 820ED96Ch case   25:*/		return 0x820ED970;
		  /* 820ED970h */ case   26:  		/* bc 4, CR6_EQ, 16 */
		/* 820ED970h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820ED980;  }
		/* 820ED970h case   26:*/		return 0x820ED974;
		  /* 820ED974h */ case   27:  		/* lwz R11, <#[R11 + 60]> */
		/* 820ED974h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820ED974h case   27:*/		return 0x820ED978;
		  /* 820ED978h */ case   28:  		/* lwz R4, <#[R11 + 64]> */
		/* 820ED978h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000040) );
		/* 820ED978h case   28:*/		return 0x820ED97C;
		  /* 820ED97Ch */ case   29:  		/* lwz R5, <#[R11 + 72]> */
		/* 820ED97Ch case   29:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000048) );
		/* 820ED97Ch case   29:*/		return 0x820ED980;
	}
	return 0x820ED980;
} // Block from 820ED908h-820ED980h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820ED980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED980);
		  /* 820ED980h */ case    0:  		/* lwz R30, <#[R3]> */
		/* 820ED980h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 820ED980h case    0:*/		return 0x820ED984;
		  /* 820ED984h */ case    1:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 820ED984h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 820ED984h case    1:*/		return 0x820ED988;
		  /* 820ED988h */ case    2:  		/* lwz R11, <#[R31 + 272]> */
		/* 820ED988h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000110) );
		/* 820ED988h case    2:*/		return 0x820ED98C;
		  /* 820ED98Ch */ case    3:  		/* subf R7, R9, R8 */
		/* 820ED98Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R9,regs.R8);
		/* 820ED98Ch case    3:*/		return 0x820ED990;
		  /* 820ED990h */ case    4:  		/* add R6, R10, R11 */
		/* 820ED990h case    4:*/		cpu::op::add<0>(regs,&regs.R6,regs.R10,regs.R11);
		/* 820ED990h case    4:*/		return 0x820ED994;
		  /* 820ED994h */ case    5:  		/* lwz R11, <#[R30 + 12]> */
		/* 820ED994h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820ED994h case    5:*/		return 0x820ED998;
		  /* 820ED998h */ case    6:  		/* mtspr CTR, R11 */
		/* 820ED998h case    6:*/		regs.CTR = regs.R11;
		/* 820ED998h case    6:*/		return 0x820ED99C;
		  /* 820ED99Ch */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820ED99Ch case    7:*/		if ( 1 ) { regs.LR = 0x820ED9A0; return (uint32)regs.CTR; }
		/* 820ED99Ch case    7:*/		return 0x820ED9A0;
		  /* 820ED9A0h */ case    8:  		/* lwz R11, <#[R31 + 276]> */
		/* 820ED9A0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820ED9A0h case    8:*/		return 0x820ED9A4;
		  /* 820ED9A4h */ case    9:  		/* stw R11, <#[R31 + 288]> */
		/* 820ED9A4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000120) );
		/* 820ED9A4h case    9:*/		return 0x820ED9A8;
		  /* 820ED9A8h */ case   10:  		/* b 8 */
		/* 820ED9A8h case   10:*/		return 0x820ED9B0;
		/* 820ED9A8h case   10:*/		return 0x820ED9AC;
	}
	return 0x820ED9AC;
} // Block from 820ED980h-820ED9ACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ED9ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED9AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED9AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED9AC);
		  /* 820ED9ACh */ case    0:  		/* li R3, 0 */
		/* 820ED9ACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820ED9ACh case    0:*/		return 0x820ED9B0;
	}
	return 0x820ED9B0;
} // Block from 820ED9ACh-820ED9B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED9B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED9B0);
		  /* 820ED9B0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820ED9B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820ED9B0h case    0:*/		return 0x820ED9B4;
		  /* 820ED9B4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820ED9B4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820ED9B4h case    1:*/		return 0x820ED9B8;
		  /* 820ED9B8h */ case    2:  		/* mtspr LR, R12 */
		/* 820ED9B8h case    2:*/		regs.LR = regs.R12;
		/* 820ED9B8h case    2:*/		return 0x820ED9BC;
		  /* 820ED9BCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820ED9BCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820ED9BCh case    3:*/		return 0x820ED9C0;
		  /* 820ED9C0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820ED9C0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820ED9C0h case    4:*/		return 0x820ED9C4;
		  /* 820ED9C4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820ED9C4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820ED9C4h case    5:*/		return 0x820ED9C8;
	}
	return 0x820ED9C8;
} // Block from 820ED9B0h-820ED9C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820ED9C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED9C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED9C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED9C8);
		  /* 820ED9C8h */ case    0:  		/* lwz R11, <#[R3 + 348]> */
		/* 820ED9C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000015C) );
		/* 820ED9C8h case    0:*/		return 0x820ED9CC;
		  /* 820ED9CCh */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820ED9CCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ED9CCh case    1:*/		return 0x820ED9D0;
		  /* 820ED9D0h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820ED9D0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ED9DC;  }
		/* 820ED9D0h case    2:*/		return 0x820ED9D4;
		  /* 820ED9D4h */ case    3:  		/* li R3, 0 */
		/* 820ED9D4h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820ED9D4h case    3:*/		return 0x820ED9D8;
		  /* 820ED9D8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820ED9D8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820ED9D8h case    4:*/		return 0x820ED9DC;
	}
	return 0x820ED9DC;
} // Block from 820ED9C8h-820ED9DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ED9DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED9DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED9DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED9DC);
		  /* 820ED9DCh */ case    0:  		/* lwz R11, <#[R3 + 504]> */
		/* 820ED9DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000001F8) );
		/* 820ED9DCh case    0:*/		return 0x820ED9E0;
		  /* 820ED9E0h */ case    1:  		/* lwz R9, <#[R3 + 500]> */
		/* 820ED9E0h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x000001F4) );
		/* 820ED9E0h case    1:*/		return 0x820ED9E4;
		  /* 820ED9E4h */ case    2:  		/* lwz R10, <#[R3 + 468]> */
		/* 820ED9E4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000001D4) );
		/* 820ED9E4h case    2:*/		return 0x820ED9E8;
		  /* 820ED9E8h */ case    3:  		/* add R11, R11, R9 */
		/* 820ED9E8h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820ED9E8h case    3:*/		return 0x820ED9EC;
		  /* 820ED9ECh */ case    4:  		/* add R3, R11, R10 */
		/* 820ED9ECh case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820ED9ECh case    4:*/		return 0x820ED9F0;
		  /* 820ED9F0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820ED9F0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820ED9F0h case    5:*/		return 0x820ED9F4;
	}
	return 0x820ED9F4;
} // Block from 820ED9DCh-820ED9F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820ED9F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED9F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED9F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED9F4);
		  /* 820ED9F4h */ case    0:  		/* nop */
		/* 820ED9F4h case    0:*/		cpu::op::nop();
		/* 820ED9F4h case    0:*/		return 0x820ED9F8;
	}
	return 0x820ED9F8;
} // Block from 820ED9F4h-820ED9F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ED9F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ED9F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ED9F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ED9F8);
		  /* 820ED9F8h */ case    0:  		/* mfspr R12, LR */
		/* 820ED9F8h case    0:*/		regs.R12 = regs.LR;
		/* 820ED9F8h case    0:*/		return 0x820ED9FC;
		  /* 820ED9FCh */ case    1:  		/* bl -378800 */
		/* 820ED9FCh case    1:*/		regs.LR = 0x820EDA00; return 0x8209124C;
		/* 820ED9FCh case    1:*/		return 0x820EDA00;
		  /* 820EDA00h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820EDA00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820EDA00h case    2:*/		return 0x820EDA04;
		  /* 820EDA04h */ case    3:  		/* lwz R30, <#[R4 + 64]> */
		/* 820EDA04h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x00000040) );
		/* 820EDA04h case    3:*/		return 0x820EDA08;
		  /* 820EDA08h */ case    4:  		/* mr R26, R3 */
		/* 820EDA08h case    4:*/		regs.R26 = regs.R3;
		/* 820EDA08h case    4:*/		return 0x820EDA0C;
		  /* 820EDA0Ch */ case    5:  		/* mr R25, R5 */
		/* 820EDA0Ch case    5:*/		regs.R25 = regs.R5;
		/* 820EDA0Ch case    5:*/		return 0x820EDA10;
		  /* 820EDA10h */ case    6:  		/* li R28, 0 */
		/* 820EDA10h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820EDA10h case    6:*/		return 0x820EDA14;
		  /* 820EDA14h */ case    7:  		/* li R29, 0 */
		/* 820EDA14h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820EDA14h case    7:*/		return 0x820EDA18;
		  /* 820EDA18h */ case    8:  		/* li R27, 0 */
		/* 820EDA18h case    8:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820EDA18h case    8:*/		return 0x820EDA1C;
		  /* 820EDA1Ch */ case    9:  		/* cmplwi CR6, R30, 0 */
		/* 820EDA1Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820EDA1Ch case    9:*/		return 0x820EDA20;
		  /* 820EDA20h */ case   10:  		/* bc 12, CR6_EQ, 220 */
		/* 820EDA20h case   10:*/		if ( regs.CR[6].eq ) { return 0x820EDAFC;  }
		/* 820EDA20h case   10:*/		return 0x820EDA24;
		  /* 820EDA24h */ case   11:  		/* lwz R10, <#[R30 + 8]> */
		/* 820EDA24h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 820EDA24h case   11:*/		return 0x820EDA28;
		  /* 820EDA28h */ case   12:  		/* lwz R11, <#[R10 + 4]> */
		/* 820EDA28h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820EDA28h case   12:*/		return 0x820EDA2C;
		  /* 820EDA2Ch */ case   13:  		/* cmpwi CR6, R11, 18 */
		/* 820EDA2Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000012);
		/* 820EDA2Ch case   13:*/		return 0x820EDA30;
		  /* 820EDA30h */ case   14:  		/* bc 4, CR6_EQ, 184 */
		/* 820EDA30h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820EDAE8;  }
		/* 820EDA30h case   14:*/		return 0x820EDA34;
		  /* 820EDA34h */ case   15:  		/* lwz R11, <#[R10 + 16]> */
		/* 820EDA34h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820EDA34h case   15:*/		return 0x820EDA38;
		  /* 820EDA38h */ case   16:  		/* li R3, 0 */
		/* 820EDA38h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EDA38h case   16:*/		return 0x820EDA3C;
		  /* 820EDA3Ch */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 820EDA3Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EDA3Ch case   17:*/		return 0x820EDA40;
		  /* 820EDA40h */ case   18:  		/* bc 12, CR6_EQ, 8 */
		/* 820EDA40h case   18:*/		if ( regs.CR[6].eq ) { return 0x820EDA48;  }
		/* 820EDA40h case   18:*/		return 0x820EDA44;
		  /* 820EDA44h */ case   19:  		/* lwz R3, <#[R11 + 24]> */
		/* 820EDA44h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000018) );
		/* 820EDA44h case   19:*/		return 0x820EDA48;
	}
	return 0x820EDA48;
} // Block from 820ED9F8h-820EDA48h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820EDA48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDA48);
		  /* 820EDA48h */ case    0:  		/* lwz R11, <#[R10 + 20]> */
		/* 820EDA48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 820EDA48h case    0:*/		return 0x820EDA4C;
		  /* 820EDA4Ch */ case    1:  		/* li R31, 0 */
		/* 820EDA4Ch case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820EDA4Ch case    1:*/		return 0x820EDA50;
		  /* 820EDA50h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820EDA50h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EDA50h case    2:*/		return 0x820EDA54;
		  /* 820EDA54h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 820EDA54h case    3:*/		if ( regs.CR[6].eq ) { return 0x820EDA5C;  }
		/* 820EDA54h case    3:*/		return 0x820EDA58;
		  /* 820EDA58h */ case    4:  		/* lwz R31, <#[R11 + 24]> */
		/* 820EDA58h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000018) );
		/* 820EDA58h case    4:*/		return 0x820EDA5C;
	}
	return 0x820EDA5C;
} // Block from 820EDA48h-820EDA5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EDA5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDA5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDA5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDA5C);
		  /* 820EDA5Ch */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820EDA5Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820EDA5Ch case    0:*/		return 0x820EDA60;
		  /* 820EDA60h */ case    1:  		/* bc 12, CR6_EQ, 104 */
		/* 820EDA60h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EDAC8;  }
		/* 820EDA60h case    1:*/		return 0x820EDA64;
		  /* 820EDA64h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 820EDA64h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820EDA64h case    2:*/		return 0x820EDA68;
		  /* 820EDA68h */ case    3:  		/* bc 12, CR6_EQ, 128 */
		/* 820EDA68h case    3:*/		if ( regs.CR[6].eq ) { return 0x820EDAE8;  }
		/* 820EDA68h case    3:*/		return 0x820EDA6C;
		  /* 820EDA6Ch */ case    4:  		/* addi R5, R1, 80 */
		/* 820EDA6Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820EDA6Ch case    4:*/		return 0x820EDA70;
		  /* 820EDA70h */ case    5:  		/* li R4, 0 */
		/* 820EDA70h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820EDA70h case    5:*/		return 0x820EDA74;
		  /* 820EDA74h */ case    6:  		/* bl -322788 */
		/* 820EDA74h case    6:*/		regs.LR = 0x820EDA78; return 0x8209ED90;
		/* 820EDA74h case    6:*/		return 0x820EDA78;
		  /* 820EDA78h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820EDA78h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EDA78h case    7:*/		return 0x820EDA7C;
		  /* 820EDA7Ch */ case    8:  		/* bc 12, CR0_LT, 108 */
		/* 820EDA7Ch case    8:*/		if ( regs.CR[0].lt ) { return 0x820EDAE8;  }
		/* 820EDA7Ch case    8:*/		return 0x820EDA80;
		  /* 820EDA80h */ case    9:  		/* lbz R11, <#[R31]> */
		/* 820EDA80h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EDA80h case    9:*/		return 0x820EDA84;
		  /* 820EDA84h */ case   10:  		/* extsb R3, R11 */
		/* 820EDA84h case   10:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820EDA84h case   10:*/		return 0x820EDA88;
		  /* 820EDA88h */ case   11:  		/* bl -344824 */
		/* 820EDA88h case   11:*/		regs.LR = 0x820EDA8C; return 0x82099790;
		/* 820EDA88h case   11:*/		return 0x820EDA8C;
		  /* 820EDA8Ch */ case   12:  		/* cmpwi CR6, R3, 99 */
		/* 820EDA8Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000063);
		/* 820EDA8Ch case   12:*/		return 0x820EDA90;
		  /* 820EDA90h */ case   13:  		/* bc 4, CR6_EQ, 88 */
		/* 820EDA90h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820EDAE8;  }
		/* 820EDA90h case   13:*/		return 0x820EDA94;
		  /* 820EDA94h */ case   14:  		/* lwz R11, <#[R26 + 200]> */
		/* 820EDA94h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x000000C8) );
		/* 820EDA94h case   14:*/		return 0x820EDA98;
		  /* 820EDA98h */ case   15:  		/* lwz R10, <#[R1 + 84]> */
		/* 820EDA98h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 820EDA98h case   15:*/		return 0x820EDA9C;
		  /* 820EDA9Ch */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820EDA9Ch case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EDA9Ch case   16:*/		return 0x820EDAA0;
		  /* 820EDAA0h */ case   17:  		/* bc 4, CR6_EQ, 12 */
		/* 820EDAA0h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820EDAAC;  }
		/* 820EDAA0h case   17:*/		return 0x820EDAA4;
		  /* 820EDAA4h */ case   18:  		/* mr R28, R31 */
		/* 820EDAA4h case   18:*/		regs.R28 = regs.R31;
		/* 820EDAA4h case   18:*/		return 0x820EDAA8;
		  /* 820EDAA8h */ case   19:  		/* b 64 */
		/* 820EDAA8h case   19:*/		return 0x820EDAE8;
		/* 820EDAA8h case   19:*/		return 0x820EDAAC;
	}
	return 0x820EDAAC;
} // Block from 820EDA5Ch-820EDAACh (20 instructions)

//////////////////////////////////////////////////////
// Block at 820EDAACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDAAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDAAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDAAC);
		  /* 820EDAACh */ case    0:  		/* xor R11, R11, R10 */
		/* 820EDAACh case    0:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820EDAACh case    0:*/		return 0x820EDAB0;
		  /* 820EDAB0h */ case    1:  		/* rlwinm. R11, R11, 0, 0, 15 */
		/* 820EDAB0h case    1:*/		cpu::op::rlwinm<1,0,0,15>(regs,&regs.R11,regs.R11);
		/* 820EDAB0h case    1:*/		return 0x820EDAB4;
		  /* 820EDAB4h */ case    2:  		/* bc 4, CR0_EQ, 52 */
		/* 820EDAB4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820EDAE8;  }
		/* 820EDAB4h case    2:*/		return 0x820EDAB8;
		  /* 820EDAB8h */ case    3:  		/* rlwinm. R11, R10, 0, 16, 31 */
		/* 820EDAB8h case    3:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R11,regs.R10);
		/* 820EDAB8h case    3:*/		return 0x820EDABC;
		  /* 820EDABCh */ case    4:  		/* bc 4, CR0_EQ, 44 */
		/* 820EDABCh case    4:*/		if ( !regs.CR[0].eq ) { return 0x820EDAE8;  }
		/* 820EDABCh case    4:*/		return 0x820EDAC0;
		  /* 820EDAC0h */ case    5:  		/* mr R29, R31 */
		/* 820EDAC0h case    5:*/		regs.R29 = regs.R31;
		/* 820EDAC0h case    5:*/		return 0x820EDAC4;
		  /* 820EDAC4h */ case    6:  		/* b 36 */
		/* 820EDAC4h case    6:*/		return 0x820EDAE8;
		/* 820EDAC4h case    6:*/		return 0x820EDAC8;
	}
	return 0x820EDAC8;
} // Block from 820EDAACh-820EDAC8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EDAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDAC8);
		  /* 820EDAC8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820EDAC8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820EDAC8h case    0:*/		return 0x820EDACC;
		  /* 820EDACCh */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820EDACCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820EDAE8;  }
		/* 820EDACCh case    1:*/		return 0x820EDAD0;
		  /* 820EDAD0h */ case    2:  		/* lbz R11, <#[R31]> */
		/* 820EDAD0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EDAD0h case    2:*/		return 0x820EDAD4;
		  /* 820EDAD4h */ case    3:  		/* extsb R3, R11 */
		/* 820EDAD4h case    3:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820EDAD4h case    3:*/		return 0x820EDAD8;
		  /* 820EDAD8h */ case    4:  		/* bl -344904 */
		/* 820EDAD8h case    4:*/		regs.LR = 0x820EDADC; return 0x82099790;
		/* 820EDAD8h case    4:*/		return 0x820EDADC;
		  /* 820EDADCh */ case    5:  		/* cmpwi CR6, R3, 99 */
		/* 820EDADCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000063);
		/* 820EDADCh case    5:*/		return 0x820EDAE0;
		  /* 820EDAE0h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 820EDAE0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820EDAE8;  }
		/* 820EDAE0h case    6:*/		return 0x820EDAE4;
		  /* 820EDAE4h */ case    7:  		/* mr R27, R31 */
		/* 820EDAE4h case    7:*/		regs.R27 = regs.R31;
		/* 820EDAE4h case    7:*/		return 0x820EDAE8;
	}
	return 0x820EDAE8;
} // Block from 820EDAC8h-820EDAE8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EDAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDAE8);
		  /* 820EDAE8h */ case    0:  		/* lwz R30, <#[R30 + 12]> */
		/* 820EDAE8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x0000000C) );
		/* 820EDAE8h case    0:*/		return 0x820EDAEC;
		  /* 820EDAECh */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 820EDAECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820EDAECh case    1:*/		return 0x820EDAF0;
		  /* 820EDAF0h */ case    2:  		/* bc 4, CR6_EQ, -204 */
		/* 820EDAF0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820EDA24;  }
		/* 820EDAF0h case    2:*/		return 0x820EDAF4;
		  /* 820EDAF4h */ case    3:  		/* cmplwi CR6, R28, 0 */
		/* 820EDAF4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EDAF4h case    3:*/		return 0x820EDAF8;
		  /* 820EDAF8h */ case    4:  		/* bc 4, CR6_EQ, 28 */
		/* 820EDAF8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820EDB14;  }
		/* 820EDAF8h case    4:*/		return 0x820EDAFC;
	}
	return 0x820EDAFC;
} // Block from 820EDAE8h-820EDAFCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EDAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDAFC);
		  /* 820EDAFCh */ case    0:  		/* mr R28, R29 */
		/* 820EDAFCh case    0:*/		regs.R28 = regs.R29;
		/* 820EDAFCh case    0:*/		return 0x820EDB00;
		  /* 820EDB00h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 820EDB00h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820EDB00h case    1:*/		return 0x820EDB04;
		  /* 820EDB04h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820EDB04h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820EDB14;  }
		/* 820EDB04h case    2:*/		return 0x820EDB08;
		  /* 820EDB08h */ case    3:  		/* mr R28, R27 */
		/* 820EDB08h case    3:*/		regs.R28 = regs.R27;
		/* 820EDB08h case    3:*/		return 0x820EDB0C;
		  /* 820EDB0Ch */ case    4:  		/* cmplwi CR6, R27, 0 */
		/* 820EDB0Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820EDB0Ch case    4:*/		return 0x820EDB10;
		  /* 820EDB10h */ case    5:  		/* bc 12, CR6_EQ, 200 */
		/* 820EDB10h case    5:*/		if ( regs.CR[6].eq ) { return 0x820EDBD8;  }
		/* 820EDB10h case    5:*/		return 0x820EDB14;
	}
	return 0x820EDB14;
} // Block from 820EDAFCh-820EDB14h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EDB14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDB14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDB14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDB14);
		  /* 820EDB14h */ case    0:  		/* lwz R11, <#[R26 + 348]> */
		/* 820EDB14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000015C) );
		/* 820EDB14h case    0:*/		return 0x820EDB18;
		  /* 820EDB18h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820EDB18h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820EDB18h case    1:*/		return 0x820EDB1C;
		  /* 820EDB1Ch */ case    2:  		/* bc 12, CR6_EQ, 176 */
		/* 820EDB1Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820EDBCC;  }
		/* 820EDB1Ch case    2:*/		return 0x820EDB20;
		  /* 820EDB20h */ case    3:  		/* lbz R11, <#[R28]> */
		/* 820EDB20h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820EDB20h case    3:*/		return 0x820EDB24;
		  /* 820EDB24h */ case    4:  		/* extsb R3, R11 */
		/* 820EDB24h case    4:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820EDB24h case    4:*/		return 0x820EDB28;
		  /* 820EDB28h */ case    5:  		/* bl -344984 */
		/* 820EDB28h case    5:*/		regs.LR = 0x820EDB2C; return 0x82099790;
		/* 820EDB28h case    5:*/		return 0x820EDB2C;
		  /* 820EDB2Ch */ case    6:  		/* cmpwi CR6, R3, 99 */
		/* 820EDB2Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000063);
		/* 820EDB2Ch case    6:*/		return 0x820EDB30;
		  /* 820EDB30h */ case    7:  		/* bc 4, CR6_EQ, 168 */
		/* 820EDB30h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820EDBD8;  }
		/* 820EDB30h case    7:*/		return 0x820EDB34;
		  /* 820EDB34h */ case    8:  		/* lbz R11, <#[R28 + 1]> */
		/* 820EDB34h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000001) );
		/* 820EDB34h case    8:*/		return 0x820EDB38;
		  /* 820EDB38h */ case    9:  		/* addi R29, R28, 1 */
		/* 820EDB38h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R28,0x1);
		/* 820EDB38h case    9:*/		return 0x820EDB3C;
		  /* 820EDB3Ch */ case   10:  		/* extsb R3, R11 */
		/* 820EDB3Ch case   10:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820EDB3Ch case   10:*/		return 0x820EDB40;
		  /* 820EDB40h */ case   11:  		/* bl -345136 */
		/* 820EDB40h case   11:*/		regs.LR = 0x820EDB44; return 0x82099710;
		/* 820EDB40h case   11:*/		return 0x820EDB44;
		  /* 820EDB44h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820EDB44h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EDB44h case   12:*/		return 0x820EDB48;
		  /* 820EDB48h */ case   13:  		/* bc 12, CR0_EQ, 144 */
		/* 820EDB48h case   13:*/		if ( regs.CR[0].eq ) { return 0x820EDBD8;  }
		/* 820EDB48h case   13:*/		return 0x820EDB4C;
		  /* 820EDB4Ch */ case   14:  		/* addi R31, R28, 2 */
		/* 820EDB4Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R28,0x2);
		/* 820EDB4Ch case   14:*/		return 0x820EDB50;
		  /* 820EDB50h */ case   15:  		/* lbz R11, <#[R28 + 2]> */
		/* 820EDB50h case   15:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000002) );
		/* 820EDB50h case   15:*/		return 0x820EDB54;
		  /* 820EDB54h */ case   16:  		/* mr R30, R31 */
		/* 820EDB54h case   16:*/		regs.R30 = regs.R31;
		/* 820EDB54h case   16:*/		return 0x820EDB58;
		  /* 820EDB58h */ case   17:  		/* b 8 */
		/* 820EDB58h case   17:*/		return 0x820EDB60;
		/* 820EDB58h case   17:*/		return 0x820EDB5C;
		  /* 820EDB5Ch */ case   18:  		/* lbzu R11, <#[R30 + 1]> */
		/* 820EDB5Ch case   18:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820EDB5Ch case   18:*/		return 0x820EDB60;
	}
	return 0x820EDB60;
} // Block from 820EDB14h-820EDB60h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820EDB60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDB60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDB60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDB60);
		  /* 820EDB60h */ case    0:  		/* extsb R3, R11 */
		/* 820EDB60h case    0:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820EDB60h case    0:*/		return 0x820EDB64;
		  /* 820EDB64h */ case    1:  		/* bl -345172 */
		/* 820EDB64h case    1:*/		regs.LR = 0x820EDB68; return 0x82099710;
		/* 820EDB64h case    1:*/		return 0x820EDB68;
		  /* 820EDB68h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820EDB68h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EDB68h case    2:*/		return 0x820EDB6C;
		  /* 820EDB6Ch */ case    3:  		/* bc 4, CR0_EQ, -16 */
		/* 820EDB6Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x820EDB5C;  }
		/* 820EDB6Ch case    3:*/		return 0x820EDB70;
		  /* 820EDB70h */ case    4:  		/* lbz R11, <#[R30]> */
		/* 820EDB70h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820EDB70h case    4:*/		return 0x820EDB74;
		  /* 820EDB74h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 820EDB74h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820EDB74h case    5:*/		return 0x820EDB78;
		  /* 820EDB78h */ case    6:  		/* bc 4, CR0_EQ, 96 */
		/* 820EDB78h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820EDBD8;  }
		/* 820EDB78h case    6:*/		return 0x820EDB7C;
		  /* 820EDB7Ch */ case    7:  		/* mr R3, R29 */
		/* 820EDB7Ch case    7:*/		regs.R3 = regs.R29;
		/* 820EDB7Ch case    7:*/		return 0x820EDB80;
		  /* 820EDB80h */ case    8:  		/* bl -372760 */
		/* 820EDB80h case    8:*/		regs.LR = 0x820EDB84; return 0x82092B68;
		/* 820EDB80h case    8:*/		return 0x820EDB84;
		  /* 820EDB84h */ case    9:  		/* mr R8, R3 */
		/* 820EDB84h case    9:*/		regs.R8 = regs.R3;
		/* 820EDB84h case    9:*/		return 0x820EDB88;
		  /* 820EDB88h */ case   10:  		/* cmplwi CR6, R3, 8191 */
		/* 820EDB88h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00001FFF);
		/* 820EDB88h case   10:*/		return 0x820EDB8C;
		  /* 820EDB8Ch */ case   11:  		/* bc 4, CR6_GT, 44 */
		/* 820EDB8Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x820EDBB8;  }
		/* 820EDB8Ch case   11:*/		return 0x820EDB90;
		  /* 820EDB90h */ case   12:  		/* lis R11, -32255 */
		/* 820EDB90h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820EDB90h case   12:*/		return 0x820EDB94;
		  /* 820EDB94h */ case   13:  		/* mr R7, R31 */
		/* 820EDB94h case   13:*/		regs.R7 = regs.R31;
		/* 820EDB94h case   13:*/		return 0x820EDB98;
		  /* 820EDB98h */ case   14:  		/* addi R6, R11, 11480 */
		/* 820EDB98h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2CD8);
		/* 820EDB98h case   14:*/		return 0x820EDB9C;
		  /* 820EDB9Ch */ case   15:  		/* li R5, 0 */
		/* 820EDB9Ch case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EDB9Ch case   15:*/		return 0x820EDBA0;
		  /* 820EDBA0h */ case   16:  		/* li R4, 0 */
		/* 820EDBA0h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820EDBA0h case   16:*/		return 0x820EDBA4;
		  /* 820EDBA4h */ case   17:  		/* mr R3, R26 */
		/* 820EDBA4h case   17:*/		regs.R3 = regs.R26;
		/* 820EDBA4h case   17:*/		return 0x820EDBA8;
		  /* 820EDBA8h */ case   18:  		/* bl 134024 */
		/* 820EDBA8h case   18:*/		regs.LR = 0x820EDBAC; return 0x8210E730;
		/* 820EDBA8h case   18:*/		return 0x820EDBAC;
		  /* 820EDBACh */ case   19:  		/* lis R3, -32768 */
		/* 820EDBACh case   19:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820EDBACh case   19:*/		return 0x820EDBB0;
		  /* 820EDBB0h */ case   20:  		/* ori R3, R3, 16389 */
		/* 820EDBB0h case   20:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820EDBB0h case   20:*/		return 0x820EDBB4;
		  /* 820EDBB4h */ case   21:  		/* b 40 */
		/* 820EDBB4h case   21:*/		return 0x820EDBDC;
		/* 820EDBB4h case   21:*/		return 0x820EDBB8;
	}
	return 0x820EDBB8;
} // Block from 820EDB60h-820EDBB8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820EDBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDBB8);
		  /* 820EDBB8h */ case    0:  		/* lhz R11, <#[R25 + 10]> */
		/* 820EDBB8h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000A) );
		/* 820EDBB8h case    0:*/		return 0x820EDBBC;
		  /* 820EDBBCh */ case    1:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 820EDBBCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 820EDBBCh case    1:*/		return 0x820EDBC0;
		  /* 820EDBC0h */ case    2:  		/* or R11, R10, R11 */
		/* 820EDBC0h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820EDBC0h case    2:*/		return 0x820EDBC4;
		  /* 820EDBC4h */ case    3:  		/* ori R11, R11, 2 */
		/* 820EDBC4h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820EDBC4h case    3:*/		return 0x820EDBC8;
		  /* 820EDBC8h */ case    4:  		/* b 12 */
		/* 820EDBC8h case    4:*/		return 0x820EDBD4;
		/* 820EDBC8h case    4:*/		return 0x820EDBCC;
	}
	return 0x820EDBCC;
} // Block from 820EDBB8h-820EDBCCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EDBCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDBCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDBCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDBCC);
		  /* 820EDBCCh */ case    0:  		/* lhz R11, <#[R25 + 10]> */
		/* 820EDBCCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000A) );
		/* 820EDBCCh case    0:*/		return 0x820EDBD0;
		  /* 820EDBD0h */ case    1:  		/* ori R11, R11, 2 */
		/* 820EDBD0h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820EDBD0h case    1:*/		return 0x820EDBD4;
	}
	return 0x820EDBD4;
} // Block from 820EDBCCh-820EDBD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EDBD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDBD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDBD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDBD4);
		  /* 820EDBD4h */ case    0:  		/* sth R11, <#[R25 + 10]> */
		/* 820EDBD4h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R25 + 0x0000000A) );
		/* 820EDBD4h case    0:*/		return 0x820EDBD8;
	}
	return 0x820EDBD8;
} // Block from 820EDBD4h-820EDBD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EDBD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDBD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDBD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDBD8);
		  /* 820EDBD8h */ case    0:  		/* li R3, 0 */
		/* 820EDBD8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EDBD8h case    0:*/		return 0x820EDBDC;
	}
	return 0x820EDBDC;
} // Block from 820EDBD8h-820EDBDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EDBDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDBDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDBDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDBDC);
		  /* 820EDBDCh */ case    0:  		/* addi R1, R1, 160 */
		/* 820EDBDCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820EDBDCh case    0:*/		return 0x820EDBE0;
		  /* 820EDBE0h */ case    1:  		/* b -379204 */
		/* 820EDBE0h case    1:*/		return 0x8209129C;
		/* 820EDBE0h case    1:*/		return 0x820EDBE4;
		  /* 820EDBE4h */ case    2:  		/* nop */
		/* 820EDBE4h case    2:*/		cpu::op::nop();
		/* 820EDBE4h case    2:*/		return 0x820EDBE8;
		  /* 820EDBE8h */ case    3:  		/* b 16 */
		/* 820EDBE8h case    3:*/		return 0x820EDBF8;
		/* 820EDBE8h case    3:*/		return 0x820EDBEC;
		  /* 820EDBECh */ case    4:  		/* cmplw CR6, R11, R5 */
		/* 820EDBECh case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 820EDBECh case    4:*/		return 0x820EDBF0;
		  /* 820EDBF0h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820EDBF0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820EDC04;  }
		/* 820EDBF0h case    5:*/		return 0x820EDBF4;
		  /* 820EDBF4h */ case    6:  		/* addi R4, R4, 36 */
		/* 820EDBF4h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x24);
		/* 820EDBF4h case    6:*/		return 0x820EDBF8;
	}
	return 0x820EDBF8;
} // Block from 820EDBDCh-820EDBF8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EDBF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDBF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDBF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDBF8);
		  /* 820EDBF8h */ case    0:  		/* lwz R11, <#[R4 + 16]> */
		/* 820EDBF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 820EDBF8h case    0:*/		return 0x820EDBFC;
		  /* 820EDBFCh */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820EDBFCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EDBFCh case    1:*/		return 0x820EDC00;
		  /* 820EDC00h */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 820EDC00h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820EDBEC;  }
		/* 820EDC00h case    2:*/		return 0x820EDC04;
	}
	return 0x820EDC04;
} // Block from 820EDBF8h-820EDC04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EDC04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDC04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDC04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDC04);
		  /* 820EDC04h */ case    0:  		/* mr R3, R4 */
		/* 820EDC04h case    0:*/		regs.R3 = regs.R4;
		/* 820EDC04h case    0:*/		return 0x820EDC08;
		  /* 820EDC08h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820EDC08h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820EDC08h case    1:*/		return 0x820EDC0C;
	}
	return 0x820EDC0C;
} // Block from 820EDC04h-820EDC0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EDC0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDC0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDC0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDC0C);
		  /* 820EDC0Ch */ case    0:  		/* nop */
		/* 820EDC0Ch case    0:*/		cpu::op::nop();
		/* 820EDC0Ch case    0:*/		return 0x820EDC10;
	}
	return 0x820EDC10;
} // Block from 820EDC0Ch-820EDC10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EDC10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDC10);
		  /* 820EDC10h */ case    0:  		/* mfspr R12, LR */
		/* 820EDC10h case    0:*/		regs.R12 = regs.LR;
		/* 820EDC10h case    0:*/		return 0x820EDC14;
		  /* 820EDC14h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820EDC14h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820EDC14h case    1:*/		return 0x820EDC18;
		  /* 820EDC18h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820EDC18h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820EDC18h case    2:*/		return 0x820EDC1C;
		  /* 820EDC1Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820EDC1Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820EDC1Ch case    3:*/		return 0x820EDC20;
		  /* 820EDC20h */ case    4:  		/* mr R31, R3 */
		/* 820EDC20h case    4:*/		regs.R31 = regs.R3;
		/* 820EDC20h case    4:*/		return 0x820EDC24;
		  /* 820EDC24h */ case    5:  		/* bl 66604 */
		/* 820EDC24h case    5:*/		regs.LR = 0x820EDC28; return 0x820FE050;
		/* 820EDC24h case    5:*/		return 0x820EDC28;
		  /* 820EDC28h */ case    6:  		/* lis R11, -32254 */
		/* 820EDC28h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EDC28h case    6:*/		return 0x820EDC2C;
		  /* 820EDC2Ch */ case    7:  		/* addi R3, R31, 440 */
		/* 820EDC2Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x1B8);
		/* 820EDC2Ch case    7:*/		return 0x820EDC30;
		  /* 820EDC30h */ case    8:  		/* addi R11, R11, -17376 */
		/* 820EDC30h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFBC20);
		/* 820EDC30h case    8:*/		return 0x820EDC34;
		  /* 820EDC34h */ case    9:  		/* li R5, 28 */
		/* 820EDC34h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 820EDC34h case    9:*/		return 0x820EDC38;
		  /* 820EDC38h */ case   10:  		/* li R4, 0 */
		/* 820EDC38h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820EDC38h case   10:*/		return 0x820EDC3C;
		  /* 820EDC3Ch */ case   11:  		/* stw R11, <#[R31]> */
		/* 820EDC3Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EDC3Ch case   11:*/		return 0x820EDC40;
		  /* 820EDC40h */ case   12:  		/* bl -379136 */
		/* 820EDC40h case   12:*/		regs.LR = 0x820EDC44; return 0x82091340;
		/* 820EDC40h case   12:*/		return 0x820EDC44;
		  /* 820EDC44h */ case   13:  		/* addi R3, R31, 472 */
		/* 820EDC44h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x1D8);
		/* 820EDC44h case   13:*/		return 0x820EDC48;
		  /* 820EDC48h */ case   14:  		/* li R5, 28 */
		/* 820EDC48h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 820EDC48h case   14:*/		return 0x820EDC4C;
		  /* 820EDC4Ch */ case   15:  		/* li R4, 0 */
		/* 820EDC4Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820EDC4Ch case   15:*/		return 0x820EDC50;
		  /* 820EDC50h */ case   16:  		/* bl -379152 */
		/* 820EDC50h case   16:*/		regs.LR = 0x820EDC54; return 0x82091340;
		/* 820EDC50h case   16:*/		return 0x820EDC54;
		  /* 820EDC54h */ case   17:  		/* li R11, 0 */
		/* 820EDC54h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820EDC54h case   17:*/		return 0x820EDC58;
		  /* 820EDC58h */ case   18:  		/* li R10, -1 */
		/* 820EDC58h case   18:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820EDC58h case   18:*/		return 0x820EDC5C;
		  /* 820EDC5Ch */ case   19:  		/* li R9, -1 */
		/* 820EDC5Ch case   19:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 820EDC5Ch case   19:*/		return 0x820EDC60;
		  /* 820EDC60h */ case   20:  		/* stw R11, <#[R31 + 256]> */
		/* 820EDC60h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000100) );
		/* 820EDC60h case   20:*/		return 0x820EDC64;
		  /* 820EDC64h */ case   21:  		/* lis R8, 0 */
		/* 820EDC64h case   21:*/		cpu::op::lis<0>(regs,&regs.R8,0x0);
		/* 820EDC64h case   21:*/		return 0x820EDC68;
	}
	return 0x820EDC68;
} // Block from 820EDC10h-820EDC68h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820EDC68h
// Function '?FindObjectDims@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDC68);
		  /* 820EDC68h */ case    0:  		/* stw R11, <#[R31 + 260]> */
		/* 820EDC68h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820EDC68h case    0:*/		return 0x820EDC6C;
		  /* 820EDC6Ch */ case    1:  		/* stw R11, <#[R31 + 264]> */
		/* 820EDC6Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000108) );
		/* 820EDC6Ch case    1:*/		return 0x820EDC70;
		  /* 820EDC70h */ case    2:  		/* lis R7, -1 */
		/* 820EDC70h case    2:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 820EDC70h case    2:*/		return 0x820EDC74;
		  /* 820EDC74h */ case    3:  		/* stw R10, <#[R31 + 356]> */
		/* 820EDC74h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000164) );
		/* 820EDC74h case    3:*/		return 0x820EDC78;
		  /* 820EDC78h */ case    4:  		/* li R6, 16 */
		/* 820EDC78h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x10);
		/* 820EDC78h case    4:*/		return 0x820EDC7C;
		  /* 820EDC7Ch */ case    5:  		/* stw R9, <#[R31 + 360]> */
		/* 820EDC7Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000168) );
		/* 820EDC7Ch case    5:*/		return 0x820EDC80;
		  /* 820EDC80h */ case    6:  		/* ori R8, R8, 65535 */
		/* 820EDC80h case    6:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0xFFFF);
		/* 820EDC80h case    6:*/		return 0x820EDC84;
		  /* 820EDC84h */ case    7:  		/* stw R9, <#[R31 + 364]> */
		/* 820EDC84h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000016C) );
		/* 820EDC84h case    7:*/		return 0x820EDC88;
		  /* 820EDC88h */ case    8:  		/* mr R3, R31 */
		/* 820EDC88h case    8:*/		regs.R3 = regs.R31;
		/* 820EDC88h case    8:*/		return 0x820EDC8C;
		  /* 820EDC8Ch */ case    9:  		/* stw R9, <#[R31 + 368]> */
		/* 820EDC8Ch case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000170) );
		/* 820EDC8Ch case    9:*/		return 0x820EDC90;
		  /* 820EDC90h */ case   10:  		/* stw R11, <#[R31 + 272]> */
		/* 820EDC90h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000110) );
		/* 820EDC90h case   10:*/		return 0x820EDC94;
		  /* 820EDC94h */ case   11:  		/* stw R11, <#[R31 + 276]> */
		/* 820EDC94h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820EDC94h case   11:*/		return 0x820EDC98;
		  /* 820EDC98h */ case   12:  		/* stw R11, <#[R31 + 280]> */
		/* 820EDC98h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000118) );
		/* 820EDC98h case   12:*/		return 0x820EDC9C;
		  /* 820EDC9Ch */ case   13:  		/* stw R11, <#[R31 + 296]> */
		/* 820EDC9Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000128) );
		/* 820EDC9Ch case   13:*/		return 0x820EDCA0;
		  /* 820EDCA0h */ case   14:  		/* stw R11, <#[R31 + 300]> */
		/* 820EDCA0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000012C) );
		/* 820EDCA0h case   14:*/		return 0x820EDCA4;
		  /* 820EDCA4h */ case   15:  		/* stw R11, <#[R31 + 304]> */
		/* 820EDCA4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000130) );
		/* 820EDCA4h case   15:*/		return 0x820EDCA8;
		  /* 820EDCA8h */ case   16:  		/* stw R11, <#[R31 + 308]> */
		/* 820EDCA8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000134) );
		/* 820EDCA8h case   16:*/		return 0x820EDCAC;
		  /* 820EDCACh */ case   17:  		/* stw R11, <#[R31 + 312]> */
		/* 820EDCACh case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000138) );
		/* 820EDCACh case   17:*/		return 0x820EDCB0;
		  /* 820EDCB0h */ case   18:  		/* stw R11, <#[R31 + 268]> */
		/* 820EDCB0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000010C) );
		/* 820EDCB0h case   18:*/		return 0x820EDCB4;
		  /* 820EDCB4h */ case   19:  		/* stw R11, <#[R31 + 436]> */
		/* 820EDCB4h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000001B4) );
		/* 820EDCB4h case   19:*/		return 0x820EDCB8;
		  /* 820EDCB8h */ case   20:  		/* stw R11, <#[R31 + 348]> */
		/* 820EDCB8h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000015C) );
		/* 820EDCB8h case   20:*/		return 0x820EDCBC;
		  /* 820EDCBCh */ case   21:  		/* stw R11, <#[R31 + 500]> */
		/* 820EDCBCh case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000001F4) );
		/* 820EDCBCh case   21:*/		return 0x820EDCC0;
		  /* 820EDCC0h */ case   22:  		/* stw R11, <#[R31 + 468]> */
		/* 820EDCC0h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000001D4) );
		/* 820EDCC0h case   22:*/		return 0x820EDCC4;
		  /* 820EDCC4h */ case   23:  		/* stw R11, <#[R31 + 504]> */
		/* 820EDCC4h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000001F8) );
		/* 820EDCC4h case   23:*/		return 0x820EDCC8;
		  /* 820EDCC8h */ case   24:  		/* stw R7, <#[R31 + 236]> */
		/* 820EDCC8h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x000000EC) );
		/* 820EDCC8h case   24:*/		return 0x820EDCCC;
		  /* 820EDCCCh */ case   25:  		/* stw R6, <#[R31 + 240]> */
		/* 820EDCCCh case   25:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x000000F0) );
		/* 820EDCCCh case   25:*/		return 0x820EDCD0;
		  /* 820EDCD0h */ case   26:  		/* stw R8, <#[R31 + 232]> */
		/* 820EDCD0h case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x000000E8) );
		/* 820EDCD0h case   26:*/		return 0x820EDCD4;
		  /* 820EDCD4h */ case   27:  		/* stw R10, <#[R31 + 396]> */
		/* 820EDCD4h case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000018C) );
		/* 820EDCD4h case   27:*/		return 0x820EDCD8;
		  /* 820EDCD8h */ case   28:  		/* stw R11, <#[R31 + 252]> */
		/* 820EDCD8h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000FC) );
		/* 820EDCD8h case   28:*/		return 0x820EDCDC;
		  /* 820EDCDCh */ case   29:  		/* stw R11, <#[R31 + 244]> */
		/* 820EDCDCh case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000F4) );
		/* 820EDCDCh case   29:*/		return 0x820EDCE0;
		  /* 820EDCE0h */ case   30:  		/* stw R11, <#[R31 + 248]> */
		/* 820EDCE0h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000F8) );
		/* 820EDCE0h case   30:*/		return 0x820EDCE4;
		  /* 820EDCE4h */ case   31:  		/* stw R11, <#[R31 + 400]> */
		/* 820EDCE4h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000190) );
		/* 820EDCE4h case   31:*/		return 0x820EDCE8;
		  /* 820EDCE8h */ case   32:  		/* addi R1, R1, 96 */
		/* 820EDCE8h case   32:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820EDCE8h case   32:*/		return 0x820EDCEC;
		  /* 820EDCECh */ case   33:  		/* lwz R12, <#[R1 - 8]> */
		/* 820EDCECh case   33:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820EDCECh case   33:*/		return 0x820EDCF0;
		  /* 820EDCF0h */ case   34:  		/* mtspr LR, R12 */
		/* 820EDCF0h case   34:*/		regs.LR = regs.R12;
		/* 820EDCF0h case   34:*/		return 0x820EDCF4;
		  /* 820EDCF4h */ case   35:  		/* ld R31, <#[R1 - 16]> */
		/* 820EDCF4h case   35:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820EDCF4h case   35:*/		return 0x820EDCF8;
		  /* 820EDCF8h */ case   36:  		/* bclr 20, CR0_LT */
		/* 820EDCF8h case   36:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820EDCF8h case   36:*/		return 0x820EDCFC;
	}
	return 0x820EDCFC;
} // Block from 820EDC68h-820EDCFCh (37 instructions)

//////////////////////////////////////////////////////
// Block at 820EDCFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDCFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDCFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDCFC);
		  /* 820EDCFCh */ case    0:  		/* nop */
		/* 820EDCFCh case    0:*/		cpu::op::nop();
		/* 820EDCFCh case    0:*/		return 0x820EDD00;
	}
	return 0x820EDD00;
} // Block from 820EDCFCh-820EDD00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EDD00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDD00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDD00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDD00);
		  /* 820EDD00h */ case    0:  		/* mfspr R12, LR */
		/* 820EDD00h case    0:*/		regs.R12 = regs.LR;
		/* 820EDD00h case    0:*/		return 0x820EDD04;
		  /* 820EDD04h */ case    1:  		/* bl -379564 */
		/* 820EDD04h case    1:*/		regs.LR = 0x820EDD08; return 0x82091258;
		/* 820EDD04h case    1:*/		return 0x820EDD08;
		  /* 820EDD08h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820EDD08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820EDD08h case    2:*/		return 0x820EDD0C;
		  /* 820EDD0Ch */ case    3:  		/* mr R31, R3 */
		/* 820EDD0Ch case    3:*/		regs.R31 = regs.R3;
		/* 820EDD0Ch case    3:*/		return 0x820EDD10;
		  /* 820EDD10h */ case    4:  		/* lwz R3, <#[R3 + 272]> */
		/* 820EDD10h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000110) );
		/* 820EDD10h case    4:*/		return 0x820EDD14;
		  /* 820EDD14h */ case    5:  		/* lis R11, -32254 */
		/* 820EDD14h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EDD14h case    5:*/		return 0x820EDD18;
		  /* 820EDD18h */ case    6:  		/* lis R4, 9345 */
		/* 820EDD18h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820EDD18h case    6:*/		return 0x820EDD1C;
		  /* 820EDD1Ch */ case    7:  		/* addi R11, R11, -17376 */
		/* 820EDD1Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFBC20);
		/* 820EDD1Ch case    7:*/		return 0x820EDD20;
		  /* 820EDD20h */ case    8:  		/* stw R11, <#[R31]> */
		/* 820EDD20h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EDD20h case    8:*/		return 0x820EDD24;
		  /* 820EDD24h */ case    9:  		/* bl -416236 */
		/* 820EDD24h case    9:*/		regs.LR = 0x820EDD28; return 0x82088338;
		/* 820EDD24h case    9:*/		return 0x820EDD28;
		  /* 820EDD28h */ case   10:  		/* lis R4, 9345 */
		/* 820EDD28h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820EDD28h case   10:*/		return 0x820EDD2C;
		  /* 820EDD2Ch */ case   11:  		/* lwz R3, <#[R31 + 296]> */
		/* 820EDD2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000128) );
		/* 820EDD2Ch case   11:*/		return 0x820EDD30;
		  /* 820EDD30h */ case   12:  		/* bl -416248 */
		/* 820EDD30h case   12:*/		regs.LR = 0x820EDD34; return 0x82088338;
		/* 820EDD30h case   12:*/		return 0x820EDD34;
		  /* 820EDD34h */ case   13:  		/* lwz R3, <#[R31 + 436]> */
		/* 820EDD34h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000001B4) );
		/* 820EDD34h case   13:*/		return 0x820EDD38;
		  /* 820EDD38h */ case   14:  		/* cmplwi CR6, R3, 0 */
		/* 820EDD38h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820EDD38h case   14:*/		return 0x820EDD3C;
		  /* 820EDD3Ch */ case   15:  		/* bc 12, CR6_EQ, 28 */
		/* 820EDD3Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820EDD58;  }
		/* 820EDD3Ch case   15:*/		return 0x820EDD40;
		  /* 820EDD40h */ case   16:  		/* lwz R11, <#[R3]> */
		/* 820EDD40h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820EDD40h case   16:*/		return 0x820EDD44;
		  /* 820EDD44h */ case   17:  		/* lwz R11, <#[R11 + 4]> */
		/* 820EDD44h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820EDD44h case   17:*/		return 0x820EDD48;
		  /* 820EDD48h */ case   18:  		/* mtspr CTR, R11 */
		/* 820EDD48h case   18:*/		regs.CTR = regs.R11;
		/* 820EDD48h case   18:*/		return 0x820EDD4C;
		  /* 820EDD4Ch */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 820EDD4Ch case   19:*/		if ( 1 ) { regs.LR = 0x820EDD50; return (uint32)regs.CTR; }
		/* 820EDD4Ch case   19:*/		return 0x820EDD50;
		  /* 820EDD50h */ case   20:  		/* li R11, 0 */
		/* 820EDD50h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820EDD50h case   20:*/		return 0x820EDD54;
		  /* 820EDD54h */ case   21:  		/* stw R11, <#[R31 + 436]> */
		/* 820EDD54h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000001B4) );
		/* 820EDD54h case   21:*/		return 0x820EDD58;
	}
	return 0x820EDD58;
} // Block from 820EDD00h-820EDD58h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820EDD58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDD58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDD58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDD58);
		  /* 820EDD58h */ case    0:  		/* addi R30, R31, 472 */
		/* 820EDD58h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x1D8);
		/* 820EDD58h case    0:*/		return 0x820EDD5C;
		  /* 820EDD5Ch */ case    1:  		/* li R29, 7 */
		/* 820EDD5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x7);
		/* 820EDD5Ch case    1:*/		return 0x820EDD60;
		  /* 820EDD60h */ case    2:  		/* lwz R28, <#[R30]> */
		/* 820EDD60h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 820EDD60h case    2:*/		return 0x820EDD64;
		  /* 820EDD64h */ case    3:  		/* cmplwi CR6, R28, 0 */
		/* 820EDD64h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EDD64h case    3:*/		return 0x820EDD68;
		  /* 820EDD68h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 820EDD68h case    4:*/		if ( regs.CR[6].eq ) { return 0x820EDD80;  }
		/* 820EDD68h case    4:*/		return 0x820EDD6C;
		  /* 820EDD6Ch */ case    5:  		/* mr R3, R28 */
		/* 820EDD6Ch case    5:*/		regs.R3 = regs.R28;
		/* 820EDD6Ch case    5:*/		return 0x820EDD70;
		  /* 820EDD70h */ case    6:  		/* bl -280648 */
		/* 820EDD70h case    6:*/		regs.LR = 0x820EDD74; return 0x820A9528;
		/* 820EDD70h case    6:*/		return 0x820EDD74;
		  /* 820EDD74h */ case    7:  		/* lis R4, 9345 */
		/* 820EDD74h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820EDD74h case    7:*/		return 0x820EDD78;
		  /* 820EDD78h */ case    8:  		/* mr R3, R28 */
		/* 820EDD78h case    8:*/		regs.R3 = regs.R28;
		/* 820EDD78h case    8:*/		return 0x820EDD7C;
		  /* 820EDD7Ch */ case    9:  		/* bl -416324 */
		/* 820EDD7Ch case    9:*/		regs.LR = 0x820EDD80; return 0x82088338;
		/* 820EDD7Ch case    9:*/		return 0x820EDD80;
	}
	return 0x820EDD80;
} // Block from 820EDD58h-820EDD80h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EDD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDD80);
		  /* 820EDD80h */ case    0:  		/* addic. R29, R29, -1 */
		/* 820EDD80h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820EDD80h case    0:*/		return 0x820EDD84;
		  /* 820EDD84h */ case    1:  		/* addi R30, R30, 4 */
		/* 820EDD84h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820EDD84h case    1:*/		return 0x820EDD88;
		  /* 820EDD88h */ case    2:  		/* bc 4, CR0_EQ, -40 */
		/* 820EDD88h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820EDD60;  }
		/* 820EDD88h case    2:*/		return 0x820EDD8C;
		  /* 820EDD8Ch */ case    3:  		/* addi R30, R31, 440 */
		/* 820EDD8Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x1B8);
		/* 820EDD8Ch case    3:*/		return 0x820EDD90;
		  /* 820EDD90h */ case    4:  		/* li R29, 7 */
		/* 820EDD90h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x7);
		/* 820EDD90h case    4:*/		return 0x820EDD94;
		  /* 820EDD94h */ case    5:  		/* lwz R28, <#[R30]> */
		/* 820EDD94h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 820EDD94h case    5:*/		return 0x820EDD98;
		  /* 820EDD98h */ case    6:  		/* cmplwi CR6, R28, 0 */
		/* 820EDD98h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EDD98h case    6:*/		return 0x820EDD9C;
		  /* 820EDD9Ch */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 820EDD9Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820EDDB4;  }
		/* 820EDD9Ch case    7:*/		return 0x820EDDA0;
		  /* 820EDDA0h */ case    8:  		/* mr R3, R28 */
		/* 820EDDA0h case    8:*/		regs.R3 = regs.R28;
		/* 820EDDA0h case    8:*/		return 0x820EDDA4;
		  /* 820EDDA4h */ case    9:  		/* bl -280700 */
		/* 820EDDA4h case    9:*/		regs.LR = 0x820EDDA8; return 0x820A9528;
		/* 820EDDA4h case    9:*/		return 0x820EDDA8;
		  /* 820EDDA8h */ case   10:  		/* lis R4, 9345 */
		/* 820EDDA8h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820EDDA8h case   10:*/		return 0x820EDDAC;
		  /* 820EDDACh */ case   11:  		/* mr R3, R28 */
		/* 820EDDACh case   11:*/		regs.R3 = regs.R28;
		/* 820EDDACh case   11:*/		return 0x820EDDB0;
		  /* 820EDDB0h */ case   12:  		/* bl -416376 */
		/* 820EDDB0h case   12:*/		regs.LR = 0x820EDDB4; return 0x82088338;
		/* 820EDDB0h case   12:*/		return 0x820EDDB4;
	}
	return 0x820EDDB4;
} // Block from 820EDD80h-820EDDB4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820EDDB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDDB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDDB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDDB4);
		  /* 820EDDB4h */ case    0:  		/* addic. R29, R29, -1 */
		/* 820EDDB4h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820EDDB4h case    0:*/		return 0x820EDDB8;
		  /* 820EDDB8h */ case    1:  		/* addi R30, R30, 4 */
		/* 820EDDB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820EDDB8h case    1:*/		return 0x820EDDBC;
		  /* 820EDDBCh */ case    2:  		/* bc 4, CR0_EQ, -40 */
		/* 820EDDBCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x820EDD94;  }
		/* 820EDDBCh case    2:*/		return 0x820EDDC0;
		  /* 820EDDC0h */ case    3:  		/* mr R3, R31 */
		/* 820EDDC0h case    3:*/		regs.R3 = regs.R31;
		/* 820EDDC0h case    3:*/		return 0x820EDDC4;
		  /* 820EDDC4h */ case    4:  		/* bl 81148 */
		/* 820EDDC4h case    4:*/		regs.LR = 0x820EDDC8; return 0x82101AC0;
		/* 820EDDC4h case    4:*/		return 0x820EDDC8;
		  /* 820EDDC8h */ case    5:  		/* addi R1, R1, 128 */
		/* 820EDDC8h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820EDDC8h case    5:*/		return 0x820EDDCC;
		  /* 820EDDCCh */ case    6:  		/* b -379684 */
		/* 820EDDCCh case    6:*/		return 0x820912A8;
		/* 820EDDCCh case    6:*/		return 0x820EDDD0;
	}
	return 0x820EDDD0;
} // Block from 820EDDB4h-820EDDD0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EDDD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDDD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDDD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDDD0);
		  /* 820EDDD0h */ case    0:  		/* mfspr R12, LR */
		/* 820EDDD0h case    0:*/		regs.R12 = regs.LR;
		/* 820EDDD0h case    0:*/		return 0x820EDDD4;
		  /* 820EDDD4h */ case    1:  		/* bl -379828 */
		/* 820EDDD4h case    1:*/		regs.LR = 0x820EDDD8; return 0x82091220;
		/* 820EDDD4h case    1:*/		return 0x820EDDD8;
		  /* 820EDDD8h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 820EDDD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 820EDDD8h case    2:*/		return 0x820EDDDC;
		  /* 820EDDDCh */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 820EDDDCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820EDDDCh case    3:*/		return 0x820EDDE0;
		  /* 820EDDE0h */ case    4:  		/* li R22, 0 */
		/* 820EDDE0h case    4:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 820EDDE0h case    4:*/		return 0x820EDDE4;
		  /* 820EDDE4h */ case    5:  		/* mr R18, R6 */
		/* 820EDDE4h case    5:*/		regs.R18 = regs.R6;
		/* 820EDDE4h case    5:*/		return 0x820EDDE8;
		  /* 820EDDE8h */ case    6:  		/* mr R25, R3 */
		/* 820EDDE8h case    6:*/		regs.R25 = regs.R3;
		/* 820EDDE8h case    6:*/		return 0x820EDDEC;
		  /* 820EDDECh */ case    7:  		/* stw R22, <#[R1 + 80]> */
		/* 820EDDECh case    7:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 820EDDECh case    7:*/		return 0x820EDDF0;
		  /* 820EDDF0h */ case    8:  		/* mr R14, R4 */
		/* 820EDDF0h case    8:*/		regs.R14 = regs.R4;
		/* 820EDDF0h case    8:*/		return 0x820EDDF4;
		  /* 820EDDF4h */ case    9:  		/* stw R22, <#[R1 + 84]> */
		/* 820EDDF4h case    9:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 820EDDF4h case    9:*/		return 0x820EDDF8;
		  /* 820EDDF8h */ case   10:  		/* mr R19, R5 */
		/* 820EDDF8h case   10:*/		regs.R19 = regs.R5;
		/* 820EDDF8h case   10:*/		return 0x820EDDFC;
		  /* 820EDDFCh */ case   11:  		/* mr R15, R7 */
		/* 820EDDFCh case   11:*/		regs.R15 = regs.R7;
		/* 820EDDFCh case   11:*/		return 0x820EDE00;
		  /* 820EDE00h */ case   12:  		/* mr R16, R8 */
		/* 820EDE00h case   12:*/		regs.R16 = regs.R8;
		/* 820EDE00h case   12:*/		return 0x820EDE04;
		  /* 820EDE04h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 820EDE04h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EDE04h case   13:*/		return 0x820EDE08;
		  /* 820EDE08h */ case   14:  		/* mr R6, R22 */
		/* 820EDE08h case   14:*/		regs.R6 = regs.R22;
		/* 820EDE08h case   14:*/		return 0x820EDE0C;
		  /* 820EDE0Ch */ case   15:  		/* bc 4, CR6_GT, 240 */
		/* 820EDE0Ch case   15:*/		if ( !regs.CR[6].gt ) { return 0x820EDEFC;  }
		/* 820EDE0Ch case   15:*/		return 0x820EDE10;
		  /* 820EDE10h */ case   16:  		/* mr R5, R22 */
		/* 820EDE10h case   16:*/		regs.R5 = regs.R22;
		/* 820EDE10h case   16:*/		return 0x820EDE14;
		  /* 820EDE14h */ case   17:  		/* lwz R11, <#[R25 + 16]> */
		/* 820EDE14h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 820EDE14h case   17:*/		return 0x820EDE18;
		  /* 820EDE18h */ case   18:  		/* lwzx R11, <#[R11 + R5]> */
		/* 820EDE18h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820EDE18h case   18:*/		return 0x820EDE1C;
		  /* 820EDE1Ch */ case   19:  		/* lwz R7, <#[R11 + 4]> */
		/* 820EDE1Ch case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 820EDE1Ch case   19:*/		return 0x820EDE20;
		  /* 820EDE20h */ case   20:  		/* stw R22, <#[R11 + 16]> */
		/* 820EDE20h case   20:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000010) );
		/* 820EDE20h case   20:*/		return 0x820EDE24;
		  /* 820EDE24h */ case   21:  		/* rlwinm. R10, R7, 0, 21, 21 */
		/* 820EDE24h case   21:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R7);
		/* 820EDE24h case   21:*/		return 0x820EDE28;
		  /* 820EDE28h */ case   22:  		/* bc 4, CR0_EQ, 192 */
		/* 820EDE28h case   22:*/		if ( !regs.CR[0].eq ) { return 0x820EDEE8;  }
		/* 820EDE28h case   22:*/		return 0x820EDE2C;
		  /* 820EDE2Ch */ case   23:  		/* stw R22, <#[R11 + 8]> */
		/* 820EDE2Ch case   23:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000008) );
		/* 820EDE2Ch case   23:*/		return 0x820EDE30;
		  /* 820EDE30h */ case   24:  		/* mr R8, R22 */
		/* 820EDE30h case   24:*/		regs.R8 = regs.R22;
		/* 820EDE30h case   24:*/		return 0x820EDE34;
		  /* 820EDE34h */ case   25:  		/* lwz R10, <#[R25 + 8]> */
		/* 820EDE34h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820EDE34h case   25:*/		return 0x820EDE38;
		  /* 820EDE38h */ case   26:  		/* cmplwi CR6, R10, 0 */
		/* 820EDE38h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820EDE38h case   26:*/		return 0x820EDE3C;
		  /* 820EDE3Ch */ case   27:  		/* bc 4, CR6_GT, 72 */
		/* 820EDE3Ch case   27:*/		if ( !regs.CR[6].gt ) { return 0x820EDE84;  }
		/* 820EDE3Ch case   27:*/		return 0x820EDE40;
		  /* 820EDE40h */ case   28:  		/* mr R9, R22 */
		/* 820EDE40h case   28:*/		regs.R9 = regs.R22;
		/* 820EDE40h case   28:*/		return 0x820EDE44;
		  /* 820EDE44h */ case   29:  		/* lwz R10, <#[R25 + 20]> */
		/* 820EDE44h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 820EDE44h case   29:*/		return 0x820EDE48;
		  /* 820EDE48h */ case   30:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820EDE48h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EDE48h case   30:*/		return 0x820EDE4C;
		  /* 820EDE4Ch */ case   31:  		/* lwz R4, <#[R10 + 4]> */
		/* 820EDE4Ch case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 820EDE4Ch case   31:*/		return 0x820EDE50;
		  /* 820EDE50h */ case   32:  		/* cmplw CR6, R4, R6 */
		/* 820EDE50h case   32:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R6);
		/* 820EDE50h case   32:*/		return 0x820EDE54;
		  /* 820EDE54h */ case   33:  		/* bc 4, CR6_EQ, 28 */
		/* 820EDE54h case   33:*/		if ( !regs.CR[6].eq ) { return 0x820EDE70;  }
		/* 820EDE54h case   33:*/		return 0x820EDE58;
	}
	return 0x820EDE58;
} // Block from 820EDDD0h-820EDE58h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820EDE58h
// Function '?SrcSwizzle@CShaderProgram@D3DXShader@@MAAJPAIIKPAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDE58);
		  /* 820EDE58h */ case    0:  		/* lwz R10, <#[R10 + 12]> */
		/* 820EDE58h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820EDE58h case    0:*/		return 0x820EDE5C;
		  /* 820EDE5Ch */ case    1:  		/* lwz R4, <#[R11 + 8]> */
		/* 820EDE5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000008) );
		/* 820EDE5Ch case    1:*/		return 0x820EDE60;
		  /* 820EDE60h */ case    2:  		/* addi R10, R10, 1 */
		/* 820EDE60h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EDE60h case    2:*/		return 0x820EDE64;
		  /* 820EDE64h */ case    3:  		/* cmplw CR6, R10, R4 */
		/* 820EDE64h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 820EDE64h case    3:*/		return 0x820EDE68;
		  /* 820EDE68h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 820EDE68h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820EDE70;  }
		/* 820EDE68h case    4:*/		return 0x820EDE6C;
		  /* 820EDE6Ch */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 820EDE6Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820EDE6Ch case    5:*/		return 0x820EDE70;
	}
	return 0x820EDE70;
} // Block from 820EDE58h-820EDE70h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EDE70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDE70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDE70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDE70);
		  /* 820EDE70h */ case    0:  		/* lwz R10, <#[R25 + 8]> */
		/* 820EDE70h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820EDE70h case    0:*/		return 0x820EDE74;
		  /* 820EDE74h */ case    1:  		/* addi R8, R8, 1 */
		/* 820EDE74h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820EDE74h case    1:*/		return 0x820EDE78;
		  /* 820EDE78h */ case    2:  		/* addi R9, R9, 4 */
		/* 820EDE78h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820EDE78h case    2:*/		return 0x820EDE7C;
		  /* 820EDE7Ch */ case    3:  		/* cmplw CR6, R8, R10 */
		/* 820EDE7Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 820EDE7Ch case    3:*/		return 0x820EDE80;
		  /* 820EDE80h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 820EDE80h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EDE44;  }
		/* 820EDE80h case    4:*/		return 0x820EDE84;
	}
	return 0x820EDE84;
} // Block from 820EDE70h-820EDE84h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EDE84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDE84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDE84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDE84);
		  /* 820EDE84h */ case    0:  		/* rlwinm. R10, R7, 0, 23, 23 */
		/* 820EDE84h case    0:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R7);
		/* 820EDE84h case    0:*/		return 0x820EDE88;
		  /* 820EDE88h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820EDE88h case    1:*/		if ( regs.CR[0].eq ) { return 0x820EDE9C;  }
		/* 820EDE88h case    1:*/		return 0x820EDE8C;
		  /* 820EDE8Ch */ case    2:  		/* rlwinm. R10, R7, 0, 20, 20 */
		/* 820EDE8Ch case    2:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R7);
		/* 820EDE8Ch case    2:*/		return 0x820EDE90;
		  /* 820EDE90h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 820EDE90h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820EDE9C;  }
		/* 820EDE90h case    3:*/		return 0x820EDE94;
		  /* 820EDE94h */ case    4:  		/* rlwinm R10, R7, 0, 26, 24 */
		/* 820EDE94h case    4:*/		cpu::op::rlwinm<0,0,26,24>(regs,&regs.R10,regs.R7);
		/* 820EDE94h case    4:*/		return 0x820EDE98;
		  /* 820EDE98h */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 820EDE98h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820EDE98h case    5:*/		return 0x820EDE9C;
	}
	return 0x820EDE9C;
} // Block from 820EDE84h-820EDE9Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EDE9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDE9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDE9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDE9C);
		  /* 820EDE9Ch */ case    0:  		/* lwz R10, <#[R11 + 4]> */
		/* 820EDE9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820EDE9Ch case    0:*/		return 0x820EDEA0;
		  /* 820EDEA0h */ case    1:  		/* rlwinm. R9, R10, 0, 27, 27 */
		/* 820EDEA0h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R9,regs.R10);
		/* 820EDEA0h case    1:*/		return 0x820EDEA4;
		  /* 820EDEA4h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 820EDEA4h case    2:*/		if ( regs.CR[0].eq ) { return 0x820EDEC0;  }
		/* 820EDEA4h case    2:*/		return 0x820EDEA8;
		  /* 820EDEA8h */ case    3:  		/* rlwinm. R9, R10, 0, 22, 22 */
		/* 820EDEA8h case    3:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R9,regs.R10);
		/* 820EDEA8h case    3:*/		return 0x820EDEAC;
		  /* 820EDEACh */ case    4:  		/* bc 4, CR0_EQ, 20 */
		/* 820EDEACh case    4:*/		if ( !regs.CR[0].eq ) { return 0x820EDEC0;  }
		/* 820EDEACh case    4:*/		return 0x820EDEB0;
		  /* 820EDEB0h */ case    5:  		/* rlwinm. R9, R10, 0, 20, 20 */
		/* 820EDEB0h case    5:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R10);
		/* 820EDEB0h case    5:*/		return 0x820EDEB4;
		  /* 820EDEB4h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 820EDEB4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820EDEC0;  }
		/* 820EDEB4h case    6:*/		return 0x820EDEB8;
		  /* 820EDEB8h */ case    7:  		/* rlwinm R10, R10, 0, 26, 24 */
		/* 820EDEB8h case    7:*/		cpu::op::rlwinm<0,0,26,24>(regs,&regs.R10,regs.R10);
		/* 820EDEB8h case    7:*/		return 0x820EDEBC;
		  /* 820EDEBCh */ case    8:  		/* stw R10, <#[R11 + 4]> */
		/* 820EDEBCh case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820EDEBCh case    8:*/		return 0x820EDEC0;
	}
	return 0x820EDEC0;
} // Block from 820EDE9Ch-820EDEC0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820EDEC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDEC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDEC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDEC0);
		  /* 820EDEC0h */ case    0:  		/* lwz R10, <#[R11 + 4]> */
		/* 820EDEC0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820EDEC0h case    0:*/		return 0x820EDEC4;
		  /* 820EDEC4h */ case    1:  		/* rlwinm. R9, R10, 0, 24, 24 */
		/* 820EDEC4h case    1:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R9,regs.R10);
		/* 820EDEC4h case    1:*/		return 0x820EDEC8;
		  /* 820EDEC8h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 820EDEC8h case    2:*/		if ( regs.CR[0].eq ) { return 0x820EDEE8;  }
		/* 820EDEC8h case    2:*/		return 0x820EDECC;
		  /* 820EDECCh */ case    3:  		/* rlwinm. R9, R10, 0, 20, 20 */
		/* 820EDECCh case    3:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R10);
		/* 820EDECCh case    3:*/		return 0x820EDED0;
		  /* 820EDED0h */ case    4:  		/* bc 4, CR0_EQ, 24 */
		/* 820EDED0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820EDEE8;  }
		/* 820EDED0h case    4:*/		return 0x820EDED4;
		  /* 820EDED4h */ case    5:  		/* lwz R9, <#[R11 + 8]> */
		/* 820EDED4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820EDED4h case    5:*/		return 0x820EDED8;
		  /* 820EDED8h */ case    6:  		/* cmplwi CR6, R9, 1 */
		/* 820EDED8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820EDED8h case    6:*/		return 0x820EDEDC;
		  /* 820EDEDCh */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 820EDEDCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x820EDEE8;  }
		/* 820EDEDCh case    7:*/		return 0x820EDEE0;
		  /* 820EDEE0h */ case    8:  		/* rlwinm R10, R10, 0, 26, 24 */
		/* 820EDEE0h case    8:*/		cpu::op::rlwinm<0,0,26,24>(regs,&regs.R10,regs.R10);
		/* 820EDEE0h case    8:*/		return 0x820EDEE4;
		  /* 820EDEE4h */ case    9:  		/* stw R10, <#[R11 + 4]> */
		/* 820EDEE4h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820EDEE4h case    9:*/		return 0x820EDEE8;
	}
	return 0x820EDEE8;
} // Block from 820EDEC0h-820EDEE8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EDEE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDEE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDEE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDEE8);
		  /* 820EDEE8h */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 820EDEE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820EDEE8h case    0:*/		return 0x820EDEEC;
		  /* 820EDEECh */ case    1:  		/* addi R6, R6, 1 */
		/* 820EDEECh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820EDEECh case    1:*/		return 0x820EDEF0;
		  /* 820EDEF0h */ case    2:  		/* addi R5, R5, 4 */
		/* 820EDEF0h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 820EDEF0h case    2:*/		return 0x820EDEF4;
		  /* 820EDEF4h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 820EDEF4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820EDEF4h case    3:*/		return 0x820EDEF8;
		  /* 820EDEF8h */ case    4:  		/* bc 12, CR6_LT, -228 */
		/* 820EDEF8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EDE14;  }
		/* 820EDEF8h case    4:*/		return 0x820EDEFC;
	}
	return 0x820EDEFC;
} // Block from 820EDEE8h-820EDEFCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EDEFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDEFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDEFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDEFC);
		  /* 820EDEFCh */ case    0:  		/* mulli R31, R19, 12 */
		/* 820EDEFCh case    0:*/		cpu::op::mulli<0>(regs,&regs.R31,regs.R19,0xC);
		/* 820EDEFCh case    0:*/		return 0x820EDF00;
		  /* 820EDF00h */ case    1:  		/* lis R4, 9345 */
		/* 820EDF00h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820EDF00h case    1:*/		return 0x820EDF04;
		  /* 820EDF04h */ case    2:  		/* mr R3, R31 */
		/* 820EDF04h case    2:*/		regs.R3 = regs.R31;
		/* 820EDF04h case    2:*/		return 0x820EDF08;
		  /* 820EDF08h */ case    3:  		/* bl -417032 */
		/* 820EDF08h case    3:*/		regs.LR = 0x820EDF0C; return 0x82088200;
		/* 820EDF08h case    3:*/		return 0x820EDF0C;
		  /* 820EDF0Ch */ case    4:  		/* or. R17, R3, R3 */
		/* 820EDF0Ch case    4:*/		cpu::op::or<1>(regs,&regs.R17,regs.R3,regs.R3);
		/* 820EDF0Ch case    4:*/		return 0x820EDF10;
		  /* 820EDF10h */ case    5:  		/* bc 12, CR0_EQ, 2256 */
		/* 820EDF10h case    5:*/		if ( regs.CR[0].eq ) { return 0x820EE7E0;  }
		/* 820EDF10h case    5:*/		return 0x820EDF14;
		  /* 820EDF14h */ case    6:  		/* mr R5, R31 */
		/* 820EDF14h case    6:*/		regs.R5 = regs.R31;
		/* 820EDF14h case    6:*/		return 0x820EDF18;
		  /* 820EDF18h */ case    7:  		/* li R4, 0 */
		/* 820EDF18h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820EDF18h case    7:*/		return 0x820EDF1C;
		  /* 820EDF1Ch */ case    8:  		/* mr R3, R17 */
		/* 820EDF1Ch case    8:*/		regs.R3 = regs.R17;
		/* 820EDF1Ch case    8:*/		return 0x820EDF20;
		  /* 820EDF20h */ case    9:  		/* bl -379872 */
		/* 820EDF20h case    9:*/		regs.LR = 0x820EDF24; return 0x82091340;
		/* 820EDF20h case    9:*/		return 0x820EDF24;
		  /* 820EDF24h */ case   10:  		/* lwz R11, <#[R25 + 4]> */
		/* 820EDF24h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820EDF24h case   10:*/		return 0x820EDF28;
		  /* 820EDF28h */ case   11:  		/* mr R26, R22 */
		/* 820EDF28h case   11:*/		regs.R26 = regs.R22;
		/* 820EDF28h case   11:*/		return 0x820EDF2C;
		  /* 820EDF2Ch */ case   12:  		/* li R21, -1 */
		/* 820EDF2Ch case   12:*/		cpu::op::li<0>(regs,&regs.R21,0xFFFFFFFF);
		/* 820EDF2Ch case   12:*/		return 0x820EDF30;
		  /* 820EDF30h */ case   13:  		/* li R20, 1 */
		/* 820EDF30h case   13:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 820EDF30h case   13:*/		return 0x820EDF34;
		  /* 820EDF34h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 820EDF34h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EDF34h case   14:*/		return 0x820EDF38;
		  /* 820EDF38h */ case   15:  		/* bc 12, CR6_EQ, 660 */
		/* 820EDF38h case   15:*/		if ( regs.CR[6].eq ) { return 0x820EE1CC;  }
		/* 820EDF38h case   15:*/		return 0x820EDF3C;
		  /* 820EDF3Ch */ case   16:  		/* lis R11, -32254 */
		/* 820EDF3Ch case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EDF3Ch case   16:*/		return 0x820EDF40;
		  /* 820EDF40h */ case   17:  		/* mr R24, R22 */
		/* 820EDF40h case   17:*/		regs.R24 = regs.R22;
		/* 820EDF40h case   17:*/		return 0x820EDF44;
		  /* 820EDF44h */ case   18:  		/* addi R23, R11, -16576 */
		/* 820EDF44h case   18:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R11,0xFFFFBF40);
		/* 820EDF44h case   18:*/		return 0x820EDF48;
		  /* 820EDF48h */ case   19:  		/* lwz R11, <#[R25 + 16]> */
		/* 820EDF48h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 820EDF48h case   19:*/		return 0x820EDF4C;
		  /* 820EDF4Ch */ case   20:  		/* lwzx R27, <#[R11 + R24]> */
		/* 820EDF4Ch case   20:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 820EDF4Ch case   20:*/		return 0x820EDF50;
		  /* 820EDF50h */ case   21:  		/* lwz R11, <#[R27 + 4]> */
		/* 820EDF50h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 820EDF50h case   21:*/		return 0x820EDF54;
		  /* 820EDF54h */ case   22:  		/* and R10, R11, R18 */
		/* 820EDF54h case   22:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R18);
		/* 820EDF54h case   22:*/		return 0x820EDF58;
		  /* 820EDF58h */ case   23:  		/* cmplw CR6, R10, R18 */
		/* 820EDF58h case   23:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R18);
		/* 820EDF58h case   23:*/		return 0x820EDF5C;
		  /* 820EDF5Ch */ case   24:  		/* bc 4, CR6_EQ, 604 */
		/* 820EDF5Ch case   24:*/		if ( !regs.CR[6].eq ) { return 0x820EE1B8;  }
		/* 820EDF5Ch case   24:*/		return 0x820EDF60;
		  /* 820EDF60h */ case   25:  		/* and. R10, R11, R15 */
		/* 820EDF60h case   25:*/		cpu::op::and<1>(regs,&regs.R10,regs.R11,regs.R15);
		/* 820EDF60h case   25:*/		return 0x820EDF64;
		  /* 820EDF64h */ case   26:  		/* bc 4, CR0_EQ, 596 */
		/* 820EDF64h case   26:*/		if ( !regs.CR[0].eq ) { return 0x820EE1B8;  }
		/* 820EDF64h case   26:*/		return 0x820EDF68;
		  /* 820EDF68h */ case   27:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 820EDF68h case   27:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 820EDF68h case   27:*/		return 0x820EDF6C;
		  /* 820EDF6Ch */ case   28:  		/* bc 12, CR0_EQ, 588 */
		/* 820EDF6Ch case   28:*/		if ( regs.CR[0].eq ) { return 0x820EE1B8;  }
		/* 820EDF6Ch case   28:*/		return 0x820EDF70;
		  /* 820EDF70h */ case   29:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 820EDF70h case   29:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 820EDF70h case   29:*/		return 0x820EDF74;
		  /* 820EDF74h */ case   30:  		/* bc 12, CR0_EQ, 580 */
		/* 820EDF74h case   30:*/		if ( regs.CR[0].eq ) { return 0x820EE1B8;  }
		/* 820EDF74h case   30:*/		return 0x820EDF78;
		  /* 820EDF78h */ case   31:  		/* lwz R11, <#[R27 + 8]> */
		/* 820EDF78h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820EDF78h case   31:*/		return 0x820EDF7C;
		  /* 820EDF7Ch */ case   32:  		/* cmplwi CR6, R11, 0 */
		/* 820EDF7Ch case   32:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EDF7Ch case   32:*/		return 0x820EDF80;
		  /* 820EDF80h */ case   33:  		/* bc 12, CR6_EQ, 568 */
		/* 820EDF80h case   33:*/		if ( regs.CR[6].eq ) { return 0x820EE1B8;  }
		/* 820EDF80h case   33:*/		return 0x820EDF84;
		  /* 820EDF84h */ case   34:  		/* stw R21, <#[R27 + 16]> */
		/* 820EDF84h case   34:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R27 + 0x00000010) );
		/* 820EDF84h case   34:*/		return 0x820EDF88;
		  /* 820EDF88h */ case   35:  		/* mr R28, R22 */
		/* 820EDF88h case   35:*/		regs.R28 = regs.R22;
		/* 820EDF88h case   35:*/		return 0x820EDF8C;
		  /* 820EDF8Ch */ case   36:  		/* lwz R9, <#[R25 + 8]> */
		/* 820EDF8Ch case   36:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000008) );
		/* 820EDF8Ch case   36:*/		return 0x820EDF90;
		  /* 820EDF90h */ case   37:  		/* mr R29, R20 */
		/* 820EDF90h case   37:*/		regs.R29 = regs.R20;
		/* 820EDF90h case   37:*/		return 0x820EDF94;
		  /* 820EDF94h */ case   38:  		/* mr R8, R22 */
		/* 820EDF94h case   38:*/		regs.R8 = regs.R22;
		/* 820EDF94h case   38:*/		return 0x820EDF98;
		  /* 820EDF98h */ case   39:  		/* cmplwi CR6, R9, 0 */
		/* 820EDF98h case   39:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820EDF98h case   39:*/		return 0x820EDF9C;
		  /* 820EDF9Ch */ case   40:  		/* bc 12, CR6_EQ, 68 */
		/* 820EDF9Ch case   40:*/		if ( regs.CR[6].eq ) { return 0x820EDFE0;  }
		/* 820EDF9Ch case   40:*/		return 0x820EDFA0;
		  /* 820EDFA0h */ case   41:  		/* lwz R7, <#[R25 + 20]> */
		/* 820EDFA0h case   41:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000014) );
		/* 820EDFA0h case   41:*/		return 0x820EDFA4;
		  /* 820EDFA4h */ case   42:  		/* mr R10, R22 */
		/* 820EDFA4h case   42:*/		regs.R10 = regs.R22;
		/* 820EDFA4h case   42:*/		return 0x820EDFA8;
		  /* 820EDFA8h */ case   43:  		/* lwzx R11, <#[R7 + R10]> */
		/* 820EDFA8h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820EDFA8h case   43:*/		return 0x820EDFAC;
		  /* 820EDFACh */ case   44:  		/* lwz R6, <#[R11 + 4]> */
		/* 820EDFACh case   44:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 820EDFACh case   44:*/		return 0x820EDFB0;
		  /* 820EDFB0h */ case   45:  		/* cmplw CR6, R6, R26 */
		/* 820EDFB0h case   45:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R26);
		/* 820EDFB0h case   45:*/		return 0x820EDFB4;
		  /* 820EDFB4h */ case   46:  		/* bc 4, CR6_EQ, 28 */
		/* 820EDFB4h case   46:*/		if ( !regs.CR[6].eq ) { return 0x820EDFD0;  }
		/* 820EDFB4h case   46:*/		return 0x820EDFB8;
		  /* 820EDFB8h */ case   47:  		/* lwz R6, <#[R11]> */
		/* 820EDFB8h case   47:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820EDFB8h case   47:*/		return 0x820EDFBC;
		  /* 820EDFBCh */ case   48:  		/* mr R28, R11 */
		/* 820EDFBCh case   48:*/		regs.R28 = regs.R11;
		/* 820EDFBCh case   48:*/		return 0x820EDFC0;
		  /* 820EDFC0h */ case   49:  		/* rlwinm R11, R6, 0, 3, 3 */
		/* 820EDFC0h case   49:*/		cpu::op::rlwinm<0,0,3,3>(regs,&regs.R11,regs.R6);
		/* 820EDFC0h case   49:*/		return 0x820EDFC4;
		  /* 820EDFC4h */ case   50:  		/* subfic R11, R11, 0 */
		/* 820EDFC4h case   50:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820EDFC4h case   50:*/		return 0x820EDFC8;
		  /* 820EDFC8h */ case   51:  		/* subfe R11, R11, R11 */
		/* 820EDFC8h case   51:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820EDFC8h case   51:*/		return 0x820EDFCC;
		  /* 820EDFCCh */ case   52:  		/* and R29, R11, R29 */
		/* 820EDFCCh case   52:*/		cpu::op::and<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 820EDFCCh case   52:*/		return 0x820EDFD0;
	}
	return 0x820EDFD0;
} // Block from 820EDEFCh-820EDFD0h (53 instructions)

//////////////////////////////////////////////////////
// Block at 820EDFD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDFD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDFD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDFD0);
		  /* 820EDFD0h */ case    0:  		/* addi R8, R8, 1 */
		/* 820EDFD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820EDFD0h case    0:*/		return 0x820EDFD4;
		  /* 820EDFD4h */ case    1:  		/* addi R10, R10, 4 */
		/* 820EDFD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EDFD4h case    1:*/		return 0x820EDFD8;
		  /* 820EDFD8h */ case    2:  		/* cmplw CR6, R8, R9 */
		/* 820EDFD8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820EDFD8h case    2:*/		return 0x820EDFDC;
		  /* 820EDFDCh */ case    3:  		/* bc 12, CR6_LT, -52 */
		/* 820EDFDCh case    3:*/		if ( regs.CR[6].lt ) { return 0x820EDFA8;  }
		/* 820EDFDCh case    3:*/		return 0x820EDFE0;
	}
	return 0x820EDFE0;
} // Block from 820EDFD0h-820EDFE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EDFE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EDFE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EDFE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EDFE0);
		  /* 820EDFE0h */ case    0:  		/* mr R7, R26 */
		/* 820EDFE0h case    0:*/		regs.R7 = regs.R26;
		/* 820EDFE0h case    0:*/		return 0x820EDFE4;
		  /* 820EDFE4h */ case    1:  		/* lwz R4, <#[R27]> */
		/* 820EDFE4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000000) );
		/* 820EDFE4h case    1:*/		return 0x820EDFE8;
		  /* 820EDFE8h */ case    2:  		/* mr R6, R16 */
		/* 820EDFE8h case    2:*/		regs.R6 = regs.R16;
		/* 820EDFE8h case    2:*/		return 0x820EDFEC;
		  /* 820EDFECh */ case    3:  		/* addi R5, R1, 88 */
		/* 820EDFECh case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 820EDFECh case    3:*/		return 0x820EDFF0;
		  /* 820EDFF0h */ case    4:  		/* mr R3, R25 */
		/* 820EDFF0h case    4:*/		regs.R3 = regs.R25;
		/* 820EDFF0h case    4:*/		return 0x820EDFF4;
		  /* 820EDFF4h */ case    5:  		/* bl -39220 */
		/* 820EDFF4h case    5:*/		regs.LR = 0x820EDFF8; return 0x820E46C0;
		/* 820EDFF4h case    5:*/		return 0x820EDFF8;
		  /* 820EDFF8h */ case    6:  		/* or. R31, R3, R3 */
		/* 820EDFF8h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820EDFF8h case    6:*/		return 0x820EDFFC;
		  /* 820EDFFCh */ case    7:  		/* bc 4, CR0_LT, 28 */
		/* 820EDFFCh case    7:*/		if ( !regs.CR[0].lt ) { return 0x820EE018;  }
		/* 820EDFFCh case    7:*/		return 0x820EE000;
		  /* 820EE000h */ case    8:  		/* cmpwi CR6, R29, 0 */
		/* 820EE000h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820EE000h case    8:*/		return 0x820EE004;
		  /* 820EE004h */ case    9:  		/* bc 4, CR6_EQ, 436 */
		/* 820EE004h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820EE1B8;  }
		/* 820EE004h case    9:*/		return 0x820EE008;
	}
	return 0x820EE008;
} // Block from 820EDFE0h-820EE008h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EE008h
// Function '?PredRegister@CShaderProgram@D3DXShader@@MAAJPAVCArgument@2@PAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE008);
		  /* 820EE008h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820EE008h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EE008h case    0:*/		return 0x820EE00C;
		  /* 820EE00Ch */ case    1:  		/* bc 12, CR6_EQ, 828 */
		/* 820EE00Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820EE348;  }
		/* 820EE00Ch case    1:*/		return 0x820EE010;
		  /* 820EE010h */ case    2:  		/* lwz R4, <#[R28 + 96]> */
		/* 820EE010h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000060) );
		/* 820EE010h case    2:*/		return 0x820EE014;
		  /* 820EE014h */ case    3:  		/* b 824 */
		/* 820EE014h case    3:*/		return 0x820EE34C;
		/* 820EE014h case    3:*/		return 0x820EE018;
	}
	return 0x820EE018;
} // Block from 820EE008h-820EE018h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE018);
		  /* 820EE018h */ case    0:  		/* lwz R31, <#[R1 + 88]> */
		/* 820EE018h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000058) );
		/* 820EE018h case    0:*/		return 0x820EE01C;
		  /* 820EE01Ch */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820EE01Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820EE01Ch case    1:*/		return 0x820EE020;
		  /* 820EE020h */ case    2:  		/* bc 12, CR6_EQ, 116 */
		/* 820EE020h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EE094;  }
		/* 820EE020h case    2:*/		return 0x820EE024;
		  /* 820EE024h */ case    3:  		/* lbz R11, <#[R31]> */
		/* 820EE024h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EE024h case    3:*/		return 0x820EE028;
		  /* 820EE028h */ case    4:  		/* extsb R3, R11 */
		/* 820EE028h case    4:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820EE028h case    4:*/		return 0x820EE02C;
		  /* 820EE02Ch */ case    5:  		/* bl -346268 */
		/* 820EE02Ch case    5:*/		regs.LR = 0x820EE030; return 0x82099790;
		/* 820EE02Ch case    5:*/		return 0x820EE030;
		  /* 820EE030h */ case    6:  		/* extsb R11, R16 */
		/* 820EE030h case    6:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R16);
		/* 820EE030h case    6:*/		return 0x820EE034;
		  /* 820EE034h */ case    7:  		/* cmpw CR6, R11, R3 */
		/* 820EE034h case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R3);
		/* 820EE034h case    7:*/		return 0x820EE038;
		  /* 820EE038h */ case    8:  		/* bc 4, CR6_EQ, 92 */
		/* 820EE038h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820EE094;  }
		/* 820EE038h case    8:*/		return 0x820EE03C;
		  /* 820EE03Ch */ case    9:  		/* lbz R11, <#[R31 + 1]> */
		/* 820EE03Ch case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		/* 820EE03Ch case    9:*/		return 0x820EE040;
		  /* 820EE040h */ case   10:  		/* addi R30, R31, 1 */
		/* 820EE040h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x1);
		/* 820EE040h case   10:*/		return 0x820EE044;
		  /* 820EE044h */ case   11:  		/* extsb R3, R11 */
		/* 820EE044h case   11:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820EE044h case   11:*/		return 0x820EE048;
		  /* 820EE048h */ case   12:  		/* bl -346424 */
		/* 820EE048h case   12:*/		regs.LR = 0x820EE04C; return 0x82099710;
		/* 820EE048h case   12:*/		return 0x820EE04C;
		  /* 820EE04Ch */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820EE04Ch case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EE04Ch case   13:*/		return 0x820EE050;
		  /* 820EE050h */ case   14:  		/* bc 12, CR0_EQ, 68 */
		/* 820EE050h case   14:*/		if ( regs.CR[0].eq ) { return 0x820EE094;  }
		/* 820EE050h case   14:*/		return 0x820EE054;
		  /* 820EE054h */ case   15:  		/* addi R31, R31, 2 */
		/* 820EE054h case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x2);
		/* 820EE054h case   15:*/		return 0x820EE058;
		  /* 820EE058h */ case   16:  		/* lbz R11, <#[R31]> */
		/* 820EE058h case   16:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EE058h case   16:*/		return 0x820EE05C;
		  /* 820EE05Ch */ case   17:  		/* b 8 */
		/* 820EE05Ch case   17:*/		return 0x820EE064;
		/* 820EE05Ch case   17:*/		return 0x820EE060;
		  /* 820EE060h */ case   18:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820EE060h case   18:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820EE060h case   18:*/		return 0x820EE064;
	}
	return 0x820EE064;
} // Block from 820EE018h-820EE064h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820EE064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE064);
		  /* 820EE064h */ case    0:  		/* extsb R3, R11 */
		/* 820EE064h case    0:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820EE064h case    0:*/		return 0x820EE068;
		  /* 820EE068h */ case    1:  		/* bl -346456 */
		/* 820EE068h case    1:*/		regs.LR = 0x820EE06C; return 0x82099710;
		/* 820EE068h case    1:*/		return 0x820EE06C;
		  /* 820EE06Ch */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820EE06Ch case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EE06Ch case    2:*/		return 0x820EE070;
		  /* 820EE070h */ case    3:  		/* bc 4, CR0_EQ, -16 */
		/* 820EE070h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820EE060;  }
		/* 820EE070h case    3:*/		return 0x820EE074;
		  /* 820EE074h */ case    4:  		/* lbz R11, <#[R31]> */
		/* 820EE074h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EE074h case    4:*/		return 0x820EE078;
		  /* 820EE078h */ case    5:  		/* extsb. R11, R11 */
		/* 820EE078h case    5:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R11);
		/* 820EE078h case    5:*/		return 0x820EE07C;
		  /* 820EE07Ch */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 820EE07Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820EE088;  }
		/* 820EE07Ch case    6:*/		return 0x820EE080;
		  /* 820EE080h */ case    7:  		/* cmpwi CR6, R11, 59 */
		/* 820EE080h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000003B);
		/* 820EE080h case    7:*/		return 0x820EE084;
		  /* 820EE084h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 820EE084h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820EE094;  }
		/* 820EE084h case    8:*/		return 0x820EE088;
	}
	return 0x820EE088;
} // Block from 820EE064h-820EE088h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820EE088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE088);
		  /* 820EE088h */ case    0:  		/* mr R3, R30 */
		/* 820EE088h case    0:*/		regs.R3 = regs.R30;
		/* 820EE088h case    0:*/		return 0x820EE08C;
		  /* 820EE08Ch */ case    1:  		/* bl -374052 */
		/* 820EE08Ch case    1:*/		regs.LR = 0x820EE090; return 0x82092B68;
		/* 820EE08Ch case    1:*/		return 0x820EE090;
		  /* 820EE090h */ case    2:  		/* stw R3, <#[R27 + 16]> */
		/* 820EE090h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x00000010) );
		/* 820EE090h case    2:*/		return 0x820EE094;
	}
	return 0x820EE094;
} // Block from 820EE088h-820EE094h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EE094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE094);
		  /* 820EE094h */ case    0:  		/* lwz R11, <#[R27 + 16]> */
		/* 820EE094h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 820EE094h case    0:*/		return 0x820EE098;
		  /* 820EE098h */ case    1:  		/* cmplw CR6, R11, R19 */
		/* 820EE098h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 820EE098h case    1:*/		return 0x820EE09C;
		  /* 820EE09Ch */ case    2:  		/* bc 12, CR6_LT, 12 */
		/* 820EE09Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x820EE0A8;  }
		/* 820EE09Ch case    2:*/		return 0x820EE0A0;
		  /* 820EE0A0h */ case    3:  		/* cmpwi CR6, R29, 0 */
		/* 820EE0A0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820EE0A0h case    3:*/		return 0x820EE0A4;
		  /* 820EE0A4h */ case    4:  		/* bc 12, CR6_EQ, 708 */
		/* 820EE0A4h case    4:*/		if ( regs.CR[6].eq ) { return 0x820EE368;  }
		/* 820EE0A4h case    4:*/		return 0x820EE0A8;
	}
	return 0x820EE0A8;
} // Block from 820EE094h-820EE0A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EE0A8h
// Function '?ValidateInst@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE0A8);
		  /* 820EE0A8h */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 820EE0A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820EE0A8h case    0:*/		return 0x820EE0AC;
		  /* 820EE0ACh */ case    1:  		/* mr R29, R22 */
		/* 820EE0ACh case    1:*/		regs.R29 = regs.R22;
		/* 820EE0ACh case    1:*/		return 0x820EE0B0;
		  /* 820EE0B0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820EE0B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE0B0h case    2:*/		return 0x820EE0B4;
		  /* 820EE0B4h */ case    3:  		/* bc 4, CR6_GT, 260 */
		/* 820EE0B4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820EE1B8;  }
		/* 820EE0B4h case    3:*/		return 0x820EE0B8;
		  /* 820EE0B8h */ case    4:  		/* lwz R11, <#[R25 + 8]> */
		/* 820EE0B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820EE0B8h case    4:*/		return 0x820EE0BC;
		  /* 820EE0BCh */ case    5:  		/* mr R9, R22 */
		/* 820EE0BCh case    5:*/		regs.R9 = regs.R22;
		/* 820EE0BCh case    5:*/		return 0x820EE0C0;
		  /* 820EE0C0h */ case    6:  		/* lwz R10, <#[R27 + 16]> */
		/* 820EE0C0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 820EE0C0h case    6:*/		return 0x820EE0C4;
		  /* 820EE0C4h */ case    7:  		/* mr R6, R11 */
		/* 820EE0C4h case    7:*/		regs.R6 = regs.R11;
		/* 820EE0C4h case    7:*/		return 0x820EE0C8;
		  /* 820EE0C8h */ case    8:  		/* add R8, R10, R29 */
		/* 820EE0C8h case    8:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R29);
		/* 820EE0C8h case    8:*/		return 0x820EE0CC;
		  /* 820EE0CCh */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820EE0CCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE0CCh case    9:*/		return 0x820EE0D0;
		  /* 820EE0D0h */ case   10:  		/* bc 12, CR6_EQ, 72 */
		/* 820EE0D0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820EE118;  }
		/* 820EE0D0h case   10:*/		return 0x820EE0D4;
		  /* 820EE0D4h */ case   11:  		/* lwz R5, <#[R25 + 20]> */
		/* 820EE0D4h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R25 + 0x00000014) );
		/* 820EE0D4h case   11:*/		return 0x820EE0D8;
		  /* 820EE0D8h */ case   12:  		/* mr R7, R22 */
		/* 820EE0D8h case   12:*/		regs.R7 = regs.R22;
		/* 820EE0D8h case   12:*/		return 0x820EE0DC;
		  /* 820EE0DCh */ case   13:  		/* lwzx R10, <#[R5 + R7]> */
		/* 820EE0DCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + regs.R7 + 0x00000000) );
		/* 820EE0DCh case   13:*/		return 0x820EE0E0;
		  /* 820EE0E0h */ case   14:  		/* lwz R4, <#[R10 + 4]> */
		/* 820EE0E0h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 820EE0E0h case   14:*/		return 0x820EE0E4;
		  /* 820EE0E4h */ case   15:  		/* cmplw CR6, R4, R26 */
		/* 820EE0E4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R26);
		/* 820EE0E4h case   15:*/		return 0x820EE0E8;
		  /* 820EE0E8h */ case   16:  		/* bc 4, CR6_EQ, 32 */
		/* 820EE0E8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820EE108;  }
		/* 820EE0E8h case   16:*/		return 0x820EE0EC;
		  /* 820EE0ECh */ case   17:  		/* lwz R4, <#[R10 + 12]> */
		/* 820EE0ECh case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000000C) );
		/* 820EE0ECh case   17:*/		return 0x820EE0F0;
		  /* 820EE0F0h */ case   18:  		/* cmplw CR6, R29, R4 */
		/* 820EE0F0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R4);
		/* 820EE0F0h case   18:*/		return 0x820EE0F4;
		  /* 820EE0F4h */ case   19:  		/* bc 4, CR6_EQ, 20 */
		/* 820EE0F4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820EE108;  }
		/* 820EE0F4h case   19:*/		return 0x820EE0F8;
		  /* 820EE0F8h */ case   20:  		/* lwz R10, <#[R10]> */
		/* 820EE0F8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820EE0F8h case   20:*/		return 0x820EE0FC;
		  /* 820EE0FCh */ case   21:  		/* mr R6, R9 */
		/* 820EE0FCh case   21:*/		regs.R6 = regs.R9;
		/* 820EE0FCh case   21:*/		return 0x820EE100;
		  /* 820EE100h */ case   22:  		/* rlwinm. R10, R10, 0, 3, 3 */
		/* 820EE100h case   22:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R10);
		/* 820EE100h case   22:*/		return 0x820EE104;
		  /* 820EE104h */ case   23:  		/* bc 12, CR0_EQ, 20 */
		/* 820EE104h case   23:*/		if ( regs.CR[0].eq ) { return 0x820EE118;  }
		/* 820EE104h case   23:*/		return 0x820EE108;
	}
	return 0x820EE108;
} // Block from 820EE0A8h-820EE108h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820EE108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE108);
		  /* 820EE108h */ case    0:  		/* addi R9, R9, 1 */
		/* 820EE108h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820EE108h case    0:*/		return 0x820EE10C;
		  /* 820EE10Ch */ case    1:  		/* addi R7, R7, 4 */
		/* 820EE10Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820EE10Ch case    1:*/		return 0x820EE110;
		  /* 820EE110h */ case    2:  		/* cmplw CR6, R9, R11 */
		/* 820EE110h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820EE110h case    2:*/		return 0x820EE114;
		  /* 820EE114h */ case    3:  		/* bc 12, CR6_LT, -56 */
		/* 820EE114h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EE0DC;  }
		/* 820EE114h case    3:*/		return 0x820EE118;
	}
	return 0x820EE118;
} // Block from 820EE108h-820EE118h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE118);
		  /* 820EE118h */ case    0:  		/* cmplw CR6, R6, R11 */
		/* 820EE118h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820EE118h case    0:*/		return 0x820EE11C;
		  /* 820EE11Ch */ case    1:  		/* bc 12, CR6_EQ, 140 */
		/* 820EE11Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820EE1A8;  }
		/* 820EE11Ch case    1:*/		return 0x820EE120;
		  /* 820EE120h */ case    2:  		/* lwz R11, <#[R25 + 20]> */
		/* 820EE120h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000014) );
		/* 820EE120h case    2:*/		return 0x820EE124;
		  /* 820EE124h */ case    3:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 820EE124h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 820EE124h case    3:*/		return 0x820EE128;
		  /* 820EE128h */ case    4:  		/* lwzx R30, <#[R10 + R11]> */
		/* 820EE128h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EE128h case    4:*/		return 0x820EE12C;
		  /* 820EE12Ch */ case    5:  		/* lwz R11, <#[R30]> */
		/* 820EE12Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820EE12Ch case    5:*/		return 0x820EE130;
		  /* 820EE130h */ case    6:  		/* rlwinm. R11, R11, 0, 3, 3 */
		/* 820EE130h case    6:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R11);
		/* 820EE130h case    6:*/		return 0x820EE134;
		  /* 820EE134h */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 820EE134h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820EE140;  }
		/* 820EE134h case    7:*/		return 0x820EE138;
		  /* 820EE138h */ case    8:  		/* cmplw CR6, R8, R19 */
		/* 820EE138h case    8:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R19);
		/* 820EE138h case    8:*/		return 0x820EE13C;
		  /* 820EE13Ch */ case    9:  		/* bc 4, CR6_LT, 608 */
		/* 820EE13Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x820EE39C;  }
		/* 820EE13Ch case    9:*/		return 0x820EE140;
	}
	return 0x820EE140;
} // Block from 820EE118h-820EE140h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EE140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE140);
		  /* 820EE140h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820EE140h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE140h case    0:*/		return 0x820EE144;
		  /* 820EE144h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820EE144h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EE150;  }
		/* 820EE144h case    1:*/		return 0x820EE148;
		  /* 820EE148h */ case    2:  		/* cmplw CR6, R8, R19 */
		/* 820EE148h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R19);
		/* 820EE148h case    2:*/		return 0x820EE14C;
		  /* 820EE14Ch */ case    3:  		/* bc 4, CR6_LT, 92 */
		/* 820EE14Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x820EE1A8;  }
		/* 820EE14Ch case    3:*/		return 0x820EE150;
	}
	return 0x820EE150;
} // Block from 820EE140h-820EE150h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE150);
		  /* 820EE150h */ case    0:  		/* mulli R10, R8, 12 */
		/* 820EE150h case    0:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R8,0xC);
		/* 820EE150h case    0:*/		return 0x820EE154;
		  /* 820EE154h */ case    1:  		/* add R31, R10, R17 */
		/* 820EE154h case    1:*/		cpu::op::add<0>(regs,&regs.R31,regs.R10,regs.R17);
		/* 820EE154h case    1:*/		return 0x820EE158;
		  /* 820EE158h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820EE158h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE158h case    2:*/		return 0x820EE15C;
		  /* 820EE15Ch */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 820EE15Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820EE190;  }
		/* 820EE15Ch case    3:*/		return 0x820EE160;
		  /* 820EE160h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 820EE160h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EE160h case    4:*/		return 0x820EE164;
		  /* 820EE164h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820EE164h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE164h case    5:*/		return 0x820EE168;
	}
	return 0x820EE168;
} // Block from 820EE150h-820EE168h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EE168h
// Function '?CalcNumExtraSymbolTableEntries@CShaderProgram@D3DXShader@@MAAIXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE168);
		  /* 820EE168h */ case    0:  		/* bc 12, CR6_EQ, 40 */
		/* 820EE168h case    0:*/		if ( regs.CR[6].eq ) { return 0x820EE190;  }
		/* 820EE168h case    0:*/		return 0x820EE16C;
		  /* 820EE16Ch */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 820EE16Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820EE16Ch case    1:*/		return 0x820EE170;
		  /* 820EE170h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 820EE170h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820EE170h case    2:*/		return 0x820EE174;
		  /* 820EE174h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 820EE174h case    3:*/		if ( regs.CR[6].eq ) { return 0x820EE190;  }
		/* 820EE174h case    3:*/		return 0x820EE178;
		  /* 820EE178h */ case    4:  		/* mr R6, R23 */
		/* 820EE178h case    4:*/		regs.R6 = regs.R23;
		/* 820EE178h case    4:*/		return 0x820EE17C;
		  /* 820EE17Ch */ case    5:  		/* extsb R7, R16 */
		/* 820EE17Ch case    5:*/		cpu::op::extsb<0>(regs,&regs.R7,regs.R16);
		/* 820EE17Ch case    5:*/		return 0x820EE180;
		  /* 820EE180h */ case    6:  		/* li R5, 4500 */
		/* 820EE180h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1194);
		/* 820EE180h case    6:*/		return 0x820EE184;
		  /* 820EE184h */ case    7:  		/* li R4, 0 */
		/* 820EE184h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820EE184h case    7:*/		return 0x820EE188;
		  /* 820EE188h */ case    8:  		/* mr R3, R25 */
		/* 820EE188h case    8:*/		regs.R3 = regs.R25;
		/* 820EE188h case    8:*/		return 0x820EE18C;
		  /* 820EE18Ch */ case    9:  		/* bl 132516 */
		/* 820EE18Ch case    9:*/		regs.LR = 0x820EE190; return 0x8210E730;
		/* 820EE18Ch case    9:*/		return 0x820EE190;
	}
	return 0x820EE190;
} // Block from 820EE168h-820EE190h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EE190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE190);
		  /* 820EE190h */ case    0:  		/* stw R26, <#[R31]> */
		/* 820EE190h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000000) );
		/* 820EE190h case    0:*/		return 0x820EE194;
		  /* 820EE194h */ case    1:  		/* stw R29, <#[R31 + 4]> */
		/* 820EE194h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 820EE194h case    1:*/		return 0x820EE198;
	}
	return 0x820EE198;
} // Block from 820EE190h-820EE198h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EE198h
// Function '?AddUserOffsetInfo@CShaderProgram@D3DXShader@@MAAJPAVCNodeVariable@2@PAU_D3DXSHADER_CONSTANTINFO@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE198);
		  /* 820EE198h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820EE198h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820EE198h case    0:*/		return 0x820EE19C;
		  /* 820EE19Ch */ case    1:  		/* rlwinm. R11, R11, 0, 3, 3 */
		/* 820EE19Ch case    1:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R11);
		/* 820EE19Ch case    1:*/		return 0x820EE1A0;
		  /* 820EE1A0h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 820EE1A0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820EE1A8;  }
		/* 820EE1A0h case    2:*/		return 0x820EE1A4;
		  /* 820EE1A4h */ case    3:  		/* stw R20, <#[R31 + 8]> */
		/* 820EE1A4h case    3:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R31 + 0x00000008) );
		/* 820EE1A4h case    3:*/		return 0x820EE1A8;
	}
	return 0x820EE1A8;
} // Block from 820EE198h-820EE1A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE1A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE1A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE1A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE1A8);
		  /* 820EE1A8h */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 820EE1A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820EE1A8h case    0:*/		return 0x820EE1AC;
		  /* 820EE1ACh */ case    1:  		/* addi R29, R29, 1 */
		/* 820EE1ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820EE1ACh case    1:*/		return 0x820EE1B0;
		  /* 820EE1B0h */ case    2:  		/* cmplw CR6, R29, R11 */
		/* 820EE1B0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820EE1B0h case    2:*/		return 0x820EE1B4;
		  /* 820EE1B4h */ case    3:  		/* bc 12, CR6_LT, -252 */
		/* 820EE1B4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EE0B8;  }
		/* 820EE1B4h case    3:*/		return 0x820EE1B8;
	}
	return 0x820EE1B8;
} // Block from 820EE1A8h-820EE1B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE1B8);
		  /* 820EE1B8h */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 820EE1B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820EE1B8h case    0:*/		return 0x820EE1BC;
		  /* 820EE1BCh */ case    1:  		/* addi R26, R26, 1 */
		/* 820EE1BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820EE1BCh case    1:*/		return 0x820EE1C0;
		  /* 820EE1C0h */ case    2:  		/* addi R24, R24, 4 */
		/* 820EE1C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 820EE1C0h case    2:*/		return 0x820EE1C4;
		  /* 820EE1C4h */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 820EE1C4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 820EE1C4h case    3:*/		return 0x820EE1C8;
		  /* 820EE1C8h */ case    4:  		/* bc 12, CR6_LT, -640 */
		/* 820EE1C8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EDF48;  }
		/* 820EE1C8h case    4:*/		return 0x820EE1CC;
	}
	return 0x820EE1CC;
} // Block from 820EE1B8h-820EE1CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EE1CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE1CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE1CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE1CC);
		  /* 820EE1CCh */ case    0:  		/* mr R5, R22 */
		/* 820EE1CCh case    0:*/		regs.R5 = regs.R22;
		/* 820EE1CCh case    0:*/		return 0x820EE1D0;
		  /* 820EE1D0h */ case    1:  		/* mr R6, R22 */
		/* 820EE1D0h case    1:*/		regs.R6 = regs.R22;
		/* 820EE1D0h case    1:*/		return 0x820EE1D4;
		  /* 820EE1D4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820EE1D4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE1D4h case    2:*/		return 0x820EE1D8;
		  /* 820EE1D8h */ case    3:  		/* bc 12, CR6_EQ, 88 */
		/* 820EE1D8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820EE230;  }
		/* 820EE1D8h case    3:*/		return 0x820EE1DC;
		  /* 820EE1DCh */ case    4:  		/* lwz R7, <#[R25 + 16]> */
		/* 820EE1DCh case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000010) );
		/* 820EE1DCh case    4:*/		return 0x820EE1E0;
		  /* 820EE1E0h */ case    5:  		/* mr R9, R22 */
		/* 820EE1E0h case    5:*/		regs.R9 = regs.R22;
		/* 820EE1E0h case    5:*/		return 0x820EE1E4;
		  /* 820EE1E4h */ case    6:  		/* lwzx R8, <#[R7 + R9]> */
		/* 820EE1E4h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 820EE1E4h case    6:*/		return 0x820EE1E8;
		  /* 820EE1E8h */ case    7:  		/* lwz R10, <#[R8 + 4]> */
		/* 820EE1E8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 820EE1E8h case    7:*/		return 0x820EE1EC;
		  /* 820EE1ECh */ case    8:  		/* and R4, R10, R18 */
		/* 820EE1ECh case    8:*/		cpu::op::and<0>(regs,&regs.R4,regs.R10,regs.R18);
		/* 820EE1ECh case    8:*/		return 0x820EE1F0;
		  /* 820EE1F0h */ case    9:  		/* cmplw CR6, R4, R18 */
		/* 820EE1F0h case    9:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R18);
		/* 820EE1F0h case    9:*/		return 0x820EE1F4;
		  /* 820EE1F4h */ case   10:  		/* bc 4, CR6_EQ, 44 */
		/* 820EE1F4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820EE220;  }
		/* 820EE1F4h case   10:*/		return 0x820EE1F8;
		  /* 820EE1F8h */ case   11:  		/* and. R4, R10, R15 */
		/* 820EE1F8h case   11:*/		cpu::op::and<1>(regs,&regs.R4,regs.R10,regs.R15);
		/* 820EE1F8h case   11:*/		return 0x820EE1FC;
		  /* 820EE1FCh */ case   12:  		/* bc 4, CR0_EQ, 36 */
		/* 820EE1FCh case   12:*/		if ( !regs.CR[0].eq ) { return 0x820EE220;  }
		/* 820EE1FCh case   12:*/		return 0x820EE200;
		  /* 820EE200h */ case   13:  		/* rlwinm. R4, R10, 0, 25, 25 */
		/* 820EE200h case   13:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R4,regs.R10);
		/* 820EE200h case   13:*/		return 0x820EE204;
		  /* 820EE204h */ case   14:  		/* bc 12, CR0_EQ, 28 */
		/* 820EE204h case   14:*/		if ( regs.CR[0].eq ) { return 0x820EE220;  }
		/* 820EE204h case   14:*/		return 0x820EE208;
		  /* 820EE208h */ case   15:  		/* rlwinm. R10, R10, 0, 20, 20 */
		/* 820EE208h case   15:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R10);
		/* 820EE208h case   15:*/		return 0x820EE20C;
		  /* 820EE20Ch */ case   16:  		/* bc 4, CR0_EQ, 20 */
		/* 820EE20Ch case   16:*/		if ( !regs.CR[0].eq ) { return 0x820EE220;  }
		/* 820EE20Ch case   16:*/		return 0x820EE210;
		  /* 820EE210h */ case   17:  		/* lwz R10, <#[R8 + 8]> */
		/* 820EE210h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000008) );
		/* 820EE210h case   17:*/		return 0x820EE214;
		  /* 820EE214h */ case   18:  		/* cmplwi CR6, R10, 0 */
		/* 820EE214h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820EE214h case   18:*/		return 0x820EE218;
		  /* 820EE218h */ case   19:  		/* bc 12, CR6_EQ, 8 */
		/* 820EE218h case   19:*/		if ( regs.CR[6].eq ) { return 0x820EE220;  }
		/* 820EE218h case   19:*/		return 0x820EE21C;
		  /* 820EE21Ch */ case   20:  		/* addi R5, R5, 1 */
		/* 820EE21Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820EE21Ch case   20:*/		return 0x820EE220;
	}
	return 0x820EE220;
} // Block from 820EE1CCh-820EE220h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820EE220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE220);
		  /* 820EE220h */ case    0:  		/* addi R6, R6, 1 */
		/* 820EE220h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820EE220h case    0:*/		return 0x820EE224;
		  /* 820EE224h */ case    1:  		/* addi R9, R9, 4 */
		/* 820EE224h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820EE224h case    1:*/		return 0x820EE228;
		  /* 820EE228h */ case    2:  		/* cmplw CR6, R6, R11 */
		/* 820EE228h case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820EE228h case    2:*/		return 0x820EE22C;
		  /* 820EE22Ch */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 820EE22Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820EE1E4;  }
		/* 820EE22Ch case    3:*/		return 0x820EE230;
	}
	return 0x820EE230;
} // Block from 820EE220h-820EE230h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE230);
		  /* 820EE230h */ case    0:  		/* lis R4, 9345 */
		/* 820EE230h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820EE230h case    0:*/		return 0x820EE234;
		  /* 820EE234h */ case    1:  		/* rlwinm R3, R5, 2, 0, 29 */
		/* 820EE234h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R5);
		/* 820EE234h case    1:*/		return 0x820EE238;
		  /* 820EE238h */ case    2:  		/* bl -417848 */
		/* 820EE238h case    2:*/		regs.LR = 0x820EE23C; return 0x82088200;
		/* 820EE238h case    2:*/		return 0x820EE23C;
		  /* 820EE23Ch */ case    3:  		/* stw R3, <#[R1 + 80]> */
		/* 820EE23Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820EE23Ch case    3:*/		return 0x820EE240;
		  /* 820EE240h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820EE240h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EE240h case    4:*/		return 0x820EE244;
		  /* 820EE244h */ case    5:  		/* bc 12, CR0_EQ, 1436 */
		/* 820EE244h case    5:*/		if ( regs.CR[0].eq ) { return 0x820EE7E0;  }
		/* 820EE244h case    5:*/		return 0x820EE248;
		  /* 820EE248h */ case    6:  		/* lwz R11, <#[R25 + 4]> */
		/* 820EE248h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820EE248h case    6:*/		return 0x820EE24C;
		  /* 820EE24Ch */ case    7:  		/* mr R31, R22 */
		/* 820EE24Ch case    7:*/		regs.R31 = regs.R22;
		/* 820EE24Ch case    7:*/		return 0x820EE250;
		  /* 820EE250h */ case    8:  		/* mr R8, R22 */
		/* 820EE250h case    8:*/		regs.R8 = regs.R22;
		/* 820EE250h case    8:*/		return 0x820EE254;
		  /* 820EE254h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820EE254h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE254h case    9:*/		return 0x820EE258;
		  /* 820EE258h */ case   10:  		/* rlwinm R30, R3, 0, 0, 31 */
		/* 820EE258h case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R30,regs.R3);
		/* 820EE258h case   10:*/		return 0x820EE25C;
		  /* 820EE25Ch */ case   11:  		/* bc 4, CR6_GT, 100 */
		/* 820EE25Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x820EE2C0;  }
		/* 820EE25Ch case   11:*/		return 0x820EE260;
		  /* 820EE260h */ case   12:  		/* mr R10, R22 */
		/* 820EE260h case   12:*/		regs.R10 = regs.R22;
		/* 820EE260h case   12:*/		return 0x820EE264;
		  /* 820EE264h */ case   13:  		/* addi R7, R30, -4 */
		/* 820EE264h case   13:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R30,0xFFFFFFFC);
		/* 820EE264h case   13:*/		return 0x820EE268;
		  /* 820EE268h */ case   14:  		/* lwz R11, <#[R25 + 16]> */
		/* 820EE268h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 820EE268h case   14:*/		return 0x820EE26C;
		  /* 820EE26Ch */ case   15:  		/* lwzx R9, <#[R11 + R10]> */
		/* 820EE26Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EE26Ch case   15:*/		return 0x820EE270;
		  /* 820EE270h */ case   16:  		/* lwz R11, <#[R9 + 4]> */
		/* 820EE270h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 820EE270h case   16:*/		return 0x820EE274;
		  /* 820EE274h */ case   17:  		/* and R6, R11, R18 */
		/* 820EE274h case   17:*/		cpu::op::and<0>(regs,&regs.R6,regs.R11,regs.R18);
		/* 820EE274h case   17:*/		return 0x820EE278;
		  /* 820EE278h */ case   18:  		/* cmplw CR6, R6, R18 */
		/* 820EE278h case   18:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R18);
		/* 820EE278h case   18:*/		return 0x820EE27C;
		  /* 820EE27Ch */ case   19:  		/* bc 4, CR6_EQ, 48 */
		/* 820EE27Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x820EE2AC;  }
		/* 820EE27Ch case   19:*/		return 0x820EE280;
		  /* 820EE280h */ case   20:  		/* and. R6, R11, R15 */
		/* 820EE280h case   20:*/		cpu::op::and<1>(regs,&regs.R6,regs.R11,regs.R15);
		/* 820EE280h case   20:*/		return 0x820EE284;
		  /* 820EE284h */ case   21:  		/* bc 4, CR0_EQ, 40 */
		/* 820EE284h case   21:*/		if ( !regs.CR[0].eq ) { return 0x820EE2AC;  }
		/* 820EE284h case   21:*/		return 0x820EE288;
		  /* 820EE288h */ case   22:  		/* rlwinm. R6, R11, 0, 25, 25 */
		/* 820EE288h case   22:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R6,regs.R11);
		/* 820EE288h case   22:*/		return 0x820EE28C;
		  /* 820EE28Ch */ case   23:  		/* bc 12, CR0_EQ, 32 */
		/* 820EE28Ch case   23:*/		if ( regs.CR[0].eq ) { return 0x820EE2AC;  }
		/* 820EE28Ch case   23:*/		return 0x820EE290;
		  /* 820EE290h */ case   24:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 820EE290h case   24:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 820EE290h case   24:*/		return 0x820EE294;
		  /* 820EE294h */ case   25:  		/* bc 4, CR0_EQ, 24 */
		/* 820EE294h case   25:*/		if ( !regs.CR[0].eq ) { return 0x820EE2AC;  }
		/* 820EE294h case   25:*/		return 0x820EE298;
		  /* 820EE298h */ case   26:  		/* lwz R11, <#[R9 + 8]> */
		/* 820EE298h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 820EE298h case   26:*/		return 0x820EE29C;
		  /* 820EE29Ch */ case   27:  		/* cmplwi CR6, R11, 0 */
		/* 820EE29Ch case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE29Ch case   27:*/		return 0x820EE2A0;
		  /* 820EE2A0h */ case   28:  		/* bc 12, CR6_EQ, 12 */
		/* 820EE2A0h case   28:*/		if ( regs.CR[6].eq ) { return 0x820EE2AC;  }
		/* 820EE2A0h case   28:*/		return 0x820EE2A4;
		  /* 820EE2A4h */ case   29:  		/* stwu R8, <#[R7 + 4]> */
		/* 820EE2A4h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820EE2A4h case   29:*/		return 0x820EE2A8;
		  /* 820EE2A8h */ case   30:  		/* addi R31, R31, 1 */
		/* 820EE2A8h case   30:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820EE2A8h case   30:*/		return 0x820EE2AC;
	}
	return 0x820EE2AC;
} // Block from 820EE230h-820EE2ACh (31 instructions)

//////////////////////////////////////////////////////
// Block at 820EE2ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE2AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE2AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE2AC);
		  /* 820EE2ACh */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 820EE2ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820EE2ACh case    0:*/		return 0x820EE2B0;
		  /* 820EE2B0h */ case    1:  		/* addi R8, R8, 1 */
		/* 820EE2B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820EE2B0h case    1:*/		return 0x820EE2B4;
		  /* 820EE2B4h */ case    2:  		/* addi R10, R10, 4 */
		/* 820EE2B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EE2B4h case    2:*/		return 0x820EE2B8;
		  /* 820EE2B8h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 820EE2B8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820EE2B8h case    3:*/		return 0x820EE2BC;
		  /* 820EE2BCh */ case    4:  		/* bc 12, CR6_LT, -84 */
		/* 820EE2BCh case    4:*/		if ( regs.CR[6].lt ) { return 0x820EE268;  }
		/* 820EE2BCh case    4:*/		return 0x820EE2C0;
	}
	return 0x820EE2C0;
} // Block from 820EE2ACh-820EE2C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EE2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE2C0);
		  /* 820EE2C0h */ case    0:  		/* lis R11, -32242 */
		/* 820EE2C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820E);
		/* 820EE2C0h case    0:*/		return 0x820EE2C4;
		  /* 820EE2C4h */ case    1:  		/* mr R6, R25 */
		/* 820EE2C4h case    1:*/		regs.R6 = regs.R25;
		/* 820EE2C4h case    1:*/		return 0x820EE2C8;
		  /* 820EE2C8h */ case    2:  		/* mr R5, R31 */
		/* 820EE2C8h case    2:*/		regs.R5 = regs.R31;
		/* 820EE2C8h case    2:*/		return 0x820EE2CC;
		  /* 820EE2CCh */ case    3:  		/* mr R4, R30 */
		/* 820EE2CCh case    3:*/		regs.R4 = regs.R30;
		/* 820EE2CCh case    3:*/		return 0x820EE2D0;
		  /* 820EE2D0h */ case    4:  		/* addi R3, R11, 14480 */
		/* 820EE2D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x3890);
		/* 820EE2D0h case    4:*/		return 0x820EE2D4;
		  /* 820EE2D4h */ case    5:  		/* bl 64460 */
		/* 820EE2D4h case    5:*/		regs.LR = 0x820EE2D8; return 0x820FDEA0;
		/* 820EE2D4h case    5:*/		return 0x820EE2D8;
		  /* 820EE2D8h */ case    6:  		/* mr R3, R22 */
		/* 820EE2D8h case    6:*/		regs.R3 = regs.R22;
		/* 820EE2D8h case    6:*/		return 0x820EE2DC;
		  /* 820EE2DCh */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 820EE2DCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820EE2DCh case    7:*/		return 0x820EE2E0;
		  /* 820EE2E0h */ case    8:  		/* bc 12, CR6_EQ, 536 */
		/* 820EE2E0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EE4F8;  }
		/* 820EE2E0h case    8:*/		return 0x820EE2E4;
		  /* 820EE2E4h */ case    9:  		/* mr R4, R30 */
		/* 820EE2E4h case    9:*/		regs.R4 = regs.R30;
		/* 820EE2E4h case    9:*/		return 0x820EE2E8;
		  /* 820EE2E8h */ case   10:  		/* lwz R11, <#[R4]> */
		/* 820EE2E8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820EE2E8h case   10:*/		return 0x820EE2EC;
		  /* 820EE2ECh */ case   11:  		/* mr R10, R22 */
		/* 820EE2ECh case   11:*/		regs.R10 = regs.R22;
		/* 820EE2ECh case   11:*/		return 0x820EE2F0;
		  /* 820EE2F0h */ case   12:  		/* lwz R9, <#[R25 + 16]> */
		/* 820EE2F0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000010) );
		/* 820EE2F0h case   12:*/		return 0x820EE2F4;
		  /* 820EE2F4h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EE2F4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EE2F4h case   13:*/		return 0x820EE2F8;
		  /* 820EE2F8h */ case   14:  		/* lwzx R5, <#[R11 + R9]> */
		/* 820EE2F8h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EE2F8h case   14:*/		return 0x820EE2FC;
		  /* 820EE2FCh */ case   15:  		/* lwz R11, <#[R5 + 4]> */
		/* 820EE2FCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 820EE2FCh case   15:*/		return 0x820EE300;
		  /* 820EE300h */ case   16:  		/* rlwinm. R9, R11, 0, 23, 23 */
		/* 820EE300h case   16:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R11);
		/* 820EE300h case   16:*/		return 0x820EE304;
		  /* 820EE304h */ case   17:  		/* bc 12, CR0_EQ, 16 */
		/* 820EE304h case   17:*/		if ( regs.CR[0].eq ) { return 0x820EE314;  }
		/* 820EE304h case   17:*/		return 0x820EE308;
		  /* 820EE308h */ case   18:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 820EE308h case   18:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 820EE308h case   18:*/		return 0x820EE30C;
		  /* 820EE30Ch */ case   19:  		/* mr R11, R20 */
		/* 820EE30Ch case   19:*/		regs.R11 = regs.R20;
		/* 820EE30Ch case   19:*/		return 0x820EE310;
		  /* 820EE310h */ case   20:  		/* bc 4, CR0_EQ, 8 */
		/* 820EE310h case   20:*/		if ( !regs.CR[0].eq ) { return 0x820EE318;  }
		/* 820EE310h case   20:*/		return 0x820EE314;
	}
	return 0x820EE314;
} // Block from 820EE2C0h-820EE314h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820EE314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE314);
		  /* 820EE314h */ case    0:  		/* mr R11, R22 */
		/* 820EE314h case    0:*/		regs.R11 = regs.R22;
		/* 820EE314h case    0:*/		return 0x820EE318;
	}
	return 0x820EE318;
} // Block from 820EE314h-820EE318h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EE318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE318);
		  /* 820EE318h */ case    0:  		/* rlwinm R6, R11, 0, 24, 31 */
		/* 820EE318h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R6,regs.R11);
		/* 820EE318h case    0:*/		return 0x820EE31C;
		  /* 820EE31Ch */ case    1:  		/* cmplwi CR6, R19, 0 */
		/* 820EE31Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820EE31Ch case    1:*/		return 0x820EE320;
		  /* 820EE320h */ case    2:  		/* bc 12, CR6_EQ, 356 */
		/* 820EE320h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EE484;  }
		/* 820EE320h case    2:*/		return 0x820EE324;
		  /* 820EE324h */ case    3:  		/* lwz R7, <#[R5 + 8]> */
		/* 820EE324h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000008) );
		/* 820EE324h case    3:*/		return 0x820EE328;
		  /* 820EE328h */ case    4:  		/* cmplw CR6, R10, R19 */
		/* 820EE328h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R19);
		/* 820EE328h case    4:*/		return 0x820EE32C;
		  /* 820EE32Ch */ case    5:  		/* bc 4, CR6_LT, 252 */
		/* 820EE32Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x820EE428;  }
		/* 820EE32Ch case    5:*/		return 0x820EE330;
		  /* 820EE330h */ case    6:  		/* rlwinm R9, R6, 0, 24, 31 */
		/* 820EE330h case    6:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R6);
		/* 820EE330h case    6:*/		return 0x820EE334;
		  /* 820EE334h */ case    7:  		/* cmplwi CR6, R9, 0 */
		/* 820EE334h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820EE334h case    7:*/		return 0x820EE338;
		  /* 820EE338h */ case    8:  		/* bc 12, CR6_EQ, 208 */
		/* 820EE338h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EE408;  }
		/* 820EE338h case    8:*/		return 0x820EE33C;
		  /* 820EE33Ch */ case    9:  		/* subf R11, R10, R19 */
		/* 820EE33Ch case    9:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R19);
		/* 820EE33Ch case    9:*/		return 0x820EE340;
		  /* 820EE340h */ case   10:  		/* addi R11, R11, -1 */
		/* 820EE340h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820EE340h case   10:*/		return 0x820EE344;
		  /* 820EE344h */ case   11:  		/* b 200 */
		/* 820EE344h case   11:*/		return 0x820EE40C;
		/* 820EE344h case   11:*/		return 0x820EE348;
	}
	return 0x820EE348;
} // Block from 820EE318h-820EE348h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820EE348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE348);
		  /* 820EE348h */ case    0:  		/* mr R4, R22 */
		/* 820EE348h case    0:*/		regs.R4 = regs.R22;
		/* 820EE348h case    0:*/		return 0x820EE34C;
	}
	return 0x820EE34C;
} // Block from 820EE348h-820EE34Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EE34Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE34C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE34C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE34C);
		  /* 820EE34Ch */ case    0:  		/* lis R11, -32254 */
		/* 820EE34Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EE34Ch case    0:*/		return 0x820EE350;
		  /* 820EE350h */ case    1:  		/* lwz R7, <#[R27]> */
		/* 820EE350h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R27 + 0x00000000) );
		/* 820EE350h case    1:*/		return 0x820EE354;
		  /* 820EE354h */ case    2:  		/* li R5, 4556 */
		/* 820EE354h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x11CC);
		/* 820EE354h case    2:*/		return 0x820EE358;
		  /* 820EE358h */ case    3:  		/* addi R6, R11, -16628 */
		/* 820EE358h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBF0C);
		/* 820EE358h case    3:*/		return 0x820EE35C;
		  /* 820EE35Ch */ case    4:  		/* mr R3, R25 */
		/* 820EE35Ch case    4:*/		regs.R3 = regs.R25;
		/* 820EE35Ch case    4:*/		return 0x820EE360;
		  /* 820EE360h */ case    5:  		/* bl 132048 */
		/* 820EE360h case    5:*/		regs.LR = 0x820EE364; return 0x8210E730;
		/* 820EE360h case    5:*/		return 0x820EE364;
		  /* 820EE364h */ case    6:  		/* b 1368 */
		/* 820EE364h case    6:*/		return 0x820EE8BC;
		/* 820EE364h case    6:*/		return 0x820EE368;
	}
	return 0x820EE368;
} // Block from 820EE34Ch-820EE368h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EE368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE368);
		  /* 820EE368h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820EE368h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EE368h case    0:*/		return 0x820EE36C;
		  /* 820EE36Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820EE36Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820EE378;  }
		/* 820EE36Ch case    1:*/		return 0x820EE370;
		  /* 820EE370h */ case    2:  		/* lwz R4, <#[R28 + 96]> */
		/* 820EE370h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000060) );
		/* 820EE370h case    2:*/		return 0x820EE374;
		  /* 820EE374h */ case    3:  		/* b 8 */
		/* 820EE374h case    3:*/		return 0x820EE37C;
		/* 820EE374h case    3:*/		return 0x820EE378;
	}
	return 0x820EE378;
} // Block from 820EE368h-820EE378h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE378);
		  /* 820EE378h */ case    0:  		/* mr R4, R22 */
		/* 820EE378h case    0:*/		regs.R4 = regs.R22;
		/* 820EE378h case    0:*/		return 0x820EE37C;
	}
	return 0x820EE37C;
} // Block from 820EE378h-820EE37Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EE37Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE37C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE37C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE37C);
		  /* 820EE37Ch */ case    0:  		/* lis R11, -32254 */
		/* 820EE37Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EE37Ch case    0:*/		return 0x820EE380;
		  /* 820EE380h */ case    1:  		/* lwz R7, <#[R27]> */
		/* 820EE380h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R27 + 0x00000000) );
		/* 820EE380h case    1:*/		return 0x820EE384;
		  /* 820EE384h */ case    2:  		/* extsb R8, R16 */
		/* 820EE384h case    2:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R16);
		/* 820EE384h case    2:*/		return 0x820EE388;
	}
	return 0x820EE388;
} // Block from 820EE37Ch-820EE388h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EE388h
// Function '?FindSemantic@CShaderProgram@D3DXShader@@IAAPAUD3DX_SEMANTIC@2@PAU32@K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE388);
		  /* 820EE388h */ case    0:  		/* addi R6, R11, -16744 */
		/* 820EE388h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBE98);
		/* 820EE388h case    0:*/		return 0x820EE38C;
		  /* 820EE38Ch */ case    1:  		/* li R5, 4509 */
		/* 820EE38Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x119D);
		/* 820EE38Ch case    1:*/		return 0x820EE390;
		  /* 820EE390h */ case    2:  		/* mr R3, R25 */
		/* 820EE390h case    2:*/		regs.R3 = regs.R25;
		/* 820EE390h case    2:*/		return 0x820EE394;
		  /* 820EE394h */ case    3:  		/* bl 131996 */
		/* 820EE394h case    3:*/		regs.LR = 0x820EE398; return 0x8210E730;
		/* 820EE394h case    3:*/		return 0x820EE398;
		  /* 820EE398h */ case    4:  		/* b 1176 */
		/* 820EE398h case    4:*/		return 0x820EE830;
		/* 820EE398h case    4:*/		return 0x820EE39C;
	}
	return 0x820EE39C;
} // Block from 820EE388h-820EE39Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EE39Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE39C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE39C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE39C);
		  /* 820EE39Ch */ case    0:  		/* extsb R11, R16 */
		/* 820EE39Ch case    0:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R16);
		/* 820EE39Ch case    0:*/		return 0x820EE3A0;
		  /* 820EE3A0h */ case    1:  		/* cmpwi CR6, R11, 98 */
		/* 820EE3A0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000062);
		/* 820EE3A0h case    1:*/		return 0x820EE3A4;
		  /* 820EE3A4h */ case    2:  		/* bc 12, CR6_EQ, 84 */
		/* 820EE3A4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EE3F8;  }
		/* 820EE3A4h case    2:*/		return 0x820EE3A8;
		  /* 820EE3A8h */ case    3:  		/* cmpwi CR6, R11, 99 */
		/* 820EE3A8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000063);
		/* 820EE3A8h case    3:*/		return 0x820EE3AC;
		  /* 820EE3ACh */ case    4:  		/* bc 12, CR6_EQ, 60 */
		/* 820EE3ACh case    4:*/		if ( regs.CR[6].eq ) { return 0x820EE3E8;  }
		/* 820EE3ACh case    4:*/		return 0x820EE3B0;
	}
	return 0x820EE3B0;
} // Block from 820EE39Ch-820EE3B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EE3B0h
// Function '??0CShaderProgram@D3DXShader@@QAA@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE3B0);
		  /* 820EE3B0h */ case    0:  		/* cmpwi CR6, R11, 105 */
		/* 820EE3B0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000069);
		/* 820EE3B0h case    0:*/		return 0x820EE3B4;
		  /* 820EE3B4h */ case    1:  		/* bc 12, CR6_EQ, 796 */
		/* 820EE3B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EE6D0;  }
		/* 820EE3B4h case    1:*/		return 0x820EE3B8;
		  /* 820EE3B8h */ case    2:  		/* cmpwi CR6, R11, 115 */
		/* 820EE3B8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000073);
		/* 820EE3B8h case    2:*/		return 0x820EE3BC;
		  /* 820EE3BCh */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 820EE3BCh case    3:*/		if ( regs.CR[6].eq ) { return 0x820EE3D8;  }
		/* 820EE3BCh case    3:*/		return 0x820EE3C0;
		  /* 820EE3C0h */ case    4:  		/* cmpwi CR6, R11, 118 */
		/* 820EE3C0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000076);
		/* 820EE3C0h case    4:*/		return 0x820EE3C4;
		  /* 820EE3C4h */ case    5:  		/* bc 4, CR6_EQ, 1132 */
		/* 820EE3C4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820EE830;  }
		/* 820EE3C4h case    5:*/		return 0x820EE3C8;
		  /* 820EE3C8h */ case    6:  		/* lis R11, -32254 */
		/* 820EE3C8h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EE3C8h case    6:*/		return 0x820EE3CC;
		  /* 820EE3CCh */ case    7:  		/* li R5, 4506 */
		/* 820EE3CCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x119A);
		/* 820EE3CCh case    7:*/		return 0x820EE3D0;
		  /* 820EE3D0h */ case    8:  		/* addi R6, R11, -17768 */
		/* 820EE3D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBA98);
		/* 820EE3D0h case    8:*/		return 0x820EE3D4;
		  /* 820EE3D4h */ case    9:  		/* b 1104 */
		/* 820EE3D4h case    9:*/		return 0x820EE824;
		/* 820EE3D4h case    9:*/		return 0x820EE3D8;
	}
	return 0x820EE3D8;
} // Block from 820EE3B0h-820EE3D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EE3D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE3D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE3D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE3D8);
		  /* 820EE3D8h */ case    0:  		/* li R5, 4510 */
		/* 820EE3D8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x119E);
		/* 820EE3D8h case    0:*/		return 0x820EE3DC;
		  /* 820EE3DCh */ case    1:  		/* lis R11, -32254 */
		/* 820EE3DCh case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EE3DCh case    1:*/		return 0x820EE3E0;
		  /* 820EE3E0h */ case    2:  		/* addi R6, R11, -17596 */
		/* 820EE3E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBB44);
		/* 820EE3E0h case    2:*/		return 0x820EE3E4;
		  /* 820EE3E4h */ case    3:  		/* b 1088 */
		/* 820EE3E4h case    3:*/		return 0x820EE824;
		/* 820EE3E4h case    3:*/		return 0x820EE3E8;
	}
	return 0x820EE3E8;
} // Block from 820EE3D8h-820EE3E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE3E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE3E8);
		  /* 820EE3E8h */ case    0:  		/* lis R11, -32254 */
		/* 820EE3E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EE3E8h case    0:*/		return 0x820EE3EC;
		  /* 820EE3ECh */ case    1:  		/* li R5, 4507 */
		/* 820EE3ECh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x119B);
		/* 820EE3ECh case    1:*/		return 0x820EE3F0;
		  /* 820EE3F0h */ case    2:  		/* addi R6, R11, -17512 */
		/* 820EE3F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBB98);
		/* 820EE3F0h case    2:*/		return 0x820EE3F4;
		  /* 820EE3F4h */ case    3:  		/* b 1072 */
		/* 820EE3F4h case    3:*/		return 0x820EE824;
		/* 820EE3F4h case    3:*/		return 0x820EE3F8;
	}
	return 0x820EE3F8;
} // Block from 820EE3E8h-820EE3F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE3F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE3F8);
		  /* 820EE3F8h */ case    0:  		/* lis R11, -32254 */
		/* 820EE3F8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EE3F8h case    0:*/		return 0x820EE3FC;
		  /* 820EE3FCh */ case    1:  		/* li R5, 4550 */
		/* 820EE3FCh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x11C6);
		/* 820EE3FCh case    1:*/		return 0x820EE400;
		  /* 820EE400h */ case    2:  		/* addi R6, R11, -16832 */
		/* 820EE400h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBE40);
		/* 820EE400h case    2:*/		return 0x820EE404;
		  /* 820EE404h */ case    3:  		/* b 1056 */
		/* 820EE404h case    3:*/		return 0x820EE824;
		/* 820EE404h case    3:*/		return 0x820EE408;
	}
	return 0x820EE408;
} // Block from 820EE3F8h-820EE408h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE408);
		  /* 820EE408h */ case    0:  		/* mr R11, R10 */
		/* 820EE408h case    0:*/		regs.R11 = regs.R10;
		/* 820EE408h case    0:*/		return 0x820EE40C;
	}
	return 0x820EE40C;
} // Block from 820EE408h-820EE40Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EE40Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE40C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE40C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE40C);
		  /* 820EE40Ch */ case    0:  		/* mulli R11, R11, 12 */
		/* 820EE40Ch case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 820EE40Ch case    0:*/		return 0x820EE410;
		  /* 820EE410h */ case    1:  		/* lwzx R11, <#[R11 + R17]> */
		/* 820EE410h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R17 + 0x00000000) );
		/* 820EE410h case    1:*/		return 0x820EE414;
		  /* 820EE414h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820EE414h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE414h case    2:*/		return 0x820EE418;
		  /* 820EE418h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 820EE418h case    3:*/		if ( regs.CR[6].eq ) { return 0x820EE428;  }
		/* 820EE418h case    3:*/		return 0x820EE41C;
		  /* 820EE41Ch */ case    4:  		/* addi R10, R10, 1 */
		/* 820EE41Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EE41Ch case    4:*/		return 0x820EE420;
		  /* 820EE420h */ case    5:  		/* cmplw CR6, R10, R19 */
		/* 820EE420h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R19);
		/* 820EE420h case    5:*/		return 0x820EE424;
		  /* 820EE424h */ case    6:  		/* bc 12, CR6_LT, -240 */
		/* 820EE424h case    6:*/		if ( regs.CR[6].lt ) { return 0x820EE334;  }
		/* 820EE424h case    6:*/		return 0x820EE428;
	}
	return 0x820EE428;
} // Block from 820EE40Ch-820EE428h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EE428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE428);
		  /* 820EE428h */ case    0:  		/* mr R11, R10 */
		/* 820EE428h case    0:*/		regs.R11 = regs.R10;
		/* 820EE428h case    0:*/		return 0x820EE42C;
		  /* 820EE42Ch */ case    1:  		/* cmplw CR6, R10, R19 */
		/* 820EE42Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R19);
		/* 820EE42Ch case    1:*/		return 0x820EE430;
		  /* 820EE430h */ case    2:  		/* bc 4, CR6_LT, 60 */
		/* 820EE430h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820EE46C;  }
		/* 820EE430h case    2:*/		return 0x820EE434;
		  /* 820EE434h */ case    3:  		/* rlwinm R8, R6, 0, 24, 31 */
		/* 820EE434h case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R8,regs.R6);
		/* 820EE434h case    3:*/		return 0x820EE438;
		  /* 820EE438h */ case    4:  		/* cmplwi CR6, R8, 0 */
		/* 820EE438h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820EE438h case    4:*/		return 0x820EE43C;
		  /* 820EE43Ch */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820EE43Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820EE44C;  }
		/* 820EE43Ch case    5:*/		return 0x820EE440;
		  /* 820EE440h */ case    6:  		/* subf R9, R11, R19 */
		/* 820EE440h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R19);
		/* 820EE440h case    6:*/		return 0x820EE444;
		  /* 820EE444h */ case    7:  		/* addi R9, R9, -1 */
		/* 820EE444h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 820EE444h case    7:*/		return 0x820EE448;
		  /* 820EE448h */ case    8:  		/* b 8 */
		/* 820EE448h case    8:*/		return 0x820EE450;
		/* 820EE448h case    8:*/		return 0x820EE44C;
	}
	return 0x820EE44C;
} // Block from 820EE428h-820EE44Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820EE44Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE44C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE44C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE44C);
		  /* 820EE44Ch */ case    0:  		/* mr R9, R11 */
		/* 820EE44Ch case    0:*/		regs.R9 = regs.R11;
		/* 820EE44Ch case    0:*/		return 0x820EE450;
	}
	return 0x820EE450;
} // Block from 820EE44Ch-820EE450h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EE450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE450);
		  /* 820EE450h */ case    0:  		/* mulli R9, R9, 12 */
		/* 820EE450h case    0:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R9,0xC);
		/* 820EE450h case    0:*/		return 0x820EE454;
		  /* 820EE454h */ case    1:  		/* lwzx R9, <#[R9 + R17]> */
		/* 820EE454h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R17 + 0x00000000) );
		/* 820EE454h case    1:*/		return 0x820EE458;
		  /* 820EE458h */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 820EE458h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820EE458h case    2:*/		return 0x820EE45C;
		  /* 820EE45Ch */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820EE45Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820EE46C;  }
		/* 820EE45Ch case    3:*/		return 0x820EE460;
		  /* 820EE460h */ case    4:  		/* addi R11, R11, 1 */
		/* 820EE460h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EE460h case    4:*/		return 0x820EE464;
		  /* 820EE464h */ case    5:  		/* cmplw CR6, R11, R19 */
		/* 820EE464h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 820EE464h case    5:*/		return 0x820EE468;
		  /* 820EE468h */ case    6:  		/* bc 12, CR6_LT, -48 */
		/* 820EE468h case    6:*/		if ( regs.CR[6].lt ) { return 0x820EE438;  }
		/* 820EE468h case    6:*/		return 0x820EE46C;
	}
	return 0x820EE46C;
} // Block from 820EE450h-820EE46Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EE46Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE46C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE46C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE46C);
		  /* 820EE46Ch */ case    0:  		/* subf R9, R10, R11 */
		/* 820EE46Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 820EE46Ch case    0:*/		return 0x820EE470;
		  /* 820EE470h */ case    1:  		/* cmplw CR6, R9, R7 */
		/* 820EE470h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 820EE470h case    1:*/		return 0x820EE474;
		  /* 820EE474h */ case    2:  		/* bc 4, CR6_LT, 16 */
		/* 820EE474h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820EE484;  }
		/* 820EE474h case    2:*/		return 0x820EE478;
		  /* 820EE478h */ case    3:  		/* mr R10, R11 */
		/* 820EE478h case    3:*/		regs.R10 = regs.R11;
		/* 820EE478h case    3:*/		return 0x820EE47C;
		  /* 820EE47Ch */ case    4:  		/* cmplw CR6, R11, R19 */
		/* 820EE47Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 820EE47Ch case    4:*/		return 0x820EE480;
		  /* 820EE480h */ case    5:  		/* bc 12, CR6_LT, -344 */
		/* 820EE480h case    5:*/		if ( regs.CR[6].lt ) { return 0x820EE328;  }
		/* 820EE480h case    5:*/		return 0x820EE484;
	}
	return 0x820EE484;
} // Block from 820EE46Ch-820EE484h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EE484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE484);
		  /* 820EE484h */ case    0:  		/* lwz R11, <#[R5 + 8]> */
		/* 820EE484h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 820EE484h case    0:*/		return 0x820EE488;
		  /* 820EE488h */ case    1:  		/* add R9, R11, R10 */
		/* 820EE488h case    1:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 820EE488h case    1:*/		return 0x820EE48C;
		  /* 820EE48Ch */ case    2:  		/* cmplw CR6, R9, R19 */
		/* 820EE48Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R19);
		/* 820EE48Ch case    2:*/		return 0x820EE490;
		  /* 820EE490h */ case    3:  		/* bc 12, CR6_GT, 524 */
		/* 820EE490h case    3:*/		if ( regs.CR[6].gt ) { return 0x820EE69C;  }
		/* 820EE490h case    3:*/		return 0x820EE494;
		  /* 820EE494h */ case    4:  		/* rlwinm. R9, R6, 0, 24, 31 */
		/* 820EE494h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R6);
		/* 820EE494h case    4:*/		return 0x820EE498;
		  /* 820EE498h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 820EE498h case    5:*/		if ( regs.CR[0].eq ) { return 0x820EE4AC;  }
		/* 820EE498h case    5:*/		return 0x820EE49C;
		  /* 820EE49Ch */ case    6:  		/* subf R10, R10, R19 */
		/* 820EE49Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R19);
		/* 820EE49Ch case    6:*/		return 0x820EE4A0;
	}
	return 0x820EE4A0;
} // Block from 820EE484h-820EE4A0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EE4A0h
// Function '??1CShaderProgram@D3DXShader@@UAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE4A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE4A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE4A0);
		  /* 820EE4A0h */ case    0:  		/* addi R10, R10, -1 */
		/* 820EE4A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820EE4A0h case    0:*/		return 0x820EE4A4;
		  /* 820EE4A4h */ case    1:  		/* subf R10, R11, R10 */
		/* 820EE4A4h case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820EE4A4h case    1:*/		return 0x820EE4A8;
		  /* 820EE4A8h */ case    2:  		/* addi R10, R10, 1 */
		/* 820EE4A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EE4A8h case    2:*/		return 0x820EE4AC;
	}
	return 0x820EE4AC;
} // Block from 820EE4A0h-820EE4ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EE4ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE4AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE4AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE4AC);
		  /* 820EE4ACh */ case    0:  		/* mr R9, R22 */
		/* 820EE4ACh case    0:*/		regs.R9 = regs.R22;
		/* 820EE4ACh case    0:*/		return 0x820EE4B0;
		  /* 820EE4B0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820EE4B0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE4B0h case    1:*/		return 0x820EE4B4;
		  /* 820EE4B4h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 820EE4B4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EE4E4;  }
		/* 820EE4B4h case    2:*/		return 0x820EE4B8;
		  /* 820EE4B8h */ case    3:  		/* mulli R11, R10, 12 */
		/* 820EE4B8h case    3:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R10,0xC);
		/* 820EE4B8h case    3:*/		return 0x820EE4BC;
		  /* 820EE4BCh */ case    4:  		/* add R11, R11, R17 */
		/* 820EE4BCh case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R17);
		/* 820EE4BCh case    4:*/		return 0x820EE4C0;
		  /* 820EE4C0h */ case    5:  		/* addi R11, R11, -4 */
		/* 820EE4C0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820EE4C0h case    5:*/		return 0x820EE4C4;
		  /* 820EE4C4h */ case    6:  		/* lwz R8, <#[R4]> */
		/* 820EE4C4h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 820EE4C4h case    6:*/		return 0x820EE4C8;
		  /* 820EE4C8h */ case    7:  		/* stw R9, <#[R11 + 8]> */
		/* 820EE4C8h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820EE4C8h case    7:*/		return 0x820EE4CC;
		  /* 820EE4CCh */ case    8:  		/* addi R9, R9, 1 */
		/* 820EE4CCh case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820EE4CCh case    8:*/		return 0x820EE4D0;
		  /* 820EE4D0h */ case    9:  		/* stw R8, <#[R11 + 4]> */
		/* 820EE4D0h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820EE4D0h case    9:*/		return 0x820EE4D4;
		  /* 820EE4D4h */ case   10:  		/* stwu R20, <#[R11 + 12]> */
		/* 820EE4D4h case   10:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + 0x0000000C) );
		regs.R11 = (uint32)(regs.R11 + 0x0000000C);
		/* 820EE4D4h case   10:*/		return 0x820EE4D8;
		  /* 820EE4D8h */ case   11:  		/* lwz R8, <#[R5 + 8]> */
		/* 820EE4D8h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000008) );
		/* 820EE4D8h case   11:*/		return 0x820EE4DC;
		  /* 820EE4DCh */ case   12:  		/* cmplw CR6, R9, R8 */
		/* 820EE4DCh case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820EE4DCh case   12:*/		return 0x820EE4E0;
		  /* 820EE4E0h */ case   13:  		/* bc 12, CR6_LT, -28 */
		/* 820EE4E0h case   13:*/		if ( regs.CR[6].lt ) { return 0x820EE4C4;  }
		/* 820EE4E0h case   13:*/		return 0x820EE4E4;
	}
	return 0x820EE4E4;
} // Block from 820EE4ACh-820EE4E4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820EE4E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE4E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE4E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE4E4);
		  /* 820EE4E4h */ case    0:  		/* addi R3, R3, 1 */
		/* 820EE4E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820EE4E4h case    0:*/		return 0x820EE4E8;
		  /* 820EE4E8h */ case    1:  		/* stw R10, <#[R5 + 16]> */
		/* 820EE4E8h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000010) );
		/* 820EE4E8h case    1:*/		return 0x820EE4EC;
		  /* 820EE4ECh */ case    2:  		/* addi R4, R4, 4 */
		/* 820EE4ECh case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 820EE4ECh case    2:*/		return 0x820EE4F0;
		  /* 820EE4F0h */ case    3:  		/* cmplw CR6, R3, R31 */
		/* 820EE4F0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R31);
		/* 820EE4F0h case    3:*/		return 0x820EE4F4;
		  /* 820EE4F4h */ case    4:  		/* bc 12, CR6_LT, -524 */
		/* 820EE4F4h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EE2E8;  }
		/* 820EE4F4h case    4:*/		return 0x820EE4F8;
	}
	return 0x820EE4F8;
} // Block from 820EE4E4h-820EE4F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EE4F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE4F8);
		  /* 820EE4F8h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 820EE4F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820EE4F8h case    0:*/		return 0x820EE4FC;
		  /* 820EE4FCh */ case    1:  		/* mr R10, R22 */
		/* 820EE4FCh case    1:*/		regs.R10 = regs.R22;
		/* 820EE4FCh case    1:*/		return 0x820EE500;
		  /* 820EE500h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820EE500h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE500h case    2:*/		return 0x820EE504;
		  /* 820EE504h */ case    3:  		/* bc 4, CR6_GT, 68 */
		/* 820EE504h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820EE548;  }
		/* 820EE504h case    3:*/		return 0x820EE508;
		  /* 820EE508h */ case    4:  		/* mr R11, R22 */
		/* 820EE508h case    4:*/		regs.R11 = regs.R22;
		/* 820EE508h case    4:*/		return 0x820EE50C;
		  /* 820EE50Ch */ case    5:  		/* lwz R9, <#[R25 + 20]> */
		/* 820EE50Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000014) );
		/* 820EE50Ch case    5:*/		return 0x820EE510;
		  /* 820EE510h */ case    6:  		/* addi R10, R10, 1 */
		/* 820EE510h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EE510h case    6:*/		return 0x820EE514;
		  /* 820EE514h */ case    7:  		/* lwz R8, <#[R25 + 16]> */
		/* 820EE514h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000010) );
		/* 820EE514h case    7:*/		return 0x820EE518;
		  /* 820EE518h */ case    8:  		/* lwzx R7, <#[R11 + R9]> */
		/* 820EE518h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EE518h case    8:*/		return 0x820EE51C;
		  /* 820EE51Ch */ case    9:  		/* addi R11, R11, 4 */
		/* 820EE51Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EE51Ch case    9:*/		return 0x820EE520;
		  /* 820EE520h */ case   10:  		/* lwz R6, <#[R7 + 4]> */
		/* 820EE520h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R7 + 0x00000004) );
		/* 820EE520h case   10:*/		return 0x820EE524;
		  /* 820EE524h */ case   11:  		/* lwz R9, <#[R7 + 12]> */
		/* 820EE524h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x0000000C) );
		/* 820EE524h case   11:*/		return 0x820EE528;
		  /* 820EE528h */ case   12:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820EE528h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820EE528h case   12:*/		return 0x820EE52C;
		  /* 820EE52Ch */ case   13:  		/* lwzx R8, <#[R6 + R8]> */
		/* 820EE52Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820EE52Ch case   13:*/		return 0x820EE530;
		  /* 820EE530h */ case   14:  		/* lwz R8, <#[R8 + 16]> */
		/* 820EE530h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000010) );
		/* 820EE530h case   14:*/		return 0x820EE534;
		  /* 820EE534h */ case   15:  		/* add R9, R8, R9 */
		/* 820EE534h case   15:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820EE534h case   15:*/		return 0x820EE538;
		  /* 820EE538h */ case   16:  		/* stw R9, <#[R7 + 12]> */
		/* 820EE538h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x0000000C) );
		/* 820EE538h case   16:*/		return 0x820EE53C;
		  /* 820EE53Ch */ case   17:  		/* lwz R9, <#[R25 + 8]> */
		/* 820EE53Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000008) );
		/* 820EE53Ch case   17:*/		return 0x820EE540;
		  /* 820EE540h */ case   18:  		/* cmplw CR6, R10, R9 */
		/* 820EE540h case   18:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820EE540h case   18:*/		return 0x820EE544;
		  /* 820EE544h */ case   19:  		/* bc 12, CR6_LT, -56 */
		/* 820EE544h case   19:*/		if ( regs.CR[6].lt ) { return 0x820EE50C;  }
		/* 820EE544h case   19:*/		return 0x820EE548;
	}
	return 0x820EE548;
} // Block from 820EE4F8h-820EE548h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820EE548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE548);
		  /* 820EE548h */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 820EE548h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820EE548h case    0:*/		return 0x820EE54C;
		  /* 820EE54Ch */ case    1:  		/* mr R10, R22 */
		/* 820EE54Ch case    1:*/		regs.R10 = regs.R22;
		/* 820EE54Ch case    1:*/		return 0x820EE550;
		  /* 820EE550h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820EE550h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE550h case    2:*/		return 0x820EE554;
		  /* 820EE554h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 820EE554h case    3:*/		if ( regs.CR[6].eq ) { return 0x820EE58C;  }
		/* 820EE554h case    3:*/		return 0x820EE558;
		  /* 820EE558h */ case    4:  		/* mr R9, R22 */
		/* 820EE558h case    4:*/		regs.R9 = regs.R22;
		/* 820EE558h case    4:*/		return 0x820EE55C;
		  /* 820EE55Ch */ case    5:  		/* lwz R11, <#[R25 + 16]> */
		/* 820EE55Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 820EE55Ch case    5:*/		return 0x820EE560;
		  /* 820EE560h */ case    6:  		/* addi R10, R10, 1 */
		/* 820EE560h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EE560h case    6:*/		return 0x820EE564;
		  /* 820EE564h */ case    7:  		/* lwzx R7, <#[R9 + R11]> */
		/* 820EE564h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820EE564h case    7:*/		return 0x820EE568;
		  /* 820EE568h */ case    8:  		/* addi R9, R9, 4 */
		/* 820EE568h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820EE568h case    8:*/		return 0x820EE56C;
		  /* 820EE56Ch */ case    9:  		/* lwz R11, <#[R7 + 16]> */
		/* 820EE56Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000010) );
		/* 820EE56Ch case    9:*/		return 0x820EE570;
	}
	return 0x820EE570;
} // Block from 820EE548h-820EE570h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EE570h
// Function '?CombineConstants@CShaderProgram@D3DXShader@@IAAJIIKKD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE570);
		  /* 820EE570h */ case    0:  		/* lwz R8, <#[R7 + 8]> */
		/* 820EE570h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000008) );
		/* 820EE570h case    0:*/		return 0x820EE574;
		  /* 820EE574h */ case    1:  		/* stw R22, <#[R7 + 16]> */
		/* 820EE574h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R7 + 0x00000010) );
		/* 820EE574h case    1:*/		return 0x820EE578;
		  /* 820EE578h */ case    2:  		/* add R11, R8, R11 */
		/* 820EE578h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820EE578h case    2:*/		return 0x820EE57C;
		  /* 820EE57Ch */ case    3:  		/* stw R11, <#[R7 + 8]> */
		/* 820EE57Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 820EE57Ch case    3:*/		return 0x820EE580;
		  /* 820EE580h */ case    4:  		/* lwz R11, <#[R25 + 4]> */
		/* 820EE580h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820EE580h case    4:*/		return 0x820EE584;
		  /* 820EE584h */ case    5:  		/* cmplw CR6, R10, R11 */
		/* 820EE584h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820EE584h case    5:*/		return 0x820EE588;
		  /* 820EE588h */ case    6:  		/* bc 12, CR6_LT, -44 */
		/* 820EE588h case    6:*/		if ( regs.CR[6].lt ) { return 0x820EE55C;  }
		/* 820EE588h case    6:*/		return 0x820EE58C;
	}
	return 0x820EE58C;
} // Block from 820EE570h-820EE58Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EE58Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE58C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE58C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE58C);
		  /* 820EE58Ch */ case    0:  		/* mr R30, R22 */
		/* 820EE58Ch case    0:*/		regs.R30 = regs.R22;
		/* 820EE58Ch case    0:*/		return 0x820EE590;
		  /* 820EE590h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820EE590h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE590h case    1:*/		return 0x820EE594;
		  /* 820EE594h */ case    2:  		/* bc 12, CR6_EQ, 488 */
		/* 820EE594h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EE77C;  }
		/* 820EE594h case    2:*/		return 0x820EE598;
		  /* 820EE598h */ case    3:  		/* mr R28, R22 */
		/* 820EE598h case    3:*/		regs.R28 = regs.R22;
		/* 820EE598h case    3:*/		return 0x820EE59C;
		  /* 820EE59Ch */ case    4:  		/* lwz R11, <#[R25 + 16]> */
		/* 820EE59Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 820EE59Ch case    4:*/		return 0x820EE5A0;
		  /* 820EE5A0h */ case    5:  		/* lwzx R31, <#[R28 + R11]> */
		/* 820EE5A0h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820EE5A0h case    5:*/		return 0x820EE5A4;
		  /* 820EE5A4h */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 820EE5A4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820EE5A4h case    6:*/		return 0x820EE5A8;
		  /* 820EE5A8h */ case    7:  		/* and R10, R11, R18 */
		/* 820EE5A8h case    7:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R18);
		/* 820EE5A8h case    7:*/		return 0x820EE5AC;
		  /* 820EE5ACh */ case    8:  		/* cmplw CR6, R10, R18 */
		/* 820EE5ACh case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R18);
		/* 820EE5ACh case    8:*/		return 0x820EE5B0;
		  /* 820EE5B0h */ case    9:  		/* bc 4, CR6_EQ, 440 */
		/* 820EE5B0h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820EE768;  }
		/* 820EE5B0h case    9:*/		return 0x820EE5B4;
		  /* 820EE5B4h */ case   10:  		/* and. R10, R11, R15 */
		/* 820EE5B4h case   10:*/		cpu::op::and<1>(regs,&regs.R10,regs.R11,regs.R15);
		/* 820EE5B4h case   10:*/		return 0x820EE5B8;
		  /* 820EE5B8h */ case   11:  		/* bc 4, CR0_EQ, 432 */
		/* 820EE5B8h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820EE768;  }
		/* 820EE5B8h case   11:*/		return 0x820EE5BC;
		  /* 820EE5BCh */ case   12:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 820EE5BCh case   12:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 820EE5BCh case   12:*/		return 0x820EE5C0;
		  /* 820EE5C0h */ case   13:  		/* bc 4, CR0_EQ, 424 */
		/* 820EE5C0h case   13:*/		if ( !regs.CR[0].eq ) { return 0x820EE768;  }
		/* 820EE5C0h case   13:*/		return 0x820EE5C4;
		  /* 820EE5C4h */ case   14:  		/* rlwinm. R10, R11, 0, 20, 20 */
		/* 820EE5C4h case   14:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R11);
		/* 820EE5C4h case   14:*/		return 0x820EE5C8;
		  /* 820EE5C8h */ case   15:  		/* bc 4, CR0_EQ, 416 */
		/* 820EE5C8h case   15:*/		if ( !regs.CR[0].eq ) { return 0x820EE768;  }
		/* 820EE5C8h case   15:*/		return 0x820EE5CC;
		  /* 820EE5CCh */ case   16:  		/* lwz R10, <#[R31 + 8]> */
		/* 820EE5CCh case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820EE5CCh case   16:*/		return 0x820EE5D0;
		  /* 820EE5D0h */ case   17:  		/* cmplwi CR6, R10, 0 */
		/* 820EE5D0h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820EE5D0h case   17:*/		return 0x820EE5D4;
		  /* 820EE5D4h */ case   18:  		/* bc 12, CR6_EQ, 404 */
		/* 820EE5D4h case   18:*/		if ( regs.CR[6].eq ) { return 0x820EE768;  }
		/* 820EE5D4h case   18:*/		return 0x820EE5D8;
		  /* 820EE5D8h */ case   19:  		/* rlwinm. R9, R11, 0, 23, 23 */
		/* 820EE5D8h case   19:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R11);
		/* 820EE5D8h case   19:*/		return 0x820EE5DC;
		  /* 820EE5DCh */ case   20:  		/* bc 12, CR0_EQ, 16 */
		/* 820EE5DCh case   20:*/		if ( regs.CR[0].eq ) { return 0x820EE5EC;  }
		/* 820EE5DCh case   20:*/		return 0x820EE5E0;
		  /* 820EE5E0h */ case   21:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 820EE5E0h case   21:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 820EE5E0h case   21:*/		return 0x820EE5E4;
		  /* 820EE5E4h */ case   22:  		/* mr R11, R20 */
		/* 820EE5E4h case   22:*/		regs.R11 = regs.R20;
		/* 820EE5E4h case   22:*/		return 0x820EE5E8;
		  /* 820EE5E8h */ case   23:  		/* bc 4, CR0_EQ, 8 */
		/* 820EE5E8h case   23:*/		if ( !regs.CR[0].eq ) { return 0x820EE5F0;  }
		/* 820EE5E8h case   23:*/		return 0x820EE5EC;
	}
	return 0x820EE5EC;
} // Block from 820EE58Ch-820EE5ECh (24 instructions)

//////////////////////////////////////////////////////
// Block at 820EE5ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE5EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE5EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE5EC);
		  /* 820EE5ECh */ case    0:  		/* mr R11, R22 */
		/* 820EE5ECh case    0:*/		regs.R11 = regs.R22;
		/* 820EE5ECh case    0:*/		return 0x820EE5F0;
	}
	return 0x820EE5F0;
} // Block from 820EE5ECh-820EE5F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EE5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE5F0);
		  /* 820EE5F0h */ case    0:  		/* rlwinm R3, R10, 2, 0, 29 */
		/* 820EE5F0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R10);
		/* 820EE5F0h case    0:*/		return 0x820EE5F4;
		  /* 820EE5F4h */ case    1:  		/* lis R4, 9345 */
		/* 820EE5F4h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820EE5F4h case    1:*/		return 0x820EE5F8;
		  /* 820EE5F8h */ case    2:  		/* rlwinm R29, R11, 0, 24, 31 */
		/* 820EE5F8h case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R29,regs.R11);
		/* 820EE5F8h case    2:*/		return 0x820EE5FC;
		  /* 820EE5FCh */ case    3:  		/* bl -418812 */
		/* 820EE5FCh case    3:*/		regs.LR = 0x820EE600; return 0x82088200;
		/* 820EE5FCh case    3:*/		return 0x820EE600;
		  /* 820EE600h */ case    4:  		/* stw R3, <#[R1 + 84]> */
		/* 820EE600h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820EE600h case    4:*/		return 0x820EE604;
		  /* 820EE604h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820EE604h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EE604h case    5:*/		return 0x820EE608;
		  /* 820EE608h */ case    6:  		/* bc 12, CR0_EQ, 472 */
		/* 820EE608h case    6:*/		if ( regs.CR[0].eq ) { return 0x820EE7E0;  }
		/* 820EE608h case    6:*/		return 0x820EE60C;
		  /* 820EE60Ch */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 820EE60Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820EE60Ch case    7:*/		return 0x820EE610;
		  /* 820EE610h */ case    8:  		/* rlwinm R31, R3, 0, 0, 31 */
		/* 820EE610h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R31,regs.R3);
		/* 820EE610h case    8:*/		return 0x820EE614;
		  /* 820EE614h */ case    9:  		/* li R4, 255 */
		/* 820EE614h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 820EE614h case    9:*/		return 0x820EE618;
		  /* 820EE618h */ case   10:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820EE618h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820EE618h case   10:*/		return 0x820EE61C;
		  /* 820EE61Ch */ case   11:  		/* mr R3, R31 */
		/* 820EE61Ch case   11:*/		regs.R3 = regs.R31;
		/* 820EE61Ch case   11:*/		return 0x820EE620;
		  /* 820EE620h */ case   12:  		/* bl -381664 */
		/* 820EE620h case   12:*/		regs.LR = 0x820EE624; return 0x82091340;
		/* 820EE620h case   12:*/		return 0x820EE624;
		  /* 820EE624h */ case   13:  		/* lwz R11, <#[R25 + 8]> */
		/* 820EE624h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820EE624h case   13:*/		return 0x820EE628;
		  /* 820EE628h */ case   14:  		/* mr R7, R22 */
		/* 820EE628h case   14:*/		regs.R7 = regs.R22;
		/* 820EE628h case   14:*/		return 0x820EE62C;
		  /* 820EE62Ch */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 820EE62Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE62Ch case   15:*/		return 0x820EE630;
		  /* 820EE630h */ case   16:  		/* bc 4, CR6_GT, 296 */
		/* 820EE630h case   16:*/		if ( !regs.CR[6].gt ) { return 0x820EE758;  }
		/* 820EE630h case   16:*/		return 0x820EE634;
		  /* 820EE634h */ case   17:  		/* mr R8, R22 */
		/* 820EE634h case   17:*/		regs.R8 = regs.R22;
		/* 820EE634h case   17:*/		return 0x820EE638;
		  /* 820EE638h */ case   18:  		/* lwz R11, <#[R25 + 20]> */
		/* 820EE638h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000014) );
		/* 820EE638h case   18:*/		return 0x820EE63C;
		  /* 820EE63Ch */ case   19:  		/* lwzx R9, <#[R8 + R11]> */
		/* 820EE63Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820EE63Ch case   19:*/		return 0x820EE640;
		  /* 820EE640h */ case   20:  		/* lwz R11, <#[R9 + 4]> */
		/* 820EE640h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 820EE640h case   20:*/		return 0x820EE644;
		  /* 820EE644h */ case   21:  		/* cmplw CR6, R11, R30 */
		/* 820EE644h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820EE644h case   21:*/		return 0x820EE648;
		  /* 820EE648h */ case   22:  		/* bc 4, CR6_EQ, 252 */
		/* 820EE648h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820EE744;  }
		/* 820EE648h case   22:*/		return 0x820EE64C;
		  /* 820EE64Ch */ case   23:  		/* lwz R11, <#[R9 + 12]> */
		/* 820EE64Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 820EE64Ch case   23:*/		return 0x820EE650;
		  /* 820EE650h */ case   24:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EE650h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EE650h case   24:*/		return 0x820EE654;
		  /* 820EE654h */ case   25:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820EE654h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820EE654h case   25:*/		return 0x820EE658;
		  /* 820EE658h */ case   26:  		/* cmpwi CR6, R11, -1 */
		/* 820EE658h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EE658h case   26:*/		return 0x820EE65C;
		  /* 820EE65Ch */ case   27:  		/* bc 4, CR6_EQ, 216 */
		/* 820EE65Ch case   27:*/		if ( !regs.CR[6].eq ) { return 0x820EE734;  }
		/* 820EE65Ch case   27:*/		return 0x820EE660;
		  /* 820EE660h */ case   28:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 820EE660h case   28:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 820EE660h case   28:*/		return 0x820EE664;
		  /* 820EE664h */ case   29:  		/* bc 12, CR0_EQ, 120 */
		/* 820EE664h case   29:*/		if ( regs.CR[0].eq ) { return 0x820EE6DC;  }
		/* 820EE664h case   29:*/		return 0x820EE668;
		  /* 820EE668h */ case   30:  		/* addi R11, R19, -1 */
		/* 820EE668h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R19,0xFFFFFFFF);
		/* 820EE668h case   30:*/		return 0x820EE66C;
		  /* 820EE66Ch */ case   31:  		/* cmplw CR6, R11, R21 */
		/* 820EE66Ch case   31:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 820EE66Ch case   31:*/		return 0x820EE670;
		  /* 820EE670h */ case   32:  		/* bc 4, CR6_LT, 152 */
		/* 820EE670h case   32:*/		if ( !regs.CR[6].lt ) { return 0x820EE708;  }
		/* 820EE670h case   32:*/		return 0x820EE674;
		  /* 820EE674h */ case   33:  		/* mulli R10, R11, 12 */
		/* 820EE674h case   33:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0xC);
		/* 820EE674h case   33:*/		return 0x820EE678;
		  /* 820EE678h */ case   34:  		/* add R10, R10, R17 */
		/* 820EE678h case   34:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R17);
		/* 820EE678h case   34:*/		return 0x820EE67C;
		  /* 820EE67Ch */ case   35:  		/* lwz R6, <#[R10]> */
		/* 820EE67Ch case   35:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820EE67Ch case   35:*/		return 0x820EE680;
		  /* 820EE680h */ case   36:  		/* cmplwi CR6, R6, 0 */
		/* 820EE680h case   36:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820EE680h case   36:*/		return 0x820EE684;
		  /* 820EE684h */ case   37:  		/* bc 12, CR6_EQ, 132 */
		/* 820EE684h case   37:*/		if ( regs.CR[6].eq ) { return 0x820EE708;  }
		/* 820EE684h case   37:*/		return 0x820EE688;
		  /* 820EE688h */ case   38:  		/* addi R11, R11, -1 */
		/* 820EE688h case   38:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820EE688h case   38:*/		return 0x820EE68C;
		  /* 820EE68Ch */ case   39:  		/* addi R10, R10, -12 */
		/* 820EE68Ch case   39:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFF4);
		/* 820EE68Ch case   39:*/		return 0x820EE690;
		  /* 820EE690h */ case   40:  		/* cmplw CR6, R11, R21 */
		/* 820EE690h case   40:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 820EE690h case   40:*/		return 0x820EE694;
		  /* 820EE694h */ case   41:  		/* bc 12, CR6_LT, -24 */
		/* 820EE694h case   41:*/		if ( regs.CR[6].lt ) { return 0x820EE67C;  }
		/* 820EE694h case   41:*/		return 0x820EE698;
		  /* 820EE698h */ case   42:  		/* b 112 */
		/* 820EE698h case   42:*/		return 0x820EE708;
		/* 820EE698h case   42:*/		return 0x820EE69C;
	}
	return 0x820EE69C;
} // Block from 820EE5F0h-820EE69Ch (43 instructions)

//////////////////////////////////////////////////////
// Block at 820EE69Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE69C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE69C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE69C);
		  /* 820EE69Ch */ case    0:  		/* extsb R11, R16 */
		/* 820EE69Ch case    0:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R16);
		/* 820EE69Ch case    0:*/		return 0x820EE6A0;
		  /* 820EE6A0h */ case    1:  		/* cmpwi CR6, R11, 118 */
		/* 820EE6A0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000076);
		/* 820EE6A0h case    1:*/		return 0x820EE6A4;
		  /* 820EE6A4h */ case    2:  		/* bc 12, CR6_EQ, -732 */
		/* 820EE6A4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EE3C8;  }
		/* 820EE6A4h case    2:*/		return 0x820EE6A8;
		  /* 820EE6A8h */ case    3:  		/* cmpwi CR6, R11, 99 */
		/* 820EE6A8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000063);
		/* 820EE6A8h case    3:*/		return 0x820EE6AC;
		  /* 820EE6ACh */ case    4:  		/* bc 12, CR6_EQ, -708 */
		/* 820EE6ACh case    4:*/		if ( regs.CR[6].eq ) { return 0x820EE3E8;  }
		/* 820EE6ACh case    4:*/		return 0x820EE6B0;
		  /* 820EE6B0h */ case    5:  		/* cmpwi CR6, R11, 115 */
		/* 820EE6B0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000073);
		/* 820EE6B0h case    5:*/		return 0x820EE6B4;
		  /* 820EE6B4h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 820EE6B4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820EE6C0;  }
		/* 820EE6B4h case    6:*/		return 0x820EE6B8;
		  /* 820EE6B8h */ case    7:  		/* li R5, 4546 */
		/* 820EE6B8h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x11C2);
		/* 820EE6B8h case    7:*/		return 0x820EE6BC;
		  /* 820EE6BCh */ case    8:  		/* b -736 */
		/* 820EE6BCh case    8:*/		return 0x820EE3DC;
		/* 820EE6BCh case    8:*/		return 0x820EE6C0;
	}
	return 0x820EE6C0;
} // Block from 820EE69Ch-820EE6C0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820EE6C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE6C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE6C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE6C0);
		  /* 820EE6C0h */ case    0:  		/* cmpwi CR6, R11, 98 */
		/* 820EE6C0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000062);
		/* 820EE6C0h case    0:*/		return 0x820EE6C4;
		  /* 820EE6C4h */ case    1:  		/* bc 12, CR6_EQ, -716 */
		/* 820EE6C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EE3F8;  }
		/* 820EE6C4h case    1:*/		return 0x820EE6C8;
		  /* 820EE6C8h */ case    2:  		/* cmpwi CR6, R11, 105 */
		/* 820EE6C8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000069);
		/* 820EE6C8h case    2:*/		return 0x820EE6CC;
		  /* 820EE6CCh */ case    3:  		/* bc 4, CR6_EQ, 356 */
		/* 820EE6CCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820EE830;  }
		/* 820EE6CCh case    3:*/		return 0x820EE6D0;
	}
	return 0x820EE6D0;
} // Block from 820EE6C0h-820EE6D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE6D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE6D0);
		  /* 820EE6D0h */ case    0:  		/* lis R11, -32254 */
		/* 820EE6D0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EE6D0h case    0:*/		return 0x820EE6D4;
		  /* 820EE6D4h */ case    1:  		/* addi R6, R11, -16904 */
		/* 820EE6D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBDF8);
		/* 820EE6D4h case    1:*/		return 0x820EE6D8;
		  /* 820EE6D8h */ case    2:  		/* b 328 */
		/* 820EE6D8h case    2:*/		return 0x820EE820;
		/* 820EE6D8h case    2:*/		return 0x820EE6DC;
	}
	return 0x820EE6DC;
} // Block from 820EE6D0h-820EE6DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EE6DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE6DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE6DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE6DC);
		  /* 820EE6DCh */ case    0:  		/* mr R11, R22 */
		/* 820EE6DCh case    0:*/		regs.R11 = regs.R22;
		/* 820EE6DCh case    0:*/		return 0x820EE6E0;
		  /* 820EE6E0h */ case    1:  		/* cmplwi CR6, R19, 0 */
		/* 820EE6E0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820EE6E0h case    1:*/		return 0x820EE6E4;
		  /* 820EE6E4h */ case    2:  		/* bc 12, CR6_EQ, 264 */
		/* 820EE6E4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EE7EC;  }
		/* 820EE6E4h case    2:*/		return 0x820EE6E8;
		  /* 820EE6E8h */ case    3:  		/* mr R10, R17 */
		/* 820EE6E8h case    3:*/		regs.R10 = regs.R17;
		/* 820EE6E8h case    3:*/		return 0x820EE6EC;
		  /* 820EE6ECh */ case    4:  		/* lwz R6, <#[R10]> */
		/* 820EE6ECh case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820EE6ECh case    4:*/		return 0x820EE6F0;
		  /* 820EE6F0h */ case    5:  		/* cmplwi CR6, R6, 0 */
		/* 820EE6F0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820EE6F0h case    5:*/		return 0x820EE6F4;
		  /* 820EE6F4h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 820EE6F4h case    6:*/		if ( regs.CR[6].eq ) { return 0x820EE708;  }
		/* 820EE6F4h case    6:*/		return 0x820EE6F8;
		  /* 820EE6F8h */ case    7:  		/* addi R11, R11, 1 */
		/* 820EE6F8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EE6F8h case    7:*/		return 0x820EE6FC;
		  /* 820EE6FCh */ case    8:  		/* addi R10, R10, 12 */
		/* 820EE6FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 820EE6FCh case    8:*/		return 0x820EE700;
		  /* 820EE700h */ case    9:  		/* cmplw CR6, R11, R19 */
		/* 820EE700h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 820EE700h case    9:*/		return 0x820EE704;
		  /* 820EE704h */ case   10:  		/* bc 12, CR6_LT, -24 */
		/* 820EE704h case   10:*/		if ( regs.CR[6].lt ) { return 0x820EE6EC;  }
		/* 820EE704h case   10:*/		return 0x820EE708;
	}
	return 0x820EE708;
} // Block from 820EE6DCh-820EE708h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820EE708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE708);
		  /* 820EE708h */ case    0:  		/* cmplw CR6, R11, R19 */
		/* 820EE708h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 820EE708h case    0:*/		return 0x820EE70C;
		  /* 820EE70Ch */ case    1:  		/* bc 4, CR6_LT, 224 */
		/* 820EE70Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x820EE7EC;  }
		/* 820EE70Ch case    1:*/		return 0x820EE710;
		  /* 820EE710h */ case    2:  		/* mulli R10, R11, 12 */
		/* 820EE710h case    2:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0xC);
		/* 820EE710h case    2:*/		return 0x820EE714;
		  /* 820EE714h */ case    3:  		/* add R10, R10, R17 */
		/* 820EE714h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R17);
		/* 820EE714h case    3:*/		return 0x820EE718;
		  /* 820EE718h */ case    4:  		/* stw R30, <#[R10]> */
		/* 820EE718h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00000000) );
		/* 820EE718h case    4:*/		return 0x820EE71C;
		  /* 820EE71Ch */ case    5:  		/* lwz R6, <#[R9 + 12]> */
		/* 820EE71Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x0000000C) );
		/* 820EE71Ch case    5:*/		return 0x820EE720;
		  /* 820EE720h */ case    6:  		/* stw R20, <#[R10 + 8]> */
		/* 820EE720h case    6:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R10 + 0x00000008) );
		/* 820EE720h case    6:*/		return 0x820EE724;
		  /* 820EE724h */ case    7:  		/* stw R6, <#[R10 + 4]> */
		/* 820EE724h case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 820EE724h case    7:*/		return 0x820EE728;
		  /* 820EE728h */ case    8:  		/* lwz R10, <#[R9 + 12]> */
		/* 820EE728h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000000C) );
		/* 820EE728h case    8:*/		return 0x820EE72C;
		  /* 820EE72Ch */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EE72Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EE72Ch case    9:*/		return 0x820EE730;
		  /* 820EE730h */ case   10:  		/* stwx R11, <#[R10 + R31]> */
		/* 820EE730h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820EE730h case   10:*/		return 0x820EE734;
	}
	return 0x820EE734;
} // Block from 820EE708h-820EE734h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820EE734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE734);
		  /* 820EE734h */ case    0:  		/* lwz R11, <#[R9 + 12]> */
		/* 820EE734h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 820EE734h case    0:*/		return 0x820EE738;
		  /* 820EE738h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EE738h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EE738h case    1:*/		return 0x820EE73C;
		  /* 820EE73Ch */ case    2:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820EE73Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820EE73Ch case    2:*/		return 0x820EE740;
		  /* 820EE740h */ case    3:  		/* stw R11, <#[R9 + 12]> */
		/* 820EE740h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 820EE740h case    3:*/		return 0x820EE744;
	}
	return 0x820EE744;
} // Block from 820EE734h-820EE744h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE744);
		  /* 820EE744h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 820EE744h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820EE744h case    0:*/		return 0x820EE748;
		  /* 820EE748h */ case    1:  		/* addi R7, R7, 1 */
		/* 820EE748h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820EE748h case    1:*/		return 0x820EE74C;
		  /* 820EE74Ch */ case    2:  		/* addi R8, R8, 4 */
		/* 820EE74Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820EE74Ch case    2:*/		return 0x820EE750;
		  /* 820EE750h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820EE750h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820EE750h case    3:*/		return 0x820EE754;
		  /* 820EE754h */ case    4:  		/* bc 12, CR6_LT, -284 */
		/* 820EE754h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EE638;  }
		/* 820EE754h case    4:*/		return 0x820EE758;
	}
	return 0x820EE758;
} // Block from 820EE744h-820EE758h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EE758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE758);
		  /* 820EE758h */ case    0:  		/* lis R4, 9345 */
		/* 820EE758h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820EE758h case    0:*/		return 0x820EE75C;
		  /* 820EE75Ch */ case    1:  		/* mr R3, R31 */
		/* 820EE75Ch case    1:*/		regs.R3 = regs.R31;
		/* 820EE75Ch case    1:*/		return 0x820EE760;
		  /* 820EE760h */ case    2:  		/* bl -418856 */
		/* 820EE760h case    2:*/		regs.LR = 0x820EE764; return 0x82088338;
		/* 820EE760h case    2:*/		return 0x820EE764;
		  /* 820EE764h */ case    3:  		/* stw R22, <#[R1 + 84]> */
		/* 820EE764h case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 820EE764h case    3:*/		return 0x820EE768;
	}
	return 0x820EE768;
} // Block from 820EE758h-820EE768h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE768);
		  /* 820EE768h */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 820EE768h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820EE768h case    0:*/		return 0x820EE76C;
		  /* 820EE76Ch */ case    1:  		/* addi R30, R30, 1 */
		/* 820EE76Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820EE76Ch case    1:*/		return 0x820EE770;
		  /* 820EE770h */ case    2:  		/* addi R28, R28, 4 */
		/* 820EE770h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820EE770h case    2:*/		return 0x820EE774;
		  /* 820EE774h */ case    3:  		/* cmplw CR6, R30, R11 */
		/* 820EE774h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820EE774h case    3:*/		return 0x820EE778;
		  /* 820EE778h */ case    4:  		/* bc 12, CR6_LT, -476 */
		/* 820EE778h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EE59C;  }
		/* 820EE778h case    4:*/		return 0x820EE77C;
	}
	return 0x820EE77C;
} // Block from 820EE768h-820EE77Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EE77Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE77C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE77C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE77C);
		  /* 820EE77Ch */ case    0:  		/* cmpwi CR6, R14, -1 */
		/* 820EE77Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0xFFFFFFFF);
		/* 820EE77Ch case    0:*/		return 0x820EE780;
		  /* 820EE780h */ case    1:  		/* bc 12, CR6_EQ, 312 */
		/* 820EE780h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EE8B8;  }
		/* 820EE780h case    1:*/		return 0x820EE784;
		  /* 820EE784h */ case    2:  		/* lwz R11, <#[R25 + 8]> */
		/* 820EE784h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820EE784h case    2:*/		return 0x820EE788;
		  /* 820EE788h */ case    3:  		/* mr R8, R22 */
		/* 820EE788h case    3:*/		regs.R8 = regs.R22;
		/* 820EE788h case    3:*/		return 0x820EE78C;
		  /* 820EE78Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820EE78Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EE78Ch case    4:*/		return 0x820EE790;
		  /* 820EE790h */ case    5:  		/* bc 4, CR6_GT, 216 */
		/* 820EE790h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820EE868;  }
		/* 820EE790h case    5:*/		return 0x820EE794;
		  /* 820EE794h */ case    6:  		/* mr R9, R22 */
		/* 820EE794h case    6:*/		regs.R9 = regs.R22;
		/* 820EE794h case    6:*/		return 0x820EE798;
		  /* 820EE798h */ case    7:  		/* lwz R11, <#[R25 + 20]> */
		/* 820EE798h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000014) );
		/* 820EE798h case    7:*/		return 0x820EE79C;
		  /* 820EE79Ch */ case    8:  		/* lwz R7, <#[R25 + 16]> */
		/* 820EE79Ch case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000010) );
		/* 820EE79Ch case    8:*/		return 0x820EE7A0;
		  /* 820EE7A0h */ case    9:  		/* lwzx R10, <#[R9 + R11]> */
		/* 820EE7A0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820EE7A0h case    9:*/		return 0x820EE7A4;
		  /* 820EE7A4h */ case   10:  		/* lwz R11, <#[R10 + 4]> */
		/* 820EE7A4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820EE7A4h case   10:*/		return 0x820EE7A8;
		  /* 820EE7A8h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EE7A8h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EE7A8h case   11:*/		return 0x820EE7AC;
		  /* 820EE7ACh */ case   12:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820EE7ACh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820EE7ACh case   12:*/		return 0x820EE7B0;
		  /* 820EE7B0h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 820EE7B0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820EE7B0h case   13:*/		return 0x820EE7B4;
		  /* 820EE7B4h */ case   14:  		/* and R7, R11, R18 */
		/* 820EE7B4h case   14:*/		cpu::op::and<0>(regs,&regs.R7,regs.R11,regs.R18);
		/* 820EE7B4h case   14:*/		return 0x820EE7B8;
		  /* 820EE7B8h */ case   15:  		/* cmplw CR6, R7, R18 */
		/* 820EE7B8h case   15:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R18);
		/* 820EE7B8h case   15:*/		return 0x820EE7BC;
		  /* 820EE7BCh */ case   16:  		/* bc 4, CR6_EQ, 152 */
		/* 820EE7BCh case   16:*/		if ( !regs.CR[6].eq ) { return 0x820EE854;  }
		/* 820EE7BCh case   16:*/		return 0x820EE7C0;
		  /* 820EE7C0h */ case   17:  		/* and. R7, R11, R15 */
		/* 820EE7C0h case   17:*/		cpu::op::and<1>(regs,&regs.R7,regs.R11,regs.R15);
		/* 820EE7C0h case   17:*/		return 0x820EE7C4;
		  /* 820EE7C4h */ case   18:  		/* bc 4, CR0_EQ, 144 */
		/* 820EE7C4h case   18:*/		if ( !regs.CR[0].eq ) { return 0x820EE854;  }
		/* 820EE7C4h case   18:*/		return 0x820EE7C8;
		  /* 820EE7C8h */ case   19:  		/* rlwinm. R7, R11, 0, 23, 23 */
		/* 820EE7C8h case   19:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R7,regs.R11);
		/* 820EE7C8h case   19:*/		return 0x820EE7CC;
		  /* 820EE7CCh */ case   20:  		/* bc 12, CR0_EQ, 132 */
		/* 820EE7CCh case   20:*/		if ( regs.CR[0].eq ) { return 0x820EE850;  }
		/* 820EE7CCh case   20:*/		return 0x820EE7D0;
		  /* 820EE7D0h */ case   21:  		/* rlwinm. R7, R11, 0, 13, 13 */
		/* 820EE7D0h case   21:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R7,regs.R11);
		/* 820EE7D0h case   21:*/		return 0x820EE7D4;
		  /* 820EE7D4h */ case   22:  		/* bc 12, CR0_EQ, 104 */
		/* 820EE7D4h case   22:*/		if ( regs.CR[0].eq ) { return 0x820EE83C;  }
		/* 820EE7D4h case   22:*/		return 0x820EE7D8;
		  /* 820EE7D8h */ case   23:  		/* lwz R11, <#[R25 + 392]> */
		/* 820EE7D8h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000188) );
		/* 820EE7D8h case   23:*/		return 0x820EE7DC;
		  /* 820EE7DCh */ case   24:  		/* b 108 */
		/* 820EE7DCh case   24:*/		return 0x820EE848;
		/* 820EE7DCh case   24:*/		return 0x820EE7E0;
	}
	return 0x820EE7E0;
} // Block from 820EE77Ch-820EE7E0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820EE7E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE7E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE7E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE7E0);
		  /* 820EE7E0h */ case    0:  		/* lis R31, -32761 */
		/* 820EE7E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820EE7E0h case    0:*/		return 0x820EE7E4;
		  /* 820EE7E4h */ case    1:  		/* ori R31, R31, 14 */
		/* 820EE7E4h case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820EE7E4h case    1:*/		return 0x820EE7E8;
		  /* 820EE7E8h */ case    2:  		/* b 212 */
		/* 820EE7E8h case    2:*/		return 0x820EE8BC;
		/* 820EE7E8h case    2:*/		return 0x820EE7EC;
	}
	return 0x820EE7EC;
} // Block from 820EE7E0h-820EE7ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EE7ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE7EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE7EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE7EC);
		  /* 820EE7ECh */ case    0:  		/* extsb R11, R16 */
		/* 820EE7ECh case    0:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R16);
		/* 820EE7ECh case    0:*/		return 0x820EE7F0;
		  /* 820EE7F0h */ case    1:  		/* cmpwi CR6, R11, 118 */
		/* 820EE7F0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000076);
		/* 820EE7F0h case    1:*/		return 0x820EE7F4;
		  /* 820EE7F4h */ case    2:  		/* bc 12, CR6_EQ, -1068 */
		/* 820EE7F4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EE3C8;  }
		/* 820EE7F4h case    2:*/		return 0x820EE7F8;
		  /* 820EE7F8h */ case    3:  		/* cmpwi CR6, R11, 99 */
		/* 820EE7F8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000063);
		/* 820EE7F8h case    3:*/		return 0x820EE7FC;
		  /* 820EE7FCh */ case    4:  		/* bc 12, CR6_EQ, -1044 */
		/* 820EE7FCh case    4:*/		if ( regs.CR[6].eq ) { return 0x820EE3E8;  }
		/* 820EE7FCh case    4:*/		return 0x820EE800;
		  /* 820EE800h */ case    5:  		/* cmpwi CR6, R11, 115 */
		/* 820EE800h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000073);
		/* 820EE800h case    5:*/		return 0x820EE804;
		  /* 820EE804h */ case    6:  		/* bc 12, CR6_EQ, -332 */
		/* 820EE804h case    6:*/		if ( regs.CR[6].eq ) { return 0x820EE6B8;  }
		/* 820EE804h case    6:*/		return 0x820EE808;
		  /* 820EE808h */ case    7:  		/* cmpwi CR6, R11, 98 */
		/* 820EE808h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000062);
		/* 820EE808h case    7:*/		return 0x820EE80C;
		  /* 820EE80Ch */ case    8:  		/* bc 12, CR6_EQ, -1044 */
		/* 820EE80Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820EE3F8;  }
		/* 820EE80Ch case    8:*/		return 0x820EE810;
		  /* 820EE810h */ case    9:  		/* cmpwi CR6, R11, 105 */
		/* 820EE810h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000069);
		/* 820EE810h case    9:*/		return 0x820EE814;
		  /* 820EE814h */ case   10:  		/* bc 4, CR6_EQ, 28 */
		/* 820EE814h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820EE830;  }
		/* 820EE814h case   10:*/		return 0x820EE818;
		  /* 820EE818h */ case   11:  		/* lis R11, -32254 */
		/* 820EE818h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EE818h case   11:*/		return 0x820EE81C;
		  /* 820EE81Ch */ case   12:  		/* addi R6, R11, -17000 */
		/* 820EE81Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBD98);
		/* 820EE81Ch case   12:*/		return 0x820EE820;
	}
	return 0x820EE820;
} // Block from 820EE7ECh-820EE820h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820EE820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE820);
		  /* 820EE820h */ case    0:  		/* li R5, 4551 */
		/* 820EE820h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x11C7);
		/* 820EE820h case    0:*/		return 0x820EE824;
	}
	return 0x820EE824;
} // Block from 820EE820h-820EE824h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EE824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE824);
		  /* 820EE824h */ case    0:  		/* li R4, 0 */
		/* 820EE824h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820EE824h case    0:*/		return 0x820EE828;
		  /* 820EE828h */ case    1:  		/* mr R3, R25 */
		/* 820EE828h case    1:*/		regs.R3 = regs.R25;
		/* 820EE828h case    1:*/		return 0x820EE82C;
		  /* 820EE82Ch */ case    2:  		/* bl 130820 */
		/* 820EE82Ch case    2:*/		regs.LR = 0x820EE830; return 0x8210E730;
		/* 820EE82Ch case    2:*/		return 0x820EE830;
	}
	return 0x820EE830;
} // Block from 820EE824h-820EE830h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EE830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE830);
		  /* 820EE830h */ case    0:  		/* lis R31, -32768 */
		/* 820EE830h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8000);
		/* 820EE830h case    0:*/		return 0x820EE834;
		  /* 820EE834h */ case    1:  		/* ori R31, R31, 16389 */
		/* 820EE834h case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x4005);
		/* 820EE834h case    1:*/		return 0x820EE838;
		  /* 820EE838h */ case    2:  		/* b 132 */
		/* 820EE838h case    2:*/		return 0x820EE8BC;
		/* 820EE838h case    2:*/		return 0x820EE83C;
	}
	return 0x820EE83C;
} // Block from 820EE830h-820EE83Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EE83Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE83C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE83C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE83C);
		  /* 820EE83Ch */ case    0:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 820EE83Ch case    0:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 820EE83Ch case    0:*/		return 0x820EE840;
		  /* 820EE840h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 820EE840h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820EE854;  }
		/* 820EE840h case    1:*/		return 0x820EE844;
		  /* 820EE844h */ case    2:  		/* lwz R11, <#[R25 + 120]> */
		/* 820EE844h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000078) );
		/* 820EE844h case    2:*/		return 0x820EE848;
	}
	return 0x820EE848;
} // Block from 820EE83Ch-820EE848h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EE848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE848);
		  /* 820EE848h */ case    0:  		/* stw R11, <#[R10 + 4]> */
		/* 820EE848h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820EE848h case    0:*/		return 0x820EE84C;
		  /* 820EE84Ch */ case    1:  		/* b 8 */
		/* 820EE84Ch case    1:*/		return 0x820EE854;
		/* 820EE84Ch case    1:*/		return 0x820EE850;
	}
	return 0x820EE850;
} // Block from 820EE848h-820EE850h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EE850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE850);
		  /* 820EE850h */ case    0:  		/* stw R14, <#[R10 + 4]> */
		/* 820EE850h case    0:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R10 + 0x00000004) );
		/* 820EE850h case    0:*/		return 0x820EE854;
	}
	return 0x820EE854;
} // Block from 820EE850h-820EE854h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EE854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE854);
		  /* 820EE854h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 820EE854h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820EE854h case    0:*/		return 0x820EE858;
		  /* 820EE858h */ case    1:  		/* addi R8, R8, 1 */
		/* 820EE858h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820EE858h case    1:*/		return 0x820EE85C;
		  /* 820EE85Ch */ case    2:  		/* addi R9, R9, 4 */
		/* 820EE85Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820EE85Ch case    2:*/		return 0x820EE860;
		  /* 820EE860h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 820EE860h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820EE860h case    3:*/		return 0x820EE864;
		  /* 820EE864h */ case    4:  		/* bc 12, CR6_LT, -204 */
		/* 820EE864h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EE798;  }
		/* 820EE864h case    4:*/		return 0x820EE868;
	}
	return 0x820EE868;
} // Block from 820EE854h-820EE868h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EE868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE868);
		  /* 820EE868h */ case    0:  		/* lwz R11, <#[R25 + 16]> */
		/* 820EE868h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 820EE868h case    0:*/		return 0x820EE86C;
		  /* 820EE86Ch */ case    1:  		/* rlwinm R10, R14, 2, 0, 29 */
		/* 820EE86Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R14);
		/* 820EE86Ch case    1:*/		return 0x820EE870;
		  /* 820EE870h */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820EE870h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EE870h case    2:*/		return 0x820EE874;
		  /* 820EE874h */ case    3:  		/* stw R22, <#[R11 + 16]> */
		/* 820EE874h case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000010) );
		/* 820EE874h case    3:*/		return 0x820EE878;
		  /* 820EE878h */ case    4:  		/* lwz R11, <#[R25 + 16]> */
		/* 820EE878h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 820EE878h case    4:*/		return 0x820EE87C;
		  /* 820EE87Ch */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820EE87Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EE87Ch case    5:*/		return 0x820EE880;
		  /* 820EE880h */ case    6:  		/* stw R19, <#[R11 + 8]> */
		/* 820EE880h case    6:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000008) );
		/* 820EE880h case    6:*/		return 0x820EE884;
		  /* 820EE884h */ case    7:  		/* lwz R11, <#[R25 + 124]> */
		/* 820EE884h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000007C) );
		/* 820EE884h case    7:*/		return 0x820EE888;
		  /* 820EE888h */ case    8:  		/* cmplw CR6, R14, R11 */
		/* 820EE888h case    8:*/		cpu::op::cmplw<6>(regs,regs.R14,regs.R11);
		/* 820EE888h case    8:*/		return 0x820EE88C;
		  /* 820EE88Ch */ case    9:  		/* bc 4, CR6_EQ, 44 */
		/* 820EE88Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820EE8B8;  }
		/* 820EE88Ch case    9:*/		return 0x820EE890;
		  /* 820EE890h */ case   10:  		/* lwz R11, <#[R25 + 120]> */
		/* 820EE890h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000078) );
		/* 820EE890h case   10:*/		return 0x820EE894;
		  /* 820EE894h */ case   11:  		/* lwz R10, <#[R25 + 16]> */
		/* 820EE894h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000010) );
		/* 820EE894h case   11:*/		return 0x820EE898;
		  /* 820EE898h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EE898h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EE898h case   12:*/		return 0x820EE89C;
		  /* 820EE89Ch */ case   13:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EE89Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EE89Ch case   13:*/		return 0x820EE8A0;
		  /* 820EE8A0h */ case   14:  		/* stw R22, <#[R11 + 16]> */
		/* 820EE8A0h case   14:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000010) );
		/* 820EE8A0h case   14:*/		return 0x820EE8A4;
		  /* 820EE8A4h */ case   15:  		/* lwz R11, <#[R25 + 120]> */
		/* 820EE8A4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000078) );
		/* 820EE8A4h case   15:*/		return 0x820EE8A8;
		  /* 820EE8A8h */ case   16:  		/* lwz R10, <#[R25 + 16]> */
		/* 820EE8A8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000010) );
		/* 820EE8A8h case   16:*/		return 0x820EE8AC;
		  /* 820EE8ACh */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EE8ACh case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EE8ACh case   17:*/		return 0x820EE8B0;
		  /* 820EE8B0h */ case   18:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EE8B0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EE8B0h case   18:*/		return 0x820EE8B4;
		  /* 820EE8B4h */ case   19:  		/* stw R19, <#[R11 + 8]> */
		/* 820EE8B4h case   19:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000008) );
		/* 820EE8B4h case   19:*/		return 0x820EE8B8;
	}
	return 0x820EE8B8;
} // Block from 820EE868h-820EE8B8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820EE8B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE8B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE8B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE8B8);
		  /* 820EE8B8h */ case    0:  		/* mr R31, R22 */
		/* 820EE8B8h case    0:*/		regs.R31 = regs.R22;
		/* 820EE8B8h case    0:*/		return 0x820EE8BC;
	}
	return 0x820EE8BC;
} // Block from 820EE8B8h-820EE8BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EE8BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE8BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE8BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE8BC);
		  /* 820EE8BCh */ case    0:  		/* lis R4, 9345 */
		/* 820EE8BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820EE8BCh case    0:*/		return 0x820EE8C0;
		  /* 820EE8C0h */ case    1:  		/* mr R3, R17 */
		/* 820EE8C0h case    1:*/		regs.R3 = regs.R17;
		/* 820EE8C0h case    1:*/		return 0x820EE8C4;
		  /* 820EE8C4h */ case    2:  		/* bl -419212 */
		/* 820EE8C4h case    2:*/		regs.LR = 0x820EE8C8; return 0x82088338;
		/* 820EE8C4h case    2:*/		return 0x820EE8C8;
		  /* 820EE8C8h */ case    3:  		/* lis R4, 9345 */
		/* 820EE8C8h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820EE8C8h case    3:*/		return 0x820EE8CC;
		  /* 820EE8CCh */ case    4:  		/* lwz R3, <#[R1 + 80]> */
		/* 820EE8CCh case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820EE8CCh case    4:*/		return 0x820EE8D0;
		  /* 820EE8D0h */ case    5:  		/* bl -419224 */
		/* 820EE8D0h case    5:*/		regs.LR = 0x820EE8D4; return 0x82088338;
		/* 820EE8D0h case    5:*/		return 0x820EE8D4;
		  /* 820EE8D4h */ case    6:  		/* lis R4, 9345 */
		/* 820EE8D4h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820EE8D4h case    6:*/		return 0x820EE8D8;
		  /* 820EE8D8h */ case    7:  		/* lwz R3, <#[R1 + 84]> */
		/* 820EE8D8h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820EE8D8h case    7:*/		return 0x820EE8DC;
		  /* 820EE8DCh */ case    8:  		/* bl -419236 */
		/* 820EE8DCh case    8:*/		regs.LR = 0x820EE8E0; return 0x82088338;
		/* 820EE8DCh case    8:*/		return 0x820EE8E0;
		  /* 820EE8E0h */ case    9:  		/* mr R3, R31 */
		/* 820EE8E0h case    9:*/		regs.R3 = regs.R31;
		/* 820EE8E0h case    9:*/		return 0x820EE8E4;
		  /* 820EE8E4h */ case   10:  		/* addi R1, R1, 256 */
		/* 820EE8E4h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 820EE8E4h case   10:*/		return 0x820EE8E8;
		  /* 820EE8E8h */ case   11:  		/* b -382584 */
		/* 820EE8E8h case   11:*/		return 0x82091270;
		/* 820EE8E8h case   11:*/		return 0x820EE8EC;
		  /* 820EE8ECh */ case   12:  		/* nop */
		/* 820EE8ECh case   12:*/		cpu::op::nop();
		/* 820EE8ECh case   12:*/		return 0x820EE8F0;
	}
	return 0x820EE8F0;
} // Block from 820EE8BCh-820EE8F0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820EE8F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE8F0);
		  /* 820EE8F0h */ case    0:  		/* mfspr R12, LR */
		/* 820EE8F0h case    0:*/		regs.R12 = regs.LR;
		/* 820EE8F0h case    0:*/		return 0x820EE8F4;
		  /* 820EE8F4h */ case    1:  		/* bl -382676 */
		/* 820EE8F4h case    1:*/		regs.LR = 0x820EE8F8; return 0x82091220;
		/* 820EE8F4h case    1:*/		return 0x820EE8F8;
		  /* 820EE8F8h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 820EE8F8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820EE8F8h case    2:*/		return 0x820EE8FC;
		  /* 820EE8FCh */ case    3:  		/* stwu R1, <#[R1 - 304]> */
		/* 820EE8FCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFED0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFED0);
		/* 820EE8FCh case    3:*/		return 0x820EE900;
		  /* 820EE900h */ case    4:  		/* mr R30, R3 */
		/* 820EE900h case    4:*/		regs.R30 = regs.R3;
		/* 820EE900h case    4:*/		return 0x820EE904;
		  /* 820EE904h */ case    5:  		/* bl -41252 */
		/* 820EE904h case    5:*/		regs.LR = 0x820EE908; return 0x820E47E0;
		/* 820EE904h case    5:*/		return 0x820EE908;
		  /* 820EE908h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820EE908h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EE908h case    6:*/		return 0x820EE90C;
		  /* 820EE90Ch */ case    7:  		/* bc 12, CR0_LT, 1680 */
		/* 820EE90Ch case    7:*/		if ( regs.CR[0].lt ) { return 0x820EEF9C;  }
		/* 820EE90Ch case    7:*/		return 0x820EE910;
		  /* 820EE910h */ case    8:  		/* lwz R6, <#[R30 + 8]> */
		/* 820EE910h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000008) );
		/* 820EE910h case    8:*/		return 0x820EE914;
		  /* 820EE914h */ case    9:  		/* li R17, 0 */
		/* 820EE914h case    9:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 820EE914h case    9:*/		return 0x820EE918;
		  /* 820EE918h */ case   10:  		/* stw R17, <#[R1 + 80]> */
		/* 820EE918h case   10:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x00000050) );
		/* 820EE918h case   10:*/		return 0x820EE91C;
		  /* 820EE91Ch */ case   11:  		/* mr R7, R17 */
		/* 820EE91Ch case   11:*/		regs.R7 = regs.R17;
		/* 820EE91Ch case   11:*/		return 0x820EE920;
		  /* 820EE920h */ case   12:  		/* cmplwi CR6, R6, 0 */
		/* 820EE920h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820EE920h case   12:*/		return 0x820EE924;
		  /* 820EE924h */ case   13:  		/* bc 12, CR6_EQ, 72 */
		/* 820EE924h case   13:*/		if ( regs.CR[6].eq ) { return 0x820EE96C;  }
		/* 820EE924h case   13:*/		return 0x820EE928;
		  /* 820EE928h */ case   14:  		/* lwz R9, <#[R30 + 136]> */
		/* 820EE928h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000088) );
		/* 820EE928h case   14:*/		return 0x820EE92C;
		  /* 820EE92Ch */ case   15:  		/* mr R10, R17 */
		/* 820EE92Ch case   15:*/		regs.R10 = regs.R17;
		/* 820EE92Ch case   15:*/		return 0x820EE930;
		  /* 820EE930h */ case   16:  		/* lwz R8, <#[R30 + 20]> */
		/* 820EE930h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000014) );
		/* 820EE930h case   16:*/		return 0x820EE934;
		  /* 820EE934h */ case   17:  		/* lwzx R11, <#[R8 + R10]> */
		/* 820EE934h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820EE934h case   17:*/		return 0x820EE938;
		  /* 820EE938h */ case   18:  		/* lwz R5, <#[R11 + 4]> */
		/* 820EE938h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000004) );
		/* 820EE938h case   18:*/		return 0x820EE93C;
		  /* 820EE93Ch */ case   19:  		/* cmplw CR6, R9, R5 */
		/* 820EE93Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 820EE93Ch case   19:*/		return 0x820EE940;
		  /* 820EE940h */ case   20:  		/* bc 4, CR6_EQ, 28 */
		/* 820EE940h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820EE95C;  }
		/* 820EE940h case   20:*/		return 0x820EE944;
		  /* 820EE944h */ case   21:  		/* lwz R11, <#[R11 + 12]> */
		/* 820EE944h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820EE944h case   21:*/		return 0x820EE948;
		  /* 820EE948h */ case   22:  		/* lwz R5, <#[R1 + 80]> */
		/* 820EE948h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820EE948h case   22:*/		return 0x820EE94C;
		  /* 820EE94Ch */ case   23:  		/* cmplw CR6, R11, R5 */
		/* 820EE94Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 820EE94Ch case   23:*/		return 0x820EE950;
		  /* 820EE950h */ case   24:  		/* bc 12, CR6_LT, 12 */
		/* 820EE950h case   24:*/		if ( regs.CR[6].lt ) { return 0x820EE95C;  }
		/* 820EE950h case   24:*/		return 0x820EE954;
		  /* 820EE954h */ case   25:  		/* addi R11, R11, 1 */
		/* 820EE954h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EE954h case   25:*/		return 0x820EE958;
		  /* 820EE958h */ case   26:  		/* stw R11, <#[R1 + 80]> */
		/* 820EE958h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820EE958h case   26:*/		return 0x820EE95C;
	}
	return 0x820EE95C;
} // Block from 820EE8F0h-820EE95Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 820EE95Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE95C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE95C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE95C);
		  /* 820EE95Ch */ case    0:  		/* addi R7, R7, 1 */
		/* 820EE95Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820EE95Ch case    0:*/		return 0x820EE960;
		  /* 820EE960h */ case    1:  		/* addi R10, R10, 4 */
		/* 820EE960h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EE960h case    1:*/		return 0x820EE964;
		  /* 820EE964h */ case    2:  		/* cmplw CR6, R7, R6 */
		/* 820EE964h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 820EE964h case    2:*/		return 0x820EE968;
		  /* 820EE968h */ case    3:  		/* bc 12, CR6_LT, -52 */
		/* 820EE968h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EE934;  }
		/* 820EE968h case    3:*/		return 0x820EE96C;
	}
	return 0x820EE96C;
} // Block from 820EE95Ch-820EE96Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EE96Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EE96C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EE96C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EE96C);
		  /* 820EE96Ch */ case    0:  		/* lwz R10, <#[R30 + 12]> */
		/* 820EE96Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000000C) );
		/* 820EE96Ch case    0:*/		return 0x820EE970;
		  /* 820EE970h */ case    1:  		/* mr R24, R17 */
		/* 820EE970h case    1:*/		regs.R24 = regs.R17;
		/* 820EE970h case    1:*/		return 0x820EE974;
		  /* 820EE974h */ case    2:  		/* stw R17, <#[R1 + 88]> */
		/* 820EE974h case    2:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x00000058) );
		/* 820EE974h case    2:*/		return 0x820EE978;
		  /* 820EE978h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 820EE978h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820EE978h case    3:*/		return 0x820EE97C;
		  /* 820EE97Ch */ case    4:  		/* stw R10, <#[R1 + 96]> */
		/* 820EE97Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 820EE97Ch case    4:*/		return 0x820EE980;
		  /* 820EE980h */ case    5:  		/* bc 12, CR6_EQ, 1560 */
		/* 820EE980h case    5:*/		if ( regs.CR[6].eq ) { return 0x820EEF98;  }
		/* 820EE980h case    5:*/		return 0x820EE984;
		  /* 820EE984h */ case    6:  		/* lis R11, -32256 */
		/* 820EE984h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820EE984h case    6:*/		return 0x820EE988;
		  /* 820EE988h */ case    7:  		/* stw R17, <#[R1 + 92]> */
		/* 820EE988h case    7:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x0000005C) );
		/* 820EE988h case    7:*/		return 0x820EE98C;
		  /* 820EE98Ch */ case    8:  		/* mr R31, R17 */
		/* 820EE98Ch case    8:*/		regs.R31 = regs.R17;
		/* 820EE98Ch case    8:*/		return 0x820EE990;
		  /* 820EE990h */ case    9:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 820EE990h case    9:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 820EE990h case    9:*/		return 0x820EE994;
		  /* 820EE994h */ case   10:  		/* lwz R11, <#[R30 + 24]> */
		/* 820EE994h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820EE994h case   10:*/		return 0x820EE998;
		  /* 820EE998h */ case   11:  		/* lwzx R21, <#[R31 + R11]> */
		/* 820EE998h case   11:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820EE998h case   11:*/		return 0x820EE99C;
		  /* 820EE99Ch */ case   12:  		/* lwz R11, <#[R21]> */
		/* 820EE99Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820EE99Ch case   12:*/		return 0x820EE9A0;
		  /* 820EE9A0h */ case   13:  		/* rlwinm. R9, R11, 0, 0, 11 */
		/* 820EE9A0h case   13:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R9,regs.R11);
		/* 820EE9A0h case   13:*/		return 0x820EE9A4;
		  /* 820EE9A4h */ case   14:  		/* bc 12, CR0_EQ, 1500 */
		/* 820EE9A4h case   14:*/		if ( regs.CR[0].eq ) { return 0x820EEF80;  }
		/* 820EE9A4h case   14:*/		return 0x820EE9A8;
		  /* 820EE9A8h */ case   15:  		/* lwz R10, <#[R21 + 16]> */
		/* 820EE9A8h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000010) );
		/* 820EE9A8h case   15:*/		return 0x820EE9AC;
		  /* 820EE9ACh */ case   16:  		/* rlwinm R18, R11, 0, 12, 31 */
		/* 820EE9ACh case   16:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R18,regs.R11);
		/* 820EE9ACh case   16:*/		return 0x820EE9B0;
		  /* 820EE9B0h */ case   17:  		/* lwz R11, <#[R30]> */
		/* 820EE9B0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820EE9B0h case   17:*/		return 0x820EE9B4;
		  /* 820EE9B4h */ case   18:  		/* addi R5, R1, 84 */
		/* 820EE9B4h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820EE9B4h case   18:*/		return 0x820EE9B8;
		  /* 820EE9B8h */ case   19:  		/* lwz R9, <#[R30 + 20]> */
		/* 820EE9B8h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 820EE9B8h case   19:*/		return 0x820EE9BC;
		  /* 820EE9BCh */ case   20:  		/* mr R4, R21 */
		/* 820EE9BCh case   20:*/		regs.R4 = regs.R21;
		/* 820EE9BCh case   20:*/		return 0x820EE9C0;
		  /* 820EE9C0h */ case   21:  		/* lwz R8, <#[R21 + 4]> */
		/* 820EE9C0h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R21 + 0x00000004) );
		/* 820EE9C0h case   21:*/		return 0x820EE9C4;
		  /* 820EE9C4h */ case   22:  		/* mr R3, R30 */
		/* 820EE9C4h case   22:*/		regs.R3 = regs.R30;
		/* 820EE9C4h case   22:*/		return 0x820EE9C8;
		  /* 820EE9C8h */ case   23:  		/* twi 6, R18, 0 */
		/* 820EE9C8h case   23:*/		cpu::op::tw<6>(regs, 0x820EE9C8, regs.R18, 0x00000000);
		/* 820EE9C8h case   23:*/		return 0x820EE9CC;
		  /* 820EE9CCh */ case   24:  		/* lwz R10, <#[R10]> */
		/* 820EE9CCh case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820EE9CCh case   24:*/		return 0x820EE9D0;
		  /* 820EE9D0h */ case   25:  		/* divwu R14, R8, R18 */
		/* 820EE9D0h case   25:*/		cpu::op::divwu<0>(regs,&regs.R14,regs.R8,regs.R18);
		/* 820EE9D0h case   25:*/		return 0x820EE9D4;
		  /* 820EE9D4h */ case   26:  		/* lwz R11, <#[R11 + 32]> */
		/* 820EE9D4h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 820EE9D4h case   26:*/		return 0x820EE9D8;
		  /* 820EE9D8h */ case   27:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EE9D8h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EE9D8h case   27:*/		return 0x820EE9DC;
		  /* 820EE9DCh */ case   28:  		/* mtspr CTR, R11 */
		/* 820EE9DCh case   28:*/		regs.CTR = regs.R11;
		/* 820EE9DCh case   28:*/		return 0x820EE9E0;
		  /* 820EE9E0h */ case   29:  		/* lwzx R11, <#[R10 + R9]> */
		/* 820EE9E0h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EE9E0h case   29:*/		return 0x820EE9E4;
		  /* 820EE9E4h */ case   30:  		/* lwz R16, <#[R11 + 20]> */
		/* 820EE9E4h case   30:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R11 + 0x00000014) );
		/* 820EE9E4h case   30:*/		return 0x820EE9E8;
		  /* 820EE9E8h */ case   31:  		/* lwz R15, <#[R11 + 24]> */
		/* 820EE9E8h case   31:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R11 + 0x00000018) );
		/* 820EE9E8h case   31:*/		return 0x820EE9EC;
		  /* 820EE9ECh */ case   32:  		/* bcctrl 20, CR0_LT */
		/* 820EE9ECh case   32:*/		if ( 1 ) { regs.LR = 0x820EE9F0; return (uint32)regs.CTR; }
		/* 820EE9ECh case   32:*/		return 0x820EE9F0;
		  /* 820EE9F0h */ case   33:  		/* b 1388 */
		/* 820EE9F0h case   33:*/		return 0x820EEF5C;
		/* 820EE9F0h case   33:*/		return 0x820EE9F4;
		  /* 820EE9F4h */ case   34:  		/* lwz R11, <#[R21]> */
		/* 820EE9F4h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820EE9F4h case   34:*/		return 0x820EE9F8;
		  /* 820EE9F8h */ case   35:  		/* lis R10, 29712 */
		/* 820EE9F8h case   35:*/		cpu::op::lis<0>(regs,&regs.R10,0x7410);
		/* 820EE9F8h case   35:*/		return 0x820EE9FC;
		  /* 820EE9FCh */ case   36:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820EE9FCh case   36:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820EE9FCh case   36:*/		return 0x820EEA00;
		  /* 820EEA00h */ case   37:  		/* cmplw CR6, R11, R10 */
		/* 820EEA00h case   37:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EEA00h case   37:*/		return 0x820EEA04;
		  /* 820EEA04h */ case   38:  		/* bc 12, CR6_EQ, 1376 */
		/* 820EEA04h case   38:*/		if ( regs.CR[6].eq ) { return 0x820EEF64;  }
		/* 820EEA04h case   38:*/		return 0x820EEA08;
		  /* 820EEA08h */ case   39:  		/* lwz R11, <#[R1 + 84]> */
		/* 820EEA08h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820EEA08h case   39:*/		return 0x820EEA0C;
		  /* 820EEA0Ch */ case   40:  		/* lwz R10, <#[R21 + 8]> */
		/* 820EEA0Ch case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000008) );
		/* 820EEA0Ch case   40:*/		return 0x820EEA10;
		  /* 820EEA10h */ case   41:  		/* mullw R11, R11, R18 */
		/* 820EEA10h case   41:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R18);
		/* 820EEA10h case   41:*/		return 0x820EEA14;
		  /* 820EEA14h */ case   42:  		/* lwz R9, <#[R30 + 20]> */
		/* 820EEA14h case   42:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 820EEA14h case   42:*/		return 0x820EEA18;
		  /* 820EEA18h */ case   43:  		/* lwz R8, <#[R30 + 16]> */
		/* 820EEA18h case   43:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000010) );
		/* 820EEA18h case   43:*/		return 0x820EEA1C;
		  /* 820EEA1Ch */ case   44:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEA1Ch case   44:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEA1Ch case   44:*/		return 0x820EEA20;
		  /* 820EEA20h */ case   45:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EEA20h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EEA20h case   45:*/		return 0x820EEA24;
		  /* 820EEA24h */ case   46:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEA24h case   46:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEA24h case   46:*/		return 0x820EEA28;
		  /* 820EEA28h */ case   47:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820EEA28h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EEA28h case   47:*/		return 0x820EEA2C;
		  /* 820EEA2Ch */ case   48:  		/* lwz R11, <#[R11 + 4]> */
		/* 820EEA2Ch case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820EEA2Ch case   48:*/		return 0x820EEA30;
		  /* 820EEA30h */ case   49:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEA30h case   49:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEA30h case   49:*/		return 0x820EEA34;
		  /* 820EEA34h */ case   50:  		/* lwzx R25, <#[R11 + R8]> */
		/* 820EEA34h case   50:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820EEA34h case   50:*/		return 0x820EEA38;
		  /* 820EEA38h */ case   51:  		/* lwz R11, <#[R25 + 4]> */
		/* 820EEA38h case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820EEA38h case   51:*/		return 0x820EEA3C;
		  /* 820EEA3Ch */ case   52:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820EEA3Ch case   52:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820EEA3Ch case   52:*/		return 0x820EEA40;
		  /* 820EEA40h */ case   53:  		/* bc 4, CR0_EQ, 1384 */
		/* 820EEA40h case   53:*/		if ( !regs.CR[0].eq ) { return 0x820EEFA8;  }
		/* 820EEA40h case   53:*/		return 0x820EEA44;
		  /* 820EEA44h */ case   54:  		/* mr R27, R17 */
		/* 820EEA44h case   54:*/		regs.R27 = regs.R17;
		/* 820EEA44h case   54:*/		return 0x820EEA48;
		  /* 820EEA48h */ case   55:  		/* mr R28, R17 */
		/* 820EEA48h case   55:*/		regs.R28 = regs.R17;
		/* 820EEA48h case   55:*/		return 0x820EEA4C;
		  /* 820EEA4Ch */ case   56:  		/* cmplwi CR6, R14, 0 */
		/* 820EEA4Ch case   56:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820EEA4Ch case   56:*/		return 0x820EEA50;
		  /* 820EEA50h */ case   57:  		/* bc 12, CR6_EQ, 292 */
		/* 820EEA50h case   57:*/		if ( regs.CR[6].eq ) { return 0x820EEB74;  }
		/* 820EEA50h case   57:*/		return 0x820EEA54;
		  /* 820EEA54h */ case   58:  		/* mr R29, R17 */
		/* 820EEA54h case   58:*/		regs.R29 = regs.R17;
		/* 820EEA54h case   58:*/		return 0x820EEA58;
		  /* 820EEA58h */ case   59:  		/* rlwinm R26, R18, 2, 0, 29 */
		/* 820EEA58h case   59:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R18);
		/* 820EEA58h case   59:*/		return 0x820EEA5C;
		  /* 820EEA5Ch */ case   60:  		/* lwz R11, <#[R21 + 8]> */
		/* 820EEA5Ch case   60:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 820EEA5Ch case   60:*/		return 0x820EEA60;
		  /* 820EEA60h */ case   61:  		/* mr R5, R28 */
		/* 820EEA60h case   61:*/		regs.R5 = regs.R28;
		/* 820EEA60h case   61:*/		return 0x820EEA64;
		  /* 820EEA64h */ case   62:  		/* lwz R10, <#[R30 + 20]> */
		/* 820EEA64h case   62:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 820EEA64h case   62:*/		return 0x820EEA68;
		  /* 820EEA68h */ case   63:  		/* mr R4, R21 */
		/* 820EEA68h case   63:*/		regs.R4 = regs.R21;
		/* 820EEA68h case   63:*/		return 0x820EEA6C;
		  /* 820EEA6Ch */ case   64:  		/* lwz R9, <#[R30]> */
		/* 820EEA6Ch case   64:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 820EEA6Ch case   64:*/		return 0x820EEA70;
		  /* 820EEA70h */ case   65:  		/* mr R3, R30 */
		/* 820EEA70h case   65:*/		regs.R3 = regs.R30;
		/* 820EEA70h case   65:*/		return 0x820EEA74;
		  /* 820EEA74h */ case   66:  		/* lwz R8, <#[R30 + 16]> */
		/* 820EEA74h case   66:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000010) );
		/* 820EEA74h case   66:*/		return 0x820EEA78;
		  /* 820EEA78h */ case   67:  		/* lwzx R11, <#[R29 + R11]> */
		/* 820EEA78h case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820EEA78h case   67:*/		return 0x820EEA7C;
		  /* 820EEA7Ch */ case   68:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEA7Ch case   68:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEA7Ch case   68:*/		return 0x820EEA80;
		  /* 820EEA80h */ case   69:  		/* lwz R9, <#[R9 + 368]> */
		/* 820EEA80h case   69:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000170) );
		/* 820EEA80h case   69:*/		return 0x820EEA84;
		  /* 820EEA84h */ case   70:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EEA84h case   70:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EEA84h case   70:*/		return 0x820EEA88;
		  /* 820EEA88h */ case   71:  		/* mtspr CTR, R9 */
		/* 820EEA88h case   71:*/		regs.CTR = regs.R9;
		/* 820EEA88h case   71:*/		return 0x820EEA8C;
		  /* 820EEA8Ch */ case   72:  		/* lwz R11, <#[R11 + 4]> */
		/* 820EEA8Ch case   72:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820EEA8Ch case   72:*/		return 0x820EEA90;
		  /* 820EEA90h */ case   73:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEA90h case   73:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEA90h case   73:*/		return 0x820EEA94;
		  /* 820EEA94h */ case   74:  		/* lwzx R31, <#[R11 + R8]> */
		/* 820EEA94h case   74:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820EEA94h case   74:*/		return 0x820EEA98;
		  /* 820EEA98h */ case   75:  		/* bcctrl 20, CR0_LT */
		/* 820EEA98h case   75:*/		if ( 1 ) { regs.LR = 0x820EEA9C; return (uint32)regs.CTR; }
		/* 820EEA98h case   75:*/		return 0x820EEA9C;
		  /* 820EEA9Ch */ case   76:  		/* cmpwi CR6, R3, 1 */
		/* 820EEA9Ch case   76:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 820EEA9Ch case   76:*/		return 0x820EEAA0;
		  /* 820EEAA0h */ case   77:  		/* bc 12, CR6_EQ, 196 */
		/* 820EEAA0h case   77:*/		if ( regs.CR[6].eq ) { return 0x820EEB64;  }
		/* 820EEAA0h case   77:*/		return 0x820EEAA4;
		  /* 820EEAA4h */ case   78:  		/* lwz R11, <#[R31 + 4]> */
		/* 820EEAA4h case   78:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820EEAA4h case   78:*/		return 0x820EEAA8;
		  /* 820EEAA8h */ case   79:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 820EEAA8h case   79:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 820EEAA8h case   79:*/		return 0x820EEAAC;
		  /* 820EEAACh */ case   80:  		/* bc 12, CR0_EQ, 184 */
		/* 820EEAACh case   80:*/		if ( regs.CR[0].eq ) { return 0x820EEB64;  }
		/* 820EEAACh case   80:*/		return 0x820EEAB0;
		  /* 820EEAB0h */ case   81:  		/* lwz R10, <#[R25 + 4]> */
		/* 820EEAB0h case   81:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820EEAB0h case   81:*/		return 0x820EEAB4;
		  /* 820EEAB4h */ case   82:  		/* xor R11, R11, R10 */
		/* 820EEAB4h case   82:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820EEAB4h case   82:*/		return 0x820EEAB8;
		  /* 820EEAB8h */ case   83:  		/* andi. R11, R11, 4799 */
		/* 820EEAB8h case   83:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x12BF);
		/* 820EEAB8h case   83:*/		return 0x820EEABC;
		  /* 820EEABCh */ case   84:  		/* cmplwi CR0, R11, 0 */
		/* 820EEABCh case   84:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820EEABCh case   84:*/		return 0x820EEAC0;
		  /* 820EEAC0h */ case   85:  		/* bc 4, CR0_EQ, 164 */
		/* 820EEAC0h case   85:*/		if ( !regs.CR[0].eq ) { return 0x820EEB64;  }
		/* 820EEAC0h case   85:*/		return 0x820EEAC4;
		  /* 820EEAC4h */ case   86:  		/* cmplwi CR6, R18, 0 */
		/* 820EEAC4h case   86:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 820EEAC4h case   86:*/		return 0x820EEAC8;
		  /* 820EEAC8h */ case   87:  		/* bc 12, CR6_EQ, 156 */
		/* 820EEAC8h case   87:*/		if ( regs.CR[6].eq ) { return 0x820EEB64;  }
		/* 820EEAC8h case   87:*/		return 0x820EEACC;
		  /* 820EEACCh */ case   88:  		/* lwz R5, <#[R30 + 20]> */
		/* 820EEACCh case   88:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000014) );
		/* 820EEACCh case   88:*/		return 0x820EEAD0;
		  /* 820EEAD0h */ case   89:  		/* mr R3, R29 */
		/* 820EEAD0h case   89:*/		regs.R3 = regs.R29;
		/* 820EEAD0h case   89:*/		return 0x820EEAD4;
		  /* 820EEAD4h */ case   90:  		/* lwz R4, <#[R30 + 8]> */
		/* 820EEAD4h case   90:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000008) );
		/* 820EEAD4h case   90:*/		return 0x820EEAD8;
		  /* 820EEAD8h */ case   91:  		/* mtspr CTR, R18 */
		/* 820EEAD8h case   91:*/		regs.CTR = regs.R18;
		/* 820EEAD8h case   91:*/		return 0x820EEADC;
		  /* 820EEADCh */ case   92:  		/* lwz R11, <#[R21 + 8]> */
		/* 820EEADCh case   92:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 820EEADCh case   92:*/		return 0x820EEAE0;
		  /* 820EEAE0h */ case   93:  		/* mr R8, R17 */
		/* 820EEAE0h case   93:*/		regs.R8 = regs.R17;
		/* 820EEAE0h case   93:*/		return 0x820EEAE4;
		  /* 820EEAE4h */ case   94:  		/* mr R7, R17 */
		/* 820EEAE4h case   94:*/		regs.R7 = regs.R17;
		/* 820EEAE4h case   94:*/		return 0x820EEAE8;
		  /* 820EEAE8h */ case   95:  		/* cmplwi CR6, R4, 0 */
		/* 820EEAE8h case   95:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820EEAE8h case   95:*/		return 0x820EEAEC;
		  /* 820EEAECh */ case   96:  		/* lwzx R11, <#[R3 + R11]> */
		/* 820EEAECh case   96:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 820EEAECh case   96:*/		return 0x820EEAF0;
		  /* 820EEAF0h */ case   97:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEAF0h case   97:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEAF0h case   97:*/		return 0x820EEAF4;
		  /* 820EEAF4h */ case   98:  		/* lwzx R9, <#[R11 + R5]> */
		/* 820EEAF4h case   98:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820EEAF4h case   98:*/		return 0x820EEAF8;
		  /* 820EEAF8h */ case   99:  		/* bc 12, CR6_EQ, 100 */
		/* 820EEAF8h case   99:*/		if ( regs.CR[6].eq ) { return 0x820EEB5C;  }
		/* 820EEAF8h case   99:*/		return 0x820EEAFC;
		  /* 820EEAFCh */ case  100:  		/* lwz R6, <#[R9 + 4]> */
		/* 820EEAFCh case  100:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000004) );
		/* 820EEAFCh case  100:*/		return 0x820EEB00;
		  /* 820EEB00h */ case  101:  		/* mr R10, R17 */
		/* 820EEB00h case  101:*/		regs.R10 = regs.R17;
		/* 820EEB00h case  101:*/		return 0x820EEB04;
		  /* 820EEB04h */ case  102:  		/* lwzx R11, <#[R5 + R10]> */
		/* 820EEB04h case  102:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 820EEB04h case  102:*/		return 0x820EEB08;
		  /* 820EEB08h */ case  103:  		/* lwz R31, <#[R11 + 4]> */
		/* 820EEB08h case  103:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 820EEB08h case  103:*/		return 0x820EEB0C;
		  /* 820EEB0Ch */ case  104:  		/* cmplw CR6, R31, R6 */
		/* 820EEB0Ch case  104:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R6);
		/* 820EEB0Ch case  104:*/		return 0x820EEB10;
		  /* 820EEB10h */ case  105:  		/* bc 4, CR6_EQ, 44 */
		/* 820EEB10h case  105:*/		if ( !regs.CR[6].eq ) { return 0x820EEB3C;  }
		/* 820EEB10h case  105:*/		return 0x820EEB14;
		  /* 820EEB14h */ case  106:  		/* lwz R31, <#[R11 + 12]> */
		/* 820EEB14h case  106:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 820EEB14h case  106:*/		return 0x820EEB18;
		  /* 820EEB18h */ case  107:  		/* lwz R23, <#[R9 + 12]> */
		/* 820EEB18h case  107:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R9 + 0x0000000C) );
		/* 820EEB18h case  107:*/		return 0x820EEB1C;
		  /* 820EEB1Ch */ case  108:  		/* cmplw CR6, R31, R23 */
		/* 820EEB1Ch case  108:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R23);
		/* 820EEB1Ch case  108:*/		return 0x820EEB20;
		  /* 820EEB20h */ case  109:  		/* bc 4, CR6_EQ, 28 */
		/* 820EEB20h case  109:*/		if ( !regs.CR[6].eq ) { return 0x820EEB3C;  }
		/* 820EEB20h case  109:*/		return 0x820EEB24;
		  /* 820EEB24h */ case  110:  		/* lwz R31, <#[R11 + 8]> */
		/* 820EEB24h case  110:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000008) );
		/* 820EEB24h case  110:*/		return 0x820EEB28;
		  /* 820EEB28h */ case  111:  		/* lwz R23, <#[R9 + 8]> */
		/* 820EEB28h case  111:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R9 + 0x00000008) );
		/* 820EEB28h case  111:*/		return 0x820EEB2C;
		  /* 820EEB2Ch */ case  112:  		/* cmplw CR6, R31, R23 */
		/* 820EEB2Ch case  112:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R23);
		/* 820EEB2Ch case  112:*/		return 0x820EEB30;
		  /* 820EEB30h */ case  113:  		/* bc 4, CR6_EQ, 12 */
		/* 820EEB30h case  113:*/		if ( !regs.CR[6].eq ) { return 0x820EEB3C;  }
		/* 820EEB30h case  113:*/		return 0x820EEB34;
		  /* 820EEB34h */ case  114:  		/* lwz R11, <#[R11 + 92]> */
		/* 820EEB34h case  114:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000005C) );
		/* 820EEB34h case  114:*/		return 0x820EEB38;
		  /* 820EEB38h */ case  115:  		/* add R8, R11, R8 */
		/* 820EEB38h case  115:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 820EEB38h case  115:*/		return 0x820EEB3C;
	}
	return 0x820EEB3C;
} // Block from 820EE96Ch-820EEB3Ch (116 instructions)

//////////////////////////////////////////////////////
// Block at 820EEB3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEB3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEB3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEB3C);
		  /* 820EEB3Ch */ case    0:  		/* addi R7, R7, 1 */
		/* 820EEB3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820EEB3Ch case    0:*/		return 0x820EEB40;
		  /* 820EEB40h */ case    1:  		/* addi R10, R10, 4 */
		/* 820EEB40h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EEB40h case    1:*/		return 0x820EEB44;
		  /* 820EEB44h */ case    2:  		/* cmplw CR6, R7, R4 */
		/* 820EEB44h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 820EEB44h case    2:*/		return 0x820EEB48;
		  /* 820EEB48h */ case    3:  		/* bc 12, CR6_LT, -68 */
		/* 820EEB48h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EEB04;  }
		/* 820EEB48h case    3:*/		return 0x820EEB4C;
		  /* 820EEB4Ch */ case    4:  		/* cmplw CR6, R27, R8 */
		/* 820EEB4Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R8);
		/* 820EEB4Ch case    4:*/		return 0x820EEB50;
		  /* 820EEB50h */ case    5:  		/* bc 4, CR6_LT, 12 */
		/* 820EEB50h case    5:*/		if ( !regs.CR[6].lt ) { return 0x820EEB5C;  }
		/* 820EEB50h case    5:*/		return 0x820EEB54;
		  /* 820EEB54h */ case    6:  		/* stw R28, <#[R1 + 84]> */
		/* 820EEB54h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820EEB54h case    6:*/		return 0x820EEB58;
		  /* 820EEB58h */ case    7:  		/* mr R27, R8 */
		/* 820EEB58h case    7:*/		regs.R27 = regs.R8;
		/* 820EEB58h case    7:*/		return 0x820EEB5C;
	}
	return 0x820EEB5C;
} // Block from 820EEB3Ch-820EEB5Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EEB5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEB5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEB5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEB5C);
		  /* 820EEB5Ch */ case    0:  		/* addi R3, R3, 4 */
		/* 820EEB5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 820EEB5Ch case    0:*/		return 0x820EEB60;
		  /* 820EEB60h */ case    1:  		/* bc 16, CR0_LT, -132 */
		/* 820EEB60h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EEADC;  }
		/* 820EEB60h case    1:*/		return 0x820EEB64;
	}
	return 0x820EEB64;
} // Block from 820EEB5Ch-820EEB64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EEB64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEB64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEB64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEB64);
		  /* 820EEB64h */ case    0:  		/* addi R28, R28, 1 */
		/* 820EEB64h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820EEB64h case    0:*/		return 0x820EEB68;
		  /* 820EEB68h */ case    1:  		/* add R29, R26, R29 */
		/* 820EEB68h case    1:*/		cpu::op::add<0>(regs,&regs.R29,regs.R26,regs.R29);
		/* 820EEB68h case    1:*/		return 0x820EEB6C;
		  /* 820EEB6Ch */ case    2:  		/* cmplw CR6, R28, R14 */
		/* 820EEB6Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R14);
		/* 820EEB6Ch case    2:*/		return 0x820EEB70;
		  /* 820EEB70h */ case    3:  		/* bc 12, CR6_LT, -276 */
		/* 820EEB70h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EEA5C;  }
		/* 820EEB70h case    3:*/		return 0x820EEB74;
	}
	return 0x820EEB74;
} // Block from 820EEB64h-820EEB74h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EEB74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEB74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEB74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEB74);
		  /* 820EEB74h */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 820EEB74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820EEB74h case    0:*/		return 0x820EEB78;
		  /* 820EEB78h */ case    1:  		/* lwz R10, <#[R21 + 8]> */
		/* 820EEB78h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000008) );
		/* 820EEB78h case    1:*/		return 0x820EEB7C;
		  /* 820EEB7Ch */ case    2:  		/* mullw R11, R11, R18 */
		/* 820EEB7Ch case    2:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R18);
		/* 820EEB7Ch case    2:*/		return 0x820EEB80;
		  /* 820EEB80h */ case    3:  		/* lwz R9, <#[R30 + 20]> */
		/* 820EEB80h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 820EEB80h case    3:*/		return 0x820EEB84;
		  /* 820EEB84h */ case    4:  		/* lwz R8, <#[R30 + 16]> */
		/* 820EEB84h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000010) );
		/* 820EEB84h case    4:*/		return 0x820EEB88;
		  /* 820EEB88h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEB88h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEB88h case    5:*/		return 0x820EEB8C;
		  /* 820EEB8Ch */ case    6:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EEB8Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EEB8Ch case    6:*/		return 0x820EEB90;
		  /* 820EEB90h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEB90h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEB90h case    7:*/		return 0x820EEB94;
		  /* 820EEB94h */ case    8:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820EEB94h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EEB94h case    8:*/		return 0x820EEB98;
		  /* 820EEB98h */ case    9:  		/* lwz R22, <#[R11 + 4]> */
		/* 820EEB98h case    9:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R11 + 0x00000004) );
		/* 820EEB98h case    9:*/		return 0x820EEB9C;
		  /* 820EEB9Ch */ case   10:  		/* lwz R20, <#[R11 + 12]> */
		/* 820EEB9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R11 + 0x0000000C) );
		/* 820EEB9Ch case   10:*/		return 0x820EEBA0;
		  /* 820EEBA0h */ case   11:  		/* rlwinm R10, R22, 2, 0, 29 */
		/* 820EEBA0h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R22);
		/* 820EEBA0h case   11:*/		return 0x820EEBA4;
		  /* 820EEBA4h */ case   12:  		/* lwz R19, <#[R11 + 8]> */
		/* 820EEBA4h case   12:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R11 + 0x00000008) );
		/* 820EEBA4h case   12:*/		return 0x820EEBA8;
		  /* 820EEBA8h */ case   13:  		/* lwzx R11, <#[R10 + R8]> */
		/* 820EEBA8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820EEBA8h case   13:*/		return 0x820EEBAC;
		  /* 820EEBACh */ case   14:  		/* lwz R11, <#[R11 + 4]> */
		/* 820EEBACh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820EEBACh case   14:*/		return 0x820EEBB0;
		  /* 820EEBB0h */ case   15:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 820EEBB0h case   15:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 820EEBB0h case   15:*/		return 0x820EEBB4;
		  /* 820EEBB4h */ case   16:  		/* bc 12, CR0_EQ, 1048 */
		/* 820EEBB4h case   16:*/		if ( regs.CR[0].eq ) { return 0x820EEFCC;  }
		/* 820EEBB4h case   16:*/		return 0x820EEBB8;
		  /* 820EEBB8h */ case   17:  		/* addi R10, R1, 128 */
		/* 820EEBB8h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 820EEBB8h case   17:*/		return 0x820EEBBC;
		  /* 820EEBBCh */ case   18:  		/* lwz R7, <#[R30 + 8]> */
		/* 820EEBBCh case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 820EEBBCh case   18:*/		return 0x820EEBC0;
		  /* 820EEBC0h */ case   19:  		/* li R11, -1 */
		/* 820EEBC0h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820EEBC0h case   19:*/		return 0x820EEBC4;
		  /* 820EEBC4h */ case   20:  		/* mr R23, R17 */
		/* 820EEBC4h case   20:*/		regs.R23 = regs.R17;
		/* 820EEBC4h case   20:*/		return 0x820EEBC8;
		  /* 820EEBC8h */ case   21:  		/* mr R9, R17 */
		/* 820EEBC8h case   21:*/		regs.R9 = regs.R17;
		/* 820EEBC8h case   21:*/		return 0x820EEBCC;
		  /* 820EEBCCh */ case   22:  		/* cmplwi CR6, R7, 0 */
		/* 820EEBCCh case   22:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820EEBCCh case   22:*/		return 0x820EEBD0;
		  /* 820EEBD0h */ case   23:  		/* std R11, <#[R10]> */
		/* 820EEBD0h case   23:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820EEBD0h case   23:*/		return 0x820EEBD4;
		  /* 820EEBD4h */ case   24:  		/* std R11, <#[R10 + 8]> */
		/* 820EEBD4h case   24:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820EEBD4h case   24:*/		return 0x820EEBD8;
		  /* 820EEBD8h */ case   25:  		/* bc 12, CR6_EQ, 120 */
		/* 820EEBD8h case   25:*/		if ( regs.CR[6].eq ) { return 0x820EEC50;  }
		/* 820EEBD8h case   25:*/		return 0x820EEBDC;
		  /* 820EEBDCh */ case   26:  		/* lwz R6, <#[R30 + 20]> */
		/* 820EEBDCh case   26:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000014) );
		/* 820EEBDCh case   26:*/		return 0x820EEBE0;
		  /* 820EEBE0h */ case   27:  		/* mr R8, R17 */
		/* 820EEBE0h case   27:*/		regs.R8 = regs.R17;
		/* 820EEBE0h case   27:*/		return 0x820EEBE4;
		  /* 820EEBE4h */ case   28:  		/* lwzx R11, <#[R6 + R8]> */
		/* 820EEBE4h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820EEBE4h case   28:*/		return 0x820EEBE8;
		  /* 820EEBE8h */ case   29:  		/* lwz R10, <#[R11 + 4]> */
		/* 820EEBE8h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820EEBE8h case   29:*/		return 0x820EEBEC;
		  /* 820EEBECh */ case   30:  		/* cmplw CR6, R10, R22 */
		/* 820EEBECh case   30:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R22);
		/* 820EEBECh case   30:*/		return 0x820EEBF0;
		  /* 820EEBF0h */ case   31:  		/* bc 4, CR6_EQ, 80 */
		/* 820EEBF0h case   31:*/		if ( !regs.CR[6].eq ) { return 0x820EEC40;  }
		/* 820EEBF0h case   31:*/		return 0x820EEBF4;
		  /* 820EEBF4h */ case   32:  		/* lwz R10, <#[R11 + 12]> */
		/* 820EEBF4h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820EEBF4h case   32:*/		return 0x820EEBF8;
		  /* 820EEBF8h */ case   33:  		/* cmplw CR6, R10, R20 */
		/* 820EEBF8h case   33:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R20);
		/* 820EEBF8h case   33:*/		return 0x820EEBFC;
		  /* 820EEBFCh */ case   34:  		/* bc 4, CR6_EQ, 68 */
		/* 820EEBFCh case   34:*/		if ( !regs.CR[6].eq ) { return 0x820EEC40;  }
		/* 820EEBFCh case   34:*/		return 0x820EEC00;
		  /* 820EEC00h */ case   35:  		/* lwz R10, <#[R11 + 8]> */
		/* 820EEC00h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820EEC00h case   35:*/		return 0x820EEC04;
		  /* 820EEC04h */ case   36:  		/* cmplw CR6, R10, R19 */
		/* 820EEC04h case   36:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R19);
		/* 820EEC04h case   36:*/		return 0x820EEC08;
		  /* 820EEC08h */ case   37:  		/* bc 4, CR6_EQ, 56 */
		/* 820EEC08h case   37:*/		if ( !regs.CR[6].eq ) { return 0x820EEC40;  }
		/* 820EEC08h case   37:*/		return 0x820EEC0C;
		  /* 820EEC0Ch */ case   38:  		/* lwz R10, <#[R11 + 60]> */
		/* 820EEC0Ch case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 820EEC0Ch case   38:*/		return 0x820EEC10;
		  /* 820EEC10h */ case   39:  		/* cmplwi CR6, R10, 0 */
		/* 820EEC10h case   39:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820EEC10h case   39:*/		return 0x820EEC14;
		  /* 820EEC14h */ case   40:  		/* bc 4, CR6_EQ, 44 */
		/* 820EEC14h case   40:*/		if ( !regs.CR[6].eq ) { return 0x820EEC40;  }
		/* 820EEC14h case   40:*/		return 0x820EEC18;
		  /* 820EEC18h */ case   41:  		/* lwz R10, <#[R11 + 88]> */
		/* 820EEC18h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000058) );
		/* 820EEC18h case   41:*/		return 0x820EEC1C;
		  /* 820EEC1Ch */ case   42:  		/* cmplw CR6, R10, R24 */
		/* 820EEC1Ch case   42:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 820EEC1Ch case   42:*/		return 0x820EEC20;
		  /* 820EEC20h */ case   43:  		/* bc 12, CR6_LT, 32 */
		/* 820EEC20h case   43:*/		if ( regs.CR[6].lt ) { return 0x820EEC40;  }
		/* 820EEC20h case   43:*/		return 0x820EEC24;
		  /* 820EEC24h */ case   44:  		/* lwz R11, <#[R11 + 16]> */
		/* 820EEC24h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820EEC24h case   44:*/		return 0x820EEC28;
		  /* 820EEC28h */ case   45:  		/* addi R5, R1, 128 */
		/* 820EEC28h case   45:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 820EEC28h case   45:*/		return 0x820EEC2C;
		  /* 820EEC2Ch */ case   46:  		/* cmplw CR6, R23, R10 */
		/* 820EEC2Ch case   46:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R10);
		/* 820EEC2Ch case   46:*/		return 0x820EEC30;
		  /* 820EEC30h */ case   47:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEC30h case   47:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEC30h case   47:*/		return 0x820EEC34;
		  /* 820EEC34h */ case   48:  		/* stwx R9, <#[R11 + R5]> */
		/* 820EEC34h case   48:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820EEC34h case   48:*/		return 0x820EEC38;
		  /* 820EEC38h */ case   49:  		/* bc 12, CR6_GT, 8 */
		/* 820EEC38h case   49:*/		if ( regs.CR[6].gt ) { return 0x820EEC40;  }
		/* 820EEC38h case   49:*/		return 0x820EEC3C;
		  /* 820EEC3Ch */ case   50:  		/* addi R23, R10, 1 */
		/* 820EEC3Ch case   50:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0x1);
		/* 820EEC3Ch case   50:*/		return 0x820EEC40;
	}
	return 0x820EEC40;
} // Block from 820EEB74h-820EEC40h (51 instructions)

//////////////////////////////////////////////////////
// Block at 820EEC40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEC40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEC40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEC40);
		  /* 820EEC40h */ case    0:  		/* addi R9, R9, 1 */
		/* 820EEC40h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820EEC40h case    0:*/		return 0x820EEC44;
		  /* 820EEC44h */ case    1:  		/* addi R8, R8, 4 */
		/* 820EEC44h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820EEC44h case    1:*/		return 0x820EEC48;
		  /* 820EEC48h */ case    2:  		/* cmplw CR6, R9, R7 */
		/* 820EEC48h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 820EEC48h case    2:*/		return 0x820EEC4C;
		  /* 820EEC4Ch */ case    3:  		/* bc 12, CR6_LT, -104 */
		/* 820EEC4Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820EEBE4;  }
		/* 820EEC4Ch case    3:*/		return 0x820EEC50;
	}
	return 0x820EEC50;
} // Block from 820EEC40h-820EEC50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EEC50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEC50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEC50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEC50);
		  /* 820EEC50h */ case    0:  		/* mr R29, R17 */
		/* 820EEC50h case    0:*/		regs.R29 = regs.R17;
		/* 820EEC50h case    0:*/		return 0x820EEC54;
		  /* 820EEC54h */ case    1:  		/* mr R27, R17 */
		/* 820EEC54h case    1:*/		regs.R27 = regs.R17;
		/* 820EEC54h case    1:*/		return 0x820EEC58;
		  /* 820EEC58h */ case    2:  		/* mr R28, R17 */
		/* 820EEC58h case    2:*/		regs.R28 = regs.R17;
		/* 820EEC58h case    2:*/		return 0x820EEC5C;
		  /* 820EEC5Ch */ case    3:  		/* addi R11, R1, 128 */
		/* 820EEC5Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820EEC5Ch case    3:*/		return 0x820EEC60;
		  /* 820EEC60h */ case    4:  		/* lwzx R31, <#[R28 + R11]> */
		/* 820EEC60h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820EEC60h case    4:*/		return 0x820EEC64;
		  /* 820EEC64h */ case    5:  		/* cmpwi CR6, R31, -1 */
		/* 820EEC64h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 820EEC64h case    5:*/		return 0x820EEC68;
		  /* 820EEC68h */ case    6:  		/* bc 12, CR6_EQ, 108 */
		/* 820EEC68h case    6:*/		if ( regs.CR[6].eq ) { return 0x820EECD4;  }
		/* 820EEC68h case    6:*/		return 0x820EEC6C;
		  /* 820EEC6Ch */ case    7:  		/* mr R6, R27 */
		/* 820EEC6Ch case    7:*/		regs.R6 = regs.R27;
		/* 820EEC6Ch case    7:*/		return 0x820EEC70;
		  /* 820EEC70h */ case    8:  		/* lwz R4, <#[R30 + 136]> */
		/* 820EEC70h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000088) );
		/* 820EEC70h case    8:*/		return 0x820EEC74;
		  /* 820EEC74h */ case    9:  		/* mr R3, R30 */
		/* 820EEC74h case    9:*/		regs.R3 = regs.R30;
		/* 820EEC74h case    9:*/		return 0x820EEC78;
		  /* 820EEC78h */ case   10:  		/* lwz R5, <#[R1 + 80]> */
		/* 820EEC78h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820EEC78h case   10:*/		return 0x820EEC7C;
		  /* 820EEC7Ch */ case   11:  		/* fmr FR1, FR31 */
		/* 820EEC7Ch case   11:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820EEC7Ch case   11:*/		return 0x820EEC80;
		  /* 820EEC80h */ case   12:  		/* bl 58792 */
		/* 820EEC80h case   12:*/		regs.LR = 0x820EEC84; return 0x820FD228;
		/* 820EEC80h case   12:*/		return 0x820EEC84;
		  /* 820EEC84h */ case   13:  		/* addi R11, R1, 112 */
		/* 820EEC84h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820EEC84h case   13:*/		return 0x820EEC88;
		  /* 820EEC88h */ case   14:  		/* cmpwi CR6, R3, -1 */
		/* 820EEC88h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820EEC88h case   14:*/		return 0x820EEC8C;
		  /* 820EEC8Ch */ case   15:  		/* stwx R3, <#[R28 + R11]> */
		/* 820EEC8Ch case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820EEC8Ch case   15:*/		return 0x820EEC90;
		  /* 820EEC90h */ case   16:  		/* bc 12, CR6_EQ, 840 */
		/* 820EEC90h case   16:*/		if ( regs.CR[6].eq ) { return 0x820EEFD8;  }
		/* 820EEC90h case   16:*/		return 0x820EEC94;
		  /* 820EEC94h */ case   17:  		/* lwz R11, <#[R30 + 20]> */
		/* 820EEC94h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820EEC94h case   17:*/		return 0x820EEC98;
		  /* 820EEC98h */ case   18:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820EEC98h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820EEC98h case   18:*/		return 0x820EEC9C;
		  /* 820EEC9Ch */ case   19:  		/* rlwinm R9, R31, 2, 0, 29 */
		/* 820EEC9Ch case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R31);
		/* 820EEC9Ch case   19:*/		return 0x820EECA0;
		  /* 820EECA0h */ case   20:  		/* lwzx R31, <#[R10 + R11]> */
		/* 820EECA0h case   20:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EECA0h case   20:*/		return 0x820EECA4;
		  /* 820EECA4h */ case   21:  		/* lwzx R4, <#[R9 + R11]> */
		/* 820EECA4h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820EECA4h case   21:*/		return 0x820EECA8;
		  /* 820EECA8h */ case   22:  		/* mr R3, R31 */
		/* 820EECA8h case   22:*/		regs.R3 = regs.R31;
		/* 820EECA8h case   22:*/		return 0x820EECAC;
		  /* 820EECACh */ case   23:  		/* bl 57332 */
		/* 820EECACh case   23:*/		regs.LR = 0x820EECB0; return 0x820FCCA0;
		/* 820EECACh case   23:*/		return 0x820EECB0;
		  /* 820EECB0h */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 820EECB0h case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EECB0h case   24:*/		return 0x820EECB4;
		  /* 820EECB4h */ case   25:  		/* bc 12, CR0_LT, 744 */
		/* 820EECB4h case   25:*/		if ( regs.CR[0].lt ) { return 0x820EEF9C;  }
		/* 820EECB4h case   25:*/		return 0x820EECB8;
		  /* 820EECB8h */ case   26:  		/* li R11, -1 */
		/* 820EECB8h case   26:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820EECB8h case   26:*/		return 0x820EECBC;
		  /* 820EECBCh */ case   27:  		/* stw R16, <#[R31 + 20]> */
		/* 820EECBCh case   27:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R31 + 0x00000014) );
		/* 820EECBCh case   27:*/		return 0x820EECC0;
		  /* 820EECC0h */ case   28:  		/* stw R15, <#[R31 + 24]> */
		/* 820EECC0h case   28:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R31 + 0x00000018) );
		/* 820EECC0h case   28:*/		return 0x820EECC4;
		  /* 820EECC4h */ case   29:  		/* addi R29, R29, 1 */
		/* 820EECC4h case   29:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820EECC4h case   29:*/		return 0x820EECC8;
		  /* 820EECC8h */ case   30:  		/* stw R17, <#[R31 + 104]> */
		/* 820EECC8h case   30:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R31 + 0x00000068) );
		/* 820EECC8h case   30:*/		return 0x820EECCC;
		  /* 820EECCCh */ case   31:  		/* stw R11, <#[R31 + 108]> */
		/* 820EECCCh case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820EECCCh case   31:*/		return 0x820EECD0;
		  /* 820EECD0h */ case   32:  		/* stw R17, <#[R31 + 112]> */
		/* 820EECD0h case   32:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R31 + 0x00000070) );
		/* 820EECD0h case   32:*/		return 0x820EECD4;
	}
	return 0x820EECD4;
} // Block from 820EEC50h-820EECD4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820EECD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EECD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EECD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EECD4);
		  /* 820EECD4h */ case    0:  		/* addi R28, R28, 4 */
		/* 820EECD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820EECD4h case    0:*/		return 0x820EECD8;
		  /* 820EECD8h */ case    1:  		/* addi R27, R27, 1 */
		/* 820EECD8h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820EECD8h case    1:*/		return 0x820EECDC;
		  /* 820EECDCh */ case    2:  		/* cmplwi CR6, R28, 16 */
		/* 820EECDCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000010);
		/* 820EECDCh case    2:*/		return 0x820EECE0;
		  /* 820EECE0h */ case    3:  		/* bc 12, CR6_LT, -132 */
		/* 820EECE0h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EEC5C;  }
		/* 820EECE0h case    3:*/		return 0x820EECE4;
		  /* 820EECE4h */ case    4:  		/* li R11, 1 */
		/* 820EECE4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820EECE4h case    4:*/		return 0x820EECE8;
		  /* 820EECE8h */ case    5:  		/* mr R4, R29 */
		/* 820EECE8h case    5:*/		regs.R4 = regs.R29;
		/* 820EECE8h case    5:*/		return 0x820EECEC;
		  /* 820EECECh */ case    6:  		/* mr R6, R29 */
		/* 820EECECh case    6:*/		regs.R6 = regs.R29;
		/* 820EECECh case    6:*/		return 0x820EECF0;
		  /* 820EECF0h */ case    7:  		/* rlwimi R4, R11, 28, 0, 11 */
		/* 820EECF0h case    7:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R11);
		/* 820EECF0h case    7:*/		return 0x820EECF4;
		  /* 820EECF4h */ case    8:  		/* mr R5, R29 */
		/* 820EECF4h case    8:*/		regs.R5 = regs.R29;
		/* 820EECF4h case    8:*/		return 0x820EECF8;
		  /* 820EECF8h */ case    9:  		/* mr R3, R30 */
		/* 820EECF8h case    9:*/		regs.R3 = regs.R30;
		/* 820EECF8h case    9:*/		return 0x820EECFC;
		  /* 820EECFCh */ case   10:  		/* bl 58828 */
		/* 820EECFCh case   10:*/		regs.LR = 0x820EED00; return 0x820FD2C8;
		/* 820EECFCh case   10:*/		return 0x820EED00;
		  /* 820EED00h */ case   11:  		/* cmpwi CR6, R3, -1 */
		/* 820EED00h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820EED00h case   11:*/		return 0x820EED04;
		  /* 820EED04h */ case   12:  		/* bc 12, CR6_EQ, 724 */
		/* 820EED04h case   12:*/		if ( regs.CR[6].eq ) { return 0x820EEFD8;  }
		/* 820EED04h case   12:*/		return 0x820EED08;
		  /* 820EED08h */ case   13:  		/* lwz R11, <#[R30 + 24]> */
		/* 820EED08h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820EED08h case   13:*/		return 0x820EED0C;
		  /* 820EED0Ch */ case   14:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820EED0Ch case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820EED0Ch case   14:*/		return 0x820EED10;
		  /* 820EED10h */ case   15:  		/* mr R4, R21 */
		/* 820EED10h case   15:*/		regs.R4 = regs.R21;
		/* 820EED10h case   15:*/		return 0x820EED14;
		  /* 820EED14h */ case   16:  		/* lwzx R31, <#[R10 + R11]> */
		/* 820EED14h case   16:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EED14h case   16:*/		return 0x820EED18;
		  /* 820EED18h */ case   17:  		/* mr R3, R31 */
		/* 820EED18h case   17:*/		regs.R3 = regs.R31;
		/* 820EED18h case   17:*/		return 0x820EED1C;
		  /* 820EED1Ch */ case   18:  		/* bl 53716 */
		/* 820EED1Ch case   18:*/		regs.LR = 0x820EED20; return 0x820FBEF0;
		/* 820EED1Ch case   18:*/		return 0x820EED20;
		  /* 820EED20h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820EED20h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EED20h case   19:*/		return 0x820EED24;
		  /* 820EED24h */ case   20:  		/* bc 12, CR0_LT, 632 */
		/* 820EED24h case   20:*/		if ( regs.CR[0].lt ) { return 0x820EEF9C;  }
		/* 820EED24h case   20:*/		return 0x820EED28;
		  /* 820EED28h */ case   21:  		/* li R9, 4 */
		/* 820EED28h case   21:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820EED28h case   21:*/		return 0x820EED2C;
		  /* 820EED2Ch */ case   22:  		/* mr R11, R17 */
		/* 820EED2Ch case   22:*/		regs.R11 = regs.R17;
		/* 820EED2Ch case   22:*/		return 0x820EED30;
		  /* 820EED30h */ case   23:  		/* mr R10, R17 */
		/* 820EED30h case   23:*/		regs.R10 = regs.R17;
		/* 820EED30h case   23:*/		return 0x820EED34;
		  /* 820EED34h */ case   24:  		/* mtspr CTR, R9 */
		/* 820EED34h case   24:*/		regs.CTR = regs.R9;
		/* 820EED34h case   24:*/		return 0x820EED38;
		  /* 820EED38h */ case   25:  		/* addi R9, R1, 128 */
		/* 820EED38h case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 820EED38h case   25:*/		return 0x820EED3C;
		  /* 820EED3Ch */ case   26:  		/* lwzx R9, <#[R10 + R9]> */
		/* 820EED3Ch case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EED3Ch case   26:*/		return 0x820EED40;
		  /* 820EED40h */ case   27:  		/* cmpwi CR6, R9, -1 */
		/* 820EED40h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820EED40h case   27:*/		return 0x820EED44;
		  /* 820EED44h */ case   28:  		/* bc 12, CR6_EQ, 32 */
		/* 820EED44h case   28:*/		if ( regs.CR[6].eq ) { return 0x820EED64;  }
		/* 820EED44h case   28:*/		return 0x820EED48;
		  /* 820EED48h */ case   29:  		/* addi R8, R1, 112 */
		/* 820EED48h case   29:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x70);
		/* 820EED48h case   29:*/		return 0x820EED4C;
		  /* 820EED4Ch */ case   30:  		/* lwz R7, <#[R31 + 8]> */
		/* 820EED4Ch case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 820EED4Ch case   30:*/		return 0x820EED50;
		  /* 820EED50h */ case   31:  		/* lwzx R8, <#[R10 + R8]> */
		/* 820EED50h case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820EED50h case   31:*/		return 0x820EED54;
		  /* 820EED54h */ case   32:  		/* stwx R9, <#[R7 + R11]> */
		/* 820EED54h case   32:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 820EED54h case   32:*/		return 0x820EED58;
		  /* 820EED58h */ case   33:  		/* lwz R9, <#[R31 + 16]> */
		/* 820EED58h case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820EED58h case   33:*/		return 0x820EED5C;
		  /* 820EED5Ch */ case   34:  		/* stwx R8, <#[R9 + R11]> */
		/* 820EED5Ch case   34:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820EED5Ch case   34:*/		return 0x820EED60;
		  /* 820EED60h */ case   35:  		/* addi R11, R11, 4 */
		/* 820EED60h case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EED60h case   35:*/		return 0x820EED64;
	}
	return 0x820EED64;
} // Block from 820EECD4h-820EED64h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820EED64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EED64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EED64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EED64);
		  /* 820EED64h */ case    0:  		/* addi R10, R10, 4 */
		/* 820EED64h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EED64h case    0:*/		return 0x820EED68;
		  /* 820EED68h */ case    1:  		/* bc 16, CR0_LT, -48 */
		/* 820EED68h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EED38;  }
		/* 820EED68h case    1:*/		return 0x820EED6C;
		  /* 820EED6Ch */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 820EED6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820EED6Ch case    2:*/		return 0x820EED70;
		  /* 820EED70h */ case    3:  		/* lwz R24, <#[R1 + 88]> */
		/* 820EED70h case    3:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000058) );
		/* 820EED70h case    3:*/		return 0x820EED74;
		  /* 820EED74h */ case    4:  		/* addi R11, R11, 1 */
		/* 820EED74h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EED74h case    4:*/		return 0x820EED78;
		  /* 820EED78h */ case    5:  		/* cmplw CR6, R24, R23 */
		/* 820EED78h case    5:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R23);
		/* 820EED78h case    5:*/		return 0x820EED7C;
		  /* 820EED7Ch */ case    6:  		/* stw R11, <#[R1 + 80]> */
		/* 820EED7Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820EED7Ch case    6:*/		return 0x820EED80;
		  /* 820EED80h */ case    7:  		/* bc 4, CR6_LT, 440 */
		/* 820EED80h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820EEF38;  }
		/* 820EED80h case    7:*/		return 0x820EED84;
		  /* 820EED84h */ case    8:  		/* lwz R25, <#[R1 + 92]> */
		/* 820EED84h case    8:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x0000005C) );
		/* 820EED84h case    8:*/		return 0x820EED88;
		  /* 820EED88h */ case    9:  		/* lwz R11, <#[R30 + 24]> */
		/* 820EED88h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820EED88h case    9:*/		return 0x820EED8C;
		  /* 820EED8Ch */ case   10:  		/* lwzx R27, <#[R25 + R11]> */
		/* 820EED8Ch case   10:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R25 + regs.R11 + 0x00000000) );
		/* 820EED8Ch case   10:*/		return 0x820EED90;
		  /* 820EED90h */ case   11:  		/* lwz R11, <#[R27]> */
		/* 820EED90h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820EED90h case   11:*/		return 0x820EED94;
		  /* 820EED94h */ case   12:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 820EED94h case   12:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820EED94h case   12:*/		return 0x820EED98;
		  /* 820EED98h */ case   13:  		/* bc 12, CR0_EQ, 400 */
		/* 820EED98h case   13:*/		if ( regs.CR[0].eq ) { return 0x820EEF28;  }
		/* 820EED98h case   13:*/		return 0x820EED9C;
		  /* 820EED9Ch */ case   14:  		/* lwz R11, <#[R27 + 16]> */
		/* 820EED9Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 820EED9Ch case   14:*/		return 0x820EEDA0;
		  /* 820EEDA0h */ case   15:  		/* lwz R11, <#[R11]> */
		/* 820EEDA0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820EEDA0h case   15:*/		return 0x820EEDA4;
		  /* 820EEDA4h */ case   16:  		/* b 20 */
		/* 820EEDA4h case   16:*/		return 0x820EEDB8;
		/* 820EEDA4h case   16:*/		return 0x820EEDA8;
		  /* 820EEDA8h */ case   17:  		/* cmplw CR6, R11, R16 */
		/* 820EEDA8h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 820EEDA8h case   17:*/		return 0x820EEDAC;
		  /* 820EEDACh */ case   18:  		/* bc 4, CR6_EQ, 12 */
		/* 820EEDACh case   18:*/		if ( !regs.CR[6].eq ) { return 0x820EEDB8;  }
		/* 820EEDACh case   18:*/		return 0x820EEDB0;
		  /* 820EEDB0h */ case   19:  		/* cmpw CR6, R10, R15 */
		/* 820EEDB0h case   19:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R15);
		/* 820EEDB0h case   19:*/		return 0x820EEDB4;
		  /* 820EEDB4h */ case   20:  		/* bc 12, CR6_EQ, 32 */
		/* 820EEDB4h case   20:*/		if ( regs.CR[6].eq ) { return 0x820EEDD4;  }
		/* 820EEDB4h case   20:*/		return 0x820EEDB8;
	}
	return 0x820EEDB8;
} // Block from 820EED64h-820EEDB8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820EEDB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEDB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEDB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEDB8);
		  /* 820EEDB8h */ case    0:  		/* lwz R10, <#[R30 + 20]> */
		/* 820EEDB8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 820EEDB8h case    0:*/		return 0x820EEDBC;
		  /* 820EEDBCh */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEDBCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEDBCh case    1:*/		return 0x820EEDC0;
		  /* 820EEDC0h */ case    2:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820EEDC0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EEDC0h case    2:*/		return 0x820EEDC4;
		  /* 820EEDC4h */ case    3:  		/* lwz R11, <#[R10 + 20]> */
		/* 820EEDC4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 820EEDC4h case    3:*/		return 0x820EEDC8;
		  /* 820EEDC8h */ case    4:  		/* lwz R10, <#[R10 + 24]> */
		/* 820EEDC8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 820EEDC8h case    4:*/		return 0x820EEDCC;
		  /* 820EEDCCh */ case    5:  		/* cmpwi CR6, R11, -1 */
		/* 820EEDCCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EEDCCh case    5:*/		return 0x820EEDD0;
		  /* 820EEDD0h */ case    6:  		/* bc 4, CR6_EQ, -40 */
		/* 820EEDD0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820EEDA8;  }
		/* 820EEDD0h case    6:*/		return 0x820EEDD4;
	}
	return 0x820EEDD4;
} // Block from 820EEDB8h-820EEDD4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EEDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEDD4);
		  /* 820EEDD4h */ case    0:  		/* cmplw CR6, R11, R16 */
		/* 820EEDD4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 820EEDD4h case    0:*/		return 0x820EEDD8;
		  /* 820EEDD8h */ case    1:  		/* bc 4, CR6_EQ, 336 */
		/* 820EEDD8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EEF28;  }
		/* 820EEDD8h case    1:*/		return 0x820EEDDC;
		  /* 820EEDDCh */ case    2:  		/* cmpw CR6, R10, R15 */
		/* 820EEDDCh case    2:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R15);
		/* 820EEDDCh case    2:*/		return 0x820EEDE0;
		  /* 820EEDE0h */ case    3:  		/* bc 4, CR6_EQ, 328 */
		/* 820EEDE0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820EEF28;  }
		/* 820EEDE0h case    3:*/		return 0x820EEDE4;
		  /* 820EEDE4h */ case    4:  		/* lwz R11, <#[R30]> */
		/* 820EEDE4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820EEDE4h case    4:*/		return 0x820EEDE8;
		  /* 820EEDE8h */ case    5:  		/* li R5, 0 */
		/* 820EEDE8h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EEDE8h case    5:*/		return 0x820EEDEC;
		  /* 820EEDECh */ case    6:  		/* mr R4, R27 */
		/* 820EEDECh case    6:*/		regs.R4 = regs.R27;
		/* 820EEDECh case    6:*/		return 0x820EEDF0;
		  /* 820EEDF0h */ case    7:  		/* mr R3, R30 */
		/* 820EEDF0h case    7:*/		regs.R3 = regs.R30;
		/* 820EEDF0h case    7:*/		return 0x820EEDF4;
		  /* 820EEDF4h */ case    8:  		/* lwz R11, <#[R11 + 32]> */
		/* 820EEDF4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 820EEDF4h case    8:*/		return 0x820EEDF8;
		  /* 820EEDF8h */ case    9:  		/* mtspr CTR, R11 */
		/* 820EEDF8h case    9:*/		regs.CTR = regs.R11;
		/* 820EEDF8h case    9:*/		return 0x820EEDFC;
		  /* 820EEDFCh */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820EEDFCh case   10:*/		if ( 1 ) { regs.LR = 0x820EEE00; return (uint32)regs.CTR; }
		/* 820EEDFCh case   10:*/		return 0x820EEE00;
		  /* 820EEE00h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820EEE00h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EEE00h case   11:*/		return 0x820EEE04;
		  /* 820EEE04h */ case   12:  		/* bc 12, CR0_EQ, 292 */
		/* 820EEE04h case   12:*/		if ( regs.CR[0].eq ) { return 0x820EEF28;  }
		/* 820EEE04h case   12:*/		return 0x820EEE08;
		  /* 820EEE08h */ case   13:  		/* lwz R11, <#[R27]> */
		/* 820EEE08h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820EEE08h case   13:*/		return 0x820EEE0C;
		  /* 820EEE0Ch */ case   14:  		/* lis R10, 29712 */
		/* 820EEE0Ch case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x7410);
		/* 820EEE0Ch case   14:*/		return 0x820EEE10;
		  /* 820EEE10h */ case   15:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820EEE10h case   15:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820EEE10h case   15:*/		return 0x820EEE14;
		  /* 820EEE14h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 820EEE14h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EEE14h case   16:*/		return 0x820EEE18;
		  /* 820EEE18h */ case   17:  		/* bc 12, CR6_EQ, 272 */
		/* 820EEE18h case   17:*/		if ( regs.CR[6].eq ) { return 0x820EEF28;  }
		/* 820EEE18h case   17:*/		return 0x820EEE1C;
		  /* 820EEE1Ch */ case   18:  		/* lwz R11, <#[R27 + 4]> */
		/* 820EEE1Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 820EEE1Ch case   18:*/		return 0x820EEE20;
		  /* 820EEE20h */ case   19:  		/* mr R26, R17 */
		/* 820EEE20h case   19:*/		regs.R26 = regs.R17;
		/* 820EEE20h case   19:*/		return 0x820EEE24;
		  /* 820EEE24h */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 820EEE24h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EEE24h case   20:*/		return 0x820EEE28;
		  /* 820EEE28h */ case   21:  		/* bc 4, CR6_GT, 256 */
		/* 820EEE28h case   21:*/		if ( !regs.CR[6].gt ) { return 0x820EEF28;  }
		/* 820EEE28h case   21:*/		return 0x820EEE2C;
		  /* 820EEE2Ch */ case   22:  		/* mr R31, R17 */
		/* 820EEE2Ch case   22:*/		regs.R31 = regs.R17;
		/* 820EEE2Ch case   22:*/		return 0x820EEE30;
		  /* 820EEE30h */ case   23:  		/* lwz R10, <#[R27 + 8]> */
		/* 820EEE30h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 820EEE30h case   23:*/		return 0x820EEE34;
		  /* 820EEE34h */ case   24:  		/* lwz R11, <#[R30 + 20]> */
		/* 820EEE34h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820EEE34h case   24:*/		return 0x820EEE38;
		  /* 820EEE38h */ case   25:  		/* lwzx R9, <#[R31 + R10]> */
		/* 820EEE38h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 820EEE38h case   25:*/		return 0x820EEE3C;
		  /* 820EEE3Ch */ case   26:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820EEE3Ch case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820EEE3Ch case   26:*/		return 0x820EEE40;
		  /* 820EEE40h */ case   27:  		/* lwzx R29, <#[R9 + R11]> */
		/* 820EEE40h case   27:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820EEE40h case   27:*/		return 0x820EEE44;
		  /* 820EEE44h */ case   28:  		/* lwz R9, <#[R29 + 4]> */
		/* 820EEE44h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000004) );
		/* 820EEE44h case   28:*/		return 0x820EEE48;
		  /* 820EEE48h */ case   29:  		/* cmplw CR6, R9, R22 */
		/* 820EEE48h case   29:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R22);
		/* 820EEE48h case   29:*/		return 0x820EEE4C;
		  /* 820EEE4Ch */ case   30:  		/* bc 4, CR6_EQ, 200 */
		/* 820EEE4Ch case   30:*/		if ( !regs.CR[6].eq ) { return 0x820EEF14;  }
		/* 820EEE4Ch case   30:*/		return 0x820EEE50;
		  /* 820EEE50h */ case   31:  		/* lwz R9, <#[R29 + 12]> */
		/* 820EEE50h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x0000000C) );
		/* 820EEE50h case   31:*/		return 0x820EEE54;
		  /* 820EEE54h */ case   32:  		/* cmplw CR6, R9, R20 */
		/* 820EEE54h case   32:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R20);
		/* 820EEE54h case   32:*/		return 0x820EEE58;
		  /* 820EEE58h */ case   33:  		/* bc 4, CR6_EQ, 188 */
		/* 820EEE58h case   33:*/		if ( !regs.CR[6].eq ) { return 0x820EEF14;  }
		/* 820EEE58h case   33:*/		return 0x820EEE5C;
		  /* 820EEE5Ch */ case   34:  		/* lwz R9, <#[R29 + 8]> */
		/* 820EEE5Ch case   34:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 820EEE5Ch case   34:*/		return 0x820EEE60;
		  /* 820EEE60h */ case   35:  		/* cmplw CR6, R9, R19 */
		/* 820EEE60h case   35:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R19);
		/* 820EEE60h case   35:*/		return 0x820EEE64;
		  /* 820EEE64h */ case   36:  		/* bc 4, CR6_EQ, 176 */
		/* 820EEE64h case   36:*/		if ( !regs.CR[6].eq ) { return 0x820EEF14;  }
		/* 820EEE64h case   36:*/		return 0x820EEE68;
		  /* 820EEE68h */ case   37:  		/* lwz R9, <#[R29 + 60]> */
		/* 820EEE68h case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x0000003C) );
		/* 820EEE68h case   37:*/		return 0x820EEE6C;
		  /* 820EEE6Ch */ case   38:  		/* cmplwi CR6, R9, 0 */
		/* 820EEE6Ch case   38:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820EEE6Ch case   38:*/		return 0x820EEE70;
		  /* 820EEE70h */ case   39:  		/* addi R9, R1, 112 */
		/* 820EEE70h case   39:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820EEE70h case   39:*/		return 0x820EEE74;
		  /* 820EEE74h */ case   40:  		/* bc 4, CR6_EQ, 24 */
		/* 820EEE74h case   40:*/		if ( !regs.CR[6].eq ) { return 0x820EEE8C;  }
		/* 820EEE74h case   40:*/		return 0x820EEE78;
		  /* 820EEE78h */ case   41:  		/* lwz R11, <#[R29 + 16]> */
		/* 820EEE78h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 820EEE78h case   41:*/		return 0x820EEE7C;
		  /* 820EEE7Ch */ case   42:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEE7Ch case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEE7Ch case   42:*/		return 0x820EEE80;
		  /* 820EEE80h */ case   43:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820EEE80h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EEE80h case   43:*/		return 0x820EEE84;
		  /* 820EEE84h */ case   44:  		/* stwx R11, <#[R31 + R10]> */
		/* 820EEE84h case   44:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 820EEE84h case   44:*/		return 0x820EEE88;
		  /* 820EEE88h */ case   45:  		/* b 140 */
		/* 820EEE88h case   45:*/		return 0x820EEF14;
		/* 820EEE88h case   45:*/		return 0x820EEE8C;
	}
	return 0x820EEE8C;
} // Block from 820EEDD4h-820EEE8Ch (46 instructions)

//////////////////////////////////////////////////////
// Block at 820EEE8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEE8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEE8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEE8C);
		  /* 820EEE8Ch */ case    0:  		/* lwz R10, <#[R29 + 16]> */
		/* 820EEE8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 820EEE8Ch case    0:*/		return 0x820EEE90;
		  /* 820EEE90h */ case    1:  		/* mr R3, R30 */
		/* 820EEE90h case    1:*/		regs.R3 = regs.R30;
		/* 820EEE90h case    1:*/		return 0x820EEE94;
		  /* 820EEE94h */ case    2:  		/* lwz R4, <#[R30 + 136]> */
		/* 820EEE94h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000088) );
		/* 820EEE94h case    2:*/		return 0x820EEE98;
		  /* 820EEE98h */ case    3:  		/* fmr FR1, FR31 */
		/* 820EEE98h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820EEE98h case    3:*/		return 0x820EEE9C;
		  /* 820EEE9Ch */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EEE9Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EEE9Ch case    4:*/		return 0x820EEEA0;
		  /* 820EEEA0h */ case    5:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820EEEA0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EEEA0h case    5:*/		return 0x820EEEA4;
		  /* 820EEEA4h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EEEA4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EEEA4h case    6:*/		return 0x820EEEA8;
		  /* 820EEEA8h */ case    7:  		/* lwzx R28, <#[R10 + R11]> */
		/* 820EEEA8h case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EEEA8h case    7:*/		return 0x820EEEAC;
		  /* 820EEEACh */ case    8:  		/* lwz R6, <#[R28 + 16]> */
		/* 820EEEACh case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R28 + 0x00000010) );
		/* 820EEEACh case    8:*/		return 0x820EEEB0;
		  /* 820EEEB0h */ case    9:  		/* lwz R5, <#[R28 + 12]> */
		/* 820EEEB0h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 820EEEB0h case    9:*/		return 0x820EEEB4;
		  /* 820EEEB4h */ case   10:  		/* bl 58228 */
		/* 820EEEB4h case   10:*/		regs.LR = 0x820EEEB8; return 0x820FD228;
		/* 820EEEB4h case   10:*/		return 0x820EEEB8;
		  /* 820EEEB8h */ case   11:  		/* lwz R11, <#[R27 + 8]> */
		/* 820EEEB8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820EEEB8h case   11:*/		return 0x820EEEBC;
		  /* 820EEEBCh */ case   12:  		/* stwx R3, <#[R31 + R11]> */
		/* 820EEEBCh case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820EEEBCh case   12:*/		return 0x820EEEC0;
		  /* 820EEEC0h */ case   13:  		/* lwz R11, <#[R27 + 8]> */
		/* 820EEEC0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820EEEC0h case   13:*/		return 0x820EEEC4;
		  /* 820EEEC4h */ case   14:  		/* lwzx R11, <#[R31 + R11]> */
		/* 820EEEC4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820EEEC4h case   14:*/		return 0x820EEEC8;
		  /* 820EEEC8h */ case   15:  		/* cmpwi CR6, R11, -1 */
		/* 820EEEC8h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EEEC8h case   15:*/		return 0x820EEECC;
		  /* 820EEECCh */ case   16:  		/* bc 12, CR6_EQ, 268 */
		/* 820EEECCh case   16:*/		if ( regs.CR[6].eq ) { return 0x820EEFD8;  }
		/* 820EEECCh case   16:*/		return 0x820EEED0;
		  /* 820EEED0h */ case   17:  		/* lwz R11, <#[R27 + 8]> */
		/* 820EEED0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820EEED0h case   17:*/		return 0x820EEED4;
		  /* 820EEED4h */ case   18:  		/* mr R4, R28 */
		/* 820EEED4h case   18:*/		regs.R4 = regs.R28;
		/* 820EEED4h case   18:*/		return 0x820EEED8;
		  /* 820EEED8h */ case   19:  		/* lwz R10, <#[R30 + 20]> */
		/* 820EEED8h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 820EEED8h case   19:*/		return 0x820EEEDC;
		  /* 820EEEDCh */ case   20:  		/* lwzx R11, <#[R31 + R11]> */
		/* 820EEEDCh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820EEEDCh case   20:*/		return 0x820EEEE0;
		  /* 820EEEE0h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEEE0h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEEE0h case   21:*/		return 0x820EEEE4;
		  /* 820EEEE4h */ case   22:  		/* lwzx R28, <#[R11 + R10]> */
		/* 820EEEE4h case   22:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EEEE4h case   22:*/		return 0x820EEEE8;
		  /* 820EEEE8h */ case   23:  		/* mr R3, R28 */
		/* 820EEEE8h case   23:*/		regs.R3 = regs.R28;
		/* 820EEEE8h case   23:*/		return 0x820EEEEC;
		  /* 820EEEECh */ case   24:  		/* bl 56756 */
		/* 820EEEECh case   24:*/		regs.LR = 0x820EEEF0; return 0x820FCCA0;
		/* 820EEEECh case   24:*/		return 0x820EEEF0;
		  /* 820EEEF0h */ case   25:  		/* cmpwi CR0, R3, 0 */
		/* 820EEEF0h case   25:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EEEF0h case   25:*/		return 0x820EEEF4;
		  /* 820EEEF4h */ case   26:  		/* bc 12, CR0_LT, 168 */
		/* 820EEEF4h case   26:*/		if ( regs.CR[0].lt ) { return 0x820EEF9C;  }
		/* 820EEEF4h case   26:*/		return 0x820EEEF8;
		  /* 820EEEF8h */ case   27:  		/* lwz R11, <#[R29 + 16]> */
		/* 820EEEF8h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 820EEEF8h case   27:*/		return 0x820EEEFC;
		  /* 820EEEFCh */ case   28:  		/* addi R10, R1, 112 */
		/* 820EEEFCh case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 820EEEFCh case   28:*/		return 0x820EEF00;
		  /* 820EEF00h */ case   29:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EEF00h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EEF00h case   29:*/		return 0x820EEF04;
		  /* 820EEF04h */ case   30:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EEF04h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EEF04h case   30:*/		return 0x820EEF08;
		  /* 820EEF08h */ case   31:  		/* stw R11, <#[R28 + 56]> */
		/* 820EEF08h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000038) );
		/* 820EEF08h case   31:*/		return 0x820EEF0C;
		  /* 820EEF0Ch */ case   32:  		/* lwz R11, <#[R29 + 60]> */
		/* 820EEF0Ch case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000003C) );
		/* 820EEF0Ch case   32:*/		return 0x820EEF10;
		  /* 820EEF10h */ case   33:  		/* stw R11, <#[R28 + 60]> */
		/* 820EEF10h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x0000003C) );
		/* 820EEF10h case   33:*/		return 0x820EEF14;
	}
	return 0x820EEF14;
} // Block from 820EEE8Ch-820EEF14h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820EEF14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEF14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEF14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEF14);
		  /* 820EEF14h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 820EEF14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 820EEF14h case    0:*/		return 0x820EEF18;
		  /* 820EEF18h */ case    1:  		/* addi R26, R26, 1 */
		/* 820EEF18h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820EEF18h case    1:*/		return 0x820EEF1C;
		  /* 820EEF1Ch */ case    2:  		/* addi R31, R31, 4 */
		/* 820EEF1Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820EEF1Ch case    2:*/		return 0x820EEF20;
		  /* 820EEF20h */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 820EEF20h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 820EEF20h case    3:*/		return 0x820EEF24;
		  /* 820EEF24h */ case    4:  		/* bc 12, CR6_LT, -244 */
		/* 820EEF24h case    4:*/		if ( regs.CR[6].lt ) { return 0x820EEE30;  }
		/* 820EEF24h case    4:*/		return 0x820EEF28;
	}
	return 0x820EEF28;
} // Block from 820EEF14h-820EEF28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EEF28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEF28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEF28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEF28);
		  /* 820EEF28h */ case    0:  		/* addi R24, R24, 1 */
		/* 820EEF28h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 820EEF28h case    0:*/		return 0x820EEF2C;
		  /* 820EEF2Ch */ case    1:  		/* addi R25, R25, 4 */
		/* 820EEF2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 820EEF2Ch case    1:*/		return 0x820EEF30;
		  /* 820EEF30h */ case    2:  		/* cmplw CR6, R24, R23 */
		/* 820EEF30h case    2:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R23);
		/* 820EEF30h case    2:*/		return 0x820EEF34;
		  /* 820EEF34h */ case    3:  		/* bc 12, CR6_LT, -428 */
		/* 820EEF34h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EED88;  }
		/* 820EEF34h case    3:*/		return 0x820EEF38;
	}
	return 0x820EEF38;
} // Block from 820EEF28h-820EEF38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EEF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEF38);
		  /* 820EEF38h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820EEF38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820EEF38h case    0:*/		return 0x820EEF3C;
		  /* 820EEF3Ch */ case    1:  		/* addi R5, R1, 84 */
		/* 820EEF3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820EEF3Ch case    1:*/		return 0x820EEF40;
		  /* 820EEF40h */ case    2:  		/* mr R4, R21 */
		/* 820EEF40h case    2:*/		regs.R4 = regs.R21;
		/* 820EEF40h case    2:*/		return 0x820EEF44;
		  /* 820EEF44h */ case    3:  		/* mr R3, R30 */
		/* 820EEF44h case    3:*/		regs.R3 = regs.R30;
		/* 820EEF44h case    3:*/		return 0x820EEF48;
		  /* 820EEF48h */ case    4:  		/* lwz R11, <#[R11 + 32]> */
		/* 820EEF48h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 820EEF48h case    4:*/		return 0x820EEF4C;
		  /* 820EEF4Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 820EEF4Ch case    5:*/		regs.CTR = regs.R11;
		/* 820EEF4Ch case    5:*/		return 0x820EEF50;
		  /* 820EEF50h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820EEF50h case    6:*/		if ( 1 ) { regs.LR = 0x820EEF54; return (uint32)regs.CTR; }
		/* 820EEF50h case    6:*/		return 0x820EEF54;
		  /* 820EEF54h */ case    7:  		/* lwz R31, <#[R1 + 92]> */
		/* 820EEF54h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x0000005C) );
		/* 820EEF54h case    7:*/		return 0x820EEF58;
		  /* 820EEF58h */ case    8:  		/* lwz R24, <#[R1 + 88]> */
		/* 820EEF58h case    8:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000058) );
		/* 820EEF58h case    8:*/		return 0x820EEF5C;
	}
	return 0x820EEF5C;
} // Block from 820EEF38h-820EEF5Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820EEF5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEF5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEF5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEF5C);
		  /* 820EEF5Ch */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820EEF5Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EEF5Ch case    0:*/		return 0x820EEF60;
		  /* 820EEF60h */ case    1:  		/* bc 4, CR0_EQ, -1388 */
		/* 820EEF60h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820EE9F4;  }
		/* 820EEF60h case    1:*/		return 0x820EEF64;
	}
	return 0x820EEF64;
} // Block from 820EEF5Ch-820EEF64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EEF64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEF64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEF64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEF64);
		  /* 820EEF64h */ case    0:  		/* mr R4, R21 */
		/* 820EEF64h case    0:*/		regs.R4 = regs.R21;
		/* 820EEF64h case    0:*/		return 0x820EEF68;
		  /* 820EEF68h */ case    1:  		/* mr R3, R30 */
		/* 820EEF68h case    1:*/		regs.R3 = regs.R30;
		/* 820EEF68h case    1:*/		return 0x820EEF6C;
		  /* 820EEF6Ch */ case    2:  		/* bl 58620 */
		/* 820EEF6Ch case    2:*/		regs.LR = 0x820EEF70; return 0x820FD468;
		/* 820EEF6Ch case    2:*/		return 0x820EEF70;
		  /* 820EEF70h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820EEF70h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EEF70h case    3:*/		return 0x820EEF74;
		  /* 820EEF74h */ case    4:  		/* bc 12, CR0_LT, 40 */
		/* 820EEF74h case    4:*/		if ( regs.CR[0].lt ) { return 0x820EEF9C;  }
		/* 820EEF74h case    4:*/		return 0x820EEF78;
		  /* 820EEF78h */ case    5:  		/* lwz R10, <#[R1 + 96]> */
		/* 820EEF78h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 820EEF78h case    5:*/		return 0x820EEF7C;
		  /* 820EEF7Ch */ case    6:  		/* stw R17, <#[R21]> */
		/* 820EEF7Ch case    6:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R21 + 0x00000000) );
		/* 820EEF7Ch case    6:*/		return 0x820EEF80;
	}
	return 0x820EEF80;
} // Block from 820EEF64h-820EEF80h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EEF80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEF80);
		  /* 820EEF80h */ case    0:  		/* addi R24, R24, 1 */
		/* 820EEF80h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 820EEF80h case    0:*/		return 0x820EEF84;
		  /* 820EEF84h */ case    1:  		/* addi R31, R31, 4 */
		/* 820EEF84h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820EEF84h case    1:*/		return 0x820EEF88;
		  /* 820EEF88h */ case    2:  		/* stw R24, <#[R1 + 88]> */
		/* 820EEF88h case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000058) );
		/* 820EEF88h case    2:*/		return 0x820EEF8C;
		  /* 820EEF8Ch */ case    3:  		/* cmplw CR6, R24, R10 */
		/* 820EEF8Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R10);
		/* 820EEF8Ch case    3:*/		return 0x820EEF90;
		  /* 820EEF90h */ case    4:  		/* stw R31, <#[R1 + 92]> */
		/* 820EEF90h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000005C) );
		/* 820EEF90h case    4:*/		return 0x820EEF94;
		  /* 820EEF94h */ case    5:  		/* bc 12, CR6_LT, -1536 */
		/* 820EEF94h case    5:*/		if ( regs.CR[6].lt ) { return 0x820EE994;  }
		/* 820EEF94h case    5:*/		return 0x820EEF98;
	}
	return 0x820EEF98;
} // Block from 820EEF80h-820EEF98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EEF98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEF98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEF98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEF98);
		  /* 820EEF98h */ case    0:  		/* mr R3, R17 */
		/* 820EEF98h case    0:*/		regs.R3 = regs.R17;
		/* 820EEF98h case    0:*/		return 0x820EEF9C;
	}
	return 0x820EEF9C;
} // Block from 820EEF98h-820EEF9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EEF9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEF9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEF9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEF9C);
		  /* 820EEF9Ch */ case    0:  		/* addi R1, R1, 304 */
		/* 820EEF9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x130);
		/* 820EEF9Ch case    0:*/		return 0x820EEFA0;
		  /* 820EEFA0h */ case    1:  		/* lfd FR31, <#[R1 - 160]> */
		/* 820EEFA0h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820EEFA0h case    1:*/		return 0x820EEFA4;
		  /* 820EEFA4h */ case    2:  		/* b -384308 */
		/* 820EEFA4h case    2:*/		return 0x82091270;
		/* 820EEFA4h case    2:*/		return 0x820EEFA8;
	}
	return 0x820EEFA8;
} // Block from 820EEF9Ch-820EEFA8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EEFA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEFA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEFA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEFA8);
		  /* 820EEFA8h */ case    0:  		/* lis R11, -32254 */
		/* 820EEFA8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EEFA8h case    0:*/		return 0x820EEFAC;
		  /* 820EEFACh */ case    1:  		/* addi R6, R11, -16452 */
		/* 820EEFACh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBFBC);
		/* 820EEFACh case    1:*/		return 0x820EEFB0;
		  /* 820EEFB0h */ case    2:  		/* li R5, 0 */
		/* 820EEFB0h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820EEFB0h case    2:*/		return 0x820EEFB4;
		  /* 820EEFB4h */ case    3:  		/* lwz R4, <#[R21 + 60]> */
		/* 820EEFB4h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R21 + 0x0000003C) );
		/* 820EEFB4h case    3:*/		return 0x820EEFB8;
		  /* 820EEFB8h */ case    4:  		/* mr R3, R30 */
		/* 820EEFB8h case    4:*/		regs.R3 = regs.R30;
		/* 820EEFB8h case    4:*/		return 0x820EEFBC;
		  /* 820EEFBCh */ case    5:  		/* bl 128884 */
		/* 820EEFBCh case    5:*/		regs.LR = 0x820EEFC0; return 0x8210E730;
		/* 820EEFBCh case    5:*/		return 0x820EEFC0;
		  /* 820EEFC0h */ case    6:  		/* lis R3, -32768 */
		/* 820EEFC0h case    6:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820EEFC0h case    6:*/		return 0x820EEFC4;
		  /* 820EEFC4h */ case    7:  		/* ori R3, R3, 16389 */
		/* 820EEFC4h case    7:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820EEFC4h case    7:*/		return 0x820EEFC8;
		  /* 820EEFC8h */ case    8:  		/* b -44 */
		/* 820EEFC8h case    8:*/		return 0x820EEF9C;
		/* 820EEFC8h case    8:*/		return 0x820EEFCC;
	}
	return 0x820EEFCC;
} // Block from 820EEFA8h-820EEFCCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820EEFCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEFCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEFCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEFCC);
		  /* 820EEFCCh */ case    0:  		/* lis R11, -32254 */
		/* 820EEFCCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EEFCCh case    0:*/		return 0x820EEFD0;
		  /* 820EEFD0h */ case    1:  		/* addi R6, R11, -16516 */
		/* 820EEFD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBF7C);
		/* 820EEFD0h case    1:*/		return 0x820EEFD4;
		  /* 820EEFD4h */ case    2:  		/* b -36 */
		/* 820EEFD4h case    2:*/		return 0x820EEFB0;
		/* 820EEFD4h case    2:*/		return 0x820EEFD8;
	}
	return 0x820EEFD8;
} // Block from 820EEFCCh-820EEFD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EEFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEFD8);
		  /* 820EEFD8h */ case    0:  		/* lis R3, -32761 */
		/* 820EEFD8h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820EEFD8h case    0:*/		return 0x820EEFDC;
		  /* 820EEFDCh */ case    1:  		/* ori R3, R3, 14 */
		/* 820EEFDCh case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820EEFDCh case    1:*/		return 0x820EEFE0;
		  /* 820EEFE0h */ case    2:  		/* b -68 */
		/* 820EEFE0h case    2:*/		return 0x820EEF9C;
		/* 820EEFE0h case    2:*/		return 0x820EEFE4;
		  /* 820EEFE4h */ case    3:  		/* nop */
		/* 820EEFE4h case    3:*/		cpu::op::nop();
		/* 820EEFE4h case    3:*/		return 0x820EEFE8;
	}
	return 0x820EEFE8;
} // Block from 820EEFD8h-820EEFE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EEFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EEFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EEFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EEFE8);
		  /* 820EEFE8h */ case    0:  		/* mfspr R12, LR */
		/* 820EEFE8h case    0:*/		regs.R12 = regs.LR;
		/* 820EEFE8h case    0:*/		return 0x820EEFEC;
		  /* 820EEFECh */ case    1:  		/* bl -384456 */
		/* 820EEFECh case    1:*/		regs.LR = 0x820EEFF0; return 0x82091224;
		/* 820EEFECh case    1:*/		return 0x820EEFF0;
		  /* 820EEFF0h */ case    2:  		/* stwu R1, <#[R1 - 288]> */
		/* 820EEFF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 820EEFF0h case    2:*/		return 0x820EEFF4;
		  /* 820EEFF4h */ case    3:  		/* mr R31, R3 */
		/* 820EEFF4h case    3:*/		regs.R31 = regs.R3;
		/* 820EEFF4h case    3:*/		return 0x820EEFF8;
		  /* 820EEFF8h */ case    4:  		/* bl -43032 */
		/* 820EEFF8h case    4:*/		regs.LR = 0x820EEFFC; return 0x820E47E0;
		/* 820EEFF8h case    4:*/		return 0x820EEFFC;
		  /* 820EEFFCh */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820EEFFCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EEFFCh case    5:*/		return 0x820EF000;
		  /* 820EF000h */ case    6:  		/* bc 12, CR0_LT, 832 */
		/* 820EF000h case    6:*/		if ( regs.CR[0].lt ) { return 0x820EF340;  }
		/* 820EF000h case    6:*/		return 0x820EF004;
		  /* 820EF004h */ case    7:  		/* lwz R17, <#[R31 + 12]> */
		/* 820EF004h case    7:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R31 + 0x0000000C) );
		/* 820EF004h case    7:*/		return 0x820EF008;
		  /* 820EF008h */ case    8:  		/* li R19, 0 */
		/* 820EF008h case    8:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 820EF008h case    8:*/		return 0x820EF00C;
		  /* 820EF00Ch */ case    9:  		/* cmplwi CR6, R17, 0 */
		/* 820EF00Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 820EF00Ch case    9:*/		return 0x820EF010;
		  /* 820EF010h */ case   10:  		/* bc 12, CR6_EQ, 740 */
		/* 820EF010h case   10:*/		if ( regs.CR[6].eq ) { return 0x820EF2F4;  }
		/* 820EF010h case   10:*/		return 0x820EF014;
		  /* 820EF014h */ case   11:  		/* li R18, 0 */
		/* 820EF014h case   11:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 820EF014h case   11:*/		return 0x820EF018;
		  /* 820EF018h */ case   12:  		/* li R15, -1 */
		/* 820EF018h case   12:*/		cpu::op::li<0>(regs,&regs.R15,0xFFFFFFFF);
		/* 820EF018h case   12:*/		return 0x820EF01C;
		  /* 820EF01Ch */ case   13:  		/* li R16, -1 */
		/* 820EF01Ch case   13:*/		cpu::op::li<0>(regs,&regs.R16,0xFFFFFFFF);
		/* 820EF01Ch case   13:*/		return 0x820EF020;
		  /* 820EF020h */ case   14:  		/* lwz R11, <#[R31 + 24]> */
		/* 820EF020h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820EF020h case   14:*/		return 0x820EF024;
		  /* 820EF024h */ case   15:  		/* lwzx R28, <#[R18 + R11]> */
		/* 820EF024h case   15:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R18 + regs.R11 + 0x00000000) );
		/* 820EF024h case   15:*/		return 0x820EF028;
		  /* 820EF028h */ case   16:  		/* lwz R11, <#[R28]> */
		/* 820EF028h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820EF028h case   16:*/		return 0x820EF02C;
		  /* 820EF02Ch */ case   17:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 820EF02Ch case   17:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 820EF02Ch case   17:*/		return 0x820EF030;
		  /* 820EF030h */ case   18:  		/* bc 12, CR0_EQ, 692 */
		/* 820EF030h case   18:*/		if ( regs.CR[0].eq ) { return 0x820EF2E4;  }
		/* 820EF030h case   18:*/		return 0x820EF034;
		  /* 820EF034h */ case   19:  		/* lwz R10, <#[R31]> */
		/* 820EF034h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820EF034h case   19:*/		return 0x820EF038;
		  /* 820EF038h */ case   20:  		/* rlwinm R27, R11, 0, 12, 31 */
		/* 820EF038h case   20:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R27,regs.R11);
		/* 820EF038h case   20:*/		return 0x820EF03C;
		  /* 820EF03Ch */ case   21:  		/* addi R5, R1, 80 */
		/* 820EF03Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820EF03Ch case   21:*/		return 0x820EF040;
		  /* 820EF040h */ case   22:  		/* mr R4, R28 */
		/* 820EF040h case   22:*/		regs.R4 = regs.R28;
		/* 820EF040h case   22:*/		return 0x820EF044;
		  /* 820EF044h */ case   23:  		/* mr R3, R31 */
		/* 820EF044h case   23:*/		regs.R3 = regs.R31;
		/* 820EF044h case   23:*/		return 0x820EF048;
		  /* 820EF048h */ case   24:  		/* li R21, 0 */
		/* 820EF048h case   24:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 820EF048h case   24:*/		return 0x820EF04C;
		  /* 820EF04Ch */ case   25:  		/* lwz R11, <#[R10 + 32]> */
		/* 820EF04Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000020) );
		/* 820EF04Ch case   25:*/		return 0x820EF050;
		  /* 820EF050h */ case   26:  		/* mtspr CTR, R11 */
		/* 820EF050h case   26:*/		regs.CTR = regs.R11;
		/* 820EF050h case   26:*/		return 0x820EF054;
		  /* 820EF054h */ case   27:  		/* bcctrl 20, CR0_LT */
		/* 820EF054h case   27:*/		if ( 1 ) { regs.LR = 0x820EF058; return (uint32)regs.CTR; }
		/* 820EF054h case   27:*/		return 0x820EF058;
		  /* 820EF058h */ case   28:  		/* cmpwi CR0, R3, 0 */
		/* 820EF058h case   28:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EF058h case   28:*/		return 0x820EF05C;
		  /* 820EF05Ch */ case   29:  		/* bc 12, CR0_EQ, 600 */
		/* 820EF05Ch case   29:*/		if ( regs.CR[0].eq ) { return 0x820EF2B4;  }
		/* 820EF05Ch case   29:*/		return 0x820EF060;
		  /* 820EF060h */ case   30:  		/* addi R11, R1, 128 */
		/* 820EF060h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820EF060h case   30:*/		return 0x820EF064;
		  /* 820EF064h */ case   31:  		/* addi R20, R11, -4 */
		/* 820EF064h case   31:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R11,0xFFFFFFFC);
		/* 820EF064h case   31:*/		return 0x820EF068;
		  /* 820EF068h */ case   32:  		/* lwz R11, <#[R28]> */
		/* 820EF068h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820EF068h case   32:*/		return 0x820EF06C;
		  /* 820EF06Ch */ case   33:  		/* lis R10, 29712 */
		/* 820EF06Ch case   33:*/		cpu::op::lis<0>(regs,&regs.R10,0x7410);
		/* 820EF06Ch case   33:*/		return 0x820EF070;
		  /* 820EF070h */ case   34:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820EF070h case   34:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820EF070h case   34:*/		return 0x820EF074;
		  /* 820EF074h */ case   35:  		/* cmplw CR6, R11, R10 */
		/* 820EF074h case   35:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EF074h case   35:*/		return 0x820EF078;
		  /* 820EF078h */ case   36:  		/* bc 12, CR6_EQ, 572 */
		/* 820EF078h case   36:*/		if ( regs.CR[6].eq ) { return 0x820EF2B4;  }
		/* 820EF078h case   36:*/		return 0x820EF07C;
		  /* 820EF07Ch */ case   37:  		/* lwz R11, <#[R31 + 336]> */
		/* 820EF07Ch case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 820EF07Ch case   37:*/		return 0x820EF080;
		  /* 820EF080h */ case   38:  		/* cmplw CR6, R19, R11 */
		/* 820EF080h case   38:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R11);
		/* 820EF080h case   38:*/		return 0x820EF084;
		  /* 820EF084h */ case   39:  		/* bc 12, CR6_LT, 28 */
		/* 820EF084h case   39:*/		if ( regs.CR[6].lt ) { return 0x820EF0A0;  }
		/* 820EF084h case   39:*/		return 0x820EF088;
		  /* 820EF088h */ case   40:  		/* addi R11, R1, 96 */
		/* 820EF088h case   40:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820EF088h case   40:*/		return 0x820EF08C;
		  /* 820EF08Ch */ case   41:  		/* addi R10, R1, 112 */
		/* 820EF08Ch case   41:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 820EF08Ch case   41:*/		return 0x820EF090;
	}
	return 0x820EF090;
} // Block from 820EEFE8h-820EF090h (42 instructions)

//////////////////////////////////////////////////////
// Block at 820EF090h
// Function '?ConstrainPorts@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF090);
		  /* 820EF090h */ case    0:  		/* std R15, <#[R11]> */
		/* 820EF090h case    0:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000000) );
		/* 820EF090h case    0:*/		return 0x820EF094;
		  /* 820EF094h */ case    1:  		/* std R15, <#[R10]> */
		/* 820EF094h case    1:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R10 + 0x00000000) );
		/* 820EF094h case    1:*/		return 0x820EF098;
		  /* 820EF098h */ case    2:  		/* std R15, <#[R11 + 8]> */
		/* 820EF098h case    2:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000008) );
		/* 820EF098h case    2:*/		return 0x820EF09C;
		  /* 820EF09Ch */ case    3:  		/* std R15, <#[R10 + 8]> */
		/* 820EF09Ch case    3:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R10 + 0x00000008) );
		/* 820EF09Ch case    3:*/		return 0x820EF0A0;
	}
	return 0x820EF0A0;
} // Block from 820EF090h-820EF0A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EF0A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF0A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF0A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF0A0);
		  /* 820EF0A0h */ case    0:  		/* addi R10, R27, -1 */
		/* 820EF0A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0xFFFFFFFF);
		/* 820EF0A0h case    0:*/		return 0x820EF0A4;
		  /* 820EF0A4h */ case    1:  		/* lwz R9, <#[R1 + 80]> */
		/* 820EF0A4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820EF0A4h case    1:*/		return 0x820EF0A8;
		  /* 820EF0A8h */ case    2:  		/* li R8, 3 */
		/* 820EF0A8h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 820EF0A8h case    2:*/		return 0x820EF0AC;
		  /* 820EF0ACh */ case    3:  		/* lwz R11, <#[R28 + 8]> */
		/* 820EF0ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820EF0ACh case    3:*/		return 0x820EF0B0;
		  /* 820EF0B0h */ case    4:  		/* addic R10, R10, -1 */
		/* 820EF0B0h case    4:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820EF0B0h case    4:*/		return 0x820EF0B4;
		  /* 820EF0B4h */ case    5:  		/* mullw R9, R9, R27 */
		/* 820EF0B4h case    5:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R27);
		/* 820EF0B4h case    5:*/		return 0x820EF0B8;
		  /* 820EF0B8h */ case    6:  		/* subfe R7, R10, R10 */
		/* 820EF0B8h case    6:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R10,regs.R10);
		/* 820EF0B8h case    6:*/		return 0x820EF0BC;
		  /* 820EF0BCh */ case    7:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 820EF0BCh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 820EF0BCh case    7:*/		return 0x820EF0C0;
		  /* 820EF0C0h */ case    8:  		/* and R29, R7, R8 */
		/* 820EF0C0h case    8:*/		cpu::op::and<0>(regs,&regs.R29,regs.R7,regs.R8);
		/* 820EF0C0h case    8:*/		return 0x820EF0C4;
		  /* 820EF0C4h */ case    9:  		/* addi R9, R1, 112 */
		/* 820EF0C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820EF0C4h case    9:*/		return 0x820EF0C8;
		  /* 820EF0C8h */ case   10:  		/* rlwinm R23, R29, 2, 0, 29 */
		/* 820EF0C8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R23,regs.R29);
		/* 820EF0C8h case   10:*/		return 0x820EF0CC;
		  /* 820EF0CCh */ case   11:  		/* add R25, R10, R11 */
		/* 820EF0CCh case   11:*/		cpu::op::add<0>(regs,&regs.R25,regs.R10,regs.R11);
		/* 820EF0CCh case   11:*/		return 0x820EF0D0;
		  /* 820EF0D0h */ case   12:  		/* add R22, R23, R9 */
		/* 820EF0D0h case   12:*/		cpu::op::add<0>(regs,&regs.R22,regs.R23,regs.R9);
		/* 820EF0D0h case   12:*/		return 0x820EF0D4;
		  /* 820EF0D4h */ case   13:  		/* rlwinm. R26, R27, 2, 0, 29 */
		/* 820EF0D4h case   13:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R26,regs.R27);
		/* 820EF0D4h case   13:*/		return 0x820EF0D8;
		  /* 820EF0D8h */ case   14:  		/* mr R10, R22 */
		/* 820EF0D8h case   14:*/		regs.R10 = regs.R22;
		/* 820EF0D8h case   14:*/		return 0x820EF0DC;
		  /* 820EF0DCh */ case   15:  		/* mr R11, R25 */
		/* 820EF0DCh case   15:*/		regs.R11 = regs.R25;
		/* 820EF0DCh case   15:*/		return 0x820EF0E0;
		  /* 820EF0E0h */ case   16:  		/* li R9, 0 */
		/* 820EF0E0h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820EF0E0h case   16:*/		return 0x820EF0E4;
		  /* 820EF0E4h */ case   17:  		/* bc 12, CR0_EQ, 40 */
		/* 820EF0E4h case   17:*/		if ( regs.CR[0].eq ) { return 0x820EF10C;  }
		/* 820EF0E4h case   17:*/		return 0x820EF0E8;
		  /* 820EF0E8h */ case   18:  		/* add R8, R25, R26 */
		/* 820EF0E8h case   18:*/		cpu::op::add<0>(regs,&regs.R8,regs.R25,regs.R26);
		/* 820EF0E8h case   18:*/		return 0x820EF0EC;
		  /* 820EF0ECh */ case   19:  		/* lbz R9, <#[R11]> */
		/* 820EF0ECh case   19:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820EF0ECh case   19:*/		return 0x820EF0F0;
		  /* 820EF0F0h */ case   20:  		/* lbz R7, <#[R10]> */
		/* 820EF0F0h case   20:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820EF0F0h case   20:*/		return 0x820EF0F4;
		  /* 820EF0F4h */ case   21:  		/* subf. R9, R7, R9 */
		/* 820EF0F4h case   21:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820EF0F4h case   21:*/		return 0x820EF0F8;
		  /* 820EF0F8h */ case   22:  		/* bc 4, CR0_EQ, 20 */
		/* 820EF0F8h case   22:*/		if ( !regs.CR[0].eq ) { return 0x820EF10C;  }
		/* 820EF0F8h case   22:*/		return 0x820EF0FC;
		  /* 820EF0FCh */ case   23:  		/* addi R11, R11, 1 */
		/* 820EF0FCh case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EF0FCh case   23:*/		return 0x820EF100;
		  /* 820EF100h */ case   24:  		/* addi R10, R10, 1 */
		/* 820EF100h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EF100h case   24:*/		return 0x820EF104;
		  /* 820EF104h */ case   25:  		/* cmpw CR6, R11, R8 */
		/* 820EF104h case   25:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820EF104h case   25:*/		return 0x820EF108;
		  /* 820EF108h */ case   26:  		/* bc 4, CR6_EQ, -28 */
		/* 820EF108h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820EF0EC;  }
		/* 820EF108h case   26:*/		return 0x820EF10C;
	}
	return 0x820EF10C;
} // Block from 820EF0A0h-820EF10Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 820EF10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF10C);
		  /* 820EF10Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820EF10Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820EF10Ch case    0:*/		return 0x820EF110;
		  /* 820EF110h */ case    1:  		/* bc 4, CR0_EQ, 48 */
		/* 820EF110h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820EF140;  }
		/* 820EF110h case    1:*/		return 0x820EF114;
		  /* 820EF114h */ case    2:  		/* lwz R11, <#[R28 + 12]> */
		/* 820EF114h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 820EF114h case    2:*/		return 0x820EF118;
		  /* 820EF118h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820EF118h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EF118h case    3:*/		return 0x820EF11C;
		  /* 820EF11Ch */ case    4:  		/* bc 12, CR6_EQ, 352 */
		/* 820EF11Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820EF27C;  }
		/* 820EF11Ch case    4:*/		return 0x820EF120;
		  /* 820EF120h */ case    5:  		/* lwz R11, <#[R28 + 16]> */
		/* 820EF120h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 820EF120h case    5:*/		return 0x820EF124;
		  /* 820EF124h */ case    6:  		/* lwz R10, <#[R31 + 20]> */
		/* 820EF124h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820EF124h case    6:*/		return 0x820EF128;
		  /* 820EF128h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820EF128h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820EF128h case    7:*/		return 0x820EF12C;
		  /* 820EF12Ch */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EF12Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EF12Ch case    8:*/		return 0x820EF130;
		  /* 820EF130h */ case    9:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EF130h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EF130h case    9:*/		return 0x820EF134;
		  /* 820EF134h */ case   10:  		/* lwz R11, <#[R11 + 20]> */
		/* 820EF134h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820EF134h case   10:*/		return 0x820EF138;
		  /* 820EF138h */ case   11:  		/* cmpwi CR6, R11, -1 */
		/* 820EF138h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EF138h case   11:*/		return 0x820EF13C;
		  /* 820EF13Ch */ case   12:  		/* bc 12, CR6_EQ, 320 */
		/* 820EF13Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820EF27C;  }
		/* 820EF13Ch case   12:*/		return 0x820EF140;
	}
	return 0x820EF140;
} // Block from 820EF10Ch-820EF140h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820EF140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF140);
		  /* 820EF140h */ case    0:  		/* li R11, 1 */
		/* 820EF140h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820EF140h case    0:*/		return 0x820EF144;
		  /* 820EF144h */ case    1:  		/* mr R4, R27 */
		/* 820EF144h case    1:*/		regs.R4 = regs.R27;
		/* 820EF144h case    1:*/		return 0x820EF148;
		  /* 820EF148h */ case    2:  		/* mr R6, R16 */
		/* 820EF148h case    2:*/		regs.R6 = regs.R16;
		/* 820EF148h case    2:*/		return 0x820EF14C;
		  /* 820EF14Ch */ case    3:  		/* rlwimi R4, R11, 28, 0, 11 */
		/* 820EF14Ch case    3:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R11);
		/* 820EF14Ch case    3:*/		return 0x820EF150;
		  /* 820EF150h */ case    4:  		/* mr R5, R16 */
		/* 820EF150h case    4:*/		regs.R5 = regs.R16;
		/* 820EF150h case    4:*/		return 0x820EF154;
		  /* 820EF154h */ case    5:  		/* mr R3, R31 */
		/* 820EF154h case    5:*/		regs.R3 = regs.R31;
		/* 820EF154h case    5:*/		return 0x820EF158;
		  /* 820EF158h */ case    6:  		/* bl 57712 */
		/* 820EF158h case    6:*/		regs.LR = 0x820EF15C; return 0x820FD2C8;
		/* 820EF158h case    6:*/		return 0x820EF15C;
		  /* 820EF15Ch */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 820EF15Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820EF15Ch case    7:*/		return 0x820EF160;
		  /* 820EF160h */ case    8:  		/* bc 12, CR6_EQ, 488 */
		/* 820EF160h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EF348;  }
		/* 820EF160h case    8:*/		return 0x820EF164;
		  /* 820EF164h */ case    9:  		/* lwz R11, <#[R31 + 24]> */
		/* 820EF164h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820EF164h case    9:*/		return 0x820EF168;
		  /* 820EF168h */ case   10:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820EF168h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820EF168h case   10:*/		return 0x820EF16C;
		  /* 820EF16Ch */ case   11:  		/* mr R4, R28 */
		/* 820EF16Ch case   11:*/		regs.R4 = regs.R28;
		/* 820EF16Ch case   11:*/		return 0x820EF170;
		  /* 820EF170h */ case   12:  		/* lwzx R24, <#[R10 + R11]> */
		/* 820EF170h case   12:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EF170h case   12:*/		return 0x820EF174;
		  /* 820EF174h */ case   13:  		/* mr R3, R24 */
		/* 820EF174h case   13:*/		regs.R3 = regs.R24;
		/* 820EF174h case   13:*/		return 0x820EF178;
		  /* 820EF178h */ case   14:  		/* bl 52600 */
		/* 820EF178h case   14:*/		regs.LR = 0x820EF17C; return 0x820FBEF0;
		/* 820EF178h case   14:*/		return 0x820EF17C;
		  /* 820EF17Ch */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820EF17Ch case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EF17Ch case   15:*/		return 0x820EF180;
		  /* 820EF180h */ case   16:  		/* bc 12, CR0_LT, 448 */
		/* 820EF180h case   16:*/		if ( regs.CR[0].lt ) { return 0x820EF340;  }
		/* 820EF180h case   16:*/		return 0x820EF184;
		  /* 820EF184h */ case   17:  		/* lwz R10, <#[R31]> */
		/* 820EF184h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820EF184h case   17:*/		return 0x820EF188;
		  /* 820EF188h */ case   18:  		/* addi R11, R1, 96 */
		/* 820EF188h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820EF188h case   18:*/		return 0x820EF18C;
		  /* 820EF18Ch */ case   19:  		/* mr R8, R21 */
		/* 820EF18Ch case   19:*/		regs.R8 = regs.R21;
		/* 820EF18Ch case   19:*/		return 0x820EF190;
		  /* 820EF190h */ case   20:  		/* add R30, R23, R11 */
		/* 820EF190h case   20:*/		cpu::op::add<0>(regs,&regs.R30,regs.R23,regs.R11);
		/* 820EF190h case   20:*/		return 0x820EF194;
		  /* 820EF194h */ case   21:  		/* addi R7, R1, 128 */
		/* 820EF194h case   21:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x80);
		/* 820EF194h case   21:*/		return 0x820EF198;
		  /* 820EF198h */ case   22:  		/* mr R6, R27 */
		/* 820EF198h case   22:*/		regs.R6 = regs.R27;
		/* 820EF198h case   22:*/		return 0x820EF19C;
		  /* 820EF19Ch */ case   23:  		/* lwz R11, <#[R10 + 340]> */
		/* 820EF19Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000154) );
		/* 820EF19Ch case   23:*/		return 0x820EF1A0;
		  /* 820EF1A0h */ case   24:  		/* mr R5, R30 */
		/* 820EF1A0h case   24:*/		regs.R5 = regs.R30;
		/* 820EF1A0h case   24:*/		return 0x820EF1A4;
		  /* 820EF1A4h */ case   25:  		/* mr R4, R19 */
		/* 820EF1A4h case   25:*/		regs.R4 = regs.R19;
		/* 820EF1A4h case   25:*/		return 0x820EF1A8;
		  /* 820EF1A8h */ case   26:  		/* mr R3, R31 */
		/* 820EF1A8h case   26:*/		regs.R3 = regs.R31;
		/* 820EF1A8h case   26:*/		return 0x820EF1AC;
		  /* 820EF1ACh */ case   27:  		/* mtspr CTR, R11 */
		/* 820EF1ACh case   27:*/		regs.CTR = regs.R11;
		/* 820EF1ACh case   27:*/		return 0x820EF1B0;
		  /* 820EF1B0h */ case   28:  		/* bcctrl 20, CR0_LT */
		/* 820EF1B0h case   28:*/		if ( 1 ) { regs.LR = 0x820EF1B4; return (uint32)regs.CTR; }
		/* 820EF1B0h case   28:*/		return 0x820EF1B4;
		  /* 820EF1B4h */ case   29:  		/* cmpwi CR0, R3, 0 */
		/* 820EF1B4h case   29:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EF1B4h case   29:*/		return 0x820EF1B8;
		  /* 820EF1B8h */ case   30:  		/* bc 12, CR0_LT, 392 */
		/* 820EF1B8h case   30:*/		if ( regs.CR[0].lt ) { return 0x820EF340;  }
		/* 820EF1B8h case   30:*/		return 0x820EF1BC;
		  /* 820EF1BCh */ case   31:  		/* lwz R11, <#[R30]> */
		/* 820EF1BCh case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820EF1BCh case   31:*/		return 0x820EF1C0;
		  /* 820EF1C0h */ case   32:  		/* add R8, R29, R27 */
		/* 820EF1C0h case   32:*/		cpu::op::add<0>(regs,&regs.R8,regs.R29,regs.R27);
		/* 820EF1C0h case   32:*/		return 0x820EF1C4;
		  /* 820EF1C4h */ case   33:  		/* lwz R10, <#[R31 + 20]> */
		/* 820EF1C4h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820EF1C4h case   33:*/		return 0x820EF1C8;
		  /* 820EF1C8h */ case   34:  		/* mr R7, R29 */
		/* 820EF1C8h case   34:*/		regs.R7 = regs.R29;
		/* 820EF1C8h case   34:*/		return 0x820EF1CC;
		  /* 820EF1CCh */ case   35:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EF1CCh case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EF1CCh case   35:*/		return 0x820EF1D0;
		  /* 820EF1D0h */ case   36:  		/* cmplw CR6, R29, R8 */
		/* 820EF1D0h case   36:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R8);
		/* 820EF1D0h case   36:*/		return 0x820EF1D4;
		  /* 820EF1D4h */ case   37:  		/* lwzx R6, <#[R11 + R10]> */
		/* 820EF1D4h case   37:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EF1D4h case   37:*/		return 0x820EF1D8;
		  /* 820EF1D8h */ case   38:  		/* bc 4, CR6_LT, 104 */
		/* 820EF1D8h case   38:*/		if ( !regs.CR[6].lt ) { return 0x820EF240;  }
		/* 820EF1D8h case   38:*/		return 0x820EF1DC;
		  /* 820EF1DCh */ case   39:  		/* mr R9, R30 */
		/* 820EF1DCh case   39:*/		regs.R9 = regs.R30;
		/* 820EF1DCh case   39:*/		return 0x820EF1E0;
		  /* 820EF1E0h */ case   40:  		/* lwz R10, <#[R9]> */
		/* 820EF1E0h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820EF1E0h case   40:*/		return 0x820EF1E4;
		  /* 820EF1E4h */ case   41:  		/* lwz R11, <#[R31 + 20]> */
		/* 820EF1E4h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820EF1E4h case   41:*/		return 0x820EF1E8;
		  /* 820EF1E8h */ case   42:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EF1E8h case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EF1E8h case   42:*/		return 0x820EF1EC;
		  /* 820EF1ECh */ case   43:  		/* lwz R5, <#[R28 + 12]> */
		/* 820EF1ECh case   43:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 820EF1ECh case   43:*/		return 0x820EF1F0;
		  /* 820EF1F0h */ case   44:  		/* cmplwi CR6, R5, 0 */
		/* 820EF1F0h case   44:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820EF1F0h case   44:*/		return 0x820EF1F4;
		  /* 820EF1F4h */ case   45:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820EF1F4h case   45:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EF1F4h case   45:*/		return 0x820EF1F8;
		  /* 820EF1F8h */ case   46:  		/* bc 12, CR6_EQ, 56 */
		/* 820EF1F8h case   46:*/		if ( regs.CR[6].eq ) { return 0x820EF230;  }
		/* 820EF1F8h case   46:*/		return 0x820EF1FC;
		  /* 820EF1FCh */ case   47:  		/* lwz R5, <#[R28 + 16]> */
		/* 820EF1FCh case   47:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x00000010) );
		/* 820EF1FCh case   47:*/		return 0x820EF200;
		  /* 820EF200h */ case   48:  		/* lwz R5, <#[R5]> */
		/* 820EF200h case   48:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000000) );
		/* 820EF200h case   48:*/		return 0x820EF204;
		  /* 820EF204h */ case   49:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 820EF204h case   49:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 820EF204h case   49:*/		return 0x820EF208;
		  /* 820EF208h */ case   50:  		/* lwzx R11, <#[R5 + R11]> */
		/* 820EF208h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820EF208h case   50:*/		return 0x820EF20C;
		  /* 820EF20Ch */ case   51:  		/* lwz R11, <#[R11 + 20]> */
		/* 820EF20Ch case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820EF20Ch case   51:*/		return 0x820EF210;
		  /* 820EF210h */ case   52:  		/* stw R11, <#[R10 + 20]> */
		/* 820EF210h case   52:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 820EF210h case   52:*/		return 0x820EF214;
		  /* 820EF214h */ case   53:  		/* lwz R11, <#[R28 + 16]> */
		/* 820EF214h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 820EF214h case   53:*/		return 0x820EF218;
		  /* 820EF218h */ case   54:  		/* lwz R5, <#[R31 + 20]> */
		/* 820EF218h case   54:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000014) );
		/* 820EF218h case   54:*/		return 0x820EF21C;
		  /* 820EF21Ch */ case   55:  		/* lwz R11, <#[R11]> */
		/* 820EF21Ch case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820EF21Ch case   55:*/		return 0x820EF220;
		  /* 820EF220h */ case   56:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EF220h case   56:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EF220h case   56:*/		return 0x820EF224;
		  /* 820EF224h */ case   57:  		/* lwzx R11, <#[R11 + R5]> */
		/* 820EF224h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820EF224h case   57:*/		return 0x820EF228;
		  /* 820EF228h */ case   58:  		/* lwz R11, <#[R11 + 24]> */
		/* 820EF228h case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820EF228h case   58:*/		return 0x820EF22C;
		  /* 820EF22Ch */ case   59:  		/* stw R11, <#[R10 + 24]> */
		/* 820EF22Ch case   59:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 820EF22Ch case   59:*/		return 0x820EF230;
	}
	return 0x820EF230;
} // Block from 820EF140h-820EF230h (60 instructions)

//////////////////////////////////////////////////////
// Block at 820EF230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF230);
		  /* 820EF230h */ case    0:  		/* addi R7, R7, 1 */
		/* 820EF230h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820EF230h case    0:*/		return 0x820EF234;
		  /* 820EF234h */ case    1:  		/* addi R9, R9, 4 */
		/* 820EF234h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820EF234h case    1:*/		return 0x820EF238;
		  /* 820EF238h */ case    2:  		/* cmplw CR6, R7, R8 */
		/* 820EF238h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 820EF238h case    2:*/		return 0x820EF23C;
		  /* 820EF23Ch */ case    3:  		/* bc 12, CR6_LT, -92 */
		/* 820EF23Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820EF1E0;  }
		/* 820EF23Ch case    3:*/		return 0x820EF240;
	}
	return 0x820EF240;
} // Block from 820EF230h-820EF240h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EF240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF240);
		  /* 820EF240h */ case    0:  		/* lwz R11, <#[R6 + 12]> */
		/* 820EF240h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x0000000C) );
		/* 820EF240h case    0:*/		return 0x820EF244;
		  /* 820EF244h */ case    1:  		/* mr R5, R26 */
		/* 820EF244h case    1:*/		regs.R5 = regs.R26;
		/* 820EF244h case    1:*/		return 0x820EF248;
		  /* 820EF248h */ case    2:  		/* mr R4, R30 */
		/* 820EF248h case    2:*/		regs.R4 = regs.R30;
		/* 820EF248h case    2:*/		return 0x820EF24C;
		  /* 820EF24Ch */ case    3:  		/* addi R21, R21, 1 */
		/* 820EF24Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 820EF24Ch case    3:*/		return 0x820EF250;
		  /* 820EF250h */ case    4:  		/* stwu R11, <#[R20 + 4]> */
		/* 820EF250h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000004) );
		regs.R20 = (uint32)(regs.R20 + 0x00000004);
		/* 820EF250h case    4:*/		return 0x820EF254;
		  /* 820EF254h */ case    5:  		/* lwz R3, <#[R24 + 16]> */
		/* 820EF254h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000010) );
		/* 820EF254h case    5:*/		return 0x820EF258;
		  /* 820EF258h */ case    6:  		/* bl -383144 */
		/* 820EF258h case    6:*/		regs.LR = 0x820EF25C; return 0x820919B0;
		/* 820EF258h case    6:*/		return 0x820EF25C;
		  /* 820EF25Ch */ case    7:  		/* mr R5, R26 */
		/* 820EF25Ch case    7:*/		regs.R5 = regs.R26;
		/* 820EF25Ch case    7:*/		return 0x820EF260;
		  /* 820EF260h */ case    8:  		/* lwz R3, <#[R24 + 8]> */
		/* 820EF260h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000008) );
		/* 820EF260h case    8:*/		return 0x820EF264;
		  /* 820EF264h */ case    9:  		/* mr R4, R25 */
		/* 820EF264h case    9:*/		regs.R4 = regs.R25;
		/* 820EF264h case    9:*/		return 0x820EF268;
		  /* 820EF268h */ case   10:  		/* bl -383160 */
		/* 820EF268h case   10:*/		regs.LR = 0x820EF26C; return 0x820919B0;
		/* 820EF268h case   10:*/		return 0x820EF26C;
		  /* 820EF26Ch */ case   11:  		/* mr R5, R26 */
		/* 820EF26Ch case   11:*/		regs.R5 = regs.R26;
		/* 820EF26Ch case   11:*/		return 0x820EF270;
		  /* 820EF270h */ case   12:  		/* mr R4, R25 */
		/* 820EF270h case   12:*/		regs.R4 = regs.R25;
		/* 820EF270h case   12:*/		return 0x820EF274;
		  /* 820EF274h */ case   13:  		/* mr R3, R22 */
		/* 820EF274h case   13:*/		regs.R3 = regs.R22;
		/* 820EF274h case   13:*/		return 0x820EF278;
		  /* 820EF278h */ case   14:  		/* bl -383176 */
		/* 820EF278h case   14:*/		regs.LR = 0x820EF27C; return 0x820919B0;
		/* 820EF278h case   14:*/		return 0x820EF27C;
	}
	return 0x820EF27C;
} // Block from 820EF240h-820EF27Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820EF27Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF27C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF27C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF27C);
		  /* 820EF27Ch */ case    0:  		/* addi R11, R1, 96 */
		/* 820EF27Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820EF27Ch case    0:*/		return 0x820EF280;
		  /* 820EF280h */ case    1:  		/* mr R5, R26 */
		/* 820EF280h case    1:*/		regs.R5 = regs.R26;
		/* 820EF280h case    1:*/		return 0x820EF284;
		  /* 820EF284h */ case    2:  		/* add R4, R23, R11 */
		/* 820EF284h case    2:*/		cpu::op::add<0>(regs,&regs.R4,regs.R23,regs.R11);
		/* 820EF284h case    2:*/		return 0x820EF288;
		  /* 820EF288h */ case    3:  		/* mr R3, R25 */
		/* 820EF288h case    3:*/		regs.R3 = regs.R25;
		/* 820EF288h case    3:*/		return 0x820EF28C;
		  /* 820EF28Ch */ case    4:  		/* bl -383196 */
		/* 820EF28Ch case    4:*/		regs.LR = 0x820EF290; return 0x820919B0;
		/* 820EF28Ch case    4:*/		return 0x820EF290;
		  /* 820EF290h */ case    5:  		/* lwz R11, <#[R31]> */
		/* 820EF290h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EF290h case    5:*/		return 0x820EF294;
		  /* 820EF294h */ case    6:  		/* addi R5, R1, 80 */
		/* 820EF294h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820EF294h case    6:*/		return 0x820EF298;
		  /* 820EF298h */ case    7:  		/* mr R4, R28 */
		/* 820EF298h case    7:*/		regs.R4 = regs.R28;
		/* 820EF298h case    7:*/		return 0x820EF29C;
		  /* 820EF29Ch */ case    8:  		/* mr R3, R31 */
		/* 820EF29Ch case    8:*/		regs.R3 = regs.R31;
		/* 820EF29Ch case    8:*/		return 0x820EF2A0;
		  /* 820EF2A0h */ case    9:  		/* lwz R11, <#[R11 + 32]> */
		/* 820EF2A0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 820EF2A0h case    9:*/		return 0x820EF2A4;
		  /* 820EF2A4h */ case   10:  		/* mtspr CTR, R11 */
		/* 820EF2A4h case   10:*/		regs.CTR = regs.R11;
		/* 820EF2A4h case   10:*/		return 0x820EF2A8;
		  /* 820EF2A8h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820EF2A8h case   11:*/		if ( 1 ) { regs.LR = 0x820EF2AC; return (uint32)regs.CTR; }
		/* 820EF2A8h case   11:*/		return 0x820EF2AC;
		  /* 820EF2ACh */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820EF2ACh case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EF2ACh case   12:*/		return 0x820EF2B0;
		  /* 820EF2B0h */ case   13:  		/* bc 4, CR0_EQ, -584 */
		/* 820EF2B0h case   13:*/		if ( !regs.CR[0].eq ) { return 0x820EF068;  }
		/* 820EF2B0h case   13:*/		return 0x820EF2B4;
	}
	return 0x820EF2B4;
} // Block from 820EF27Ch-820EF2B4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820EF2B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF2B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF2B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF2B4);
		  /* 820EF2B4h */ case    0:  		/* mr R4, R28 */
		/* 820EF2B4h case    0:*/		regs.R4 = regs.R28;
		/* 820EF2B4h case    0:*/		return 0x820EF2B8;
		  /* 820EF2B8h */ case    1:  		/* mr R3, R31 */
		/* 820EF2B8h case    1:*/		regs.R3 = regs.R31;
		/* 820EF2B8h case    1:*/		return 0x820EF2BC;
		  /* 820EF2BCh */ case    2:  		/* bl 57772 */
		/* 820EF2BCh case    2:*/		regs.LR = 0x820EF2C0; return 0x820FD468;
		/* 820EF2BCh case    2:*/		return 0x820EF2C0;
		  /* 820EF2C0h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 820EF2C0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820EF2C0h case    3:*/		return 0x820EF2C4;
		  /* 820EF2C4h */ case    4:  		/* bc 12, CR6_EQ, 132 */
		/* 820EF2C4h case    4:*/		if ( regs.CR[6].eq ) { return 0x820EF348;  }
		/* 820EF2C4h case    4:*/		return 0x820EF2C8;
		  /* 820EF2C8h */ case    5:  		/* mr R3, R28 */
		/* 820EF2C8h case    5:*/		regs.R3 = regs.R28;
		/* 820EF2C8h case    5:*/		return 0x820EF2CC;
		  /* 820EF2CCh */ case    6:  		/* bl 1237236 */
		/* 820EF2CCh case    6:*/		regs.LR = 0x820EF2D0; return 0x8221D3C0;
		/* 820EF2CCh case    6:*/		return 0x820EF2D0;
		  /* 820EF2D0h */ case    7:  		/* mr R3, R28 */
		/* 820EF2D0h case    7:*/		regs.R3 = regs.R28;
		/* 820EF2D0h case    7:*/		return 0x820EF2D4;
		  /* 820EF2D4h */ case    8:  		/* bl 54044 */
		/* 820EF2D4h case    8:*/		regs.LR = 0x820EF2D8; return 0x820FC5F0;
		/* 820EF2D4h case    8:*/		return 0x820EF2D8;
		  /* 820EF2D8h */ case    9:  		/* lwz R10, <#[R31 + 24]> */
		/* 820EF2D8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820EF2D8h case    9:*/		return 0x820EF2DC;
		  /* 820EF2DCh */ case   10:  		/* li R11, 0 */
		/* 820EF2DCh case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820EF2DCh case   10:*/		return 0x820EF2E0;
		  /* 820EF2E0h */ case   11:  		/* stwx R11, <#[R18 + R10]> */
		/* 820EF2E0h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R18 + regs.R10 + 0x00000000) );
		/* 820EF2E0h case   11:*/		return 0x820EF2E4;
	}
	return 0x820EF2E4;
} // Block from 820EF2B4h-820EF2E4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820EF2E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF2E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF2E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF2E4);
		  /* 820EF2E4h */ case    0:  		/* addi R19, R19, 1 */
		/* 820EF2E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 820EF2E4h case    0:*/		return 0x820EF2E8;
		  /* 820EF2E8h */ case    1:  		/* addi R18, R18, 4 */
		/* 820EF2E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x4);
		/* 820EF2E8h case    1:*/		return 0x820EF2EC;
		  /* 820EF2ECh */ case    2:  		/* cmplw CR6, R19, R17 */
		/* 820EF2ECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R17);
		/* 820EF2ECh case    2:*/		return 0x820EF2F0;
		  /* 820EF2F0h */ case    3:  		/* bc 12, CR6_LT, -720 */
		/* 820EF2F0h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EF020;  }
		/* 820EF2F0h case    3:*/		return 0x820EF2F4;
	}
	return 0x820EF2F4;
} // Block from 820EF2E4h-820EF2F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EF2F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF2F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF2F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF2F4);
		  /* 820EF2F4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820EF2F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820EF2F4h case    0:*/		return 0x820EF2F8;
		  /* 820EF2F8h */ case    1:  		/* mr R9, R17 */
		/* 820EF2F8h case    1:*/		regs.R9 = regs.R17;
		/* 820EF2F8h case    1:*/		return 0x820EF2FC;
		  /* 820EF2FCh */ case    2:  		/* cmplw CR6, R17, R11 */
		/* 820EF2FCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R17,regs.R11);
		/* 820EF2FCh case    2:*/		return 0x820EF300;
		  /* 820EF300h */ case    3:  		/* bc 4, CR6_LT, 48 */
		/* 820EF300h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820EF330;  }
		/* 820EF300h case    3:*/		return 0x820EF304;
		  /* 820EF304h */ case    4:  		/* rlwinm R11, R17, 2, 0, 29 */
		/* 820EF304h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R17);
		/* 820EF304h case    4:*/		return 0x820EF308;
		  /* 820EF308h */ case    5:  		/* li R10, 0 */
		/* 820EF308h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820EF308h case    5:*/		return 0x820EF30C;
		  /* 820EF30Ch */ case    6:  		/* lwz R8, <#[R31 + 24]> */
		/* 820EF30Ch case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 820EF30Ch case    6:*/		return 0x820EF310;
		  /* 820EF310h */ case    7:  		/* addi R9, R9, 1 */
		/* 820EF310h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820EF310h case    7:*/		return 0x820EF314;
		  /* 820EF314h */ case    8:  		/* lwzx R7, <#[R11 + R8]> */
		/* 820EF314h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820EF314h case    8:*/		return 0x820EF318;
		  /* 820EF318h */ case    9:  		/* addi R11, R11, 4 */
		/* 820EF318h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EF318h case    9:*/		return 0x820EF31C;
		  /* 820EF31Ch */ case   10:  		/* stwx R7, <#[R10 + R8]> */
		/* 820EF31Ch case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820EF31Ch case   10:*/		return 0x820EF320;
		  /* 820EF320h */ case   11:  		/* addi R10, R10, 4 */
		/* 820EF320h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EF320h case   11:*/		return 0x820EF324;
		  /* 820EF324h */ case   12:  		/* lwz R8, <#[R31 + 12]> */
		/* 820EF324h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 820EF324h case   12:*/		return 0x820EF328;
		  /* 820EF328h */ case   13:  		/* cmplw CR6, R9, R8 */
		/* 820EF328h case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820EF328h case   13:*/		return 0x820EF32C;
		  /* 820EF32Ch */ case   14:  		/* bc 12, CR6_LT, -32 */
		/* 820EF32Ch case   14:*/		if ( regs.CR[6].lt ) { return 0x820EF30C;  }
		/* 820EF32Ch case   14:*/		return 0x820EF330;
	}
	return 0x820EF330;
} // Block from 820EF2F4h-820EF330h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820EF330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF330);
		  /* 820EF330h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820EF330h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820EF330h case    0:*/		return 0x820EF334;
		  /* 820EF334h */ case    1:  		/* li R3, 0 */
		/* 820EF334h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820EF334h case    1:*/		return 0x820EF338;
		  /* 820EF338h */ case    2:  		/* subf R11, R17, R11 */
		/* 820EF338h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R17,regs.R11);
		/* 820EF338h case    2:*/		return 0x820EF33C;
		  /* 820EF33Ch */ case    3:  		/* stw R11, <#[R31 + 12]> */
		/* 820EF33Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820EF33Ch case    3:*/		return 0x820EF340;
	}
	return 0x820EF340;
} // Block from 820EF330h-820EF340h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EF340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF340);
		  /* 820EF340h */ case    0:  		/* addi R1, R1, 288 */
		/* 820EF340h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 820EF340h case    0:*/		return 0x820EF344;
		  /* 820EF344h */ case    1:  		/* b -385232 */
		/* 820EF344h case    1:*/		return 0x82091274;
		/* 820EF344h case    1:*/		return 0x820EF348;
	}
	return 0x820EF348;
} // Block from 820EF340h-820EF348h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EF348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF348);
		  /* 820EF348h */ case    0:  		/* lis R3, -32761 */
		/* 820EF348h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820EF348h case    0:*/		return 0x820EF34C;
		  /* 820EF34Ch */ case    1:  		/* ori R3, R3, 14 */
		/* 820EF34Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820EF34Ch case    1:*/		return 0x820EF350;
		  /* 820EF350h */ case    2:  		/* b -16 */
		/* 820EF350h case    2:*/		return 0x820EF340;
		/* 820EF350h case    2:*/		return 0x820EF354;
		  /* 820EF354h */ case    3:  		/* nop */
		/* 820EF354h case    3:*/		cpu::op::nop();
		/* 820EF354h case    3:*/		return 0x820EF358;
	}
	return 0x820EF358;
} // Block from 820EF348h-820EF358h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EF358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF358);
		  /* 820EF358h */ case    0:  		/* mfspr R12, LR */
		/* 820EF358h case    0:*/		regs.R12 = regs.LR;
		/* 820EF358h case    0:*/		return 0x820EF35C;
		  /* 820EF35Ch */ case    1:  		/* bl -385316 */
		/* 820EF35Ch case    1:*/		regs.LR = 0x820EF360; return 0x82091238;
		/* 820EF35Ch case    1:*/		return 0x820EF360;
		  /* 820EF360h */ case    2:  		/* stwu R1, <#[R1 - 480]> */
		/* 820EF360h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE20);
		/* 820EF360h case    2:*/		return 0x820EF364;
		  /* 820EF364h */ case    3:  		/* lwz R4, <#[R3 + 260]> */
		/* 820EF364h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000104) );
		/* 820EF364h case    3:*/		return 0x820EF368;
		  /* 820EF368h */ case    4:  		/* lis R11, -32254 */
		/* 820EF368h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820EF368h case    4:*/		return 0x820EF36C;
		  /* 820EF36Ch */ case    5:  		/* li R7, 3 */
		/* 820EF36Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 820EF36Ch case    5:*/		return 0x820EF370;
		  /* 820EF370h */ case    6:  		/* addi R31, R11, -25096 */
		/* 820EF370h case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF9DF8);
		/* 820EF370h case    6:*/		return 0x820EF374;
		  /* 820EF374h */ case    7:  		/* li R22, 0 */
		/* 820EF374h case    7:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 820EF374h case    7:*/		return 0x820EF378;
		  /* 820EF378h */ case    8:  		/* stw R7, <#[R1 + 124]> */
		/* 820EF378h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x0000007C) );
		/* 820EF378h case    8:*/		return 0x820EF37C;
		  /* 820EF37Ch */ case    9:  		/* li R11, 2 */
		/* 820EF37Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820EF37Ch case    9:*/		return 0x820EF380;
		  /* 820EF380h */ case   10:  		/* lwz R10, <#[R4]> */
		/* 820EF380h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 820EF380h case   10:*/		return 0x820EF384;
		  /* 820EF384h */ case   11:  		/* li R21, 1 */
		/* 820EF384h case   11:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 820EF384h case   11:*/		return 0x820EF388;
		  /* 820EF388h */ case   12:  		/* addi R5, R31, 448 */
		/* 820EF388h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x1C0);
		/* 820EF388h case   12:*/		return 0x820EF38C;
		  /* 820EF38Ch */ case   13:  		/* stw R22, <#[R1 + 96]> */
		/* 820EF38Ch case   13:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 820EF38Ch case   13:*/		return 0x820EF390;
		  /* 820EF390h */ case   14:  		/* rlwinm R25, R10, 0, 12, 31 */
		/* 820EF390h case   14:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R25,regs.R10);
		/* 820EF390h case   14:*/		return 0x820EF394;
		  /* 820EF394h */ case   15:  		/* stw R22, <#[R1 + 112]> */
		/* 820EF394h case   15:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000070) );
		/* 820EF394h case   15:*/		return 0x820EF398;
		  /* 820EF398h */ case   16:  		/* addi R9, R1, 112 */
		/* 820EF398h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820EF398h case   16:*/		return 0x820EF39C;
		  /* 820EF39Ch */ case   17:  		/* stw R22, <#[R1 + 84]> */
		/* 820EF39Ch case   17:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 820EF39Ch case   17:*/		return 0x820EF3A0;
		  /* 820EF3A0h */ case   18:  		/* addi R8, R1, 208 */
		/* 820EF3A0h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xD0);
		/* 820EF3A0h case   18:*/		return 0x820EF3A4;
		  /* 820EF3A4h */ case   19:  		/* stw R21, <#[R1 + 116]> */
		/* 820EF3A4h case   19:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000074) );
		/* 820EF3A4h case   19:*/		return 0x820EF3A8;
		  /* 820EF3A8h */ case   20:  		/* addi R7, R1, 96 */
		/* 820EF3A8h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820EF3A8h case   20:*/		return 0x820EF3AC;
		  /* 820EF3ACh */ case   21:  		/* stw R11, <#[R1 + 120]> */
		/* 820EF3ACh case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820EF3ACh case   21:*/		return 0x820EF3B0;
		  /* 820EF3B0h */ case   22:  		/* addi R6, R1, 144 */
		/* 820EF3B0h case   22:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 820EF3B0h case   22:*/		return 0x820EF3B4;
		  /* 820EF3B4h */ case   23:  		/* mr R10, R25 */
		/* 820EF3B4h case   23:*/		regs.R10 = regs.R25;
		/* 820EF3B4h case   23:*/		return 0x820EF3B8;
		  /* 820EF3B8h */ case   24:  		/* mr R26, R3 */
		/* 820EF3B8h case   24:*/		regs.R26 = regs.R3;
		/* 820EF3B8h case   24:*/		return 0x820EF3BC;
		  /* 820EF3BCh */ case   25:  		/* mr R30, R22 */
		/* 820EF3BCh case   25:*/		regs.R30 = regs.R22;
		/* 820EF3BCh case   25:*/		return 0x820EF3C0;
		  /* 820EF3C0h */ case   26:  		/* mr R23, R22 */
		/* 820EF3C0h case   26:*/		regs.R23 = regs.R22;
		/* 820EF3C0h case   26:*/		return 0x820EF3C4;
		  /* 820EF3C4h */ case   27:  		/* mr R24, R22 */
		/* 820EF3C4h case   27:*/		regs.R24 = regs.R22;
		/* 820EF3C4h case   27:*/		return 0x820EF3C8;
		  /* 820EF3C8h */ case   28:  		/* mr R20, R22 */
		/* 820EF3C8h case   28:*/		regs.R20 = regs.R22;
		/* 820EF3C8h case   28:*/		return 0x820EF3CC;
		  /* 820EF3CCh */ case   29:  		/* bl -46924 */
		/* 820EF3CCh case   29:*/		regs.LR = 0x820EF3D0; return 0x820E3C80;
		/* 820EF3CCh case   29:*/		return 0x820EF3D0;
		  /* 820EF3D0h */ case   30:  		/* cmpwi CR6, R3, 1 */
		/* 820EF3D0h case   30:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 820EF3D0h case   30:*/		return 0x820EF3D4;
		  /* 820EF3D4h */ case   31:  		/* bc 4, CR6_EQ, 48 */
		/* 820EF3D4h case   31:*/		if ( !regs.CR[6].eq ) { return 0x820EF404;  }
		/* 820EF3D4h case   31:*/		return 0x820EF3D8;
		  /* 820EF3D8h */ case   32:  		/* addi R5, R31, 352 */
		/* 820EF3D8h case   32:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x160);
		/* 820EF3D8h case   32:*/		return 0x820EF3DC;
		  /* 820EF3DCh */ case   33:  		/* lwz R4, <#[R26 + 260]> */
		/* 820EF3DCh case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000104) );
		/* 820EF3DCh case   33:*/		return 0x820EF3E0;
		  /* 820EF3E0h */ case   34:  		/* mr R10, R25 */
		/* 820EF3E0h case   34:*/		regs.R10 = regs.R25;
		/* 820EF3E0h case   34:*/		return 0x820EF3E4;
		  /* 820EF3E4h */ case   35:  		/* stw R22, <#[R1 + 84]> */
		/* 820EF3E4h case   35:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 820EF3E4h case   35:*/		return 0x820EF3E8;
		  /* 820EF3E8h */ case   36:  		/* addi R9, R1, 112 */
		/* 820EF3E8h case   36:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820EF3E8h case   36:*/		return 0x820EF3EC;
		  /* 820EF3ECh */ case   37:  		/* addi R8, R1, 208 */
		/* 820EF3ECh case   37:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xD0);
		/* 820EF3ECh case   37:*/		return 0x820EF3F0;
		  /* 820EF3F0h */ case   38:  		/* addi R7, R1, 96 */
		/* 820EF3F0h case   38:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820EF3F0h case   38:*/		return 0x820EF3F4;
		  /* 820EF3F4h */ case   39:  		/* addi R6, R1, 144 */
		/* 820EF3F4h case   39:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 820EF3F4h case   39:*/		return 0x820EF3F8;
		  /* 820EF3F8h */ case   40:  		/* mr R3, R26 */
		/* 820EF3F8h case   40:*/		regs.R3 = regs.R26;
		/* 820EF3F8h case   40:*/		return 0x820EF3FC;
		  /* 820EF3FCh */ case   41:  		/* bl -46972 */
		/* 820EF3FCh case   41:*/		regs.LR = 0x820EF400; return 0x820E3C80;
		/* 820EF3FCh case   41:*/		return 0x820EF400;
		  /* 820EF400h */ case   42:  		/* mr R30, R21 */
		/* 820EF400h case   42:*/		regs.R30 = regs.R21;
		/* 820EF400h case   42:*/		return 0x820EF404;
	}
	return 0x820EF404;
} // Block from 820EF358h-820EF404h (43 instructions)

//////////////////////////////////////////////////////
// Block at 820EF404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF404);
		  /* 820EF404h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820EF404h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820EF404h case    0:*/		return 0x820EF408;
		  /* 820EF408h */ case    1:  		/* bc 4, CR6_EQ, 644 */
		/* 820EF408h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EF68C;  }
		/* 820EF408h case    1:*/		return 0x820EF40C;
		  /* 820EF40Ch */ case    2:  		/* lis R11, -32256 */
		/* 820EF40Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820EF40Ch case    2:*/		return 0x820EF410;
		  /* 820EF410h */ case    3:  		/* lis R10, -32256 */
		/* 820EF410h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820EF410h case    3:*/		return 0x820EF414;
		  /* 820EF414h */ case    4:  		/* mr R4, R22 */
		/* 820EF414h case    4:*/		regs.R4 = regs.R22;
		/* 820EF414h case    4:*/		return 0x820EF418;
		  /* 820EF418h */ case    5:  		/* mr R6, R22 */
		/* 820EF418h case    5:*/		regs.R6 = regs.R22;
		/* 820EF418h case    5:*/		return 0x820EF41C;
		  /* 820EF41Ch */ case    6:  		/* lfs FR12, <#[R11 + 1816]> */
		/* 820EF41Ch case    6:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000718) );
		/* 820EF41Ch case    6:*/		return 0x820EF420;
		  /* 820EF420h */ case    7:  		/* lfs FR13, <#[R10 + 1792]> */
		/* 820EF420h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000700) );
		/* 820EF420h case    7:*/		return 0x820EF424;
		  /* 820EF424h */ case    8:  		/* mr R5, R22 */
		/* 820EF424h case    8:*/		regs.R5 = regs.R22;
		/* 820EF424h case    8:*/		return 0x820EF428;
		  /* 820EF428h */ case    9:  		/* mr R7, R22 */
		/* 820EF428h case    9:*/		regs.R7 = regs.R22;
		/* 820EF428h case    9:*/		return 0x820EF42C;
		  /* 820EF42Ch */ case   10:  		/* cmplwi CR6, R25, 0 */
		/* 820EF42Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820EF42Ch case   10:*/		return 0x820EF430;
		  /* 820EF430h */ case   11:  		/* bc 12, CR6_EQ, 148 */
		/* 820EF430h case   11:*/		if ( regs.CR[6].eq ) { return 0x820EF4C4;  }
		/* 820EF430h case   11:*/		return 0x820EF434;
		  /* 820EF434h */ case   12:  		/* lwz R10, <#[R26 + 20]> */
		/* 820EF434h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 820EF434h case   12:*/		return 0x820EF438;
		  /* 820EF438h */ case   13:  		/* rlwinm R8, R6, 2, 0, 29 */
		/* 820EF438h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R6);
		/* 820EF438h case   13:*/		return 0x820EF43C;
		  /* 820EF43Ch */ case   14:  		/* lwz R9, <#[R26 + 16]> */
		/* 820EF43Ch case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000010) );
		/* 820EF43Ch case   14:*/		return 0x820EF440;
		  /* 820EF440h */ case   15:  		/* mtspr CTR, R25 */
		/* 820EF440h case   15:*/		regs.CTR = regs.R25;
		/* 820EF440h case   15:*/		return 0x820EF444;
		  /* 820EF444h */ case   16:  		/* add R11, R8, R7 */
		/* 820EF444h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R7);
		/* 820EF444h case   16:*/		return 0x820EF448;
		  /* 820EF448h */ case   17:  		/* addi R3, R1, 224 */
		/* 820EF448h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xE0);
		/* 820EF448h case   17:*/		return 0x820EF44C;
		  /* 820EF44Ch */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EF44Ch case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EF44Ch case   18:*/		return 0x820EF450;
		  /* 820EF450h */ case   19:  		/* lwzx R11, <#[R11 + R3]> */
		/* 820EF450h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 820EF450h case   19:*/		return 0x820EF454;
		  /* 820EF454h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EF454h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EF454h case   20:*/		return 0x820EF458;
		  /* 820EF458h */ case   21:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820EF458h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EF458h case   21:*/		return 0x820EF45C;
		  /* 820EF45Ch */ case   22:  		/* lwz R3, <#[R11 + 4]> */
		/* 820EF45Ch case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 820EF45Ch case   22:*/		return 0x820EF460;
		  /* 820EF460h */ case   23:  		/* rlwinm R3, R3, 2, 0, 29 */
		/* 820EF460h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R3);
		/* 820EF460h case   23:*/		return 0x820EF464;
		  /* 820EF464h */ case   24:  		/* lwzx R3, <#[R3 + R9]> */
		/* 820EF464h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + regs.R9 + 0x00000000) );
		/* 820EF464h case   24:*/		return 0x820EF468;
		  /* 820EF468h */ case   25:  		/* lwz R3, <#[R3 + 4]> */
		/* 820EF468h case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 820EF468h case   25:*/		return 0x820EF46C;
		  /* 820EF46Ch */ case   26:  		/* rlwinm. R3, R3, 0, 23, 23 */
		/* 820EF46Ch case   26:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R3,regs.R3);
		/* 820EF46Ch case   26:*/		return 0x820EF470;
		  /* 820EF470h */ case   27:  		/* bc 12, CR0_EQ, 48 */
		/* 820EF470h case   27:*/		if ( regs.CR[0].eq ) { return 0x820EF4A0;  }
		/* 820EF470h case   27:*/		return 0x820EF474;
		  /* 820EF474h */ case   28:  		/* lwz R3, <#[R11 + 8]> */
		/* 820EF474h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000008) );
		/* 820EF474h case   28:*/		return 0x820EF478;
		  /* 820EF478h */ case   29:  		/* cmpwi CR6, R3, -1 */
		/* 820EF478h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820EF478h case   29:*/		return 0x820EF47C;
		  /* 820EF47Ch */ case   30:  		/* bc 4, CR6_EQ, 36 */
		/* 820EF47Ch case   30:*/		if ( !regs.CR[6].eq ) { return 0x820EF4A0;  }
		/* 820EF47Ch case   30:*/		return 0x820EF480;
		  /* 820EF480h */ case   31:  		/* cmpwi CR6, R30, 0 */
		/* 820EF480h case   31:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820EF480h case   31:*/		return 0x820EF484;
		  /* 820EF484h */ case   32:  		/* bc 12, CR6_EQ, 12 */
		/* 820EF484h case   32:*/		if ( regs.CR[6].eq ) { return 0x820EF490;  }
		/* 820EF484h case   32:*/		return 0x820EF488;
		  /* 820EF488h */ case   33:  		/* fmr FR0, FR13 */
		/* 820EF488h case   33:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR13);
		/* 820EF488h case   33:*/		return 0x820EF48C;
		  /* 820EF48Ch */ case   34:  		/* b 8 */
		/* 820EF48Ch case   34:*/		return 0x820EF494;
		/* 820EF48Ch case   34:*/		return 0x820EF490;
	}
	return 0x820EF490;
} // Block from 820EF404h-820EF490h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820EF490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF490);
		  /* 820EF490h */ case    0:  		/* fmr FR0, FR12 */
		/* 820EF490h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR12);
		/* 820EF490h case    0:*/		return 0x820EF494;
	}
	return 0x820EF494;
} // Block from 820EF490h-820EF494h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EF494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF494);
		  /* 820EF494h */ case    0:  		/* lfd FR11, <#[R11 + 32]> */
		/* 820EF494h case    0:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000020) );
		/* 820EF494h case    0:*/		return 0x820EF498;
		  /* 820EF498h */ case    1:  		/* fcmpu CR6, FR11, FR0 */
		/* 820EF498h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR0);
		/* 820EF498h case    1:*/		return 0x820EF49C;
		  /* 820EF49Ch */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820EF49Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820EF4A4;  }
		/* 820EF49Ch case    2:*/		return 0x820EF4A0;
	}
	return 0x820EF4A0;
} // Block from 820EF494h-820EF4A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EF4A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF4A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF4A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF4A0);
		  /* 820EF4A0h */ case    0:  		/* mr R5, R21 */
		/* 820EF4A0h case    0:*/		regs.R5 = regs.R21;
		/* 820EF4A0h case    0:*/		return 0x820EF4A4;
	}
	return 0x820EF4A4;
} // Block from 820EF4A0h-820EF4A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EF4A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF4A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF4A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF4A4);
		  /* 820EF4A4h */ case    0:  		/* addi R7, R7, 1 */
		/* 820EF4A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820EF4A4h case    0:*/		return 0x820EF4A8;
		  /* 820EF4A8h */ case    1:  		/* bc 16, CR0_LT, -100 */
		/* 820EF4A8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EF444;  }
		/* 820EF4A8h case    1:*/		return 0x820EF4AC;
		  /* 820EF4ACh */ case    2:  		/* cmpwi CR6, R5, 0 */
		/* 820EF4ACh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 820EF4ACh case    2:*/		return 0x820EF4B0;
		  /* 820EF4B0h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 820EF4B0h case    3:*/		if ( regs.CR[6].eq ) { return 0x820EF4C4;  }
		/* 820EF4B0h case    3:*/		return 0x820EF4B4;
		  /* 820EF4B4h */ case    4:  		/* addi R6, R6, 1 */
		/* 820EF4B4h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820EF4B4h case    4:*/		return 0x820EF4B8;
		  /* 820EF4B8h */ case    5:  		/* cmplwi CR6, R6, 2 */
		/* 820EF4B8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000002);
		/* 820EF4B8h case    5:*/		return 0x820EF4BC;
		  /* 820EF4BCh */ case    6:  		/* bc 12, CR6_LT, -152 */
		/* 820EF4BCh case    6:*/		if ( regs.CR[6].lt ) { return 0x820EF424;  }
		/* 820EF4BCh case    6:*/		return 0x820EF4C0;
		  /* 820EF4C0h */ case    7:  		/* b 16 */
		/* 820EF4C0h case    7:*/		return 0x820EF4D0;
		/* 820EF4C0h case    7:*/		return 0x820EF4C4;
	}
	return 0x820EF4C4;
} // Block from 820EF4A4h-820EF4C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EF4C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF4C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF4C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF4C4);
		  /* 820EF4C4h */ case    0:  		/* rlwinm R11, R6, 4, 0, 27 */
		/* 820EF4C4h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R6);
		/* 820EF4C4h case    0:*/		return 0x820EF4C8;
		  /* 820EF4C8h */ case    1:  		/* addi R10, R1, 240 */
		/* 820EF4C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xF0);
		/* 820EF4C8h case    1:*/		return 0x820EF4CC;
		  /* 820EF4CCh */ case    2:  		/* subf R4, R11, R10 */
		/* 820EF4CCh case    2:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 820EF4CCh case    2:*/		return 0x820EF4D0;
	}
	return 0x820EF4D0;
} // Block from 820EF4C4h-820EF4D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EF4D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF4D0);
		  /* 820EF4D0h */ case    0:  		/* mr R7, R22 */
		/* 820EF4D0h case    0:*/		regs.R7 = regs.R22;
		/* 820EF4D0h case    0:*/		return 0x820EF4D4;
		  /* 820EF4D4h */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 820EF4D4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820EF4D4h case    1:*/		return 0x820EF4D8;
		  /* 820EF4D8h */ case    2:  		/* bc 12, CR6_EQ, 124 */
		/* 820EF4D8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EF554;  }
		/* 820EF4D8h case    2:*/		return 0x820EF4DC;
		  /* 820EF4DCh */ case    3:  		/* lwz R9, <#[R26 + 20]> */
		/* 820EF4DCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000014) );
		/* 820EF4DCh case    3:*/		return 0x820EF4E0;
		  /* 820EF4E0h */ case    4:  		/* addi R10, R1, 208 */
		/* 820EF4E0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xD0);
		/* 820EF4E0h case    4:*/		return 0x820EF4E4;
		  /* 820EF4E4h */ case    5:  		/* lwz R8, <#[R26 + 16]> */
		/* 820EF4E4h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000010) );
		/* 820EF4E4h case    5:*/		return 0x820EF4E8;
		  /* 820EF4E8h */ case    6:  		/* mtspr CTR, R25 */
		/* 820EF4E8h case    6:*/		regs.CTR = regs.R25;
		/* 820EF4E8h case    6:*/		return 0x820EF4EC;
		  /* 820EF4ECh */ case    7:  		/* lwz R11, <#[R10]> */
		/* 820EF4ECh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820EF4ECh case    7:*/		return 0x820EF4F0;
		  /* 820EF4F0h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EF4F0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EF4F0h case    8:*/		return 0x820EF4F4;
		  /* 820EF4F4h */ case    9:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820EF4F4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820EF4F4h case    9:*/		return 0x820EF4F8;
		  /* 820EF4F8h */ case   10:  		/* lwz R6, <#[R11 + 4]> */
		/* 820EF4F8h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 820EF4F8h case   10:*/		return 0x820EF4FC;
		  /* 820EF4FCh */ case   11:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820EF4FCh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820EF4FCh case   11:*/		return 0x820EF500;
		  /* 820EF500h */ case   12:  		/* lwzx R6, <#[R6 + R8]> */
		/* 820EF500h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820EF500h case   12:*/		return 0x820EF504;
		  /* 820EF504h */ case   13:  		/* lwz R6, <#[R6 + 4]> */
		/* 820EF504h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820EF504h case   13:*/		return 0x820EF508;
		  /* 820EF508h */ case   14:  		/* rlwinm. R6, R6, 0, 23, 23 */
		/* 820EF508h case   14:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R6,regs.R6);
		/* 820EF508h case   14:*/		return 0x820EF50C;
		  /* 820EF50Ch */ case   15:  		/* bc 12, CR0_EQ, 48 */
		/* 820EF50Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x820EF53C;  }
		/* 820EF50Ch case   15:*/		return 0x820EF510;
		  /* 820EF510h */ case   16:  		/* lwz R6, <#[R11 + 8]> */
		/* 820EF510h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 820EF510h case   16:*/		return 0x820EF514;
		  /* 820EF514h */ case   17:  		/* cmpwi CR6, R6, -1 */
		/* 820EF514h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 820EF514h case   17:*/		return 0x820EF518;
		  /* 820EF518h */ case   18:  		/* bc 4, CR6_EQ, 36 */
		/* 820EF518h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820EF53C;  }
		/* 820EF518h case   18:*/		return 0x820EF51C;
		  /* 820EF51Ch */ case   19:  		/* cmpwi CR6, R30, 0 */
		/* 820EF51Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820EF51Ch case   19:*/		return 0x820EF520;
		  /* 820EF520h */ case   20:  		/* bc 12, CR6_EQ, 12 */
		/* 820EF520h case   20:*/		if ( regs.CR[6].eq ) { return 0x820EF52C;  }
		/* 820EF520h case   20:*/		return 0x820EF524;
		  /* 820EF524h */ case   21:  		/* fmr FR0, FR12 */
		/* 820EF524h case   21:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR12);
		/* 820EF524h case   21:*/		return 0x820EF528;
		  /* 820EF528h */ case   22:  		/* b 8 */
		/* 820EF528h case   22:*/		return 0x820EF530;
		/* 820EF528h case   22:*/		return 0x820EF52C;
	}
	return 0x820EF52C;
} // Block from 820EF4D0h-820EF52Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 820EF52Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF52C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF52C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF52C);
		  /* 820EF52Ch */ case    0:  		/* fmr FR0, FR13 */
		/* 820EF52Ch case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR13);
		/* 820EF52Ch case    0:*/		return 0x820EF530;
	}
	return 0x820EF530;
} // Block from 820EF52Ch-820EF530h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EF530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF530);
		  /* 820EF530h */ case    0:  		/* lfd FR11, <#[R11 + 32]> */
		/* 820EF530h case    0:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000020) );
		/* 820EF530h case    0:*/		return 0x820EF534;
		  /* 820EF534h */ case    1:  		/* fcmpu CR6, FR11, FR0 */
		/* 820EF534h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR0);
		/* 820EF534h case    1:*/		return 0x820EF538;
		  /* 820EF538h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820EF538h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EF540;  }
		/* 820EF538h case    2:*/		return 0x820EF53C;
	}
	return 0x820EF53C;
} // Block from 820EF530h-820EF53Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EF53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF53C);
		  /* 820EF53Ch */ case    0:  		/* mr R7, R21 */
		/* 820EF53Ch case    0:*/		regs.R7 = regs.R21;
		/* 820EF53Ch case    0:*/		return 0x820EF540;
	}
	return 0x820EF540;
} // Block from 820EF53Ch-820EF540h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EF540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF540);
		  /* 820EF540h */ case    0:  		/* addi R10, R10, 4 */
		/* 820EF540h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EF540h case    0:*/		return 0x820EF544;
		  /* 820EF544h */ case    1:  		/* bc 16, CR0_LT, -88 */
		/* 820EF544h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EF4EC;  }
		/* 820EF544h case    1:*/		return 0x820EF548;
		  /* 820EF548h */ case    2:  		/* addic R11, R7, -1 */
		/* 820EF548h case    2:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R7,0xFFFFFFFF);
		/* 820EF548h case    2:*/		return 0x820EF54C;
		  /* 820EF54Ch */ case    3:  		/* subfe R11, R11, R11 */
		/* 820EF54Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820EF54Ch case    3:*/		return 0x820EF550;
		  /* 820EF550h */ case    4:  		/* and R4, R11, R4 */
		/* 820EF550h case    4:*/		cpu::op::and<0>(regs,&regs.R4,regs.R11,regs.R4);
		/* 820EF550h case    4:*/		return 0x820EF554;
	}
	return 0x820EF554;
} // Block from 820EF540h-820EF554h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EF554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF554);
		  /* 820EF554h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820EF554h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820EF554h case    0:*/		return 0x820EF558;
		  /* 820EF558h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820EF558h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EF564;  }
		/* 820EF558h case    1:*/		return 0x820EF55C;
		  /* 820EF55Ch */ case    2:  		/* li R3, 1 */
		/* 820EF55Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820EF55Ch case    2:*/		return 0x820EF560;
		  /* 820EF560h */ case    3:  		/* b 3080 */
		/* 820EF560h case    3:*/		return 0x820F0168;
		/* 820EF560h case    3:*/		return 0x820EF564;
	}
	return 0x820EF564;
} // Block from 820EF554h-820EF564h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EF564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF564);
		  /* 820EF564h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 820EF564h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820EF564h case    0:*/		return 0x820EF568;
		  /* 820EF568h */ case    1:  		/* bc 12, CR6_EQ, 112 */
		/* 820EF568h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EF5D8;  }
		/* 820EF568h case    1:*/		return 0x820EF56C;
		  /* 820EF56Ch */ case    2:  		/* addi R11, R1, 112 */
		/* 820EF56Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820EF56Ch case    2:*/		return 0x820EF570;
		  /* 820EF570h */ case    3:  		/* lwz R6, <#[R26 + 20]> */
		/* 820EF570h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000014) );
		/* 820EF570h case    3:*/		return 0x820EF574;
		  /* 820EF574h */ case    4:  		/* mr R8, R4 */
		/* 820EF574h case    4:*/		regs.R8 = regs.R4;
		/* 820EF574h case    4:*/		return 0x820EF578;
		  /* 820EF578h */ case    5:  		/* mtspr CTR, R25 */
		/* 820EF578h case    5:*/		regs.CTR = regs.R25;
		/* 820EF578h case    5:*/		return 0x820EF57C;
		  /* 820EF57Ch */ case    6:  		/* addi R5, R11, -4 */
		/* 820EF57Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFC);
		/* 820EF57Ch case    6:*/		return 0x820EF580;
		  /* 820EF580h */ case    7:  		/* lwz R10, <#[R8]> */
		/* 820EF580h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820EF580h case    7:*/		return 0x820EF584;
		  /* 820EF584h */ case    8:  		/* mr R11, R22 */
		/* 820EF584h case    8:*/		regs.R11 = regs.R22;
		/* 820EF584h case    8:*/		return 0x820EF588;
		  /* 820EF588h */ case    9:  		/* cmplwi CR6, R23, 0 */
		/* 820EF588h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820EF588h case    9:*/		return 0x820EF58C;
		  /* 820EF58Ch */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EF58Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EF58Ch case   10:*/		return 0x820EF590;
		  /* 820EF590h */ case   11:  		/* lwzx R9, <#[R10 + R6]> */
		/* 820EF590h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 820EF590h case   11:*/		return 0x820EF594;
		  /* 820EF594h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 820EF594h case   12:*/		if ( regs.CR[6].eq ) { return 0x820EF5BC;  }
		/* 820EF594h case   12:*/		return 0x820EF598;
		  /* 820EF598h */ case   13:  		/* lwz R7, <#[R9 + 72]> */
		/* 820EF598h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000048) );
		/* 820EF598h case   13:*/		return 0x820EF59C;
		  /* 820EF59Ch */ case   14:  		/* addi R10, R1, 112 */
		/* 820EF59Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 820EF59Ch case   14:*/		return 0x820EF5A0;
		  /* 820EF5A0h */ case   15:  		/* lwz R3, <#[R10]> */
		/* 820EF5A0h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000000) );
		/* 820EF5A0h case   15:*/		return 0x820EF5A4;
		  /* 820EF5A4h */ case   16:  		/* cmplw CR6, R7, R3 */
		/* 820EF5A4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R3);
		/* 820EF5A4h case   16:*/		return 0x820EF5A8;
		  /* 820EF5A8h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 820EF5A8h case   17:*/		if ( regs.CR[6].eq ) { return 0x820EF5BC;  }
		/* 820EF5A8h case   17:*/		return 0x820EF5AC;
		  /* 820EF5ACh */ case   18:  		/* addi R11, R11, 1 */
		/* 820EF5ACh case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EF5ACh case   18:*/		return 0x820EF5B0;
		  /* 820EF5B0h */ case   19:  		/* addi R10, R10, 4 */
		/* 820EF5B0h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EF5B0h case   19:*/		return 0x820EF5B4;
		  /* 820EF5B4h */ case   20:  		/* cmplw CR6, R11, R23 */
		/* 820EF5B4h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 820EF5B4h case   20:*/		return 0x820EF5B8;
		  /* 820EF5B8h */ case   21:  		/* bc 12, CR6_LT, -24 */
		/* 820EF5B8h case   21:*/		if ( regs.CR[6].lt ) { return 0x820EF5A0;  }
		/* 820EF5B8h case   21:*/		return 0x820EF5BC;
	}
	return 0x820EF5BC;
} // Block from 820EF564h-820EF5BCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 820EF5BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF5BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF5BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF5BC);
		  /* 820EF5BCh */ case    0:  		/* cmplw CR6, R11, R23 */
		/* 820EF5BCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 820EF5BCh case    0:*/		return 0x820EF5C0;
		  /* 820EF5C0h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820EF5C0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EF5D0;  }
		/* 820EF5C0h case    1:*/		return 0x820EF5C4;
		  /* 820EF5C4h */ case    2:  		/* lwz R11, <#[R9 + 72]> */
		/* 820EF5C4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000048) );
		/* 820EF5C4h case    2:*/		return 0x820EF5C8;
		  /* 820EF5C8h */ case    3:  		/* addi R23, R23, 1 */
		/* 820EF5C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 820EF5C8h case    3:*/		return 0x820EF5CC;
		  /* 820EF5CCh */ case    4:  		/* stwu R11, <#[R5 + 4]> */
		/* 820EF5CCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 820EF5CCh case    4:*/		return 0x820EF5D0;
	}
	return 0x820EF5D0;
} // Block from 820EF5BCh-820EF5D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EF5D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF5D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF5D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF5D0);
		  /* 820EF5D0h */ case    0:  		/* addi R8, R8, 4 */
		/* 820EF5D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820EF5D0h case    0:*/		return 0x820EF5D4;
		  /* 820EF5D4h */ case    1:  		/* bc 16, CR0_LT, -84 */
		/* 820EF5D4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EF580;  }
		/* 820EF5D4h case    1:*/		return 0x820EF5D8;
	}
	return 0x820EF5D8;
} // Block from 820EF5D0h-820EF5D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EF5D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF5D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF5D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF5D8);
		  /* 820EF5D8h */ case    0:  		/* mr R24, R4 */
		/* 820EF5D8h case    0:*/		regs.R24 = regs.R4;
		/* 820EF5D8h case    0:*/		return 0x820EF5DC;
		  /* 820EF5DCh */ case    1:  		/* lwz R28, <#[R1 + 96]> */
		/* 820EF5DCh case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000060) );
		/* 820EF5DCh case    1:*/		return 0x820EF5E0;
		  /* 820EF5E0h */ case    2:  		/* mr R3, R22 */
		/* 820EF5E0h case    2:*/		regs.R3 = regs.R22;
		/* 820EF5E0h case    2:*/		return 0x820EF5E4;
		  /* 820EF5E4h */ case    3:  		/* cmplwi CR6, R23, 0 */
		/* 820EF5E4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820EF5E4h case    3:*/		return 0x820EF5E8;
		  /* 820EF5E8h */ case    4:  		/* bc 12, CR6_EQ, 2048 */
		/* 820EF5E8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820EFDE8;  }
		/* 820EF5E8h case    4:*/		return 0x820EF5EC;
		  /* 820EF5ECh */ case    5:  		/* addi R31, R1, 112 */
		/* 820EF5ECh case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x70);
		/* 820EF5ECh case    5:*/		return 0x820EF5F0;
		  /* 820EF5F0h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 820EF5F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820EF5F0h case    6:*/		return 0x820EF5F4;
		  /* 820EF5F4h */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 820EF5F4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EF5F4h case    7:*/		return 0x820EF5F8;
		  /* 820EF5F8h */ case    8:  		/* bc 12, CR6_EQ, 2324 */
		/* 820EF5F8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EFF0C;  }
		/* 820EF5F8h case    8:*/		return 0x820EF5FC;
		  /* 820EF5FCh */ case    9:  		/* lwz R10, <#[R26 + 24]> */
		/* 820EF5FCh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000018) );
		/* 820EF5FCh case    9:*/		return 0x820EF600;
		  /* 820EF600h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EF600h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EF600h case   10:*/		return 0x820EF604;
		  /* 820EF604h */ case   11:  		/* lis R9, 24576 */
		/* 820EF604h case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0x6000);
		/* 820EF604h case   11:*/		return 0x820EF608;
		  /* 820EF608h */ case   12:  		/* lwzx R6, <#[R11 + R10]> */
		/* 820EF608h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EF608h case   12:*/		return 0x820EF60C;
		  /* 820EF60Ch */ case   13:  		/* lwz R11, <#[R6]> */
		/* 820EF60Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 820EF60Ch case   13:*/		return 0x820EF610;
		  /* 820EF610h */ case   14:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 820EF610h case   14:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 820EF610h case   14:*/		return 0x820EF614;
		  /* 820EF614h */ case   15:  		/* cmplw CR6, R11, R9 */
		/* 820EF614h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820EF614h case   15:*/		return 0x820EF618;
		  /* 820EF618h */ case   16:  		/* bc 12, CR6_EQ, 2292 */
		/* 820EF618h case   16:*/		if ( regs.CR[6].eq ) { return 0x820EFF0C;  }
		/* 820EF618h case   16:*/		return 0x820EF61C;
		  /* 820EF61Ch */ case   17:  		/* lwz R10, <#[R6 + 12]> */
		/* 820EF61Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x0000000C) );
		/* 820EF61Ch case   17:*/		return 0x820EF620;
		  /* 820EF620h */ case   18:  		/* mr R4, R22 */
		/* 820EF620h case   18:*/		regs.R4 = regs.R22;
		/* 820EF620h case   18:*/		return 0x820EF624;
		  /* 820EF624h */ case   19:  		/* cmplwi CR6, R25, 0 */
		/* 820EF624h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820EF624h case   19:*/		return 0x820EF628;
		  /* 820EF628h */ case   20:  		/* bc 12, CR6_EQ, 72 */
		/* 820EF628h case   20:*/		if ( regs.CR[6].eq ) { return 0x820EF670;  }
		/* 820EF628h case   20:*/		return 0x820EF62C;
		  /* 820EF62Ch */ case   21:  		/* mr R9, R24 */
		/* 820EF62Ch case   21:*/		regs.R9 = regs.R24;
		/* 820EF62Ch case   21:*/		return 0x820EF630;
		  /* 820EF630h */ case   22:  		/* mr R5, R25 */
		/* 820EF630h case   22:*/		regs.R5 = regs.R25;
		/* 820EF630h case   22:*/		return 0x820EF634;
		  /* 820EF634h */ case   23:  		/* cmplwi CR6, R10, 0 */
		/* 820EF634h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820EF634h case   23:*/		return 0x820EF638;
		  /* 820EF638h */ case   24:  		/* bc 12, CR6_EQ, 44 */
		/* 820EF638h case   24:*/		if ( regs.CR[6].eq ) { return 0x820EF664;  }
		/* 820EF638h case   24:*/		return 0x820EF63C;
		  /* 820EF63Ch */ case   25:  		/* lwz R8, <#[R6 + 16]> */
		/* 820EF63Ch case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000010) );
		/* 820EF63Ch case   25:*/		return 0x820EF640;
		  /* 820EF640h */ case   26:  		/* mr R11, R22 */
		/* 820EF640h case   26:*/		regs.R11 = regs.R22;
		/* 820EF640h case   26:*/		return 0x820EF644;
		  /* 820EF644h */ case   27:  		/* lwz R7, <#[R9]> */
		/* 820EF644h case   27:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820EF644h case   27:*/		return 0x820EF648;
		  /* 820EF648h */ case   28:  		/* mtspr CTR, R10 */
		/* 820EF648h case   28:*/		regs.CTR = regs.R10;
		/* 820EF648h case   28:*/		return 0x820EF64C;
		  /* 820EF64Ch */ case   29:  		/* lwzx R30, <#[R11 + R8]> */
		/* 820EF64Ch case   29:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820EF64Ch case   29:*/		return 0x820EF650;
		  /* 820EF650h */ case   30:  		/* cmplw CR6, R30, R7 */
		/* 820EF650h case   30:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R7);
		/* 820EF650h case   30:*/		return 0x820EF654;
		  /* 820EF654h */ case   31:  		/* bc 4, CR6_EQ, 8 */
		/* 820EF654h case   31:*/		if ( !regs.CR[6].eq ) { return 0x820EF65C;  }
		/* 820EF654h case   31:*/		return 0x820EF658;
		  /* 820EF658h */ case   32:  		/* addi R4, R4, 1 */
		/* 820EF658h case   32:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820EF658h case   32:*/		return 0x820EF65C;
	}
	return 0x820EF65C;
} // Block from 820EF5D8h-820EF65Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 820EF65Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF65C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF65C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF65C);
		  /* 820EF65Ch */ case    0:  		/* addi R11, R11, 4 */
		/* 820EF65Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EF65Ch case    0:*/		return 0x820EF660;
		  /* 820EF660h */ case    1:  		/* bc 16, CR0_LT, -20 */
		/* 820EF660h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EF64C;  }
		/* 820EF660h case    1:*/		return 0x820EF664;
	}
	return 0x820EF664;
} // Block from 820EF65Ch-820EF664h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EF664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF664);
		  /* 820EF664h */ case    0:  		/* addic. R5, R5, -1 */
		/* 820EF664h case    0:*/		cpu::op::addic<1>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 820EF664h case    0:*/		return 0x820EF668;
		  /* 820EF668h */ case    1:  		/* addi R9, R9, 4 */
		/* 820EF668h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820EF668h case    1:*/		return 0x820EF66C;
		  /* 820EF66Ch */ case    2:  		/* bc 4, CR0_EQ, -56 */
		/* 820EF66Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820EF634;  }
		/* 820EF66Ch case    2:*/		return 0x820EF670;
	}
	return 0x820EF670;
} // Block from 820EF664h-820EF670h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EF670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF670);
		  /* 820EF670h */ case    0:  		/* cmplw CR6, R4, R10 */
		/* 820EF670h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 820EF670h case    0:*/		return 0x820EF674;
		  /* 820EF674h */ case    1:  		/* bc 4, CR6_EQ, 1904 */
		/* 820EF674h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EFDE4;  }
		/* 820EF674h case    1:*/		return 0x820EF678;
		  /* 820EF678h */ case    2:  		/* addi R3, R3, 1 */
		/* 820EF678h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820EF678h case    2:*/		return 0x820EF67C;
		  /* 820EF67Ch */ case    3:  		/* addi R31, R31, 4 */
		/* 820EF67Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820EF67Ch case    3:*/		return 0x820EF680;
		  /* 820EF680h */ case    4:  		/* cmplw CR6, R3, R23 */
		/* 820EF680h case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R23);
		/* 820EF680h case    4:*/		return 0x820EF684;
		  /* 820EF684h */ case    5:  		/* bc 12, CR6_LT, -148 */
		/* 820EF684h case    5:*/		if ( regs.CR[6].lt ) { return 0x820EF5F0;  }
		/* 820EF684h case    5:*/		return 0x820EF688;
		  /* 820EF688h */ case    6:  		/* b 1888 */
		/* 820EF688h case    6:*/		return 0x820EFDE8;
		/* 820EF688h case    6:*/		return 0x820EF68C;
	}
	return 0x820EF68C;
} // Block from 820EF670h-820EF68Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EF68Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF68C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF68C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF68C);
		  /* 820EF68Ch */ case    0:  		/* lwz R4, <#[R26 + 260]> */
		/* 820EF68Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000104) );
		/* 820EF68Ch case    0:*/		return 0x820EF690;
		  /* 820EF690h */ case    1:  		/* addi R5, R31, -160 */
		/* 820EF690h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0xFFFFFF60);
		/* 820EF690h case    1:*/		return 0x820EF694;
		  /* 820EF694h */ case    2:  		/* addi R9, R1, 112 */
		/* 820EF694h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820EF694h case    2:*/		return 0x820EF698;
		  /* 820EF698h */ case    3:  		/* stw R22, <#[R1 + 84]> */
		/* 820EF698h case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 820EF698h case    3:*/		return 0x820EF69C;
		  /* 820EF69Ch */ case    4:  		/* addi R8, R1, 208 */
		/* 820EF69Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xD0);
		/* 820EF69Ch case    4:*/		return 0x820EF6A0;
		  /* 820EF6A0h */ case    5:  		/* addi R7, R1, 96 */
		/* 820EF6A0h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820EF6A0h case    5:*/		return 0x820EF6A4;
		  /* 820EF6A4h */ case    6:  		/* addi R6, R1, 144 */
		/* 820EF6A4h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 820EF6A4h case    6:*/		return 0x820EF6A8;
		  /* 820EF6A8h */ case    7:  		/* lwz R11, <#[R4]> */
		/* 820EF6A8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820EF6A8h case    7:*/		return 0x820EF6AC;
		  /* 820EF6ACh */ case    8:  		/* mr R3, R26 */
		/* 820EF6ACh case    8:*/		regs.R3 = regs.R26;
		/* 820EF6ACh case    8:*/		return 0x820EF6B0;
		  /* 820EF6B0h */ case    9:  		/* mr R29, R21 */
		/* 820EF6B0h case    9:*/		regs.R29 = regs.R21;
		/* 820EF6B0h case    9:*/		return 0x820EF6B4;
		  /* 820EF6B4h */ case   10:  		/* rlwinm R25, R11, 0, 12, 31 */
		/* 820EF6B4h case   10:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R25,regs.R11);
		/* 820EF6B4h case   10:*/		return 0x820EF6B8;
		  /* 820EF6B8h */ case   11:  		/* mr R10, R25 */
		/* 820EF6B8h case   11:*/		regs.R10 = regs.R25;
		/* 820EF6B8h case   11:*/		return 0x820EF6BC;
		  /* 820EF6BCh */ case   12:  		/* bl -47676 */
		/* 820EF6BCh case   12:*/		regs.LR = 0x820EF6C0; return 0x820E3C80;
		/* 820EF6BCh case   12:*/		return 0x820EF6C0;
		  /* 820EF6C0h */ case   13:  		/* mr R30, R3 */
		/* 820EF6C0h case   13:*/		regs.R30 = regs.R3;
		/* 820EF6C0h case   13:*/		return 0x820EF6C4;
		  /* 820EF6C4h */ case   14:  		/* cmpwi CR6, R3, 1 */
		/* 820EF6C4h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 820EF6C4h case   14:*/		return 0x820EF6C8;
		  /* 820EF6C8h */ case   15:  		/* bc 4, CR6_EQ, 52 */
		/* 820EF6C8h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820EF6FC;  }
		/* 820EF6C8h case   15:*/		return 0x820EF6CC;
		  /* 820EF6CCh */ case   16:  		/* addi R5, R31, 192 */
		/* 820EF6CCh case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0xC0);
		/* 820EF6CCh case   16:*/		return 0x820EF6D0;
		  /* 820EF6D0h */ case   17:  		/* lwz R4, <#[R26 + 260]> */
		/* 820EF6D0h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000104) );
		/* 820EF6D0h case   17:*/		return 0x820EF6D4;
		  /* 820EF6D4h */ case   18:  		/* mr R10, R25 */
		/* 820EF6D4h case   18:*/		regs.R10 = regs.R25;
		/* 820EF6D4h case   18:*/		return 0x820EF6D8;
		  /* 820EF6D8h */ case   19:  		/* stw R22, <#[R1 + 84]> */
		/* 820EF6D8h case   19:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 820EF6D8h case   19:*/		return 0x820EF6DC;
		  /* 820EF6DCh */ case   20:  		/* addi R9, R1, 112 */
		/* 820EF6DCh case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820EF6DCh case   20:*/		return 0x820EF6E0;
		  /* 820EF6E0h */ case   21:  		/* addi R8, R1, 208 */
		/* 820EF6E0h case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xD0);
		/* 820EF6E0h case   21:*/		return 0x820EF6E4;
		  /* 820EF6E4h */ case   22:  		/* addi R7, R1, 96 */
		/* 820EF6E4h case   22:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820EF6E4h case   22:*/		return 0x820EF6E8;
		  /* 820EF6E8h */ case   23:  		/* addi R6, R1, 144 */
		/* 820EF6E8h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 820EF6E8h case   23:*/		return 0x820EF6EC;
		  /* 820EF6ECh */ case   24:  		/* mr R3, R26 */
		/* 820EF6ECh case   24:*/		regs.R3 = regs.R26;
		/* 820EF6ECh case   24:*/		return 0x820EF6F0;
		  /* 820EF6F0h */ case   25:  		/* bl -47728 */
		/* 820EF6F0h case   25:*/		regs.LR = 0x820EF6F4; return 0x820E3C80;
		/* 820EF6F0h case   25:*/		return 0x820EF6F4;
		  /* 820EF6F4h */ case   26:  		/* mr R30, R3 */
		/* 820EF6F4h case   26:*/		regs.R30 = regs.R3;
		/* 820EF6F4h case   26:*/		return 0x820EF6F8;
		  /* 820EF6F8h */ case   27:  		/* mr R29, R22 */
		/* 820EF6F8h case   27:*/		regs.R29 = regs.R22;
		/* 820EF6F8h case   27:*/		return 0x820EF6FC;
	}
	return 0x820EF6FC;
} // Block from 820EF68Ch-820EF6FCh (28 instructions)

//////////////////////////////////////////////////////
// Block at 820EF6FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF6FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF6FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF6FC);
		  /* 820EF6FCh */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 820EF6FCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820EF6FCh case    0:*/		return 0x820EF700;
		  /* 820EF700h */ case    1:  		/* bc 4, CR6_EQ, 412 */
		/* 820EF700h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EF89C;  }
		/* 820EF700h case    1:*/		return 0x820EF704;
		  /* 820EF704h */ case    2:  		/* mr R31, R22 */
		/* 820EF704h case    2:*/		regs.R31 = regs.R22;
		/* 820EF704h case    2:*/		return 0x820EF708;
		  /* 820EF708h */ case    3:  		/* cmplwi CR6, R25, 0 */
		/* 820EF708h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820EF708h case    3:*/		return 0x820EF70C;
		  /* 820EF70Ch */ case    4:  		/* bc 12, CR6_EQ, 392 */
		/* 820EF70Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820EF894;  }
		/* 820EF70Ch case    4:*/		return 0x820EF710;
		  /* 820EF710h */ case    5:  		/* addi R11, R1, 112 */
		/* 820EF710h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820EF710h case    5:*/		return 0x820EF714;
		  /* 820EF714h */ case    6:  		/* lwz R4, <#[R26 + 20]> */
		/* 820EF714h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000014) );
		/* 820EF714h case    6:*/		return 0x820EF718;
		  /* 820EF718h */ case    7:  		/* lis R10, -32256 */
		/* 820EF718h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820EF718h case    7:*/		return 0x820EF71C;
		  /* 820EF71Ch */ case    8:  		/* addi R3, R11, -4 */
		/* 820EF71Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 820EF71Ch case    8:*/		return 0x820EF720;
		  /* 820EF720h */ case    9:  		/* lis R11, -32256 */
		/* 820EF720h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820EF720h case    9:*/		return 0x820EF724;
		  /* 820EF724h */ case   10:  		/* addi R7, R1, 224 */
		/* 820EF724h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xE0);
		/* 820EF724h case   10:*/		return 0x820EF728;
		  /* 820EF728h */ case   11:  		/* lfd FR0, <#[R10 + 1848]> */
		/* 820EF728h case   11:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000738) );
		/* 820EF728h case   11:*/		return 0x820EF72C;
		  /* 820EF72Ch */ case   12:  		/* lfd FR13, <#[R11 + 1808]> */
		/* 820EF72Ch case   12:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000710) );
		/* 820EF72Ch case   12:*/		return 0x820EF730;
		  /* 820EF730h */ case   13:  		/* lwz R11, <#[R7 - 16]> */
		/* 820EF730h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0xFFFFFFF0) );
		/* 820EF730h case   13:*/		return 0x820EF734;
		  /* 820EF734h */ case   14:  		/* lwz R10, <#[R7]> */
		/* 820EF734h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 820EF734h case   14:*/		return 0x820EF738;
		  /* 820EF738h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EF738h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EF738h case   15:*/		return 0x820EF73C;
		  /* 820EF73Ch */ case   16:  		/* lwz R6, <#[R7 + 16]> */
		/* 820EF73Ch case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R7 + 0x00000010) );
		/* 820EF73Ch case   16:*/		return 0x820EF740;
		  /* 820EF740h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EF740h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EF740h case   17:*/		return 0x820EF744;
		  /* 820EF744h */ case   18:  		/* lwz R9, <#[R7 + 64]> */
		/* 820EF744h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000040) );
		/* 820EF744h case   18:*/		return 0x820EF748;
		  /* 820EF748h */ case   19:  		/* cmplw CR6, R6, R9 */
		/* 820EF748h case   19:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R9);
		/* 820EF748h case   19:*/		return 0x820EF74C;
		  /* 820EF74Ch */ case   20:  		/* lwzx R8, <#[R11 + R4]> */
		/* 820EF74Ch case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 820EF74Ch case   20:*/		return 0x820EF750;
		  /* 820EF750h */ case   21:  		/* lwzx R5, <#[R10 + R4]> */
		/* 820EF750h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 820EF750h case   21:*/		return 0x820EF754;
		  /* 820EF754h */ case   22:  		/* bc 4, CR6_EQ, -504 */
		/* 820EF754h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EF754h case   22:*/		return 0x820EF758;
		  /* 820EF758h */ case   23:  		/* lwz R10, <#[R7 + 32]> */
		/* 820EF758h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000020) );
		/* 820EF758h case   23:*/		return 0x820EF75C;
		  /* 820EF75Ch */ case   24:  		/* lwz R11, <#[R7 + 80]> */
		/* 820EF75Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000050) );
		/* 820EF75Ch case   24:*/		return 0x820EF760;
		  /* 820EF760h */ case   25:  		/* cmplw CR6, R10, R11 */
		/* 820EF760h case   25:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820EF760h case   25:*/		return 0x820EF764;
		  /* 820EF764h */ case   26:  		/* bc 4, CR6_EQ, -520 */
		/* 820EF764h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EF764h case   26:*/		return 0x820EF768;
		  /* 820EF768h */ case   27:  		/* lwz R11, <#[R7 + 48]> */
		/* 820EF768h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000030) );
		/* 820EF768h case   27:*/		return 0x820EF76C;
		  /* 820EF76Ch */ case   28:  		/* lwz R9, <#[R7 + 96]> */
		/* 820EF76Ch case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000060) );
		/* 820EF76Ch case   28:*/		return 0x820EF770;
		  /* 820EF770h */ case   29:  		/* cmplw CR6, R11, R9 */
		/* 820EF770h case   29:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820EF770h case   29:*/		return 0x820EF774;
		  /* 820EF774h */ case   30:  		/* bc 4, CR6_EQ, -536 */
		/* 820EF774h case   30:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EF774h case   30:*/		return 0x820EF778;
		  /* 820EF778h */ case   31:  		/* cmplw CR6, R6, R10 */
		/* 820EF778h case   31:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 820EF778h case   31:*/		return 0x820EF77C;
		  /* 820EF77Ch */ case   32:  		/* bc 4, CR6_EQ, -544 */
		/* 820EF77Ch case   32:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EF77Ch case   32:*/		return 0x820EF780;
		  /* 820EF780h */ case   33:  		/* lwz R10, <#[R8 + 4]> */
		/* 820EF780h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 820EF780h case   33:*/		return 0x820EF784;
		  /* 820EF784h */ case   34:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 820EF784h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 820EF784h case   34:*/		return 0x820EF788;
	}
	return 0x820EF788;
} // Block from 820EF6FCh-820EF788h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820EF788h
// Function '?PortConstraints@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF788);
		  /* 820EF788h */ case    0:  		/* lwz R11, <#[R26 + 16]> */
		/* 820EF788h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820EF788h case    0:*/		return 0x820EF78C;
		  /* 820EF78Ch */ case    1:  		/* rlwinm R30, R10, 2, 0, 29 */
		/* 820EF78Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R10);
		/* 820EF78Ch case    1:*/		return 0x820EF790;
		  /* 820EF790h */ case    2:  		/* lwz R10, <#[R26 + 20]> */
		/* 820EF790h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 820EF790h case    2:*/		return 0x820EF794;
		  /* 820EF794h */ case    3:  		/* lwzx R30, <#[R30 + R11]> */
		/* 820EF794h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820EF794h case    3:*/		return 0x820EF798;
		  /* 820EF798h */ case    4:  		/* lwzx R9, <#[R9 + R10]> */
		/* 820EF798h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820EF798h case    4:*/		return 0x820EF79C;
		  /* 820EF79Ch */ case    5:  		/* lwz R30, <#[R30 + 4]> */
		/* 820EF79Ch case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 820EF79Ch case    5:*/		return 0x820EF7A0;
		  /* 820EF7A0h */ case    6:  		/* rlwinm. R30, R30, 0, 23, 23 */
		/* 820EF7A0h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R30,regs.R30);
		/* 820EF7A0h case    6:*/		return 0x820EF7A4;
		  /* 820EF7A4h */ case    7:  		/* bc 12, CR0_EQ, -584 */
		/* 820EF7A4h case    7:*/		if ( regs.CR[0].eq ) { return 0x820EF55C;  }
		/* 820EF7A4h case    7:*/		return 0x820EF7A8;
		  /* 820EF7A8h */ case    8:  		/* lwz R30, <#[R5 + 4]> */
		/* 820EF7A8h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R5 + 0x00000004) );
		/* 820EF7A8h case    8:*/		return 0x820EF7AC;
		  /* 820EF7ACh */ case    9:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820EF7ACh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820EF7ACh case    9:*/		return 0x820EF7B0;
		  /* 820EF7B0h */ case   10:  		/* lwzx R30, <#[R30 + R11]> */
		/* 820EF7B0h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820EF7B0h case   10:*/		return 0x820EF7B4;
		  /* 820EF7B4h */ case   11:  		/* lwz R30, <#[R30 + 4]> */
		/* 820EF7B4h case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 820EF7B4h case   11:*/		return 0x820EF7B8;
		  /* 820EF7B8h */ case   12:  		/* rlwinm. R30, R30, 0, 23, 23 */
		/* 820EF7B8h case   12:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R30,regs.R30);
		/* 820EF7B8h case   12:*/		return 0x820EF7BC;
		  /* 820EF7BCh */ case   13:  		/* bc 12, CR0_EQ, -608 */
		/* 820EF7BCh case   13:*/		if ( regs.CR[0].eq ) { return 0x820EF55C;  }
		/* 820EF7BCh case   13:*/		return 0x820EF7C0;
		  /* 820EF7C0h */ case   14:  		/* lwz R30, <#[R9 + 4]> */
		/* 820EF7C0h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000004) );
		/* 820EF7C0h case   14:*/		return 0x820EF7C4;
		  /* 820EF7C4h */ case   15:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820EF7C4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820EF7C4h case   15:*/		return 0x820EF7C8;
		  /* 820EF7C8h */ case   16:  		/* lwzx R11, <#[R30 + R11]> */
		/* 820EF7C8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820EF7C8h case   16:*/		return 0x820EF7CC;
		  /* 820EF7CCh */ case   17:  		/* lwz R11, <#[R11 + 4]> */
		/* 820EF7CCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820EF7CCh case   17:*/		return 0x820EF7D0;
		  /* 820EF7D0h */ case   18:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820EF7D0h case   18:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820EF7D0h case   18:*/		return 0x820EF7D4;
		  /* 820EF7D4h */ case   19:  		/* bc 12, CR0_EQ, -632 */
		/* 820EF7D4h case   19:*/		if ( regs.CR[0].eq ) { return 0x820EF55C;  }
		/* 820EF7D4h case   19:*/		return 0x820EF7D8;
		  /* 820EF7D8h */ case   20:  		/* lfd FR12, <#[R8 + 32]> */
		/* 820EF7D8h case   20:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R8 + 0x00000020) );
		/* 820EF7D8h case   20:*/		return 0x820EF7DC;
		  /* 820EF7DCh */ case   21:  		/* fcmpu CR6, FR12, FR0 */
		/* 820EF7DCh case   21:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 820EF7DCh case   21:*/		return 0x820EF7E0;
		  /* 820EF7E0h */ case   22:  		/* bc 4, CR6_EQ, -644 */
		/* 820EF7E0h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EF7E0h case   22:*/		return 0x820EF7E4;
		  /* 820EF7E4h */ case   23:  		/* subfic R11, R29, 0 */
		/* 820EF7E4h case   23:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R29,0x0);
		/* 820EF7E4h case   23:*/		return 0x820EF7E8;
		  /* 820EF7E8h */ case   24:  		/* lfd FR12, <#[R5 + 32]> */
		/* 820EF7E8h case   24:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R5 + 0x00000020) );
		/* 820EF7E8h case   24:*/		return 0x820EF7EC;
		  /* 820EF7ECh */ case   25:  		/* subfe R11, R11, R11 */
		/* 820EF7ECh case   25:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820EF7ECh case   25:*/		return 0x820EF7F0;
		  /* 820EF7F0h */ case   26:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 820EF7F0h case   26:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 820EF7F0h case   26:*/		return 0x820EF7F4;
		  /* 820EF7F4h */ case   27:  		/* addi R11, R11, 1 */
		/* 820EF7F4h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EF7F4h case   27:*/		return 0x820EF7F8;
		  /* 820EF7F8h */ case   28:  		/* extsw R11, R11 */
		/* 820EF7F8h case   28:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 820EF7F8h case   28:*/		return 0x820EF7FC;
		  /* 820EF7FCh */ case   29:  		/* std R11, <#[R1 + 128]> */
		/* 820EF7FCh case   29:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820EF7FCh case   29:*/		return 0x820EF800;
		  /* 820EF800h */ case   30:  		/* lfd FR11, <#[R1 + 128]> */
		/* 820EF800h case   30:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000080) );
		/* 820EF800h case   30:*/		return 0x820EF804;
		  /* 820EF804h */ case   31:  		/* fcfid FR11, FR11 */
		/* 820EF804h case   31:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 820EF804h case   31:*/		return 0x820EF808;
		  /* 820EF808h */ case   32:  		/* fcmpu CR6, FR12, FR11 */
		/* 820EF808h case   32:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR11);
		/* 820EF808h case   32:*/		return 0x820EF80C;
		  /* 820EF80Ch */ case   33:  		/* bc 4, CR6_EQ, -688 */
		/* 820EF80Ch case   33:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EF80Ch case   33:*/		return 0x820EF810;
		  /* 820EF810h */ case   34:  		/* lfd FR12, <#[R9 + 32]> */
		/* 820EF810h case   34:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R9 + 0x00000020) );
		/* 820EF810h case   34:*/		return 0x820EF814;
		  /* 820EF814h */ case   35:  		/* fcmpu CR6, FR12, FR13 */
		/* 820EF814h case   35:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR13);
		/* 820EF814h case   35:*/		return 0x820EF818;
		  /* 820EF818h */ case   36:  		/* bc 4, CR6_EQ, -700 */
		/* 820EF818h case   36:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EF818h case   36:*/		return 0x820EF81C;
		  /* 820EF81Ch */ case   37:  		/* rlwinm R11, R6, 2, 0, 29 */
		/* 820EF81Ch case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R6);
		/* 820EF81Ch case   37:*/		return 0x820EF820;
		  /* 820EF820h */ case   38:  		/* lwz R9, <#[R26 + 136]> */
		/* 820EF820h case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000088) );
		/* 820EF820h case   38:*/		return 0x820EF824;
		  /* 820EF824h */ case   39:  		/* lwzx R8, <#[R11 + R10]> */
		/* 820EF824h case   39:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EF824h case   39:*/		return 0x820EF828;
		  /* 820EF828h */ case   40:  		/* lwz R11, <#[R8 + 4]> */
		/* 820EF828h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 820EF828h case   40:*/		return 0x820EF82C;
		  /* 820EF82Ch */ case   41:  		/* cmplw CR6, R11, R9 */
		/* 820EF82Ch case   41:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820EF82Ch case   41:*/		return 0x820EF830;
		  /* 820EF830h */ case   42:  		/* bc 12, CR6_EQ, 8 */
		/* 820EF830h case   42:*/		if ( regs.CR[6].eq ) { return 0x820EF838;  }
		/* 820EF830h case   42:*/		return 0x820EF834;
		  /* 820EF834h */ case   43:  		/* mr R20, R21 */
		/* 820EF834h case   43:*/		regs.R20 = regs.R21;
		/* 820EF834h case   43:*/		return 0x820EF838;
	}
	return 0x820EF838;
} // Block from 820EF788h-820EF838h (44 instructions)

//////////////////////////////////////////////////////
// Block at 820EF838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF838);
		  /* 820EF838h */ case    0:  		/* mr R10, R22 */
		/* 820EF838h case    0:*/		regs.R10 = regs.R22;
		/* 820EF838h case    0:*/		return 0x820EF83C;
		  /* 820EF83Ch */ case    1:  		/* cmplwi CR6, R23, 0 */
		/* 820EF83Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820EF83Ch case    1:*/		return 0x820EF840;
		  /* 820EF840h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820EF840h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EF868;  }
		/* 820EF840h case    2:*/		return 0x820EF844;
		  /* 820EF844h */ case    3:  		/* lwz R9, <#[R8 + 72]> */
		/* 820EF844h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000048) );
		/* 820EF844h case    3:*/		return 0x820EF848;
		  /* 820EF848h */ case    4:  		/* addi R11, R1, 112 */
		/* 820EF848h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820EF848h case    4:*/		return 0x820EF84C;
		  /* 820EF84Ch */ case    5:  		/* lwz R6, <#[R11]> */
		/* 820EF84Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820EF84Ch case    5:*/		return 0x820EF850;
		  /* 820EF850h */ case    6:  		/* cmplw CR6, R9, R6 */
		/* 820EF850h case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 820EF850h case    6:*/		return 0x820EF854;
		  /* 820EF854h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820EF854h case    7:*/		if ( regs.CR[6].eq ) { return 0x820EF868;  }
		/* 820EF854h case    7:*/		return 0x820EF858;
		  /* 820EF858h */ case    8:  		/* addi R10, R10, 1 */
		/* 820EF858h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EF858h case    8:*/		return 0x820EF85C;
		  /* 820EF85Ch */ case    9:  		/* addi R11, R11, 4 */
		/* 820EF85Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EF85Ch case    9:*/		return 0x820EF860;
		  /* 820EF860h */ case   10:  		/* cmplw CR6, R10, R23 */
		/* 820EF860h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R23);
		/* 820EF860h case   10:*/		return 0x820EF864;
		  /* 820EF864h */ case   11:  		/* bc 12, CR6_LT, -24 */
		/* 820EF864h case   11:*/		if ( regs.CR[6].lt ) { return 0x820EF84C;  }
		/* 820EF864h case   11:*/		return 0x820EF868;
	}
	return 0x820EF868;
} // Block from 820EF838h-820EF868h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820EF868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF868);
		  /* 820EF868h */ case    0:  		/* cmplw CR6, R10, R23 */
		/* 820EF868h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R23);
		/* 820EF868h case    0:*/		return 0x820EF86C;
		  /* 820EF86Ch */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 820EF86Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EF884;  }
		/* 820EF86Ch case    1:*/		return 0x820EF870;
		  /* 820EF870h */ case    2:  		/* cmpwi CR6, R20, 0 */
		/* 820EF870h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 820EF870h case    2:*/		return 0x820EF874;
		  /* 820EF874h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820EF874h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820EF884;  }
		/* 820EF874h case    3:*/		return 0x820EF878;
		  /* 820EF878h */ case    4:  		/* lwz R11, <#[R8 + 72]> */
		/* 820EF878h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000048) );
		/* 820EF878h case    4:*/		return 0x820EF87C;
		  /* 820EF87Ch */ case    5:  		/* addi R23, R23, 1 */
		/* 820EF87Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 820EF87Ch case    5:*/		return 0x820EF880;
		  /* 820EF880h */ case    6:  		/* stwu R11, <#[R3 + 4]> */
		/* 820EF880h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820EF880h case    6:*/		return 0x820EF884;
	}
	return 0x820EF884;
} // Block from 820EF868h-820EF884h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EF884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF884);
		  /* 820EF884h */ case    0:  		/* addi R31, R31, 1 */
		/* 820EF884h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820EF884h case    0:*/		return 0x820EF888;
		  /* 820EF888h */ case    1:  		/* addi R7, R7, 4 */
		/* 820EF888h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820EF888h case    1:*/		return 0x820EF88C;
		  /* 820EF88Ch */ case    2:  		/* cmplw CR6, R31, R25 */
		/* 820EF88Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R25);
		/* 820EF88Ch case    2:*/		return 0x820EF890;
		  /* 820EF890h */ case    3:  		/* bc 12, CR6_LT, -352 */
		/* 820EF890h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EF730;  }
		/* 820EF890h case    3:*/		return 0x820EF894;
	}
	return 0x820EF894;
} // Block from 820EF884h-820EF894h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EF894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF894);
		  /* 820EF894h */ case    0:  		/* addi R24, R1, 240 */
		/* 820EF894h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R1,0xF0);
		/* 820EF894h case    0:*/		return 0x820EF898;
		  /* 820EF898h */ case    1:  		/* b -700 */
		/* 820EF898h case    1:*/		return 0x820EF5DC;
		/* 820EF898h case    1:*/		return 0x820EF89C;
	}
	return 0x820EF89C;
} // Block from 820EF894h-820EF89Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EF89Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF89C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF89C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF89C);
		  /* 820EF89Ch */ case    0:  		/* cmpwi CR6, R30, 1 */
		/* 820EF89Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000001);
		/* 820EF89Ch case    0:*/		return 0x820EF8A0;
		  /* 820EF8A0h */ case    1:  		/* bc 4, CR6_EQ, 1328 */
		/* 820EF8A0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EFDD0;  }
		/* 820EF8A0h case    1:*/		return 0x820EF8A4;
		  /* 820EF8A4h */ case    2:  		/* mr R5, R31 */
		/* 820EF8A4h case    2:*/		regs.R5 = regs.R31;
		/* 820EF8A4h case    2:*/		return 0x820EF8A8;
		  /* 820EF8A8h */ case    3:  		/* lwz R4, <#[R26 + 260]> */
		/* 820EF8A8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000104) );
		/* 820EF8A8h case    3:*/		return 0x820EF8AC;
		  /* 820EF8ACh */ case    4:  		/* mr R10, R25 */
		/* 820EF8ACh case    4:*/		regs.R10 = regs.R25;
		/* 820EF8ACh case    4:*/		return 0x820EF8B0;
		  /* 820EF8B0h */ case    5:  		/* stw R22, <#[R1 + 84]> */
		/* 820EF8B0h case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 820EF8B0h case    5:*/		return 0x820EF8B4;
		  /* 820EF8B4h */ case    6:  		/* addi R9, R1, 112 */
		/* 820EF8B4h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820EF8B4h case    6:*/		return 0x820EF8B8;
		  /* 820EF8B8h */ case    7:  		/* addi R8, R1, 208 */
		/* 820EF8B8h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xD0);
		/* 820EF8B8h case    7:*/		return 0x820EF8BC;
		  /* 820EF8BCh */ case    8:  		/* addi R7, R1, 96 */
		/* 820EF8BCh case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820EF8BCh case    8:*/		return 0x820EF8C0;
		  /* 820EF8C0h */ case    9:  		/* addi R6, R1, 144 */
		/* 820EF8C0h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 820EF8C0h case    9:*/		return 0x820EF8C4;
		  /* 820EF8C4h */ case   10:  		/* mr R3, R26 */
		/* 820EF8C4h case   10:*/		regs.R3 = regs.R26;
		/* 820EF8C4h case   10:*/		return 0x820EF8C8;
		  /* 820EF8C8h */ case   11:  		/* bl -48200 */
		/* 820EF8C8h case   11:*/		regs.LR = 0x820EF8CC; return 0x820E3C80;
		/* 820EF8C8h case   11:*/		return 0x820EF8CC;
		  /* 820EF8CCh */ case   12:  		/* or. R30, R3, R3 */
		/* 820EF8CCh case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820EF8CCh case   12:*/		return 0x820EF8D0;
		  /* 820EF8D0h */ case   13:  		/* bc 4, CR0_EQ, 688 */
		/* 820EF8D0h case   13:*/		if ( !regs.CR[0].eq ) { return 0x820EFB80;  }
		/* 820EF8D0h case   13:*/		return 0x820EF8D4;
		  /* 820EF8D4h */ case   14:  		/* mr R27, R22 */
		/* 820EF8D4h case   14:*/		regs.R27 = regs.R22;
		/* 820EF8D4h case   14:*/		return 0x820EF8D8;
		  /* 820EF8D8h */ case   15:  		/* cmplwi CR6, R25, 0 */
		/* 820EF8D8h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820EF8D8h case   15:*/		return 0x820EF8DC;
		  /* 820EF8DCh */ case   16:  		/* bc 12, CR6_EQ, -768 */
		/* 820EF8DCh case   16:*/		if ( regs.CR[6].eq ) { return 0x820EF5DC;  }
		/* 820EF8DCh case   16:*/		return 0x820EF8E0;
		  /* 820EF8E0h */ case   17:  		/* addi R11, R1, 112 */
		/* 820EF8E0h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820EF8E0h case   17:*/		return 0x820EF8E4;
		  /* 820EF8E4h */ case   18:  		/* lis R10, -32256 */
		/* 820EF8E4h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820EF8E4h case   18:*/		return 0x820EF8E8;
		  /* 820EF8E8h */ case   19:  		/* addi R28, R11, -4 */
		/* 820EF8E8h case   19:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFFFFC);
		/* 820EF8E8h case   19:*/		return 0x820EF8EC;
		  /* 820EF8ECh */ case   20:  		/* lis R11, -32255 */
		/* 820EF8ECh case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820EF8ECh case   20:*/		return 0x820EF8F0;
		  /* 820EF8F0h */ case   21:  		/* lis R9, -32256 */
		/* 820EF8F0h case   21:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 820EF8F0h case   21:*/		return 0x820EF8F4;
		  /* 820EF8F4h */ case   22:  		/* mr R29, R22 */
		/* 820EF8F4h case   22:*/		regs.R29 = regs.R22;
		/* 820EF8F4h case   22:*/		return 0x820EF8F8;
		  /* 820EF8F8h */ case   23:  		/* lfd FR12, <#[R10 + 1808]> */
		/* 820EF8F8h case   23:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R10 + 0x00000710) );
		/* 820EF8F8h case   23:*/		return 0x820EF8FC;
		  /* 820EF8FCh */ case   24:  		/* lfd FR13, <#[R11 - 24488]> */
		/* 820EF8FCh case   24:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0xFFFFA058) );
		/* 820EF8FCh case   24:*/		return 0x820EF900;
		  /* 820EF900h */ case   25:  		/* lfd FR0, <#[R9 + 1848]> */
		/* 820EF900h case   25:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000738) );
		/* 820EF900h case   25:*/		return 0x820EF904;
		  /* 820EF904h */ case   26:  		/* addi R11, R1, 272 */
		/* 820EF904h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x110);
		/* 820EF904h case   26:*/		return 0x820EF908;
		  /* 820EF908h */ case   27:  		/* mr R5, R22 */
		/* 820EF908h case   27:*/		regs.R5 = regs.R22;
		/* 820EF908h case   27:*/		return 0x820EF90C;
		  /* 820EF90Ch */ case   28:  		/* add R4, R11, R29 */
		/* 820EF90Ch case   28:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R29);
		/* 820EF90Ch case   28:*/		return 0x820EF910;
		  /* 820EF910h */ case   29:  		/* lwz R31, <#[R4 - 48]> */
		/* 820EF910h case   29:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0xFFFFFFD0) );
		/* 820EF910h case   29:*/		return 0x820EF914;
		  /* 820EF914h */ case   30:  		/* lwz R11, <#[R4 - 16]> */
		/* 820EF914h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0xFFFFFFF0) );
		/* 820EF914h case   30:*/		return 0x820EF918;
		  /* 820EF918h */ case   31:  		/* cmplw CR6, R31, R11 */
		/* 820EF918h case   31:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820EF918h case   31:*/		return 0x820EF91C;
		  /* 820EF91Ch */ case   32:  		/* bc 4, CR6_EQ, -960 */
		/* 820EF91Ch case   32:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EF91Ch case   32:*/		return 0x820EF920;
		  /* 820EF920h */ case   33:  		/* lwz R30, <#[R4 - 32]> */
		/* 820EF920h case   33:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0xFFFFFFE0) );
		/* 820EF920h case   33:*/		return 0x820EF924;
		  /* 820EF924h */ case   34:  		/* lwz R11, <#[R4]> */
		/* 820EF924h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820EF924h case   34:*/		return 0x820EF928;
		  /* 820EF928h */ case   35:  		/* cmplw CR6, R30, R11 */
		/* 820EF928h case   35:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820EF928h case   35:*/		return 0x820EF92C;
		  /* 820EF92Ch */ case   36:  		/* bc 4, CR6_EQ, -976 */
		/* 820EF92Ch case   36:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EF92Ch case   36:*/		return 0x820EF930;
		  /* 820EF930h */ case   37:  		/* lwz R11, <#[R4 + 16]> */
		/* 820EF930h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 820EF930h case   37:*/		return 0x820EF934;
		  /* 820EF934h */ case   38:  		/* lwz R10, <#[R4 + 48]> */
		/* 820EF934h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000030) );
		/* 820EF934h case   38:*/		return 0x820EF938;
		  /* 820EF938h */ case   39:  		/* cmplw CR6, R11, R10 */
		/* 820EF938h case   39:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820EF938h case   39:*/		return 0x820EF93C;
		  /* 820EF93Ch */ case   40:  		/* bc 4, CR6_EQ, -992 */
		/* 820EF93Ch case   40:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EF93Ch case   40:*/		return 0x820EF940;
		  /* 820EF940h */ case   41:  		/* lwz R10, <#[R4 + 32]> */
		/* 820EF940h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000020) );
		/* 820EF940h case   41:*/		return 0x820EF944;
		  /* 820EF944h */ case   42:  		/* lwz R9, <#[R4 + 64]> */
		/* 820EF944h case   42:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000040) );
		/* 820EF944h case   42:*/		return 0x820EF948;
		  /* 820EF948h */ case   43:  		/* cmplw CR6, R10, R9 */
		/* 820EF948h case   43:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820EF948h case   43:*/		return 0x820EF94C;
		  /* 820EF94Ch */ case   44:  		/* bc 4, CR6_EQ, -1008 */
		/* 820EF94Ch case   44:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EF94Ch case   44:*/		return 0x820EF950;
		  /* 820EF950h */ case   45:  		/* lwz R8, <#[R26 + 20]> */
		/* 820EF950h case   45:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 820EF950h case   45:*/		return 0x820EF954;
		  /* 820EF954h */ case   46:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 820EF954h case   46:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 820EF954h case   46:*/		return 0x820EF958;
		  /* 820EF958h */ case   47:  		/* rlwinm R6, R10, 2, 0, 29 */
		/* 820EF958h case   47:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R10);
		/* 820EF958h case   47:*/		return 0x820EF95C;
		  /* 820EF95Ch */ case   48:  		/* lwz R24, <#[R26 + 16]> */
		/* 820EF95Ch case   48:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R26 + 0x00000010) );
		/* 820EF95Ch case   48:*/		return 0x820EF960;
		  /* 820EF960h */ case   49:  		/* cmplw CR6, R11, R30 */
		/* 820EF960h case   49:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820EF960h case   49:*/		return 0x820EF964;
		  /* 820EF964h */ case   50:  		/* mr R7, R22 */
		/* 820EF964h case   50:*/		regs.R7 = regs.R22;
		/* 820EF964h case   50:*/		return 0x820EF968;
		  /* 820EF968h */ case   51:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820EF968h case   51:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820EF968h case   51:*/		return 0x820EF96C;
		  /* 820EF96Ch */ case   52:  		/* lwzx R8, <#[R6 + R8]> */
		/* 820EF96Ch case   52:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820EF96Ch case   52:*/		return 0x820EF970;
		  /* 820EF970h */ case   53:  		/* lwz R11, <#[R9 + 4]> */
		/* 820EF970h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 820EF970h case   53:*/		return 0x820EF974;
		  /* 820EF974h */ case   54:  		/* lwz R6, <#[R8 + 4]> */
		/* 820EF974h case   54:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000004) );
		/* 820EF974h case   54:*/		return 0x820EF978;
		  /* 820EF978h */ case   55:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EF978h case   55:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EF978h case   55:*/		return 0x820EF97C;
		  /* 820EF97Ch */ case   56:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820EF97Ch case   56:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820EF97Ch case   56:*/		return 0x820EF980;
		  /* 820EF980h */ case   57:  		/* lwzx R3, <#[R11 + R24]> */
		/* 820EF980h case   57:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 820EF980h case   57:*/		return 0x820EF984;
		  /* 820EF984h */ case   58:  		/* lwzx R6, <#[R6 + R24]> */
		/* 820EF984h case   58:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R24 + 0x00000000) );
		/* 820EF984h case   58:*/		return 0x820EF988;
		  /* 820EF988h */ case   59:  		/* bc 4, CR6_EQ, 28 */
		/* 820EF988h case   59:*/		if ( !regs.CR[6].eq ) { return 0x820EF9A4;  }
		/* 820EF988h case   59:*/		return 0x820EF98C;
		  /* 820EF98Ch */ case   60:  		/* lwz R11, <#[R6 + 4]> */
		/* 820EF98Ch case   60:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 820EF98Ch case   60:*/		return 0x820EF990;
		  /* 820EF990h */ case   61:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820EF990h case   61:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820EF990h case   61:*/		return 0x820EF994;
		  /* 820EF994h */ case   62:  		/* bc 12, CR0_EQ, 16 */
		/* 820EF994h case   62:*/		if ( regs.CR[0].eq ) { return 0x820EF9A4;  }
		/* 820EF994h case   62:*/		return 0x820EF998;
		  /* 820EF998h */ case   63:  		/* lfd FR11, <#[R8 + 32]> */
		/* 820EF998h case   63:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R8 + 0x00000020) );
		/* 820EF998h case   63:*/		return 0x820EF99C;
		  /* 820EF99Ch */ case   64:  		/* fcmpu CR6, FR11, FR13 */
		/* 820EF99Ch case   64:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR13);
		/* 820EF99Ch case   64:*/		return 0x820EF9A0;
		  /* 820EF9A0h */ case   65:  		/* bc 12, CR6_EQ, 36 */
		/* 820EF9A0h case   65:*/		if ( regs.CR[6].eq ) { return 0x820EF9C4;  }
		/* 820EF9A0h case   65:*/		return 0x820EF9A4;
	}
	return 0x820EF9A4;
} // Block from 820EF89Ch-820EF9A4h (66 instructions)

//////////////////////////////////////////////////////
// Block at 820EF9A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF9A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF9A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF9A4);
		  /* 820EF9A4h */ case    0:  		/* cmplw CR6, R10, R30 */
		/* 820EF9A4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 820EF9A4h case    0:*/		return 0x820EF9A8;
		  /* 820EF9A8h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 820EF9A8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EF9C8;  }
		/* 820EF9A8h case    1:*/		return 0x820EF9AC;
		  /* 820EF9ACh */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 820EF9ACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820EF9ACh case    2:*/		return 0x820EF9B0;
		  /* 820EF9B0h */ case    3:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820EF9B0h case    3:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820EF9B0h case    3:*/		return 0x820EF9B4;
		  /* 820EF9B4h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 820EF9B4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820EF9C8;  }
		/* 820EF9B4h case    4:*/		return 0x820EF9B8;
		  /* 820EF9B8h */ case    5:  		/* lfd FR11, <#[R9 + 32]> */
		/* 820EF9B8h case    5:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R9 + 0x00000020) );
		/* 820EF9B8h case    5:*/		return 0x820EF9BC;
		  /* 820EF9BCh */ case    6:  		/* fcmpu CR6, FR11, FR13 */
		/* 820EF9BCh case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR13);
		/* 820EF9BCh case    6:*/		return 0x820EF9C0;
		  /* 820EF9C0h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 820EF9C0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820EF9C8;  }
		/* 820EF9C0h case    7:*/		return 0x820EF9C4;
	}
	return 0x820EF9C4;
} // Block from 820EF9A4h-820EF9C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EF9C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF9C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF9C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF9C4);
		  /* 820EF9C4h */ case    0:  		/* mr R7, R21 */
		/* 820EF9C4h case    0:*/		regs.R7 = regs.R21;
		/* 820EF9C4h case    0:*/		return 0x820EF9C8;
	}
	return 0x820EF9C8;
} // Block from 820EF9C4h-820EF9C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EF9C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EF9C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EF9C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EF9C8);
		  /* 820EF9C8h */ case    0:  		/* addi R24, R1, 240 */
		/* 820EF9C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R1,0xF0);
		/* 820EF9C8h case    0:*/		return 0x820EF9CC;
		  /* 820EF9CCh */ case    1:  		/* cmpwi CR6, R7, 0 */
		/* 820EF9CCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 820EF9CCh case    1:*/		return 0x820EF9D0;
		  /* 820EF9D0h */ case    2:  		/* bc 4, CR6_EQ, 192 */
		/* 820EF9D0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820EFA90;  }
		/* 820EF9D0h case    2:*/		return 0x820EF9D4;
		  /* 820EF9D4h */ case    3:  		/* lwz R10, <#[R26 + 20]> */
		/* 820EF9D4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 820EF9D4h case    3:*/		return 0x820EF9D8;
		  /* 820EF9D8h */ case    4:  		/* rlwinm R5, R31, 2, 0, 29 */
		/* 820EF9D8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R31);
		/* 820EF9D8h case    4:*/		return 0x820EF9DC;
		  /* 820EF9DCh */ case    5:  		/* lwz R11, <#[R9 + 56]> */
		/* 820EF9DCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000038) );
		/* 820EF9DCh case    5:*/		return 0x820EF9E0;
		  /* 820EF9E0h */ case    6:  		/* cmplw CR6, R11, R31 */
		/* 820EF9E0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820EF9E0h case    6:*/		return 0x820EF9E4;
		  /* 820EF9E4h */ case    7:  		/* lwzx R10, <#[R5 + R10]> */
		/* 820EF9E4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 820EF9E4h case    7:*/		return 0x820EF9E8;
		  /* 820EF9E8h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 820EF9E8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EFA00;  }
		/* 820EF9E8h case    8:*/		return 0x820EF9EC;
		  /* 820EF9ECh */ case    9:  		/* cmpwi CR6, R11, -1 */
		/* 820EF9ECh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EF9ECh case    9:*/		return 0x820EF9F0;
		  /* 820EF9F0h */ case   10:  		/* bc 12, CR6_EQ, 64 */
		/* 820EF9F0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820EFA30;  }
		/* 820EF9F0h case   10:*/		return 0x820EF9F4;
		  /* 820EF9F4h */ case   11:  		/* lwz R5, <#[R10 + 56]> */
		/* 820EF9F4h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000038) );
		/* 820EF9F4h case   11:*/		return 0x820EF9F8;
		  /* 820EF9F8h */ case   12:  		/* cmplw CR6, R5, R11 */
		/* 820EF9F8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 820EF9F8h case   12:*/		return 0x820EF9FC;
		  /* 820EF9FCh */ case   13:  		/* bc 4, CR6_EQ, 52 */
		/* 820EF9FCh case   13:*/		if ( !regs.CR[6].eq ) { return 0x820EFA30;  }
		/* 820EF9FCh case   13:*/		return 0x820EFA00;
	}
	return 0x820EFA00;
} // Block from 820EF9C8h-820EFA00h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820EFA00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFA00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFA00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFA00);
		  /* 820EFA00h */ case    0:  		/* lwz R11, <#[R10 + 60]> */
		/* 820EFA00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000003C) );
		/* 820EFA00h case    0:*/		return 0x820EFA04;
		  /* 820EFA04h */ case    1:  		/* lwz R5, <#[R9 + 60]> */
		/* 820EFA04h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x0000003C) );
		/* 820EFA04h case    1:*/		return 0x820EFA08;
		  /* 820EFA08h */ case    2:  		/* xoris R11, R11, 8 */
		/* 820EFA08h case    2:*/		cpu::op::xoris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820EFA08h case    2:*/		return 0x820EFA0C;
		  /* 820EFA0Ch */ case    3:  		/* cmplw CR6, R5, R11 */
		/* 820EFA0Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 820EFA0Ch case    3:*/		return 0x820EFA10;
		  /* 820EFA10h */ case    4:  		/* bc 4, CR6_EQ, 32 */
		/* 820EFA10h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820EFA30;  }
		/* 820EFA10h case    4:*/		return 0x820EFA14;
		  /* 820EFA14h */ case    5:  		/* lwz R11, <#[R6 + 4]> */
		/* 820EFA14h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 820EFA14h case    5:*/		return 0x820EFA18;
		  /* 820EFA18h */ case    6:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820EFA18h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820EFA18h case    6:*/		return 0x820EFA1C;
		  /* 820EFA1Ch */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820EFA1Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820EFA30;  }
		/* 820EFA1Ch case    7:*/		return 0x820EFA20;
		  /* 820EFA20h */ case    8:  		/* lfd FR11, <#[R8 + 32]> */
		/* 820EFA20h case    8:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R8 + 0x00000020) );
		/* 820EFA20h case    8:*/		return 0x820EFA24;
		  /* 820EFA24h */ case    9:  		/* fcmpu CR6, FR11, FR0 */
		/* 820EFA24h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR0);
		/* 820EFA24h case    9:*/		return 0x820EFA28;
		  /* 820EFA28h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 820EFA28h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820EFA30;  }
		/* 820EFA28h case   10:*/		return 0x820EFA2C;
		  /* 820EFA2Ch */ case   11:  		/* mr R7, R21 */
		/* 820EFA2Ch case   11:*/		regs.R7 = regs.R21;
		/* 820EFA2Ch case   11:*/		return 0x820EFA30;
	}
	return 0x820EFA30;
} // Block from 820EFA00h-820EFA30h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820EFA30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFA30);
		  /* 820EFA30h */ case    0:  		/* lwz R11, <#[R8 + 56]> */
		/* 820EFA30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000038) );
		/* 820EFA30h case    0:*/		return 0x820EFA34;
		  /* 820EFA34h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 820EFA34h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820EFA34h case    1:*/		return 0x820EFA38;
		  /* 820EFA38h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820EFA38h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EFA50;  }
		/* 820EFA38h case    2:*/		return 0x820EFA3C;
		  /* 820EFA3Ch */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 820EFA3Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EFA3Ch case    3:*/		return 0x820EFA40;
		  /* 820EFA40h */ case    4:  		/* bc 12, CR6_EQ, 64 */
		/* 820EFA40h case    4:*/		if ( regs.CR[6].eq ) { return 0x820EFA80;  }
		/* 820EFA40h case    4:*/		return 0x820EFA44;
		  /* 820EFA44h */ case    5:  		/* lwz R6, <#[R10 + 56]> */
		/* 820EFA44h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000038) );
		/* 820EFA44h case    5:*/		return 0x820EFA48;
		  /* 820EFA48h */ case    6:  		/* cmplw CR6, R6, R11 */
		/* 820EFA48h case    6:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820EFA48h case    6:*/		return 0x820EFA4C;
		  /* 820EFA4Ch */ case    7:  		/* bc 4, CR6_EQ, 52 */
		/* 820EFA4Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820EFA80;  }
		/* 820EFA4Ch case    7:*/		return 0x820EFA50;
	}
	return 0x820EFA50;
} // Block from 820EFA30h-820EFA50h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EFA50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFA50);
		  /* 820EFA50h */ case    0:  		/* lwz R11, <#[R10 + 60]> */
		/* 820EFA50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000003C) );
		/* 820EFA50h case    0:*/		return 0x820EFA54;
		  /* 820EFA54h */ case    1:  		/* lwz R10, <#[R8 + 60]> */
		/* 820EFA54h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x0000003C) );
		/* 820EFA54h case    1:*/		return 0x820EFA58;
		  /* 820EFA58h */ case    2:  		/* xoris R11, R11, 8 */
		/* 820EFA58h case    2:*/		cpu::op::xoris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820EFA58h case    2:*/		return 0x820EFA5C;
		  /* 820EFA5Ch */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 820EFA5Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820EFA5Ch case    3:*/		return 0x820EFA60;
		  /* 820EFA60h */ case    4:  		/* bc 4, CR6_EQ, 32 */
		/* 820EFA60h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820EFA80;  }
		/* 820EFA60h case    4:*/		return 0x820EFA64;
		  /* 820EFA64h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 820EFA64h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820EFA64h case    5:*/		return 0x820EFA68;
		  /* 820EFA68h */ case    6:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820EFA68h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820EFA68h case    6:*/		return 0x820EFA6C;
		  /* 820EFA6Ch */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820EFA6Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820EFA80;  }
		/* 820EFA6Ch case    7:*/		return 0x820EFA70;
		  /* 820EFA70h */ case    8:  		/* lfd FR11, <#[R9 + 32]> */
		/* 820EFA70h case    8:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R9 + 0x00000020) );
		/* 820EFA70h case    8:*/		return 0x820EFA74;
		  /* 820EFA74h */ case    9:  		/* fcmpu CR6, FR11, FR0 */
		/* 820EFA74h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR0);
		/* 820EFA74h case    9:*/		return 0x820EFA78;
		  /* 820EFA78h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 820EFA78h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820EFA80;  }
		/* 820EFA78h case   10:*/		return 0x820EFA7C;
		  /* 820EFA7Ch */ case   11:  		/* mr R7, R21 */
		/* 820EFA7Ch case   11:*/		regs.R7 = regs.R21;
		/* 820EFA7Ch case   11:*/		return 0x820EFA80;
	}
	return 0x820EFA80;
} // Block from 820EFA50h-820EFA80h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820EFA80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFA80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFA80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFA80);
		  /* 820EFA80h */ case    0:  		/* mr R5, R21 */
		/* 820EFA80h case    0:*/		regs.R5 = regs.R21;
		/* 820EFA80h case    0:*/		return 0x820EFA84;
		  /* 820EFA84h */ case    1:  		/* cmpwi CR6, R7, 0 */
		/* 820EFA84h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 820EFA84h case    1:*/		return 0x820EFA88;
		  /* 820EFA88h */ case    2:  		/* bc 12, CR6_EQ, -1324 */
		/* 820EFA88h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EFA88h case    2:*/		return 0x820EFA8C;
		  /* 820EFA8Ch */ case    3:  		/* addi R24, R1, 224 */
		/* 820EFA8Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R1,0xE0);
		/* 820EFA8Ch case    3:*/		return 0x820EFA90;
	}
	return 0x820EFA90;
} // Block from 820EFA80h-820EFA90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EFA90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFA90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFA90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFA90);
		  /* 820EFA90h */ case    0:  		/* lwz R10, <#[R4 - 64]> */
		/* 820EFA90h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0xFFFFFFC0) );
		/* 820EFA90h case    0:*/		return 0x820EFA94;
		  /* 820EFA94h */ case    1:  		/* cmpwi CR6, R5, 0 */
		/* 820EFA94h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 820EFA94h case    1:*/		return 0x820EFA98;
		  /* 820EFA98h */ case    2:  		/* lwz R11, <#[R26 + 20]> */
		/* 820EFA98h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 820EFA98h case    2:*/		return 0x820EFA9C;
		  /* 820EFA9Ch */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EFA9Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EFA9Ch case    3:*/		return 0x820EFAA0;
		  /* 820EFAA0h */ case    4:  		/* lwzx R8, <#[R10 + R11]> */
		/* 820EFAA0h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EFAA0h case    4:*/		return 0x820EFAA4;
		  /* 820EFAA4h */ case    5:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 820EFAA4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 820EFAA4h case    5:*/		return 0x820EFAA8;
		  /* 820EFAA8h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 820EFAA8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820EFAB0;  }
		/* 820EFAA8h case    6:*/		return 0x820EFAAC;
		  /* 820EFAACh */ case    7:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 820EFAACh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 820EFAACh case    7:*/		return 0x820EFAB0;
	}
	return 0x820EFAB0;
} // Block from 820EFA90h-820EFAB0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EFAB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFAB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFAB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFAB0);
		  /* 820EFAB0h */ case    0:  		/* lwz R7, <#[R8 + 4]> */
		/* 820EFAB0h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000004) );
		/* 820EFAB0h case    0:*/		return 0x820EFAB4;
		  /* 820EFAB4h */ case    1:  		/* lwzx R9, <#[R10 + R11]> */
		/* 820EFAB4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EFAB4h case    1:*/		return 0x820EFAB8;
		  /* 820EFAB8h */ case    2:  		/* lwz R10, <#[R26 + 16]> */
		/* 820EFAB8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 820EFAB8h case    2:*/		return 0x820EFABC;
		  /* 820EFABCh */ case    3:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820EFABCh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820EFABCh case    3:*/		return 0x820EFAC0;
		  /* 820EFAC0h */ case    4:  		/* lwzx R7, <#[R7 + R10]> */
		/* 820EFAC0h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820EFAC0h case    4:*/		return 0x820EFAC4;
		  /* 820EFAC4h */ case    5:  		/* lwz R7, <#[R7 + 4]> */
		/* 820EFAC4h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 820EFAC4h case    5:*/		return 0x820EFAC8;
		  /* 820EFAC8h */ case    6:  		/* rlwinm. R7, R7, 0, 23, 23 */
		/* 820EFAC8h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R7,regs.R7);
		/* 820EFAC8h case    6:*/		return 0x820EFACC;
		  /* 820EFACCh */ case    7:  		/* bc 12, CR0_EQ, -1392 */
		/* 820EFACCh case    7:*/		if ( regs.CR[0].eq ) { return 0x820EF55C;  }
		/* 820EFACCh case    7:*/		return 0x820EFAD0;
		  /* 820EFAD0h */ case    8:  		/* lfd FR11, <#[R8 + 32]> */
		/* 820EFAD0h case    8:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R8 + 0x00000020) );
		/* 820EFAD0h case    8:*/		return 0x820EFAD4;
		  /* 820EFAD4h */ case    9:  		/* fcmpu CR6, FR11, FR12 */
		/* 820EFAD4h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR12);
		/* 820EFAD4h case    9:*/		return 0x820EFAD8;
		  /* 820EFAD8h */ case   10:  		/* bc 4, CR6_EQ, -1404 */
		/* 820EFAD8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EFAD8h case   10:*/		return 0x820EFADC;
		  /* 820EFADCh */ case   11:  		/* lwz R8, <#[R9 + 4]> */
		/* 820EFADCh case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000004) );
		/* 820EFADCh case   11:*/		return 0x820EFAE0;
		  /* 820EFAE0h */ case   12:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820EFAE0h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820EFAE0h case   12:*/		return 0x820EFAE4;
		  /* 820EFAE4h */ case   13:  		/* lwzx R10, <#[R8 + R10]> */
		/* 820EFAE4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820EFAE4h case   13:*/		return 0x820EFAE8;
		  /* 820EFAE8h */ case   14:  		/* lwz R10, <#[R10 + 4]> */
		/* 820EFAE8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820EFAE8h case   14:*/		return 0x820EFAEC;
		  /* 820EFAECh */ case   15:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 820EFAECh case   15:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 820EFAECh case   15:*/		return 0x820EFAF0;
		  /* 820EFAF0h */ case   16:  		/* bc 12, CR0_EQ, -1428 */
		/* 820EFAF0h case   16:*/		if ( regs.CR[0].eq ) { return 0x820EF55C;  }
		/* 820EFAF0h case   16:*/		return 0x820EFAF4;
		  /* 820EFAF4h */ case   17:  		/* lfd FR11, <#[R9 + 32]> */
		/* 820EFAF4h case   17:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R9 + 0x00000020) );
		/* 820EFAF4h case   17:*/		return 0x820EFAF8;
	}
	return 0x820EFAF8;
} // Block from 820EFAB0h-820EFAF8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820EFAF8h
// Function '?MatchSatModifier@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFAF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFAF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFAF8);
		  /* 820EFAF8h */ case    0:  		/* fcmpu CR6, FR11, FR0 */
		/* 820EFAF8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR0);
		/* 820EFAF8h case    0:*/		return 0x820EFAFC;
		  /* 820EFAFCh */ case    1:  		/* bc 4, CR6_EQ, -1440 */
		/* 820EFAFCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EFAFCh case    1:*/		return 0x820EFB00;
		  /* 820EFB00h */ case    2:  		/* lwzx R10, <#[R24 + R29]> */
		/* 820EFB00h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + regs.R29 + 0x00000000) );
		/* 820EFB00h case    2:*/		return 0x820EFB04;
		  /* 820EFB04h */ case    3:  		/* lwz R8, <#[R26 + 136]> */
		/* 820EFB04h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000088) );
		/* 820EFB04h case    3:*/		return 0x820EFB08;
		  /* 820EFB08h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EFB08h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EFB08h case    4:*/		return 0x820EFB0C;
		  /* 820EFB0Ch */ case    5:  		/* lwzx R9, <#[R10 + R11]> */
		/* 820EFB0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820EFB0Ch case    5:*/		return 0x820EFB10;
		  /* 820EFB10h */ case    6:  		/* lwz R11, <#[R9 + 4]> */
		/* 820EFB10h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 820EFB10h case    6:*/		return 0x820EFB14;
		  /* 820EFB14h */ case    7:  		/* cmplw CR6, R11, R8 */
		/* 820EFB14h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820EFB14h case    7:*/		return 0x820EFB18;
		  /* 820EFB18h */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 820EFB18h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EFB20;  }
		/* 820EFB18h case    8:*/		return 0x820EFB1C;
		  /* 820EFB1Ch */ case    9:  		/* mr R20, R21 */
		/* 820EFB1Ch case    9:*/		regs.R20 = regs.R21;
		/* 820EFB1Ch case    9:*/		return 0x820EFB20;
	}
	return 0x820EFB20;
} // Block from 820EFAF8h-820EFB20h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820EFB20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFB20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFB20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFB20);
		  /* 820EFB20h */ case    0:  		/* mr R10, R22 */
		/* 820EFB20h case    0:*/		regs.R10 = regs.R22;
		/* 820EFB20h case    0:*/		return 0x820EFB24;
		  /* 820EFB24h */ case    1:  		/* cmplwi CR6, R23, 0 */
		/* 820EFB24h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820EFB24h case    1:*/		return 0x820EFB28;
		  /* 820EFB28h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820EFB28h case    2:*/		if ( regs.CR[6].eq ) { return 0x820EFB50;  }
		/* 820EFB28h case    2:*/		return 0x820EFB2C;
		  /* 820EFB2Ch */ case    3:  		/* lwz R8, <#[R9 + 72]> */
		/* 820EFB2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000048) );
		/* 820EFB2Ch case    3:*/		return 0x820EFB30;
		  /* 820EFB30h */ case    4:  		/* addi R11, R1, 112 */
		/* 820EFB30h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820EFB30h case    4:*/		return 0x820EFB34;
		  /* 820EFB34h */ case    5:  		/* lwz R7, <#[R11]> */
		/* 820EFB34h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820EFB34h case    5:*/		return 0x820EFB38;
		  /* 820EFB38h */ case    6:  		/* cmplw CR6, R8, R7 */
		/* 820EFB38h case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820EFB38h case    6:*/		return 0x820EFB3C;
		  /* 820EFB3Ch */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820EFB3Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820EFB50;  }
		/* 820EFB3Ch case    7:*/		return 0x820EFB40;
		  /* 820EFB40h */ case    8:  		/* addi R10, R10, 1 */
		/* 820EFB40h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EFB40h case    8:*/		return 0x820EFB44;
		  /* 820EFB44h */ case    9:  		/* addi R11, R11, 4 */
		/* 820EFB44h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EFB44h case    9:*/		return 0x820EFB48;
		  /* 820EFB48h */ case   10:  		/* cmplw CR6, R10, R23 */
		/* 820EFB48h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R23);
		/* 820EFB48h case   10:*/		return 0x820EFB4C;
		  /* 820EFB4Ch */ case   11:  		/* bc 12, CR6_LT, -24 */
		/* 820EFB4Ch case   11:*/		if ( regs.CR[6].lt ) { return 0x820EFB34;  }
		/* 820EFB4Ch case   11:*/		return 0x820EFB50;
	}
	return 0x820EFB50;
} // Block from 820EFB20h-820EFB50h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820EFB50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFB50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFB50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFB50);
		  /* 820EFB50h */ case    0:  		/* cmplw CR6, R10, R23 */
		/* 820EFB50h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R23);
		/* 820EFB50h case    0:*/		return 0x820EFB54;
		  /* 820EFB54h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 820EFB54h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EFB6C;  }
		/* 820EFB54h case    1:*/		return 0x820EFB58;
		  /* 820EFB58h */ case    2:  		/* cmpwi CR6, R20, 0 */
		/* 820EFB58h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 820EFB58h case    2:*/		return 0x820EFB5C;
		  /* 820EFB5Ch */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820EFB5Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820EFB6C;  }
		/* 820EFB5Ch case    3:*/		return 0x820EFB60;
		  /* 820EFB60h */ case    4:  		/* lwz R11, <#[R9 + 72]> */
		/* 820EFB60h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000048) );
		/* 820EFB60h case    4:*/		return 0x820EFB64;
		  /* 820EFB64h */ case    5:  		/* addi R23, R23, 1 */
		/* 820EFB64h case    5:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 820EFB64h case    5:*/		return 0x820EFB68;
		  /* 820EFB68h */ case    6:  		/* stwu R11, <#[R28 + 4]> */
		/* 820EFB68h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		regs.R28 = (uint32)(regs.R28 + 0x00000004);
		/* 820EFB68h case    6:*/		return 0x820EFB6C;
	}
	return 0x820EFB6C;
} // Block from 820EFB50h-820EFB6Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EFB6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFB6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFB6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFB6C);
		  /* 820EFB6Ch */ case    0:  		/* addi R27, R27, 1 */
		/* 820EFB6Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820EFB6Ch case    0:*/		return 0x820EFB70;
		  /* 820EFB70h */ case    1:  		/* addi R29, R29, 4 */
		/* 820EFB70h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820EFB70h case    1:*/		return 0x820EFB74;
		  /* 820EFB74h */ case    2:  		/* cmplw CR6, R27, R25 */
		/* 820EFB74h case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R25);
		/* 820EFB74h case    2:*/		return 0x820EFB78;
		  /* 820EFB78h */ case    3:  		/* bc 12, CR6_LT, -628 */
		/* 820EFB78h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EF904;  }
		/* 820EFB78h case    3:*/		return 0x820EFB7C;
		  /* 820EFB7Ch */ case    4:  		/* b -1440 */
		/* 820EFB7Ch case    4:*/		return 0x820EF5DC;
		/* 820EFB7Ch case    4:*/		return 0x820EFB80;
	}
	return 0x820EFB80;
} // Block from 820EFB6Ch-820EFB80h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EFB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFB80);
		  /* 820EFB80h */ case    0:  		/* lwz R11, <#[R26 + 108]> */
		/* 820EFB80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000006C) );
		/* 820EFB80h case    0:*/		return 0x820EFB84;
		  /* 820EFB84h */ case    1:  		/* mr R29, R22 */
		/* 820EFB84h case    1:*/		regs.R29 = regs.R22;
		/* 820EFB84h case    1:*/		return 0x820EFB88;
		  /* 820EFB88h */ case    2:  		/* stw R22, <#[R1 + 128]> */
		/* 820EFB88h case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000080) );
		/* 820EFB88h case    2:*/		return 0x820EFB8C;
		  /* 820EFB8Ch */ case    3:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820EFB8Ch case    3:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820EFB8Ch case    3:*/		return 0x820EFB90;
		  /* 820EFB90h */ case    4:  		/* bc 12, CR0_EQ, 76 */
		/* 820EFB90h case    4:*/		if ( regs.CR[0].eq ) { return 0x820EFBDC;  }
		/* 820EFB90h case    4:*/		return 0x820EFB94;
		  /* 820EFB94h */ case    5:  		/* addi R6, R1, 96 */
		/* 820EFB94h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 820EFB94h case    5:*/		return 0x820EFB98;
		  /* 820EFB98h */ case    6:  		/* addi R5, R1, 144 */
		/* 820EFB98h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x90);
		/* 820EFB98h case    6:*/		return 0x820EFB9C;
		  /* 820EFB9Ch */ case    7:  		/* addi R4, R1, 128 */
		/* 820EFB9Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 820EFB9Ch case    7:*/		return 0x820EFBA0;
		  /* 820EFBA0h */ case    8:  		/* mr R3, R26 */
		/* 820EFBA0h case    8:*/		regs.R3 = regs.R26;
		/* 820EFBA0h case    8:*/		return 0x820EFBA4;
		  /* 820EFBA4h */ case    9:  		/* bl -41692 */
		/* 820EFBA4h case    9:*/		regs.LR = 0x820EFBA8; return 0x820E58C8;
		/* 820EFBA4h case    9:*/		return 0x820EFBA8;
		  /* 820EFBA8h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820EFBA8h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EFBA8h case   10:*/		return 0x820EFBAC;
		  /* 820EFBACh */ case   11:  		/* bc 12, CR0_EQ, 32 */
		/* 820EFBACh case   11:*/		if ( regs.CR[0].eq ) { return 0x820EFBCC;  }
		/* 820EFBACh case   11:*/		return 0x820EFBB0;
		  /* 820EFBB0h */ case   12:  		/* addi R6, R1, 96 */
		/* 820EFBB0h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 820EFBB0h case   12:*/		return 0x820EFBB4;
		  /* 820EFBB4h */ case   13:  		/* addi R5, R1, 144 */
		/* 820EFBB4h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x90);
		/* 820EFBB4h case   13:*/		return 0x820EFBB8;
		  /* 820EFBB8h */ case   14:  		/* addi R4, R1, 128 */
		/* 820EFBB8h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 820EFBB8h case   14:*/		return 0x820EFBBC;
		  /* 820EFBBCh */ case   15:  		/* mr R3, R26 */
		/* 820EFBBCh case   15:*/		regs.R3 = regs.R26;
		/* 820EFBBCh case   15:*/		return 0x820EFBC0;
		  /* 820EFBC0h */ case   16:  		/* bl -40032 */
		/* 820EFBC0h case   16:*/		regs.LR = 0x820EFBC4; return 0x820E5F60;
		/* 820EFBC0h case   16:*/		return 0x820EFBC4;
		  /* 820EFBC4h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820EFBC4h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820EFBC4h case   17:*/		return 0x820EFBC8;
		  /* 820EFBC8h */ case   18:  		/* bc 4, CR0_EQ, 20 */
		/* 820EFBC8h case   18:*/		if ( !regs.CR[0].eq ) { return 0x820EFBDC;  }
		/* 820EFBC8h case   18:*/		return 0x820EFBCC;
	}
	return 0x820EFBCC;
} // Block from 820EFB80h-820EFBCCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820EFBCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFBCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFBCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFBCC);
		  /* 820EFBCCh */ case    0:  		/* lwz R6, <#[R1 + 128]> */
		/* 820EFBCCh case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 820EFBCCh case    0:*/		return 0x820EFBD0;
		  /* 820EFBD0h */ case    1:  		/* lwz R28, <#[R1 + 96]> */
		/* 820EFBD0h case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000060) );
		/* 820EFBD0h case    1:*/		return 0x820EFBD4;
		  /* 820EFBD4h */ case    2:  		/* mr R29, R6 */
		/* 820EFBD4h case    2:*/		regs.R29 = regs.R6;
		/* 820EFBD4h case    2:*/		return 0x820EFBD8;
		  /* 820EFBD8h */ case    3:  		/* b 20 */
		/* 820EFBD8h case    3:*/		return 0x820EFBEC;
		/* 820EFBD8h case    3:*/		return 0x820EFBDC;
	}
	return 0x820EFBDC;
} // Block from 820EFBCCh-820EFBDCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EFBDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFBDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFBDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFBDC);
		  /* 820EFBDCh */ case    0:  		/* lwz R11, <#[R26 + 260]> */
		/* 820EFBDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000104) );
		/* 820EFBDCh case    0:*/		return 0x820EFBE0;
		  /* 820EFBE0h */ case    1:  		/* mr R28, R21 */
		/* 820EFBE0h case    1:*/		regs.R28 = regs.R21;
		/* 820EFBE0h case    1:*/		return 0x820EFBE4;
		  /* 820EFBE4h */ case    2:  		/* mr R6, R11 */
		/* 820EFBE4h case    2:*/		regs.R6 = regs.R11;
		/* 820EFBE4h case    2:*/		return 0x820EFBE8;
		  /* 820EFBE8h */ case    3:  		/* stw R11, <#[R1 + 144]> */
		/* 820EFBE8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 820EFBE8h case    3:*/		return 0x820EFBEC;
	}
	return 0x820EFBEC;
} // Block from 820EFBDCh-820EFBECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EFBECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFBEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFBEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFBEC);
		  /* 820EFBECh */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 820EFBECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820EFBECh case    0:*/		return 0x820EFBF0;
		  /* 820EFBF0h */ case    1:  		/* bc 12, CR6_EQ, 452 */
		/* 820EFBF0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EFDB4;  }
		/* 820EFBF0h case    1:*/		return 0x820EFBF4;
		  /* 820EFBF4h */ case    2:  		/* lwz R11, <#[R6]> */
		/* 820EFBF4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 820EFBF4h case    2:*/		return 0x820EFBF8;
		  /* 820EFBF8h */ case    3:  		/* lis R10, 28848 */
		/* 820EFBF8h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x70B0);
		/* 820EFBF8h case    3:*/		return 0x820EFBFC;
		  /* 820EFBFCh */ case    4:  		/* rlwinm R9, R11, 0, 0, 11 */
		/* 820EFBFCh case    4:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R11);
		/* 820EFBFCh case    4:*/		return 0x820EFC00;
		  /* 820EFC00h */ case    5:  		/* cmplw CR6, R9, R10 */
		/* 820EFC00h case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820EFC00h case    5:*/		return 0x820EFC04;
		  /* 820EFC04h */ case    6:  		/* bc 4, CR6_EQ, 432 */
		/* 820EFC04h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820EFDB4;  }
		/* 820EFC04h case    6:*/		return 0x820EFC08;
		  /* 820EFC08h */ case    7:  		/* rlwinm R25, R11, 0, 12, 31 */
		/* 820EFC08h case    7:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R25,regs.R11);
		/* 820EFC08h case    7:*/		return 0x820EFC0C;
		  /* 820EFC0Ch */ case    8:  		/* lis R11, -32256 */
		/* 820EFC0Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820EFC0Ch case    8:*/		return 0x820EFC10;
		  /* 820EFC10h */ case    9:  		/* mr R30, R22 */
		/* 820EFC10h case    9:*/		regs.R30 = regs.R22;
		/* 820EFC10h case    9:*/		return 0x820EFC14;
		  /* 820EFC14h */ case   10:  		/* neg R31, R25 */
		/* 820EFC14h case   10:*/		cpu::op::neg<0>(regs,&regs.R31,regs.R25);
		/* 820EFC14h case   10:*/		return 0x820EFC18;
		  /* 820EFC18h */ case   11:  		/* mr R4, R22 */
		/* 820EFC18h case   11:*/		regs.R4 = regs.R22;
		/* 820EFC18h case   11:*/		return 0x820EFC1C;
		  /* 820EFC1Ch */ case   12:  		/* mr R5, R25 */
		/* 820EFC1Ch case   12:*/		regs.R5 = regs.R25;
		/* 820EFC1Ch case   12:*/		return 0x820EFC20;
		  /* 820EFC20h */ case   13:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 820EFC20h case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 820EFC20h case   13:*/		return 0x820EFC24;
		  /* 820EFC24h */ case   14:  		/* mr R9, R22 */
		/* 820EFC24h case   14:*/		regs.R9 = regs.R22;
		/* 820EFC24h case   14:*/		return 0x820EFC28;
		  /* 820EFC28h */ case   15:  		/* cmplwi CR6, R25, 0 */
		/* 820EFC28h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820EFC28h case   15:*/		return 0x820EFC2C;
		  /* 820EFC2Ch */ case   16:  		/* bc 12, CR6_EQ, 188 */
		/* 820EFC2Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x820EFCE8;  }
		/* 820EFC2Ch case   16:*/		return 0x820EFC30;
		  /* 820EFC30h */ case   17:  		/* lwz R7, <#[R26 + 20]> */
		/* 820EFC30h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000014) );
		/* 820EFC30h case   17:*/		return 0x820EFC34;
		  /* 820EFC34h */ case   18:  		/* addi R3, R1, 128 */
		/* 820EFC34h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 820EFC34h case   18:*/		return 0x820EFC38;
		  /* 820EFC38h */ case   19:  		/* add R11, R4, R9 */
		/* 820EFC38h case   19:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R9);
		/* 820EFC38h case   19:*/		return 0x820EFC3C;
		  /* 820EFC3Ch */ case   20:  		/* lwz R8, <#[R6 + 8]> */
		/* 820EFC3Ch case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000008) );
		/* 820EFC3Ch case   20:*/		return 0x820EFC40;
		  /* 820EFC40h */ case   21:  		/* add R27, R5, R9 */
		/* 820EFC40h case   21:*/		cpu::op::add<0>(regs,&regs.R27,regs.R5,regs.R9);
		/* 820EFC40h case   21:*/		return 0x820EFC44;
		  /* 820EFC44h */ case   22:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 820EFC44h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820EFC44h case   22:*/		return 0x820EFC48;
		  /* 820EFC48h */ case   23:  		/* rlwinm R11, R27, 2, 0, 29 */
		/* 820EFC48h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R27);
		/* 820EFC48h case   23:*/		return 0x820EFC4C;
		  /* 820EFC4Ch */ case   24:  		/* lwzx R27, <#[R8 + R10]> */
		/* 820EFC4Ch case   24:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820EFC4Ch case   24:*/		return 0x820EFC50;
		  /* 820EFC50h */ case   25:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820EFC50h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820EFC50h case   25:*/		return 0x820EFC54;
		  /* 820EFC54h */ case   26:  		/* rlwinm R8, R27, 2, 0, 29 */
		/* 820EFC54h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R27);
		/* 820EFC54h case   26:*/		return 0x820EFC58;
		  /* 820EFC58h */ case   27:  		/* rlwinm R27, R11, 2, 0, 29 */
		/* 820EFC58h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R11);
		/* 820EFC58h case   27:*/		return 0x820EFC5C;
		  /* 820EFC5Ch */ case   28:  		/* lwzx R11, <#[R8 + R7]> */
		/* 820EFC5Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820EFC5Ch case   28:*/		return 0x820EFC60;
		  /* 820EFC60h */ case   29:  		/* lwzx R8, <#[R27 + R7]> */
		/* 820EFC60h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + regs.R7 + 0x00000000) );
		/* 820EFC60h case   29:*/		return 0x820EFC64;
		  /* 820EFC64h */ case   30:  		/* lwz R27, <#[R11 + 60]> */
		/* 820EFC64h case   30:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x0000003C) );
		/* 820EFC64h case   30:*/		return 0x820EFC68;
		  /* 820EFC68h */ case   31:  		/* rlwinm. R27, R27, 0, 12, 12 */
		/* 820EFC68h case   31:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R27,regs.R27);
		/* 820EFC68h case   31:*/		return 0x820EFC6C;
		  /* 820EFC6Ch */ case   32:  		/* lwz R27, <#[R11]> */
		/* 820EFC6Ch case   32:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 820EFC6Ch case   32:*/		return 0x820EFC70;
		  /* 820EFC70h */ case   33:  		/* bc 12, CR0_EQ, 12 */
		/* 820EFC70h case   33:*/		if ( regs.CR[0].eq ) { return 0x820EFC7C;  }
		/* 820EFC70h case   33:*/		return 0x820EFC74;
		  /* 820EFC74h */ case   34:  		/* rlwinm. R27, R27, 0, 28, 28 */
		/* 820EFC74h case   34:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R27,regs.R27);
		/* 820EFC74h case   34:*/		return 0x820EFC78;
		  /* 820EFC78h */ case   35:  		/* b 8 */
		/* 820EFC78h case   35:*/		return 0x820EFC80;
		/* 820EFC78h case   35:*/		return 0x820EFC7C;
	}
	return 0x820EFC7C;
} // Block from 820EFBECh-820EFC7Ch (36 instructions)

//////////////////////////////////////////////////////
// Block at 820EFC7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFC7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFC7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFC7C);
		  /* 820EFC7Ch */ case    0:  		/* rlwinm. R27, R27, 0, 29, 29 */
		/* 820EFC7Ch case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R27,regs.R27);
		/* 820EFC7Ch case    0:*/		return 0x820EFC80;
	}
	return 0x820EFC80;
} // Block from 820EFC7Ch-820EFC80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EFC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFC80);
		  /* 820EFC80h */ case    0:  		/* bc 12, CR0_EQ, 104 */
		/* 820EFC80h case    0:*/		if ( regs.CR[0].eq ) { return 0x820EFCE8;  }
		/* 820EFC80h case    0:*/		return 0x820EFC84;
		  /* 820EFC84h */ case    1:  		/* lwz R27, <#[R8 + 4]> */
		/* 820EFC84h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R8 + 0x00000004) );
		/* 820EFC84h case    1:*/		return 0x820EFC88;
		  /* 820EFC88h */ case    2:  		/* lwz R24, <#[R26 + 16]> */
		/* 820EFC88h case    2:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R26 + 0x00000010) );
		/* 820EFC88h case    2:*/		return 0x820EFC8C;
		  /* 820EFC8Ch */ case    3:  		/* rlwinm R27, R27, 2, 0, 29 */
		/* 820EFC8Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R27);
		/* 820EFC8Ch case    3:*/		return 0x820EFC90;
		  /* 820EFC90h */ case    4:  		/* lwzx R27, <#[R27 + R24]> */
		/* 820EFC90h case    4:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + regs.R24 + 0x00000000) );
		/* 820EFC90h case    4:*/		return 0x820EFC94;
		  /* 820EFC94h */ case    5:  		/* lwz R27, <#[R27 + 4]> */
		/* 820EFC94h case    5:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000004) );
		/* 820EFC94h case    5:*/		return 0x820EFC98;
		  /* 820EFC98h */ case    6:  		/* rlwinm. R27, R27, 0, 23, 23 */
		/* 820EFC98h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R27,regs.R27);
		/* 820EFC98h case    6:*/		return 0x820EFC9C;
		  /* 820EFC9Ch */ case    7:  		/* bc 12, CR0_EQ, 76 */
		/* 820EFC9Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820EFCE8;  }
		/* 820EFC9Ch case    7:*/		return 0x820EFCA0;
		  /* 820EFCA0h */ case    8:  		/* lfd FR13, <#[R8 + 32]> */
		/* 820EFCA0h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R8 + 0x00000020) );
		/* 820EFCA0h case    8:*/		return 0x820EFCA4;
		  /* 820EFCA4h */ case    9:  		/* fcmpu CR6, FR13, FR0 */
		/* 820EFCA4h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820EFCA4h case    9:*/		return 0x820EFCA8;
		  /* 820EFCA8h */ case   10:  		/* bc 4, CR6_EQ, 64 */
		/* 820EFCA8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820EFCE8;  }
		/* 820EFCA8h case   10:*/		return 0x820EFCAC;
		  /* 820EFCACh */ case   11:  		/* lwz R8, <#[R8 + 8]> */
		/* 820EFCACh case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 820EFCACh case   11:*/		return 0x820EFCB0;
		  /* 820EFCB0h */ case   12:  		/* cmpwi CR6, R8, -1 */
		/* 820EFCB0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 820EFCB0h case   12:*/		return 0x820EFCB4;
		  /* 820EFCB4h */ case   13:  		/* bc 4, CR6_EQ, 52 */
		/* 820EFCB4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820EFCE8;  }
		/* 820EFCB4h case   13:*/		return 0x820EFCB8;
		  /* 820EFCB8h */ case   14:  		/* lwz R8, <#[R6 + 8]> */
		/* 820EFCB8h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000008) );
		/* 820EFCB8h case   14:*/		return 0x820EFCBC;
		  /* 820EFCBCh */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 820EFCBCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820EFCBCh case   15:*/		return 0x820EFCC0;
		  /* 820EFCC0h */ case   16:  		/* lwz R27, <#[R26 + 136]> */
		/* 820EFCC0h case   16:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R26 + 0x00000088) );
		/* 820EFCC0h case   16:*/		return 0x820EFCC4;
		  /* 820EFCC4h */ case   17:  		/* cmplw CR6, R11, R27 */
		/* 820EFCC4h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820EFCC4h case   17:*/		return 0x820EFCC8;
		  /* 820EFCC8h */ case   18:  		/* lwzx R11, <#[R10 + R8]> */
		/* 820EFCC8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820EFCC8h case   18:*/		return 0x820EFCCC;
		  /* 820EFCCCh */ case   19:  		/* stw R11, <#[R3]> */
		/* 820EFCCCh case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820EFCCCh case   19:*/		return 0x820EFCD0;
		  /* 820EFCD0h */ case   20:  		/* bc 12, CR6_EQ, 8 */
		/* 820EFCD0h case   20:*/		if ( regs.CR[6].eq ) { return 0x820EFCD8;  }
		/* 820EFCD0h case   20:*/		return 0x820EFCD4;
		  /* 820EFCD4h */ case   21:  		/* mr R20, R21 */
		/* 820EFCD4h case   21:*/		regs.R20 = regs.R21;
		/* 820EFCD4h case   21:*/		return 0x820EFCD8;
	}
	return 0x820EFCD8;
} // Block from 820EFC80h-820EFCD8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820EFCD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFCD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFCD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFCD8);
		  /* 820EFCD8h */ case    0:  		/* addi R9, R9, 1 */
		/* 820EFCD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820EFCD8h case    0:*/		return 0x820EFCDC;
		  /* 820EFCDCh */ case    1:  		/* addi R3, R3, 4 */
		/* 820EFCDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 820EFCDCh case    1:*/		return 0x820EFCE0;
		  /* 820EFCE0h */ case    2:  		/* cmplw CR6, R9, R25 */
		/* 820EFCE0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R25);
		/* 820EFCE0h case    2:*/		return 0x820EFCE4;
		  /* 820EFCE4h */ case    3:  		/* bc 12, CR6_LT, -172 */
		/* 820EFCE4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820EFC38;  }
		/* 820EFCE4h case    3:*/		return 0x820EFCE8;
	}
	return 0x820EFCE8;
} // Block from 820EFCD8h-820EFCE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EFCE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFCE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFCE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFCE8);
		  /* 820EFCE8h */ case    0:  		/* cmplw CR6, R9, R25 */
		/* 820EFCE8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R25);
		/* 820EFCE8h case    0:*/		return 0x820EFCEC;
		  /* 820EFCECh */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820EFCECh case    1:*/		if ( regs.CR[6].eq ) { return 0x820EFD08;  }
		/* 820EFCECh case    1:*/		return 0x820EFCF0;
		  /* 820EFCF0h */ case    2:  		/* addi R30, R30, 1 */
		/* 820EFCF0h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820EFCF0h case    2:*/		return 0x820EFCF4;
		  /* 820EFCF4h */ case    3:  		/* add R5, R31, R5 */
		/* 820EFCF4h case    3:*/		cpu::op::add<0>(regs,&regs.R5,regs.R31,regs.R5);
		/* 820EFCF4h case    3:*/		return 0x820EFCF8;
		  /* 820EFCF8h */ case    4:  		/* add R4, R4, R25 */
		/* 820EFCF8h case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R4,regs.R25);
		/* 820EFCF8h case    4:*/		return 0x820EFCFC;
		  /* 820EFCFCh */ case    5:  		/* cmplwi CR6, R30, 2 */
		/* 820EFCFCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000002);
		/* 820EFCFCh case    5:*/		return 0x820EFD00;
		  /* 820EFD00h */ case    6:  		/* bc 12, CR6_LT, -220 */
		/* 820EFD00h case    6:*/		if ( regs.CR[6].lt ) { return 0x820EFC24;  }
		/* 820EFD00h case    6:*/		return 0x820EFD04;
		  /* 820EFD04h */ case    7:  		/* b 160 */
		/* 820EFD04h case    7:*/		return 0x820EFDA4;
		/* 820EFD04h case    7:*/		return 0x820EFD08;
	}
	return 0x820EFD08;
} // Block from 820EFCE8h-820EFD08h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EFD08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFD08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFD08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFD08);
		  /* 820EFD08h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 820EFD08h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820EFD08h case    0:*/		return 0x820EFD0C;
		  /* 820EFD0Ch */ case    1:  		/* bc 12, CR6_EQ, 152 */
		/* 820EFD0Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820EFDA4;  }
		/* 820EFD0Ch case    1:*/		return 0x820EFD10;
		  /* 820EFD10h */ case    2:  		/* mullw R9, R30, R25 */
		/* 820EFD10h case    2:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R30,regs.R25);
		/* 820EFD10h case    2:*/		return 0x820EFD14;
		  /* 820EFD14h */ case    3:  		/* lwz R10, <#[R6 + 8]> */
		/* 820EFD14h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000008) );
		/* 820EFD14h case    3:*/		return 0x820EFD18;
		  /* 820EFD18h */ case    4:  		/* lwz R5, <#[R26 + 20]> */
		/* 820EFD18h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x00000014) );
		/* 820EFD18h case    4:*/		return 0x820EFD1C;
		  /* 820EFD1Ch */ case    5:  		/* mtspr CTR, R25 */
		/* 820EFD1Ch case    5:*/		regs.CTR = regs.R25;
		/* 820EFD1Ch case    5:*/		return 0x820EFD20;
		  /* 820EFD20h */ case    6:  		/* addi R11, R1, 112 */
		/* 820EFD20h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820EFD20h case    6:*/		return 0x820EFD24;
		  /* 820EFD24h */ case    7:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820EFD24h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820EFD24h case    7:*/		return 0x820EFD28;
		  /* 820EFD28h */ case    8:  		/* addi R6, R11, -4 */
		/* 820EFD28h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFFC);
		/* 820EFD28h case    8:*/		return 0x820EFD2C;
		  /* 820EFD2Ch */ case    9:  		/* add R7, R9, R10 */
		/* 820EFD2Ch case    9:*/		cpu::op::add<0>(regs,&regs.R7,regs.R9,regs.R10);
		/* 820EFD2Ch case    9:*/		return 0x820EFD30;
		  /* 820EFD30h */ case   10:  		/* lwz R11, <#[R7]> */
		/* 820EFD30h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 820EFD30h case   10:*/		return 0x820EFD34;
		  /* 820EFD34h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EFD34h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EFD34h case   11:*/		return 0x820EFD38;
		  /* 820EFD38h */ case   12:  		/* lwzx R8, <#[R11 + R5]> */
		/* 820EFD38h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820EFD38h case   12:*/		return 0x820EFD3C;
		  /* 820EFD3Ch */ case   13:  		/* lwz R11, <#[R8 + 56]> */
		/* 820EFD3Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000038) );
		/* 820EFD3Ch case   13:*/		return 0x820EFD40;
		  /* 820EFD40h */ case   14:  		/* cmpwi CR6, R11, -1 */
		/* 820EFD40h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820EFD40h case   14:*/		return 0x820EFD44;
		  /* 820EFD44h */ case   15:  		/* bc 4, CR6_EQ, 84 */
		/* 820EFD44h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820EFD98;  }
		/* 820EFD44h case   15:*/		return 0x820EFD48;
		  /* 820EFD48h */ case   16:  		/* mr R10, R22 */
		/* 820EFD48h case   16:*/		regs.R10 = regs.R22;
		/* 820EFD48h case   16:*/		return 0x820EFD4C;
		  /* 820EFD4Ch */ case   17:  		/* cmplwi CR6, R23, 0 */
		/* 820EFD4Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820EFD4Ch case   17:*/		return 0x820EFD50;
		  /* 820EFD50h */ case   18:  		/* bc 12, CR6_EQ, 40 */
		/* 820EFD50h case   18:*/		if ( regs.CR[6].eq ) { return 0x820EFD78;  }
		/* 820EFD50h case   18:*/		return 0x820EFD54;
		  /* 820EFD54h */ case   19:  		/* lwz R9, <#[R8 + 72]> */
		/* 820EFD54h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000048) );
		/* 820EFD54h case   19:*/		return 0x820EFD58;
		  /* 820EFD58h */ case   20:  		/* addi R11, R1, 112 */
		/* 820EFD58h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820EFD58h case   20:*/		return 0x820EFD5C;
		  /* 820EFD5Ch */ case   21:  		/* lwz R4, <#[R11]> */
		/* 820EFD5Ch case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820EFD5Ch case   21:*/		return 0x820EFD60;
		  /* 820EFD60h */ case   22:  		/* cmplw CR6, R9, R4 */
		/* 820EFD60h case   22:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 820EFD60h case   22:*/		return 0x820EFD64;
		  /* 820EFD64h */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 820EFD64h case   23:*/		if ( regs.CR[6].eq ) { return 0x820EFD78;  }
		/* 820EFD64h case   23:*/		return 0x820EFD68;
		  /* 820EFD68h */ case   24:  		/* addi R10, R10, 1 */
		/* 820EFD68h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820EFD68h case   24:*/		return 0x820EFD6C;
		  /* 820EFD6Ch */ case   25:  		/* addi R11, R11, 4 */
		/* 820EFD6Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EFD6Ch case   25:*/		return 0x820EFD70;
		  /* 820EFD70h */ case   26:  		/* cmplw CR6, R10, R23 */
		/* 820EFD70h case   26:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R23);
		/* 820EFD70h case   26:*/		return 0x820EFD74;
		  /* 820EFD74h */ case   27:  		/* bc 12, CR6_LT, -24 */
		/* 820EFD74h case   27:*/		if ( regs.CR[6].lt ) { return 0x820EFD5C;  }
		/* 820EFD74h case   27:*/		return 0x820EFD78;
	}
	return 0x820EFD78;
} // Block from 820EFD08h-820EFD78h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820EFD78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFD78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFD78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFD78);
		  /* 820EFD78h */ case    0:  		/* cmplw CR6, R10, R23 */
		/* 820EFD78h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R23);
		/* 820EFD78h case    0:*/		return 0x820EFD7C;
		  /* 820EFD7Ch */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 820EFD7Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EFD9C;  }
		/* 820EFD7Ch case    1:*/		return 0x820EFD80;
		  /* 820EFD80h */ case    2:  		/* cmpwi CR6, R20, 0 */
		/* 820EFD80h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 820EFD80h case    2:*/		return 0x820EFD84;
		  /* 820EFD84h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 820EFD84h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820EFD9C;  }
		/* 820EFD84h case    3:*/		return 0x820EFD88;
		  /* 820EFD88h */ case    4:  		/* lwz R11, <#[R8 + 72]> */
		/* 820EFD88h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000048) );
		/* 820EFD88h case    4:*/		return 0x820EFD8C;
		  /* 820EFD8Ch */ case    5:  		/* addi R23, R23, 1 */
		/* 820EFD8Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 820EFD8Ch case    5:*/		return 0x820EFD90;
		  /* 820EFD90h */ case    6:  		/* stwu R11, <#[R6 + 4]> */
		/* 820EFD90h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 820EFD90h case    6:*/		return 0x820EFD94;
		  /* 820EFD94h */ case    7:  		/* b 8 */
		/* 820EFD94h case    7:*/		return 0x820EFD9C;
		/* 820EFD94h case    7:*/		return 0x820EFD98;
	}
	return 0x820EFD98;
} // Block from 820EFD78h-820EFD98h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820EFD98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFD98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFD98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFD98);
		  /* 820EFD98h */ case    0:  		/* mr R20, R21 */
		/* 820EFD98h case    0:*/		regs.R20 = regs.R21;
		/* 820EFD98h case    0:*/		return 0x820EFD9C;
	}
	return 0x820EFD9C;
} // Block from 820EFD98h-820EFD9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EFD9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFD9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFD9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFD9C);
		  /* 820EFD9Ch */ case    0:  		/* addi R7, R7, 4 */
		/* 820EFD9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820EFD9Ch case    0:*/		return 0x820EFDA0;
		  /* 820EFDA0h */ case    1:  		/* bc 16, CR0_LT, -112 */
		/* 820EFDA0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EFD30;  }
		/* 820EFDA0h case    1:*/		return 0x820EFDA4;
	}
	return 0x820EFDA4;
} // Block from 820EFD9Ch-820EFDA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EFDA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFDA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFDA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFDA4);
		  /* 820EFDA4h */ case    0:  		/* cmplwi CR6, R30, 2 */
		/* 820EFDA4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000002);
		/* 820EFDA4h case    0:*/		return 0x820EFDA8;
		  /* 820EFDA8h */ case    1:  		/* bc 12, CR6_EQ, -2124 */
		/* 820EFDA8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EFDA8h case    1:*/		return 0x820EFDAC;
		  /* 820EFDACh */ case    2:  		/* addi R24, R1, 128 */
		/* 820EFDACh case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R1,0x80);
		/* 820EFDACh case    2:*/		return 0x820EFDB0;
		  /* 820EFDB0h */ case    3:  		/* mr R30, R22 */
		/* 820EFDB0h case    3:*/		regs.R30 = regs.R22;
		/* 820EFDB0h case    3:*/		return 0x820EFDB4;
	}
	return 0x820EFDB4;
} // Block from 820EFDA4h-820EFDB4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EFDB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFDB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFDB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFDB4);
		  /* 820EFDB4h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820EFDB4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820EFDB4h case    0:*/		return 0x820EFDB8;
		  /* 820EFDB8h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820EFDB8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EFDD4;  }
		/* 820EFDB8h case    1:*/		return 0x820EFDBC;
		  /* 820EFDBCh */ case    2:  		/* mr R3, R29 */
		/* 820EFDBCh case    2:*/		regs.R3 = regs.R29;
		/* 820EFDBCh case    2:*/		return 0x820EFDC0;
		  /* 820EFDC0h */ case    3:  		/* bl 1234432 */
		/* 820EFDC0h case    3:*/		regs.LR = 0x820EFDC4; return 0x8221D3C0;
		/* 820EFDC0h case    3:*/		return 0x820EFDC4;
		  /* 820EFDC4h */ case    4:  		/* mr R3, R29 */
		/* 820EFDC4h case    4:*/		regs.R3 = regs.R29;
		/* 820EFDC4h case    4:*/		return 0x820EFDC8;
		  /* 820EFDC8h */ case    5:  		/* bl 51240 */
		/* 820EFDC8h case    5:*/		regs.LR = 0x820EFDCC; return 0x820FC5F0;
		/* 820EFDC8h case    5:*/		return 0x820EFDCC;
		  /* 820EFDCCh */ case    6:  		/* b 8 */
		/* 820EFDCCh case    6:*/		return 0x820EFDD4;
		/* 820EFDCCh case    6:*/		return 0x820EFDD0;
	}
	return 0x820EFDD0;
} // Block from 820EFDB4h-820EFDD0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EFDD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFDD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFDD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFDD0);
		  /* 820EFDD0h */ case    0:  		/* lwz R28, <#[R1 + 96]> */
		/* 820EFDD0h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000060) );
		/* 820EFDD0h case    0:*/		return 0x820EFDD4;
	}
	return 0x820EFDD4;
} // Block from 820EFDD0h-820EFDD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EFDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFDD4);
		  /* 820EFDD4h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 820EFDD4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820EFDD4h case    0:*/		return 0x820EFDD8;
		  /* 820EFDD8h */ case    1:  		/* bc 12, CR6_EQ, -2040 */
		/* 820EFDD8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EF5E0;  }
		/* 820EFDD8h case    1:*/		return 0x820EFDDC;
		  /* 820EFDDCh */ case    2:  		/* mr R3, R30 */
		/* 820EFDDCh case    2:*/		regs.R3 = regs.R30;
		/* 820EFDDCh case    2:*/		return 0x820EFDE0;
		  /* 820EFDE0h */ case    3:  		/* b 904 */
		/* 820EFDE0h case    3:*/		return 0x820F0168;
		/* 820EFDE0h case    3:*/		return 0x820EFDE4;
	}
	return 0x820EFDE4;
} // Block from 820EFDD4h-820EFDE4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EFDE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFDE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFDE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFDE4);
		  /* 820EFDE4h */ case    0:  		/* mr R20, R21 */
		/* 820EFDE4h case    0:*/		regs.R20 = regs.R21;
		/* 820EFDE4h case    0:*/		return 0x820EFDE8;
	}
	return 0x820EFDE8;
} // Block from 820EFDE4h-820EFDE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EFDE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFDE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFDE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFDE8);
		  /* 820EFDE8h */ case    0:  		/* cmpwi CR6, R20, 0 */
		/* 820EFDE8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 820EFDE8h case    0:*/		return 0x820EFDEC;
		  /* 820EFDECh */ case    1:  		/* bc 4, CR6_EQ, 288 */
		/* 820EFDECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EFF0C;  }
		/* 820EFDECh case    1:*/		return 0x820EFDF0;
		  /* 820EFDF0h */ case    2:  		/* mr R7, R22 */
		/* 820EFDF0h case    2:*/		regs.R7 = regs.R22;
		/* 820EFDF0h case    2:*/		return 0x820EFDF4;
		  /* 820EFDF4h */ case    3:  		/* li R6, -1 */
		/* 820EFDF4h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820EFDF4h case    3:*/		return 0x820EFDF8;
		  /* 820EFDF8h */ case    4:  		/* cmplwi CR6, R25, 0 */
		/* 820EFDF8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820EFDF8h case    4:*/		return 0x820EFDFC;
		  /* 820EFDFCh */ case    5:  		/* bc 12, CR6_EQ, 68 */
		/* 820EFDFCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820EFE40;  }
		/* 820EFDFCh case    5:*/		return 0x820EFE00;
		  /* 820EFE00h */ case    6:  		/* lwz R8, <#[R26 + 20]> */
		/* 820EFE00h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 820EFE00h case    6:*/		return 0x820EFE04;
		  /* 820EFE04h */ case    7:  		/* mr R9, R24 */
		/* 820EFE04h case    7:*/		regs.R9 = regs.R24;
		/* 820EFE04h case    7:*/		return 0x820EFE08;
		  /* 820EFE08h */ case    8:  		/* mtspr CTR, R25 */
		/* 820EFE08h case    8:*/		regs.CTR = regs.R25;
		/* 820EFE08h case    8:*/		return 0x820EFE0C;
		  /* 820EFE0Ch */ case    9:  		/* lwz R11, <#[R9]> */
		/* 820EFE0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820EFE0Ch case    9:*/		return 0x820EFE10;
		  /* 820EFE10h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820EFE10h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820EFE10h case   10:*/		return 0x820EFE14;
		  /* 820EFE14h */ case   11:  		/* lwzx R10, <#[R11 + R8]> */
		/* 820EFE14h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820EFE14h case   11:*/		return 0x820EFE18;
		  /* 820EFE18h */ case   12:  		/* lwz R11, <#[R10 + 88]> */
		/* 820EFE18h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000058) );
		/* 820EFE18h case   12:*/		return 0x820EFE1C;
		  /* 820EFE1Ch */ case   13:  		/* cmplw CR6, R7, R11 */
		/* 820EFE1Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820EFE1Ch case   13:*/		return 0x820EFE20;
		  /* 820EFE20h */ case   14:  		/* bc 4, CR6_LT, 8 */
		/* 820EFE20h case   14:*/		if ( !regs.CR[6].lt ) { return 0x820EFE28;  }
		/* 820EFE20h case   14:*/		return 0x820EFE24;
		  /* 820EFE24h */ case   15:  		/* mr R7, R11 */
		/* 820EFE24h case   15:*/		regs.R7 = regs.R11;
		/* 820EFE24h case   15:*/		return 0x820EFE28;
	}
	return 0x820EFE28;
} // Block from 820EFDE8h-820EFE28h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820EFE28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFE28);
		  /* 820EFE28h */ case    0:  		/* lwz R11, <#[R10 + 84]> */
		/* 820EFE28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000054) );
		/* 820EFE28h case    0:*/		return 0x820EFE2C;
		  /* 820EFE2Ch */ case    1:  		/* cmplw CR6, R6, R11 */
		/* 820EFE2Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820EFE2Ch case    1:*/		return 0x820EFE30;
		  /* 820EFE30h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 820EFE30h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820EFE38;  }
		/* 820EFE30h case    2:*/		return 0x820EFE34;
		  /* 820EFE34h */ case    3:  		/* mr R6, R11 */
		/* 820EFE34h case    3:*/		regs.R6 = regs.R11;
		/* 820EFE34h case    3:*/		return 0x820EFE38;
	}
	return 0x820EFE38;
} // Block from 820EFE28h-820EFE38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820EFE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFE38);
		  /* 820EFE38h */ case    0:  		/* addi R9, R9, 4 */
		/* 820EFE38h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820EFE38h case    0:*/		return 0x820EFE3C;
		  /* 820EFE3Ch */ case    1:  		/* bc 16, CR0_LT, -48 */
		/* 820EFE3Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EFE0C;  }
		/* 820EFE3Ch case    1:*/		return 0x820EFE40;
	}
	return 0x820EFE40;
} // Block from 820EFE38h-820EFE40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EFE40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFE40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFE40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFE40);
		  /* 820EFE40h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 820EFE40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 820EFE40h case    0:*/		return 0x820EFE44;
		  /* 820EFE44h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820EFE44h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EFE44h case    1:*/		return 0x820EFE48;
		  /* 820EFE48h */ case    2:  		/* bc 12, CR6_EQ, 500 */
		/* 820EFE48h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F003C;  }
		/* 820EFE48h case    2:*/		return 0x820EFE4C;
		  /* 820EFE4Ch */ case    3:  		/* lwz R4, <#[R26 + 24]> */
		/* 820EFE4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000018) );
		/* 820EFE4Ch case    3:*/		return 0x820EFE50;
		  /* 820EFE50h */ case    4:  		/* mr R3, R11 */
		/* 820EFE50h case    4:*/		regs.R3 = regs.R11;
		/* 820EFE50h case    4:*/		return 0x820EFE54;
		  /* 820EFE54h */ case    5:  		/* lwz R9, <#[R4]> */
		/* 820EFE54h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000000) );
		/* 820EFE54h case    5:*/		return 0x820EFE58;
		  /* 820EFE58h */ case    6:  		/* lwz R11, <#[R9]> */
		/* 820EFE58h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820EFE58h case    6:*/		return 0x820EFE5C;
		  /* 820EFE5Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820EFE5Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EFE5Ch case    7:*/		return 0x820EFE60;
		  /* 820EFE60h */ case    8:  		/* bc 12, CR6_EQ, 152 */
		/* 820EFE60h case    8:*/		if ( regs.CR[6].eq ) { return 0x820EFEF8;  }
		/* 820EFE60h case    8:*/		return 0x820EFE64;
		  /* 820EFE64h */ case    9:  		/* mr R11, R22 */
		/* 820EFE64h case    9:*/		regs.R11 = regs.R22;
		/* 820EFE64h case    9:*/		return 0x820EFE68;
		  /* 820EFE68h */ case   10:  		/* cmplwi CR6, R28, 0 */
		/* 820EFE68h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EFE68h case   10:*/		return 0x820EFE6C;
		  /* 820EFE6Ch */ case   11:  		/* bc 12, CR6_EQ, 36 */
		/* 820EFE6Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820EFE90;  }
		/* 820EFE6Ch case   11:*/		return 0x820EFE70;
		  /* 820EFE70h */ case   12:  		/* addi R10, R1, 144 */
		/* 820EFE70h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 820EFE70h case   12:*/		return 0x820EFE74;
		  /* 820EFE74h */ case   13:  		/* lwz R8, <#[R10]> */
		/* 820EFE74h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820EFE74h case   13:*/		return 0x820EFE78;
		  /* 820EFE78h */ case   14:  		/* cmplw CR6, R9, R8 */
		/* 820EFE78h case   14:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820EFE78h case   14:*/		return 0x820EFE7C;
		  /* 820EFE7Ch */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 820EFE7Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820EFE90;  }
		/* 820EFE7Ch case   15:*/		return 0x820EFE80;
		  /* 820EFE80h */ case   16:  		/* addi R11, R11, 1 */
		/* 820EFE80h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820EFE80h case   16:*/		return 0x820EFE84;
		  /* 820EFE84h */ case   17:  		/* addi R10, R10, 4 */
		/* 820EFE84h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820EFE84h case   17:*/		return 0x820EFE88;
		  /* 820EFE88h */ case   18:  		/* cmplw CR6, R11, R28 */
		/* 820EFE88h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 820EFE88h case   18:*/		return 0x820EFE8C;
		  /* 820EFE8Ch */ case   19:  		/* bc 12, CR6_LT, -24 */
		/* 820EFE8Ch case   19:*/		if ( regs.CR[6].lt ) { return 0x820EFE74;  }
		/* 820EFE8Ch case   19:*/		return 0x820EFE90;
	}
	return 0x820EFE90;
} // Block from 820EFE40h-820EFE90h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820EFE90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFE90);
		  /* 820EFE90h */ case    0:  		/* cmplw CR6, R11, R28 */
		/* 820EFE90h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 820EFE90h case    0:*/		return 0x820EFE94;
		  /* 820EFE94h */ case    1:  		/* bc 4, CR6_EQ, 100 */
		/* 820EFE94h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820EFEF8;  }
		/* 820EFE94h case    1:*/		return 0x820EFE98;
		  /* 820EFE98h */ case    2:  		/* lwz R11, <#[R9 + 4]> */
		/* 820EFE98h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 820EFE98h case    2:*/		return 0x820EFE9C;
		  /* 820EFE9Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820EFE9Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820EFE9Ch case    3:*/		return 0x820EFEA0;
		  /* 820EFEA0h */ case    4:  		/* bc 12, CR6_EQ, 88 */
		/* 820EFEA0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820EFEF8;  }
		/* 820EFEA0h case    4:*/		return 0x820EFEA4;
		  /* 820EFEA4h */ case    5:  		/* lwz R5, <#[R26 + 20]> */
		/* 820EFEA4h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x00000014) );
		/* 820EFEA4h case    5:*/		return 0x820EFEA8;
		  /* 820EFEA8h */ case    6:  		/* lwz R8, <#[R9 + 8]> */
		/* 820EFEA8h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000008) );
		/* 820EFEA8h case    6:*/		return 0x820EFEAC;
		  /* 820EFEACh */ case    7:  		/* lwz R9, <#[R8]> */
		/* 820EFEACh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 820EFEACh case    7:*/		return 0x820EFEB0;
		  /* 820EFEB0h */ case    8:  		/* cmplwi CR6, R25, 0 */
		/* 820EFEB0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820EFEB0h case    8:*/		return 0x820EFEB4;
		  /* 820EFEB4h */ case    9:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 820EFEB4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 820EFEB4h case    9:*/		return 0x820EFEB8;
		  /* 820EFEB8h */ case   10:  		/* lwzx R6, <#[R10 + R5]> */
		/* 820EFEB8h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820EFEB8h case   10:*/		return 0x820EFEBC;
		  /* 820EFEBCh */ case   11:  		/* bc 12, CR6_EQ, 48 */
		/* 820EFEBCh case   11:*/		if ( regs.CR[6].eq ) { return 0x820EFEEC;  }
		/* 820EFEBCh case   11:*/		return 0x820EFEC0;
		  /* 820EFEC0h */ case   12:  		/* mr R7, R24 */
		/* 820EFEC0h case   12:*/		regs.R7 = regs.R24;
		/* 820EFEC0h case   12:*/		return 0x820EFEC4;
		  /* 820EFEC4h */ case   13:  		/* mtspr CTR, R25 */
		/* 820EFEC4h case   13:*/		regs.CTR = regs.R25;
		/* 820EFEC4h case   13:*/		return 0x820EFEC8;
		  /* 820EFEC8h */ case   14:  		/* lwz R10, <#[R7]> */
		/* 820EFEC8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 820EFEC8h case   14:*/		return 0x820EFECC;
		  /* 820EFECCh */ case   15:  		/* cmplw CR6, R10, R9 */
		/* 820EFECCh case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820EFECCh case   15:*/		return 0x820EFED0;
		  /* 820EFED0h */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 820EFED0h case   16:*/		if ( regs.CR[6].eq ) { return 0x820EFEE0;  }
		/* 820EFED0h case   16:*/		return 0x820EFED4;
		  /* 820EFED4h */ case   17:  		/* lwz R31, <#[R6 + 56]> */
		/* 820EFED4h case   17:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R6 + 0x00000038) );
		/* 820EFED4h case   17:*/		return 0x820EFED8;
		  /* 820EFED8h */ case   18:  		/* cmplw CR6, R31, R10 */
		/* 820EFED8h case   18:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 820EFED8h case   18:*/		return 0x820EFEDC;
		  /* 820EFEDCh */ case   19:  		/* bc 4, CR6_EQ, 8 */
		/* 820EFEDCh case   19:*/		if ( !regs.CR[6].eq ) { return 0x820EFEE4;  }
		/* 820EFEDCh case   19:*/		return 0x820EFEE0;
	}
	return 0x820EFEE0;
} // Block from 820EFE90h-820EFEE0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820EFEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFEE0);
		  /* 820EFEE0h */ case    0:  		/* mr R20, R21 */
		/* 820EFEE0h case    0:*/		regs.R20 = regs.R21;
		/* 820EFEE0h case    0:*/		return 0x820EFEE4;
	}
	return 0x820EFEE4;
} // Block from 820EFEE0h-820EFEE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EFEE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFEE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFEE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFEE4);
		  /* 820EFEE4h */ case    0:  		/* addi R7, R7, 4 */
		/* 820EFEE4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820EFEE4h case    0:*/		return 0x820EFEE8;
		  /* 820EFEE8h */ case    1:  		/* bc 16, CR0_LT, -32 */
		/* 820EFEE8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EFEC8;  }
		/* 820EFEE8h case    1:*/		return 0x820EFEEC;
	}
	return 0x820EFEEC;
} // Block from 820EFEE4h-820EFEECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820EFEECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFEEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFEEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFEEC);
		  /* 820EFEECh */ case    0:  		/* addic. R11, R11, -1 */
		/* 820EFEECh case    0:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820EFEECh case    0:*/		return 0x820EFEF0;
		  /* 820EFEF0h */ case    1:  		/* addi R8, R8, 4 */
		/* 820EFEF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820EFEF0h case    1:*/		return 0x820EFEF4;
		  /* 820EFEF4h */ case    2:  		/* bc 4, CR0_EQ, -72 */
		/* 820EFEF4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820EFEAC;  }
		/* 820EFEF4h case    2:*/		return 0x820EFEF8;
	}
	return 0x820EFEF8;
} // Block from 820EFEECh-820EFEF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820EFEF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFEF8);
		  /* 820EFEF8h */ case    0:  		/* addic. R3, R3, -1 */
		/* 820EFEF8h case    0:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0xFFFFFFFF);
		/* 820EFEF8h case    0:*/		return 0x820EFEFC;
		  /* 820EFEFCh */ case    1:  		/* addi R4, R4, 4 */
		/* 820EFEFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 820EFEFCh case    1:*/		return 0x820EFF00;
		  /* 820EFF00h */ case    2:  		/* bc 4, CR0_EQ, -172 */
		/* 820EFF00h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820EFE54;  }
		/* 820EFF00h case    2:*/		return 0x820EFF04;
		  /* 820EFF04h */ case    3:  		/* cmpwi CR6, R20, 0 */
		/* 820EFF04h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 820EFF04h case    3:*/		return 0x820EFF08;
		  /* 820EFF08h */ case    4:  		/* bc 12, CR6_EQ, 308 */
		/* 820EFF08h case    4:*/		if ( regs.CR[6].eq ) { return 0x820F003C;  }
		/* 820EFF08h case    4:*/		return 0x820EFF0C;
	}
	return 0x820EFF0C;
} // Block from 820EFEF8h-820EFF0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820EFF0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFF0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFF0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFF0C);
		  /* 820EFF0Ch */ case    0:  		/* li R3, 116 */
		/* 820EFF0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 820EFF0Ch case    0:*/		return 0x820EFF10;
		  /* 820EFF10h */ case    1:  		/* bl 50824 */
		/* 820EFF10h case    1:*/		regs.LR = 0x820EFF14; return 0x820FC598;
		/* 820EFF10h case    1:*/		return 0x820EFF14;
		  /* 820EFF14h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820EFF14h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820EFF14h case    2:*/		return 0x820EFF18;
		  /* 820EFF18h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820EFF18h case    3:*/		if ( regs.CR[0].eq ) { return 0x820EFF28;  }
		/* 820EFF18h case    3:*/		return 0x820EFF1C;
		  /* 820EFF1Ch */ case    4:  		/* bl 49028 */
		/* 820EFF1Ch case    4:*/		regs.LR = 0x820EFF20; return 0x820FBEA0;
		/* 820EFF1Ch case    4:*/		return 0x820EFF20;
		  /* 820EFF20h */ case    5:  		/* mr R31, R3 */
		/* 820EFF20h case    5:*/		regs.R31 = regs.R3;
		/* 820EFF20h case    5:*/		return 0x820EFF24;
		  /* 820EFF24h */ case    6:  		/* b 8 */
		/* 820EFF24h case    6:*/		return 0x820EFF2C;
		/* 820EFF24h case    6:*/		return 0x820EFF28;
	}
	return 0x820EFF28;
} // Block from 820EFF0Ch-820EFF28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820EFF28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFF28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFF28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFF28);
		  /* 820EFF28h */ case    0:  		/* mr R31, R22 */
		/* 820EFF28h case    0:*/		regs.R31 = regs.R22;
		/* 820EFF28h case    0:*/		return 0x820EFF2C;
	}
	return 0x820EFF2C;
} // Block from 820EFF28h-820EFF2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820EFF2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFF2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFF2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFF2C);
		  /* 820EFF2Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820EFF2Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820EFF2Ch case    0:*/		return 0x820EFF30;
		  /* 820EFF30h */ case    1:  		/* bc 12, CR6_EQ, -2516 */
		/* 820EFF30h case    1:*/		if ( regs.CR[6].eq ) { return 0x820EF55C;  }
		/* 820EFF30h case    1:*/		return 0x820EFF34;
		  /* 820EFF34h */ case    2:  		/* mr R4, R25 */
		/* 820EFF34h case    2:*/		regs.R4 = regs.R25;
		/* 820EFF34h case    2:*/		return 0x820EFF38;
		  /* 820EFF38h */ case    3:  		/* li R7, 0 */
		/* 820EFF38h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820EFF38h case    3:*/		return 0x820EFF3C;
		  /* 820EFF3Ch */ case    4:  		/* rlwimi R4, R21, 28, 0, 11 */
		/* 820EFF3Ch case    4:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R21);
		/* 820EFF3Ch case    4:*/		return 0x820EFF40;
		  /* 820EFF40h */ case    5:  		/* mr R6, R25 */
		/* 820EFF40h case    5:*/		regs.R6 = regs.R25;
		/* 820EFF40h case    5:*/		return 0x820EFF44;
		  /* 820EFF44h */ case    6:  		/* mr R5, R25 */
		/* 820EFF44h case    6:*/		regs.R5 = regs.R25;
		/* 820EFF44h case    6:*/		return 0x820EFF48;
		  /* 820EFF48h */ case    7:  		/* mr R3, R31 */
		/* 820EFF48h case    7:*/		regs.R3 = regs.R31;
		/* 820EFF48h case    7:*/		return 0x820EFF4C;
		  /* 820EFF4Ch */ case    8:  		/* bl 50916 */
		/* 820EFF4Ch case    8:*/		regs.LR = 0x820EFF50; return 0x820FC630;
		/* 820EFF4Ch case    8:*/		return 0x820EFF50;
		  /* 820EFF50h */ case    9:  		/* or. R30, R3, R3 */
		/* 820EFF50h case    9:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820EFF50h case    9:*/		return 0x820EFF54;
		  /* 820EFF54h */ case   10:  		/* mr R3, R31 */
		/* 820EFF54h case   10:*/		regs.R3 = regs.R31;
		/* 820EFF54h case   10:*/		return 0x820EFF58;
		  /* 820EFF58h */ case   11:  		/* bc 4, CR0_LT, 20 */
		/* 820EFF58h case   11:*/		if ( !regs.CR[0].lt ) { return 0x820EFF6C;  }
		/* 820EFF58h case   11:*/		return 0x820EFF5C;
		  /* 820EFF5Ch */ case   12:  		/* bl 1234020 */
		/* 820EFF5Ch case   12:*/		regs.LR = 0x820EFF60; return 0x8221D3C0;
		/* 820EFF5Ch case   12:*/		return 0x820EFF60;
		  /* 820EFF60h */ case   13:  		/* mr R3, R31 */
		/* 820EFF60h case   13:*/		regs.R3 = regs.R31;
		/* 820EFF60h case   13:*/		return 0x820EFF64;
		  /* 820EFF64h */ case   14:  		/* bl 50828 */
		/* 820EFF64h case   14:*/		regs.LR = 0x820EFF68; return 0x820FC5F0;
		/* 820EFF64h case   14:*/		return 0x820EFF68;
		  /* 820EFF68h */ case   15:  		/* b -396 */
		/* 820EFF68h case   15:*/		return 0x820EFDDC;
		/* 820EFF68h case   15:*/		return 0x820EFF6C;
	}
	return 0x820EFF6C;
} // Block from 820EFF2Ch-820EFF6Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 820EFF6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFF6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFF6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFF6C);
		  /* 820EFF6Ch */ case    0:  		/* lwz R4, <#[R26 + 260]> */
		/* 820EFF6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000104) );
		/* 820EFF6Ch case    0:*/		return 0x820EFF70;
		  /* 820EFF70h */ case    1:  		/* bl 49024 */
		/* 820EFF70h case    1:*/		regs.LR = 0x820EFF74; return 0x820FBEF0;
		/* 820EFF70h case    1:*/		return 0x820EFF74;
		  /* 820EFF74h */ case    2:  		/* or. R30, R3, R3 */
		/* 820EFF74h case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820EFF74h case    2:*/		return 0x820EFF78;
		  /* 820EFF78h */ case    3:  		/* bc 4, CR0_LT, 12 */
		/* 820EFF78h case    3:*/		if ( !regs.CR[0].lt ) { return 0x820EFF84;  }
		/* 820EFF78h case    3:*/		return 0x820EFF7C;
		  /* 820EFF7Ch */ case    4:  		/* mr R3, R31 */
		/* 820EFF7Ch case    4:*/		regs.R3 = regs.R31;
		/* 820EFF7Ch case    4:*/		return 0x820EFF80;
		  /* 820EFF80h */ case    5:  		/* b -36 */
		/* 820EFF80h case    5:*/		return 0x820EFF5C;
		/* 820EFF80h case    5:*/		return 0x820EFF84;
	}
	return 0x820EFF84;
} // Block from 820EFF6Ch-820EFF84h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820EFF84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFF84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFF84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFF84);
		  /* 820EFF84h */ case    0:  		/* rlwinm R30, R25, 2, 0, 29 */
		/* 820EFF84h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R25);
		/* 820EFF84h case    0:*/		return 0x820EFF88;
		  /* 820EFF88h */ case    1:  		/* lwz R3, <#[R31 + 8]> */
		/* 820EFF88h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820EFF88h case    1:*/		return 0x820EFF8C;
		  /* 820EFF8Ch */ case    2:  		/* mr R4, R24 */
		/* 820EFF8Ch case    2:*/		regs.R4 = regs.R24;
		/* 820EFF8Ch case    2:*/		return 0x820EFF90;
		  /* 820EFF90h */ case    3:  		/* mr R5, R30 */
		/* 820EFF90h case    3:*/		regs.R5 = regs.R30;
		/* 820EFF90h case    3:*/		return 0x820EFF94;
		  /* 820EFF94h */ case    4:  		/* bl -386532 */
		/* 820EFF94h case    4:*/		regs.LR = 0x820EFF98; return 0x820919B0;
		/* 820EFF94h case    4:*/		return 0x820EFF98;
		  /* 820EFF98h */ case    5:  		/* lwz R11, <#[R26 + 260]> */
		/* 820EFF98h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000104) );
		/* 820EFF98h case    5:*/		return 0x820EFF9C;
		  /* 820EFF9Ch */ case    6:  		/* mr R5, R30 */
		/* 820EFF9Ch case    6:*/		regs.R5 = regs.R30;
		/* 820EFF9Ch case    6:*/		return 0x820EFFA0;
		  /* 820EFFA0h */ case    7:  		/* lwz R3, <#[R31 + 16]> */
		/* 820EFFA0h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820EFFA0h case    7:*/		return 0x820EFFA4;
		  /* 820EFFA4h */ case    8:  		/* lwz R4, <#[R11 + 16]> */
		/* 820EFFA4h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000010) );
		/* 820EFFA4h case    8:*/		return 0x820EFFA8;
		  /* 820EFFA8h */ case    9:  		/* bl -386552 */
		/* 820EFFA8h case    9:*/		regs.LR = 0x820EFFAC; return 0x820919B0;
		/* 820EFFA8h case    9:*/		return 0x820EFFAC;
		  /* 820EFFACh */ case   10:  		/* cmplwi CR6, R25, 0 */
		/* 820EFFACh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820EFFACh case   10:*/		return 0x820EFFB0;
		  /* 820EFFB0h */ case   11:  		/* bc 12, CR6_EQ, 52 */
		/* 820EFFB0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820EFFE4;  }
		/* 820EFFB0h case   11:*/		return 0x820EFFB4;
		  /* 820EFFB4h */ case   12:  		/* mtspr CTR, R25 */
		/* 820EFFB4h case   12:*/		regs.CTR = regs.R25;
		/* 820EFFB4h case   12:*/		return 0x820EFFB8;
		  /* 820EFFB8h */ case   13:  		/* mr R11, R22 */
		/* 820EFFB8h case   13:*/		regs.R11 = regs.R22;
		/* 820EFFB8h case   13:*/		return 0x820EFFBC;
		  /* 820EFFBCh */ case   14:  		/* lwz R10, <#[R31 + 16]> */
		/* 820EFFBCh case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820EFFBCh case   14:*/		return 0x820EFFC0;
		  /* 820EFFC0h */ case   15:  		/* lwz R9, <#[R26 + 20]> */
		/* 820EFFC0h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000014) );
		/* 820EFFC0h case   15:*/		return 0x820EFFC4;
		  /* 820EFFC4h */ case   16:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820EFFC4h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820EFFC4h case   16:*/		return 0x820EFFC8;
		  /* 820EFFC8h */ case   17:  		/* addi R11, R11, 4 */
		/* 820EFFC8h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820EFFC8h case   17:*/		return 0x820EFFCC;
		  /* 820EFFCCh */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820EFFCCh case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820EFFCCh case   18:*/		return 0x820EFFD0;
		  /* 820EFFD0h */ case   19:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820EFFD0h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820EFFD0h case   19:*/		return 0x820EFFD4;
		  /* 820EFFD4h */ case   20:  		/* lwz R9, <#[R10 + 60]> */
		/* 820EFFD4h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000003C) );
		/* 820EFFD4h case   20:*/		return 0x820EFFD8;
		  /* 820EFFD8h */ case   21:  		/* ori R9, R9, 512 */
		/* 820EFFD8h case   21:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x200);
		/* 820EFFD8h case   21:*/		return 0x820EFFDC;
		  /* 820EFFDCh */ case   22:  		/* stw R9, <#[R10 + 60]> */
		/* 820EFFDCh case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000003C) );
		/* 820EFFDCh case   22:*/		return 0x820EFFE0;
		  /* 820EFFE0h */ case   23:  		/* bc 16, CR0_LT, -36 */
		/* 820EFFE0h case   23:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EFFBC;  }
		/* 820EFFE0h case   23:*/		return 0x820EFFE4;
	}
	return 0x820EFFE4;
} // Block from 820EFF84h-820EFFE4h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820EFFE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820EFFE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820EFFE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820EFFE4);
		  /* 820EFFE4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820EFFE4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820EFFE4h case    0:*/		return 0x820EFFE8;
		  /* 820EFFE8h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820EFFE8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F0000;  }
		/* 820EFFE8h case    1:*/		return 0x820EFFEC;
		  /* 820EFFECh */ case    2:  		/* addi R11, R1, 140 */
		/* 820EFFECh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x8C);
		/* 820EFFECh case    2:*/		return 0x820EFFF0;
		  /* 820EFFF0h */ case    3:  		/* mtspr CTR, R28 */
		/* 820EFFF0h case    3:*/		regs.CTR = regs.R28;
		/* 820EFFF0h case    3:*/		return 0x820EFFF4;
		  /* 820EFFF4h */ case    4:  		/* lwzu R10, <#[R11 + 4]> */
		/* 820EFFF4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820EFFF4h case    4:*/		return 0x820EFFF8;
		  /* 820EFFF8h */ case    5:  		/* stw R22, <#[R10]> */
		/* 820EFFF8h case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R10 + 0x00000000) );
		/* 820EFFF8h case    5:*/		return 0x820EFFFC;
		  /* 820EFFFCh */ case    6:  		/* bc 16, CR0_LT, -8 */
		/* 820EFFFCh case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820EFFF4;  }
		/* 820EFFFCh case    6:*/		return 0x820F0000;
	}
	return 0x820F0000;
} // Block from 820EFFE4h-820F0000h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F0000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0000);
		  /* 820F0000h */ case    0:  		/* lwz R11, <#[R26 + 256]> */
		/* 820F0000h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000100) );
		/* 820F0000h case    0:*/		return 0x820F0004;
		  /* 820F0004h */ case    1:  		/* lwz R10, <#[R26 + 24]> */
		/* 820F0004h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000018) );
		/* 820F0004h case    1:*/		return 0x820F0008;
		  /* 820F0008h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F0008h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F0008h case    2:*/		return 0x820F000C;
		  /* 820F000Ch */ case    3:  		/* lwzx R30, <#[R11 + R10]> */
		/* 820F000Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F000Ch case    3:*/		return 0x820F0010;
		  /* 820F0010h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 820F0010h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F0010h case    4:*/		return 0x820F0014;
		  /* 820F0014h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820F0014h case    5:*/		if ( regs.CR[6].eq ) { return 0x820F0028;  }
		/* 820F0014h case    5:*/		return 0x820F0018;
		  /* 820F0018h */ case    6:  		/* mr R3, R30 */
		/* 820F0018h case    6:*/		regs.R3 = regs.R30;
		/* 820F0018h case    6:*/		return 0x820F001C;
		  /* 820F001Ch */ case    7:  		/* bl 1233828 */
		/* 820F001Ch case    7:*/		regs.LR = 0x820F0020; return 0x8221D3C0;
		/* 820F001Ch case    7:*/		return 0x820F0020;
		  /* 820F0020h */ case    8:  		/* mr R3, R30 */
		/* 820F0020h case    8:*/		regs.R3 = regs.R30;
		/* 820F0020h case    8:*/		return 0x820F0024;
		  /* 820F0024h */ case    9:  		/* bl 50636 */
		/* 820F0024h case    9:*/		regs.LR = 0x820F0028; return 0x820FC5F0;
		/* 820F0024h case    9:*/		return 0x820F0028;
	}
	return 0x820F0028;
} // Block from 820F0000h-820F0028h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F0028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0028);
		  /* 820F0028h */ case    0:  		/* lwz R11, <#[R26 + 256]> */
		/* 820F0028h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000100) );
		/* 820F0028h case    0:*/		return 0x820F002C;
		  /* 820F002Ch */ case    1:  		/* lwz R10, <#[R26 + 24]> */
		/* 820F002Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000018) );
		/* 820F002Ch case    1:*/		return 0x820F0030;
		  /* 820F0030h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F0030h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F0030h case    2:*/		return 0x820F0034;
		  /* 820F0034h */ case    3:  		/* stwx R31, <#[R11 + R10]> */
		/* 820F0034h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F0034h case    3:*/		return 0x820F0038;
		  /* 820F0038h */ case    4:  		/* b 300 */
		/* 820F0038h case    4:*/		return 0x820F0164;
		/* 820F0038h case    4:*/		return 0x820F003C;
	}
	return 0x820F003C;
} // Block from 820F0028h-820F003Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F003Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F003C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F003C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F003C);
		  /* 820F003Ch */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 820F003Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820F003Ch case    0:*/		return 0x820F0040;
		  /* 820F0040h */ case    1:  		/* bc 12, CR6_EQ, 252 */
		/* 820F0040h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F013C;  }
		/* 820F0040h case    1:*/		return 0x820F0044;
		  /* 820F0044h */ case    2:  		/* addi R3, R1, 112 */
		/* 820F0044h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 820F0044h case    2:*/		return 0x820F0048;
		  /* 820F0048h */ case    3:  		/* mr R31, R23 */
		/* 820F0048h case    3:*/		regs.R31 = regs.R23;
		/* 820F0048h case    3:*/		return 0x820F004C;
		  /* 820F004Ch */ case    4:  		/* lwz R7, <#[R3]> */
		/* 820F004Ch case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000000) );
		/* 820F004Ch case    4:*/		return 0x820F0050;
		  /* 820F0050h */ case    5:  		/* mr R6, R22 */
		/* 820F0050h case    5:*/		regs.R6 = regs.R22;
		/* 820F0050h case    5:*/		return 0x820F0054;
		  /* 820F0054h */ case    6:  		/* lwz R11, <#[R26 + 260]> */
		/* 820F0054h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000104) );
		/* 820F0054h case    6:*/		return 0x820F0058;
		  /* 820F0058h */ case    7:  		/* lwz R10, <#[R26 + 24]> */
		/* 820F0058h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000018) );
		/* 820F0058h case    7:*/		return 0x820F005C;
		  /* 820F005Ch */ case    8:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 820F005Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 820F005Ch case    8:*/		return 0x820F0060;
		  /* 820F0060h */ case    9:  		/* lwz R4, <#[R11 + 12]> */
		/* 820F0060h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F0060h case    9:*/		return 0x820F0064;
		  /* 820F0064h */ case   10:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820F0064h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820F0064h case   10:*/		return 0x820F0068;
		  /* 820F0068h */ case   11:  		/* cmplwi CR6, R4, 0 */
		/* 820F0068h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F0068h case   11:*/		return 0x820F006C;
		  /* 820F006Ch */ case   12:  		/* bc 12, CR6_EQ, 156 */
		/* 820F006Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820F0108;  }
		/* 820F006Ch case   12:*/		return 0x820F0070;
		  /* 820F0070h */ case   13:  		/* lwz R11, <#[R10 + 12]> */
		/* 820F0070h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F0070h case   13:*/		return 0x820F0074;
		  /* 820F0074h */ case   14:  		/* mr R5, R22 */
		/* 820F0074h case   14:*/		regs.R5 = regs.R22;
		/* 820F0074h case   14:*/		return 0x820F0078;
		  /* 820F0078h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 820F0078h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F0078h case   15:*/		return 0x820F007C;
		  /* 820F007Ch */ case   16:  		/* bc 4, CR6_GT, 128 */
		/* 820F007Ch case   16:*/		if ( !regs.CR[6].gt ) { return 0x820F00FC;  }
		/* 820F007Ch case   16:*/		return 0x820F0080;
		  /* 820F0080h */ case   17:  		/* rlwinm R8, R6, 2, 0, 29 */
		/* 820F0080h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R6);
		/* 820F0080h case   17:*/		return 0x820F0084;
		  /* 820F0084h */ case   18:  		/* mr R11, R22 */
		/* 820F0084h case   18:*/		regs.R11 = regs.R22;
		/* 820F0084h case   18:*/		return 0x820F0088;
		  /* 820F0088h */ case   19:  		/* lwz R9, <#[R10 + 16]> */
		/* 820F0088h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 820F0088h case   19:*/		return 0x820F008C;
		  /* 820F008Ch */ case   20:  		/* lwzx R30, <#[R8 + R24]> */
		/* 820F008Ch case   20:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R8 + regs.R24 + 0x00000000) );
		/* 820F008Ch case   20:*/		return 0x820F0090;
		  /* 820F0090h */ case   21:  		/* lwzx R9, <#[R11 + R9]> */
		/* 820F0090h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F0090h case   21:*/		return 0x820F0094;
		  /* 820F0094h */ case   22:  		/* cmplw CR6, R9, R30 */
		/* 820F0094h case   22:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R30);
		/* 820F0094h case   22:*/		return 0x820F0098;
		  /* 820F0098h */ case   23:  		/* bc 4, CR6_EQ, 80 */
		/* 820F0098h case   23:*/		if ( !regs.CR[6].eq ) { return 0x820F00E8;  }
		/* 820F0098h case   23:*/		return 0x820F009C;
		  /* 820F009Ch */ case   24:  		/* lwz R9, <#[R26 + 260]> */
		/* 820F009Ch case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000104) );
		/* 820F009Ch case   24:*/		return 0x820F00A0;
		  /* 820F00A0h */ case   25:  		/* lwz R30, <#[R10 + 16]> */
		/* 820F00A0h case   25:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x00000010) );
		/* 820F00A0h case   25:*/		return 0x820F00A4;
		  /* 820F00A4h */ case   26:  		/* lwz R9, <#[R9 + 16]> */
		/* 820F00A4h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000010) );
		/* 820F00A4h case   26:*/		return 0x820F00A8;
		  /* 820F00A8h */ case   27:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820F00A8h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820F00A8h case   27:*/		return 0x820F00AC;
		  /* 820F00ACh */ case   28:  		/* stwx R9, <#[R11 + R30]> */
		/* 820F00ACh case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820F00ACh case   28:*/		return 0x820F00B0;
		  /* 820F00B0h */ case   29:  		/* lwz R9, <#[R10 + 16]> */
		/* 820F00B0h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 820F00B0h case   29:*/		return 0x820F00B4;
		  /* 820F00B4h */ case   30:  		/* lwz R30, <#[R26 + 20]> */
		/* 820F00B4h case   30:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000014) );
		/* 820F00B4h case   30:*/		return 0x820F00B8;
		  /* 820F00B8h */ case   31:  		/* lwzx R9, <#[R11 + R9]> */
		/* 820F00B8h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F00B8h case   31:*/		return 0x820F00BC;
		  /* 820F00BCh */ case   32:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F00BCh case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F00BCh case   32:*/		return 0x820F00C0;
		  /* 820F00C0h */ case   33:  		/* lwzx R9, <#[R9 + R30]> */
		/* 820F00C0h case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 820F00C0h case   33:*/		return 0x820F00C4;
		  /* 820F00C4h */ case   34:  		/* lwz R30, <#[R9 + 60]> */
		/* 820F00C4h case   34:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x0000003C) );
		/* 820F00C4h case   34:*/		return 0x820F00C8;
		  /* 820F00C8h */ case   35:  		/* ori R30, R30, 512 */
		/* 820F00C8h case   35:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x200);
		/* 820F00C8h case   35:*/		return 0x820F00CC;
		  /* 820F00CCh */ case   36:  		/* stw R30, <#[R9 + 60]> */
		/* 820F00CCh case   36:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R9 + 0x0000003C) );
		/* 820F00CCh case   36:*/		return 0x820F00D0;
		  /* 820F00D0h */ case   37:  		/* lwz R9, <#[R10 + 16]> */
		/* 820F00D0h case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 820F00D0h case   37:*/		return 0x820F00D4;
		  /* 820F00D4h */ case   38:  		/* lwz R30, <#[R26 + 20]> */
		/* 820F00D4h case   38:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000014) );
		/* 820F00D4h case   38:*/		return 0x820F00D8;
		  /* 820F00D8h */ case   39:  		/* lwzx R9, <#[R11 + R9]> */
		/* 820F00D8h case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F00D8h case   39:*/		return 0x820F00DC;
		  /* 820F00DCh */ case   40:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F00DCh case   40:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F00DCh case   40:*/		return 0x820F00E0;
		  /* 820F00E0h */ case   41:  		/* lwzx R9, <#[R9 + R30]> */
		/* 820F00E0h case   41:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 820F00E0h case   41:*/		return 0x820F00E4;
		  /* 820F00E4h */ case   42:  		/* stw R7, <#[R9 + 72]> */
		/* 820F00E4h case   42:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000048) );
		/* 820F00E4h case   42:*/		return 0x820F00E8;
	}
	return 0x820F00E8;
} // Block from 820F003Ch-820F00E8h (43 instructions)

//////////////////////////////////////////////////////
// Block at 820F00E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F00E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F00E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F00E8);
		  /* 820F00E8h */ case    0:  		/* lwz R9, <#[R10 + 12]> */
		/* 820F00E8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F00E8h case    0:*/		return 0x820F00EC;
		  /* 820F00ECh */ case    1:  		/* addi R5, R5, 1 */
		/* 820F00ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820F00ECh case    1:*/		return 0x820F00F0;
		  /* 820F00F0h */ case    2:  		/* addi R11, R11, 4 */
		/* 820F00F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F00F0h case    2:*/		return 0x820F00F4;
		  /* 820F00F4h */ case    3:  		/* cmplw CR6, R5, R9 */
		/* 820F00F4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R9);
		/* 820F00F4h case    3:*/		return 0x820F00F8;
		  /* 820F00F8h */ case    4:  		/* bc 12, CR6_LT, -112 */
		/* 820F00F8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F0088;  }
		/* 820F00F8h case    4:*/		return 0x820F00FC;
	}
	return 0x820F00FC;
} // Block from 820F00E8h-820F00FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F00FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F00FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F00FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F00FC);
		  /* 820F00FCh */ case    0:  		/* addi R6, R6, 1 */
		/* 820F00FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820F00FCh case    0:*/		return 0x820F0100;
		  /* 820F0100h */ case    1:  		/* cmplw CR6, R6, R4 */
		/* 820F0100h case    1:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R4);
		/* 820F0100h case    1:*/		return 0x820F0104;
		  /* 820F0104h */ case    2:  		/* bc 12, CR6_LT, -148 */
		/* 820F0104h case    2:*/		if ( regs.CR[6].lt ) { return 0x820F0070;  }
		/* 820F0104h case    2:*/		return 0x820F0108;
	}
	return 0x820F0108;
} // Block from 820F00FCh-820F0108h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F0108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0108);
		  /* 820F0108h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820F0108h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820F0108h case    0:*/		return 0x820F010C;
		  /* 820F010Ch */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 820F010Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820F0130;  }
		/* 820F010Ch case    1:*/		return 0x820F0110;
		  /* 820F0110h */ case    2:  		/* addi R11, R1, 144 */
		/* 820F0110h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 820F0110h case    2:*/		return 0x820F0114;
		  /* 820F0114h */ case    3:  		/* mtspr CTR, R28 */
		/* 820F0114h case    3:*/		regs.CTR = regs.R28;
		/* 820F0114h case    3:*/		return 0x820F0118;
		  /* 820F0118h */ case    4:  		/* lwz R9, <#[R11]> */
		/* 820F0118h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820F0118h case    4:*/		return 0x820F011C;
		  /* 820F011Ch */ case    5:  		/* cmplw CR6, R10, R9 */
		/* 820F011Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F011Ch case    5:*/		return 0x820F0120;
		  /* 820F0120h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 820F0120h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820F0128;  }
		/* 820F0120h case    6:*/		return 0x820F0124;
		  /* 820F0124h */ case    7:  		/* stw R22, <#[R11]> */
		/* 820F0124h case    7:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000000) );
		/* 820F0124h case    7:*/		return 0x820F0128;
	}
	return 0x820F0128;
} // Block from 820F0108h-820F0128h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F0128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0128);
		  /* 820F0128h */ case    0:  		/* addi R11, R11, 4 */
		/* 820F0128h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F0128h case    0:*/		return 0x820F012C;
		  /* 820F012Ch */ case    1:  		/* bc 16, CR0_LT, -20 */
		/* 820F012Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F0118;  }
		/* 820F012Ch case    1:*/		return 0x820F0130;
	}
	return 0x820F0130;
} // Block from 820F0128h-820F0130h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F0130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0130);
		  /* 820F0130h */ case    0:  		/* addic. R31, R31, -1 */
		/* 820F0130h case    0:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 820F0130h case    0:*/		return 0x820F0134;
		  /* 820F0134h */ case    1:  		/* addi R3, R3, 4 */
		/* 820F0134h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 820F0134h case    1:*/		return 0x820F0138;
		  /* 820F0138h */ case    2:  		/* bc 4, CR0_EQ, -236 */
		/* 820F0138h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820F004C;  }
		/* 820F0138h case    2:*/		return 0x820F013C;
	}
	return 0x820F013C;
} // Block from 820F0130h-820F013Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F013Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F013C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F013C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F013C);
		  /* 820F013Ch */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820F013Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820F013Ch case    0:*/		return 0x820F0140;
		  /* 820F0140h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 820F0140h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F0164;  }
		/* 820F0140h case    1:*/		return 0x820F0144;
		  /* 820F0144h */ case    2:  		/* addi R10, R1, 144 */
		/* 820F0144h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 820F0144h case    2:*/		return 0x820F0148;
		  /* 820F0148h */ case    3:  		/* mtspr CTR, R28 */
		/* 820F0148h case    3:*/		regs.CTR = regs.R28;
		/* 820F0148h case    3:*/		return 0x820F014C;
		  /* 820F014Ch */ case    4:  		/* lwz R11, <#[R10]> */
		/* 820F014Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F014Ch case    4:*/		return 0x820F0150;
		  /* 820F0150h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820F0150h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F0150h case    5:*/		return 0x820F0154;
		  /* 820F0154h */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 820F0154h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F015C;  }
		/* 820F0154h case    6:*/		return 0x820F0158;
		  /* 820F0158h */ case    7:  		/* stw R22, <#[R11]> */
		/* 820F0158h case    7:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000000) );
		/* 820F0158h case    7:*/		return 0x820F015C;
	}
	return 0x820F015C;
} // Block from 820F013Ch-820F015Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F015Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F015C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F015C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F015C);
		  /* 820F015Ch */ case    0:  		/* addi R10, R10, 4 */
		/* 820F015Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F015Ch case    0:*/		return 0x820F0160;
		  /* 820F0160h */ case    1:  		/* bc 16, CR0_LT, -20 */
		/* 820F0160h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F014C;  }
		/* 820F0160h case    1:*/		return 0x820F0164;
	}
	return 0x820F0164;
} // Block from 820F015Ch-820F0164h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F0164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0164);
		  /* 820F0164h */ case    0:  		/* li R3, 0 */
		/* 820F0164h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F0164h case    0:*/		return 0x820F0168;
	}
	return 0x820F0168;
} // Block from 820F0164h-820F0168h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F0168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0168);
		  /* 820F0168h */ case    0:  		/* addi R1, R1, 480 */
		/* 820F0168h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1E0);
		/* 820F0168h case    0:*/		return 0x820F016C;
		  /* 820F016Ch */ case    1:  		/* b -388836 */
		/* 820F016Ch case    1:*/		return 0x82091288;
		/* 820F016Ch case    1:*/		return 0x820F0170;
	}
	return 0x820F0170;
} // Block from 820F0168h-820F0170h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F0170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0170);
		  /* 820F0170h */ case    0:  		/* mfspr R12, LR */
		/* 820F0170h case    0:*/		regs.R12 = regs.LR;
		/* 820F0170h case    0:*/		return 0x820F0174;
		  /* 820F0174h */ case    1:  		/* bl -388908 */
		/* 820F0174h case    1:*/		regs.LR = 0x820F0178; return 0x82091248;
		/* 820F0174h case    1:*/		return 0x820F0178;
		  /* 820F0178h */ case    2:  		/* stwu R1, <#[R1 - 432]> */
		/* 820F0178h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE50);
		/* 820F0178h case    2:*/		return 0x820F017C;
		  /* 820F017Ch */ case    3:  		/* lhz R9, <#[R3 + 202]> */
		/* 820F017Ch case    3:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R3 + 0x000000CA) );
		/* 820F017Ch case    3:*/		return 0x820F0180;
		  /* 820F0180h */ case    4:  		/* li R10, 768 */
		/* 820F0180h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x300);
		/* 820F0180h case    4:*/		return 0x820F0184;
		  /* 820F0184h */ case    5:  		/* mr R24, R4 */
		/* 820F0184h case    5:*/		regs.R24 = regs.R4;
		/* 820F0184h case    5:*/		return 0x820F0188;
		  /* 820F0188h */ case    6:  		/* lwz R4, <#[R3 + 260]> */
		/* 820F0188h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000104) );
		/* 820F0188h case    6:*/		return 0x820F018C;
		  /* 820F018Ch */ case    7:  		/* subfc R10, R10, R9 */
		/* 820F018Ch case    7:*/		cpu::op::subfc<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820F018Ch case    7:*/		return 0x820F0190;
		  /* 820F0190h */ case    8:  		/* lis R11, -32254 */
		/* 820F0190h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F0190h case    8:*/		return 0x820F0194;
		  /* 820F0194h */ case    9:  		/* subfe R28, R10, R10 */
		/* 820F0194h case    9:*/		cpu::op::subfe<0>(regs,&regs.R28,regs.R10,regs.R10);
		/* 820F0194h case    9:*/		return 0x820F0198;
		  /* 820F0198h */ case   10:  		/* li R10, 2 */
		/* 820F0198h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 820F0198h case   10:*/		return 0x820F019C;
		  /* 820F019Ch */ case   11:  		/* addi R29, R11, -26024 */
		/* 820F019Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFF9A58);
		/* 820F019Ch case   11:*/		return 0x820F01A0;
		  /* 820F01A0h */ case   12:  		/* lwz R11, <#[R4]> */
		/* 820F01A0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820F01A0h case   12:*/		return 0x820F01A4;
		  /* 820F01A4h */ case   13:  		/* stw R10, <#[R1 + 120]> */
		/* 820F01A4h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000078) );
		/* 820F01A4h case   13:*/		return 0x820F01A8;
		  /* 820F01A8h */ case   14:  		/* li R10, 1 */
		/* 820F01A8h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820F01A8h case   14:*/		return 0x820F01AC;
		  /* 820F01ACh */ case   15:  		/* rlwinm R30, R11, 0, 12, 31 */
		/* 820F01ACh case   15:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R11);
		/* 820F01ACh case   15:*/		return 0x820F01B0;
		  /* 820F01B0h */ case   16:  		/* li R25, 0 */
		/* 820F01B0h case   16:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820F01B0h case   16:*/		return 0x820F01B4;
		  /* 820F01B4h */ case   17:  		/* stw R10, <#[R1 + 116]> */
		/* 820F01B4h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 820F01B4h case   17:*/		return 0x820F01B8;
		  /* 820F01B8h */ case   18:  		/* li R11, 3 */
		/* 820F01B8h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820F01B8h case   18:*/		return 0x820F01BC;
		  /* 820F01BCh */ case   19:  		/* mr R5, R29 */
		/* 820F01BCh case   19:*/		regs.R5 = regs.R29;
		/* 820F01BCh case   19:*/		return 0x820F01C0;
		  /* 820F01C0h */ case   20:  		/* stw R25, <#[R1 + 96]> */
		/* 820F01C0h case   20:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000060) );
		/* 820F01C0h case   20:*/		return 0x820F01C4;
		  /* 820F01C4h */ case   21:  		/* addi R9, R1, 112 */
		/* 820F01C4h case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820F01C4h case   21:*/		return 0x820F01C8;
		  /* 820F01C8h */ case   22:  		/* stw R25, <#[R1 + 112]> */
		/* 820F01C8h case   22:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000070) );
		/* 820F01C8h case   22:*/		return 0x820F01CC;
		  /* 820F01CCh */ case   23:  		/* addi R8, R1, 192 */
		/* 820F01CCh case   23:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xC0);
		/* 820F01CCh case   23:*/		return 0x820F01D0;
		  /* 820F01D0h */ case   24:  		/* stw R25, <#[R1 + 84]> */
		/* 820F01D0h case   24:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000054) );
		/* 820F01D0h case   24:*/		return 0x820F01D4;
		  /* 820F01D4h */ case   25:  		/* mr R10, R30 */
		/* 820F01D4h case   25:*/		regs.R10 = regs.R30;
		/* 820F01D4h case   25:*/		return 0x820F01D8;
		  /* 820F01D8h */ case   26:  		/* stw R11, <#[R1 + 124]> */
		/* 820F01D8h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820F01D8h case   26:*/		return 0x820F01DC;
		  /* 820F01DCh */ case   27:  		/* addi R7, R1, 96 */
		/* 820F01DCh case   27:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F01DCh case   27:*/		return 0x820F01E0;
		  /* 820F01E0h */ case   28:  		/* addi R6, R1, 128 */
		/* 820F01E0h case   28:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820F01E0h case   28:*/		return 0x820F01E4;
		  /* 820F01E4h */ case   29:  		/* mr R31, R3 */
		/* 820F01E4h case   29:*/		regs.R31 = regs.R3;
		/* 820F01E4h case   29:*/		return 0x820F01E8;
		  /* 820F01E8h */ case   30:  		/* mr R26, R25 */
		/* 820F01E8h case   30:*/		regs.R26 = regs.R25;
		/* 820F01E8h case   30:*/		return 0x820F01EC;
		  /* 820F01ECh */ case   31:  		/* mr R27, R25 */
		/* 820F01ECh case   31:*/		regs.R27 = regs.R25;
		/* 820F01ECh case   31:*/		return 0x820F01F0;
		  /* 820F01F0h */ case   32:  		/* and R28, R28, R24 */
		/* 820F01F0h case   32:*/		cpu::op::and<0>(regs,&regs.R28,regs.R28,regs.R24);
		/* 820F01F0h case   32:*/		return 0x820F01F4;
		  /* 820F01F4h */ case   33:  		/* bl -50548 */
		/* 820F01F4h case   33:*/		regs.LR = 0x820F01F8; return 0x820E3C80;
		/* 820F01F4h case   33:*/		return 0x820F01F8;
		  /* 820F01F8h */ case   34:  		/* cmpwi CR0, R3, 0 */
		/* 820F01F8h case   34:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F01F8h case   34:*/		return 0x820F01FC;
		  /* 820F01FCh */ case   35:  		/* bc 12, CR0_EQ, 988 */
		/* 820F01FCh case   35:*/		if ( regs.CR[0].eq ) { return 0x820F05D8;  }
		/* 820F01FCh case   35:*/		return 0x820F0200;
		  /* 820F0200h */ case   36:  		/* addi R5, R29, 96 */
		/* 820F0200h case   36:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x60);
		/* 820F0200h case   36:*/		return 0x820F0204;
		  /* 820F0204h */ case   37:  		/* lwz R4, <#[R31 + 260]> */
		/* 820F0204h case   37:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000104) );
		/* 820F0204h case   37:*/		return 0x820F0208;
		  /* 820F0208h */ case   38:  		/* mr R10, R30 */
		/* 820F0208h case   38:*/		regs.R10 = regs.R30;
		/* 820F0208h case   38:*/		return 0x820F020C;
		  /* 820F020Ch */ case   39:  		/* stw R25, <#[R1 + 84]> */
		/* 820F020Ch case   39:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000054) );
		/* 820F020Ch case   39:*/		return 0x820F0210;
		  /* 820F0210h */ case   40:  		/* addi R9, R1, 112 */
		/* 820F0210h case   40:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820F0210h case   40:*/		return 0x820F0214;
		  /* 820F0214h */ case   41:  		/* addi R8, R1, 192 */
		/* 820F0214h case   41:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xC0);
		/* 820F0214h case   41:*/		return 0x820F0218;
		  /* 820F0218h */ case   42:  		/* addi R7, R1, 96 */
		/* 820F0218h case   42:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F0218h case   42:*/		return 0x820F021C;
		  /* 820F021Ch */ case   43:  		/* addi R6, R1, 128 */
		/* 820F021Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820F021Ch case   43:*/		return 0x820F0220;
		  /* 820F0220h */ case   44:  		/* mr R3, R31 */
		/* 820F0220h case   44:*/		regs.R3 = regs.R31;
		/* 820F0220h case   44:*/		return 0x820F0224;
		  /* 820F0224h */ case   45:  		/* bl -50596 */
		/* 820F0224h case   45:*/		regs.LR = 0x820F0228; return 0x820E3C80;
		/* 820F0224h case   45:*/		return 0x820F0228;
		  /* 820F0228h */ case   46:  		/* li R27, 1 */
		/* 820F0228h case   46:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820F0228h case   46:*/		return 0x820F022C;
		  /* 820F022Ch */ case   47:  		/* cmpwi CR0, R3, 0 */
		/* 820F022Ch case   47:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F022Ch case   47:*/		return 0x820F0230;
		  /* 820F0230h */ case   48:  		/* bc 12, CR0_EQ, 936 */
		/* 820F0230h case   48:*/		if ( regs.CR[0].eq ) { return 0x820F05D8;  }
		/* 820F0230h case   48:*/		return 0x820F0234;
		  /* 820F0234h */ case   49:  		/* cmpwi CR6, R24, 0 */
		/* 820F0234h case   49:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 820F0234h case   49:*/		return 0x820F0238;
		  /* 820F0238h */ case   50:  		/* bc 12, CR6_EQ, 100 */
		/* 820F0238h case   50:*/		if ( regs.CR[6].eq ) { return 0x820F029C;  }
		/* 820F0238h case   50:*/		return 0x820F023C;
		  /* 820F023Ch */ case   51:  		/* mr R5, R29 */
		/* 820F023Ch case   51:*/		regs.R5 = regs.R29;
		/* 820F023Ch case   51:*/		return 0x820F0240;
		  /* 820F0240h */ case   52:  		/* lwz R4, <#[R31 + 260]> */
		/* 820F0240h case   52:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000104) );
		/* 820F0240h case   52:*/		return 0x820F0244;
		  /* 820F0244h */ case   53:  		/* mr R10, R30 */
		/* 820F0244h case   53:*/		regs.R10 = regs.R30;
		/* 820F0244h case   53:*/		return 0x820F0248;
		  /* 820F0248h */ case   54:  		/* stw R28, <#[R1 + 84]> */
		/* 820F0248h case   54:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820F0248h case   54:*/		return 0x820F024C;
		  /* 820F024Ch */ case   55:  		/* addi R9, R1, 112 */
		/* 820F024Ch case   55:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820F024Ch case   55:*/		return 0x820F0250;
		  /* 820F0250h */ case   56:  		/* addi R8, R1, 192 */
		/* 820F0250h case   56:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xC0);
		/* 820F0250h case   56:*/		return 0x820F0254;
		  /* 820F0254h */ case   57:  		/* addi R7, R1, 96 */
		/* 820F0254h case   57:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F0254h case   57:*/		return 0x820F0258;
		  /* 820F0258h */ case   58:  		/* addi R6, R1, 128 */
		/* 820F0258h case   58:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820F0258h case   58:*/		return 0x820F025C;
		  /* 820F025Ch */ case   59:  		/* mr R3, R31 */
		/* 820F025Ch case   59:*/		regs.R3 = regs.R31;
		/* 820F025Ch case   59:*/		return 0x820F0260;
		  /* 820F0260h */ case   60:  		/* mr R27, R25 */
		/* 820F0260h case   60:*/		regs.R27 = regs.R25;
		/* 820F0260h case   60:*/		return 0x820F0264;
		  /* 820F0264h */ case   61:  		/* bl -50660 */
		/* 820F0264h case   61:*/		regs.LR = 0x820F0268; return 0x820E3C80;
		/* 820F0264h case   61:*/		return 0x820F0268;
		  /* 820F0268h */ case   62:  		/* cmpwi CR0, R3, 0 */
		/* 820F0268h case   62:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0268h case   62:*/		return 0x820F026C;
		  /* 820F026Ch */ case   63:  		/* bc 12, CR0_EQ, 876 */
		/* 820F026Ch case   63:*/		if ( regs.CR[0].eq ) { return 0x820F05D8;  }
		/* 820F026Ch case   63:*/		return 0x820F0270;
		  /* 820F0270h */ case   64:  		/* addi R5, R29, 96 */
		/* 820F0270h case   64:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x60);
		/* 820F0270h case   64:*/		return 0x820F0274;
		  /* 820F0274h */ case   65:  		/* lwz R4, <#[R31 + 260]> */
		/* 820F0274h case   65:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000104) );
		/* 820F0274h case   65:*/		return 0x820F0278;
		  /* 820F0278h */ case   66:  		/* mr R10, R30 */
		/* 820F0278h case   66:*/		regs.R10 = regs.R30;
		/* 820F0278h case   66:*/		return 0x820F027C;
		  /* 820F027Ch */ case   67:  		/* stw R28, <#[R1 + 84]> */
		/* 820F027Ch case   67:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820F027Ch case   67:*/		return 0x820F0280;
		  /* 820F0280h */ case   68:  		/* addi R9, R1, 112 */
		/* 820F0280h case   68:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820F0280h case   68:*/		return 0x820F0284;
		  /* 820F0284h */ case   69:  		/* addi R8, R1, 192 */
		/* 820F0284h case   69:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xC0);
		/* 820F0284h case   69:*/		return 0x820F0288;
		  /* 820F0288h */ case   70:  		/* addi R7, R1, 96 */
		/* 820F0288h case   70:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F0288h case   70:*/		return 0x820F028C;
		  /* 820F028Ch */ case   71:  		/* addi R6, R1, 128 */
		/* 820F028Ch case   71:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820F028Ch case   71:*/		return 0x820F0290;
		  /* 820F0290h */ case   72:  		/* mr R3, R31 */
		/* 820F0290h case   72:*/		regs.R3 = regs.R31;
		/* 820F0290h case   72:*/		return 0x820F0294;
		  /* 820F0294h */ case   73:  		/* bl -50708 */
		/* 820F0294h case   73:*/		regs.LR = 0x820F0298; return 0x820E3C80;
		/* 820F0294h case   73:*/		return 0x820F0298;
		  /* 820F0298h */ case   74:  		/* li R27, 1 */
		/* 820F0298h case   74:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820F0298h case   74:*/		return 0x820F029C;
	}
	return 0x820F029C;
} // Block from 820F0170h-820F029Ch (75 instructions)

//////////////////////////////////////////////////////
// Block at 820F029Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F029C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F029C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F029C);
		  /* 820F029Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820F029Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F029Ch case    0:*/		return 0x820F02A0;
		  /* 820F02A0h */ case    1:  		/* bc 12, CR6_EQ, 824 */
		/* 820F02A0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F05D8;  }
		/* 820F02A0h case    1:*/		return 0x820F02A4;
		  /* 820F02A4h */ case    2:  		/* addi R5, R29, 192 */
		/* 820F02A4h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0xC0);
		/* 820F02A4h case    2:*/		return 0x820F02A8;
		  /* 820F02A8h */ case    3:  		/* lwz R4, <#[R31 + 260]> */
		/* 820F02A8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000104) );
		/* 820F02A8h case    3:*/		return 0x820F02AC;
		  /* 820F02ACh */ case    4:  		/* mr R10, R30 */
		/* 820F02ACh case    4:*/		regs.R10 = regs.R30;
		/* 820F02ACh case    4:*/		return 0x820F02B0;
		  /* 820F02B0h */ case    5:  		/* stw R28, <#[R1 + 84]> */
		/* 820F02B0h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820F02B0h case    5:*/		return 0x820F02B4;
		  /* 820F02B4h */ case    6:  		/* addi R9, R1, 112 */
		/* 820F02B4h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820F02B4h case    6:*/		return 0x820F02B8;
		  /* 820F02B8h */ case    7:  		/* addi R8, R1, 192 */
		/* 820F02B8h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xC0);
		/* 820F02B8h case    7:*/		return 0x820F02BC;
		  /* 820F02BCh */ case    8:  		/* addi R7, R1, 96 */
		/* 820F02BCh case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F02BCh case    8:*/		return 0x820F02C0;
		  /* 820F02C0h */ case    9:  		/* addi R6, R1, 128 */
		/* 820F02C0h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820F02C0h case    9:*/		return 0x820F02C4;
		  /* 820F02C4h */ case   10:  		/* mr R3, R31 */
		/* 820F02C4h case   10:*/		regs.R3 = regs.R31;
		/* 820F02C4h case   10:*/		return 0x820F02C8;
		  /* 820F02C8h */ case   11:  		/* mr R27, R25 */
		/* 820F02C8h case   11:*/		regs.R27 = regs.R25;
		/* 820F02C8h case   11:*/		return 0x820F02CC;
		  /* 820F02CCh */ case   12:  		/* bl -50764 */
		/* 820F02CCh case   12:*/		regs.LR = 0x820F02D0; return 0x820E3C80;
		/* 820F02CCh case   12:*/		return 0x820F02D0;
		  /* 820F02D0h */ case   13:  		/* cmplwi CR6, R30, 0 */
		/* 820F02D0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F02D0h case   13:*/		return 0x820F02D4;
		  /* 820F02D4h */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 820F02D4h case   14:*/		if ( regs.CR[6].eq ) { return 0x820F02FC;  }
		/* 820F02D4h case   14:*/		return 0x820F02D8;
		  /* 820F02D8h */ case   15:  		/* addi R11, R1, 192 */
		/* 820F02D8h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 820F02D8h case   15:*/		return 0x820F02DC;
		  /* 820F02DCh */ case   16:  		/* mtspr CTR, R30 */
		/* 820F02DCh case   16:*/		regs.CTR = regs.R30;
		/* 820F02DCh case   16:*/		return 0x820F02E0;
		  /* 820F02E0h */ case   17:  		/* lwz R10, <#[R11]> */
		/* 820F02E0h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F02E0h case   17:*/		return 0x820F02E4;
		  /* 820F02E4h */ case   18:  		/* lwz R9, <#[R11 + 16]> */
		/* 820F02E4h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 820F02E4h case   18:*/		return 0x820F02E8;
		  /* 820F02E8h */ case   19:  		/* cmplw CR6, R10, R9 */
		/* 820F02E8h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F02E8h case   19:*/		return 0x820F02EC;
		  /* 820F02ECh */ case   20:  		/* bc 12, CR6_EQ, 8 */
		/* 820F02ECh case   20:*/		if ( regs.CR[6].eq ) { return 0x820F02F4;  }
		/* 820F02ECh case   20:*/		return 0x820F02F0;
		  /* 820F02F0h */ case   21:  		/* li R3, 1 */
		/* 820F02F0h case   21:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F02F0h case   21:*/		return 0x820F02F4;
	}
	return 0x820F02F4;
} // Block from 820F029Ch-820F02F4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F02F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F02F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F02F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F02F4);
		  /* 820F02F4h */ case    0:  		/* addi R11, R11, 4 */
		/* 820F02F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F02F4h case    0:*/		return 0x820F02F8;
		  /* 820F02F8h */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 820F02F8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F02E0;  }
		/* 820F02F8h case    1:*/		return 0x820F02FC;
	}
	return 0x820F02FC;
} // Block from 820F02F4h-820F02FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F02FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F02FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F02FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F02FC);
		  /* 820F02FCh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820F02FCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F02FCh case    0:*/		return 0x820F0300;
		  /* 820F0300h */ case    1:  		/* bc 12, CR6_EQ, 304 */
		/* 820F0300h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F0430;  }
		/* 820F0300h case    1:*/		return 0x820F0304;
		  /* 820F0304h */ case    2:  		/* addi R5, R29, 288 */
		/* 820F0304h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x120);
		/* 820F0304h case    2:*/		return 0x820F0308;
		  /* 820F0308h */ case    3:  		/* lwz R4, <#[R31 + 260]> */
		/* 820F0308h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000104) );
		/* 820F0308h case    3:*/		return 0x820F030C;
		  /* 820F030Ch */ case    4:  		/* mr R10, R30 */
		/* 820F030Ch case    4:*/		regs.R10 = regs.R30;
		/* 820F030Ch case    4:*/		return 0x820F0310;
		  /* 820F0310h */ case    5:  		/* stw R28, <#[R1 + 84]> */
		/* 820F0310h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820F0310h case    5:*/		return 0x820F0314;
		  /* 820F0314h */ case    6:  		/* addi R9, R1, 112 */
		/* 820F0314h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820F0314h case    6:*/		return 0x820F0318;
		  /* 820F0318h */ case    7:  		/* stw R25, <#[R1 + 96]> */
		/* 820F0318h case    7:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000060) );
		/* 820F0318h case    7:*/		return 0x820F031C;
		  /* 820F031Ch */ case    8:  		/* addi R8, R1, 192 */
		/* 820F031Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xC0);
		/* 820F031Ch case    8:*/		return 0x820F0320;
		  /* 820F0320h */ case    9:  		/* addi R7, R1, 96 */
		/* 820F0320h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F0320h case    9:*/		return 0x820F0324;
		  /* 820F0324h */ case   10:  		/* addi R6, R1, 128 */
		/* 820F0324h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820F0324h case   10:*/		return 0x820F0328;
		  /* 820F0328h */ case   11:  		/* mr R3, R31 */
		/* 820F0328h case   11:*/		regs.R3 = regs.R31;
		/* 820F0328h case   11:*/		return 0x820F032C;
		  /* 820F032Ch */ case   12:  		/* bl -50860 */
		/* 820F032Ch case   12:*/		regs.LR = 0x820F0330; return 0x820E3C80;
		/* 820F032Ch case   12:*/		return 0x820F0330;
		  /* 820F0330h */ case   13:  		/* li R27, 1 */
		/* 820F0330h case   13:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820F0330h case   13:*/		return 0x820F0334;
		  /* 820F0334h */ case   14:  		/* cmplwi CR6, R30, 0 */
		/* 820F0334h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F0334h case   14:*/		return 0x820F0338;
		  /* 820F0338h */ case   15:  		/* bc 12, CR6_EQ, 40 */
		/* 820F0338h case   15:*/		if ( regs.CR[6].eq ) { return 0x820F0360;  }
		/* 820F0338h case   15:*/		return 0x820F033C;
		  /* 820F033Ch */ case   16:  		/* addi R11, R1, 192 */
		/* 820F033Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 820F033Ch case   16:*/		return 0x820F0340;
		  /* 820F0340h */ case   17:  		/* mtspr CTR, R30 */
		/* 820F0340h case   17:*/		regs.CTR = regs.R30;
		/* 820F0340h case   17:*/		return 0x820F0344;
		  /* 820F0344h */ case   18:  		/* lwz R10, <#[R11]> */
		/* 820F0344h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F0344h case   18:*/		return 0x820F0348;
		  /* 820F0348h */ case   19:  		/* lwz R9, <#[R11 + 16]> */
		/* 820F0348h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 820F0348h case   19:*/		return 0x820F034C;
		  /* 820F034Ch */ case   20:  		/* cmplw CR6, R10, R9 */
		/* 820F034Ch case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F034Ch case   20:*/		return 0x820F0350;
		  /* 820F0350h */ case   21:  		/* bc 12, CR6_EQ, 8 */
		/* 820F0350h case   21:*/		if ( regs.CR[6].eq ) { return 0x820F0358;  }
		/* 820F0350h case   21:*/		return 0x820F0354;
		  /* 820F0354h */ case   22:  		/* li R3, 1 */
		/* 820F0354h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F0354h case   22:*/		return 0x820F0358;
	}
	return 0x820F0358;
} // Block from 820F02FCh-820F0358h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820F0358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0358);
		  /* 820F0358h */ case    0:  		/* addi R11, R11, 4 */
		/* 820F0358h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F0358h case    0:*/		return 0x820F035C;
		  /* 820F035Ch */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 820F035Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F0344;  }
		/* 820F035Ch case    1:*/		return 0x820F0360;
	}
	return 0x820F0360;
} // Block from 820F0358h-820F0360h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F0360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0360);
		  /* 820F0360h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820F0360h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F0360h case    0:*/		return 0x820F0364;
		  /* 820F0364h */ case    1:  		/* bc 12, CR6_EQ, 204 */
		/* 820F0364h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F0430;  }
		/* 820F0364h case    1:*/		return 0x820F0368;
		  /* 820F0368h */ case    2:  		/* addi R5, R29, 384 */
		/* 820F0368h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x180);
		/* 820F0368h case    2:*/		return 0x820F036C;
		  /* 820F036Ch */ case    3:  		/* lwz R4, <#[R31 + 260]> */
		/* 820F036Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000104) );
		/* 820F036Ch case    3:*/		return 0x820F0370;
		  /* 820F0370h */ case    4:  		/* mr R10, R30 */
		/* 820F0370h case    4:*/		regs.R10 = regs.R30;
		/* 820F0370h case    4:*/		return 0x820F0374;
		  /* 820F0374h */ case    5:  		/* stw R28, <#[R1 + 84]> */
		/* 820F0374h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820F0374h case    5:*/		return 0x820F0378;
		  /* 820F0378h */ case    6:  		/* addi R9, R1, 112 */
		/* 820F0378h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820F0378h case    6:*/		return 0x820F037C;
		  /* 820F037Ch */ case    7:  		/* stw R25, <#[R1 + 96]> */
		/* 820F037Ch case    7:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000060) );
		/* 820F037Ch case    7:*/		return 0x820F0380;
		  /* 820F0380h */ case    8:  		/* addi R8, R1, 192 */
		/* 820F0380h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xC0);
		/* 820F0380h case    8:*/		return 0x820F0384;
		  /* 820F0384h */ case    9:  		/* addi R7, R1, 96 */
		/* 820F0384h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F0384h case    9:*/		return 0x820F0388;
		  /* 820F0388h */ case   10:  		/* addi R6, R1, 128 */
		/* 820F0388h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820F0388h case   10:*/		return 0x820F038C;
		  /* 820F038Ch */ case   11:  		/* mr R3, R31 */
		/* 820F038Ch case   11:*/		regs.R3 = regs.R31;
		/* 820F038Ch case   11:*/		return 0x820F0390;
		  /* 820F0390h */ case   12:  		/* mr R27, R25 */
		/* 820F0390h case   12:*/		regs.R27 = regs.R25;
		/* 820F0390h case   12:*/		return 0x820F0394;
		  /* 820F0394h */ case   13:  		/* bl -50964 */
		/* 820F0394h case   13:*/		regs.LR = 0x820F0398; return 0x820E3C80;
		/* 820F0394h case   13:*/		return 0x820F0398;
		  /* 820F0398h */ case   14:  		/* cmplwi CR6, R30, 0 */
		/* 820F0398h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F0398h case   14:*/		return 0x820F039C;
		  /* 820F039Ch */ case   15:  		/* bc 12, CR6_EQ, 40 */
		/* 820F039Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820F03C4;  }
		/* 820F039Ch case   15:*/		return 0x820F03A0;
		  /* 820F03A0h */ case   16:  		/* addi R11, R1, 192 */
		/* 820F03A0h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 820F03A0h case   16:*/		return 0x820F03A4;
		  /* 820F03A4h */ case   17:  		/* mtspr CTR, R30 */
		/* 820F03A4h case   17:*/		regs.CTR = regs.R30;
		/* 820F03A4h case   17:*/		return 0x820F03A8;
		  /* 820F03A8h */ case   18:  		/* lwz R10, <#[R11]> */
		/* 820F03A8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F03A8h case   18:*/		return 0x820F03AC;
		  /* 820F03ACh */ case   19:  		/* lwz R9, <#[R11 + 16]> */
		/* 820F03ACh case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 820F03ACh case   19:*/		return 0x820F03B0;
		  /* 820F03B0h */ case   20:  		/* cmplw CR6, R10, R9 */
		/* 820F03B0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F03B0h case   20:*/		return 0x820F03B4;
		  /* 820F03B4h */ case   21:  		/* bc 12, CR6_EQ, 8 */
		/* 820F03B4h case   21:*/		if ( regs.CR[6].eq ) { return 0x820F03BC;  }
		/* 820F03B4h case   21:*/		return 0x820F03B8;
		  /* 820F03B8h */ case   22:  		/* li R3, 1 */
		/* 820F03B8h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F03B8h case   22:*/		return 0x820F03BC;
	}
	return 0x820F03BC;
} // Block from 820F0360h-820F03BCh (23 instructions)

//////////////////////////////////////////////////////
// Block at 820F03BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F03BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F03BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F03BC);
		  /* 820F03BCh */ case    0:  		/* addi R11, R11, 4 */
		/* 820F03BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F03BCh case    0:*/		return 0x820F03C0;
		  /* 820F03C0h */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 820F03C0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F03A8;  }
		/* 820F03C0h case    1:*/		return 0x820F03C4;
	}
	return 0x820F03C4;
} // Block from 820F03BCh-820F03C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F03C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F03C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F03C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F03C4);
		  /* 820F03C4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820F03C4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F03C4h case    0:*/		return 0x820F03C8;
		  /* 820F03C8h */ case    1:  		/* bc 12, CR6_EQ, 104 */
		/* 820F03C8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F0430;  }
		/* 820F03C8h case    1:*/		return 0x820F03CC;
		  /* 820F03CCh */ case    2:  		/* addi R5, R29, 480 */
		/* 820F03CCh case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x1E0);
		/* 820F03CCh case    2:*/		return 0x820F03D0;
		  /* 820F03D0h */ case    3:  		/* lwz R4, <#[R31 + 260]> */
		/* 820F03D0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000104) );
		/* 820F03D0h case    3:*/		return 0x820F03D4;
		  /* 820F03D4h */ case    4:  		/* mr R10, R30 */
		/* 820F03D4h case    4:*/		regs.R10 = regs.R30;
		/* 820F03D4h case    4:*/		return 0x820F03D8;
		  /* 820F03D8h */ case    5:  		/* stw R28, <#[R1 + 84]> */
		/* 820F03D8h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820F03D8h case    5:*/		return 0x820F03DC;
		  /* 820F03DCh */ case    6:  		/* addi R9, R1, 112 */
		/* 820F03DCh case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 820F03DCh case    6:*/		return 0x820F03E0;
		  /* 820F03E0h */ case    7:  		/* stw R25, <#[R1 + 96]> */
		/* 820F03E0h case    7:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000060) );
		/* 820F03E0h case    7:*/		return 0x820F03E4;
		  /* 820F03E4h */ case    8:  		/* addi R8, R1, 192 */
		/* 820F03E4h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xC0);
		/* 820F03E4h case    8:*/		return 0x820F03E8;
		  /* 820F03E8h */ case    9:  		/* addi R7, R1, 96 */
		/* 820F03E8h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820F03E8h case    9:*/		return 0x820F03EC;
		  /* 820F03ECh */ case   10:  		/* addi R6, R1, 128 */
		/* 820F03ECh case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820F03ECh case   10:*/		return 0x820F03F0;
		  /* 820F03F0h */ case   11:  		/* mr R3, R31 */
		/* 820F03F0h case   11:*/		regs.R3 = regs.R31;
		/* 820F03F0h case   11:*/		return 0x820F03F4;
		  /* 820F03F4h */ case   12:  		/* bl -51060 */
		/* 820F03F4h case   12:*/		regs.LR = 0x820F03F8; return 0x820E3C80;
		/* 820F03F4h case   12:*/		return 0x820F03F8;
		  /* 820F03F8h */ case   13:  		/* li R27, 1 */
		/* 820F03F8h case   13:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820F03F8h case   13:*/		return 0x820F03FC;
		  /* 820F03FCh */ case   14:  		/* cmplwi CR6, R30, 0 */
		/* 820F03FCh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F03FCh case   14:*/		return 0x820F0400;
		  /* 820F0400h */ case   15:  		/* bc 12, CR6_EQ, 40 */
		/* 820F0400h case   15:*/		if ( regs.CR[6].eq ) { return 0x820F0428;  }
		/* 820F0400h case   15:*/		return 0x820F0404;
		  /* 820F0404h */ case   16:  		/* addi R11, R1, 192 */
		/* 820F0404h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 820F0404h case   16:*/		return 0x820F0408;
		  /* 820F0408h */ case   17:  		/* mtspr CTR, R30 */
		/* 820F0408h case   17:*/		regs.CTR = regs.R30;
		/* 820F0408h case   17:*/		return 0x820F040C;
		  /* 820F040Ch */ case   18:  		/* lwz R10, <#[R11]> */
		/* 820F040Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F040Ch case   18:*/		return 0x820F0410;
		  /* 820F0410h */ case   19:  		/* lwz R9, <#[R11 + 16]> */
		/* 820F0410h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 820F0410h case   19:*/		return 0x820F0414;
		  /* 820F0414h */ case   20:  		/* cmplw CR6, R10, R9 */
		/* 820F0414h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F0414h case   20:*/		return 0x820F0418;
		  /* 820F0418h */ case   21:  		/* bc 12, CR6_EQ, 8 */
		/* 820F0418h case   21:*/		if ( regs.CR[6].eq ) { return 0x820F0420;  }
		/* 820F0418h case   21:*/		return 0x820F041C;
		  /* 820F041Ch */ case   22:  		/* li R3, 1 */
		/* 820F041Ch case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F041Ch case   22:*/		return 0x820F0420;
	}
	return 0x820F0420;
} // Block from 820F03C4h-820F0420h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820F0420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0420);
		  /* 820F0420h */ case    0:  		/* addi R11, R11, 4 */
		/* 820F0420h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F0420h case    0:*/		return 0x820F0424;
		  /* 820F0424h */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 820F0424h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F040C;  }
		/* 820F0424h case    1:*/		return 0x820F0428;
	}
	return 0x820F0428;
} // Block from 820F0420h-820F0428h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F0428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0428);
		  /* 820F0428h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820F0428h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F0428h case    0:*/		return 0x820F042C;
		  /* 820F042Ch */ case    1:  		/* bc 4, CR6_EQ, 692 */
		/* 820F042Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F06E0;  }
		/* 820F042Ch case    1:*/		return 0x820F0430;
	}
	return 0x820F0430;
} // Block from 820F0428h-820F0430h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F0430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0430);
		  /* 820F0430h */ case    0:  		/* mr R11, R25 */
		/* 820F0430h case    0:*/		regs.R11 = regs.R25;
		/* 820F0430h case    0:*/		return 0x820F0434;
		  /* 820F0434h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 820F0434h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F0434h case    1:*/		return 0x820F0438;
		  /* 820F0438h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820F0438h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F0460;  }
		/* 820F0438h case    2:*/		return 0x820F043C;
		  /* 820F043Ch */ case    3:  		/* addi R10, R1, 192 */
		/* 820F043Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xC0);
		/* 820F043Ch case    3:*/		return 0x820F0440;
		  /* 820F0440h */ case    4:  		/* lwz R9, <#[R10]> */
		/* 820F0440h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820F0440h case    4:*/		return 0x820F0444;
		  /* 820F0444h */ case    5:  		/* lwz R8, <#[R10 + 16]> */
		/* 820F0444h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 820F0444h case    5:*/		return 0x820F0448;
		  /* 820F0448h */ case    6:  		/* cmplw CR6, R9, R8 */
		/* 820F0448h case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820F0448h case    6:*/		return 0x820F044C;
		  /* 820F044Ch */ case    7:  		/* bc 4, CR6_EQ, 88 */
		/* 820F044Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820F04A4;  }
		/* 820F044Ch case    7:*/		return 0x820F0450;
		  /* 820F0450h */ case    8:  		/* addi R11, R11, 1 */
		/* 820F0450h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F0450h case    8:*/		return 0x820F0454;
		  /* 820F0454h */ case    9:  		/* addi R10, R10, 4 */
		/* 820F0454h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F0454h case    9:*/		return 0x820F0458;
		  /* 820F0458h */ case   10:  		/* cmplw CR6, R11, R30 */
		/* 820F0458h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820F0458h case   10:*/		return 0x820F045C;
		  /* 820F045Ch */ case   11:  		/* bc 12, CR6_LT, -28 */
		/* 820F045Ch case   11:*/		if ( regs.CR[6].lt ) { return 0x820F0440;  }
		/* 820F045Ch case   11:*/		return 0x820F0460;
	}
	return 0x820F0460;
} // Block from 820F0430h-820F0460h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F0460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0460);
		  /* 820F0460h */ case    0:  		/* lwz R10, <#[R31 + 356]> */
		/* 820F0460h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000164) );
		/* 820F0460h case    0:*/		return 0x820F0464;
		  /* 820F0464h */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 820F0464h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820F0464h case    1:*/		return 0x820F0468;
		  /* 820F0468h */ case    2:  		/* bc 4, CR6_EQ, 108 */
		/* 820F0468h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F04D4;  }
		/* 820F0468h case    2:*/		return 0x820F046C;
		  /* 820F046Ch */ case    3:  		/* lis R11, -32255 */
		/* 820F046Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820F046Ch case    3:*/		return 0x820F0470;
		  /* 820F0470h */ case    4:  		/* li R7, 4 */
		/* 820F0470h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 820F0470h case    4:*/		return 0x820F0474;
		  /* 820F0474h */ case    5:  		/* addi R4, R11, -8736 */
		/* 820F0474h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFDDE0);
		/* 820F0474h case    5:*/		return 0x820F0478;
		  /* 820F0478h */ case    6:  		/* li R6, 1 */
		/* 820F0478h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F0478h case    6:*/		return 0x820F047C;
		  /* 820F047Ch */ case    7:  		/* li R5, 785 */
		/* 820F047Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x311);
		/* 820F047Ch case    7:*/		return 0x820F0480;
		  /* 820F0480h */ case    8:  		/* mr R3, R31 */
		/* 820F0480h case    8:*/		regs.R3 = regs.R31;
		/* 820F0480h case    8:*/		return 0x820F0484;
		  /* 820F0484h */ case    9:  		/* bl 52484 */
		/* 820F0484h case    9:*/		regs.LR = 0x820F0488; return 0x820FD188;
		/* 820F0484h case    9:*/		return 0x820F0488;
		  /* 820F0488h */ case   10:  		/* mr R4, R3 */
		/* 820F0488h case   10:*/		regs.R4 = regs.R3;
		/* 820F0488h case   10:*/		return 0x820F048C;
		  /* 820F048Ch */ case   11:  		/* stw R3, <#[R31 + 372]> */
		/* 820F048Ch case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000174) );
		/* 820F048Ch case   11:*/		return 0x820F0490;
		  /* 820F0490h */ case   12:  		/* cmpwi CR6, R3, -1 */
		/* 820F0490h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820F0490h case   12:*/		return 0x820F0494;
		  /* 820F0494h */ case   13:  		/* bc 4, CR6_EQ, 24 */
		/* 820F0494h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820F04AC;  }
		/* 820F0494h case   13:*/		return 0x820F0498;
		  /* 820F0498h */ case   14:  		/* lis R3, -32761 */
		/* 820F0498h case   14:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820F0498h case   14:*/		return 0x820F049C;
		  /* 820F049Ch */ case   15:  		/* ori R3, R3, 14 */
		/* 820F049Ch case   15:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820F049Ch case   15:*/		return 0x820F04A0;
		  /* 820F04A0h */ case   16:  		/* b 608 */
		/* 820F04A0h case   16:*/		return 0x820F0700;
		/* 820F04A0h case   16:*/		return 0x820F04A4;
	}
	return 0x820F04A4;
} // Block from 820F0460h-820F04A4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820F04A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F04A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F04A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F04A4);
		  /* 820F04A4h */ case    0:  		/* li R3, 1 */
		/* 820F04A4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F04A4h case    0:*/		return 0x820F04A8;
		  /* 820F04A8h */ case    1:  		/* b 600 */
		/* 820F04A8h case    1:*/		return 0x820F0700;
		/* 820F04A8h case    1:*/		return 0x820F04AC;
	}
	return 0x820F04AC;
} // Block from 820F04A4h-820F04ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F04ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F04AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F04AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F04AC);
		  /* 820F04ACh */ case    0:  		/* lis R11, -32255 */
		/* 820F04ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820F04ACh case    0:*/		return 0x820F04B0;
		  /* 820F04B0h */ case    1:  		/* li R6, 0 */
		/* 820F04B0h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F04B0h case    1:*/		return 0x820F04B4;
		  /* 820F04B4h */ case    2:  		/* li R5, 0 */
		/* 820F04B4h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F04B4h case    2:*/		return 0x820F04B8;
		  /* 820F04B8h */ case    3:  		/* mr R3, R31 */
		/* 820F04B8h case    3:*/		regs.R3 = regs.R31;
		/* 820F04B8h case    3:*/		return 0x820F04BC;
		  /* 820F04BCh */ case    4:  		/* lfd FR1, <#[R11 - 24504]> */
		/* 820F04BCh case    4:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0xFFFFA048) );
		/* 820F04BCh case    4:*/		return 0x820F04C0;
		  /* 820F04C0h */ case    5:  		/* bl 52584 */
		/* 820F04C0h case    5:*/		regs.LR = 0x820F04C4; return 0x820FD228;
		/* 820F04C0h case    5:*/		return 0x820F04C4;
		  /* 820F04C4h */ case    6:  		/* stw R3, <#[R31 + 356]> */
		/* 820F04C4h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000164) );
		/* 820F04C4h case    6:*/		return 0x820F04C8;
		  /* 820F04C8h */ case    7:  		/* mr R10, R3 */
		/* 820F04C8h case    7:*/		regs.R10 = regs.R3;
		/* 820F04C8h case    7:*/		return 0x820F04CC;
		  /* 820F04CCh */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 820F04CCh case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820F04CCh case    8:*/		return 0x820F04D0;
		  /* 820F04D0h */ case    9:  		/* bc 12, CR6_EQ, -56 */
		/* 820F04D0h case    9:*/		if ( regs.CR[6].eq ) { return 0x820F0498;  }
		/* 820F04D0h case    9:*/		return 0x820F04D4;
	}
	return 0x820F04D4;
} // Block from 820F04ACh-820F04D4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F04D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F04D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F04D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F04D4);
		  /* 820F04D4h */ case    0:  		/* li R9, 1 */
		/* 820F04D4h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820F04D4h case    0:*/		return 0x820F04D8;
		  /* 820F04D8h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 820F04D8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F04D8h case    1:*/		return 0x820F04DC;
		  /* 820F04DCh */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 820F04DCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820F050C;  }
		/* 820F04DCh case    2:*/		return 0x820F04E0;
		  /* 820F04E0h */ case    3:  		/* addi R11, R1, 224 */
		/* 820F04E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xE0);
		/* 820F04E0h case    3:*/		return 0x820F04E4;
		  /* 820F04E4h */ case    4:  		/* mtspr CTR, R30 */
		/* 820F04E4h case    4:*/		regs.CTR = regs.R30;
		/* 820F04E4h case    4:*/		return 0x820F04E8;
		  /* 820F04E8h */ case    5:  		/* lwz R8, <#[R11]> */
		/* 820F04E8h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820F04E8h case    5:*/		return 0x820F04EC;
		  /* 820F04ECh */ case    6:  		/* stw R10, <#[R11 - 32]> */
		/* 820F04ECh case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0xFFFFFFE0) );
		/* 820F04ECh case    6:*/		return 0x820F04F0;
		  /* 820F04F0h */ case    7:  		/* addi R11, R11, 4 */
		/* 820F04F0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F04F0h case    7:*/		return 0x820F04F4;
		  /* 820F04F4h */ case    8:  		/* lwz R7, <#[R1 + 224]> */
		/* 820F04F4h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000E0) );
		/* 820F04F4h case    8:*/		return 0x820F04F8;
		  /* 820F04F8h */ case    9:  		/* subf R8, R8, R7 */
		/* 820F04F8h case    9:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 820F04F8h case    9:*/		return 0x820F04FC;
		  /* 820F04FCh */ case   10:  		/* addic R8, R8, -1 */
		/* 820F04FCh case   10:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820F04FCh case   10:*/		return 0x820F0500;
		  /* 820F0500h */ case   11:  		/* subfe R8, R8, R8 */
		/* 820F0500h case   11:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 820F0500h case   11:*/		return 0x820F0504;
		  /* 820F0504h */ case   12:  		/* and R9, R8, R9 */
		/* 820F0504h case   12:*/		cpu::op::and<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820F0504h case   12:*/		return 0x820F0508;
		  /* 820F0508h */ case   13:  		/* bc 16, CR0_LT, -32 */
		/* 820F0508h case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F04E8;  }
		/* 820F0508h case   13:*/		return 0x820F050C;
	}
	return 0x820F050C;
} // Block from 820F04D4h-820F050Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F050Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F050C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F050C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F050C);
		  /* 820F050Ch */ case    0:  		/* lwz R11, <#[R1 + 224]> */
		/* 820F050Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000E0) );
		/* 820F050Ch case    0:*/		return 0x820F0510;
		  /* 820F0510h */ case    1:  		/* lwz R7, <#[R31 + 20]> */
		/* 820F0510h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 820F0510h case    1:*/		return 0x820F0514;
		  /* 820F0514h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F0514h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F0514h case    2:*/		return 0x820F0518;
		  /* 820F0518h */ case    3:  		/* lwz R10, <#[R31 + 16]> */
		/* 820F0518h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820F0518h case    3:*/		return 0x820F051C;
		  /* 820F051Ch */ case    4:  		/* lwzx R8, <#[R11 + R7]> */
		/* 820F051Ch case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820F051Ch case    4:*/		return 0x820F0520;
		  /* 820F0520h */ case    5:  		/* lwz R11, <#[R8 + 4]> */
		/* 820F0520h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 820F0520h case    5:*/		return 0x820F0524;
		  /* 820F0524h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F0524h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F0524h case    6:*/		return 0x820F0528;
		  /* 820F0528h */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F0528h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F0528h case    7:*/		return 0x820F052C;
		  /* 820F052Ch */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F052Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F052Ch case    8:*/		return 0x820F0530;
		  /* 820F0530h */ case    9:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820F0530h case    9:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820F0530h case    9:*/		return 0x820F0534;
		  /* 820F0534h */ case   10:  		/* bc 12, CR0_EQ, 164 */
		/* 820F0534h case   10:*/		if ( regs.CR[0].eq ) { return 0x820F05D8;  }
		/* 820F0534h case   10:*/		return 0x820F0538;
		  /* 820F0538h */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820F0538h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820F0538h case   11:*/		return 0x820F053C;
		  /* 820F053Ch */ case   12:  		/* bc 12, CR6_EQ, 156 */
		/* 820F053Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820F05D8;  }
		/* 820F053Ch case   12:*/		return 0x820F0540;
		  /* 820F0540h */ case   13:  		/* mr R11, R25 */
		/* 820F0540h case   13:*/		regs.R11 = regs.R25;
		/* 820F0540h case   13:*/		return 0x820F0544;
		  /* 820F0544h */ case   14:  		/* addi R10, R31, 360 */
		/* 820F0544h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x168);
		/* 820F0544h case   14:*/		return 0x820F0548;
		  /* 820F0548h */ case   15:  		/* lwz R9, <#[R10]> */
		/* 820F0548h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820F0548h case   15:*/		return 0x820F054C;
		  /* 820F054Ch */ case   16:  		/* cmpwi CR6, R9, -1 */
		/* 820F054Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820F054Ch case   16:*/		return 0x820F0550;
		  /* 820F0550h */ case   17:  		/* bc 12, CR6_EQ, 44 */
		/* 820F0550h case   17:*/		if ( regs.CR[6].eq ) { return 0x820F057C;  }
		/* 820F0550h case   17:*/		return 0x820F0554;
		  /* 820F0554h */ case   18:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F0554h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F0554h case   18:*/		return 0x820F0558;
		  /* 820F0558h */ case   19:  		/* lfd FR0, <#[R8 + 32]> */
		/* 820F0558h case   19:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R8 + 0x00000020) );
		/* 820F0558h case   19:*/		return 0x820F055C;
		  /* 820F055Ch */ case   20:  		/* lwzx R9, <#[R9 + R7]> */
		/* 820F055Ch case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820F055Ch case   20:*/		return 0x820F0560;
		  /* 820F0560h */ case   21:  		/* lfd FR13, <#[R9 + 32]> */
		/* 820F0560h case   21:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R9 + 0x00000020) );
		/* 820F0560h case   21:*/		return 0x820F0564;
		  /* 820F0564h */ case   22:  		/* fcmpu CR6, FR13, FR0 */
		/* 820F0564h case   22:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820F0564h case   22:*/		return 0x820F0568;
		  /* 820F0568h */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 820F0568h case   23:*/		if ( regs.CR[6].eq ) { return 0x820F057C;  }
		/* 820F0568h case   23:*/		return 0x820F056C;
		  /* 820F056Ch */ case   24:  		/* addi R11, R11, 1 */
		/* 820F056Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F056Ch case   24:*/		return 0x820F0570;
		  /* 820F0570h */ case   25:  		/* addi R10, R10, 4 */
		/* 820F0570h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F0570h case   25:*/		return 0x820F0574;
		  /* 820F0574h */ case   26:  		/* cmplwi CR6, R11, 3 */
		/* 820F0574h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820F0574h case   26:*/		return 0x820F0578;
		  /* 820F0578h */ case   27:  		/* bc 12, CR6_LT, -48 */
		/* 820F0578h case   27:*/		if ( regs.CR[6].lt ) { return 0x820F0548;  }
		/* 820F0578h case   27:*/		return 0x820F057C;
	}
	return 0x820F057C;
} // Block from 820F050Ch-820F057Ch (28 instructions)

//////////////////////////////////////////////////////
// Block at 820F057Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F057C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F057C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F057C);
		  /* 820F057Ch */ case    0:  		/* cmplwi CR6, R11, 3 */
		/* 820F057Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820F057Ch case    0:*/		return 0x820F0580;
		  /* 820F0580h */ case    1:  		/* bc 12, CR6_EQ, 88 */
		/* 820F0580h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F05D8;  }
		/* 820F0580h case    1:*/		return 0x820F0584;
		  /* 820F0584h */ case    2:  		/* addi R10, R11, 90 */
		/* 820F0584h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x5A);
		/* 820F0584h case    2:*/		return 0x820F0588;
		  /* 820F0588h */ case    3:  		/* rlwinm R29, R10, 2, 0, 29 */
		/* 820F0588h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R10);
		/* 820F0588h case    3:*/		return 0x820F058C;
		  /* 820F058Ch */ case    4:  		/* lwzx R10, <#[R29 + R31]> */
		/* 820F058Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 820F058Ch case    4:*/		return 0x820F0590;
		  /* 820F0590h */ case    5:  		/* cmpwi CR6, R10, -1 */
		/* 820F0590h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820F0590h case    5:*/		return 0x820F0594;
		  /* 820F0594h */ case    6:  		/* bc 4, CR6_EQ, 44 */
		/* 820F0594h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820F05C0;  }
		/* 820F0594h case    6:*/		return 0x820F0598;
		  /* 820F0598h */ case    7:  		/* addi R6, R11, 1 */
		/* 820F0598h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1);
		/* 820F0598h case    7:*/		return 0x820F059C;
		  /* 820F059Ch */ case    8:  		/* lfd FR1, <#[R8 + 32]> */
		/* 820F059Ch case    8:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R8 + 0x00000020) );
		/* 820F059Ch case    8:*/		return 0x820F05A0;
		  /* 820F05A0h */ case    9:  		/* li R5, 0 */
		/* 820F05A0h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F05A0h case    9:*/		return 0x820F05A4;
		  /* 820F05A4h */ case   10:  		/* lwz R4, <#[R31 + 372]> */
		/* 820F05A4h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000174) );
		/* 820F05A4h case   10:*/		return 0x820F05A8;
		  /* 820F05A8h */ case   11:  		/* mr R3, R31 */
		/* 820F05A8h case   11:*/		regs.R3 = regs.R31;
		/* 820F05A8h case   11:*/		return 0x820F05AC;
		  /* 820F05ACh */ case   12:  		/* bl 52348 */
		/* 820F05ACh case   12:*/		regs.LR = 0x820F05B0; return 0x820FD228;
		/* 820F05ACh case   12:*/		return 0x820F05B0;
		  /* 820F05B0h */ case   13:  		/* stwx R3, <#[R29 + R31]> */
		/* 820F05B0h case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 820F05B0h case   13:*/		return 0x820F05B4;
		  /* 820F05B4h */ case   14:  		/* mr R10, R3 */
		/* 820F05B4h case   14:*/		regs.R10 = regs.R3;
		/* 820F05B4h case   14:*/		return 0x820F05B8;
		  /* 820F05B8h */ case   15:  		/* cmpwi CR6, R3, -1 */
		/* 820F05B8h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820F05B8h case   15:*/		return 0x820F05BC;
		  /* 820F05BCh */ case   16:  		/* bc 12, CR6_EQ, -292 */
		/* 820F05BCh case   16:*/		if ( regs.CR[6].eq ) { return 0x820F0498;  }
		/* 820F05BCh case   16:*/		return 0x820F05C0;
	}
	return 0x820F05C0;
} // Block from 820F057Ch-820F05C0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820F05C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F05C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F05C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F05C0);
		  /* 820F05C0h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820F05C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F05C0h case    0:*/		return 0x820F05C4;
		  /* 820F05C4h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820F05C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F05D8;  }
		/* 820F05C4h case    1:*/		return 0x820F05C8;
		  /* 820F05C8h */ case    2:  		/* addi R11, R1, 220 */
		/* 820F05C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xDC);
		/* 820F05C8h case    2:*/		return 0x820F05CC;
		  /* 820F05CCh */ case    3:  		/* mtspr CTR, R30 */
		/* 820F05CCh case    3:*/		regs.CTR = regs.R30;
		/* 820F05CCh case    3:*/		return 0x820F05D0;
		  /* 820F05D0h */ case    4:  		/* stwu R10, <#[R11 + 4]> */
		/* 820F05D0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820F05D0h case    4:*/		return 0x820F05D4;
		  /* 820F05D4h */ case    5:  		/* bc 16, CR0_LT, -4 */
		/* 820F05D4h case    5:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F05D0;  }
		/* 820F05D4h case    5:*/		return 0x820F05D8;
	}
	return 0x820F05D8;
} // Block from 820F05C0h-820F05D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F05D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F05D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F05D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F05D8);
		  /* 820F05D8h */ case    0:  		/* li R3, 116 */
		/* 820F05D8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x74);
		/* 820F05D8h case    0:*/		return 0x820F05DC;
		  /* 820F05DCh */ case    1:  		/* bl 49084 */
		/* 820F05DCh case    1:*/		regs.LR = 0x820F05E0; return 0x820FC598;
		/* 820F05DCh case    1:*/		return 0x820F05E0;
		  /* 820F05E0h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820F05E0h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820F05E0h case    2:*/		return 0x820F05E4;
		  /* 820F05E4h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820F05E4h case    3:*/		if ( regs.CR[0].eq ) { return 0x820F05F4;  }
		/* 820F05E4h case    3:*/		return 0x820F05E8;
		  /* 820F05E8h */ case    4:  		/* bl 47288 */
		/* 820F05E8h case    4:*/		regs.LR = 0x820F05EC; return 0x820FBEA0;
		/* 820F05E8h case    4:*/		return 0x820F05EC;
		  /* 820F05ECh */ case    5:  		/* mr R26, R3 */
		/* 820F05ECh case    5:*/		regs.R26 = regs.R3;
		/* 820F05ECh case    5:*/		return 0x820F05F0;
		  /* 820F05F0h */ case    6:  		/* b 8 */
		/* 820F05F0h case    6:*/		return 0x820F05F8;
		/* 820F05F0h case    6:*/		return 0x820F05F4;
	}
	return 0x820F05F4;
} // Block from 820F05D8h-820F05F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F05F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F05F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F05F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F05F4);
		  /* 820F05F4h */ case    0:  		/* mr R26, R25 */
		/* 820F05F4h case    0:*/		regs.R26 = regs.R25;
		/* 820F05F4h case    0:*/		return 0x820F05F8;
	}
	return 0x820F05F8;
} // Block from 820F05F4h-820F05F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F05F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F05F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F05F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F05F8);
		  /* 820F05F8h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 820F05F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820F05F8h case    0:*/		return 0x820F05FC;
		  /* 820F05FCh */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820F05FCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F060C;  }
		/* 820F05FCh case    1:*/		return 0x820F0600;
		  /* 820F0600h */ case    2:  		/* lis R29, -32761 */
		/* 820F0600h case    2:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8007);
		/* 820F0600h case    2:*/		return 0x820F0604;
		  /* 820F0604h */ case    3:  		/* ori R29, R29, 14 */
		/* 820F0604h case    3:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0xE);
		/* 820F0604h case    3:*/		return 0x820F0608;
		  /* 820F0608h */ case    4:  		/* b 244 */
		/* 820F0608h case    4:*/		return 0x820F06FC;
		/* 820F0608h case    4:*/		return 0x820F060C;
	}
	return 0x820F060C;
} // Block from 820F05F8h-820F060Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F060Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F060C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F060C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F060C);
		  /* 820F060Ch */ case    0:  		/* rlwinm R11, R30, 0, 12, 31 */
		/* 820F060Ch case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R30);
		/* 820F060Ch case    0:*/		return 0x820F0610;
		  /* 820F0610h */ case    1:  		/* cmpwi CR6, R27, 0 */
		/* 820F0610h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820F0610h case    1:*/		return 0x820F0614;
		  /* 820F0614h */ case    2:  		/* oris R4, R11, 28736 */
		/* 820F0614h case    2:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R11,0x7040);
		/* 820F0614h case    2:*/		return 0x820F0618;
		  /* 820F0618h */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 820F0618h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820F0620;  }
		/* 820F0618h case    3:*/		return 0x820F061C;
		  /* 820F061Ch */ case    4:  		/* oris R4, R11, 28720 */
		/* 820F061Ch case    4:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R11,0x7030);
		/* 820F061Ch case    4:*/		return 0x820F0620;
	}
	return 0x820F0620;
} // Block from 820F060Ch-820F0620h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F0620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0620);
		  /* 820F0620h */ case    0:  		/* li R7, 0 */
		/* 820F0620h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F0620h case    0:*/		return 0x820F0624;
		  /* 820F0624h */ case    1:  		/* mr R6, R30 */
		/* 820F0624h case    1:*/		regs.R6 = regs.R30;
		/* 820F0624h case    1:*/		return 0x820F0628;
		  /* 820F0628h */ case    2:  		/* mulli R5, R30, 3 */
		/* 820F0628h case    2:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R30,0x3);
		/* 820F0628h case    2:*/		return 0x820F062C;
		  /* 820F062Ch */ case    3:  		/* mr R3, R26 */
		/* 820F062Ch case    3:*/		regs.R3 = regs.R26;
		/* 820F062Ch case    3:*/		return 0x820F0630;
		  /* 820F0630h */ case    4:  		/* bl 49152 */
		/* 820F0630h case    4:*/		regs.LR = 0x820F0634; return 0x820FC630;
		/* 820F0630h case    4:*/		return 0x820F0634;
		  /* 820F0634h */ case    5:  		/* or. R29, R3, R3 */
		/* 820F0634h case    5:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F0634h case    5:*/		return 0x820F0638;
		  /* 820F0638h */ case    6:  		/* bc 12, CR0_LT, 172 */
		/* 820F0638h case    6:*/		if ( regs.CR[0].lt ) { return 0x820F06E4;  }
		/* 820F0638h case    6:*/		return 0x820F063C;
		  /* 820F063Ch */ case    7:  		/* mr R3, R26 */
		/* 820F063Ch case    7:*/		regs.R3 = regs.R26;
		/* 820F063Ch case    7:*/		return 0x820F0640;
		  /* 820F0640h */ case    8:  		/* lwz R4, <#[R31 + 260]> */
		/* 820F0640h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000104) );
		/* 820F0640h case    8:*/		return 0x820F0644;
		  /* 820F0644h */ case    9:  		/* bl 47276 */
		/* 820F0644h case    9:*/		regs.LR = 0x820F0648; return 0x820FBEF0;
		/* 820F0644h case    9:*/		return 0x820F0648;
		  /* 820F0648h */ case   10:  		/* or. R29, R3, R3 */
		/* 820F0648h case   10:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F0648h case   10:*/		return 0x820F064C;
		  /* 820F064Ch */ case   11:  		/* bc 12, CR0_LT, 152 */
		/* 820F064Ch case   11:*/		if ( regs.CR[0].lt ) { return 0x820F06E4;  }
		/* 820F064Ch case   11:*/		return 0x820F0650;
		  /* 820F0650h */ case   12:  		/* mr R8, R25 */
		/* 820F0650h case   12:*/		regs.R8 = regs.R25;
		/* 820F0650h case   12:*/		return 0x820F0654;
		  /* 820F0654h */ case   13:  		/* cmplwi CR6, R30, 0 */
		/* 820F0654h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F0654h case   13:*/		return 0x820F0658;
		  /* 820F0658h */ case   14:  		/* bc 12, CR6_EQ, 108 */
		/* 820F0658h case   14:*/		if ( regs.CR[6].eq ) { return 0x820F06C4;  }
		/* 820F0658h case   14:*/		return 0x820F065C;
		  /* 820F065Ch */ case   15:  		/* mtspr CTR, R30 */
		/* 820F065Ch case   15:*/		regs.CTR = regs.R30;
		/* 820F065Ch case   15:*/		return 0x820F0660;
		  /* 820F0660h */ case   16:  		/* rlwinm R7, R30, 1, 0, 30 */
		/* 820F0660h case   16:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R7,regs.R30);
		/* 820F0660h case   16:*/		return 0x820F0664;
		  /* 820F0664h */ case   17:  		/* mr R11, R25 */
		/* 820F0664h case   17:*/		regs.R11 = regs.R25;
		/* 820F0664h case   17:*/		return 0x820F0668;
		  /* 820F0668h */ case   18:  		/* rlwinm R9, R30, 2, 0, 29 */
		/* 820F0668h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R30);
		/* 820F0668h case   18:*/		return 0x820F066C;
		  /* 820F066Ch */ case   19:  		/* lwz R6, <#[R31 + 260]> */
		/* 820F066Ch case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000104) );
		/* 820F066Ch case   19:*/		return 0x820F0670;
		  /* 820F0670h */ case   20:  		/* addi R10, R1, 208 */
		/* 820F0670h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xD0);
		/* 820F0670h case   20:*/		return 0x820F0674;
		  /* 820F0674h */ case   21:  		/* lwz R5, <#[R26 + 16]> */
		/* 820F0674h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x00000010) );
		/* 820F0674h case   21:*/		return 0x820F0678;
		  /* 820F0678h */ case   22:  		/* add R4, R7, R8 */
		/* 820F0678h case   22:*/		cpu::op::add<0>(regs,&regs.R4,regs.R7,regs.R8);
		/* 820F0678h case   22:*/		return 0x820F067C;
		  /* 820F067Ch */ case   23:  		/* add R10, R11, R10 */
		/* 820F067Ch case   23:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820F067Ch case   23:*/		return 0x820F0680;
		  /* 820F0680h */ case   24:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 820F0680h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 820F0680h case   24:*/		return 0x820F0684;
		  /* 820F0684h */ case   25:  		/* addi R8, R8, 1 */
		/* 820F0684h case   25:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F0684h case   25:*/		return 0x820F0688;
		  /* 820F0688h */ case   26:  		/* lwz R6, <#[R6 + 16]> */
		/* 820F0688h case   26:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000010) );
		/* 820F0688h case   26:*/		return 0x820F068C;
		  /* 820F068Ch */ case   27:  		/* lwz R3, <#[R10 - 16]> */
		/* 820F068Ch case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0xFFFFFFF0) );
		/* 820F068Ch case   27:*/		return 0x820F0690;
		  /* 820F0690h */ case   28:  		/* lwz R30, <#[R10]> */
		/* 820F0690h case   28:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x00000000) );
		/* 820F0690h case   28:*/		return 0x820F0694;
		  /* 820F0694h */ case   29:  		/* lwz R10, <#[R10 + 16]> */
		/* 820F0694h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820F0694h case   29:*/		return 0x820F0698;
		  /* 820F0698h */ case   30:  		/* lwzx R6, <#[R6 + R11]> */
		/* 820F0698h case   30:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820F0698h case   30:*/		return 0x820F069C;
		  /* 820F069Ch */ case   31:  		/* stwx R6, <#[R5 + R11]> */
		/* 820F069Ch case   31:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820F069Ch case   31:*/		return 0x820F06A0;
		  /* 820F06A0h */ case   32:  		/* lwz R6, <#[R26 + 8]> */
		/* 820F06A0h case   32:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000008) );
		/* 820F06A0h case   32:*/		return 0x820F06A4;
		  /* 820F06A4h */ case   33:  		/* stwx R3, <#[R6 + R11]> */
		/* 820F06A4h case   33:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820F06A4h case   33:*/		return 0x820F06A8;
		  /* 820F06A8h */ case   34:  		/* addi R11, R11, 4 */
		/* 820F06A8h case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F06A8h case   34:*/		return 0x820F06AC;
		  /* 820F06ACh */ case   35:  		/* lwz R6, <#[R26 + 8]> */
		/* 820F06ACh case   35:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000008) );
		/* 820F06ACh case   35:*/		return 0x820F06B0;
		  /* 820F06B0h */ case   36:  		/* stwx R30, <#[R6 + R9]> */
		/* 820F06B0h case   36:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R6 + regs.R9 + 0x00000000) );
		/* 820F06B0h case   36:*/		return 0x820F06B4;
		  /* 820F06B4h */ case   37:  		/* addi R9, R9, 4 */
		/* 820F06B4h case   37:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F06B4h case   37:*/		return 0x820F06B8;
		  /* 820F06B8h */ case   38:  		/* lwz R6, <#[R26 + 8]> */
		/* 820F06B8h case   38:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000008) );
		/* 820F06B8h case   38:*/		return 0x820F06BC;
		  /* 820F06BCh */ case   39:  		/* stwx R10, <#[R4 + R6]> */
		/* 820F06BCh case   39:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + regs.R6 + 0x00000000) );
		/* 820F06BCh case   39:*/		return 0x820F06C0;
		  /* 820F06C0h */ case   40:  		/* bc 16, CR0_LT, -84 */
		/* 820F06C0h case   40:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F066C;  }
		/* 820F06C0h case   40:*/		return 0x820F06C4;
	}
	return 0x820F06C4;
} // Block from 820F0620h-820F06C4h (41 instructions)

//////////////////////////////////////////////////////
// Block at 820F06C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F06C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F06C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F06C4);
		  /* 820F06C4h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 820F06C4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 820F06C4h case    0:*/		return 0x820F06C8;
		  /* 820F06C8h */ case    1:  		/* mr R4, R26 */
		/* 820F06C8h case    1:*/		regs.R4 = regs.R26;
		/* 820F06C8h case    1:*/		return 0x820F06CC;
		  /* 820F06CCh */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 820F06CCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820F0708;  }
		/* 820F06CCh case    2:*/		return 0x820F06D0;
		  /* 820F06D0h */ case    3:  		/* lwz R3, <#[R31 + 260]> */
		/* 820F06D0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820F06D0h case    3:*/		return 0x820F06D4;
		  /* 820F06D4h */ case    4:  		/* bl 49788 */
		/* 820F06D4h case    4:*/		regs.LR = 0x820F06D8; return 0x820FC950;
		/* 820F06D4h case    4:*/		return 0x820F06D8;
		  /* 820F06D8h */ case    5:  		/* or. R29, R3, R3 */
		/* 820F06D8h case    5:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F06D8h case    5:*/		return 0x820F06DC;
		  /* 820F06DCh */ case    6:  		/* bc 12, CR0_LT, 8 */
		/* 820F06DCh case    6:*/		if ( regs.CR[0].lt ) { return 0x820F06E4;  }
		/* 820F06DCh case    6:*/		return 0x820F06E0;
	}
	return 0x820F06E0;
} // Block from 820F06C4h-820F06E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F06E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F06E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F06E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F06E0);
		  /* 820F06E0h */ case    0:  		/* mr R29, R25 */
		/* 820F06E0h case    0:*/		regs.R29 = regs.R25;
		/* 820F06E0h case    0:*/		return 0x820F06E4;
	}
	return 0x820F06E4;
} // Block from 820F06E0h-820F06E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F06E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F06E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F06E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F06E4);
		  /* 820F06E4h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 820F06E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820F06E4h case    0:*/		return 0x820F06E8;
		  /* 820F06E8h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820F06E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F06FC;  }
		/* 820F06E8h case    1:*/		return 0x820F06EC;
		  /* 820F06ECh */ case    2:  		/* mr R3, R26 */
		/* 820F06ECh case    2:*/		regs.R3 = regs.R26;
		/* 820F06ECh case    2:*/		return 0x820F06F0;
		  /* 820F06F0h */ case    3:  		/* bl 1232080 */
		/* 820F06F0h case    3:*/		regs.LR = 0x820F06F4; return 0x8221D3C0;
		/* 820F06F0h case    3:*/		return 0x820F06F4;
		  /* 820F06F4h */ case    4:  		/* mr R3, R26 */
		/* 820F06F4h case    4:*/		regs.R3 = regs.R26;
		/* 820F06F4h case    4:*/		return 0x820F06F8;
		  /* 820F06F8h */ case    5:  		/* bl 48888 */
		/* 820F06F8h case    5:*/		regs.LR = 0x820F06FC; return 0x820FC5F0;
		/* 820F06F8h case    5:*/		return 0x820F06FC;
	}
	return 0x820F06FC;
} // Block from 820F06E4h-820F06FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F06FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F06FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F06FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F06FC);
		  /* 820F06FCh */ case    0:  		/* mr R3, R29 */
		/* 820F06FCh case    0:*/		regs.R3 = regs.R29;
		/* 820F06FCh case    0:*/		return 0x820F0700;
	}
	return 0x820F0700;
} // Block from 820F06FCh-820F0700h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F0700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0700);
		  /* 820F0700h */ case    0:  		/* addi R1, R1, 432 */
		/* 820F0700h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1B0);
		/* 820F0700h case    0:*/		return 0x820F0704;
		  /* 820F0704h */ case    1:  		/* b -390252 */
		/* 820F0704h case    1:*/		return 0x82091298;
		/* 820F0704h case    1:*/		return 0x820F0708;
	}
	return 0x820F0708;
} // Block from 820F0700h-820F0708h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F0708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0708);
		  /* 820F0708h */ case    0:  		/* addi R5, R1, 128 */
		/* 820F0708h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 820F0708h case    0:*/		return 0x820F070C;
		  /* 820F070Ch */ case    1:  		/* lwz R6, <#[R1 + 96]> */
		/* 820F070Ch case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 820F070Ch case    1:*/		return 0x820F0710;
		  /* 820F0710h */ case    2:  		/* mr R3, R31 */
		/* 820F0710h case    2:*/		regs.R3 = regs.R31;
		/* 820F0710h case    2:*/		return 0x820F0714;
		  /* 820F0714h */ case    3:  		/* bl -28004 */
		/* 820F0714h case    3:*/		regs.LR = 0x820F0718; return 0x820E99B0;
		/* 820F0714h case    3:*/		return 0x820F0718;
		  /* 820F0718h */ case    4:  		/* b -24 */
		/* 820F0718h case    4:*/		return 0x820F0700;
		/* 820F0718h case    4:*/		return 0x820F071C;
		  /* 820F071Ch */ case    5:  		/* nop */
		/* 820F071Ch case    5:*/		cpu::op::nop();
		/* 820F071Ch case    5:*/		return 0x820F0720;
		  /* 820F0720h */ case    6:  		/* lwz R11, <#[R3 + 20]> */
		/* 820F0720h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820F0720h case    6:*/		return 0x820F0724;
		  /* 820F0724h */ case    7:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 820F0724h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 820F0724h case    7:*/		return 0x820F0728;
		  /* 820F0728h */ case    8:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820F0728h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F0728h case    8:*/		return 0x820F072C;
		  /* 820F072Ch */ case    9:  		/* lwz R11, <#[R10 + 84]> */
		/* 820F072Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000054) );
		/* 820F072Ch case    9:*/		return 0x820F0730;
		  /* 820F0730h */ case   10:  		/* cmpwi CR6, R11, -1 */
		/* 820F0730h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820F0730h case   10:*/		return 0x820F0734;
		  /* 820F0734h */ case   11:  		/* bc 12, CR6_EQ, 136 */
		/* 820F0734h case   11:*/		if ( regs.CR[6].eq ) { return 0x820F07BC;  }
		/* 820F0734h case   11:*/		return 0x820F0738;
		  /* 820F0738h */ case   12:  		/* lwz R9, <#[R3 + 108]> */
		/* 820F0738h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000006C) );
		/* 820F0738h case   12:*/		return 0x820F073C;
		  /* 820F073Ch */ case   13:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 820F073Ch case   13:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 820F073Ch case   13:*/		return 0x820F0740;
		  /* 820F0740h */ case   14:  		/* bc 4, CR0_EQ, 124 */
		/* 820F0740h case   14:*/		if ( !regs.CR[0].eq ) { return 0x820F07BC;  }
		/* 820F0740h case   14:*/		return 0x820F0744;
		  /* 820F0744h */ case   15:  		/* lwz R5, <#[R10 + 88]> */
		/* 820F0744h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000058) );
		/* 820F0744h case   15:*/		return 0x820F0748;
		  /* 820F0748h */ case   16:  		/* mr R7, R11 */
		/* 820F0748h case   16:*/		regs.R7 = regs.R11;
		/* 820F0748h case   16:*/		return 0x820F074C;
		  /* 820F074Ch */ case   17:  		/* cmplw CR6, R11, R5 */
		/* 820F074Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 820F074Ch case   17:*/		return 0x820F0750;
		  /* 820F0750h */ case   18:  		/* bc 12, CR6_GT, 108 */
		/* 820F0750h case   18:*/		if ( regs.CR[6].gt ) { return 0x820F07BC;  }
		/* 820F0750h case   18:*/		return 0x820F0754;
		  /* 820F0754h */ case   19:  		/* lwz R10, <#[R3 + 24]> */
		/* 820F0754h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820F0754h case   19:*/		return 0x820F0758;
		  /* 820F0758h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F0758h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F0758h case   20:*/		return 0x820F075C;
		  /* 820F075Ch */ case   21:  		/* add R6, R11, R10 */
		/* 820F075Ch case   21:*/		cpu::op::add<0>(regs,&regs.R6,regs.R11,regs.R10);
		/* 820F075Ch case   21:*/		return 0x820F0760;
		  /* 820F0760h */ case   22:  		/* lwz R11, <#[R6]> */
		/* 820F0760h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 820F0760h case   22:*/		return 0x820F0764;
		  /* 820F0764h */ case   23:  		/* lis R10, 24576 */
		/* 820F0764h case   23:*/		cpu::op::lis<0>(regs,&regs.R10,0x6000);
		/* 820F0764h case   23:*/		return 0x820F0768;
		  /* 820F0768h */ case   24:  		/* lwz R9, <#[R11]> */
		/* 820F0768h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820F0768h case   24:*/		return 0x820F076C;
		  /* 820F076Ch */ case   25:  		/* rlwinm R9, R9, 0, 0, 3 */
		/* 820F076Ch case   25:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R9,regs.R9);
		/* 820F076Ch case   25:*/		return 0x820F0770;
		  /* 820F0770h */ case   26:  		/* cmplw CR6, R9, R10 */
		/* 820F0770h case   26:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820F0770h case   26:*/		return 0x820F0774;
		  /* 820F0774h */ case   27:  		/* bc 4, CR6_EQ, 56 */
		/* 820F0774h case   27:*/		if ( !regs.CR[6].eq ) { return 0x820F07AC;  }
		/* 820F0774h case   27:*/		return 0x820F0778;
		  /* 820F0778h */ case   28:  		/* lwz R8, <#[R11 + 4]> */
		/* 820F0778h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820F0778h case   28:*/		return 0x820F077C;
		  /* 820F077Ch */ case   29:  		/* li R10, 0 */
		/* 820F077Ch case   29:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F077Ch case   29:*/		return 0x820F0780;
		  /* 820F0780h */ case   30:  		/* cmplwi CR6, R8, 0 */
		/* 820F0780h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820F0780h case   30:*/		return 0x820F0784;
		  /* 820F0784h */ case   31:  		/* bc 12, CR6_EQ, 40 */
		/* 820F0784h case   31:*/		if ( regs.CR[6].eq ) { return 0x820F07AC;  }
		/* 820F0784h case   31:*/		return 0x820F0788;
		  /* 820F0788h */ case   32:  		/* lwz R9, <#[R11 + 8]> */
		/* 820F0788h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820F0788h case   32:*/		return 0x820F078C;
		  /* 820F078Ch */ case   33:  		/* li R11, 0 */
		/* 820F078Ch case   33:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F078Ch case   33:*/		return 0x820F0790;
		  /* 820F0790h */ case   34:  		/* lwzx R3, <#[R11 + R9]> */
		/* 820F0790h case   34:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F0790h case   34:*/		return 0x820F0794;
		  /* 820F0794h */ case   35:  		/* cmplw CR6, R3, R4 */
		/* 820F0794h case   35:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 820F0794h case   35:*/		return 0x820F0798;
		  /* 820F0798h */ case   36:  		/* bc 12, CR6_EQ, 44 */
		/* 820F0798h case   36:*/		if ( regs.CR[6].eq ) { return 0x820F07C4;  }
		/* 820F0798h case   36:*/		return 0x820F079C;
		  /* 820F079Ch */ case   37:  		/* addi R10, R10, 1 */
		/* 820F079Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F079Ch case   37:*/		return 0x820F07A0;
		  /* 820F07A0h */ case   38:  		/* addi R11, R11, 4 */
		/* 820F07A0h case   38:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F07A0h case   38:*/		return 0x820F07A4;
		  /* 820F07A4h */ case   39:  		/* cmplw CR6, R10, R8 */
		/* 820F07A4h case   39:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820F07A4h case   39:*/		return 0x820F07A8;
		  /* 820F07A8h */ case   40:  		/* bc 12, CR6_LT, -24 */
		/* 820F07A8h case   40:*/		if ( regs.CR[6].lt ) { return 0x820F0790;  }
		/* 820F07A8h case   40:*/		return 0x820F07AC;
	}
	return 0x820F07AC;
} // Block from 820F0708h-820F07ACh (41 instructions)

//////////////////////////////////////////////////////
// Block at 820F07ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F07AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F07AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F07AC);
		  /* 820F07ACh */ case    0:  		/* addi R7, R7, 1 */
		/* 820F07ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820F07ACh case    0:*/		return 0x820F07B0;
		  /* 820F07B0h */ case    1:  		/* addi R6, R6, 4 */
		/* 820F07B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 820F07B0h case    1:*/		return 0x820F07B4;
		  /* 820F07B4h */ case    2:  		/* cmplw CR6, R7, R5 */
		/* 820F07B4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R5);
		/* 820F07B4h case    2:*/		return 0x820F07B8;
		  /* 820F07B8h */ case    3:  		/* bc 4, CR6_GT, -88 */
		/* 820F07B8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820F0760;  }
		/* 820F07B8h case    3:*/		return 0x820F07BC;
	}
	return 0x820F07BC;
} // Block from 820F07ACh-820F07BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F07BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F07BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F07BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F07BC);
		  /* 820F07BCh */ case    0:  		/* li R3, 0 */
		/* 820F07BCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F07BCh case    0:*/		return 0x820F07C0;
		  /* 820F07C0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820F07C0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F07C0h case    1:*/		return 0x820F07C4;
	}
	return 0x820F07C4;
} // Block from 820F07BCh-820F07C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F07C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F07C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F07C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F07C4);
		  /* 820F07C4h */ case    0:  		/* li R3, 1 */
		/* 820F07C4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F07C4h case    0:*/		return 0x820F07C8;
		  /* 820F07C8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820F07C8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F07C8h case    1:*/		return 0x820F07CC;
	}
	return 0x820F07CC;
} // Block from 820F07C4h-820F07CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F07CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F07CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F07CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F07CC);
		  /* 820F07CCh */ case    0:  		/* nop */
		/* 820F07CCh case    0:*/		cpu::op::nop();
		/* 820F07CCh case    0:*/		return 0x820F07D0;
	}
	return 0x820F07D0;
} // Block from 820F07CCh-820F07D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F07D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F07D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F07D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F07D0);
		  /* 820F07D0h */ case    0:  		/* mfspr R12, LR */
		/* 820F07D0h case    0:*/		regs.R12 = regs.LR;
		/* 820F07D0h case    0:*/		return 0x820F07D4;
		  /* 820F07D4h */ case    1:  		/* bl -390540 */
		/* 820F07D4h case    1:*/		regs.LR = 0x820F07D8; return 0x82091248;
		/* 820F07D4h case    1:*/		return 0x820F07D8;
		  /* 820F07D8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820F07D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820F07D8h case    2:*/		return 0x820F07DC;
		  /* 820F07DCh */ case    3:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F07DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F07DCh case    3:*/		return 0x820F07E0;
		  /* 820F07E0h */ case    4:  		/* lis R10, 28720 */
		/* 820F07E0h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x7030);
		/* 820F07E0h case    4:*/		return 0x820F07E4;
		  /* 820F07E4h */ case    5:  		/* mr R25, R3 */
		/* 820F07E4h case    5:*/		regs.R25 = regs.R3;
		/* 820F07E4h case    5:*/		return 0x820F07E8;
		  /* 820F07E8h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 820F07E8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F07E8h case    6:*/		return 0x820F07EC;
		  /* 820F07ECh */ case    7:  		/* rlwinm R9, R11, 0, 0, 11 */
		/* 820F07ECh case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R11);
		/* 820F07ECh case    7:*/		return 0x820F07F0;
		  /* 820F07F0h */ case    8:  		/* rlwinm R30, R11, 0, 12, 31 */
		/* 820F07F0h case    8:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R11);
		/* 820F07F0h case    8:*/		return 0x820F07F4;
		  /* 820F07F4h */ case    9:  		/* cmplw CR6, R9, R10 */
		/* 820F07F4h case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820F07F4h case    9:*/		return 0x820F07F8;
		  /* 820F07F8h */ case   10:  		/* bc 4, CR6_EQ, 496 */
		/* 820F07F8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820F09E8;  }
		/* 820F07F8h case   10:*/		return 0x820F07FC;
		  /* 820F07FCh */ case   11:  		/* lwz R29, <#[R3 + 260]> */
		/* 820F07FCh case   11:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000104) );
		/* 820F07FCh case   11:*/		return 0x820F0800;
		  /* 820F0800h */ case   12:  		/* li R11, 517 */
		/* 820F0800h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x205);
		/* 820F0800h case   12:*/		return 0x820F0804;
		  /* 820F0804h */ case   13:  		/* mr R4, R30 */
		/* 820F0804h case   13:*/		regs.R4 = regs.R30;
		/* 820F0804h case   13:*/		return 0x820F0808;
		  /* 820F0808h */ case   14:  		/* lwz R24, <#[R3 + 256]> */
		/* 820F0808h case   14:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R3 + 0x00000100) );
		/* 820F0808h case   14:*/		return 0x820F080C;
		  /* 820F080Ch */ case   15:  		/* li R7, 2 */
		/* 820F080Ch case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 820F080Ch case   15:*/		return 0x820F0810;
		  /* 820F0810h */ case   16:  		/* rlwimi R4, R11, 20, 0, 11 */
		/* 820F0810h case   16:*/		cpu::op::rlwimi<0,20,0,11>(regs,&regs.R4,regs.R11);
		/* 820F0810h case   16:*/		return 0x820F0814;
		  /* 820F0814h */ case   17:  		/* addi R6, R1, 80 */
		/* 820F0814h case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820F0814h case   17:*/		return 0x820F0818;
		  /* 820F0818h */ case   18:  		/* mr R5, R29 */
		/* 820F0818h case   18:*/		regs.R5 = regs.R29;
		/* 820F0818h case   18:*/		return 0x820F081C;
		  /* 820F081Ch */ case   19:  		/* bl -16668 */
		/* 820F081Ch case   19:*/		regs.LR = 0x820F0820; return 0x820EC700;
		/* 820F081Ch case   19:*/		return 0x820F0820;
		  /* 820F0820h */ case   20:  		/* lwz R28, <#[R1 + 88]> */
		/* 820F0820h case   20:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000058) );
		/* 820F0820h case   20:*/		return 0x820F0824;
		  /* 820F0824h */ case   21:  		/* cmplwi CR6, R28, 0 */
		/* 820F0824h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820F0824h case   21:*/		return 0x820F0828;
		  /* 820F0828h */ case   22:  		/* bc 12, CR6_EQ, 448 */
		/* 820F0828h case   22:*/		if ( regs.CR[6].eq ) { return 0x820F09E8;  }
		/* 820F0828h case   22:*/		return 0x820F082C;
		  /* 820F082Ch */ case   23:  		/* li R7, 0 */
		/* 820F082Ch case   23:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F082Ch case   23:*/		return 0x820F0830;
		  /* 820F0830h */ case   24:  		/* cmplwi CR6, R30, 0 */
		/* 820F0830h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F0830h case   24:*/		return 0x820F0834;
		  /* 820F0834h */ case   25:  		/* bc 12, CR6_EQ, 60 */
		/* 820F0834h case   25:*/		if ( regs.CR[6].eq ) { return 0x820F0870;  }
		/* 820F0834h case   25:*/		return 0x820F0838;
		  /* 820F0838h */ case   26:  		/* lwz R10, <#[R29 + 8]> */
		/* 820F0838h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 820F0838h case   26:*/		return 0x820F083C;
		  /* 820F083Ch */ case   27:  		/* rlwinm R8, R30, 1, 0, 30 */
		/* 820F083Ch case   27:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R30);
		/* 820F083Ch case   27:*/		return 0x820F0840;
		  /* 820F0840h */ case   28:  		/* lwz R9, <#[R28 + 16]> */
		/* 820F0840h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000010) );
		/* 820F0840h case   28:*/		return 0x820F0844;
		  /* 820F0844h */ case   29:  		/* li R11, 0 */
		/* 820F0844h case   29:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F0844h case   29:*/		return 0x820F0848;
		  /* 820F0848h */ case   30:  		/* add R6, R8, R7 */
		/* 820F0848h case   30:*/		cpu::op::add<0>(regs,&regs.R6,regs.R8,regs.R7);
		/* 820F0848h case   30:*/		return 0x820F084C;
		  /* 820F084Ch */ case   31:  		/* lwzx R5, <#[R11 + R9]> */
		/* 820F084Ch case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F084Ch case   31:*/		return 0x820F0850;
		  /* 820F0850h */ case   32:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F0850h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F0850h case   32:*/		return 0x820F0854;
		  /* 820F0854h */ case   33:  		/* lwzx R6, <#[R6 + R10]> */
		/* 820F0854h case   33:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 820F0854h case   33:*/		return 0x820F0858;
		  /* 820F0858h */ case   34:  		/* cmplw CR6, R6, R5 */
		/* 820F0858h case   34:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 820F0858h case   34:*/		return 0x820F085C;
		  /* 820F085Ch */ case   35:  		/* bc 4, CR6_EQ, 396 */
		/* 820F085Ch case   35:*/		if ( !regs.CR[6].eq ) { return 0x820F09E8;  }
		/* 820F085Ch case   35:*/		return 0x820F0860;
		  /* 820F0860h */ case   36:  		/* addi R7, R7, 1 */
		/* 820F0860h case   36:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820F0860h case   36:*/		return 0x820F0864;
		  /* 820F0864h */ case   37:  		/* addi R11, R11, 4 */
		/* 820F0864h case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F0864h case   37:*/		return 0x820F0868;
		  /* 820F0868h */ case   38:  		/* cmplw CR6, R7, R30 */
		/* 820F0868h case   38:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R30);
		/* 820F0868h case   38:*/		return 0x820F086C;
		  /* 820F086Ch */ case   39:  		/* bc 12, CR6_LT, -36 */
		/* 820F086Ch case   39:*/		if ( regs.CR[6].lt ) { return 0x820F0848;  }
		/* 820F086Ch case   39:*/		return 0x820F0870;
	}
	return 0x820F0870;
} // Block from 820F07D0h-820F0870h (40 instructions)

//////////////////////////////////////////////////////
// Block at 820F0870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0870);
		  /* 820F0870h */ case    0:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820F0870h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820F0870h case    0:*/		return 0x820F0874;
		  /* 820F0874h */ case    1:  		/* lwz R31, <#[R29 + 8]> */
		/* 820F0874h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000008) );
		/* 820F0874h case    1:*/		return 0x820F0878;
		  /* 820F0878h */ case    2:  		/* lwz R30, <#[R28 + 8]> */
		/* 820F0878h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000008) );
		/* 820F0878h case    2:*/		return 0x820F087C;
		  /* 820F087Ch */ case    3:  		/* mr R10, R24 */
		/* 820F087Ch case    3:*/		regs.R10 = regs.R24;
		/* 820F087Ch case    3:*/		return 0x820F0880;
		  /* 820F0880h */ case    4:  		/* add R27, R11, R31 */
		/* 820F0880h case    4:*/		cpu::op::add<0>(regs,&regs.R27,regs.R11,regs.R31);
		/* 820F0880h case    4:*/		return 0x820F0884;
		  /* 820F0884h */ case    5:  		/* add R26, R30, R11 */
		/* 820F0884h case    5:*/		cpu::op::add<0>(regs,&regs.R26,regs.R30,regs.R11);
		/* 820F0884h case    5:*/		return 0x820F0888;
		  /* 820F0888h */ case    6:  		/* mr R9, R29 */
		/* 820F0888h case    6:*/		regs.R9 = regs.R29;
		/* 820F0888h case    6:*/		return 0x820F088C;
		  /* 820F088Ch */ case    7:  		/* mr R8, R28 */
		/* 820F088Ch case    7:*/		regs.R8 = regs.R28;
		/* 820F088Ch case    7:*/		return 0x820F0890;
		  /* 820F0890h */ case    8:  		/* mr R3, R25 */
		/* 820F0890h case    8:*/		regs.R3 = regs.R25;
		/* 820F0890h case    8:*/		return 0x820F0894;
		  /* 820F0894h */ case    9:  		/* mr R4, R31 */
		/* 820F0894h case    9:*/		regs.R4 = regs.R31;
		/* 820F0894h case    9:*/		return 0x820F0898;
		  /* 820F0898h */ case   10:  		/* mr R5, R27 */
		/* 820F0898h case   10:*/		regs.R5 = regs.R27;
		/* 820F0898h case   10:*/		return 0x820F089C;
		  /* 820F089Ch */ case   11:  		/* mr R6, R30 */
		/* 820F089Ch case   11:*/		regs.R6 = regs.R30;
		/* 820F089Ch case   11:*/		return 0x820F08A0;
		  /* 820F08A0h */ case   12:  		/* mr R7, R26 */
		/* 820F08A0h case   12:*/		regs.R7 = regs.R26;
		/* 820F08A0h case   12:*/		return 0x820F08A4;
		  /* 820F08A4h */ case   13:  		/* bl -26404 */
		/* 820F08A4h case   13:*/		regs.LR = 0x820F08A8; return 0x820EA180;
		/* 820F08A4h case   13:*/		return 0x820F08A8;
		  /* 820F08A8h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820F08A8h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F08A8h case   14:*/		return 0x820F08AC;
		  /* 820F08ACh */ case   15:  		/* bc 4, CR0_EQ, 12 */
		/* 820F08ACh case   15:*/		if ( !regs.CR[0].eq ) { return 0x820F08B8;  }
		/* 820F08ACh case   15:*/		return 0x820F08B0;
		  /* 820F08B0h */ case   16:  		/* li R3, 0 */
		/* 820F08B0h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F08B0h case   16:*/		return 0x820F08B4;
		  /* 820F08B4h */ case   17:  		/* b 312 */
		/* 820F08B4h case   17:*/		return 0x820F09EC;
		/* 820F08B4h case   17:*/		return 0x820F08B8;
	}
	return 0x820F08B8;
} // Block from 820F0870h-820F08B8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820F08B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F08B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F08B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F08B8);
		  /* 820F08B8h */ case    0:  		/* mr R10, R24 */
		/* 820F08B8h case    0:*/		regs.R10 = regs.R24;
		/* 820F08B8h case    0:*/		return 0x820F08BC;
		  /* 820F08BCh */ case    1:  		/* mr R9, R29 */
		/* 820F08BCh case    1:*/		regs.R9 = regs.R29;
		/* 820F08BCh case    1:*/		return 0x820F08C0;
		  /* 820F08C0h */ case    2:  		/* mr R8, R28 */
		/* 820F08C0h case    2:*/		regs.R8 = regs.R28;
		/* 820F08C0h case    2:*/		return 0x820F08C4;
		  /* 820F08C4h */ case    3:  		/* mr R7, R26 */
		/* 820F08C4h case    3:*/		regs.R7 = regs.R26;
		/* 820F08C4h case    3:*/		return 0x820F08C8;
		  /* 820F08C8h */ case    4:  		/* mr R6, R30 */
		/* 820F08C8h case    4:*/		regs.R6 = regs.R30;
		/* 820F08C8h case    4:*/		return 0x820F08CC;
		  /* 820F08CCh */ case    5:  		/* mr R5, R31 */
		/* 820F08CCh case    5:*/		regs.R5 = regs.R31;
		/* 820F08CCh case    5:*/		return 0x820F08D0;
		  /* 820F08D0h */ case    6:  		/* mr R4, R27 */
		/* 820F08D0h case    6:*/		regs.R4 = regs.R27;
		/* 820F08D0h case    6:*/		return 0x820F08D4;
		  /* 820F08D4h */ case    7:  		/* mr R3, R25 */
		/* 820F08D4h case    7:*/		regs.R3 = regs.R25;
		/* 820F08D4h case    7:*/		return 0x820F08D8;
		  /* 820F08D8h */ case    8:  		/* bl -26456 */
		/* 820F08D8h case    8:*/		regs.LR = 0x820F08DC; return 0x820EA180;
		/* 820F08D8h case    8:*/		return 0x820F08DC;
		  /* 820F08DCh */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820F08DCh case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F08DCh case    9:*/		return 0x820F08E0;
		  /* 820F08E0h */ case   10:  		/* bc 12, CR0_EQ, -48 */
		/* 820F08E0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820F08B0;  }
		/* 820F08E0h case   10:*/		return 0x820F08E4;
		  /* 820F08E4h */ case   11:  		/* mr R10, R24 */
		/* 820F08E4h case   11:*/		regs.R10 = regs.R24;
		/* 820F08E4h case   11:*/		return 0x820F08E8;
		  /* 820F08E8h */ case   12:  		/* mr R9, R29 */
		/* 820F08E8h case   12:*/		regs.R9 = regs.R29;
		/* 820F08E8h case   12:*/		return 0x820F08EC;
		  /* 820F08ECh */ case   13:  		/* mr R8, R28 */
		/* 820F08ECh case   13:*/		regs.R8 = regs.R28;
		/* 820F08ECh case   13:*/		return 0x820F08F0;
		  /* 820F08F0h */ case   14:  		/* mr R7, R30 */
		/* 820F08F0h case   14:*/		regs.R7 = regs.R30;
		/* 820F08F0h case   14:*/		return 0x820F08F4;
		  /* 820F08F4h */ case   15:  		/* mr R6, R26 */
		/* 820F08F4h case   15:*/		regs.R6 = regs.R26;
		/* 820F08F4h case   15:*/		return 0x820F08F8;
		  /* 820F08F8h */ case   16:  		/* mr R5, R27 */
		/* 820F08F8h case   16:*/		regs.R5 = regs.R27;
		/* 820F08F8h case   16:*/		return 0x820F08FC;
		  /* 820F08FCh */ case   17:  		/* mr R4, R31 */
		/* 820F08FCh case   17:*/		regs.R4 = regs.R31;
		/* 820F08FCh case   17:*/		return 0x820F0900;
		  /* 820F0900h */ case   18:  		/* mr R3, R25 */
		/* 820F0900h case   18:*/		regs.R3 = regs.R25;
		/* 820F0900h case   18:*/		return 0x820F0904;
		  /* 820F0904h */ case   19:  		/* bl -26500 */
		/* 820F0904h case   19:*/		regs.LR = 0x820F0908; return 0x820EA180;
		/* 820F0904h case   19:*/		return 0x820F0908;
		  /* 820F0908h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820F0908h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0908h case   20:*/		return 0x820F090C;
		  /* 820F090Ch */ case   21:  		/* bc 12, CR0_EQ, -92 */
		/* 820F090Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x820F08B0;  }
		/* 820F090Ch case   21:*/		return 0x820F0910;
	}
	return 0x820F0910;
} // Block from 820F08B8h-820F0910h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F0910h
// Function '?MatchComplexMad@CShaderProgram@D3DXShader@@IAAJH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0910);
		  /* 820F0910h */ case    0:  		/* mr R10, R24 */
		/* 820F0910h case    0:*/		regs.R10 = regs.R24;
		/* 820F0910h case    0:*/		return 0x820F0914;
		  /* 820F0914h */ case    1:  		/* mr R9, R29 */
		/* 820F0914h case    1:*/		regs.R9 = regs.R29;
		/* 820F0914h case    1:*/		return 0x820F0918;
		  /* 820F0918h */ case    2:  		/* mr R8, R28 */
		/* 820F0918h case    2:*/		regs.R8 = regs.R28;
		/* 820F0918h case    2:*/		return 0x820F091C;
		  /* 820F091Ch */ case    3:  		/* mr R7, R30 */
		/* 820F091Ch case    3:*/		regs.R7 = regs.R30;
		/* 820F091Ch case    3:*/		return 0x820F0920;
		  /* 820F0920h */ case    4:  		/* mr R6, R26 */
		/* 820F0920h case    4:*/		regs.R6 = regs.R26;
		/* 820F0920h case    4:*/		return 0x820F0924;
		  /* 820F0924h */ case    5:  		/* mr R5, R31 */
		/* 820F0924h case    5:*/		regs.R5 = regs.R31;
		/* 820F0924h case    5:*/		return 0x820F0928;
		  /* 820F0928h */ case    6:  		/* mr R4, R27 */
		/* 820F0928h case    6:*/		regs.R4 = regs.R27;
		/* 820F0928h case    6:*/		return 0x820F092C;
		  /* 820F092Ch */ case    7:  		/* mr R3, R25 */
		/* 820F092Ch case    7:*/		regs.R3 = regs.R25;
		/* 820F092Ch case    7:*/		return 0x820F0930;
		  /* 820F0930h */ case    8:  		/* bl -26544 */
		/* 820F0930h case    8:*/		regs.LR = 0x820F0934; return 0x820EA180;
		/* 820F0930h case    8:*/		return 0x820F0934;
		  /* 820F0934h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820F0934h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0934h case    9:*/		return 0x820F0938;
		  /* 820F0938h */ case   10:  		/* bc 12, CR0_EQ, -136 */
		/* 820F0938h case   10:*/		if ( regs.CR[0].eq ) { return 0x820F08B0;  }
		/* 820F0938h case   10:*/		return 0x820F093C;
		  /* 820F093Ch */ case   11:  		/* mr R10, R24 */
		/* 820F093Ch case   11:*/		regs.R10 = regs.R24;
		/* 820F093Ch case   11:*/		return 0x820F0940;
		  /* 820F0940h */ case   12:  		/* mr R9, R29 */
		/* 820F0940h case   12:*/		regs.R9 = regs.R29;
		/* 820F0940h case   12:*/		return 0x820F0944;
		  /* 820F0944h */ case   13:  		/* mr R8, R28 */
		/* 820F0944h case   13:*/		regs.R8 = regs.R28;
		/* 820F0944h case   13:*/		return 0x820F0948;
		  /* 820F0948h */ case   14:  		/* mr R7, R27 */
		/* 820F0948h case   14:*/		regs.R7 = regs.R27;
		/* 820F0948h case   14:*/		return 0x820F094C;
		  /* 820F094Ch */ case   15:  		/* mr R6, R31 */
		/* 820F094Ch case   15:*/		regs.R6 = regs.R31;
		/* 820F094Ch case   15:*/		return 0x820F0950;
		  /* 820F0950h */ case   16:  		/* mr R5, R26 */
		/* 820F0950h case   16:*/		regs.R5 = regs.R26;
		/* 820F0950h case   16:*/		return 0x820F0954;
		  /* 820F0954h */ case   17:  		/* mr R4, R30 */
		/* 820F0954h case   17:*/		regs.R4 = regs.R30;
		/* 820F0954h case   17:*/		return 0x820F0958;
		  /* 820F0958h */ case   18:  		/* mr R3, R25 */
		/* 820F0958h case   18:*/		regs.R3 = regs.R25;
		/* 820F0958h case   18:*/		return 0x820F095C;
		  /* 820F095Ch */ case   19:  		/* bl -26588 */
		/* 820F095Ch case   19:*/		regs.LR = 0x820F0960; return 0x820EA180;
		/* 820F095Ch case   19:*/		return 0x820F0960;
		  /* 820F0960h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820F0960h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0960h case   20:*/		return 0x820F0964;
		  /* 820F0964h */ case   21:  		/* bc 12, CR0_EQ, -180 */
		/* 820F0964h case   21:*/		if ( regs.CR[0].eq ) { return 0x820F08B0;  }
		/* 820F0964h case   21:*/		return 0x820F0968;
		  /* 820F0968h */ case   22:  		/* mr R10, R24 */
		/* 820F0968h case   22:*/		regs.R10 = regs.R24;
		/* 820F0968h case   22:*/		return 0x820F096C;
		  /* 820F096Ch */ case   23:  		/* mr R9, R29 */
		/* 820F096Ch case   23:*/		regs.R9 = regs.R29;
		/* 820F096Ch case   23:*/		return 0x820F0970;
		  /* 820F0970h */ case   24:  		/* mr R8, R28 */
		/* 820F0970h case   24:*/		regs.R8 = regs.R28;
		/* 820F0970h case   24:*/		return 0x820F0974;
		  /* 820F0974h */ case   25:  		/* mr R7, R27 */
		/* 820F0974h case   25:*/		regs.R7 = regs.R27;
		/* 820F0974h case   25:*/		return 0x820F0978;
		  /* 820F0978h */ case   26:  		/* mr R6, R31 */
		/* 820F0978h case   26:*/		regs.R6 = regs.R31;
		/* 820F0978h case   26:*/		return 0x820F097C;
		  /* 820F097Ch */ case   27:  		/* mr R5, R30 */
		/* 820F097Ch case   27:*/		regs.R5 = regs.R30;
		/* 820F097Ch case   27:*/		return 0x820F0980;
		  /* 820F0980h */ case   28:  		/* mr R4, R26 */
		/* 820F0980h case   28:*/		regs.R4 = regs.R26;
		/* 820F0980h case   28:*/		return 0x820F0984;
		  /* 820F0984h */ case   29:  		/* mr R3, R25 */
		/* 820F0984h case   29:*/		regs.R3 = regs.R25;
		/* 820F0984h case   29:*/		return 0x820F0988;
		  /* 820F0988h */ case   30:  		/* bl -26632 */
		/* 820F0988h case   30:*/		regs.LR = 0x820F098C; return 0x820EA180;
		/* 820F0988h case   30:*/		return 0x820F098C;
		  /* 820F098Ch */ case   31:  		/* cmpwi CR0, R3, 0 */
		/* 820F098Ch case   31:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F098Ch case   31:*/		return 0x820F0990;
		  /* 820F0990h */ case   32:  		/* bc 12, CR0_EQ, -224 */
		/* 820F0990h case   32:*/		if ( regs.CR[0].eq ) { return 0x820F08B0;  }
		/* 820F0990h case   32:*/		return 0x820F0994;
		  /* 820F0994h */ case   33:  		/* mr R10, R24 */
		/* 820F0994h case   33:*/		regs.R10 = regs.R24;
		/* 820F0994h case   33:*/		return 0x820F0998;
		  /* 820F0998h */ case   34:  		/* mr R9, R29 */
		/* 820F0998h case   34:*/		regs.R9 = regs.R29;
		/* 820F0998h case   34:*/		return 0x820F099C;
		  /* 820F099Ch */ case   35:  		/* mr R8, R28 */
		/* 820F099Ch case   35:*/		regs.R8 = regs.R28;
		/* 820F099Ch case   35:*/		return 0x820F09A0;
		  /* 820F09A0h */ case   36:  		/* mr R7, R31 */
		/* 820F09A0h case   36:*/		regs.R7 = regs.R31;
		/* 820F09A0h case   36:*/		return 0x820F09A4;
		  /* 820F09A4h */ case   37:  		/* mr R6, R27 */
		/* 820F09A4h case   37:*/		regs.R6 = regs.R27;
		/* 820F09A4h case   37:*/		return 0x820F09A8;
		  /* 820F09A8h */ case   38:  		/* mr R5, R26 */
		/* 820F09A8h case   38:*/		regs.R5 = regs.R26;
		/* 820F09A8h case   38:*/		return 0x820F09AC;
		  /* 820F09ACh */ case   39:  		/* mr R4, R30 */
		/* 820F09ACh case   39:*/		regs.R4 = regs.R30;
		/* 820F09ACh case   39:*/		return 0x820F09B0;
		  /* 820F09B0h */ case   40:  		/* mr R3, R25 */
		/* 820F09B0h case   40:*/		regs.R3 = regs.R25;
		/* 820F09B0h case   40:*/		return 0x820F09B4;
		  /* 820F09B4h */ case   41:  		/* bl -26676 */
		/* 820F09B4h case   41:*/		regs.LR = 0x820F09B8; return 0x820EA180;
		/* 820F09B4h case   41:*/		return 0x820F09B8;
		  /* 820F09B8h */ case   42:  		/* cmpwi CR0, R3, 0 */
		/* 820F09B8h case   42:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F09B8h case   42:*/		return 0x820F09BC;
		  /* 820F09BCh */ case   43:  		/* bc 12, CR0_EQ, -268 */
		/* 820F09BCh case   43:*/		if ( regs.CR[0].eq ) { return 0x820F08B0;  }
		/* 820F09BCh case   43:*/		return 0x820F09C0;
		  /* 820F09C0h */ case   44:  		/* mr R10, R24 */
		/* 820F09C0h case   44:*/		regs.R10 = regs.R24;
		/* 820F09C0h case   44:*/		return 0x820F09C4;
		  /* 820F09C4h */ case   45:  		/* mr R9, R29 */
		/* 820F09C4h case   45:*/		regs.R9 = regs.R29;
		/* 820F09C4h case   45:*/		return 0x820F09C8;
		  /* 820F09C8h */ case   46:  		/* mr R8, R28 */
		/* 820F09C8h case   46:*/		regs.R8 = regs.R28;
		/* 820F09C8h case   46:*/		return 0x820F09CC;
		  /* 820F09CCh */ case   47:  		/* mr R7, R31 */
		/* 820F09CCh case   47:*/		regs.R7 = regs.R31;
		/* 820F09CCh case   47:*/		return 0x820F09D0;
		  /* 820F09D0h */ case   48:  		/* mr R6, R27 */
		/* 820F09D0h case   48:*/		regs.R6 = regs.R27;
		/* 820F09D0h case   48:*/		return 0x820F09D4;
		  /* 820F09D4h */ case   49:  		/* mr R5, R30 */
		/* 820F09D4h case   49:*/		regs.R5 = regs.R30;
		/* 820F09D4h case   49:*/		return 0x820F09D8;
		  /* 820F09D8h */ case   50:  		/* mr R4, R26 */
		/* 820F09D8h case   50:*/		regs.R4 = regs.R26;
		/* 820F09D8h case   50:*/		return 0x820F09DC;
		  /* 820F09DCh */ case   51:  		/* mr R3, R25 */
		/* 820F09DCh case   51:*/		regs.R3 = regs.R25;
		/* 820F09DCh case   51:*/		return 0x820F09E0;
		  /* 820F09E0h */ case   52:  		/* bl -26720 */
		/* 820F09E0h case   52:*/		regs.LR = 0x820F09E4; return 0x820EA180;
		/* 820F09E0h case   52:*/		return 0x820F09E4;
		  /* 820F09E4h */ case   53:  		/* b 8 */
		/* 820F09E4h case   53:*/		return 0x820F09EC;
		/* 820F09E4h case   53:*/		return 0x820F09E8;
	}
	return 0x820F09E8;
} // Block from 820F0910h-820F09E8h (54 instructions)

//////////////////////////////////////////////////////
// Block at 820F09E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F09E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F09E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F09E8);
		  /* 820F09E8h */ case    0:  		/* li R3, 1 */
		/* 820F09E8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F09E8h case    0:*/		return 0x820F09EC;
	}
	return 0x820F09EC;
} // Block from 820F09E8h-820F09ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F09ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F09EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F09EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F09EC);
		  /* 820F09ECh */ case    0:  		/* addi R1, R1, 176 */
		/* 820F09ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820F09ECh case    0:*/		return 0x820F09F0;
		  /* 820F09F0h */ case    1:  		/* b -391000 */
		/* 820F09F0h case    1:*/		return 0x82091298;
		/* 820F09F0h case    1:*/		return 0x820F09F4;
		  /* 820F09F4h */ case    2:  		/* nop */
		/* 820F09F4h case    2:*/		cpu::op::nop();
		/* 820F09F4h case    2:*/		return 0x820F09F8;
	}
	return 0x820F09F8;
} // Block from 820F09ECh-820F09F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F09F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F09F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F09F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F09F8);
		  /* 820F09F8h */ case    0:  		/* mfspr R12, LR */
		/* 820F09F8h case    0:*/		regs.R12 = regs.LR;
		/* 820F09F8h case    0:*/		return 0x820F09FC;
		  /* 820F09FCh */ case    1:  		/* bl -391120 */
		/* 820F09FCh case    1:*/		regs.LR = 0x820F0A00; return 0x8209122C;
		/* 820F09FCh case    1:*/		return 0x820F0A00;
		  /* 820F0A00h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 820F0A00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820F0A00h case    2:*/		return 0x820F0A04;
		  /* 820F0A04h */ case    3:  		/* mr R30, R3 */
		/* 820F0A04h case    3:*/		regs.R30 = regs.R3;
		/* 820F0A04h case    3:*/		return 0x820F0A08;
		  /* 820F0A08h */ case    4:  		/* mr R26, R4 */
		/* 820F0A08h case    4:*/		regs.R26 = regs.R4;
		/* 820F0A08h case    4:*/		return 0x820F0A0C;
		  /* 820F0A0Ch */ case    5:  		/* mr R21, R5 */
		/* 820F0A0Ch case    5:*/		regs.R21 = regs.R5;
		/* 820F0A0Ch case    5:*/		return 0x820F0A10;
		  /* 820F0A10h */ case    6:  		/* mr R22, R6 */
		/* 820F0A10h case    6:*/		regs.R22 = regs.R6;
		/* 820F0A10h case    6:*/		return 0x820F0A14;
		  /* 820F0A14h */ case    7:  		/* mr R27, R7 */
		/* 820F0A14h case    7:*/		regs.R27 = regs.R7;
		/* 820F0A14h case    7:*/		return 0x820F0A18;
		  /* 820F0A18h */ case    8:  		/* mr R20, R8 */
		/* 820F0A18h case    8:*/		regs.R20 = regs.R8;
		/* 820F0A18h case    8:*/		return 0x820F0A1C;
		  /* 820F0A1Ch */ case    9:  		/* mr R19, R9 */
		/* 820F0A1Ch case    9:*/		regs.R19 = regs.R9;
		/* 820F0A1Ch case    9:*/		return 0x820F0A20;
		  /* 820F0A20h */ case   10:  		/* li R23, 1 */
		/* 820F0A20h case   10:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 820F0A20h case   10:*/		return 0x820F0A24;
		  /* 820F0A24h */ case   11:  		/* cmplwi CR6, R7, 0 */
		/* 820F0A24h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820F0A24h case   11:*/		return 0x820F0A28;
		  /* 820F0A28h */ case   12:  		/* bc 12, CR6_EQ, 564 */
		/* 820F0A28h case   12:*/		if ( regs.CR[6].eq ) { return 0x820F0C5C;  }
		/* 820F0A28h case   12:*/		return 0x820F0A2C;
		  /* 820F0A2Ch */ case   13:  		/* lwz R10, <#[R3 + 24]> */
		/* 820F0A2Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820F0A2Ch case   13:*/		return 0x820F0A30;
		  /* 820F0A30h */ case   14:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 820F0A30h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820F0A30h case   14:*/		return 0x820F0A34;
		  /* 820F0A34h */ case   15:  		/* add R11, R11, R10 */
		/* 820F0A34h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820F0A34h case   15:*/		return 0x820F0A38;
		  /* 820F0A38h */ case   16:  		/* lwz R31, <#[R11 - 4]> */
		/* 820F0A38h case   16:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 820F0A38h case   16:*/		return 0x820F0A3C;
		  /* 820F0A3Ch */ case   17:  		/* mr R3, R31 */
		/* 820F0A3Ch case   17:*/		regs.R3 = regs.R31;
		/* 820F0A3Ch case   17:*/		return 0x820F0A40;
		  /* 820F0A40h */ case   18:  		/* bl 47208 */
		/* 820F0A40h case   18:*/		regs.LR = 0x820F0A44; return 0x820FC2A8;
		/* 820F0A40h case   18:*/		return 0x820F0A44;
		  /* 820F0A44h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820F0A44h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0A44h case   19:*/		return 0x820F0A48;
		  /* 820F0A48h */ case   20:  		/* bc 4, CR0_EQ, 532 */
		/* 820F0A48h case   20:*/		if ( !regs.CR[0].eq ) { return 0x820F0C5C;  }
		/* 820F0A48h case   20:*/		return 0x820F0A4C;
		  /* 820F0A4Ch */ case   21:  		/* lwz R11, <#[R31]> */
		/* 820F0A4Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F0A4Ch case   21:*/		return 0x820F0A50;
		  /* 820F0A50h */ case   22:  		/* lis R17, 24576 */
		/* 820F0A50h case   22:*/		cpu::op::lis<0>(regs,&regs.R17,0x6000);
		/* 820F0A50h case   22:*/		return 0x820F0A54;
		  /* 820F0A54h */ case   23:  		/* rlwinm R10, R11, 0, 0, 3 */
		/* 820F0A54h case   23:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R11);
		/* 820F0A54h case   23:*/		return 0x820F0A58;
		  /* 820F0A58h */ case   24:  		/* cmplw CR6, R10, R17 */
		/* 820F0A58h case   24:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R17);
		/* 820F0A58h case   24:*/		return 0x820F0A5C;
		  /* 820F0A5Ch */ case   25:  		/* bc 12, CR6_EQ, 512 */
		/* 820F0A5Ch case   25:*/		if ( regs.CR[6].eq ) { return 0x820F0C5C;  }
		/* 820F0A5Ch case   25:*/		return 0x820F0A60;
		  /* 820F0A60h */ case   26:  		/* lis R18, 4352 */
		/* 820F0A60h case   26:*/		cpu::op::lis<0>(regs,&regs.R18,0x1100);
		/* 820F0A60h case   26:*/		return 0x820F0A64;
		  /* 820F0A64h */ case   27:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820F0A64h case   27:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820F0A64h case   27:*/		return 0x820F0A68;
		  /* 820F0A68h */ case   28:  		/* cmplw CR6, R11, R18 */
		/* 820F0A68h case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R18);
		/* 820F0A68h case   28:*/		return 0x820F0A6C;
		  /* 820F0A6Ch */ case   29:  		/* bc 12, CR6_EQ, 496 */
		/* 820F0A6Ch case   29:*/		if ( regs.CR[6].eq ) { return 0x820F0C5C;  }
		/* 820F0A6Ch case   29:*/		return 0x820F0A70;
		  /* 820F0A70h */ case   30:  		/* addic. R25, R27, -1 */
		/* 820F0A70h case   30:*/		cpu::op::addic<1>(regs,&regs.R25,regs.R27,0xFFFFFFFF);
		/* 820F0A70h case   30:*/		return 0x820F0A74;
		  /* 820F0A74h */ case   31:  		/* bc 12, CR0_LT, 472 */
		/* 820F0A74h case   31:*/		if ( regs.CR[0].lt ) { return 0x820F0C4C;  }
		/* 820F0A74h case   31:*/		return 0x820F0A78;
		  /* 820F0A78h */ case   32:  		/* rlwinm R24, R25, 2, 0, 29 */
		/* 820F0A78h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R25);
		/* 820F0A78h case   32:*/		return 0x820F0A7C;
		  /* 820F0A7Ch */ case   33:  		/* lwz R11, <#[R30 + 24]> */
		/* 820F0A7Ch case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820F0A7Ch case   33:*/		return 0x820F0A80;
		  /* 820F0A80h */ case   34:  		/* lwzx R31, <#[R24 + R11]> */
		/* 820F0A80h case   34:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + regs.R11 + 0x00000000) );
		/* 820F0A80h case   34:*/		return 0x820F0A84;
		  /* 820F0A84h */ case   35:  		/* lwz R11, <#[R31 + 36]> */
		/* 820F0A84h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820F0A84h case   35:*/		return 0x820F0A88;
		  /* 820F0A88h */ case   36:  		/* cmplw CR6, R11, R27 */
		/* 820F0A88h case   36:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820F0A88h case   36:*/		return 0x820F0A8C;
		  /* 820F0A8Ch */ case   37:  		/* bc 12, CR6_EQ, 436 */
		/* 820F0A8Ch case   37:*/		if ( regs.CR[6].eq ) { return 0x820F0C40;  }
		/* 820F0A8Ch case   37:*/		return 0x820F0A90;
		  /* 820F0A90h */ case   38:  		/* lwz R11, <#[R31]> */
		/* 820F0A90h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F0A90h case   38:*/		return 0x820F0A94;
		  /* 820F0A94h */ case   39:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 820F0A94h case   39:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 820F0A94h case   39:*/		return 0x820F0A98;
		  /* 820F0A98h */ case   40:  		/* bc 12, CR0_EQ, 424 */
		/* 820F0A98h case   40:*/		if ( regs.CR[0].eq ) { return 0x820F0C40;  }
		/* 820F0A98h case   40:*/		return 0x820F0A9C;
		  /* 820F0A9Ch */ case   41:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 820F0A9Ch case   41:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 820F0A9Ch case   41:*/		return 0x820F0AA0;
		  /* 820F0AA0h */ case   42:  		/* cmplw CR6, R11, R17 */
		/* 820F0AA0h case   42:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 820F0AA0h case   42:*/		return 0x820F0AA4;
		  /* 820F0AA4h */ case   43:  		/* bc 12, CR6_EQ, 424 */
		/* 820F0AA4h case   43:*/		if ( regs.CR[6].eq ) { return 0x820F0C4C;  }
		/* 820F0AA4h case   43:*/		return 0x820F0AA8;
		  /* 820F0AA8h */ case   44:  		/* cmplw CR6, R10, R18 */
		/* 820F0AA8h case   44:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R18);
		/* 820F0AA8h case   44:*/		return 0x820F0AAC;
		  /* 820F0AACh */ case   45:  		/* bc 12, CR6_EQ, 416 */
		/* 820F0AACh case   45:*/		if ( regs.CR[6].eq ) { return 0x820F0C4C;  }
		/* 820F0AACh case   45:*/		return 0x820F0AB0;
		  /* 820F0AB0h */ case   46:  		/* mr R6, R27 */
		/* 820F0AB0h case   46:*/		regs.R6 = regs.R27;
		/* 820F0AB0h case   46:*/		return 0x820F0AB4;
		  /* 820F0AB4h */ case   47:  		/* mr R5, R31 */
		/* 820F0AB4h case   47:*/		regs.R5 = regs.R31;
		/* 820F0AB4h case   47:*/		return 0x820F0AB8;
		  /* 820F0AB8h */ case   48:  		/* mr R4, R22 */
		/* 820F0AB8h case   48:*/		regs.R4 = regs.R22;
		/* 820F0AB8h case   48:*/		return 0x820F0ABC;
		  /* 820F0ABCh */ case   49:  		/* mr R3, R30 */
		/* 820F0ABCh case   49:*/		regs.R3 = regs.R30;
		/* 820F0ABCh case   49:*/		return 0x820F0AC0;
		  /* 820F0AC0h */ case   50:  		/* bl -50560 */
		/* 820F0AC0h case   50:*/		regs.LR = 0x820F0AC4; return 0x820E4540;
		/* 820F0AC0h case   50:*/		return 0x820F0AC4;
		  /* 820F0AC4h */ case   51:  		/* lis R11, 20480 */
		/* 820F0AC4h case   51:*/		cpu::op::lis<0>(regs,&regs.R11,0x5000);
		/* 820F0AC4h case   51:*/		return 0x820F0AC8;
		  /* 820F0AC8h */ case   52:  		/* li R29, 0 */
		/* 820F0AC8h case   52:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820F0AC8h case   52:*/		return 0x820F0ACC;
		  /* 820F0ACCh */ case   53:  		/* li R28, 0 */
		/* 820F0ACCh case   53:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820F0ACCh case   53:*/		return 0x820F0AD0;
		  /* 820F0AD0h */ case   54:  		/* lwz R10, <#[R31]> */
		/* 820F0AD0h case   54:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F0AD0h case   54:*/		return 0x820F0AD4;
		  /* 820F0AD4h */ case   55:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 820F0AD4h case   55:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 820F0AD4h case   55:*/		return 0x820F0AD8;
		  /* 820F0AD8h */ case   56:  		/* cmplw CR6, R10, R11 */
		/* 820F0AD8h case   56:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820F0AD8h case   56:*/		return 0x820F0ADC;
		  /* 820F0ADCh */ case   57:  		/* bc 4, CR6_EQ, 8 */
		/* 820F0ADCh case   57:*/		if ( !regs.CR[6].eq ) { return 0x820F0AE4;  }
		/* 820F0ADCh case   57:*/		return 0x820F0AE0;
		  /* 820F0AE0h */ case   58:  		/* li R29, 1 */
		/* 820F0AE0h case   58:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820F0AE0h case   58:*/		return 0x820F0AE4;
	}
	return 0x820F0AE4;
} // Block from 820F09F8h-820F0AE4h (59 instructions)

//////////////////////////////////////////////////////
// Block at 820F0AE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0AE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0AE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0AE4);
		  /* 820F0AE4h */ case    0:  		/* lwz R4, <#[R31 + 12]> */
		/* 820F0AE4h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F0AE4h case    0:*/		return 0x820F0AE8;
		  /* 820F0AE8h */ case    1:  		/* li R5, 0 */
		/* 820F0AE8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F0AE8h case    1:*/		return 0x820F0AEC;
		  /* 820F0AECh */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 820F0AECh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F0AECh case    2:*/		return 0x820F0AF0;
		  /* 820F0AF0h */ case    3:  		/* bc 12, CR6_EQ, 120 */
		/* 820F0AF0h case    3:*/		if ( regs.CR[6].eq ) { return 0x820F0B68;  }
		/* 820F0AF0h case    3:*/		return 0x820F0AF4;
		  /* 820F0AF4h */ case    4:  		/* lwz R11, <#[R30 + 108]> */
		/* 820F0AF4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000006C) );
		/* 820F0AF4h case    4:*/		return 0x820F0AF8;
		  /* 820F0AF8h */ case    5:  		/* li R9, 0 */
		/* 820F0AF8h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F0AF8h case    5:*/		return 0x820F0AFC;
		  /* 820F0AFCh */ case    6:  		/* lwz R8, <#[R31 + 16]> */
		/* 820F0AFCh case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 820F0AFCh case    6:*/		return 0x820F0B00;
		  /* 820F0B00h */ case    7:  		/* rlwinm R11, R11, 29, 0, 2 */
		/* 820F0B00h case    7:*/		cpu::op::rlwinm<0,29,0,2>(regs,&regs.R11,regs.R11);
		/* 820F0B00h case    7:*/		return 0x820F0B04;
		  /* 820F0B04h */ case    8:  		/* lwz R7, <#[R30 + 20]> */
		/* 820F0B04h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000014) );
		/* 820F0B04h case    8:*/		return 0x820F0B08;
		  /* 820F0B08h */ case    9:  		/* srawi R6, R11, 31 */
		/* 820F0B08h case    9:*/		cpu::op::srawi<0,31>(regs,&regs.R6,regs.R11);
		/* 820F0B08h case    9:*/		return 0x820F0B0C;
		  /* 820F0B0Ch */ case   10:  		/* lwzx R11, <#[R9 + R8]> */
		/* 820F0B0Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820F0B0Ch case   10:*/		return 0x820F0B10;
		  /* 820F0B10h */ case   11:  		/* cmpwi CR6, R6, 0 */
		/* 820F0B10h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 820F0B10h case   11:*/		return 0x820F0B14;
		  /* 820F0B14h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F0B14h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F0B14h case   12:*/		return 0x820F0B18;
		  /* 820F0B18h */ case   13:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820F0B18h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820F0B18h case   13:*/		return 0x820F0B1C;
		  /* 820F0B1Ch */ case   14:  		/* bc 4, CR6_EQ, 36 */
		/* 820F0B1Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x820F0B40;  }
		/* 820F0B1Ch case   14:*/		return 0x820F0B20;
		  /* 820F0B20h */ case   15:  		/* lwz R3, <#[R11 + 12]> */
		/* 820F0B20h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F0B20h case   15:*/		return 0x820F0B24;
		  /* 820F0B24h */ case   16:  		/* lwz R10, <#[R11 + 16]> */
		/* 820F0B24h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820F0B24h case   16:*/		return 0x820F0B28;
		  /* 820F0B28h */ case   17:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 820F0B28h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 820F0B28h case   17:*/		return 0x820F0B2C;
		  /* 820F0B2Ch */ case   18:  		/* lwz R3, <#[R26 + 20]> */
		/* 820F0B2Ch case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000014) );
		/* 820F0B2Ch case   18:*/		return 0x820F0B30;
		  /* 820F0B30h */ case   19:  		/* add R11, R11, R10 */
		/* 820F0B30h case   19:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820F0B30h case   19:*/		return 0x820F0B34;
		  /* 820F0B34h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F0B34h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F0B34h case   20:*/		return 0x820F0B38;
		  /* 820F0B38h */ case   21:  		/* lwzx R11, <#[R11 + R3]> */
		/* 820F0B38h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 820F0B38h case   21:*/		return 0x820F0B3C;
		  /* 820F0B3Ch */ case   22:  		/* b 8 */
		/* 820F0B3Ch case   22:*/		return 0x820F0B44;
		/* 820F0B3Ch case   22:*/		return 0x820F0B40;
	}
	return 0x820F0B40;
} // Block from 820F0AE4h-820F0B40h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820F0B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0B40);
		  /* 820F0B40h */ case    0:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F0B40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F0B40h case    0:*/		return 0x820F0B44;
	}
	return 0x820F0B44;
} // Block from 820F0B40h-820F0B44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F0B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0B44);
		  /* 820F0B44h */ case    0:  		/* cmplwi CR6, R11, 3 */
		/* 820F0B44h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820F0B44h case    0:*/		return 0x820F0B48;
		  /* 820F0B48h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820F0B48h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F0B54;  }
		/* 820F0B48h case    1:*/		return 0x820F0B4C;
		  /* 820F0B4Ch */ case    2:  		/* li R28, 1 */
		/* 820F0B4Ch case    2:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820F0B4Ch case    2:*/		return 0x820F0B50;
		  /* 820F0B50h */ case    3:  		/* b 8 */
		/* 820F0B50h case    3:*/		return 0x820F0B58;
		/* 820F0B50h case    3:*/		return 0x820F0B54;
	}
	return 0x820F0B54;
} // Block from 820F0B44h-820F0B54h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F0B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0B54);
		  /* 820F0B54h */ case    0:  		/* li R29, 1 */
		/* 820F0B54h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820F0B54h case    0:*/		return 0x820F0B58;
	}
	return 0x820F0B58;
} // Block from 820F0B54h-820F0B58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F0B58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0B58);
		  /* 820F0B58h */ case    0:  		/* addi R5, R5, 1 */
		/* 820F0B58h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820F0B58h case    0:*/		return 0x820F0B5C;
		  /* 820F0B5Ch */ case    1:  		/* addi R9, R9, 4 */
		/* 820F0B5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F0B5Ch case    1:*/		return 0x820F0B60;
		  /* 820F0B60h */ case    2:  		/* cmplw CR6, R5, R4 */
		/* 820F0B60h case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 820F0B60h case    2:*/		return 0x820F0B64;
		  /* 820F0B64h */ case    3:  		/* bc 12, CR6_LT, -88 */
		/* 820F0B64h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F0B0C;  }
		/* 820F0B64h case    3:*/		return 0x820F0B68;
	}
	return 0x820F0B68;
} // Block from 820F0B58h-820F0B68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F0B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0B68);
		  /* 820F0B68h */ case    0:  		/* cmpw CR6, R29, R20 */
		/* 820F0B68h case    0:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R20);
		/* 820F0B68h case    0:*/		return 0x820F0B6C;
		  /* 820F0B6Ch */ case    1:  		/* bc 12, CR6_EQ, 212 */
		/* 820F0B6Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820F0C40;  }
		/* 820F0B6Ch case    1:*/		return 0x820F0B70;
		  /* 820F0B70h */ case    2:  		/* cmpw CR6, R28, R19 */
		/* 820F0B70h case    2:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R19);
		/* 820F0B70h case    2:*/		return 0x820F0B74;
		  /* 820F0B74h */ case    3:  		/* bc 12, CR6_EQ, 204 */
		/* 820F0B74h case    3:*/		if ( regs.CR[6].eq ) { return 0x820F0C40;  }
		/* 820F0B74h case    3:*/		return 0x820F0B78;
		  /* 820F0B78h */ case    4:  		/* mr R5, R25 */
		/* 820F0B78h case    4:*/		regs.R5 = regs.R25;
		/* 820F0B78h case    4:*/		return 0x820F0B7C;
		  /* 820F0B7Ch */ case    5:  		/* addi R4, R27, -1 */
		/* 820F0B7Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R27,0xFFFFFFFF);
		/* 820F0B7Ch case    5:*/		return 0x820F0B80;
		  /* 820F0B80h */ case    6:  		/* mr R3, R30 */
		/* 820F0B80h case    6:*/		regs.R3 = regs.R30;
		/* 820F0B80h case    6:*/		return 0x820F0B84;
		  /* 820F0B84h */ case    7:  		/* bl -23428 */
		/* 820F0B84h case    7:*/		regs.LR = 0x820F0B88; return 0x820EB000;
		/* 820F0B84h case    7:*/		return 0x820F0B88;
		  /* 820F0B88h */ case    8:  		/* or. R23, R3, R3 */
		/* 820F0B88h case    8:*/		cpu::op::or<1>(regs,&regs.R23,regs.R3,regs.R3);
		/* 820F0B88h case    8:*/		return 0x820F0B8C;
		  /* 820F0B8Ch */ case    9:  		/* bc 12, CR0_LT, 192 */
		/* 820F0B8Ch case    9:*/		if ( regs.CR[0].lt ) { return 0x820F0C4C;  }
		/* 820F0B8Ch case    9:*/		return 0x820F0B90;
		  /* 820F0B90h */ case   10:  		/* lwz R11, <#[R30 + 108]> */
		/* 820F0B90h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000006C) );
		/* 820F0B90h case   10:*/		return 0x820F0B94;
		  /* 820F0B94h */ case   11:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820F0B94h case   11:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820F0B94h case   11:*/		return 0x820F0B98;
		  /* 820F0B98h */ case   12:  		/* bc 4, CR0_EQ, 188 */
		/* 820F0B98h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820F0C54;  }
		/* 820F0B98h case   12:*/		return 0x820F0B9C;
		  /* 820F0B9Ch */ case   13:  		/* li R5, 0 */
		/* 820F0B9Ch case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F0B9Ch case   13:*/		return 0x820F0BA0;
		  /* 820F0BA0h */ case   14:  		/* mr R4, R26 */
		/* 820F0BA0h case   14:*/		regs.R4 = regs.R26;
		/* 820F0BA0h case   14:*/		return 0x820F0BA4;
		  /* 820F0BA4h */ case   15:  		/* mr R3, R30 */
		/* 820F0BA4h case   15:*/		regs.R3 = regs.R30;
		/* 820F0BA4h case   15:*/		return 0x820F0BA8;
		  /* 820F0BA8h */ case   16:  		/* bl 143144 */
		/* 820F0BA8h case   16:*/		regs.LR = 0x820F0BAC; return 0x82113AD0;
		/* 820F0BA8h case   16:*/		return 0x820F0BAC;
		  /* 820F0BACh */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820F0BACh case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0BACh case   17:*/		return 0x820F0BB0;
		  /* 820F0BB0h */ case   18:  		/* bc 12, CR0_LT, 124 */
		/* 820F0BB0h case   18:*/		if ( regs.CR[0].lt ) { return 0x820F0C2C;  }
		/* 820F0BB0h case   18:*/		return 0x820F0BB4;
		  /* 820F0BB4h */ case   19:  		/* lwz R4, <#[R31 + 12]> */
		/* 820F0BB4h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F0BB4h case   19:*/		return 0x820F0BB8;
		  /* 820F0BB8h */ case   20:  		/* li R5, 0 */
		/* 820F0BB8h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F0BB8h case   20:*/		return 0x820F0BBC;
		  /* 820F0BBCh */ case   21:  		/* cmplwi CR6, R4, 0 */
		/* 820F0BBCh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F0BBCh case   21:*/		return 0x820F0BC0;
		  /* 820F0BC0h */ case   22:  		/* bc 12, CR6_EQ, 92 */
		/* 820F0BC0h case   22:*/		if ( regs.CR[6].eq ) { return 0x820F0C1C;  }
		/* 820F0BC0h case   22:*/		return 0x820F0BC4;
		  /* 820F0BC4h */ case   23:  		/* lwz R8, <#[R31 + 16]> */
		/* 820F0BC4h case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 820F0BC4h case   23:*/		return 0x820F0BC8;
		  /* 820F0BC8h */ case   24:  		/* li R11, 0 */
		/* 820F0BC8h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F0BC8h case   24:*/		return 0x820F0BCC;
		  /* 820F0BCCh */ case   25:  		/* lwz R7, <#[R30 + 20]> */
		/* 820F0BCCh case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000014) );
		/* 820F0BCCh case   25:*/		return 0x820F0BD0;
		  /* 820F0BD0h */ case   26:  		/* lwz R6, <#[R26 + 20]> */
		/* 820F0BD0h case   26:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000014) );
		/* 820F0BD0h case   26:*/		return 0x820F0BD4;
		  /* 820F0BD4h */ case   27:  		/* lwzx R10, <#[R11 + R8]> */
		/* 820F0BD4h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820F0BD4h case   27:*/		return 0x820F0BD8;
		  /* 820F0BD8h */ case   28:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F0BD8h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F0BD8h case   28:*/		return 0x820F0BDC;
		  /* 820F0BDCh */ case   29:  		/* lwzx R10, <#[R10 + R7]> */
		/* 820F0BDCh case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 820F0BDCh case   29:*/		return 0x820F0BE0;
		  /* 820F0BE0h */ case   30:  		/* lwz R3, <#[R10 + 12]> */
		/* 820F0BE0h case   30:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F0BE0h case   30:*/		return 0x820F0BE4;
		  /* 820F0BE4h */ case   31:  		/* lwz R9, <#[R10 + 16]> */
		/* 820F0BE4h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 820F0BE4h case   31:*/		return 0x820F0BE8;
		  /* 820F0BE8h */ case   32:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820F0BE8h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820F0BE8h case   32:*/		return 0x820F0BEC;
		  /* 820F0BECh */ case   33:  		/* add R10, R10, R9 */
		/* 820F0BECh case   33:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820F0BECh case   33:*/		return 0x820F0BF0;
		  /* 820F0BF0h */ case   34:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F0BF0h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F0BF0h case   34:*/		return 0x820F0BF4;
		  /* 820F0BF4h */ case   35:  		/* lwzx R10, <#[R10 + R6]> */
		/* 820F0BF4h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 820F0BF4h case   35:*/		return 0x820F0BF8;
		  /* 820F0BF8h */ case   36:  		/* cmplwi CR6, R10, 3 */
		/* 820F0BF8h case   36:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820F0BF8h case   36:*/		return 0x820F0BFC;
		  /* 820F0BFCh */ case   37:  		/* bc 4, CR6_EQ, 12 */
		/* 820F0BFCh case   37:*/		if ( !regs.CR[6].eq ) { return 0x820F0C08;  }
		/* 820F0BFCh case   37:*/		return 0x820F0C00;
		  /* 820F0C00h */ case   38:  		/* li R28, 1 */
		/* 820F0C00h case   38:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820F0C00h case   38:*/		return 0x820F0C04;
		  /* 820F0C04h */ case   39:  		/* b 8 */
		/* 820F0C04h case   39:*/		return 0x820F0C0C;
		/* 820F0C04h case   39:*/		return 0x820F0C08;
	}
	return 0x820F0C08;
} // Block from 820F0B68h-820F0C08h (40 instructions)

//////////////////////////////////////////////////////
// Block at 820F0C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0C08);
		  /* 820F0C08h */ case    0:  		/* li R29, 1 */
		/* 820F0C08h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820F0C08h case    0:*/		return 0x820F0C0C;
	}
	return 0x820F0C0C;
} // Block from 820F0C08h-820F0C0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F0C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0C0C);
		  /* 820F0C0Ch */ case    0:  		/* addi R5, R5, 1 */
		/* 820F0C0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820F0C0Ch case    0:*/		return 0x820F0C10;
		  /* 820F0C10h */ case    1:  		/* addi R11, R11, 4 */
		/* 820F0C10h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F0C10h case    1:*/		return 0x820F0C14;
		  /* 820F0C14h */ case    2:  		/* cmplw CR6, R5, R4 */
		/* 820F0C14h case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 820F0C14h case    2:*/		return 0x820F0C18;
		  /* 820F0C18h */ case    3:  		/* bc 12, CR6_LT, -68 */
		/* 820F0C18h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F0BD4;  }
		/* 820F0C18h case    3:*/		return 0x820F0C1C;
	}
	return 0x820F0C1C;
} // Block from 820F0C0Ch-820F0C1Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F0C1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0C1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0C1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0C1C);
		  /* 820F0C1Ch */ case    0:  		/* cmpw CR6, R29, R20 */
		/* 820F0C1Ch case    0:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R20);
		/* 820F0C1Ch case    0:*/		return 0x820F0C20;
		  /* 820F0C20h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820F0C20h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F0C2C;  }
		/* 820F0C20h case    1:*/		return 0x820F0C24;
		  /* 820F0C24h */ case    2:  		/* cmpw CR6, R28, R19 */
		/* 820F0C24h case    2:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R19);
		/* 820F0C24h case    2:*/		return 0x820F0C28;
		  /* 820F0C28h */ case    3:  		/* bc 4, CR6_EQ, 44 */
		/* 820F0C28h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820F0C54;  }
		/* 820F0C28h case    3:*/		return 0x820F0C2C;
	}
	return 0x820F0C2C;
} // Block from 820F0C1Ch-820F0C2Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F0C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0C2C);
		  /* 820F0C2Ch */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 820F0C2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820F0C2Ch case    0:*/		return 0x820F0C30;
		  /* 820F0C30h */ case    1:  		/* mr R4, R21 */
		/* 820F0C30h case    1:*/		regs.R4 = regs.R21;
		/* 820F0C30h case    1:*/		return 0x820F0C34;
		  /* 820F0C34h */ case    2:  		/* lwz R3, <#[R30 + 24]> */
		/* 820F0C34h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820F0C34h case    2:*/		return 0x820F0C38;
		  /* 820F0C38h */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820F0C38h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820F0C38h case    3:*/		return 0x820F0C3C;
		  /* 820F0C3Ch */ case    4:  		/* bl -389772 */
		/* 820F0C3Ch case    4:*/		regs.LR = 0x820F0C40; return 0x820919B0;
		/* 820F0C3Ch case    4:*/		return 0x820F0C40;
	}
	return 0x820F0C40;
} // Block from 820F0C2Ch-820F0C40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F0C40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0C40);
		  /* 820F0C40h */ case    0:  		/* addic. R25, R25, -1 */
		/* 820F0C40h case    0:*/		cpu::op::addic<1>(regs,&regs.R25,regs.R25,0xFFFFFFFF);
		/* 820F0C40h case    0:*/		return 0x820F0C44;
		  /* 820F0C44h */ case    1:  		/* addi R24, R24, -4 */
		/* 820F0C44h case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0xFFFFFFFC);
		/* 820F0C44h case    1:*/		return 0x820F0C48;
		  /* 820F0C48h */ case    2:  		/* bc 4, CR0_LT, -460 */
		/* 820F0C48h case    2:*/		if ( !regs.CR[0].lt ) { return 0x820F0A7C;  }
		/* 820F0C48h case    2:*/		return 0x820F0C4C;
	}
	return 0x820F0C4C;
} // Block from 820F0C40h-820F0C4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F0C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0C4C);
		  /* 820F0C4Ch */ case    0:  		/* mr R3, R23 */
		/* 820F0C4Ch case    0:*/		regs.R3 = regs.R23;
		/* 820F0C4Ch case    0:*/		return 0x820F0C50;
		  /* 820F0C50h */ case    1:  		/* b 16 */
		/* 820F0C50h case    1:*/		return 0x820F0C60;
		/* 820F0C50h case    1:*/		return 0x820F0C54;
	}
	return 0x820F0C54;
} // Block from 820F0C4Ch-820F0C54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F0C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0C54);
		  /* 820F0C54h */ case    0:  		/* li R23, 0 */
		/* 820F0C54h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820F0C54h case    0:*/		return 0x820F0C58;
		  /* 820F0C58h */ case    1:  		/* b -12 */
		/* 820F0C58h case    1:*/		return 0x820F0C4C;
		/* 820F0C58h case    1:*/		return 0x820F0C5C;
	}
	return 0x820F0C5C;
} // Block from 820F0C54h-820F0C5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F0C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0C5C);
		  /* 820F0C5Ch */ case    0:  		/* li R3, 1 */
		/* 820F0C5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F0C5Ch case    0:*/		return 0x820F0C60;
	}
	return 0x820F0C60;
} // Block from 820F0C5Ch-820F0C60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F0C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0C60);
		  /* 820F0C60h */ case    0:  		/* addi R1, R1, 208 */
		/* 820F0C60h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820F0C60h case    0:*/		return 0x820F0C64;
		  /* 820F0C64h */ case    1:  		/* b -391656 */
		/* 820F0C64h case    1:*/		return 0x8209127C;
		/* 820F0C64h case    1:*/		return 0x820F0C68;
	}
	return 0x820F0C68;
} // Block from 820F0C60h-820F0C68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F0C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0C68);
		  /* 820F0C68h */ case    0:  		/* mfspr R12, LR */
		/* 820F0C68h case    0:*/		regs.R12 = regs.LR;
		/* 820F0C68h case    0:*/		return 0x820F0C6C;
		  /* 820F0C6Ch */ case    1:  		/* bl -391732 */
		/* 820F0C6Ch case    1:*/		regs.LR = 0x820F0C70; return 0x82091238;
		/* 820F0C6Ch case    1:*/		return 0x820F0C70;
		  /* 820F0C70h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820F0C70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820F0C70h case    2:*/		return 0x820F0C74;
		  /* 820F0C74h */ case    3:  		/* mr R31, R3 */
		/* 820F0C74h case    3:*/		regs.R31 = regs.R3;
		/* 820F0C74h case    3:*/		return 0x820F0C78;
		  /* 820F0C78h */ case    4:  		/* mr R22, R4 */
		/* 820F0C78h case    4:*/		regs.R22 = regs.R4;
		/* 820F0C78h case    4:*/		return 0x820F0C7C;
		  /* 820F0C7Ch */ case    5:  		/* mr R21, R5 */
		/* 820F0C7Ch case    5:*/		regs.R21 = regs.R5;
		/* 820F0C7Ch case    5:*/		return 0x820F0C80;
		  /* 820F0C80h */ case    6:  		/* mr R25, R7 */
		/* 820F0C80h case    6:*/		regs.R25 = regs.R7;
		/* 820F0C80h case    6:*/		return 0x820F0C84;
		  /* 820F0C84h */ case    7:  		/* mr R30, R8 */
		/* 820F0C84h case    7:*/		regs.R30 = regs.R8;
		/* 820F0C84h case    7:*/		return 0x820F0C88;
		  /* 820F0C88h */ case    8:  		/* mr R20, R9 */
		/* 820F0C88h case    8:*/		regs.R20 = regs.R9;
		/* 820F0C88h case    8:*/		return 0x820F0C8C;
		  /* 820F0C8Ch */ case    9:  		/* cmplwi CR6, R8, 0 */
		/* 820F0C8Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820F0C8Ch case    9:*/		return 0x820F0C90;
		  /* 820F0C90h */ case   10:  		/* bc 12, CR6_EQ, 400 */
		/* 820F0C90h case   10:*/		if ( regs.CR[6].eq ) { return 0x820F0E20;  }
		/* 820F0C90h case   10:*/		return 0x820F0C94;
		  /* 820F0C94h */ case   11:  		/* lwz R11, <#[R3 + 24]> */
		/* 820F0C94h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820F0C94h case   11:*/		return 0x820F0C98;
		  /* 820F0C98h */ case   12:  		/* rlwinm R24, R8, 2, 0, 29 */
		/* 820F0C98h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R8);
		/* 820F0C98h case   12:*/		return 0x820F0C9C;
		  /* 820F0C9Ch */ case   13:  		/* add R11, R11, R24 */
		/* 820F0C9Ch case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R24);
		/* 820F0C9Ch case   13:*/		return 0x820F0CA0;
		  /* 820F0CA0h */ case   14:  		/* lwz R29, <#[R11 - 4]> */
		/* 820F0CA0h case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 820F0CA0h case   14:*/		return 0x820F0CA4;
		  /* 820F0CA4h */ case   15:  		/* mr R3, R29 */
		/* 820F0CA4h case   15:*/		regs.R3 = regs.R29;
		/* 820F0CA4h case   15:*/		return 0x820F0CA8;
		  /* 820F0CA8h */ case   16:  		/* bl 46592 */
		/* 820F0CA8h case   16:*/		regs.LR = 0x820F0CAC; return 0x820FC2A8;
		/* 820F0CA8h case   16:*/		return 0x820F0CAC;
		  /* 820F0CACh */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820F0CACh case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0CACh case   17:*/		return 0x820F0CB0;
		  /* 820F0CB0h */ case   18:  		/* bc 4, CR0_EQ, 368 */
		/* 820F0CB0h case   18:*/		if ( !regs.CR[0].eq ) { return 0x820F0E20;  }
		/* 820F0CB0h case   18:*/		return 0x820F0CB4;
		  /* 820F0CB4h */ case   19:  		/* lwz R11, <#[R29]> */
		/* 820F0CB4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820F0CB4h case   19:*/		return 0x820F0CB8;
		  /* 820F0CB8h */ case   20:  		/* lis R23, 24576 */
		/* 820F0CB8h case   20:*/		cpu::op::lis<0>(regs,&regs.R23,0x6000);
		/* 820F0CB8h case   20:*/		return 0x820F0CBC;
		  /* 820F0CBCh */ case   21:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 820F0CBCh case   21:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 820F0CBCh case   21:*/		return 0x820F0CC0;
		  /* 820F0CC0h */ case   22:  		/* cmplw CR6, R11, R23 */
		/* 820F0CC0h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 820F0CC0h case   22:*/		return 0x820F0CC4;
		  /* 820F0CC4h */ case   23:  		/* bc 12, CR6_EQ, 348 */
		/* 820F0CC4h case   23:*/		if ( regs.CR[6].eq ) { return 0x820F0E20;  }
		/* 820F0CC4h case   23:*/		return 0x820F0CC8;
		  /* 820F0CC8h */ case   24:  		/* mr R27, R30 */
		/* 820F0CC8h case   24:*/		regs.R27 = regs.R30;
		/* 820F0CC8h case   24:*/		return 0x820F0CCC;
		  /* 820F0CCCh */ case   25:  		/* cmplwi CR6, R30, 0 */
		/* 820F0CCCh case   25:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F0CCCh case   25:*/		return 0x820F0CD0;
		  /* 820F0CD0h */ case   26:  		/* bc 12, CR6_EQ, 336 */
		/* 820F0CD0h case   26:*/		if ( regs.CR[6].eq ) { return 0x820F0E20;  }
		/* 820F0CD0h case   26:*/		return 0x820F0CD4;
		  /* 820F0CD4h */ case   27:  		/* mr R26, R24 */
		/* 820F0CD4h case   27:*/		regs.R26 = regs.R24;
		/* 820F0CD4h case   27:*/		return 0x820F0CD8;
		  /* 820F0CD8h */ case   28:  		/* lwz R11, <#[R31 + 24]> */
		/* 820F0CD8h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820F0CD8h case   28:*/		return 0x820F0CDC;
		  /* 820F0CDCh */ case   29:  		/* addi R26, R26, -4 */
		/* 820F0CDCh case   29:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0xFFFFFFFC);
		/* 820F0CDCh case   29:*/		return 0x820F0CE0;
		  /* 820F0CE0h */ case   30:  		/* addi R27, R27, -1 */
		/* 820F0CE0h case   30:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0xFFFFFFFF);
		/* 820F0CE0h case   30:*/		return 0x820F0CE4;
		  /* 820F0CE4h */ case   31:  		/* lwzx R28, <#[R11 + R26]> */
		/* 820F0CE4h case   31:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 820F0CE4h case   31:*/		return 0x820F0CE8;
		  /* 820F0CE8h */ case   32:  		/* lwz R11, <#[R28 + 36]> */
		/* 820F0CE8h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000024) );
		/* 820F0CE8h case   32:*/		return 0x820F0CEC;
		  /* 820F0CECh */ case   33:  		/* cmplw CR6, R11, R30 */
		/* 820F0CECh case   33:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820F0CECh case   33:*/		return 0x820F0CF0;
		  /* 820F0CF0h */ case   34:  		/* bc 12, CR6_EQ, 296 */
		/* 820F0CF0h case   34:*/		if ( regs.CR[6].eq ) { return 0x820F0E18;  }
		/* 820F0CF0h case   34:*/		return 0x820F0CF4;
		  /* 820F0CF4h */ case   35:  		/* lwz R11, <#[R28]> */
		/* 820F0CF4h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820F0CF4h case   35:*/		return 0x820F0CF8;
		  /* 820F0CF8h */ case   36:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 820F0CF8h case   36:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 820F0CF8h case   36:*/		return 0x820F0CFC;
		  /* 820F0CFCh */ case   37:  		/* bc 12, CR0_EQ, 284 */
		/* 820F0CFCh case   37:*/		if ( regs.CR[0].eq ) { return 0x820F0E18;  }
		/* 820F0CFCh case   37:*/		return 0x820F0D00;
		  /* 820F0D00h */ case   38:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 820F0D00h case   38:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 820F0D00h case   38:*/		return 0x820F0D04;
		  /* 820F0D04h */ case   39:  		/* cmplw CR6, R11, R23 */
		/* 820F0D04h case   39:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 820F0D04h case   39:*/		return 0x820F0D08;
		  /* 820F0D08h */ case   40:  		/* bc 12, CR6_EQ, 280 */
		/* 820F0D08h case   40:*/		if ( regs.CR[6].eq ) { return 0x820F0E20;  }
		/* 820F0D08h case   40:*/		return 0x820F0D0C;
		  /* 820F0D0Ch */ case   41:  		/* mr R3, R28 */
		/* 820F0D0Ch case   41:*/		regs.R3 = regs.R28;
		/* 820F0D0Ch case   41:*/		return 0x820F0D10;
		  /* 820F0D10h */ case   42:  		/* bl 46488 */
		/* 820F0D10h case   42:*/		regs.LR = 0x820F0D14; return 0x820FC2A8;
		/* 820F0D10h case   42:*/		return 0x820F0D14;
		  /* 820F0D14h */ case   43:  		/* cmpwi CR0, R3, 0 */
		/* 820F0D14h case   43:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0D14h case   43:*/		return 0x820F0D18;
		  /* 820F0D18h */ case   44:  		/* bc 4, CR0_EQ, 264 */
		/* 820F0D18h case   44:*/		if ( !regs.CR[0].eq ) { return 0x820F0E20;  }
		/* 820F0D18h case   44:*/		return 0x820F0D1C;
		  /* 820F0D1Ch */ case   45:  		/* mr R6, R30 */
		/* 820F0D1Ch case   45:*/		regs.R6 = regs.R30;
		/* 820F0D1Ch case   45:*/		return 0x820F0D20;
		  /* 820F0D20h */ case   46:  		/* mr R5, R28 */
		/* 820F0D20h case   46:*/		regs.R5 = regs.R28;
		/* 820F0D20h case   46:*/		return 0x820F0D24;
		  /* 820F0D24h */ case   47:  		/* mr R4, R25 */
		/* 820F0D24h case   47:*/		regs.R4 = regs.R25;
		/* 820F0D24h case   47:*/		return 0x820F0D28;
		  /* 820F0D28h */ case   48:  		/* mr R3, R31 */
		/* 820F0D28h case   48:*/		regs.R3 = regs.R31;
		/* 820F0D28h case   48:*/		return 0x820F0D2C;
		  /* 820F0D2Ch */ case   49:  		/* bl -51180 */
		/* 820F0D2Ch case   49:*/		regs.LR = 0x820F0D30; return 0x820E4540;
		/* 820F0D2Ch case   49:*/		return 0x820F0D30;
		  /* 820F0D30h */ case   50:  		/* lwz R11, <#[R31 + 24]> */
		/* 820F0D30h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820F0D30h case   50:*/		return 0x820F0D34;
		  /* 820F0D34h */ case   51:  		/* add R9, R11, R24 */
		/* 820F0D34h case   51:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R24);
		/* 820F0D34h case   51:*/		return 0x820F0D38;
		  /* 820F0D38h */ case   52:  		/* lwzx R10, <#[R26 + R11]> */
		/* 820F0D38h case   52:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 820F0D38h case   52:*/		return 0x820F0D3C;
		  /* 820F0D3Ch */ case   53:  		/* lwz R11, <#[R9 - 4]> */
		/* 820F0D3Ch case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0xFFFFFFFC) );
		/* 820F0D3Ch case   53:*/		return 0x820F0D40;
		  /* 820F0D40h */ case   54:  		/* lwz R9, <#[R11 + 12]> */
		/* 820F0D40h case   54:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F0D40h case   54:*/		return 0x820F0D44;
		  /* 820F0D44h */ case   55:  		/* cmplwi CR6, R9, 0 */
		/* 820F0D44h case   55:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820F0D44h case   55:*/		return 0x820F0D48;
		  /* 820F0D48h */ case   56:  		/* bc 12, CR6_EQ, 208 */
		/* 820F0D48h case   56:*/		if ( regs.CR[6].eq ) { return 0x820F0E18;  }
		/* 820F0D48h case   56:*/		return 0x820F0D4C;
		  /* 820F0D4Ch */ case   57:  		/* lwz R9, <#[R10 + 12]> */
		/* 820F0D4Ch case   57:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F0D4Ch case   57:*/		return 0x820F0D50;
		  /* 820F0D50h */ case   58:  		/* cmplwi CR6, R9, 0 */
		/* 820F0D50h case   58:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820F0D50h case   58:*/		return 0x820F0D54;
		  /* 820F0D54h */ case   59:  		/* bc 12, CR6_EQ, 196 */
		/* 820F0D54h case   59:*/		if ( regs.CR[6].eq ) { return 0x820F0E18;  }
		/* 820F0D54h case   59:*/		return 0x820F0D58;
		  /* 820F0D58h */ case   60:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F0D58h case   60:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F0D58h case   60:*/		return 0x820F0D5C;
		  /* 820F0D5Ch */ case   61:  		/* lwz R10, <#[R10 + 16]> */
		/* 820F0D5Ch case   61:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820F0D5Ch case   61:*/		return 0x820F0D60;
		  /* 820F0D60h */ case   62:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F0D60h case   62:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F0D60h case   62:*/		return 0x820F0D64;
		  /* 820F0D64h */ case   63:  		/* lwz R11, <#[R11]> */
		/* 820F0D64h case   63:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F0D64h case   63:*/		return 0x820F0D68;
		  /* 820F0D68h */ case   64:  		/* lwz R10, <#[R10]> */
		/* 820F0D68h case   64:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820F0D68h case   64:*/		return 0x820F0D6C;
		  /* 820F0D6Ch */ case   65:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F0D6Ch case   65:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F0D6Ch case   65:*/		return 0x820F0D70;
		  /* 820F0D70h */ case   66:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F0D70h case   66:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F0D70h case   66:*/		return 0x820F0D74;
		  /* 820F0D74h */ case   67:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F0D74h case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F0D74h case   67:*/		return 0x820F0D78;
		  /* 820F0D78h */ case   68:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820F0D78h case   68:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F0D78h case   68:*/		return 0x820F0D7C;
		  /* 820F0D7Ch */ case   69:  		/* lwz R9, <#[R11 + 20]> */
		/* 820F0D7Ch case   69:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820F0D7Ch case   69:*/		return 0x820F0D80;
		  /* 820F0D80h */ case   70:  		/* lwz R8, <#[R10 + 20]> */
		/* 820F0D80h case   70:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000014) );
		/* 820F0D80h case   70:*/		return 0x820F0D84;
		  /* 820F0D84h */ case   71:  		/* cmplw CR6, R9, R8 */
		/* 820F0D84h case   71:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820F0D84h case   71:*/		return 0x820F0D88;
		  /* 820F0D88h */ case   72:  		/* bc 4, CR6_EQ, 152 */
		/* 820F0D88h case   72:*/		if ( !regs.CR[6].eq ) { return 0x820F0E20;  }
		/* 820F0D88h case   72:*/		return 0x820F0D8C;
		  /* 820F0D8Ch */ case   73:  		/* lwz R11, <#[R11 + 24]> */
		/* 820F0D8Ch case   73:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820F0D8Ch case   73:*/		return 0x820F0D90;
		  /* 820F0D90h */ case   74:  		/* lwz R10, <#[R10 + 24]> */
		/* 820F0D90h case   74:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 820F0D90h case   74:*/		return 0x820F0D94;
		  /* 820F0D94h */ case   75:  		/* cmpw CR6, R11, R10 */
		/* 820F0D94h case   75:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820F0D94h case   75:*/		return 0x820F0D98;
		  /* 820F0D98h */ case   76:  		/* bc 4, CR6_EQ, 136 */
		/* 820F0D98h case   76:*/		if ( !regs.CR[6].eq ) { return 0x820F0E20;  }
		/* 820F0D98h case   76:*/		return 0x820F0D9C;
		  /* 820F0D9Ch */ case   77:  		/* addi R29, R30, -1 */
		/* 820F0D9Ch case   77:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0xFFFFFFFF);
		/* 820F0D9Ch case   77:*/		return 0x820F0DA0;
		  /* 820F0DA0h */ case   78:  		/* mr R5, R27 */
		/* 820F0DA0h case   78:*/		regs.R5 = regs.R27;
		/* 820F0DA0h case   78:*/		return 0x820F0DA4;
		  /* 820F0DA4h */ case   79:  		/* mr R4, R29 */
		/* 820F0DA4h case   79:*/		regs.R4 = regs.R29;
		/* 820F0DA4h case   79:*/		return 0x820F0DA8;
		  /* 820F0DA8h */ case   80:  		/* mr R3, R31 */
		/* 820F0DA8h case   80:*/		regs.R3 = regs.R31;
		/* 820F0DA8h case   80:*/		return 0x820F0DAC;
		  /* 820F0DACh */ case   81:  		/* bl -23980 */
		/* 820F0DACh case   81:*/		regs.LR = 0x820F0DB0; return 0x820EB000;
		/* 820F0DACh case   81:*/		return 0x820F0DB0;
		  /* 820F0DB0h */ case   82:  		/* lwz R11, <#[R31 + 108]> */
		/* 820F0DB0h case   82:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F0DB0h case   82:*/		return 0x820F0DB4;
		  /* 820F0DB4h */ case   83:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820F0DB4h case   83:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820F0DB4h case   83:*/		return 0x820F0DB8;
		  /* 820F0DB8h */ case   84:  		/* bc 4, CR0_EQ, 28 */
		/* 820F0DB8h case   84:*/		if ( !regs.CR[0].eq ) { return 0x820F0DD4;  }
		/* 820F0DB8h case   84:*/		return 0x820F0DBC;
		  /* 820F0DBCh */ case   85:  		/* li R5, 0 */
		/* 820F0DBCh case   85:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F0DBCh case   85:*/		return 0x820F0DC0;
		  /* 820F0DC0h */ case   86:  		/* mr R4, R22 */
		/* 820F0DC0h case   86:*/		regs.R4 = regs.R22;
		/* 820F0DC0h case   86:*/		return 0x820F0DC4;
		  /* 820F0DC4h */ case   87:  		/* mr R3, R31 */
		/* 820F0DC4h case   87:*/		regs.R3 = regs.R31;
		/* 820F0DC4h case   87:*/		return 0x820F0DC8;
		  /* 820F0DC8h */ case   88:  		/* bl 142600 */
		/* 820F0DC8h case   88:*/		regs.LR = 0x820F0DCC; return 0x82113AD0;
		/* 820F0DC8h case   88:*/		return 0x820F0DCC;
		  /* 820F0DCCh */ case   89:  		/* cmpwi CR0, R3, 0 */
		/* 820F0DCCh case   89:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0DCCh case   89:*/		return 0x820F0DD0;
		  /* 820F0DD0h */ case   90:  		/* bc 12, CR0_LT, 36 */
		/* 820F0DD0h case   90:*/		if ( regs.CR[0].lt ) { return 0x820F0DF4;  }
		/* 820F0DD0h case   90:*/		return 0x820F0DD4;
	}
	return 0x820F0DD4;
} // Block from 820F0C68h-820F0DD4h (91 instructions)

//////////////////////////////////////////////////////
// Block at 820F0DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0DD4);
		  /* 820F0DD4h */ case    0:  		/* cmpwi CR6, R20, 0 */
		/* 820F0DD4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 820F0DD4h case    0:*/		return 0x820F0DD8;
		  /* 820F0DD8h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 820F0DD8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F0E2C;  }
		/* 820F0DD8h case    1:*/		return 0x820F0DDC;
		  /* 820F0DDCh */ case    2:  		/* li R5, 0 */
		/* 820F0DDCh case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F0DDCh case    2:*/		return 0x820F0DE0;
		  /* 820F0DE0h */ case    3:  		/* mr R4, R21 */
		/* 820F0DE0h case    3:*/		regs.R4 = regs.R21;
		/* 820F0DE0h case    3:*/		return 0x820F0DE4;
		  /* 820F0DE4h */ case    4:  		/* mr R3, R31 */
		/* 820F0DE4h case    4:*/		regs.R3 = regs.R31;
		/* 820F0DE4h case    4:*/		return 0x820F0DE8;
		  /* 820F0DE8h */ case    5:  		/* bl 142568 */
		/* 820F0DE8h case    5:*/		regs.LR = 0x820F0DEC; return 0x82113AD0;
		/* 820F0DE8h case    5:*/		return 0x820F0DEC;
		  /* 820F0DECh */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820F0DECh case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0DECh case    6:*/		return 0x820F0DF0;
		  /* 820F0DF0h */ case    7:  		/* bc 4, CR0_LT, 60 */
		/* 820F0DF0h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820F0E2C;  }
		/* 820F0DF0h case    7:*/		return 0x820F0DF4;
	}
	return 0x820F0DF4;
} // Block from 820F0DD4h-820F0DF4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F0DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0DF4);
		  /* 820F0DF4h */ case    0:  		/* mr R5, R29 */
		/* 820F0DF4h case    0:*/		regs.R5 = regs.R29;
		/* 820F0DF4h case    0:*/		return 0x820F0DF8;
		  /* 820F0DF8h */ case    1:  		/* mr R4, R27 */
		/* 820F0DF8h case    1:*/		regs.R4 = regs.R27;
		/* 820F0DF8h case    1:*/		return 0x820F0DFC;
		  /* 820F0DFCh */ case    2:  		/* mr R3, R31 */
		/* 820F0DFCh case    2:*/		regs.R3 = regs.R31;
		/* 820F0DFCh case    2:*/		return 0x820F0E00;
		  /* 820F0E00h */ case    3:  		/* bl -24064 */
		/* 820F0E00h case    3:*/		regs.LR = 0x820F0E04; return 0x820EB000;
		/* 820F0E00h case    3:*/		return 0x820F0E04;
		  /* 820F0E04h */ case    4:  		/* mr R6, R30 */
		/* 820F0E04h case    4:*/		regs.R6 = regs.R30;
		/* 820F0E04h case    4:*/		return 0x820F0E08;
		  /* 820F0E08h */ case    5:  		/* mr R5, R28 */
		/* 820F0E08h case    5:*/		regs.R5 = regs.R28;
		/* 820F0E08h case    5:*/		return 0x820F0E0C;
		  /* 820F0E0Ch */ case    6:  		/* mr R4, R25 */
		/* 820F0E0Ch case    6:*/		regs.R4 = regs.R25;
		/* 820F0E0Ch case    6:*/		return 0x820F0E10;
		  /* 820F0E10h */ case    7:  		/* mr R3, R31 */
		/* 820F0E10h case    7:*/		regs.R3 = regs.R31;
		/* 820F0E10h case    7:*/		return 0x820F0E14;
		  /* 820F0E14h */ case    8:  		/* bl -51412 */
		/* 820F0E14h case    8:*/		regs.LR = 0x820F0E18; return 0x820E4540;
		/* 820F0E14h case    8:*/		return 0x820F0E18;
	}
	return 0x820F0E18;
} // Block from 820F0DF4h-820F0E18h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F0E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0E18);
		  /* 820F0E18h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820F0E18h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820F0E18h case    0:*/		return 0x820F0E1C;
		  /* 820F0E1Ch */ case    1:  		/* bc 4, CR6_EQ, -324 */
		/* 820F0E1Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F0CD8;  }
		/* 820F0E1Ch case    1:*/		return 0x820F0E20;
	}
	return 0x820F0E20;
} // Block from 820F0E18h-820F0E20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F0E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0E20);
		  /* 820F0E20h */ case    0:  		/* li R3, 1 */
		/* 820F0E20h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F0E20h case    0:*/		return 0x820F0E24;
		  /* 820F0E24h */ case    1:  		/* addi R1, R1, 192 */
		/* 820F0E24h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820F0E24h case    1:*/		return 0x820F0E28;
		  /* 820F0E28h */ case    2:  		/* b -392096 */
		/* 820F0E28h case    2:*/		return 0x82091288;
		/* 820F0E28h case    2:*/		return 0x820F0E2C;
	}
	return 0x820F0E2C;
} // Block from 820F0E20h-820F0E2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F0E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0E2C);
		  /* 820F0E2Ch */ case    0:  		/* li R3, 0 */
		/* 820F0E2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F0E2Ch case    0:*/		return 0x820F0E30;
		  /* 820F0E30h */ case    1:  		/* b -12 */
		/* 820F0E30h case    1:*/		return 0x820F0E24;
		/* 820F0E30h case    1:*/		return 0x820F0E34;
		  /* 820F0E34h */ case    2:  		/* nop */
		/* 820F0E34h case    2:*/		cpu::op::nop();
		/* 820F0E34h case    2:*/		return 0x820F0E38;
	}
	return 0x820F0E38;
} // Block from 820F0E2Ch-820F0E38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F0E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0E38);
		  /* 820F0E38h */ case    0:  		/* mfspr R12, LR */
		/* 820F0E38h case    0:*/		regs.R12 = regs.LR;
		/* 820F0E38h case    0:*/		return 0x820F0E3C;
		  /* 820F0E3Ch */ case    1:  		/* bl -392188 */
		/* 820F0E3Ch case    1:*/		regs.LR = 0x820F0E40; return 0x82091240;
		/* 820F0E3Ch case    1:*/		return 0x820F0E40;
		  /* 820F0E40h */ case    2:  		/* stwu R1, <#[R1 - 384]> */
		/* 820F0E40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE80);
		/* 820F0E40h case    2:*/		return 0x820F0E44;
		  /* 820F0E44h */ case    3:  		/* lwz R11, <#[R3 + 204]> */
		/* 820F0E44h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000CC) );
		/* 820F0E44h case    3:*/		return 0x820F0E48;
		  /* 820F0E48h */ case    4:  		/* mr R31, R3 */
		/* 820F0E48h case    4:*/		regs.R31 = regs.R3;
		/* 820F0E48h case    4:*/		return 0x820F0E4C;
		  /* 820F0E4Ch */ case    5:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820F0E4Ch case    5:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820F0E4Ch case    5:*/		return 0x820F0E50;
		  /* 820F0E50h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 820F0E50h case    6:*/		if ( regs.CR[0].eq ) { return 0x820F0E5C;  }
		/* 820F0E50h case    6:*/		return 0x820F0E54;
		  /* 820F0E54h */ case    7:  		/* li R3, 1 */
		/* 820F0E54h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F0E54h case    7:*/		return 0x820F0E58;
		  /* 820F0E58h */ case    8:  		/* b 968 */
		/* 820F0E58h case    8:*/		return 0x820F1220;
		/* 820F0E58h case    8:*/		return 0x820F0E5C;
	}
	return 0x820F0E5C;
} // Block from 820F0E38h-820F0E5Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F0E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0E5C);
		  /* 820F0E5Ch */ case    0:  		/* mr R3, R31 */
		/* 820F0E5Ch case    0:*/		regs.R3 = regs.R31;
		/* 820F0E5Ch case    0:*/		return 0x820F0E60;
		  /* 820F0E60h */ case    1:  		/* bl 69120 */
		/* 820F0E60h case    1:*/		regs.LR = 0x820F0E64; return 0x82101C60;
		/* 820F0E60h case    1:*/		return 0x820F0E64;
		  /* 820F0E64h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820F0E64h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0E64h case    2:*/		return 0x820F0E68;
		  /* 820F0E68h */ case    3:  		/* bc 12, CR0_LT, 952 */
		/* 820F0E68h case    3:*/		if ( regs.CR[0].lt ) { return 0x820F1220;  }
		/* 820F0E68h case    3:*/		return 0x820F0E6C;
		  /* 820F0E6Ch */ case    4:  		/* mr R3, R31 */
		/* 820F0E6Ch case    4:*/		regs.R3 = regs.R31;
		/* 820F0E6Ch case    4:*/		return 0x820F0E70;
		  /* 820F0E70h */ case    5:  		/* bl 86512 */
		/* 820F0E70h case    5:*/		regs.LR = 0x820F0E74; return 0x82106060;
		/* 820F0E70h case    5:*/		return 0x820F0E74;
		  /* 820F0E74h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820F0E74h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0E74h case    6:*/		return 0x820F0E78;
		  /* 820F0E78h */ case    7:  		/* bc 12, CR0_LT, 936 */
		/* 820F0E78h case    7:*/		if ( regs.CR[0].lt ) { return 0x820F1220;  }
		/* 820F0E78h case    7:*/		return 0x820F0E7C;
		  /* 820F0E7Ch */ case    8:  		/* li R5, 100 */
		/* 820F0E7Ch case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x64);
		/* 820F0E7Ch case    8:*/		return 0x820F0E80;
		  /* 820F0E80h */ case    9:  		/* lwz R29, <#[R31 + 12]> */
		/* 820F0E80h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F0E80h case    9:*/		return 0x820F0E84;
		  /* 820F0E84h */ case   10:  		/* li R4, 0 */
		/* 820F0E84h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F0E84h case   10:*/		return 0x820F0E88;
		  /* 820F0E88h */ case   11:  		/* addi R3, R1, 80 */
		/* 820F0E88h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820F0E88h case   11:*/		return 0x820F0E8C;
		  /* 820F0E8Ch */ case   12:  		/* li R26, 0 */
		/* 820F0E8Ch case   12:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820F0E8Ch case   12:*/		return 0x820F0E90;
		  /* 820F0E90h */ case   13:  		/* li R24, 0 */
		/* 820F0E90h case   13:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820F0E90h case   13:*/		return 0x820F0E94;
		  /* 820F0E94h */ case   14:  		/* li R23, 0 */
		/* 820F0E94h case   14:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820F0E94h case   14:*/		return 0x820F0E98;
		  /* 820F0E98h */ case   15:  		/* bl -392024 */
		/* 820F0E98h case   15:*/		regs.LR = 0x820F0E9C; return 0x82091340;
		/* 820F0E98h case   15:*/		return 0x820F0E9C;
		  /* 820F0E9Ch */ case   16:  		/* li R5, 100 */
		/* 820F0E9Ch case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x64);
		/* 820F0E9Ch case   16:*/		return 0x820F0EA0;
		  /* 820F0EA0h */ case   17:  		/* li R4, 0 */
		/* 820F0EA0h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F0EA0h case   17:*/		return 0x820F0EA4;
		  /* 820F0EA4h */ case   18:  		/* addi R3, R1, 192 */
		/* 820F0EA4h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xC0);
		/* 820F0EA4h case   18:*/		return 0x820F0EA8;
		  /* 820F0EA8h */ case   19:  		/* bl -392040 */
		/* 820F0EA8h case   19:*/		regs.LR = 0x820F0EAC; return 0x82091340;
		/* 820F0EA8h case   19:*/		return 0x820F0EAC;
		  /* 820F0EACh */ case   20:  		/* lwz R11, <#[R31 + 108]> */
		/* 820F0EACh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F0EACh case   20:*/		return 0x820F0EB0;
		  /* 820F0EB0h */ case   21:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820F0EB0h case   21:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820F0EB0h case   21:*/		return 0x820F0EB4;
		  /* 820F0EB4h */ case   22:  		/* bc 4, CR0_EQ, 208 */
		/* 820F0EB4h case   22:*/		if ( !regs.CR[0].eq ) { return 0x820F0F84;  }
		/* 820F0EB4h case   22:*/		return 0x820F0EB8;
		  /* 820F0EB8h */ case   23:  		/* lwz R6, <#[R31 + 48]> */
		/* 820F0EB8h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000030) );
		/* 820F0EB8h case   23:*/		return 0x820F0EBC;
		  /* 820F0EBCh */ case   24:  		/* cmplwi CR6, R6, 0 */
		/* 820F0EBCh case   24:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820F0EBCh case   24:*/		return 0x820F0EC0;
	}
	return 0x820F0EC0;
} // Block from 820F0E5Ch-820F0EC0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820F0EC0h
// Function '?ValidModifier@CShaderProgram@D3DXShader@@IAAJI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0EC0);
		  /* 820F0EC0h */ case    0:  		/* bc 12, CR6_EQ, 52 */
		/* 820F0EC0h case    0:*/		if ( regs.CR[6].eq ) { return 0x820F0EF4;  }
		/* 820F0EC0h case    0:*/		return 0x820F0EC4;
		  /* 820F0EC4h */ case    1:  		/* addi R4, R1, 192 */
		/* 820F0EC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xC0);
		/* 820F0EC4h case    1:*/		return 0x820F0EC8;
		  /* 820F0EC8h */ case    2:  		/* lwz R5, <#[R31 + 140]> */
		/* 820F0EC8h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000008C) );
		/* 820F0EC8h case    2:*/		return 0x820F0ECC;
		  /* 820F0ECCh */ case    3:  		/* mr R3, R31 */
		/* 820F0ECCh case    3:*/		regs.R3 = regs.R31;
		/* 820F0ECCh case    3:*/		return 0x820F0ED0;
		  /* 820F0ED0h */ case    4:  		/* bl 118312 */
		/* 820F0ED0h case    4:*/		regs.LR = 0x820F0ED4; return 0x8210DCF8;
		/* 820F0ED0h case    4:*/		return 0x820F0ED4;
		  /* 820F0ED4h */ case    5:  		/* or. R30, R3, R3 */
		/* 820F0ED4h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F0ED4h case    5:*/		return 0x820F0ED8;
		  /* 820F0ED8h */ case    6:  		/* bc 12, CR0_LT, 764 */
		/* 820F0ED8h case    6:*/		if ( regs.CR[0].lt ) { return 0x820F11D4;  }
		/* 820F0ED8h case    6:*/		return 0x820F0EDC;
		  /* 820F0EDCh */ case    7:  		/* li R5, 0 */
		/* 820F0EDCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F0EDCh case    7:*/		return 0x820F0EE0;
		  /* 820F0EE0h */ case    8:  		/* addi R4, R1, 192 */
		/* 820F0EE0h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xC0);
		/* 820F0EE0h case    8:*/		return 0x820F0EE4;
		  /* 820F0EE4h */ case    9:  		/* mr R3, R31 */
		/* 820F0EE4h case    9:*/		regs.R3 = regs.R31;
		/* 820F0EE4h case    9:*/		return 0x820F0EE8;
		  /* 820F0EE8h */ case   10:  		/* bl 142312 */
		/* 820F0EE8h case   10:*/		regs.LR = 0x820F0EEC; return 0x82113AD0;
		/* 820F0EE8h case   10:*/		return 0x820F0EEC;
		  /* 820F0EECh */ case   11:  		/* rlwinm R11, R3, 1, 31, 31 */
		/* 820F0EECh case   11:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R3);
		/* 820F0EECh case   11:*/		return 0x820F0EF0;
		  /* 820F0EF0h */ case   12:  		/* xori R23, R11, 1 */
		/* 820F0EF0h case   12:*/		cpu::op::xori<0>(regs,&regs.R23,regs.R11,0x1);
		/* 820F0EF0h case   12:*/		return 0x820F0EF4;
	}
	return 0x820F0EF4;
} // Block from 820F0EC0h-820F0EF4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820F0EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0EF4);
		  /* 820F0EF4h */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 820F0EF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820F0EF4h case    0:*/		return 0x820F0EF8;
		  /* 820F0EF8h */ case    1:  		/* addi R4, R1, 80 */
		/* 820F0EF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F0EF8h case    1:*/		return 0x820F0EFC;
		  /* 820F0EFCh */ case    2:  		/* mr R3, R31 */
		/* 820F0EFCh case    2:*/		regs.R3 = regs.R31;
		/* 820F0EFCh case    2:*/		return 0x820F0F00;
		  /* 820F0F00h */ case    3:  		/* lwz R5, <#[R31 + 136]> */
		/* 820F0F00h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000088) );
		/* 820F0F00h case    3:*/		return 0x820F0F04;
		  /* 820F0F04h */ case    4:  		/* addi R6, R11, -1 */
		/* 820F0F04h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 820F0F04h case    4:*/		return 0x820F0F08;
		  /* 820F0F08h */ case    5:  		/* bl 118256 */
		/* 820F0F08h case    5:*/		regs.LR = 0x820F0F0C; return 0x8210DCF8;
		/* 820F0F08h case    5:*/		return 0x820F0F0C;
		  /* 820F0F0Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820F0F0Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0F0Ch case    6:*/		return 0x820F0F10;
		  /* 820F0F10h */ case    7:  		/* bc 12, CR0_LT, 28 */
		/* 820F0F10h case    7:*/		if ( regs.CR[0].lt ) { return 0x820F0F2C;  }
		/* 820F0F10h case    7:*/		return 0x820F0F14;
		  /* 820F0F14h */ case    8:  		/* li R5, 0 */
		/* 820F0F14h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F0F14h case    8:*/		return 0x820F0F18;
		  /* 820F0F18h */ case    9:  		/* addi R4, R1, 80 */
		/* 820F0F18h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F0F18h case    9:*/		return 0x820F0F1C;
		  /* 820F0F1Ch */ case   10:  		/* mr R3, R31 */
		/* 820F0F1Ch case   10:*/		regs.R3 = regs.R31;
		/* 820F0F1Ch case   10:*/		return 0x820F0F20;
		  /* 820F0F20h */ case   11:  		/* bl 142256 */
		/* 820F0F20h case   11:*/		regs.LR = 0x820F0F24; return 0x82113AD0;
		/* 820F0F20h case   11:*/		return 0x820F0F24;
		  /* 820F0F24h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820F0F24h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F0F24h case   12:*/		return 0x820F0F28;
		  /* 820F0F28h */ case   13:  		/* bc 4, CR0_LT, 92 */
		/* 820F0F28h case   13:*/		if ( !regs.CR[0].lt ) { return 0x820F0F84;  }
		/* 820F0F28h case   13:*/		return 0x820F0F2C;
	}
	return 0x820F0F2C;
} // Block from 820F0EF4h-820F0F2Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F0F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0F2C);
		  /* 820F0F2Ch */ case    0:  		/* addi R4, R1, 80 */
		/* 820F0F2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F0F2Ch case    0:*/		return 0x820F0F30;
		  /* 820F0F30h */ case    1:  		/* mr R3, R31 */
		/* 820F0F30h case    1:*/		regs.R3 = regs.R31;
		/* 820F0F30h case    1:*/		return 0x820F0F34;
		  /* 820F0F34h */ case    2:  		/* bl 84828 */
		/* 820F0F34h case    2:*/		regs.LR = 0x820F0F38; return 0x82105A90;
		/* 820F0F34h case    2:*/		return 0x820F0F38;
		  /* 820F0F38h */ case    3:  		/* addi R4, R1, 80 */
		/* 820F0F38h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F0F38h case    3:*/		return 0x820F0F3C;
		  /* 820F0F3Ch */ case    4:  		/* mr R3, R31 */
		/* 820F0F3Ch case    4:*/		regs.R3 = regs.R31;
		/* 820F0F3Ch case    4:*/		return 0x820F0F40;
		  /* 820F0F40h */ case    5:  		/* lwz R6, <#[R31 + 44]> */
		/* 820F0F40h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000002C) );
		/* 820F0F40h case    5:*/		return 0x820F0F44;
		  /* 820F0F44h */ case    6:  		/* lwz R5, <#[R31 + 136]> */
		/* 820F0F44h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000088) );
		/* 820F0F44h case    6:*/		return 0x820F0F48;
		  /* 820F0F48h */ case    7:  		/* bl 118192 */
		/* 820F0F48h case    7:*/		regs.LR = 0x820F0F4C; return 0x8210DCF8;
		/* 820F0F48h case    7:*/		return 0x820F0F4C;
		  /* 820F0F4Ch */ case    8:  		/* or. R30, R3, R3 */
		/* 820F0F4Ch case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F0F4Ch case    8:*/		return 0x820F0F50;
		  /* 820F0F50h */ case    9:  		/* bc 12, CR0_LT, 28 */
		/* 820F0F50h case    9:*/		if ( regs.CR[0].lt ) { return 0x820F0F6C;  }
		/* 820F0F50h case    9:*/		return 0x820F0F54;
		  /* 820F0F54h */ case   10:  		/* li R5, 0 */
		/* 820F0F54h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F0F54h case   10:*/		return 0x820F0F58;
		  /* 820F0F58h */ case   11:  		/* addi R4, R1, 80 */
		/* 820F0F58h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F0F58h case   11:*/		return 0x820F0F5C;
		  /* 820F0F5Ch */ case   12:  		/* mr R3, R31 */
		/* 820F0F5Ch case   12:*/		regs.R3 = regs.R31;
		/* 820F0F5Ch case   12:*/		return 0x820F0F60;
		  /* 820F0F60h */ case   13:  		/* bl 142192 */
		/* 820F0F60h case   13:*/		regs.LR = 0x820F0F64; return 0x82113AD0;
		/* 820F0F60h case   13:*/		return 0x820F0F64;
		  /* 820F0F64h */ case   14:  		/* or. R30, R3, R3 */
		/* 820F0F64h case   14:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F0F64h case   14:*/		return 0x820F0F68;
		  /* 820F0F68h */ case   15:  		/* bc 4, CR0_LT, 28 */
		/* 820F0F68h case   15:*/		if ( !regs.CR[0].lt ) { return 0x820F0F84;  }
		/* 820F0F68h case   15:*/		return 0x820F0F6C;
	}
	return 0x820F0F6C;
} // Block from 820F0F2Ch-820F0F6Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 820F0F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0F6C);
		  /* 820F0F6Ch */ case    0:  		/* lis R11, -32761 */
		/* 820F0F6Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8007);
		/* 820F0F6Ch case    0:*/		return 0x820F0F70;
	}
	return 0x820F0F70;
} // Block from 820F0F6Ch-820F0F70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F0F70h
// Function '?MatchLRP@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0F70);
		  /* 820F0F70h */ case    0:  		/* ori R11, R11, 14 */
		/* 820F0F70h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xE);
		/* 820F0F70h case    0:*/		return 0x820F0F74;
		  /* 820F0F74h */ case    1:  		/* cmpw CR6, R30, R11 */
		/* 820F0F74h case    1:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 820F0F74h case    1:*/		return 0x820F0F78;
		  /* 820F0F78h */ case    2:  		/* bc 12, CR6_EQ, 604 */
		/* 820F0F78h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F11D4;  }
		/* 820F0F78h case    2:*/		return 0x820F0F7C;
		  /* 820F0F7Ch */ case    3:  		/* li R30, 1 */
		/* 820F0F7Ch case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820F0F7Ch case    3:*/		return 0x820F0F80;
		  /* 820F0F80h */ case    4:  		/* b 596 */
		/* 820F0F80h case    4:*/		return 0x820F11D4;
		/* 820F0F80h case    4:*/		return 0x820F0F84;
	}
	return 0x820F0F84;
} // Block from 820F0F70h-820F0F84h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F0F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0F84);
		  /* 820F0F84h */ case    0:  		/* rlwinm R25, R29, 2, 0, 29 */
		/* 820F0F84h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R25,regs.R29);
		/* 820F0F84h case    0:*/		return 0x820F0F88;
		  /* 820F0F88h */ case    1:  		/* lis R4, 9345 */
		/* 820F0F88h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F0F88h case    1:*/		return 0x820F0F8C;
		  /* 820F0F8Ch */ case    2:  		/* mr R3, R25 */
		/* 820F0F8Ch case    2:*/		regs.R3 = regs.R25;
		/* 820F0F8Ch case    2:*/		return 0x820F0F90;
		  /* 820F0F90h */ case    3:  		/* bl -429456 */
		/* 820F0F90h case    3:*/		regs.LR = 0x820F0F94; return 0x82088200;
		/* 820F0F90h case    3:*/		return 0x820F0F94;
		  /* 820F0F94h */ case    4:  		/* or. R26, R3, R3 */
		/* 820F0F94h case    4:*/		cpu::op::or<1>(regs,&regs.R26,regs.R3,regs.R3);
		/* 820F0F94h case    4:*/		return 0x820F0F98;
		  /* 820F0F98h */ case    5:  		/* bc 12, CR0_EQ, 24 */
		/* 820F0F98h case    5:*/		if ( regs.CR[0].eq ) { return 0x820F0FB0;  }
		/* 820F0F98h case    5:*/		return 0x820F0F9C;
		  /* 820F0F9Ch */ case    6:  		/* lis R4, 9345 */
		/* 820F0F9Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F0F9Ch case    6:*/		return 0x820F0FA0;
		  /* 820F0FA0h */ case    7:  		/* mr R3, R25 */
		/* 820F0FA0h case    7:*/		regs.R3 = regs.R25;
		/* 820F0FA0h case    7:*/		return 0x820F0FA4;
		  /* 820F0FA4h */ case    8:  		/* bl -429476 */
		/* 820F0FA4h case    8:*/		regs.LR = 0x820F0FA8; return 0x82088200;
		/* 820F0FA4h case    8:*/		return 0x820F0FA8;
		  /* 820F0FA8h */ case    9:  		/* or. R24, R3, R3 */
		/* 820F0FA8h case    9:*/		cpu::op::or<1>(regs,&regs.R24,regs.R3,regs.R3);
		/* 820F0FA8h case    9:*/		return 0x820F0FAC;
		  /* 820F0FACh */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 820F0FACh case   10:*/		if ( !regs.CR[0].eq ) { return 0x820F0FBC;  }
		/* 820F0FACh case   10:*/		return 0x820F0FB0;
	}
	return 0x820F0FB0;
} // Block from 820F0F84h-820F0FB0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F0FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0FB0);
		  /* 820F0FB0h */ case    0:  		/* lis R30, -32761 */
		/* 820F0FB0h case    0:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8007);
		/* 820F0FB0h case    0:*/		return 0x820F0FB4;
		  /* 820F0FB4h */ case    1:  		/* ori R30, R30, 14 */
		/* 820F0FB4h case    1:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xE);
		/* 820F0FB4h case    1:*/		return 0x820F0FB8;
		  /* 820F0FB8h */ case    2:  		/* b 540 */
		/* 820F0FB8h case    2:*/		return 0x820F11D4;
		/* 820F0FB8h case    2:*/		return 0x820F0FBC;
	}
	return 0x820F0FBC;
} // Block from 820F0FB0h-820F0FBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F0FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F0FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F0FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F0FBC);
		  /* 820F0FBCh */ case    0:  		/* mr R5, R25 */
		/* 820F0FBCh case    0:*/		regs.R5 = regs.R25;
		/* 820F0FBCh case    0:*/		return 0x820F0FC0;
		  /* 820F0FC0h */ case    1:  		/* lwz R4, <#[R31 + 24]> */
		/* 820F0FC0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820F0FC0h case    1:*/		return 0x820F0FC4;
		  /* 820F0FC4h */ case    2:  		/* mr R3, R24 */
		/* 820F0FC4h case    2:*/		regs.R3 = regs.R24;
		/* 820F0FC4h case    2:*/		return 0x820F0FC8;
		  /* 820F0FC8h */ case    3:  		/* bl -390680 */
		/* 820F0FC8h case    3:*/		regs.LR = 0x820F0FCC; return 0x820919B0;
		/* 820F0FC8h case    3:*/		return 0x820F0FCC;
		  /* 820F0FCCh */ case    4:  		/* mr R5, R25 */
		/* 820F0FCCh case    4:*/		regs.R5 = regs.R25;
		/* 820F0FCCh case    4:*/		return 0x820F0FD0;
		  /* 820F0FD0h */ case    5:  		/* mr R3, R26 */
		/* 820F0FD0h case    5:*/		regs.R3 = regs.R26;
		/* 820F0FD0h case    5:*/		return 0x820F0FD4;
		  /* 820F0FD4h */ case    6:  		/* lwz R4, <#[R31 + 24]> */
		/* 820F0FD4h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820F0FD4h case    6:*/		return 0x820F0FD8;
		  /* 820F0FD8h */ case    7:  		/* bl -390696 */
		/* 820F0FD8h case    7:*/		regs.LR = 0x820F0FDC; return 0x820919B0;
		/* 820F0FD8h case    7:*/		return 0x820F0FDC;
		  /* 820F0FDCh */ case    8:  		/* cmplwi CR6, R29, 0 */
		/* 820F0FDCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820F0FDCh case    8:*/		return 0x820F0FE0;
		  /* 820F0FE0h */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 820F0FE0h case    9:*/		if ( regs.CR[6].eq ) { return 0x820F1008;  }
		/* 820F0FE0h case    9:*/		return 0x820F0FE4;
		  /* 820F0FE4h */ case   10:  		/* mtspr CTR, R29 */
		/* 820F0FE4h case   10:*/		regs.CTR = regs.R29;
		/* 820F0FE4h case   10:*/		return 0x820F0FE8;
		  /* 820F0FE8h */ case   11:  		/* li R11, 0 */
		/* 820F0FE8h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F0FE8h case   11:*/		return 0x820F0FEC;
		  /* 820F0FECh */ case   12:  		/* lwz R10, <#[R31 + 24]> */
		/* 820F0FECh case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820F0FECh case   12:*/		return 0x820F0FF0;
		  /* 820F0FF0h */ case   13:  		/* li R9, -1 */
		/* 820F0FF0h case   13:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 820F0FF0h case   13:*/		return 0x820F0FF4;
		  /* 820F0FF4h */ case   14:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820F0FF4h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F0FF4h case   14:*/		return 0x820F0FF8;
		  /* 820F0FF8h */ case   15:  		/* addi R11, R11, 4 */
		/* 820F0FF8h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F0FF8h case   15:*/		return 0x820F0FFC;
		  /* 820F0FFCh */ case   16:  		/* stw R10, <#[R31 + 260]> */
		/* 820F0FFCh case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F0FFCh case   16:*/		return 0x820F1000;
		  /* 820F1000h */ case   17:  		/* stw R9, <#[R10 + 36]> */
		/* 820F1000h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000024) );
		/* 820F1000h case   17:*/		return 0x820F1004;
		  /* 820F1004h */ case   18:  		/* bc 16, CR0_LT, -24 */
		/* 820F1004h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F0FEC;  }
		/* 820F1004h case   18:*/		return 0x820F1008;
	}
	return 0x820F1008;
} // Block from 820F0FBCh-820F1008h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F1008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1008);
		  /* 820F1008h */ case    0:  		/* addic. R29, R29, -1 */
		/* 820F1008h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820F1008h case    0:*/		return 0x820F100C;
		  /* 820F100Ch */ case    1:  		/* bc 12, CR0_LT, 452 */
		/* 820F100Ch case    1:*/		if ( regs.CR[0].lt ) { return 0x820F11D0;  }
		/* 820F100Ch case    1:*/		return 0x820F1010;
		  /* 820F1010h */ case    2:  		/* rlwinm R27, R29, 2, 0, 29 */
		/* 820F1010h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R29);
		/* 820F1010h case    2:*/		return 0x820F1014;
		  /* 820F1014h */ case    3:  		/* lwz R11, <#[R31 + 24]> */
		/* 820F1014h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820F1014h case    3:*/		return 0x820F1018;
		  /* 820F1018h */ case    4:  		/* lwzx R3, <#[R27 + R11]> */
		/* 820F1018h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 820F1018h case    4:*/		return 0x820F101C;
		  /* 820F101Ch */ case    5:  		/* stw R3, <#[R31 + 260]> */
		/* 820F101Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000104) );
		/* 820F101Ch case    5:*/		return 0x820F1020;
		  /* 820F1020h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820F1020h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F1020h case    6:*/		return 0x820F1024;
		  /* 820F1024h */ case    7:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 820F1024h case    7:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 820F1024h case    7:*/		return 0x820F1028;
		  /* 820F1028h */ case    8:  		/* bc 12, CR0_EQ, 412 */
		/* 820F1028h case    8:*/		if ( regs.CR[0].eq ) { return 0x820F11C4;  }
		/* 820F1028h case    8:*/		return 0x820F102C;
		  /* 820F102Ch */ case    9:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 820F102Ch case    9:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 820F102Ch case    9:*/		return 0x820F1030;
		  /* 820F1030h */ case   10:  		/* lis R10, 24576 */
		/* 820F1030h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x6000);
		/* 820F1030h case   10:*/		return 0x820F1034;
		  /* 820F1034h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820F1034h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F1034h case   11:*/		return 0x820F1038;
		  /* 820F1038h */ case   12:  		/* bc 12, CR6_EQ, 396 */
		/* 820F1038h case   12:*/		if ( regs.CR[6].eq ) { return 0x820F11C4;  }
		/* 820F1038h case   12:*/		return 0x820F103C;
		  /* 820F103Ch */ case   13:  		/* bl 45676 */
		/* 820F103Ch case   13:*/		regs.LR = 0x820F1040; return 0x820FC2A8;
		/* 820F103Ch case   13:*/		return 0x820F1040;
		  /* 820F1040h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820F1040h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F1040h case   14:*/		return 0x820F1044;
		  /* 820F1044h */ case   15:  		/* bc 4, CR0_EQ, 384 */
		/* 820F1044h case   15:*/		if ( !regs.CR[0].eq ) { return 0x820F11C4;  }
		/* 820F1044h case   15:*/		return 0x820F1048;
		  /* 820F1048h */ case   16:  		/* lwz R5, <#[R31 + 260]> */
		/* 820F1048h case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000104) );
		/* 820F1048h case   16:*/		return 0x820F104C;
		  /* 820F104Ch */ case   17:  		/* lis R11, 4352 */
		/* 820F104Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0x1100);
		/* 820F104Ch case   17:*/		return 0x820F1050;
		  /* 820F1050h */ case   18:  		/* lwz R10, <#[R5]> */
		/* 820F1050h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 820F1050h case   18:*/		return 0x820F1054;
		  /* 820F1054h */ case   19:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 820F1054h case   19:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 820F1054h case   19:*/		return 0x820F1058;
		  /* 820F1058h */ case   20:  		/* cmplw CR6, R10, R11 */
		/* 820F1058h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820F1058h case   20:*/		return 0x820F105C;
		  /* 820F105Ch */ case   21:  		/* bc 12, CR6_EQ, 360 */
		/* 820F105Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x820F11C4;  }
		/* 820F105Ch case   21:*/		return 0x820F1060;
		  /* 820F1060h */ case   22:  		/* mr R6, R29 */
		/* 820F1060h case   22:*/		regs.R6 = regs.R29;
		/* 820F1060h case   22:*/		return 0x820F1064;
		  /* 820F1064h */ case   23:  		/* mr R4, R24 */
		/* 820F1064h case   23:*/		regs.R4 = regs.R24;
		/* 820F1064h case   23:*/		return 0x820F1068;
		  /* 820F1068h */ case   24:  		/* mr R3, R31 */
		/* 820F1068h case   24:*/		regs.R3 = regs.R31;
		/* 820F1068h case   24:*/		return 0x820F106C;
		  /* 820F106Ch */ case   25:  		/* bl -52012 */
		/* 820F106Ch case   25:*/		regs.LR = 0x820F1070; return 0x820E4540;
		/* 820F106Ch case   25:*/		return 0x820F1070;
		  /* 820F1070h */ case   26:  		/* lwz R11, <#[R31 + 112]> */
		/* 820F1070h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820F1070h case   26:*/		return 0x820F1074;
		  /* 820F1074h */ case   27:  		/* rlwinm. R11, R11, 0, 4, 4 */
		/* 820F1074h case   27:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R11,regs.R11);
		/* 820F1074h case   27:*/		return 0x820F1078;
		  /* 820F1078h */ case   28:  		/* bc 12, CR0_EQ, 260 */
		/* 820F1078h case   28:*/		if ( regs.CR[0].eq ) { return 0x820F117C;  }
		/* 820F1078h case   28:*/		return 0x820F107C;
		  /* 820F107Ch */ case   29:  		/* lwz R6, <#[R31 + 260]> */
		/* 820F107Ch case   29:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000104) );
		/* 820F107Ch case   29:*/		return 0x820F1080;
		  /* 820F1080h */ case   30:  		/* lis R11, 20480 */
		/* 820F1080h case   30:*/		cpu::op::lis<0>(regs,&regs.R11,0x5000);
		/* 820F1080h case   30:*/		return 0x820F1084;
		  /* 820F1084h */ case   31:  		/* li R28, 0 */
		/* 820F1084h case   31:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820F1084h case   31:*/		return 0x820F1088;
		  /* 820F1088h */ case   32:  		/* li R30, 0 */
		/* 820F1088h case   32:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820F1088h case   32:*/		return 0x820F108C;
		  /* 820F108Ch */ case   33:  		/* lwz R10, <#[R6]> */
		/* 820F108Ch case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 820F108Ch case   33:*/		return 0x820F1090;
		  /* 820F1090h */ case   34:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 820F1090h case   34:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 820F1090h case   34:*/		return 0x820F1094;
		  /* 820F1094h */ case   35:  		/* cmplw CR6, R10, R11 */
		/* 820F1094h case   35:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820F1094h case   35:*/		return 0x820F1098;
		  /* 820F1098h */ case   36:  		/* bc 4, CR6_EQ, 8 */
		/* 820F1098h case   36:*/		if ( !regs.CR[6].eq ) { return 0x820F10A0;  }
		/* 820F1098h case   36:*/		return 0x820F109C;
		  /* 820F109Ch */ case   37:  		/* li R30, 1 */
		/* 820F109Ch case   37:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820F109Ch case   37:*/		return 0x820F10A0;
	}
	return 0x820F10A0;
} // Block from 820F1008h-820F10A0h (38 instructions)

//////////////////////////////////////////////////////
// Block at 820F10A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F10A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F10A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F10A0);
		  /* 820F10A0h */ case    0:  		/* lwz R11, <#[R6 + 12]> */
		/* 820F10A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x0000000C) );
		/* 820F10A0h case    0:*/		return 0x820F10A4;
		  /* 820F10A4h */ case    1:  		/* li R3, 0 */
		/* 820F10A4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F10A4h case    1:*/		return 0x820F10A8;
		  /* 820F10A8h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820F10A8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F10A8h case    2:*/		return 0x820F10AC;
		  /* 820F10ACh */ case    3:  		/* bc 4, CR6_GT, 144 */
		/* 820F10ACh case    3:*/		if ( !regs.CR[6].gt ) { return 0x820F113C;  }
		/* 820F10ACh case    3:*/		return 0x820F10B0;
		  /* 820F10B0h */ case    4:  		/* lwz R11, <#[R31 + 108]> */
		/* 820F10B0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F10B0h case    4:*/		return 0x820F10B4;
		  /* 820F10B4h */ case    5:  		/* li R9, 0 */
		/* 820F10B4h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F10B4h case    5:*/		return 0x820F10B8;
		  /* 820F10B8h */ case    6:  		/* lwz R10, <#[R31 + 260]> */
		/* 820F10B8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 820F10B8h case    6:*/		return 0x820F10BC;
		  /* 820F10BCh */ case    7:  		/* rlwinm R11, R11, 29, 0, 2 */
		/* 820F10BCh case    7:*/		cpu::op::rlwinm<0,29,0,2>(regs,&regs.R11,regs.R11);
		/* 820F10BCh case    7:*/		return 0x820F10C0;
		  /* 820F10C0h */ case    8:  		/* lwz R8, <#[R31 + 20]> */
		/* 820F10C0h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 820F10C0h case    8:*/		return 0x820F10C4;
		  /* 820F10C4h */ case    9:  		/* lwz R5, <#[R1 + 100]> */
		/* 820F10C4h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000064) );
		/* 820F10C4h case    9:*/		return 0x820F10C8;
		  /* 820F10C8h */ case   10:  		/* srawi R7, R11, 31 */
		/* 820F10C8h case   10:*/		cpu::op::srawi<0,31>(regs,&regs.R7,regs.R11);
		/* 820F10C8h case   10:*/		return 0x820F10CC;
		  /* 820F10CCh */ case   11:  		/* lwz R4, <#[R10 + 12]> */
		/* 820F10CCh case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F10CCh case   11:*/		return 0x820F10D0;
		  /* 820F10D0h */ case   12:  		/* lwz R11, <#[R6 + 16]> */
		/* 820F10D0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000010) );
		/* 820F10D0h case   12:*/		return 0x820F10D4;
		  /* 820F10D4h */ case   13:  		/* cmpwi CR6, R7, 0 */
		/* 820F10D4h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 820F10D4h case   13:*/		return 0x820F10D8;
		  /* 820F10D8h */ case   14:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F10D8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F10D8h case   14:*/		return 0x820F10DC;
		  /* 820F10DCh */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F10DCh case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F10DCh case   15:*/		return 0x820F10E0;
		  /* 820F10E0h */ case   16:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820F10E0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820F10E0h case   16:*/		return 0x820F10E4;
		  /* 820F10E4h */ case   17:  		/* bc 4, CR6_EQ, 48 */
		/* 820F10E4h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820F1114;  }
		/* 820F10E4h case   17:*/		return 0x820F10E8;
		  /* 820F10E8h */ case   18:  		/* lwz R10, <#[R11 + 4]> */
		/* 820F10E8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820F10E8h case   18:*/		return 0x820F10EC;
		  /* 820F10ECh */ case   19:  		/* lwz R22, <#[R1 + 80]> */
		/* 820F10ECh case   19:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 820F10ECh case   19:*/		return 0x820F10F0;
		  /* 820F10F0h */ case   20:  		/* cmplw CR6, R22, R10 */
		/* 820F10F0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R10);
		/* 820F10F0h case   20:*/		return 0x820F10F4;
		  /* 820F10F4h */ case   21:  		/* bc 4, CR6_EQ, 32 */
		/* 820F10F4h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820F1114;  }
		/* 820F10F4h case   21:*/		return 0x820F10F8;
		  /* 820F10F8h */ case   22:  		/* lwz R22, <#[R11 + 12]> */
		/* 820F10F8h case   22:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F10F8h case   22:*/		return 0x820F10FC;
		  /* 820F10FCh */ case   23:  		/* lwz R10, <#[R11 + 16]> */
		/* 820F10FCh case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820F10FCh case   23:*/		return 0x820F1100;
		  /* 820F1100h */ case   24:  		/* rlwinm R11, R22, 2, 0, 29 */
		/* 820F1100h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R22);
		/* 820F1100h case   24:*/		return 0x820F1104;
		  /* 820F1104h */ case   25:  		/* add R11, R11, R10 */
		/* 820F1104h case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820F1104h case   25:*/		return 0x820F1108;
		  /* 820F1108h */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F1108h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F1108h case   26:*/		return 0x820F110C;
		  /* 820F110Ch */ case   27:  		/* lwzx R11, <#[R11 + R5]> */
		/* 820F110Ch case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820F110Ch case   27:*/		return 0x820F1110;
		  /* 820F1110h */ case   28:  		/* b 8 */
		/* 820F1110h case   28:*/		return 0x820F1118;
		/* 820F1110h case   28:*/		return 0x820F1114;
	}
	return 0x820F1114;
} // Block from 820F10A0h-820F1114h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820F1114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1114);
		  /* 820F1114h */ case    0:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F1114h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F1114h case    0:*/		return 0x820F1118;
	}
	return 0x820F1118;
} // Block from 820F1114h-820F1118h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F1118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1118);
		  /* 820F1118h */ case    0:  		/* cmplwi CR6, R11, 3 */
		/* 820F1118h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820F1118h case    0:*/		return 0x820F111C;
		  /* 820F111Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820F111Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F1128;  }
		/* 820F111Ch case    1:*/		return 0x820F1120;
		  /* 820F1120h */ case    2:  		/* li R28, 1 */
		/* 820F1120h case    2:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820F1120h case    2:*/		return 0x820F1124;
		  /* 820F1124h */ case    3:  		/* b 8 */
		/* 820F1124h case    3:*/		return 0x820F112C;
		/* 820F1124h case    3:*/		return 0x820F1128;
	}
	return 0x820F1128;
} // Block from 820F1118h-820F1128h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F1128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1128);
		  /* 820F1128h */ case    0:  		/* li R30, 1 */
		/* 820F1128h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820F1128h case    0:*/		return 0x820F112C;
	}
	return 0x820F112C;
} // Block from 820F1128h-820F112Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F112Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F112C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F112C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F112C);
		  /* 820F112Ch */ case    0:  		/* addi R3, R3, 1 */
		/* 820F112Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820F112Ch case    0:*/		return 0x820F1130;
		  /* 820F1130h */ case    1:  		/* addi R9, R9, 4 */
		/* 820F1130h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F1130h case    1:*/		return 0x820F1134;
		  /* 820F1134h */ case    2:  		/* cmplw CR6, R3, R4 */
		/* 820F1134h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 820F1134h case    2:*/		return 0x820F1138;
		  /* 820F1138h */ case    3:  		/* bc 12, CR6_LT, -104 */
		/* 820F1138h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F10D0;  }
		/* 820F1138h case    3:*/		return 0x820F113C;
	}
	return 0x820F113C;
} // Block from 820F112Ch-820F113Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F113Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F113C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F113C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F113C);
		  /* 820F113Ch */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 820F113Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820F113Ch case    0:*/		return 0x820F1140;
		  /* 820F1140h */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 820F1140h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F1168;  }
		/* 820F1140h case    1:*/		return 0x820F1144;
		  /* 820F1144h */ case    2:  		/* li R9, 1 */
		/* 820F1144h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820F1144h case    2:*/		return 0x820F1148;
		  /* 820F1148h */ case    3:  		/* li R8, 0 */
		/* 820F1148h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F1148h case    3:*/		return 0x820F114C;
		  /* 820F114Ch */ case    4:  		/* mr R7, R29 */
		/* 820F114Ch case    4:*/		regs.R7 = regs.R29;
		/* 820F114Ch case    4:*/		return 0x820F1150;
		  /* 820F1150h */ case    5:  		/* mr R6, R24 */
		/* 820F1150h case    5:*/		regs.R6 = regs.R24;
		/* 820F1150h case    5:*/		return 0x820F1154;
		  /* 820F1154h */ case    6:  		/* mr R5, R26 */
		/* 820F1154h case    6:*/		regs.R5 = regs.R26;
		/* 820F1154h case    6:*/		return 0x820F1158;
		  /* 820F1158h */ case    7:  		/* addi R4, R1, 80 */
		/* 820F1158h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F1158h case    7:*/		return 0x820F115C;
		  /* 820F115Ch */ case    8:  		/* mr R3, R31 */
		/* 820F115Ch case    8:*/		regs.R3 = regs.R31;
		/* 820F115Ch case    8:*/		return 0x820F1160;
		  /* 820F1160h */ case    9:  		/* bl -1896 */
		/* 820F1160h case    9:*/		regs.LR = 0x820F1164; return 0x820F09F8;
		/* 820F1160h case    9:*/		return 0x820F1164;
		  /* 820F1164h */ case   10:  		/* b 56 */
		/* 820F1164h case   10:*/		return 0x820F119C;
		/* 820F1164h case   10:*/		return 0x820F1168;
	}
	return 0x820F1168;
} // Block from 820F113Ch-820F1168h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F1168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1168);
		  /* 820F1168h */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 820F1168h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820F1168h case    0:*/		return 0x820F116C;
		  /* 820F116Ch */ case    1:  		/* bc 4, CR6_EQ, 88 */
		/* 820F116Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F11C4;  }
		/* 820F116Ch case    1:*/		return 0x820F1170;
		  /* 820F1170h */ case    2:  		/* li R9, 0 */
		/* 820F1170h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F1170h case    2:*/		return 0x820F1174;
		  /* 820F1174h */ case    3:  		/* li R8, 1 */
		/* 820F1174h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F1174h case    3:*/		return 0x820F1178;
		  /* 820F1178h */ case    4:  		/* b -44 */
		/* 820F1178h case    4:*/		return 0x820F114C;
		/* 820F1178h case    4:*/		return 0x820F117C;
	}
	return 0x820F117C;
} // Block from 820F1168h-820F117Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F117Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F117C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F117C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F117C);
		  /* 820F117Ch */ case    0:  		/* mr R9, R23 */
		/* 820F117Ch case    0:*/		regs.R9 = regs.R23;
		/* 820F117Ch case    0:*/		return 0x820F1180;
		  /* 820F1180h */ case    1:  		/* mr R8, R29 */
		/* 820F1180h case    1:*/		regs.R8 = regs.R29;
		/* 820F1180h case    1:*/		return 0x820F1184;
		  /* 820F1184h */ case    2:  		/* mr R7, R24 */
		/* 820F1184h case    2:*/		regs.R7 = regs.R24;
		/* 820F1184h case    2:*/		return 0x820F1188;
		  /* 820F1188h */ case    3:  		/* mr R6, R26 */
		/* 820F1188h case    3:*/		regs.R6 = regs.R26;
		/* 820F1188h case    3:*/		return 0x820F118C;
		  /* 820F118Ch */ case    4:  		/* addi R5, R1, 192 */
		/* 820F118Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xC0);
		/* 820F118Ch case    4:*/		return 0x820F1190;
		  /* 820F1190h */ case    5:  		/* addi R4, R1, 80 */
		/* 820F1190h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F1190h case    5:*/		return 0x820F1194;
		  /* 820F1194h */ case    6:  		/* mr R3, R31 */
		/* 820F1194h case    6:*/		regs.R3 = regs.R31;
		/* 820F1194h case    6:*/		return 0x820F1198;
	}
	return 0x820F1198;
} // Block from 820F117Ch-820F1198h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F1198h
// Function '?Reschedule_FindCoissue@CShaderProgram@D3DXShader@@AAAJPAU_D3DXCP_DATA@2@PAPAVCInstruction@2@1IHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1198);
		  /* 820F1198h */ case    0:  		/* bl -1328 */
		/* 820F1198h case    0:*/		regs.LR = 0x820F119C; return 0x820F0C68;
		/* 820F1198h case    0:*/		return 0x820F119C;
	}
	return 0x820F119C;
} // Block from 820F1198h-820F119Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F119Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F119C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F119C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F119C);
		  /* 820F119Ch */ case    0:  		/* or. R30, R3, R3 */
		/* 820F119Ch case    0:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F119Ch case    0:*/		return 0x820F11A0;
		  /* 820F11A0h */ case    1:  		/* bc 12, CR0_LT, 52 */
		/* 820F11A0h case    1:*/		if ( regs.CR[0].lt ) { return 0x820F11D4;  }
		/* 820F11A0h case    1:*/		return 0x820F11A4;
		  /* 820F11A4h */ case    2:  		/* cmpwi CR6, R30, 0 */
		/* 820F11A4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820F11A4h case    2:*/		return 0x820F11A8;
		  /* 820F11A8h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 820F11A8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820F11C4;  }
		/* 820F11A8h case    3:*/		return 0x820F11AC;
		  /* 820F11ACh */ case    4:  		/* mr R5, R25 */
		/* 820F11ACh case    4:*/		regs.R5 = regs.R25;
		/* 820F11ACh case    4:*/		return 0x820F11B0;
		  /* 820F11B0h */ case    5:  		/* lwz R4, <#[R31 + 24]> */
		/* 820F11B0h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820F11B0h case    5:*/		return 0x820F11B4;
		  /* 820F11B4h */ case    6:  		/* mr R3, R26 */
		/* 820F11B4h case    6:*/		regs.R3 = regs.R26;
		/* 820F11B4h case    6:*/		return 0x820F11B8;
		  /* 820F11B8h */ case    7:  		/* addi R29, R29, -1 */
		/* 820F11B8h case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820F11B8h case    7:*/		return 0x820F11BC;
		  /* 820F11BCh */ case    8:  		/* addi R27, R27, -4 */
		/* 820F11BCh case    8:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0xFFFFFFFC);
		/* 820F11BCh case    8:*/		return 0x820F11C0;
		  /* 820F11C0h */ case    9:  		/* bl -391184 */
		/* 820F11C0h case    9:*/		regs.LR = 0x820F11C4; return 0x820919B0;
		/* 820F11C0h case    9:*/		return 0x820F11C4;
	}
	return 0x820F11C4;
} // Block from 820F119Ch-820F11C4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F11C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F11C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F11C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F11C4);
		  /* 820F11C4h */ case    0:  		/* addic. R29, R29, -1 */
		/* 820F11C4h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820F11C4h case    0:*/		return 0x820F11C8;
		  /* 820F11C8h */ case    1:  		/* addi R27, R27, -4 */
		/* 820F11C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0xFFFFFFFC);
		/* 820F11C8h case    1:*/		return 0x820F11CC;
		  /* 820F11CCh */ case    2:  		/* bc 4, CR0_LT, -440 */
		/* 820F11CCh case    2:*/		if ( !regs.CR[0].lt ) { return 0x820F1014;  }
		/* 820F11CCh case    2:*/		return 0x820F11D0;
	}
	return 0x820F11D0;
} // Block from 820F11C4h-820F11D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F11D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F11D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F11D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F11D0);
		  /* 820F11D0h */ case    0:  		/* li R30, 0 */
		/* 820F11D0h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820F11D0h case    0:*/		return 0x820F11D4;
	}
	return 0x820F11D4;
} // Block from 820F11D0h-820F11D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F11D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F11D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F11D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F11D4);
		  /* 820F11D4h */ case    0:  		/* lwz R11, <#[R31 + 108]> */
		/* 820F11D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F11D4h case    0:*/		return 0x820F11D8;
		  /* 820F11D8h */ case    1:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820F11D8h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820F11D8h case    1:*/		return 0x820F11DC;
		  /* 820F11DCh */ case    2:  		/* bc 4, CR0_EQ, 40 */
		/* 820F11DCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x820F1204;  }
		/* 820F11DCh case    2:*/		return 0x820F11E0;
		  /* 820F11E0h */ case    3:  		/* addi R4, R1, 80 */
		/* 820F11E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F11E0h case    3:*/		return 0x820F11E4;
		  /* 820F11E4h */ case    4:  		/* mr R3, R31 */
		/* 820F11E4h case    4:*/		regs.R3 = regs.R31;
		/* 820F11E4h case    4:*/		return 0x820F11E8;
		  /* 820F11E8h */ case    5:  		/* bl 84136 */
		/* 820F11E8h case    5:*/		regs.LR = 0x820F11EC; return 0x82105A90;
		/* 820F11E8h case    5:*/		return 0x820F11EC;
		  /* 820F11ECh */ case    6:  		/* lwz R11, <#[R31 + 48]> */
		/* 820F11ECh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820F11ECh case    6:*/		return 0x820F11F0;
		  /* 820F11F0h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820F11F0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F11F0h case    7:*/		return 0x820F11F4;
		  /* 820F11F4h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 820F11F4h case    8:*/		if ( regs.CR[6].eq ) { return 0x820F1204;  }
		/* 820F11F4h case    8:*/		return 0x820F11F8;
		  /* 820F11F8h */ case    9:  		/* addi R4, R1, 192 */
		/* 820F11F8h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xC0);
		/* 820F11F8h case    9:*/		return 0x820F11FC;
		  /* 820F11FCh */ case   10:  		/* mr R3, R31 */
		/* 820F11FCh case   10:*/		regs.R3 = regs.R31;
		/* 820F11FCh case   10:*/		return 0x820F1200;
		  /* 820F1200h */ case   11:  		/* bl 84112 */
		/* 820F1200h case   11:*/		regs.LR = 0x820F1204; return 0x82105A90;
		/* 820F1200h case   11:*/		return 0x820F1204;
	}
	return 0x820F1204;
} // Block from 820F11D4h-820F1204h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F1204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1204);
		  /* 820F1204h */ case    0:  		/* lis R4, 9345 */
		/* 820F1204h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F1204h case    0:*/		return 0x820F1208;
		  /* 820F1208h */ case    1:  		/* mr R3, R24 */
		/* 820F1208h case    1:*/		regs.R3 = regs.R24;
		/* 820F1208h case    1:*/		return 0x820F120C;
		  /* 820F120Ch */ case    2:  		/* bl -429780 */
		/* 820F120Ch case    2:*/		regs.LR = 0x820F1210; return 0x82088338;
		/* 820F120Ch case    2:*/		return 0x820F1210;
		  /* 820F1210h */ case    3:  		/* lis R4, 9345 */
		/* 820F1210h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F1210h case    3:*/		return 0x820F1214;
		  /* 820F1214h */ case    4:  		/* mr R3, R26 */
		/* 820F1214h case    4:*/		regs.R3 = regs.R26;
		/* 820F1214h case    4:*/		return 0x820F1218;
		  /* 820F1218h */ case    5:  		/* bl -429792 */
		/* 820F1218h case    5:*/		regs.LR = 0x820F121C; return 0x82088338;
		/* 820F1218h case    5:*/		return 0x820F121C;
		  /* 820F121Ch */ case    6:  		/* mr R3, R30 */
		/* 820F121Ch case    6:*/		regs.R3 = regs.R30;
		/* 820F121Ch case    6:*/		return 0x820F1220;
	}
	return 0x820F1220;
} // Block from 820F1204h-820F1220h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F1220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1220);
		  /* 820F1220h */ case    0:  		/* addi R1, R1, 384 */
		/* 820F1220h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x180);
		/* 820F1220h case    0:*/		return 0x820F1224;
		  /* 820F1224h */ case    1:  		/* b -393108 */
		/* 820F1224h case    1:*/		return 0x82091290;
		/* 820F1224h case    1:*/		return 0x820F1228;
	}
	return 0x820F1228;
} // Block from 820F1220h-820F1228h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F1228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1228);
		  /* 820F1228h */ case    0:  		/* mfspr R12, LR */
		/* 820F1228h case    0:*/		regs.R12 = regs.LR;
		/* 820F1228h case    0:*/		return 0x820F122C;
		  /* 820F122Ch */ case    1:  		/* bl -393196 */
		/* 820F122Ch case    1:*/		regs.LR = 0x820F1230; return 0x82091240;
		/* 820F122Ch case    1:*/		return 0x820F1230;
		  /* 820F1230h */ case    2:  		/* stfd FR31, <#[R1 - 96]> */
		/* 820F1230h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 820F1230h case    2:*/		return 0x820F1234;
		  /* 820F1234h */ case    3:  		/* stwu R1, <#[R1 - 480]> */
		/* 820F1234h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE20);
		/* 820F1234h case    3:*/		return 0x820F1238;
		  /* 820F1238h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 820F1238h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820F1238h case    4:*/		return 0x820F123C;
		  /* 820F123Ch */ case    5:  		/* li R30, 0 */
		/* 820F123Ch case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820F123Ch case    5:*/		return 0x820F1240;
		  /* 820F1240h */ case    6:  		/* mr R31, R3 */
		/* 820F1240h case    6:*/		regs.R31 = regs.R3;
		/* 820F1240h case    6:*/		return 0x820F1244;
		  /* 820F1244h */ case    7:  		/* li R26, -1 */
		/* 820F1244h case    7:*/		cpu::op::li<0>(regs,&regs.R26,0xFFFFFFFF);
		/* 820F1244h case    7:*/		return 0x820F1248;
		  /* 820F1248h */ case    8:  		/* stw R30, <#[R1 + 112]> */
		/* 820F1248h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000070) );
		/* 820F1248h case    8:*/		return 0x820F124C;
		  /* 820F124Ch */ case    9:  		/* mr R10, R30 */
		/* 820F124Ch case    9:*/		regs.R10 = regs.R30;
		/* 820F124Ch case    9:*/		return 0x820F1250;
		  /* 820F1250h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 820F1250h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F1250h case   10:*/		return 0x820F1254;
		  /* 820F1254h */ case   11:  		/* bc 4, CR6_GT, 52 */
		/* 820F1254h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820F1288;  }
		/* 820F1254h case   11:*/		return 0x820F1258;
		  /* 820F1258h */ case   12:  		/* mr R11, R30 */
		/* 820F1258h case   12:*/		regs.R11 = regs.R30;
		/* 820F1258h case   12:*/		return 0x820F125C;
		  /* 820F125Ch */ case   13:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F125Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F125Ch case   13:*/		return 0x820F1260;
		  /* 820F1260h */ case   14:  		/* addi R10, R10, 1 */
		/* 820F1260h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F1260h case   14:*/		return 0x820F1264;
		  /* 820F1264h */ case   15:  		/* lwzx R9, <#[R11 + R9]> */
		/* 820F1264h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F1264h case   15:*/		return 0x820F1268;
		  /* 820F1268h */ case   16:  		/* stw R26, <#[R9 + 48]> */
		/* 820F1268h case   16:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R9 + 0x00000030) );
		/* 820F1268h case   16:*/		return 0x820F126C;
		  /* 820F126Ch */ case   17:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F126Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F126Ch case   17:*/		return 0x820F1270;
		  /* 820F1270h */ case   18:  		/* lwzx R9, <#[R11 + R9]> */
		/* 820F1270h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F1270h case   18:*/		return 0x820F1274;
		  /* 820F1274h */ case   19:  		/* addi R11, R11, 4 */
		/* 820F1274h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F1274h case   19:*/		return 0x820F1278;
		  /* 820F1278h */ case   20:  		/* stw R26, <#[R9 + 52]> */
		/* 820F1278h case   20:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R9 + 0x00000034) );
		/* 820F1278h case   20:*/		return 0x820F127C;
		  /* 820F127Ch */ case   21:  		/* lwz R9, <#[R31 + 8]> */
		/* 820F127Ch case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820F127Ch case   21:*/		return 0x820F1280;
		  /* 820F1280h */ case   22:  		/* cmplw CR6, R10, R9 */
		/* 820F1280h case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F1280h case   22:*/		return 0x820F1284;
		  /* 820F1284h */ case   23:  		/* bc 12, CR6_LT, -40 */
		/* 820F1284h case   23:*/		if ( regs.CR[6].lt ) { return 0x820F125C;  }
		/* 820F1284h case   23:*/		return 0x820F1288;
	}
	return 0x820F1288;
} // Block from 820F1228h-820F1288h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F1288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1288);
		  /* 820F1288h */ case    0:  		/* lwz R29, <#[R31 + 12]> */
		/* 820F1288h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F1288h case    0:*/		return 0x820F128C;
		  /* 820F128Ch */ case    1:  		/* li R11, 1 */
		/* 820F128Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820F128Ch case    1:*/		return 0x820F1290;
		  /* 820F1290h */ case    2:  		/* li R9, 0 */
		/* 820F1290h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F1290h case    2:*/		return 0x820F1294;
		  /* 820F1294h */ case    3:  		/* stw R30, <#[R1 + 108]> */
		/* 820F1294h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000006C) );
		/* 820F1294h case    3:*/		return 0x820F1298;
		  /* 820F1298h */ case    4:  		/* li R8, 0 */
		/* 820F1298h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F1298h case    4:*/		return 0x820F129C;
		  /* 820F129Ch */ case    5:  		/* stw R30, <#[R1 + 100]> */
		/* 820F129Ch case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 820F129Ch case    5:*/		return 0x820F12A0;
		  /* 820F12A0h */ case    6:  		/* mr R10, R29 */
		/* 820F12A0h case    6:*/		regs.R10 = regs.R29;
		/* 820F12A0h case    6:*/		return 0x820F12A4;
		  /* 820F12A4h */ case    7:  		/* stw R30, <#[R1 + 92]> */
		/* 820F12A4h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F12A4h case    7:*/		return 0x820F12A8;
		  /* 820F12A8h */ case    8:  		/* li R7, 0 */
		/* 820F12A8h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F12A8h case    8:*/		return 0x820F12AC;
		  /* 820F12ACh */ case    9:  		/* stw R11, <#[R1 + 84]> */
		/* 820F12ACh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820F12ACh case    9:*/		return 0x820F12B0;
		  /* 820F12B0h */ case   10:  		/* addi R6, R1, 112 */
		/* 820F12B0h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 820F12B0h case   10:*/		return 0x820F12B4;
		  /* 820F12B4h */ case   11:  		/* li R5, 1 */
		/* 820F12B4h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820F12B4h case   11:*/		return 0x820F12B8;
		  /* 820F12B8h */ case   12:  		/* mr R4, R26 */
		/* 820F12B8h case   12:*/		regs.R4 = regs.R26;
		/* 820F12B8h case   12:*/		return 0x820F12BC;
		  /* 820F12BCh */ case   13:  		/* mr R3, R31 */
		/* 820F12BCh case   13:*/		regs.R3 = regs.R31;
		/* 820F12BCh case   13:*/		return 0x820F12C0;
		  /* 820F12C0h */ case   14:  		/* bl -23368 */
		/* 820F12C0h case   14:*/		regs.LR = 0x820F12C4; return 0x820EB778;
		/* 820F12C0h case   14:*/		return 0x820F12C4;
		  /* 820F12C4h */ case   15:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F12C4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F12C4h case   15:*/		return 0x820F12C8;
		  /* 820F12C8h */ case   16:  		/* mr R9, R30 */
		/* 820F12C8h case   16:*/		regs.R9 = regs.R30;
		/* 820F12C8h case   16:*/		return 0x820F12CC;
		  /* 820F12CCh */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 820F12CCh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F12CCh case   17:*/		return 0x820F12D0;
		  /* 820F12D0h */ case   18:  		/* bc 4, CR6_GT, 112 */
		/* 820F12D0h case   18:*/		if ( !regs.CR[6].gt ) { return 0x820F1340;  }
		/* 820F12D0h case   18:*/		return 0x820F12D4;
		  /* 820F12D4h */ case   19:  		/* mr R11, R30 */
		/* 820F12D4h case   19:*/		regs.R11 = regs.R30;
		/* 820F12D4h case   19:*/		return 0x820F12D8;
		  /* 820F12D8h */ case   20:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F12D8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F12D8h case   20:*/		return 0x820F12DC;
		  /* 820F12DCh */ case   21:  		/* lwzx R8, <#[R11 + R10]> */
		/* 820F12DCh case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F12DCh case   21:*/		return 0x820F12E0;
		  /* 820F12E0h */ case   22:  		/* lwz R7, <#[R8 + 48]> */
		/* 820F12E0h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000030) );
		/* 820F12E0h case   22:*/		return 0x820F12E4;
		  /* 820F12E4h */ case   23:  		/* cmpwi CR6, R7, -1 */
		/* 820F12E4h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 820F12E4h case   23:*/		return 0x820F12E8;
		  /* 820F12E8h */ case   24:  		/* bc 4, CR6_EQ, 16 */
		/* 820F12E8h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820F12F8;  }
		/* 820F12E8h case   24:*/		return 0x820F12EC;
		  /* 820F12ECh */ case   25:  		/* lwz R8, <#[R8 + 52]> */
		/* 820F12ECh case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000034) );
		/* 820F12ECh case   25:*/		return 0x820F12F0;
		  /* 820F12F0h */ case   26:  		/* cmpwi CR6, R8, -1 */
		/* 820F12F0h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 820F12F0h case   26:*/		return 0x820F12F4;
		  /* 820F12F4h */ case   27:  		/* bc 12, CR6_EQ, 32 */
		/* 820F12F4h case   27:*/		if ( regs.CR[6].eq ) { return 0x820F1314;  }
		/* 820F12F4h case   27:*/		return 0x820F12F8;
	}
	return 0x820F12F8;
} // Block from 820F1288h-820F12F8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820F12F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F12F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F12F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F12F8);
		  /* 820F12F8h */ case    0:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820F12F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F12F8h case    0:*/		return 0x820F12FC;
		  /* 820F12FCh */ case    1:  		/* lwz R8, <#[R10 + 48]> */
		/* 820F12FCh case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000030) );
		/* 820F12FCh case    1:*/		return 0x820F1300;
		  /* 820F1300h */ case    2:  		/* stw R8, <#[R10 + 20]> */
		/* 820F1300h case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000014) );
		/* 820F1300h case    2:*/		return 0x820F1304;
		  /* 820F1304h */ case    3:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F1304h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1304h case    3:*/		return 0x820F1308;
		  /* 820F1308h */ case    4:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820F1308h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F1308h case    4:*/		return 0x820F130C;
		  /* 820F130Ch */ case    5:  		/* lwz R8, <#[R10 + 52]> */
		/* 820F130Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000034) );
		/* 820F130Ch case    5:*/		return 0x820F1310;
		  /* 820F1310h */ case    6:  		/* stw R8, <#[R10 + 24]> */
		/* 820F1310h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000018) );
		/* 820F1310h case    6:*/		return 0x820F1314;
	}
	return 0x820F1314;
} // Block from 820F12F8h-820F1314h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F1314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1314);
		  /* 820F1314h */ case    0:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F1314h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1314h case    0:*/		return 0x820F1318;
		  /* 820F1318h */ case    1:  		/* addi R9, R9, 1 */
		/* 820F1318h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F1318h case    1:*/		return 0x820F131C;
		  /* 820F131Ch */ case    2:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820F131Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F131Ch case    2:*/		return 0x820F1320;
		  /* 820F1320h */ case    3:  		/* stw R26, <#[R10 + 48]> */
		/* 820F1320h case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R10 + 0x00000030) );
		/* 820F1320h case    3:*/		return 0x820F1324;
		  /* 820F1324h */ case    4:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F1324h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1324h case    4:*/		return 0x820F1328;
		  /* 820F1328h */ case    5:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820F1328h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F1328h case    5:*/		return 0x820F132C;
		  /* 820F132Ch */ case    6:  		/* addi R11, R11, 4 */
		/* 820F132Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F132Ch case    6:*/		return 0x820F1330;
		  /* 820F1330h */ case    7:  		/* stw R26, <#[R10 + 52]> */
		/* 820F1330h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R10 + 0x00000034) );
		/* 820F1330h case    7:*/		return 0x820F1334;
		  /* 820F1334h */ case    8:  		/* lwz R10, <#[R31 + 8]> */
		/* 820F1334h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820F1334h case    8:*/		return 0x820F1338;
		  /* 820F1338h */ case    9:  		/* cmplw CR6, R9, R10 */
		/* 820F1338h case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820F1338h case    9:*/		return 0x820F133C;
		  /* 820F133Ch */ case   10:  		/* bc 12, CR6_LT, -100 */
		/* 820F133Ch case   10:*/		if ( regs.CR[6].lt ) { return 0x820F12D8;  }
		/* 820F133Ch case   10:*/		return 0x820F1340;
	}
	return 0x820F1340;
} // Block from 820F1314h-820F1340h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F1340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1340);
		  /* 820F1340h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820F1340h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820F1340h case    0:*/		return 0x820F1344;
		  /* 820F1344h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820F1344h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F1364;  }
		/* 820F1344h case    1:*/		return 0x820F1348;
		  /* 820F1348h */ case    2:  		/* mtspr CTR, R29 */
		/* 820F1348h case    2:*/		regs.CTR = regs.R29;
		/* 820F1348h case    2:*/		return 0x820F134C;
		  /* 820F134Ch */ case    3:  		/* mr R11, R30 */
		/* 820F134Ch case    3:*/		regs.R11 = regs.R30;
		/* 820F134Ch case    3:*/		return 0x820F1350;
		  /* 820F1350h */ case    4:  		/* lwz R10, <#[R31 + 24]> */
		/* 820F1350h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820F1350h case    4:*/		return 0x820F1354;
		  /* 820F1354h */ case    5:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820F1354h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F1354h case    5:*/		return 0x820F1358;
		  /* 820F1358h */ case    6:  		/* addi R11, R11, 4 */
		/* 820F1358h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F1358h case    6:*/		return 0x820F135C;
		  /* 820F135Ch */ case    7:  		/* stw R30, <#[R10]> */
		/* 820F135Ch case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00000000) );
		/* 820F135Ch case    7:*/		return 0x820F1360;
		  /* 820F1360h */ case    8:  		/* bc 16, CR0_LT, -16 */
		/* 820F1360h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F1350;  }
		/* 820F1360h case    8:*/		return 0x820F1364;
	}
	return 0x820F1364;
} // Block from 820F1340h-820F1364h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F1364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1364);
		  /* 820F1364h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820F1364h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F1364h case    0:*/		return 0x820F1368;
		  /* 820F1368h */ case    1:  		/* bc 12, CR6_LT, 760 */
		/* 820F1368h case    1:*/		if ( regs.CR[6].lt ) { return 0x820F1660;  }
		/* 820F1368h case    1:*/		return 0x820F136C;
		  /* 820F136Ch */ case    2:  		/* stw R30, <#[R31 + 256]> */
		/* 820F136Ch case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000100) );
		/* 820F136Ch case    2:*/		return 0x820F1370;
		  /* 820F1370h */ case    3:  		/* li R7, 0 */
		/* 820F1370h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F1370h case    3:*/		return 0x820F1374;
		  /* 820F1374h */ case    4:  		/* li R6, 0 */
		/* 820F1374h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F1374h case    4:*/		return 0x820F1378;
		  /* 820F1378h */ case    5:  		/* addi R5, R1, 128 */
		/* 820F1378h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 820F1378h case    5:*/		return 0x820F137C;
		  /* 820F137Ch */ case    6:  		/* addi R4, R1, 256 */
		/* 820F137Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x100);
		/* 820F137Ch case    6:*/		return 0x820F1380;
		  /* 820F1380h */ case    7:  		/* mr R3, R31 */
		/* 820F1380h case    7:*/		regs.R3 = regs.R31;
		/* 820F1380h case    7:*/		return 0x820F1384;
		  /* 820F1384h */ case    8:  		/* bl -26988 */
		/* 820F1384h case    8:*/		regs.LR = 0x820F1388; return 0x820EAA18;
		/* 820F1384h case    8:*/		return 0x820F1388;
		  /* 820F1388h */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 820F1388h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F1388h case    9:*/		return 0x820F138C;
		  /* 820F138Ch */ case   10:  		/* mr R22, R30 */
		/* 820F138Ch case   10:*/		regs.R22 = regs.R30;
		/* 820F138Ch case   10:*/		return 0x820F1390;
		  /* 820F1390h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 820F1390h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F1390h case   11:*/		return 0x820F1394;
		  /* 820F1394h */ case   12:  		/* bc 4, CR6_GT, 700 */
		/* 820F1394h case   12:*/		if ( !regs.CR[6].gt ) { return 0x820F1650;  }
		/* 820F1394h case   12:*/		return 0x820F1398;
		  /* 820F1398h */ case   13:  		/* lis R9, -32256 */
		/* 820F1398h case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 820F1398h case   13:*/		return 0x820F139C;
		  /* 820F139Ch */ case   14:  		/* lis R11, -32255 */
		/* 820F139Ch case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820F139Ch case   14:*/		return 0x820F13A0;
		  /* 820F13A0h */ case   15:  		/* lis R10, -32255 */
		/* 820F13A0h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820F13A0h case   15:*/		return 0x820F13A4;
		  /* 820F13A4h */ case   16:  		/* mr R25, R30 */
		/* 820F13A4h case   16:*/		regs.R25 = regs.R30;
		/* 820F13A4h case   16:*/		return 0x820F13A8;
		  /* 820F13A8h */ case   17:  		/* addi R24, R11, -8780 */
		/* 820F13A8h case   17:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0xFFFFDDB4);
		/* 820F13A8h case   17:*/		return 0x820F13AC;
		  /* 820F13ACh */ case   18:  		/* lfd FR31, <#[R9 + 1808]> */
		/* 820F13ACh case   18:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R9 + 0x00000710) );
		/* 820F13ACh case   18:*/		return 0x820F13B0;
		  /* 820F13B0h */ case   19:  		/* addi R23, R10, -8800 */
		/* 820F13B0h case   19:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0xFFFFDDA0);
		/* 820F13B0h case   19:*/		return 0x820F13B4;
		  /* 820F13B4h */ case   20:  		/* lwz R11, <#[R31 + 24]> */
		/* 820F13B4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820F13B4h case   20:*/		return 0x820F13B8;
		  /* 820F13B8h */ case   21:  		/* lwzx R30, <#[R25 + R11]> */
		/* 820F13B8h case   21:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R25 + regs.R11 + 0x00000000) );
		/* 820F13B8h case   21:*/		return 0x820F13BC;
		  /* 820F13BCh */ case   22:  		/* lwz R11, <#[R30]> */
		/* 820F13BCh case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F13BCh case   22:*/		return 0x820F13C0;
		  /* 820F13C0h */ case   23:  		/* rlwinm R10, R11, 0, 12, 31 */
		/* 820F13C0h case   23:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R10,regs.R11);
		/* 820F13C0h case   23:*/		return 0x820F13C4;
		  /* 820F13C4h */ case   24:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820F13C4h case   24:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820F13C4h case   24:*/		return 0x820F13C8;
		  /* 820F13C8h */ case   25:  		/* cmplwi CR6, R10, 1 */
		/* 820F13C8h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820F13C8h case   25:*/		return 0x820F13CC;
		  /* 820F13CCh */ case   26:  		/* bc 4, CR6_EQ, 624 */
		/* 820F13CCh case   26:*/		if ( !regs.CR[6].eq ) { return 0x820F163C;  }
		/* 820F13CCh case   26:*/		return 0x820F13D0;
		  /* 820F13D0h */ case   27:  		/* lis R10, 29440 */
		/* 820F13D0h case   27:*/		cpu::op::lis<0>(regs,&regs.R10,0x7300);
		/* 820F13D0h case   27:*/		return 0x820F13D4;
		  /* 820F13D4h */ case   28:  		/* stw R26, <#[R1 + 112]> */
		/* 820F13D4h case   28:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000070) );
		/* 820F13D4h case   28:*/		return 0x820F13D8;
		  /* 820F13D8h */ case   29:  		/* stw R26, <#[R1 + 116]> */
		/* 820F13D8h case   29:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000074) );
		/* 820F13D8h case   29:*/		return 0x820F13DC;
		  /* 820F13DCh */ case   30:  		/* cmplw CR6, R11, R10 */
		/* 820F13DCh case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F13DCh case   30:*/		return 0x820F13E0;
		  /* 820F13E0h */ case   31:  		/* bc 12, CR6_EQ, 508 */
		/* 820F13E0h case   31:*/		if ( regs.CR[6].eq ) { return 0x820F15DC;  }
		/* 820F13E0h case   31:*/		return 0x820F13E4;
		  /* 820F13E4h */ case   32:  		/* lis R10, 29472 */
		/* 820F13E4h case   32:*/		cpu::op::lis<0>(regs,&regs.R10,0x7320);
		/* 820F13E4h case   32:*/		return 0x820F13E8;
		  /* 820F13E8h */ case   33:  		/* cmplw CR6, R11, R10 */
		/* 820F13E8h case   33:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F13E8h case   33:*/		return 0x820F13EC;
		  /* 820F13ECh */ case   34:  		/* bc 12, CR6_EQ, 496 */
		/* 820F13ECh case   34:*/		if ( regs.CR[6].eq ) { return 0x820F15DC;  }
		/* 820F13ECh case   34:*/		return 0x820F13F0;
		  /* 820F13F0h */ case   35:  		/* lis R10, 29456 */
		/* 820F13F0h case   35:*/		cpu::op::lis<0>(regs,&regs.R10,0x7310);
		/* 820F13F0h case   35:*/		return 0x820F13F4;
		  /* 820F13F4h */ case   36:  		/* cmplw CR6, R11, R10 */
		/* 820F13F4h case   36:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F13F4h case   36:*/		return 0x820F13F8;
		  /* 820F13F8h */ case   37:  		/* bc 12, CR6_EQ, 484 */
		/* 820F13F8h case   37:*/		if ( regs.CR[6].eq ) { return 0x820F15DC;  }
		/* 820F13F8h case   37:*/		return 0x820F13FC;
		  /* 820F13FCh */ case   38:  		/* lis R10, 29488 */
		/* 820F13FCh case   38:*/		cpu::op::lis<0>(regs,&regs.R10,0x7330);
		/* 820F13FCh case   38:*/		return 0x820F1400;
		  /* 820F1400h */ case   39:  		/* cmplw CR6, R11, R10 */
		/* 820F1400h case   39:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F1400h case   39:*/		return 0x820F1404;
		  /* 820F1404h */ case   40:  		/* bc 12, CR6_EQ, 472 */
		/* 820F1404h case   40:*/		if ( regs.CR[6].eq ) { return 0x820F15DC;  }
		/* 820F1404h case   40:*/		return 0x820F1408;
	}
	return 0x820F1408;
} // Block from 820F1364h-820F1408h (41 instructions)

//////////////////////////////////////////////////////
// Block at 820F1408h
// Function '?Reschedule_FindPair@CShaderProgram@D3DXShader@@AAAJPAU_D3DXCP_DATA@2@0PAPAVCInstruction@2@1IH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1408);
		  /* 820F1408h */ case    0:  		/* lis R10, 29616 */
		/* 820F1408h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x73B0);
		/* 820F1408h case    0:*/		return 0x820F140C;
		  /* 820F140Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820F140Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F140Ch case    1:*/		return 0x820F1410;
		  /* 820F1410h */ case    2:  		/* bc 4, CR6_EQ, 216 */
		/* 820F1410h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F14E8;  }
		/* 820F1410h case    2:*/		return 0x820F1414;
		  /* 820F1414h */ case    3:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F1414h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F1414h case    3:*/		return 0x820F1418;
		  /* 820F1418h */ case    4:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F1418h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1418h case    4:*/		return 0x820F141C;
		  /* 820F141Ch */ case    5:  		/* lwz R9, <#[R31 + 16]> */
		/* 820F141Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820F141Ch case    5:*/		return 0x820F1420;
		  /* 820F1420h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F1420h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F1420h case    6:*/		return 0x820F1424;
		  /* 820F1424h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F1424h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F1424h case    7:*/		return 0x820F1428;
		  /* 820F1428h */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F1428h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F1428h case    8:*/		return 0x820F142C;
		  /* 820F142Ch */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 820F142Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820F142Ch case    9:*/		return 0x820F1430;
		  /* 820F1430h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F1430h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F1430h case   10:*/		return 0x820F1434;
		  /* 820F1434h */ case   11:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820F1434h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F1434h case   11:*/		return 0x820F1438;
		  /* 820F1438h */ case   12:  		/* lwz R10, <#[R10 + 4]> */
		/* 820F1438h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820F1438h case   12:*/		return 0x820F143C;
		  /* 820F143Ch */ case   13:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 820F143Ch case   13:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 820F143Ch case   13:*/		return 0x820F1440;
		  /* 820F1440h */ case   14:  		/* bc 12, CR0_EQ, 508 */
		/* 820F1440h case   14:*/		if ( regs.CR[0].eq ) { return 0x820F163C;  }
		/* 820F1440h case   14:*/		return 0x820F1444;
		  /* 820F1444h */ case   15:  		/* lwz R10, <#[R11 + 8]> */
		/* 820F1444h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820F1444h case   15:*/		return 0x820F1448;
		  /* 820F1448h */ case   16:  		/* cmpwi CR6, R10, -1 */
		/* 820F1448h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820F1448h case   16:*/		return 0x820F144C;
		  /* 820F144Ch */ case   17:  		/* bc 4, CR6_EQ, 496 */
		/* 820F144Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x820F163C;  }
		/* 820F144Ch case   17:*/		return 0x820F1450;
		  /* 820F1450h */ case   18:  		/* lfd FR0, <#[R11 + 32]> */
		/* 820F1450h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 820F1450h case   18:*/		return 0x820F1454;
		  /* 820F1454h */ case   19:  		/* fcmpu CR6, FR0, FR31 */
		/* 820F1454h case   19:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820F1454h case   19:*/		return 0x820F1458;
		  /* 820F1458h */ case   20:  		/* bc 4, CR6_EQ, 484 */
		/* 820F1458h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820F163C;  }
		/* 820F1458h case   20:*/		return 0x820F145C;
		  /* 820F145Ch */ case   21:  		/* li R6, 0 */
		/* 820F145Ch case   21:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F145Ch case   21:*/		return 0x820F1460;
		  /* 820F1460h */ case   22:  		/* fmr FR1, FR31 */
		/* 820F1460h case   22:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820F1460h case   22:*/		return 0x820F1464;
		  /* 820F1464h */ case   23:  		/* li R5, 0 */
		/* 820F1464h case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F1464h case   23:*/		return 0x820F1468;
		  /* 820F1468h */ case   24:  		/* li R4, 0 */
		/* 820F1468h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F1468h case   24:*/		return 0x820F146C;
		  /* 820F146Ch */ case   25:  		/* mr R3, R31 */
		/* 820F146Ch case   25:*/		regs.R3 = regs.R31;
		/* 820F146Ch case   25:*/		return 0x820F1470;
		  /* 820F1470h */ case   26:  		/* bl 48568 */
		/* 820F1470h case   26:*/		regs.LR = 0x820F1474; return 0x820FD228;
		/* 820F1470h case   26:*/		return 0x820F1474;
		  /* 820F1474h */ case   27:  		/* mr R27, R3 */
		/* 820F1474h case   27:*/		regs.R27 = regs.R3;
		/* 820F1474h case   27:*/		return 0x820F1478;
		  /* 820F1478h */ case   28:  		/* cmpwi CR6, R3, -1 */
		/* 820F1478h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820F1478h case   28:*/		return 0x820F147C;
		  /* 820F147Ch */ case   29:  		/* bc 12, CR6_EQ, 496 */
		/* 820F147Ch case   29:*/		if ( regs.CR[6].eq ) { return 0x820F166C;  }
		/* 820F147Ch case   29:*/		return 0x820F1480;
		  /* 820F1480h */ case   30:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F1480h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F1480h case   30:*/		return 0x820F1484;
		  /* 820F1484h */ case   31:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820F1484h case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820F1484h case   31:*/		return 0x820F1488;
		  /* 820F1488h */ case   32:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F1488h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1488h case   32:*/		return 0x820F148C;
		  /* 820F148Ch */ case   33:  		/* lwz R11, <#[R11]> */
		/* 820F148Ch case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F148Ch case   33:*/		return 0x820F1490;
		  /* 820F1490h */ case   34:  		/* lwzx R29, <#[R10 + R9]> */
		/* 820F1490h case   34:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F1490h case   34:*/		return 0x820F1494;
		  /* 820F1494h */ case   35:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F1494h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F1494h case   35:*/		return 0x820F1498;
		  /* 820F1498h */ case   36:  		/* mr R3, R29 */
		/* 820F1498h case   36:*/		regs.R3 = regs.R29;
		/* 820F1498h case   36:*/		return 0x820F149C;
		  /* 820F149Ch */ case   37:  		/* lwzx R28, <#[R11 + R9]> */
		/* 820F149Ch case   37:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F149Ch case   37:*/		return 0x820F14A0;
		  /* 820F14A0h */ case   38:  		/* mr R4, R28 */
		/* 820F14A0h case   38:*/		regs.R4 = regs.R28;
		/* 820F14A0h case   38:*/		return 0x820F14A4;
		  /* 820F14A4h */ case   39:  		/* bl 46852 */
		/* 820F14A4h case   39:*/		regs.LR = 0x820F14A8; return 0x820FCBA8;
		/* 820F14A4h case   39:*/		return 0x820F14A8;
		  /* 820F14A8h */ case   40:  		/* cmpwi CR0, R3, 0 */
		/* 820F14A8h case   40:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F14A8h case   40:*/		return 0x820F14AC;
		  /* 820F14ACh */ case   41:  		/* bc 12, CR0_LT, 436 */
		/* 820F14ACh case   41:*/		if ( regs.CR[0].lt ) { return 0x820F1660;  }
		/* 820F14ACh case   41:*/		return 0x820F14B0;
		  /* 820F14B0h */ case   42:  		/* mr R4, R28 */
		/* 820F14B0h case   42:*/		regs.R4 = regs.R28;
		/* 820F14B0h case   42:*/		return 0x820F14B4;
		  /* 820F14B4h */ case   43:  		/* mr R3, R29 */
		/* 820F14B4h case   43:*/		regs.R3 = regs.R29;
		/* 820F14B4h case   43:*/		return 0x820F14B8;
		  /* 820F14B8h */ case   44:  		/* bl 47080 */
		/* 820F14B8h case   44:*/		regs.LR = 0x820F14BC; return 0x820FCCA0;
		/* 820F14B8h case   44:*/		return 0x820F14BC;
		  /* 820F14BCh */ case   45:  		/* cmpwi CR0, R3, 0 */
		/* 820F14BCh case   45:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F14BCh case   45:*/		return 0x820F14C0;
		  /* 820F14C0h */ case   46:  		/* bc 12, CR0_LT, 416 */
		/* 820F14C0h case   46:*/		if ( regs.CR[0].lt ) { return 0x820F1660;  }
		/* 820F14C0h case   46:*/		return 0x820F14C4;
		  /* 820F14C4h */ case   47:  		/* lwz R11, <#[R29 + 60]> */
		/* 820F14C4h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000003C) );
		/* 820F14C4h case   47:*/		return 0x820F14C8;
		  /* 820F14C8h */ case   48:  		/* xoris R11, R11, 8 */
		/* 820F14C8h case   48:*/		cpu::op::xoris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820F14C8h case   48:*/		return 0x820F14CC;
		  /* 820F14CCh */ case   49:  		/* stw R11, <#[R29 + 60]> */
		/* 820F14CCh case   49:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x0000003C) );
		/* 820F14CCh case   49:*/		return 0x820F14D0;
		  /* 820F14D0h */ case   50:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F14D0h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F14D0h case   50:*/		return 0x820F14D4;
		  /* 820F14D4h */ case   51:  		/* lwz R11, <#[R11]> */
		/* 820F14D4h case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F14D4h case   51:*/		return 0x820F14D8;
		  /* 820F14D8h */ case   52:  		/* stw R11, <#[R29 + 56]> */
		/* 820F14D8h case   52:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000038) );
		/* 820F14D8h case   52:*/		return 0x820F14DC;
		  /* 820F14DCh */ case   53:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F14DCh case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F14DCh case   53:*/		return 0x820F14E0;
		  /* 820F14E0h */ case   54:  		/* stw R27, <#[R11 + 4]> */
		/* 820F14E0h case   54:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 820F14E0h case   54:*/		return 0x820F14E4;
		  /* 820F14E4h */ case   55:  		/* b 344 */
		/* 820F14E4h case   55:*/		return 0x820F163C;
		/* 820F14E4h case   55:*/		return 0x820F14E8;
	}
	return 0x820F14E8;
} // Block from 820F1408h-820F14E8h (56 instructions)

//////////////////////////////////////////////////////
// Block at 820F14E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F14E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F14E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F14E8);
		  /* 820F14E8h */ case    0:  		/* lis R10, 29728 */
		/* 820F14E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7420);
		/* 820F14E8h case    0:*/		return 0x820F14EC;
		  /* 820F14ECh */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820F14ECh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F14ECh case    1:*/		return 0x820F14F0;
		  /* 820F14F0h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820F14F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F1500;  }
		/* 820F14F0h case    2:*/		return 0x820F14F4;
		  /* 820F14F4h */ case    3:  		/* lis R10, 29712 */
		/* 820F14F4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x7410);
		/* 820F14F4h case    3:*/		return 0x820F14F8;
		  /* 820F14F8h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820F14F8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F14F8h case    4:*/		return 0x820F14FC;
		  /* 820F14FCh */ case    5:  		/* bc 4, CR6_EQ, 320 */
		/* 820F14FCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820F163C;  }
		/* 820F14FCh case    5:*/		return 0x820F1500;
	}
	return 0x820F1500;
} // Block from 820F14E8h-820F1500h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F1500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1500);
		  /* 820F1500h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F1500h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F1500h case    0:*/		return 0x820F1504;
		  /* 820F1504h */ case    1:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F1504h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1504h case    1:*/		return 0x820F1508;
		  /* 820F1508h */ case    2:  		/* lwz R9, <#[R31 + 16]> */
		/* 820F1508h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820F1508h case    2:*/		return 0x820F150C;
		  /* 820F150Ch */ case    3:  		/* lwz R11, <#[R11]> */
		/* 820F150Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F150Ch case    3:*/		return 0x820F1510;
		  /* 820F1510h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F1510h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F1510h case    4:*/		return 0x820F1514;
		  /* 820F1514h */ case    5:  		/* lwzx R6, <#[R11 + R10]> */
		/* 820F1514h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F1514h case    5:*/		return 0x820F1518;
		  /* 820F1518h */ case    6:  		/* lwz R11, <#[R6 + 4]> */
		/* 820F1518h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 820F1518h case    6:*/		return 0x820F151C;
		  /* 820F151Ch */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F151Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F151Ch case    7:*/		return 0x820F1520;
		  /* 820F1520h */ case    8:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F1520h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F1520h case    8:*/		return 0x820F1524;
		  /* 820F1524h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F1524h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F1524h case    9:*/		return 0x820F1528;
		  /* 820F1528h */ case   10:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 820F1528h case   10:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 820F1528h case   10:*/		return 0x820F152C;
		  /* 820F152Ch */ case   11:  		/* bc 12, CR0_EQ, 272 */
		/* 820F152Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x820F163C;  }
		/* 820F152Ch case   11:*/		return 0x820F1530;
		  /* 820F1530h */ case   12:  		/* rlwinm. R11, R11, 0, 13, 13 */
		/* 820F1530h case   12:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R11);
		/* 820F1530h case   12:*/		return 0x820F1534;
		  /* 820F1534h */ case   13:  		/* bc 4, CR0_EQ, 264 */
		/* 820F1534h case   13:*/		if ( !regs.CR[0].eq ) { return 0x820F163C;  }
		/* 820F1534h case   13:*/		return 0x820F1538;
		  /* 820F1538h */ case   14:  		/* mr R4, R24 */
		/* 820F1538h case   14:*/		regs.R4 = regs.R24;
		/* 820F1538h case   14:*/		return 0x820F153C;
		  /* 820F153Ch */ case   15:  		/* addi R7, R1, 116 */
		/* 820F153Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x74);
		/* 820F153Ch case   15:*/		return 0x820F1540;
		  /* 820F1540h */ case   16:  		/* lis R5, 4 */
		/* 820F1540h case   16:*/		cpu::op::lis<0>(regs,&regs.R5,0x4);
		/* 820F1540h case   16:*/		return 0x820F1544;
		  /* 820F1544h */ case   17:  		/* mr R3, R31 */
		/* 820F1544h case   17:*/		regs.R3 = regs.R31;
		/* 820F1544h case   17:*/		return 0x820F1548;
		  /* 820F1548h */ case   18:  		/* bl -26800 */
		/* 820F1548h case   18:*/		regs.LR = 0x820F154C; return 0x820EAC98;
		/* 820F1548h case   18:*/		return 0x820F154C;
		  /* 820F154Ch */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820F154Ch case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F154Ch case   19:*/		return 0x820F1550;
		  /* 820F1550h */ case   20:  		/* bc 12, CR0_LT, 272 */
		/* 820F1550h case   20:*/		if ( regs.CR[0].lt ) { return 0x820F1660;  }
		/* 820F1550h case   20:*/		return 0x820F1554;
		  /* 820F1554h */ case   21:  		/* lwz R11, <#[R1 + 116]> */
		/* 820F1554h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820F1554h case   21:*/		return 0x820F1558;
		  /* 820F1558h */ case   22:  		/* li R29, 1 */
		/* 820F1558h case   22:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820F1558h case   22:*/		return 0x820F155C;
		  /* 820F155Ch */ case   23:  		/* lwz R10, <#[R30 + 8]> */
		/* 820F155Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 820F155Ch case   23:*/		return 0x820F1560;
		  /* 820F1560h */ case   24:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 820F1560h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 820F1560h case   24:*/		return 0x820F1564;
		  /* 820F1564h */ case   25:  		/* stw R11, <#[R10]> */
		/* 820F1564h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F1564h case   25:*/		return 0x820F1568;
		  /* 820F1568h */ case   26:  		/* lwz R11, <#[R30 + 4]> */
		/* 820F1568h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820F1568h case   26:*/		return 0x820F156C;
		  /* 820F156Ch */ case   27:  		/* cmplwi CR6, R11, 1 */
		/* 820F156Ch case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820F156Ch case   27:*/		return 0x820F1570;
		  /* 820F1570h */ case   28:  		/* lwz R11, <#[R31 + 20]> */
		/* 820F1570h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1570h case   28:*/		return 0x820F1574;
		  /* 820F1574h */ case   29:  		/* lwzx R27, <#[R9 + R11]> */
		/* 820F1574h case   29:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F1574h case   29:*/		return 0x820F1578;
		  /* 820F1578h */ case   30:  		/* bc 4, CR6_GT, 196 */
		/* 820F1578h case   30:*/		if ( !regs.CR[6].gt ) { return 0x820F163C;  }
		/* 820F1578h case   30:*/		return 0x820F157C;
		  /* 820F157Ch */ case   31:  		/* li R28, 4 */
		/* 820F157Ch case   31:*/		cpu::op::li<0>(regs,&regs.R28,0x4);
		/* 820F157Ch case   31:*/		return 0x820F1580;
		  /* 820F1580h */ case   32:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F1580h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F1580h case   32:*/		return 0x820F1584;
		  /* 820F1584h */ case   33:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820F1584h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820F1584h case   33:*/		return 0x820F1588;
		  /* 820F1588h */ case   34:  		/* cmpwi CR6, R11, -1 */
		/* 820F1588h case   34:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820F1588h case   34:*/		return 0x820F158C;
		  /* 820F158Ch */ case   35:  		/* bc 12, CR6_EQ, 20 */
		/* 820F158Ch case   35:*/		if ( regs.CR[6].eq ) { return 0x820F15A0;  }
		/* 820F158Ch case   35:*/		return 0x820F1590;
		  /* 820F1590h */ case   36:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F1590h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1590h case   36:*/		return 0x820F1594;
		  /* 820F1594h */ case   37:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F1594h case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F1594h case   37:*/		return 0x820F1598;
		  /* 820F1598h */ case   38:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F1598h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F1598h case   38:*/		return 0x820F159C;
		  /* 820F159Ch */ case   39:  		/* b 8 */
		/* 820F159Ch case   39:*/		return 0x820F15A4;
		/* 820F159Ch case   39:*/		return 0x820F15A0;
	}
	return 0x820F15A0;
} // Block from 820F1500h-820F15A0h (40 instructions)

//////////////////////////////////////////////////////
// Block at 820F15A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F15A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F15A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F15A0);
		  /* 820F15A0h */ case    0:  		/* mr R11, R27 */
		/* 820F15A0h case    0:*/		regs.R11 = regs.R27;
		/* 820F15A0h case    0:*/		return 0x820F15A4;
	}
	return 0x820F15A4;
} // Block from 820F15A0h-820F15A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F15A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F15A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F15A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F15A4);
		  /* 820F15A4h */ case    0:  		/* mr R6, R29 */
		/* 820F15A4h case    0:*/		regs.R6 = regs.R29;
		/* 820F15A4h case    0:*/		return 0x820F15A8;
		  /* 820F15A8h */ case    1:  		/* lfd FR1, <#[R11 + 32]> */
		/* 820F15A8h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000020) );
		/* 820F15A8h case    1:*/		return 0x820F15AC;
		  /* 820F15ACh */ case    2:  		/* mr R3, R31 */
		/* 820F15ACh case    2:*/		regs.R3 = regs.R31;
		/* 820F15ACh case    2:*/		return 0x820F15B0;
		  /* 820F15B0h */ case    3:  		/* lwz R5, <#[R27 + 12]> */
		/* 820F15B0h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 820F15B0h case    3:*/		return 0x820F15B4;
		  /* 820F15B4h */ case    4:  		/* lwz R4, <#[R27 + 4]> */
		/* 820F15B4h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000004) );
		/* 820F15B4h case    4:*/		return 0x820F15B8;
		  /* 820F15B8h */ case    5:  		/* bl 48240 */
		/* 820F15B8h case    5:*/		regs.LR = 0x820F15BC; return 0x820FD228;
		/* 820F15B8h case    5:*/		return 0x820F15BC;
		  /* 820F15BCh */ case    6:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F15BCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F15BCh case    6:*/		return 0x820F15C0;
		  /* 820F15C0h */ case    7:  		/* addi R29, R29, 1 */
		/* 820F15C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820F15C0h case    7:*/		return 0x820F15C4;
		  /* 820F15C4h */ case    8:  		/* stwx R3, <#[R28 + R11]> */
		/* 820F15C4h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820F15C4h case    8:*/		return 0x820F15C8;
		  /* 820F15C8h */ case    9:  		/* addi R28, R28, 4 */
		/* 820F15C8h case    9:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820F15C8h case    9:*/		return 0x820F15CC;
		  /* 820F15CCh */ case   10:  		/* lwz R11, <#[R30 + 4]> */
		/* 820F15CCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820F15CCh case   10:*/		return 0x820F15D0;
		  /* 820F15D0h */ case   11:  		/* cmplw CR6, R29, R11 */
		/* 820F15D0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820F15D0h case   11:*/		return 0x820F15D4;
		  /* 820F15D4h */ case   12:  		/* bc 12, CR6_LT, -84 */
		/* 820F15D4h case   12:*/		if ( regs.CR[6].lt ) { return 0x820F1580;  }
		/* 820F15D4h case   12:*/		return 0x820F15D8;
	}
	return 0x820F15D8;
} // Block from 820F15A4h-820F15D8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820F15D8h
// Function '?Reschedule@CShaderProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F15D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F15D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F15D8);
		  /* 820F15D8h */ case    0:  		/* b 100 */
		/* 820F15D8h case    0:*/		return 0x820F163C;
		/* 820F15D8h case    0:*/		return 0x820F15DC;
	}
	return 0x820F15DC;
} // Block from 820F15D8h-820F15DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F15DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F15DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F15DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F15DC);
		  /* 820F15DCh */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F15DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F15DCh case    0:*/		return 0x820F15E0;
		  /* 820F15E0h */ case    1:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F15E0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F15E0h case    1:*/		return 0x820F15E4;
		  /* 820F15E4h */ case    2:  		/* lwz R9, <#[R31 + 16]> */
		/* 820F15E4h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820F15E4h case    2:*/		return 0x820F15E8;
		  /* 820F15E8h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 820F15E8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F15E8h case    3:*/		return 0x820F15EC;
		  /* 820F15ECh */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F15ECh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F15ECh case    4:*/		return 0x820F15F0;
		  /* 820F15F0h */ case    5:  		/* lwzx R6, <#[R11 + R10]> */
		/* 820F15F0h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F15F0h case    5:*/		return 0x820F15F4;
		  /* 820F15F4h */ case    6:  		/* lwz R11, <#[R6 + 4]> */
		/* 820F15F4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 820F15F4h case    6:*/		return 0x820F15F8;
		  /* 820F15F8h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F15F8h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F15F8h case    7:*/		return 0x820F15FC;
		  /* 820F15FCh */ case    8:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F15FCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F15FCh case    8:*/		return 0x820F1600;
		  /* 820F1600h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F1600h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F1600h case    9:*/		return 0x820F1604;
		  /* 820F1604h */ case   10:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 820F1604h case   10:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 820F1604h case   10:*/		return 0x820F1608;
		  /* 820F1608h */ case   11:  		/* bc 12, CR0_EQ, 52 */
		/* 820F1608h case   11:*/		if ( regs.CR[0].eq ) { return 0x820F163C;  }
		/* 820F1608h case   11:*/		return 0x820F160C;
		  /* 820F160Ch */ case   12:  		/* rlwinm. R11, R11, 0, 18, 18 */
		/* 820F160Ch case   12:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R11,regs.R11);
		/* 820F160Ch case   12:*/		return 0x820F1610;
		  /* 820F1610h */ case   13:  		/* bc 4, CR0_EQ, 44 */
		/* 820F1610h case   13:*/		if ( !regs.CR[0].eq ) { return 0x820F163C;  }
		/* 820F1610h case   13:*/		return 0x820F1614;
		  /* 820F1614h */ case   14:  		/* mr R4, R23 */
		/* 820F1614h case   14:*/		regs.R4 = regs.R23;
		/* 820F1614h case   14:*/		return 0x820F1618;
		  /* 820F1618h */ case   15:  		/* addi R7, R1, 112 */
		/* 820F1618h case   15:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x70);
		/* 820F1618h case   15:*/		return 0x820F161C;
		  /* 820F161Ch */ case   16:  		/* li R5, 8192 */
		/* 820F161Ch case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x2000);
		/* 820F161Ch case   16:*/		return 0x820F1620;
		  /* 820F1620h */ case   17:  		/* mr R3, R31 */
		/* 820F1620h case   17:*/		regs.R3 = regs.R31;
		/* 820F1620h case   17:*/		return 0x820F1624;
		  /* 820F1624h */ case   18:  		/* bl -27020 */
		/* 820F1624h case   18:*/		regs.LR = 0x820F1628; return 0x820EAC98;
		/* 820F1624h case   18:*/		return 0x820F1628;
		  /* 820F1628h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820F1628h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F1628h case   19:*/		return 0x820F162C;
		  /* 820F162Ch */ case   20:  		/* bc 12, CR0_LT, 52 */
		/* 820F162Ch case   20:*/		if ( regs.CR[0].lt ) { return 0x820F1660;  }
		/* 820F162Ch case   20:*/		return 0x820F1630;
		  /* 820F1630h */ case   21:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F1630h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F1630h case   21:*/		return 0x820F1634;
		  /* 820F1634h */ case   22:  		/* lwz R10, <#[R1 + 112]> */
		/* 820F1634h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 820F1634h case   22:*/		return 0x820F1638;
		  /* 820F1638h */ case   23:  		/* stw R10, <#[R11]> */
		/* 820F1638h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F1638h case   23:*/		return 0x820F163C;
	}
	return 0x820F163C;
} // Block from 820F15DCh-820F163Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F163Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F163C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F163C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F163C);
		  /* 820F163Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820F163Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F163Ch case    0:*/		return 0x820F1640;
		  /* 820F1640h */ case    1:  		/* addi R22, R22, 1 */
		/* 820F1640h case    1:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 820F1640h case    1:*/		return 0x820F1644;
		  /* 820F1644h */ case    2:  		/* addi R25, R25, 4 */
		/* 820F1644h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 820F1644h case    2:*/		return 0x820F1648;
		  /* 820F1648h */ case    3:  		/* cmplw CR6, R22, R11 */
		/* 820F1648h case    3:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 820F1648h case    3:*/		return 0x820F164C;
		  /* 820F164Ch */ case    4:  		/* bc 12, CR6_LT, -664 */
		/* 820F164Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820F13B4;  }
		/* 820F164Ch case    4:*/		return 0x820F1650;
	}
	return 0x820F1650;
} // Block from 820F163Ch-820F1650h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F1650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1650);
		  /* 820F1650h */ case    0:  		/* mr R3, R31 */
		/* 820F1650h case    0:*/		regs.R3 = regs.R31;
		/* 820F1650h case    0:*/		return 0x820F1654;
		  /* 820F1654h */ case    1:  		/* bl 101212 */
		/* 820F1654h case    1:*/		regs.LR = 0x820F1658; return 0x8210A1B0;
		/* 820F1654h case    1:*/		return 0x820F1658;
		  /* 820F1658h */ case    2:  		/* srawi R11, R3, 31 */
		/* 820F1658h case    2:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820F1658h case    2:*/		return 0x820F165C;
		  /* 820F165Ch */ case    3:  		/* and R3, R11, R3 */
		/* 820F165Ch case    3:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820F165Ch case    3:*/		return 0x820F1660;
	}
	return 0x820F1660;
} // Block from 820F1650h-820F1660h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F1660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1660);
		  /* 820F1660h */ case    0:  		/* addi R1, R1, 480 */
		/* 820F1660h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1E0);
		/* 820F1660h case    0:*/		return 0x820F1664;
		  /* 820F1664h */ case    1:  		/* lfd FR31, <#[R1 - 96]> */
		/* 820F1664h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 820F1664h case    1:*/		return 0x820F1668;
		  /* 820F1668h */ case    2:  		/* b -394200 */
		/* 820F1668h case    2:*/		return 0x82091290;
		/* 820F1668h case    2:*/		return 0x820F166C;
	}
	return 0x820F166C;
} // Block from 820F1660h-820F166Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F166Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F166C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F166C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F166C);
		  /* 820F166Ch */ case    0:  		/* lis R3, -32761 */
		/* 820F166Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820F166Ch case    0:*/		return 0x820F1670;
		  /* 820F1670h */ case    1:  		/* ori R3, R3, 14 */
		/* 820F1670h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820F1670h case    1:*/		return 0x820F1674;
		  /* 820F1674h */ case    2:  		/* b -20 */
		/* 820F1674h case    2:*/		return 0x820F1660;
		/* 820F1674h case    2:*/		return 0x820F1678;
	}
	return 0x820F1678;
} // Block from 820F166Ch-820F1678h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F1678h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1678);
		  /* 820F1678h */ case    0:  		/* mfspr R12, LR */
		/* 820F1678h case    0:*/		regs.R12 = regs.LR;
		/* 820F1678h case    0:*/		return 0x820F167C;
		  /* 820F167Ch */ case    1:  		/* bl -394292 */
		/* 820F167Ch case    1:*/		regs.LR = 0x820F1680; return 0x82091248;
		/* 820F167Ch case    1:*/		return 0x820F1680;
		  /* 820F1680h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820F1680h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820F1680h case    2:*/		return 0x820F1684;
		  /* 820F1684h */ case    3:  		/* mr R26, R3 */
		/* 820F1684h case    3:*/		regs.R26 = regs.R3;
		/* 820F1684h case    3:*/		return 0x820F1688;
		  /* 820F1688h */ case    4:  		/* mr R31, R4 */
		/* 820F1688h case    4:*/		regs.R31 = regs.R4;
		/* 820F1688h case    4:*/		return 0x820F168C;
		  /* 820F168Ch */ case    5:  		/* mr R25, R6 */
		/* 820F168Ch case    5:*/		regs.R25 = regs.R6;
		/* 820F168Ch case    5:*/		return 0x820F1690;
		  /* 820F1690h */ case    6:  		/* mr R24, R7 */
		/* 820F1690h case    6:*/		regs.R24 = regs.R7;
		/* 820F1690h case    6:*/		return 0x820F1694;
		  /* 820F1694h */ case    7:  		/* cmplwi CR6, R7, 0 */
		/* 820F1694h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820F1694h case    7:*/		return 0x820F1698;
		  /* 820F1698h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 820F1698h case    8:*/		if ( regs.CR[6].eq ) { return 0x820F16C8;  }
		/* 820F1698h case    8:*/		return 0x820F169C;
		  /* 820F169Ch */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 820F169Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820F169Ch case    9:*/		return 0x820F16A0;
		  /* 820F16A0h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820F16A0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820F16C8;  }
		/* 820F16A0h case   10:*/		return 0x820F16A4;
		  /* 820F16A4h */ case   11:  		/* lwz R11, <#[R31 + 4]> */
		/* 820F16A4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820F16A4h case   11:*/		return 0x820F16A8;
		  /* 820F16A8h */ case   12:  		/* cmpwi CR6, R11, 1 */
		/* 820F16A8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820F16A8h case   12:*/		return 0x820F16AC;
		  /* 820F16ACh */ case   13:  		/* bc 12, CR6_EQ, 392 */
		/* 820F16ACh case   13:*/		if ( regs.CR[6].eq ) { return 0x820F1834;  }
		/* 820F16ACh case   13:*/		return 0x820F16B0;
		  /* 820F16B0h */ case   14:  		/* cmpwi CR6, R11, 8 */
		/* 820F16B0h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 820F16B0h case   14:*/		return 0x820F16B4;
		  /* 820F16B4h */ case   15:  		/* bc 4, CR6_EQ, 28 */
		/* 820F16B4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820F16D0;  }
		/* 820F16B4h case   15:*/		return 0x820F16B8;
		  /* 820F16B8h */ case   16:  		/* lwz R11, <#[R31 + 20]> */
		/* 820F16B8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820F16B8h case   16:*/		return 0x820F16BC;
		  /* 820F16BCh */ case   17:  		/* lwz R31, <#[R31 + 16]> */
		/* 820F16BCh case   17:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000010) );
		/* 820F16BCh case   17:*/		return 0x820F16C0;
		  /* 820F16C0h */ case   18:  		/* mullw R5, R11, R5 */
		/* 820F16C0h case   18:*/		cpu::op::mullw<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 820F16C0h case   18:*/		return 0x820F16C4;
		  /* 820F16C4h */ case   19:  		/* b -40 */
		/* 820F16C4h case   19:*/		return 0x820F169C;
		/* 820F16C4h case   19:*/		return 0x820F16C8;
	}
	return 0x820F16C8;
} // Block from 820F1678h-820F16C8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820F16C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F16C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F16C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F16C8);
		  /* 820F16C8h */ case    0:  		/* li R3, 0 */
		/* 820F16C8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F16C8h case    0:*/		return 0x820F16CC;
		  /* 820F16CCh */ case    1:  		/* b 700 */
		/* 820F16CCh case    1:*/		return 0x820F1988;
		/* 820F16CCh case    1:*/		return 0x820F16D0;
	}
	return 0x820F16D0;
} // Block from 820F16C8h-820F16D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F16D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F16D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F16D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F16D0);
		  /* 820F16D0h */ case    0:  		/* cmpwi CR6, R11, 9 */
		/* 820F16D0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 820F16D0h case    0:*/		return 0x820F16D4;
		  /* 820F16D4h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820F16D4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820F16E4;  }
		/* 820F16D4h case    1:*/		return 0x820F16D8;
		  /* 820F16D8h */ case    2:  		/* lis R3, -32768 */
		/* 820F16D8h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820F16D8h case    2:*/		return 0x820F16DC;
		  /* 820F16DCh */ case    3:  		/* ori R3, R3, 16389 */
		/* 820F16DCh case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820F16DCh case    3:*/		return 0x820F16E0;
		  /* 820F16E0h */ case    4:  		/* b 680 */
		/* 820F16E0h case    4:*/		return 0x820F1988;
		/* 820F16E0h case    4:*/		return 0x820F16E4;
	}
	return 0x820F16E4;
} // Block from 820F16D0h-820F16E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F16E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F16E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F16E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F16E4);
		  /* 820F16E4h */ case    0:  		/* addi R7, R1, 80 */
		/* 820F16E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820F16E4h case    0:*/		return 0x820F16E8;
		  /* 820F16E8h */ case    1:  		/* lwz R10, <#[R31 + 16]> */
		/* 820F16E8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820F16E8h case    1:*/		return 0x820F16EC;
		  /* 820F16ECh */ case    2:  		/* li R11, 0 */
		/* 820F16ECh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F16ECh case    2:*/		return 0x820F16F0;
		  /* 820F16F0h */ case    3:  		/* li R8, 4 */
		/* 820F16F0h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 820F16F0h case    3:*/		return 0x820F16F4;
		  /* 820F16F4h */ case    4:  		/* li R9, 1 */
		/* 820F16F4h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820F16F4h case    4:*/		return 0x820F16F8;
		  /* 820F16F8h */ case    5:  		/* cmplwi CR6, R10, 1 */
		/* 820F16F8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820F16F8h case    5:*/		return 0x820F16FC;
		  /* 820F16FCh */ case    6:  		/* std R11, <#[R7]> */
		/* 820F16FCh case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 820F16FCh case    6:*/		return 0x820F1700;
		  /* 820F1700h */ case    7:  		/* std R11, <#[R7 + 8]> */
		/* 820F1700h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 820F1700h case    7:*/		return 0x820F1704;
		  /* 820F1704h */ case    8:  		/* bc 12, CR6_LT, 60 */
		/* 820F1704h case    8:*/		if ( regs.CR[6].lt ) { return 0x820F1740;  }
		/* 820F1704h case    8:*/		return 0x820F1708;
		  /* 820F1708h */ case    9:  		/* bc 12, CR6_EQ, 48 */
		/* 820F1708h case    9:*/		if ( regs.CR[6].eq ) { return 0x820F1738;  }
		/* 820F1708h case    9:*/		return 0x820F170C;
		  /* 820F170Ch */ case   10:  		/* cmplwi CR6, R10, 3 */
		/* 820F170Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820F170Ch case   10:*/		return 0x820F1710;
		  /* 820F1710h */ case   11:  		/* bc 12, CR6_LT, 16 */
		/* 820F1710h case   11:*/		if ( regs.CR[6].lt ) { return 0x820F1720;  }
		/* 820F1710h case   11:*/		return 0x820F1714;
		  /* 820F1714h */ case   12:  		/* bc 4, CR6_EQ, 48 */
		/* 820F1714h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820F1744;  }
		/* 820F1714h case   12:*/		return 0x820F1718;
		  /* 820F1718h */ case   13:  		/* sth R8, <#[R1 + 80]> */
		/* 820F1718h case   13:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 820F1718h case   13:*/		return 0x820F171C;
		  /* 820F171Ch */ case   14:  		/* b 40 */
		/* 820F171Ch case   14:*/		return 0x820F1744;
		/* 820F171Ch case   14:*/		return 0x820F1720;
	}
	return 0x820F1720;
} // Block from 820F16E4h-820F1720h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820F1720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1720);
		  /* 820F1720h */ case    0:  		/* lwz R10, <#[R31 + 36]> */
		/* 820F1720h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000024) );
		/* 820F1720h case    0:*/		return 0x820F1724;
		  /* 820F1724h */ case    1:  		/* nor R10, R10, R10 */
		/* 820F1724h case    1:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820F1724h case    1:*/		return 0x820F1728;
		  /* 820F1728h */ case    2:  		/* rlwinm R10, R10, 22, 31, 31 */
		/* 820F1728h case    2:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R10,regs.R10);
		/* 820F1728h case    2:*/		return 0x820F172C;
		  /* 820F172Ch */ case    3:  		/* ori R10, R10, 2 */
		/* 820F172Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 820F172Ch case    3:*/		return 0x820F1730;
		  /* 820F1730h */ case    4:  		/* sth R10, <#[R1 + 80]> */
		/* 820F1730h case    4:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820F1730h case    4:*/		return 0x820F1734;
		  /* 820F1734h */ case    5:  		/* b 16 */
		/* 820F1734h case    5:*/		return 0x820F1744;
		/* 820F1734h case    5:*/		return 0x820F1738;
	}
	return 0x820F1738;
} // Block from 820F1720h-820F1738h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F1738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1738);
		  /* 820F1738h */ case    0:  		/* sth R9, <#[R1 + 80]> */
		/* 820F1738h case    0:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820F1738h case    0:*/		return 0x820F173C;
		  /* 820F173Ch */ case    1:  		/* b 8 */
		/* 820F173Ch case    1:*/		return 0x820F1744;
		/* 820F173Ch case    1:*/		return 0x820F1740;
	}
	return 0x820F1740;
} // Block from 820F1738h-820F1740h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F1740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1740);
		  /* 820F1740h */ case    0:  		/* sth R11, <#[R1 + 80]> */
		/* 820F1740h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F1740h case    0:*/		return 0x820F1744;
	}
	return 0x820F1744;
} // Block from 820F1740h-820F1744h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F1744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1744);
		  /* 820F1744h */ case    0:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F1744h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1744h case    0:*/		return 0x820F1748;
		  /* 820F1748h */ case    1:  		/* cmplwi CR6, R10, 46 */
		/* 820F1748h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000002E);
		/* 820F1748h case    1:*/		return 0x820F174C;
		  /* 820F174Ch */ case    2:  		/* bc 12, CR6_GT, 204 */
		/* 820F174Ch case    2:*/		if ( regs.CR[6].gt ) { return 0x820F1818;  }
		/* 820F174Ch case    2:*/		return 0x820F1750;
		  /* 820F1750h */ case    3:  		/* lis R12, -32254 */
		/* 820F1750h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8202);
		/* 820F1750h case    3:*/		return 0x820F1754;
		  /* 820F1754h */ case    4:  		/* addi R12, R12, -18632 */
		/* 820F1754h case    4:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFB738);
		/* 820F1754h case    4:*/		return 0x820F1758;
		  /* 820F1758h */ case    5:  		/* lbzx R0, <#[R12 + R10]> */
		/* 820F1758h case    5:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R10 + 0x00000000) );
		/* 820F1758h case    5:*/		return 0x820F175C;
		  /* 820F175Ch */ case    6:  		/* lis R12, -32241 */
		/* 820F175Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820F);
		/* 820F175Ch case    6:*/		return 0x820F1760;
		  /* 820F1760h */ case    7:  		/* ori R0, R0, 0 */
		/* 820F1760h case    7:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820F1760h case    7:*/		return 0x820F1764;
		  /* 820F1764h */ case    8:  		/* addi R12, R12, 6008 */
		/* 820F1764h case    8:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x1778);
		/* 820F1764h case    8:*/		return 0x820F1768;
		  /* 820F1768h */ case    9:  		/* ori R0, R0, 0 */
		/* 820F1768h case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820F1768h case    9:*/		return 0x820F176C;
		  /* 820F176Ch */ case   10:  		/* add R12, R12, R0 */
		/* 820F176Ch case   10:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820F176Ch case   10:*/		return 0x820F1770;
		  /* 820F1770h */ case   11:  		/* mtspr CTR, R12 */
		/* 820F1770h case   11:*/		regs.CTR = regs.R12;
		/* 820F1770h case   11:*/		return 0x820F1774;
		  /* 820F1774h */ case   12:  		/* bcctr 20, CR0_LT */
		/* 820F1774h case   12:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820F1774h case   12:*/		return 0x820F1778;
		  /* 820F1778h */ case   13:  		/* sth R9, <#[R1 + 82]> */
		/* 820F1778h case   13:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x00000052) );
		/* 820F1778h case   13:*/		return 0x820F177C;
		  /* 820F177Ch */ case   14:  		/* b 160 */
		/* 820F177Ch case   14:*/		return 0x820F181C;
		/* 820F177Ch case   14:*/		return 0x820F1780;
		  /* 820F1780h */ case   15:  		/* li R11, 2 */
		/* 820F1780h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820F1780h case   15:*/		return 0x820F1784;
		  /* 820F1784h */ case   16:  		/* b 148 */
		/* 820F1784h case   16:*/		return 0x820F1818;
		/* 820F1784h case   16:*/		return 0x820F1788;
		  /* 820F1788h */ case   17:  		/* li R11, 3 */
		/* 820F1788h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820F1788h case   17:*/		return 0x820F178C;
		  /* 820F178Ch */ case   18:  		/* b 140 */
		/* 820F178Ch case   18:*/		return 0x820F1818;
		/* 820F178Ch case   18:*/		return 0x820F1790;
		  /* 820F1790h */ case   19:  		/* sth R8, <#[R1 + 82]> */
		/* 820F1790h case   19:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R1 + 0x00000052) );
		/* 820F1790h case   19:*/		return 0x820F1794;
		  /* 820F1794h */ case   20:  		/* b 136 */
		/* 820F1794h case   20:*/		return 0x820F181C;
		/* 820F1794h case   20:*/		return 0x820F1798;
		  /* 820F1798h */ case   21:  		/* li R11, 5 */
		/* 820F1798h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820F1798h case   21:*/		return 0x820F179C;
		  /* 820F179Ch */ case   22:  		/* b 124 */
		/* 820F179Ch case   22:*/		return 0x820F1818;
		/* 820F179Ch case   22:*/		return 0x820F17A0;
		  /* 820F17A0h */ case   23:  		/* li R11, 6 */
		/* 820F17A0h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820F17A0h case   23:*/		return 0x820F17A4;
		  /* 820F17A4h */ case   24:  		/* b 116 */
		/* 820F17A4h case   24:*/		return 0x820F1818;
		/* 820F17A4h case   24:*/		return 0x820F17A8;
		  /* 820F17A8h */ case   25:  		/* li R11, 7 */
		/* 820F17A8h case   25:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820F17A8h case   25:*/		return 0x820F17AC;
		  /* 820F17ACh */ case   26:  		/* b 108 */
		/* 820F17ACh case   26:*/		return 0x820F1818;
		/* 820F17ACh case   26:*/		return 0x820F17B0;
		  /* 820F17B0h */ case   27:  		/* li R11, 8 */
		/* 820F17B0h case   27:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820F17B0h case   27:*/		return 0x820F17B4;
		  /* 820F17B4h */ case   28:  		/* b 100 */
		/* 820F17B4h case   28:*/		return 0x820F1818;
		/* 820F17B4h case   28:*/		return 0x820F17B8;
		  /* 820F17B8h */ case   29:  		/* li R11, 9 */
		/* 820F17B8h case   29:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 820F17B8h case   29:*/		return 0x820F17BC;
		  /* 820F17BCh */ case   30:  		/* b 92 */
		/* 820F17BCh case   30:*/		return 0x820F1818;
		/* 820F17BCh case   30:*/		return 0x820F17C0;
		  /* 820F17C0h */ case   31:  		/* rlwinm. R11, R25, 0, 10, 10 */
		/* 820F17C0h case   31:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R25);
		/* 820F17C0h case   31:*/		return 0x820F17C4;
		  /* 820F17C4h */ case   32:  		/* bc 12, CR0_EQ, 12 */
		/* 820F17C4h case   32:*/		if ( regs.CR[0].eq ) { return 0x820F17D0;  }
		/* 820F17C4h case   32:*/		return 0x820F17C8;
		  /* 820F17C8h */ case   33:  		/* li R11, 12 */
		/* 820F17C8h case   33:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820F17C8h case   33:*/		return 0x820F17CC;
		  /* 820F17CCh */ case   34:  		/* b 76 */
		/* 820F17CCh case   34:*/		return 0x820F1818;
		/* 820F17CCh case   34:*/		return 0x820F17D0;
	}
	return 0x820F17D0;
} // Block from 820F1744h-820F17D0h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820F17D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F17D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F17D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F17D0);
		  /* 820F17D0h */ case    0:  		/* rlwinm. R11, R25, 0, 9, 9 */
		/* 820F17D0h case    0:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R25);
		/* 820F17D0h case    0:*/		return 0x820F17D4;
		  /* 820F17D4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820F17D4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820F17E0;  }
		/* 820F17D4h case    1:*/		return 0x820F17D8;
		  /* 820F17D8h */ case    2:  		/* li R11, 13 */
		/* 820F17D8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 820F17D8h case    2:*/		return 0x820F17DC;
		  /* 820F17DCh */ case    3:  		/* b 60 */
		/* 820F17DCh case    3:*/		return 0x820F1818;
		/* 820F17DCh case    3:*/		return 0x820F17E0;
	}
	return 0x820F17E0;
} // Block from 820F17D0h-820F17E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F17E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F17E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F17E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F17E0);
		  /* 820F17E0h */ case    0:  		/* rlwinm R11, R25, 10, 30, 30 */
		/* 820F17E0h case    0:*/		cpu::op::rlwinm<0,10,30,30>(regs,&regs.R11,regs.R25);
		/* 820F17E0h case    0:*/		return 0x820F17E4;
		  /* 820F17E4h */ case    1:  		/* ori R11, R11, 12 */
		/* 820F17E4h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xC);
		/* 820F17E4h case    1:*/		return 0x820F17E8;
		  /* 820F17E8h */ case    2:  		/* b 48 */
		/* 820F17E8h case    2:*/		return 0x820F1818;
		/* 820F17E8h case    2:*/		return 0x820F17EC;
		  /* 820F17ECh */ case    3:  		/* li R11, 11 */
		/* 820F17ECh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 820F17ECh case    3:*/		return 0x820F17F0;
		  /* 820F17F0h */ case    4:  		/* b 40 */
		/* 820F17F0h case    4:*/		return 0x820F1818;
		/* 820F17F0h case    4:*/		return 0x820F17F4;
		  /* 820F17F4h */ case    5:  		/* li R11, 14 */
		/* 820F17F4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0xE);
		/* 820F17F4h case    5:*/		return 0x820F17F8;
		  /* 820F17F8h */ case    6:  		/* b 32 */
		/* 820F17F8h case    6:*/		return 0x820F1818;
		/* 820F17F8h case    6:*/		return 0x820F17FC;
		  /* 820F17FCh */ case    7:  		/* li R11, 15 */
		/* 820F17FCh case    7:*/		cpu::op::li<0>(regs,&regs.R11,0xF);
		/* 820F17FCh case    7:*/		return 0x820F1800;
		  /* 820F1800h */ case    8:  		/* b 24 */
		/* 820F1800h case    8:*/		return 0x820F1818;
		/* 820F1800h case    8:*/		return 0x820F1804;
		  /* 820F1804h */ case    9:  		/* li R11, 16 */
		/* 820F1804h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 820F1804h case    9:*/		return 0x820F1808;
		  /* 820F1808h */ case   10:  		/* b 16 */
		/* 820F1808h case   10:*/		return 0x820F1818;
		/* 820F1808h case   10:*/		return 0x820F180C;
		  /* 820F180Ch */ case   11:  		/* li R11, 17 */
		/* 820F180Ch case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x11);
		/* 820F180Ch case   11:*/		return 0x820F1810;
		  /* 820F1810h */ case   12:  		/* b 8 */
		/* 820F1810h case   12:*/		return 0x820F1818;
		/* 820F1810h case   12:*/		return 0x820F1814;
		  /* 820F1814h */ case   13:  		/* li R11, 18 */
		/* 820F1814h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x12);
		/* 820F1814h case   13:*/		return 0x820F1818;
	}
	return 0x820F1818;
} // Block from 820F17E0h-820F1818h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F1818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1818);
		  /* 820F1818h */ case    0:  		/* sth R11, <#[R1 + 82]> */
		/* 820F1818h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 820F1818h case    0:*/		return 0x820F181C;
	}
	return 0x820F181C;
} // Block from 820F1818h-820F181Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F181Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F181C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F181C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F181C);
		  /* 820F181Ch */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 820F181Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820F181Ch case    0:*/		return 0x820F1820;
		  /* 820F1820h */ case    1:  		/* lwz R9, <#[R31 + 32]> */
		/* 820F1820h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000020) );
		/* 820F1820h case    1:*/		return 0x820F1824;
		  /* 820F1824h */ case    2:  		/* sth R5, <#[R1 + 88]> */
		/* 820F1824h case    2:*/		cpu::mem::store16( regs, regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 820F1824h case    2:*/		return 0x820F1828;
		  /* 820F1828h */ case    3:  		/* sth R11, <#[R1 + 84]> */
		/* 820F1828h case    3:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820F1828h case    3:*/		return 0x820F182C;
		  /* 820F182Ch */ case    4:  		/* sth R9, <#[R1 + 86]> */
		/* 820F182Ch case    4:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x00000056) );
		/* 820F182Ch case    4:*/		return 0x820F1830;
		  /* 820F1830h */ case    5:  		/* b 308 */
		/* 820F1830h case    5:*/		return 0x820F1964;
		/* 820F1830h case    5:*/		return 0x820F1834;
	}
	return 0x820F1834;
} // Block from 820F181Ch-820F1834h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F1834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1834);
		  /* 820F1834h */ case    0:  		/* addi R10, R1, 80 */
		/* 820F1834h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 820F1834h case    0:*/		return 0x820F1838;
		  /* 820F1838h */ case    1:  		/* li R11, 0 */
		/* 820F1838h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F1838h case    1:*/		return 0x820F183C;
		  /* 820F183Ch */ case    2:  		/* li R9, 5 */
		/* 820F183Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x5);
		/* 820F183Ch case    2:*/		return 0x820F1840;
		  /* 820F1840h */ case    3:  		/* li R8, 1 */
		/* 820F1840h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F1840h case    3:*/		return 0x820F1844;
		  /* 820F1844h */ case    4:  		/* mr R3, R31 */
		/* 820F1844h case    4:*/		regs.R3 = regs.R31;
		/* 820F1844h case    4:*/		return 0x820F1848;
		  /* 820F1848h */ case    5:  		/* std R11, <#[R10]> */
		/* 820F1848h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F1848h case    5:*/		return 0x820F184C;
		  /* 820F184Ch */ case    6:  		/* std R11, <#[R10 + 8]> */
		/* 820F184Ch case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820F184Ch case    6:*/		return 0x820F1850;
		  /* 820F1850h */ case    7:  		/* sth R9, <#[R1 + 80]> */
		/* 820F1850h case    7:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820F1850h case    7:*/		return 0x820F1854;
		  /* 820F1854h */ case    8:  		/* sth R11, <#[R1 + 82]> */
		/* 820F1854h case    8:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 820F1854h case    8:*/		return 0x820F1858;
		  /* 820F1858h */ case    9:  		/* sth R8, <#[R1 + 84]> */
		/* 820F1858h case    9:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 820F1858h case    9:*/		return 0x820F185C;
		  /* 820F185Ch */ case   10:  		/* bl -19500 */
		/* 820F185Ch case   10:*/		regs.LR = 0x820F1860; return 0x820ECC30;
		/* 820F185Ch case   10:*/		return 0x820F1860;
		  /* 820F1860h */ case   11:  		/* lhz R10, <#[R1 + 90]> */
		/* 820F1860h case   11:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005A) );
		/* 820F1860h case   11:*/		return 0x820F1864;
		  /* 820F1864h */ case   12:  		/* mr R11, R31 */
		/* 820F1864h case   12:*/		regs.R11 = regs.R31;
		/* 820F1864h case   12:*/		return 0x820F1868;
		  /* 820F1868h */ case   13:  		/* sth R3, <#[R1 + 86]> */
		/* 820F1868h case   13:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R1 + 0x00000056) );
		/* 820F1868h case   13:*/		return 0x820F186C;
		  /* 820F186Ch */ case   14:  		/* sth R5, <#[R1 + 88]> */
		/* 820F186Ch case   14:*/		cpu::mem::store16( regs, regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 820F186Ch case   14:*/		return 0x820F1870;
		  /* 820F1870h */ case   15:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 820F1870h case   15:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 820F1870h case   15:*/		return 0x820F1874;
		  /* 820F1874h */ case   16:  		/* addi R10, R10, 1 */
		/* 820F1874h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F1874h case   16:*/		return 0x820F1878;
		  /* 820F1878h */ case   17:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 820F1878h case   17:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 820F1878h case   17:*/		return 0x820F187C;
		  /* 820F187Ch */ case   18:  		/* sth R10, <#[R1 + 90]> */
		/* 820F187Ch case   18:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x0000005A) );
		/* 820F187Ch case   18:*/		return 0x820F1880;
		  /* 820F1880h */ case   19:  		/* lwz R11, <#[R11 + 12]> */
		/* 820F1880h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F1880h case   19:*/		return 0x820F1884;
		  /* 820F1884h */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 820F1884h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F1884h case   20:*/		return 0x820F1888;
		  /* 820F1888h */ case   21:  		/* bc 4, CR6_EQ, -24 */
		/* 820F1888h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820F1870;  }
		/* 820F1888h case   21:*/		return 0x820F188C;
		  /* 820F188Ch */ case   22:  		/* rlwinm R3, R10, 3, 13, 28 */
		/* 820F188Ch case   22:*/		cpu::op::rlwinm<0,3,13,28>(regs,&regs.R3,regs.R10);
		/* 820F188Ch case   22:*/		return 0x820F1890;
		  /* 820F1890h */ case   23:  		/* lis R4, 9345 */
		/* 820F1890h case   23:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F1890h case   23:*/		return 0x820F1894;
		  /* 820F1894h */ case   24:  		/* bl -431764 */
		/* 820F1894h case   24:*/		regs.LR = 0x820F1898; return 0x82088200;
		/* 820F1894h case   24:*/		return 0x820F1898;
		  /* 820F1898h */ case   25:  		/* or. R27, R3, R3 */
		/* 820F1898h case   25:*/		cpu::op::or<1>(regs,&regs.R27,regs.R3,regs.R3);
		/* 820F1898h case   25:*/		return 0x820F189C;
		  /* 820F189Ch */ case   26:  		/* bc 4, CR0_EQ, 16 */
		/* 820F189Ch case   26:*/		if ( !regs.CR[0].eq ) { return 0x820F18AC;  }
		/* 820F189Ch case   26:*/		return 0x820F18A0;
		  /* 820F18A0h */ case   27:  		/* lis R3, -32761 */
		/* 820F18A0h case   27:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820F18A0h case   27:*/		return 0x820F18A4;
		  /* 820F18A4h */ case   28:  		/* ori R3, R3, 14 */
		/* 820F18A4h case   28:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820F18A4h case   28:*/		return 0x820F18A8;
		  /* 820F18A8h */ case   29:  		/* b 224 */
		/* 820F18A8h case   29:*/		return 0x820F1988;
		/* 820F18A8h case   29:*/		return 0x820F18AC;
	}
	return 0x820F18AC;
} // Block from 820F1834h-820F18ACh (30 instructions)

//////////////////////////////////////////////////////
// Block at 820F18ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F18AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F18AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F18AC);
		  /* 820F18ACh */ case    0:  		/* mr R30, R27 */
		/* 820F18ACh case    0:*/		regs.R30 = regs.R27;
		/* 820F18ACh case    0:*/		return 0x820F18B0;
		  /* 820F18B0h */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F18B0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F18B0h case    1:*/		return 0x820F18B4;
		  /* 820F18B4h */ case    2:  		/* li R8, 1 */
		/* 820F18B4h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F18B4h case    2:*/		return 0x820F18B8;
		  /* 820F18B8h */ case    3:  		/* mr R7, R30 */
		/* 820F18B8h case    3:*/		regs.R7 = regs.R30;
		/* 820F18B8h case    3:*/		return 0x820F18BC;
		  /* 820F18BCh */ case    4:  		/* li R6, 7 */
		/* 820F18BCh case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 820F18BCh case    4:*/		return 0x820F18C0;
		  /* 820F18C0h */ case    5:  		/* li R5, -1 */
		/* 820F18C0h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 820F18C0h case    5:*/		return 0x820F18C4;
		  /* 820F18C4h */ case    6:  		/* mr R3, R26 */
		/* 820F18C4h case    6:*/		regs.R3 = regs.R26;
		/* 820F18C4h case    6:*/		return 0x820F18C8;
		  /* 820F18C8h */ case    7:  		/* lwz R10, <#[R11 + 20]> */
		/* 820F18C8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820F18C8h case    7:*/		return 0x820F18CC;
		  /* 820F18CCh */ case    8:  		/* lwz R28, <#[R11 + 24]> */
		/* 820F18CCh case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000018) );
		/* 820F18CCh case    8:*/		return 0x820F18D0;
		  /* 820F18D0h */ case    9:  		/* lwz R4, <#[R10 + 24]> */
		/* 820F18D0h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000018) );
		/* 820F18D0h case    9:*/		return 0x820F18D4;
		  /* 820F18D4h */ case   10:  		/* bl -144996 */
		/* 820F18D4h case   10:*/		regs.LR = 0x820F18D8; return 0x820CE270;
		/* 820F18D4h case   10:*/		return 0x820F18D8;
		  /* 820F18D8h */ case   11:  		/* or. R29, R3, R3 */
		/* 820F18D8h case   11:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F18D8h case   11:*/		return 0x820F18DC;
		  /* 820F18DCh */ case   12:  		/* bc 12, CR0_LT, 112 */
		/* 820F18DCh case   12:*/		if ( regs.CR[0].lt ) { return 0x820F194C;  }
		/* 820F18DCh case   12:*/		return 0x820F18E0;
		  /* 820F18E0h */ case   13:  		/* addi R7, R30, 4 */
		/* 820F18E0h case   13:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R30,0x4);
		/* 820F18E0h case   13:*/		return 0x820F18E4;
		  /* 820F18E4h */ case   14:  		/* lwz R4, <#[R28 + 48]> */
		/* 820F18E4h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000030) );
		/* 820F18E4h case   14:*/		return 0x820F18E8;
		  /* 820F18E8h */ case   15:  		/* mr R6, R25 */
		/* 820F18E8h case   15:*/		regs.R6 = regs.R25;
		/* 820F18E8h case   15:*/		return 0x820F18EC;
		  /* 820F18ECh */ case   16:  		/* li R5, 1 */
		/* 820F18ECh case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820F18ECh case   16:*/		return 0x820F18F0;
		  /* 820F18F0h */ case   17:  		/* mr R3, R26 */
		/* 820F18F0h case   17:*/		regs.R3 = regs.R26;
		/* 820F18F0h case   17:*/		return 0x820F18F4;
		  /* 820F18F4h */ case   18:  		/* bl -636 */
		/* 820F18F4h case   18:*/		regs.LR = 0x820F18F8; return 0x820F1678;
		/* 820F18F4h case   18:*/		return 0x820F18F8;
		  /* 820F18F8h */ case   19:  		/* or. R29, R3, R3 */
		/* 820F18F8h case   19:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F18F8h case   19:*/		return 0x820F18FC;
		  /* 820F18FCh */ case   20:  		/* bc 12, CR0_LT, 80 */
		/* 820F18FCh case   20:*/		if ( regs.CR[0].lt ) { return 0x820F194C;  }
		/* 820F18FCh case   20:*/		return 0x820F1900;
		  /* 820F1900h */ case   21:  		/* lwz R31, <#[R31 + 12]> */
		/* 820F1900h case   21:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F1900h case   21:*/		return 0x820F1904;
		  /* 820F1904h */ case   22:  		/* addi R30, R30, 8 */
		/* 820F1904h case   22:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x8);
		/* 820F1904h case   22:*/		return 0x820F1908;
		  /* 820F1908h */ case   23:  		/* cmplwi CR6, R31, 0 */
		/* 820F1908h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820F1908h case   23:*/		return 0x820F190C;
		  /* 820F190Ch */ case   24:  		/* bc 4, CR6_EQ, -92 */
		/* 820F190Ch case   24:*/		if ( !regs.CR[6].eq ) { return 0x820F18B0;  }
		/* 820F190Ch case   24:*/		return 0x820F1910;
		  /* 820F1910h */ case   25:  		/* lhz R11, <#[R1 + 90]> */
		/* 820F1910h case   25:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005A) );
		/* 820F1910h case   25:*/		return 0x820F1914;
		  /* 820F1914h */ case   26:  		/* li R8, 6 */
		/* 820F1914h case   26:*/		cpu::op::li<0>(regs,&regs.R8,0x6);
		/* 820F1914h case   26:*/		return 0x820F1918;
		  /* 820F1918h */ case   27:  		/* addi R7, R1, 92 */
		/* 820F1918h case   27:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x5C);
		/* 820F1918h case   27:*/		return 0x820F191C;
		  /* 820F191Ch */ case   28:  		/* li R6, 2 */
		/* 820F191Ch case   28:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 820F191Ch case   28:*/		return 0x820F1920;
		  /* 820F1920h */ case   29:  		/* rlwinm R5, R11, 3, 0, 31 */
		/* 820F1920h case   29:*/		cpu::op::rlwinm<0,3,0,31>(regs,&regs.R5,regs.R11);
		/* 820F1920h case   29:*/		return 0x820F1924;
		  /* 820F1924h */ case   30:  		/* mr R4, R27 */
		/* 820F1924h case   30:*/		regs.R4 = regs.R27;
		/* 820F1924h case   30:*/		return 0x820F1928;
		  /* 820F1928h */ case   31:  		/* mr R3, R26 */
		/* 820F1928h case   31:*/		regs.R3 = regs.R26;
		/* 820F1928h case   31:*/		return 0x820F192C;
		  /* 820F192Ch */ case   32:  		/* bl -145084 */
		/* 820F192Ch case   32:*/		regs.LR = 0x820F1930; return 0x820CE270;
		/* 820F192Ch case   32:*/		return 0x820F1930;
		  /* 820F1930h */ case   33:  		/* or. R31, R3, R3 */
		/* 820F1930h case   33:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F1930h case   33:*/		return 0x820F1934;
		  /* 820F1934h */ case   34:  		/* lis R4, 9345 */
		/* 820F1934h case   34:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F1934h case   34:*/		return 0x820F1938;
		  /* 820F1938h */ case   35:  		/* mr R3, R27 */
		/* 820F1938h case   35:*/		regs.R3 = regs.R27;
		/* 820F1938h case   35:*/		return 0x820F193C;
		  /* 820F193Ch */ case   36:  		/* bc 4, CR0_LT, 36 */
		/* 820F193Ch case   36:*/		if ( !regs.CR[0].lt ) { return 0x820F1960;  }
		/* 820F193Ch case   36:*/		return 0x820F1940;
		  /* 820F1940h */ case   37:  		/* bl -431624 */
		/* 820F1940h case   37:*/		regs.LR = 0x820F1944; return 0x82088338;
		/* 820F1940h case   37:*/		return 0x820F1944;
		  /* 820F1944h */ case   38:  		/* mr R3, R31 */
		/* 820F1944h case   38:*/		regs.R3 = regs.R31;
		/* 820F1944h case   38:*/		return 0x820F1948;
		  /* 820F1948h */ case   39:  		/* b 64 */
		/* 820F1948h case   39:*/		return 0x820F1988;
		/* 820F1948h case   39:*/		return 0x820F194C;
	}
	return 0x820F194C;
} // Block from 820F18ACh-820F194Ch (40 instructions)

//////////////////////////////////////////////////////
// Block at 820F194Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F194C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F194C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F194C);
		  /* 820F194Ch */ case    0:  		/* lis R4, 9345 */
		/* 820F194Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F194Ch case    0:*/		return 0x820F1950;
		  /* 820F1950h */ case    1:  		/* mr R3, R27 */
		/* 820F1950h case    1:*/		regs.R3 = regs.R27;
		/* 820F1950h case    1:*/		return 0x820F1954;
		  /* 820F1954h */ case    2:  		/* bl -431644 */
		/* 820F1954h case    2:*/		regs.LR = 0x820F1958; return 0x82088338;
		/* 820F1954h case    2:*/		return 0x820F1958;
		  /* 820F1958h */ case    3:  		/* mr R3, R29 */
		/* 820F1958h case    3:*/		regs.R3 = regs.R29;
		/* 820F1958h case    3:*/		return 0x820F195C;
		  /* 820F195Ch */ case    4:  		/* b 44 */
		/* 820F195Ch case    4:*/		return 0x820F1988;
		/* 820F195Ch case    4:*/		return 0x820F1960;
	}
	return 0x820F1960;
} // Block from 820F194Ch-820F1960h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F1960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1960);
		  /* 820F1960h */ case    0:  		/* bl -431656 */
		/* 820F1960h case    0:*/		regs.LR = 0x820F1964; return 0x82088338;
		/* 820F1960h case    0:*/		return 0x820F1964;
	}
	return 0x820F1964;
} // Block from 820F1960h-820F1964h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F1964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1964);
		  /* 820F1964h */ case    0:  		/* li R8, 4 */
		/* 820F1964h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 820F1964h case    0:*/		return 0x820F1968;
		  /* 820F1968h */ case    1:  		/* mr R7, R24 */
		/* 820F1968h case    1:*/		regs.R7 = regs.R24;
		/* 820F1968h case    1:*/		return 0x820F196C;
		  /* 820F196Ch */ case    2:  		/* li R6, 2 */
		/* 820F196Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 820F196Ch case    2:*/		return 0x820F1970;
		  /* 820F1970h */ case    3:  		/* li R5, 16 */
		/* 820F1970h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820F1970h case    3:*/		return 0x820F1974;
		  /* 820F1974h */ case    4:  		/* addi R4, R1, 80 */
		/* 820F1974h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F1974h case    4:*/		return 0x820F1978;
		  /* 820F1978h */ case    5:  		/* mr R3, R26 */
		/* 820F1978h case    5:*/		regs.R3 = regs.R26;
		/* 820F1978h case    5:*/		return 0x820F197C;
		  /* 820F197Ch */ case    6:  		/* bl -145164 */
		/* 820F197Ch case    6:*/		regs.LR = 0x820F1980; return 0x820CE270;
		/* 820F197Ch case    6:*/		return 0x820F1980;
		  /* 820F1980h */ case    7:  		/* srawi R11, R3, 31 */
		/* 820F1980h case    7:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820F1980h case    7:*/		return 0x820F1984;
		  /* 820F1984h */ case    8:  		/* and R3, R11, R3 */
		/* 820F1984h case    8:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820F1984h case    8:*/		return 0x820F1988;
	}
	return 0x820F1988;
} // Block from 820F1964h-820F1988h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F1988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1988);
		  /* 820F1988h */ case    0:  		/* addi R1, R1, 176 */
		/* 820F1988h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820F1988h case    0:*/		return 0x820F198C;
		  /* 820F198Ch */ case    1:  		/* b -394996 */
		/* 820F198Ch case    1:*/		return 0x82091298;
		/* 820F198Ch case    1:*/		return 0x820F1990;
	}
	return 0x820F1990;
} // Block from 820F1988h-820F1990h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F1990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1990);
		  /* 820F1990h */ case    0:  		/* mfspr R12, LR */
		/* 820F1990h case    0:*/		regs.R12 = regs.LR;
		/* 820F1990h case    0:*/		return 0x820F1994;
		  /* 820F1994h */ case    1:  		/* bl -395064 */
		/* 820F1994h case    1:*/		regs.LR = 0x820F1998; return 0x8209125C;
		/* 820F1994h case    1:*/		return 0x820F1998;
		  /* 820F1998h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820F1998h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820F1998h case    2:*/		return 0x820F199C;
		  /* 820F199Ch */ case    3:  		/* lwz R10, <#[R3 + 280]> */
		/* 820F199Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000118) );
		/* 820F199Ch case    3:*/		return 0x820F19A0;
		  /* 820F19A0h */ case    4:  		/* mr R31, R3 */
		/* 820F19A0h case    4:*/		regs.R31 = regs.R3;
		/* 820F19A0h case    4:*/		return 0x820F19A4;
		  /* 820F19A4h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 820F19A4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F19A4h case    5:*/		return 0x820F19A8;
		  /* 820F19A8h */ case    6:  		/* mr R30, R10 */
		/* 820F19A8h case    6:*/		regs.R30 = regs.R10;
		/* 820F19A8h case    6:*/		return 0x820F19AC;
		  /* 820F19ACh */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 820F19ACh case    7:*/		if ( !regs.CR[6].eq ) { return 0x820F19B4;  }
		/* 820F19ACh case    7:*/		return 0x820F19B0;
		  /* 820F19B0h */ case    8:  		/* li R30, 1024 */
		/* 820F19B0h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x400);
		/* 820F19B0h case    8:*/		return 0x820F19B4;
	}
	return 0x820F19B4;
} // Block from 820F1990h-820F19B4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F19B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F19B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F19B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F19B4);
		  /* 820F19B4h */ case    0:  		/* lwz R11, <#[R31 + 276]> */
		/* 820F19B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820F19B4h case    0:*/		return 0x820F19B8;
		  /* 820F19B8h */ case    1:  		/* add R11, R4, R11 */
		/* 820F19B8h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 820F19B8h case    1:*/		return 0x820F19BC;
		  /* 820F19BCh */ case    2:  		/* cmplw CR6, R11, R30 */
		/* 820F19BCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820F19BCh case    2:*/		return 0x820F19C0;
		  /* 820F19C0h */ case    3:  		/* bc 4, CR6_GT, 24 */
		/* 820F19C0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820F19D8;  }
		/* 820F19C0h case    3:*/		return 0x820F19C4;
		  /* 820F19C4h */ case    4:  		/* lwz R11, <#[R31 + 276]> */
		/* 820F19C4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820F19C4h case    4:*/		return 0x820F19C8;
	}
	return 0x820F19C8;
} // Block from 820F19B4h-820F19C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F19C8h
// Function '?ResolveFlowControl@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F19C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F19C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F19C8);
		  /* 820F19C8h */ case    0:  		/* add R11, R4, R11 */
		/* 820F19C8h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 820F19C8h case    0:*/		return 0x820F19CC;
		  /* 820F19CCh */ case    1:  		/* rlwinm R30, R30, 1, 0, 30 */
		/* 820F19CCh case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R30,regs.R30);
		/* 820F19CCh case    1:*/		return 0x820F19D0;
		  /* 820F19D0h */ case    2:  		/* cmplw CR6, R11, R30 */
		/* 820F19D0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820F19D0h case    2:*/		return 0x820F19D4;
		  /* 820F19D4h */ case    3:  		/* bc 12, CR6_GT, -8 */
		/* 820F19D4h case    3:*/		if ( regs.CR[6].gt ) { return 0x820F19CC;  }
		/* 820F19D4h case    3:*/		return 0x820F19D8;
	}
	return 0x820F19D8;
} // Block from 820F19C8h-820F19D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F19D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F19D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F19D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F19D8);
		  /* 820F19D8h */ case    0:  		/* cmplw CR6, R30, R10 */
		/* 820F19D8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 820F19D8h case    0:*/		return 0x820F19DC;
		  /* 820F19DCh */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 820F19DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820F1A28;  }
		/* 820F19DCh case    1:*/		return 0x820F19E0;
		  /* 820F19E0h */ case    2:  		/* lis R4, 9345 */
		/* 820F19E0h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F19E0h case    2:*/		return 0x820F19E4;
		  /* 820F19E4h */ case    3:  		/* rlwinm R3, R30, 2, 0, 29 */
		/* 820F19E4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R30);
		/* 820F19E4h case    3:*/		return 0x820F19E8;
		  /* 820F19E8h */ case    4:  		/* bl -432104 */
		/* 820F19E8h case    4:*/		regs.LR = 0x820F19EC; return 0x82088200;
		/* 820F19E8h case    4:*/		return 0x820F19EC;
		  /* 820F19ECh */ case    5:  		/* or. R29, R3, R3 */
		/* 820F19ECh case    5:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F19ECh case    5:*/		return 0x820F19F0;
		  /* 820F19F0h */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 820F19F0h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820F1A00;  }
		/* 820F19F0h case    6:*/		return 0x820F19F4;
		  /* 820F19F4h */ case    7:  		/* lis R3, -32761 */
		/* 820F19F4h case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820F19F4h case    7:*/		return 0x820F19F8;
		  /* 820F19F8h */ case    8:  		/* ori R3, R3, 14 */
		/* 820F19F8h case    8:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820F19F8h case    8:*/		return 0x820F19FC;
		  /* 820F19FCh */ case    9:  		/* b 48 */
		/* 820F19FCh case    9:*/		return 0x820F1A2C;
		/* 820F19FCh case    9:*/		return 0x820F1A00;
	}
	return 0x820F1A00;
} // Block from 820F19D8h-820F1A00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F1A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1A00);
		  /* 820F1A00h */ case    0:  		/* lwz R11, <#[R31 + 276]> */
		/* 820F1A00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820F1A00h case    0:*/		return 0x820F1A04;
		  /* 820F1A04h */ case    1:  		/* mr R3, R29 */
		/* 820F1A04h case    1:*/		regs.R3 = regs.R29;
		/* 820F1A04h case    1:*/		return 0x820F1A08;
		  /* 820F1A08h */ case    2:  		/* lwz R4, <#[R31 + 272]> */
		/* 820F1A08h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000110) );
		/* 820F1A08h case    2:*/		return 0x820F1A0C;
		  /* 820F1A0Ch */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820F1A0Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820F1A0Ch case    3:*/		return 0x820F1A10;
		  /* 820F1A10h */ case    4:  		/* bl -393312 */
		/* 820F1A10h case    4:*/		regs.LR = 0x820F1A14; return 0x820919B0;
		/* 820F1A10h case    4:*/		return 0x820F1A14;
		  /* 820F1A14h */ case    5:  		/* lis R4, 9345 */
		/* 820F1A14h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F1A14h case    5:*/		return 0x820F1A18;
		  /* 820F1A18h */ case    6:  		/* lwz R3, <#[R31 + 272]> */
		/* 820F1A18h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000110) );
		/* 820F1A18h case    6:*/		return 0x820F1A1C;
		  /* 820F1A1Ch */ case    7:  		/* bl -431844 */
		/* 820F1A1Ch case    7:*/		regs.LR = 0x820F1A20; return 0x82088338;
		/* 820F1A1Ch case    7:*/		return 0x820F1A20;
		  /* 820F1A20h */ case    8:  		/* stw R29, <#[R31 + 272]> */
		/* 820F1A20h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000110) );
		/* 820F1A20h case    8:*/		return 0x820F1A24;
		  /* 820F1A24h */ case    9:  		/* stw R30, <#[R31 + 280]> */
		/* 820F1A24h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000118) );
		/* 820F1A24h case    9:*/		return 0x820F1A28;
	}
	return 0x820F1A28;
} // Block from 820F1A00h-820F1A28h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F1A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1A28);
		  /* 820F1A28h */ case    0:  		/* li R3, 0 */
		/* 820F1A28h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F1A28h case    0:*/		return 0x820F1A2C;
	}
	return 0x820F1A2C;
} // Block from 820F1A28h-820F1A2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F1A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1A2C);
		  /* 820F1A2Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820F1A2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820F1A2Ch case    0:*/		return 0x820F1A30;
		  /* 820F1A30h */ case    1:  		/* b -395140 */
		/* 820F1A30h case    1:*/		return 0x820912AC;
		/* 820F1A30h case    1:*/		return 0x820F1A34;
		  /* 820F1A34h */ case    2:  		/* nop */
		/* 820F1A34h case    2:*/		cpu::op::nop();
		/* 820F1A34h case    2:*/		return 0x820F1A38;
	}
	return 0x820F1A38;
} // Block from 820F1A2Ch-820F1A38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F1A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1A38);
		  /* 820F1A38h */ case    0:  		/* mfspr R12, LR */
		/* 820F1A38h case    0:*/		regs.R12 = regs.LR;
		/* 820F1A38h case    0:*/		return 0x820F1A3C;
		  /* 820F1A3Ch */ case    1:  		/* bl -395260 */
		/* 820F1A3Ch case    1:*/		regs.LR = 0x820F1A40; return 0x82091240;
		/* 820F1A3Ch case    1:*/		return 0x820F1A40;
		  /* 820F1A40h */ case    2:  		/* stfd FR31, <#[R1 - 96]> */
		/* 820F1A40h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 820F1A40h case    2:*/		return 0x820F1A44;
		  /* 820F1A44h */ case    3:  		/* stwu R1, <#[R1 - 176]> */
		/* 820F1A44h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820F1A44h case    3:*/		return 0x820F1A48;
		  /* 820F1A48h */ case    4:  		/* li R24, 0 */
		/* 820F1A48h case    4:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820F1A48h case    4:*/		return 0x820F1A4C;
		  /* 820F1A4Ch */ case    5:  		/* mr R31, R3 */
		/* 820F1A4Ch case    5:*/		regs.R31 = regs.R3;
		/* 820F1A4Ch case    5:*/		return 0x820F1A50;
		  /* 820F1A50h */ case    6:  		/* mr R26, R4 */
		/* 820F1A50h case    6:*/		regs.R26 = regs.R4;
		/* 820F1A50h case    6:*/		return 0x820F1A54;
		  /* 820F1A54h */ case    7:  		/* mr R22, R5 */
		/* 820F1A54h case    7:*/		regs.R22 = regs.R5;
		/* 820F1A54h case    7:*/		return 0x820F1A58;
		  /* 820F1A58h */ case    8:  		/* mr R23, R6 */
		/* 820F1A58h case    8:*/		regs.R23 = regs.R6;
		/* 820F1A58h case    8:*/		return 0x820F1A5C;
		  /* 820F1A5Ch */ case    9:  		/* mr R28, R7 */
		/* 820F1A5Ch case    9:*/		regs.R28 = regs.R7;
		/* 820F1A5Ch case    9:*/		return 0x820F1A60;
		  /* 820F1A60h */ case   10:  		/* mr R30, R8 */
		/* 820F1A60h case   10:*/		regs.R30 = regs.R8;
		/* 820F1A60h case   10:*/		return 0x820F1A64;
		  /* 820F1A64h */ case   11:  		/* cmplwi CR6, R8, 0 */
		/* 820F1A64h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820F1A64h case   11:*/		return 0x820F1A68;
		  /* 820F1A68h */ case   12:  		/* mr R25, R24 */
		/* 820F1A68h case   12:*/		regs.R25 = regs.R24;
		/* 820F1A68h case   12:*/		return 0x820F1A6C;
		  /* 820F1A6Ch */ case   13:  		/* mr R9, R24 */
		/* 820F1A6Ch case   13:*/		regs.R9 = regs.R24;
		/* 820F1A6Ch case   13:*/		return 0x820F1A70;
		  /* 820F1A70h */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 820F1A70h case   14:*/		if ( regs.CR[6].eq ) { return 0x820F1A98;  }
		/* 820F1A70h case   14:*/		return 0x820F1A74;
		  /* 820F1A74h */ case   15:  		/* lwz R10, <#[R3 + 340]> */
		/* 820F1A74h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000154) );
		/* 820F1A74h case   15:*/		return 0x820F1A78;
		  /* 820F1A78h */ case   16:  		/* mr R11, R7 */
		/* 820F1A78h case   16:*/		regs.R11 = regs.R7;
		/* 820F1A78h case   16:*/		return 0x820F1A7C;
		  /* 820F1A7Ch */ case   17:  		/* mtspr CTR, R8 */
		/* 820F1A7Ch case   17:*/		regs.CTR = regs.R8;
		/* 820F1A7Ch case   17:*/		return 0x820F1A80;
		  /* 820F1A80h */ case   18:  		/* lwz R8, <#[R11]> */
		/* 820F1A80h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820F1A80h case   18:*/		return 0x820F1A84;
		  /* 820F1A84h */ case   19:  		/* cmplw CR6, R10, R8 */
		/* 820F1A84h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820F1A84h case   19:*/		return 0x820F1A88;
		  /* 820F1A88h */ case   20:  		/* bc 4, CR6_EQ, 8 */
		/* 820F1A88h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820F1A90;  }
		/* 820F1A88h case   20:*/		return 0x820F1A8C;
		  /* 820F1A8Ch */ case   21:  		/* li R9, 1 */
		/* 820F1A8Ch case   21:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820F1A8Ch case   21:*/		return 0x820F1A90;
	}
	return 0x820F1A90;
} // Block from 820F1A38h-820F1A90h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F1A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1A90);
		  /* 820F1A90h */ case    0:  		/* addi R11, R11, 4 */
		/* 820F1A90h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F1A90h case    0:*/		return 0x820F1A94;
		  /* 820F1A94h */ case    1:  		/* bc 16, CR0_LT, -20 */
		/* 820F1A94h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F1A80;  }
		/* 820F1A94h case    1:*/		return 0x820F1A98;
	}
	return 0x820F1A98;
} // Block from 820F1A90h-820F1A98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F1A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1A98);
		  /* 820F1A98h */ case    0:  		/* lwz R11, <#[R31 + 336]> */
		/* 820F1A98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 820F1A98h case    0:*/		return 0x820F1A9C;
		  /* 820F1A9Ch */ case    1:  		/* cmplw CR6, R11, R26 */
		/* 820F1A9Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820F1A9Ch case    1:*/		return 0x820F1AA0;
		  /* 820F1AA0h */ case    2:  		/* bc 4, CR6_GT, 12 */
		/* 820F1AA0h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820F1AAC;  }
		/* 820F1AA0h case    2:*/		return 0x820F1AA4;
		  /* 820F1AA4h */ case    3:  		/* cmpwi CR6, R9, 0 */
		/* 820F1AA4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820F1AA4h case    3:*/		return 0x820F1AA8;
		  /* 820F1AA8h */ case    4:  		/* bc 12, CR6_EQ, 384 */
		/* 820F1AA8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820F1C28;  }
		/* 820F1AA8h case    4:*/		return 0x820F1AAC;
	}
	return 0x820F1AAC;
} // Block from 820F1A98h-820F1AACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F1AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1AAC);
		  /* 820F1AACh */ case    0:  		/* li R29, -1 */
		/* 820F1AACh case    0:*/		cpu::op::li<0>(regs,&regs.R29,0xFFFFFFFF);
		/* 820F1AACh case    0:*/		return 0x820F1AB0;
		  /* 820F1AB0h */ case    1:  		/* lis R4, 9345 */
		/* 820F1AB0h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F1AB0h case    1:*/		return 0x820F1AB4;
		  /* 820F1AB4h */ case    2:  		/* stw R29, <#[R31 + 320]> */
		/* 820F1AB4h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000140) );
		/* 820F1AB4h case    2:*/		return 0x820F1AB8;
		  /* 820F1AB8h */ case    3:  		/* mr R11, R29 */
		/* 820F1AB8h case    3:*/		regs.R11 = regs.R29;
		/* 820F1AB8h case    3:*/		return 0x820F1ABC;
		  /* 820F1ABCh */ case    4:  		/* stw R29, <#[R31 + 324]> */
		/* 820F1ABCh case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000144) );
		/* 820F1ABCh case    4:*/		return 0x820F1AC0;
		  /* 820F1AC0h */ case    5:  		/* addi R10, R31, 320 */
		/* 820F1AC0h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x140);
		/* 820F1AC0h case    5:*/		return 0x820F1AC4;
		  /* 820F1AC4h */ case    6:  		/* stw R29, <#[R31 + 328]> */
		/* 820F1AC4h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000148) );
		/* 820F1AC4h case    6:*/		return 0x820F1AC8;
		  /* 820F1AC8h */ case    7:  		/* stw R29, <#[R31 + 332]> */
		/* 820F1AC8h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000014C) );
		/* 820F1AC8h case    7:*/		return 0x820F1ACC;
		  /* 820F1ACCh */ case    8:  		/* lwz R11, <#[R31 + 44]> */
		/* 820F1ACCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820F1ACCh case    8:*/		return 0x820F1AD0;
		  /* 820F1AD0h */ case    9:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820F1AD0h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820F1AD0h case    9:*/		return 0x820F1AD4;
		  /* 820F1AD4h */ case   10:  		/* bl -432340 */
		/* 820F1AD4h case   10:*/		regs.LR = 0x820F1AD8; return 0x82088200;
		/* 820F1AD4h case   10:*/		return 0x820F1AD8;
		  /* 820F1AD8h */ case   11:  		/* or. R25, R3, R3 */
		/* 820F1AD8h case   11:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 820F1AD8h case   11:*/		return 0x820F1ADC;
		  /* 820F1ADCh */ case   12:  		/* bc 12, CR0_EQ, 660 */
		/* 820F1ADCh case   12:*/		if ( regs.CR[0].eq ) { return 0x820F1D70;  }
		/* 820F1ADCh case   12:*/		return 0x820F1AE0;
		  /* 820F1AE0h */ case   13:  		/* lwz R11, <#[R31 + 44]> */
		/* 820F1AE0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820F1AE0h case   13:*/		return 0x820F1AE4;
		  /* 820F1AE4h */ case   14:  		/* li R4, 255 */
		/* 820F1AE4h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 820F1AE4h case   14:*/		return 0x820F1AE8;
		  /* 820F1AE8h */ case   15:  		/* mr R3, R25 */
		/* 820F1AE8h case   15:*/		regs.R3 = regs.R25;
		/* 820F1AE8h case   15:*/		return 0x820F1AEC;
		  /* 820F1AECh */ case   16:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820F1AECh case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820F1AECh case   16:*/		return 0x820F1AF0;
		  /* 820F1AF0h */ case   17:  		/* bl -395184 */
		/* 820F1AF0h case   17:*/		regs.LR = 0x820F1AF4; return 0x82091340;
		/* 820F1AF0h case   17:*/		return 0x820F1AF4;
		  /* 820F1AF4h */ case   18:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F1AF4h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F1AF4h case   18:*/		return 0x820F1AF8;
		  /* 820F1AF8h */ case   19:  		/* mr R8, R24 */
		/* 820F1AF8h case   19:*/		regs.R8 = regs.R24;
		/* 820F1AF8h case   19:*/		return 0x820F1AFC;
		  /* 820F1AFCh */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 820F1AFCh case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F1AFCh case   20:*/		return 0x820F1B00;
		  /* 820F1B00h */ case   21:  		/* bc 4, CR6_GT, 148 */
		/* 820F1B00h case   21:*/		if ( !regs.CR[6].gt ) { return 0x820F1B94;  }
		/* 820F1B00h case   21:*/		return 0x820F1B04;
		  /* 820F1B04h */ case   22:  		/* mr R9, R24 */
		/* 820F1B04h case   22:*/		regs.R9 = regs.R24;
		/* 820F1B04h case   22:*/		return 0x820F1B08;
		  /* 820F1B08h */ case   23:  		/* lwz R11, <#[R31 + 20]> */
		/* 820F1B08h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1B08h case   23:*/		return 0x820F1B0C;
		  /* 820F1B0Ch */ case   24:  		/* lwz R10, <#[R31 + 136]> */
		/* 820F1B0Ch case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000088) );
		/* 820F1B0Ch case   24:*/		return 0x820F1B10;
		  /* 820F1B10h */ case   25:  		/* lwzx R11, <#[R9 + R11]> */
		/* 820F1B10h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F1B10h case   25:*/		return 0x820F1B14;
		  /* 820F1B14h */ case   26:  		/* lwz R7, <#[R11 + 4]> */
		/* 820F1B14h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 820F1B14h case   26:*/		return 0x820F1B18;
		  /* 820F1B18h */ case   27:  		/* cmplw CR6, R10, R7 */
		/* 820F1B18h case   27:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820F1B18h case   27:*/		return 0x820F1B1C;
		  /* 820F1B1Ch */ case   28:  		/* bc 4, CR6_EQ, 100 */
		/* 820F1B1Ch case   28:*/		if ( !regs.CR[6].eq ) { return 0x820F1B80;  }
		/* 820F1B1Ch case   28:*/		return 0x820F1B20;
		  /* 820F1B20h */ case   29:  		/* lwz R10, <#[R11 + 8]> */
		/* 820F1B20h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820F1B20h case   29:*/		return 0x820F1B24;
		  /* 820F1B24h */ case   30:  		/* cmpwi CR6, R10, -1 */
		/* 820F1B24h case   30:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820F1B24h case   30:*/		return 0x820F1B28;
		  /* 820F1B28h */ case   31:  		/* bc 4, CR6_EQ, 88 */
		/* 820F1B28h case   31:*/		if ( !regs.CR[6].eq ) { return 0x820F1B80;  }
		/* 820F1B28h case   31:*/		return 0x820F1B2C;
		  /* 820F1B2Ch */ case   32:  		/* lwz R7, <#[R31 + 44]> */
		/* 820F1B2Ch case   32:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000002C) );
		/* 820F1B2Ch case   32:*/		return 0x820F1B30;
		  /* 820F1B30h */ case   33:  		/* lwz R10, <#[R11 + 12]> */
		/* 820F1B30h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F1B30h case   33:*/		return 0x820F1B34;
		  /* 820F1B34h */ case   34:  		/* cmplw CR6, R10, R7 */
		/* 820F1B34h case   34:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820F1B34h case   34:*/		return 0x820F1B38;
		  /* 820F1B38h */ case   35:  		/* bc 4, CR6_LT, 72 */
		/* 820F1B38h case   35:*/		if ( !regs.CR[6].lt ) { return 0x820F1B80;  }
		/* 820F1B38h case   35:*/		return 0x820F1B3C;
		  /* 820F1B3Ch */ case   36:  		/* lwz R7, <#[R11 + 72]> */
		/* 820F1B3Ch case   36:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000048) );
		/* 820F1B3Ch case   36:*/		return 0x820F1B40;
		  /* 820F1B40h */ case   37:  		/* cmplw CR6, R7, R26 */
		/* 820F1B40h case   37:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R26);
		/* 820F1B40h case   37:*/		return 0x820F1B44;
		  /* 820F1B44h */ case   38:  		/* bc 4, CR6_LT, 24 */
		/* 820F1B44h case   38:*/		if ( !regs.CR[6].lt ) { return 0x820F1B5C;  }
		/* 820F1B44h case   38:*/		return 0x820F1B48;
		  /* 820F1B48h */ case   39:  		/* lwz R7, <#[R11 + 88]> */
		/* 820F1B48h case   39:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000058) );
		/* 820F1B48h case   39:*/		return 0x820F1B4C;
		  /* 820F1B4Ch */ case   40:  		/* cmplw CR6, R7, R26 */
		/* 820F1B4Ch case   40:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R26);
		/* 820F1B4Ch case   40:*/		return 0x820F1B50;
		  /* 820F1B50h */ case   41:  		/* bc 12, CR6_LT, 12 */
		/* 820F1B50h case   41:*/		if ( regs.CR[6].lt ) { return 0x820F1B5C;  }
		/* 820F1B50h case   41:*/		return 0x820F1B54;
		  /* 820F1B54h */ case   42:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F1B54h case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F1B54h case   42:*/		return 0x820F1B58;
		  /* 820F1B58h */ case   43:  		/* stwx R24, <#[R10 + R25]> */
		/* 820F1B58h case   43:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 820F1B58h case   43:*/		return 0x820F1B5C;
	}
	return 0x820F1B5C;
} // Block from 820F1AACh-820F1B5Ch (44 instructions)

//////////////////////////////////////////////////////
// Block at 820F1B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1B5C);
		  /* 820F1B5Ch */ case    0:  		/* lwz R10, <#[R11 + 72]> */
		/* 820F1B5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000048) );
		/* 820F1B5Ch case    0:*/		return 0x820F1B60;
		  /* 820F1B60h */ case    1:  		/* cmplw CR6, R10, R26 */
		/* 820F1B60h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R26);
		/* 820F1B60h case    1:*/		return 0x820F1B64;
		  /* 820F1B64h */ case    2:  		/* bc 12, CR6_LT, 28 */
		/* 820F1B64h case    2:*/		if ( regs.CR[6].lt ) { return 0x820F1B80;  }
		/* 820F1B64h case    2:*/		return 0x820F1B68;
		  /* 820F1B68h */ case    3:  		/* lwz R11, <#[R11 + 12]> */
		/* 820F1B68h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F1B68h case    3:*/		return 0x820F1B6C;
		  /* 820F1B6Ch */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F1B6Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F1B6Ch case    4:*/		return 0x820F1B70;
		  /* 820F1B70h */ case    5:  		/* lwzx R7, <#[R11 + R25]> */
		/* 820F1B70h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 820F1B70h case    5:*/		return 0x820F1B74;
		  /* 820F1B74h */ case    6:  		/* cmplw CR6, R10, R7 */
		/* 820F1B74h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820F1B74h case    6:*/		return 0x820F1B78;
		  /* 820F1B78h */ case    7:  		/* bc 4, CR6_LT, 8 */
		/* 820F1B78h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820F1B80;  }
		/* 820F1B78h case    7:*/		return 0x820F1B7C;
		  /* 820F1B7Ch */ case    8:  		/* stwx R10, <#[R11 + R25]> */
		/* 820F1B7Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 820F1B7Ch case    8:*/		return 0x820F1B80;
	}
	return 0x820F1B80;
} // Block from 820F1B5Ch-820F1B80h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F1B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1B80);
		  /* 820F1B80h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F1B80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F1B80h case    0:*/		return 0x820F1B84;
		  /* 820F1B84h */ case    1:  		/* addi R8, R8, 1 */
		/* 820F1B84h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F1B84h case    1:*/		return 0x820F1B88;
		  /* 820F1B88h */ case    2:  		/* addi R9, R9, 4 */
		/* 820F1B88h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F1B88h case    2:*/		return 0x820F1B8C;
		  /* 820F1B8Ch */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 820F1B8Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820F1B8Ch case    3:*/		return 0x820F1B90;
		  /* 820F1B90h */ case    4:  		/* bc 12, CR6_LT, -136 */
		/* 820F1B90h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F1B08;  }
		/* 820F1B90h case    4:*/		return 0x820F1B94;
	}
	return 0x820F1B94;
} // Block from 820F1B80h-820F1B94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F1B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1B94);
		  /* 820F1B94h */ case    0:  		/* lwz R7, <#[R31 + 44]> */
		/* 820F1B94h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000002C) );
		/* 820F1B94h case    0:*/		return 0x820F1B98;
		  /* 820F1B98h */ case    1:  		/* mr R9, R24 */
		/* 820F1B98h case    1:*/		regs.R9 = regs.R24;
		/* 820F1B98h case    1:*/		return 0x820F1B9C;
		  /* 820F1B9Ch */ case    2:  		/* stw R24, <#[R31 + 336]> */
		/* 820F1B9Ch case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000150) );
		/* 820F1B9Ch case    2:*/		return 0x820F1BA0;
		  /* 820F1BA0h */ case    3:  		/* cmplwi CR6, R7, 0 */
		/* 820F1BA0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820F1BA0h case    3:*/		return 0x820F1BA4;
		  /* 820F1BA4h */ case    4:  		/* stw R24, <#[R31 + 340]> */
		/* 820F1BA4h case    4:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000154) );
		/* 820F1BA4h case    4:*/		return 0x820F1BA8;
		  /* 820F1BA8h */ case    5:  		/* bc 12, CR6_EQ, 108 */
		/* 820F1BA8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820F1C14;  }
		/* 820F1BA8h case    5:*/		return 0x820F1BAC;
		  /* 820F1BACh */ case    6:  		/* mr R8, R25 */
		/* 820F1BACh case    6:*/		regs.R8 = regs.R25;
		/* 820F1BACh case    6:*/		return 0x820F1BB0;
		  /* 820F1BB0h */ case    7:  		/* mr R11, R24 */
		/* 820F1BB0h case    7:*/		regs.R11 = regs.R24;
		/* 820F1BB0h case    7:*/		return 0x820F1BB4;
		  /* 820F1BB4h */ case    8:  		/* cmplwi CR6, R30, 0 */
		/* 820F1BB4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F1BB4h case    8:*/		return 0x820F1BB8;
		  /* 820F1BB8h */ case    9:  		/* bc 12, CR6_EQ, 44 */
		/* 820F1BB8h case    9:*/		if ( regs.CR[6].eq ) { return 0x820F1BE4;  }
		/* 820F1BB8h case    9:*/		return 0x820F1BBC;
		  /* 820F1BBCh */ case   10:  		/* mr R10, R28 */
		/* 820F1BBCh case   10:*/		regs.R10 = regs.R28;
		/* 820F1BBCh case   10:*/		return 0x820F1BC0;
		  /* 820F1BC0h */ case   11:  		/* lwz R6, <#[R10]> */
		/* 820F1BC0h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820F1BC0h case   11:*/		return 0x820F1BC4;
		  /* 820F1BC4h */ case   12:  		/* cmplw CR6, R9, R6 */
		/* 820F1BC4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 820F1BC4h case   12:*/		return 0x820F1BC8;
		  /* 820F1BC8h */ case   13:  		/* bc 12, CR6_EQ, 20 */
		/* 820F1BC8h case   13:*/		if ( regs.CR[6].eq ) { return 0x820F1BDC;  }
		/* 820F1BC8h case   13:*/		return 0x820F1BCC;
		  /* 820F1BCCh */ case   14:  		/* addi R11, R11, 1 */
		/* 820F1BCCh case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F1BCCh case   14:*/		return 0x820F1BD0;
		  /* 820F1BD0h */ case   15:  		/* addi R10, R10, 4 */
		/* 820F1BD0h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F1BD0h case   15:*/		return 0x820F1BD4;
		  /* 820F1BD4h */ case   16:  		/* cmplw CR6, R11, R30 */
		/* 820F1BD4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820F1BD4h case   16:*/		return 0x820F1BD8;
		  /* 820F1BD8h */ case   17:  		/* bc 12, CR6_LT, -24 */
		/* 820F1BD8h case   17:*/		if ( regs.CR[6].lt ) { return 0x820F1BC0;  }
		/* 820F1BD8h case   17:*/		return 0x820F1BDC;
	}
	return 0x820F1BDC;
} // Block from 820F1B94h-820F1BDCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 820F1BDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1BDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1BDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1BDC);
		  /* 820F1BDCh */ case    0:  		/* cmplw CR6, R11, R30 */
		/* 820F1BDCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820F1BDCh case    0:*/		return 0x820F1BE0;
		  /* 820F1BE0h */ case    1:  		/* bc 12, CR6_LT, 32 */
		/* 820F1BE0h case    1:*/		if ( regs.CR[6].lt ) { return 0x820F1C00;  }
		/* 820F1BE0h case    1:*/		return 0x820F1BE4;
	}
	return 0x820F1BE4;
} // Block from 820F1BDCh-820F1BE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F1BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1BE4);
		  /* 820F1BE4h */ case    0:  		/* lwz R11, <#[R8]> */
		/* 820F1BE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820F1BE4h case    0:*/		return 0x820F1BE8;
		  /* 820F1BE8h */ case    1:  		/* lwz R10, <#[R31 + 336]> */
		/* 820F1BE8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000150) );
		/* 820F1BE8h case    1:*/		return 0x820F1BEC;
		  /* 820F1BECh */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 820F1BECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820F1BECh case    2:*/		return 0x820F1BF0;
		  /* 820F1BF0h */ case    3:  		/* bc 4, CR6_LT, 16 */
		/* 820F1BF0h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820F1C00;  }
		/* 820F1BF0h case    3:*/		return 0x820F1BF4;
		  /* 820F1BF4h */ case    4:  		/* stw R9, <#[R31 + 340]> */
		/* 820F1BF4h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000154) );
		/* 820F1BF4h case    4:*/		return 0x820F1BF8;
		  /* 820F1BF8h */ case    5:  		/* lwz R11, <#[R8]> */
		/* 820F1BF8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820F1BF8h case    5:*/		return 0x820F1BFC;
		  /* 820F1BFCh */ case    6:  		/* stw R11, <#[R31 + 336]> */
		/* 820F1BFCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 820F1BFCh case    6:*/		return 0x820F1C00;
	}
	return 0x820F1C00;
} // Block from 820F1BE4h-820F1C00h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F1C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1C00);
		  /* 820F1C00h */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 820F1C00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820F1C00h case    0:*/		return 0x820F1C04;
		  /* 820F1C04h */ case    1:  		/* addi R9, R9, 1 */
		/* 820F1C04h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F1C04h case    1:*/		return 0x820F1C08;
		  /* 820F1C08h */ case    2:  		/* addi R8, R8, 4 */
		/* 820F1C08h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820F1C08h case    2:*/		return 0x820F1C0C;
		  /* 820F1C0Ch */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 820F1C0Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820F1C0Ch case    3:*/		return 0x820F1C10;
		  /* 820F1C10h */ case    4:  		/* bc 12, CR6_LT, -96 */
		/* 820F1C10h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F1BB0;  }
		/* 820F1C10h case    4:*/		return 0x820F1C14;
	}
	return 0x820F1C14;
} // Block from 820F1C00h-820F1C14h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F1C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1C14);
		  /* 820F1C14h */ case    0:  		/* lwz R11, <#[R31 + 336]> */
		/* 820F1C14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 820F1C14h case    0:*/		return 0x820F1C18;
		  /* 820F1C18h */ case    1:  		/* cmplw CR6, R11, R26 */
		/* 820F1C18h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820F1C18h case    1:*/		return 0x820F1C1C;
		  /* 820F1C1Ch */ case    2:  		/* bc 12, CR6_GT, 12 */
		/* 820F1C1Ch case    2:*/		if ( regs.CR[6].gt ) { return 0x820F1C28;  }
		/* 820F1C1Ch case    2:*/		return 0x820F1C20;
		  /* 820F1C20h */ case    3:  		/* stw R7, <#[R31 + 340]> */
		/* 820F1C20h case    3:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000154) );
		/* 820F1C20h case    3:*/		return 0x820F1C24;
		  /* 820F1C24h */ case    4:  		/* stw R29, <#[R31 + 336]> */
		/* 820F1C24h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000150) );
		/* 820F1C24h case    4:*/		return 0x820F1C28;
	}
	return 0x820F1C28;
} // Block from 820F1C14h-820F1C28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F1C28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1C28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1C28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1C28);
		  /* 820F1C28h */ case    0:  		/* addi R11, R23, -1 */
		/* 820F1C28h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R23,0xFFFFFFFF);
		/* 820F1C28h case    0:*/		return 0x820F1C2C;
		  /* 820F1C2Ch */ case    1:  		/* li R10, 3 */
		/* 820F1C2Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820F1C2Ch case    1:*/		return 0x820F1C30;
		  /* 820F1C30h */ case    2:  		/* addic R11, R11, -1 */
		/* 820F1C30h case    2:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820F1C30h case    2:*/		return 0x820F1C34;
		  /* 820F1C34h */ case    3:  		/* mr R27, R24 */
		/* 820F1C34h case    3:*/		regs.R27 = regs.R24;
		/* 820F1C34h case    3:*/		return 0x820F1C38;
		  /* 820F1C38h */ case    4:  		/* subfe R11, R11, R11 */
		/* 820F1C38h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820F1C38h case    4:*/		return 0x820F1C3C;
		  /* 820F1C3Ch */ case    5:  		/* cmplwi CR6, R23, 0 */
		/* 820F1C3Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820F1C3Ch case    5:*/		return 0x820F1C40;
		  /* 820F1C40h */ case    6:  		/* and R29, R11, R10 */
		/* 820F1C40h case    6:*/		cpu::op::and<0>(regs,&regs.R29,regs.R11,regs.R10);
		/* 820F1C40h case    6:*/		return 0x820F1C44;
		  /* 820F1C44h */ case    7:  		/* bc 12, CR6_EQ, 268 */
		/* 820F1C44h case    7:*/		if ( regs.CR[6].eq ) { return 0x820F1D50;  }
		/* 820F1C44h case    7:*/		return 0x820F1C48;
		  /* 820F1C48h */ case    8:  		/* addi R11, R29, 80 */
		/* 820F1C48h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x50);
		/* 820F1C48h case    8:*/		return 0x820F1C4C;
		  /* 820F1C4Ch */ case    9:  		/* mr R28, R22 */
		/* 820F1C4Ch case    9:*/		regs.R28 = regs.R22;
		/* 820F1C4Ch case    9:*/		return 0x820F1C50;
		  /* 820F1C50h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F1C50h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F1C50h case   10:*/		return 0x820F1C54;
		  /* 820F1C54h */ case   11:  		/* add R30, R11, R31 */
		/* 820F1C54h case   11:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R31);
		/* 820F1C54h case   11:*/		return 0x820F1C58;
		  /* 820F1C58h */ case   12:  		/* lis R11, -32256 */
		/* 820F1C58h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820F1C58h case   12:*/		return 0x820F1C5C;
		  /* 820F1C5Ch */ case   13:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 820F1C5Ch case   13:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 820F1C5Ch case   13:*/		return 0x820F1C60;
		  /* 820F1C60h */ case   14:  		/* lwz R11, <#[R30]> */
		/* 820F1C60h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F1C60h case   14:*/		return 0x820F1C64;
		  /* 820F1C64h */ case   15:  		/* cmpwi CR6, R11, -1 */
		/* 820F1C64h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820F1C64h case   15:*/		return 0x820F1C68;
		  /* 820F1C68h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 820F1C68h case   16:*/		if ( regs.CR[6].eq ) { return 0x820F1C7C;  }
		/* 820F1C68h case   16:*/		return 0x820F1C6C;
		  /* 820F1C6Ch */ case   17:  		/* lwz R10, <#[R31 + 20]> */
		/* 820F1C6Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1C6Ch case   17:*/		return 0x820F1C70;
		  /* 820F1C70h */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F1C70h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F1C70h case   18:*/		return 0x820F1C74;
		  /* 820F1C74h */ case   19:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F1C74h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F1C74h case   19:*/		return 0x820F1C78;
		  /* 820F1C78h */ case   20:  		/* stw R26, <#[R11 + 80]> */
		/* 820F1C78h case   20:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000050) );
		/* 820F1C78h case   20:*/		return 0x820F1C7C;
	}
	return 0x820F1C7C;
} // Block from 820F1C28h-820F1C7Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820F1C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1C7C);
		  /* 820F1C7Ch */ case    0:  		/* mr R6, R29 */
		/* 820F1C7Ch case    0:*/		regs.R6 = regs.R29;
		/* 820F1C7Ch case    0:*/		return 0x820F1C80;
		  /* 820F1C80h */ case    1:  		/* lwz R5, <#[R31 + 340]> */
		/* 820F1C80h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000154) );
		/* 820F1C80h case    1:*/		return 0x820F1C84;
		  /* 820F1C84h */ case    2:  		/* mr R3, R31 */
		/* 820F1C84h case    2:*/		regs.R3 = regs.R31;
		/* 820F1C84h case    2:*/		return 0x820F1C88;
		  /* 820F1C88h */ case    3:  		/* lwz R4, <#[R31 + 136]> */
		/* 820F1C88h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000088) );
		/* 820F1C88h case    3:*/		return 0x820F1C8C;
		  /* 820F1C8Ch */ case    4:  		/* fmr FR1, FR31 */
		/* 820F1C8Ch case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820F1C8Ch case    4:*/		return 0x820F1C90;
		  /* 820F1C90h */ case    5:  		/* bl 46488 */
		/* 820F1C90h case    5:*/		regs.LR = 0x820F1C94; return 0x820FD228;
		/* 820F1C90h case    5:*/		return 0x820F1C94;
		  /* 820F1C94h */ case    6:  		/* stw R3, <#[R30]> */
		/* 820F1C94h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820F1C94h case    6:*/		return 0x820F1C98;
		  /* 820F1C98h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 820F1C98h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820F1C98h case    7:*/		return 0x820F1C9C;
		  /* 820F1C9Ch */ case    8:  		/* bc 12, CR6_EQ, 212 */
		/* 820F1C9Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820F1D70;  }
		/* 820F1C9Ch case    8:*/		return 0x820F1CA0;
		  /* 820F1CA0h */ case    9:  		/* lwz R11, <#[R31 + 20]> */
		/* 820F1CA0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1CA0h case    9:*/		return 0x820F1CA4;
		  /* 820F1CA4h */ case   10:  		/* rlwinm R9, R3, 2, 0, 29 */
		/* 820F1CA4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R3);
		/* 820F1CA4h case   10:*/		return 0x820F1CA8;
		  /* 820F1CA8h */ case   11:  		/* li R8, 1 */
		/* 820F1CA8h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F1CA8h case   11:*/		return 0x820F1CAC;
		  /* 820F1CACh */ case   12:  		/* rlwinm R10, R26, 2, 0, 29 */
		/* 820F1CACh case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R26);
		/* 820F1CACh case   12:*/		return 0x820F1CB0;
		  /* 820F1CB0h */ case   13:  		/* lwzx R11, <#[R9 + R11]> */
		/* 820F1CB0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F1CB0h case   13:*/		return 0x820F1CB4;
		  /* 820F1CB4h */ case   14:  		/* stw R24, <#[R11 + 60]> */
		/* 820F1CB4h case   14:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F1CB4h case   14:*/		return 0x820F1CB8;
		  /* 820F1CB8h */ case   15:  		/* stw R24, <#[R11 + 48]> */
		/* 820F1CB8h case   15:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000030) );
		/* 820F1CB8h case   15:*/		return 0x820F1CBC;
		  /* 820F1CBCh */ case   16:  		/* stw R26, <#[R11 + 72]> */
		/* 820F1CBCh case   16:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000048) );
		/* 820F1CBCh case   16:*/		return 0x820F1CC0;
		  /* 820F1CC0h */ case   17:  		/* lwz R9, <#[R31 + 336]> */
		/* 820F1CC0h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000150) );
		/* 820F1CC0h case   17:*/		return 0x820F1CC4;
		  /* 820F1CC4h */ case   18:  		/* stw R9, <#[R11 + 80]> */
		/* 820F1CC4h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000050) );
		/* 820F1CC4h case   18:*/		return 0x820F1CC8;
		  /* 820F1CC8h */ case   19:  		/* stw R26, <#[R11 + 84]> */
		/* 820F1CC8h case   19:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000054) );
		/* 820F1CC8h case   19:*/		return 0x820F1CCC;
		  /* 820F1CCCh */ case   20:  		/* stw R26, <#[R11 + 88]> */
		/* 820F1CCCh case   20:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000058) );
		/* 820F1CCCh case   20:*/		return 0x820F1CD0;
		  /* 820F1CD0h */ case   21:  		/* stw R8, <#[R11 + 92]> */
		/* 820F1CD0h case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000005C) );
		/* 820F1CD0h case   21:*/		return 0x820F1CD4;
		  /* 820F1CD4h */ case   22:  		/* lwz R9, <#[R31 + 24]> */
		/* 820F1CD4h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 820F1CD4h case   22:*/		return 0x820F1CD8;
		  /* 820F1CD8h */ case   23:  		/* lwzx R9, <#[R10 + R9]> */
		/* 820F1CD8h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F1CD8h case   23:*/		return 0x820F1CDC;
		  /* 820F1CDCh */ case   24:  		/* lwz R8, <#[R9 + 12]> */
		/* 820F1CDCh case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 820F1CDCh case   24:*/		return 0x820F1CE0;
		  /* 820F1CE0h */ case   25:  		/* cmplwi CR6, R8, 0 */
		/* 820F1CE0h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820F1CE0h case   25:*/		return 0x820F1CE4;
		  /* 820F1CE4h */ case   26:  		/* bc 12, CR6_EQ, 68 */
		/* 820F1CE4h case   26:*/		if ( regs.CR[6].eq ) { return 0x820F1D28;  }
		/* 820F1CE4h case   26:*/		return 0x820F1CE8;
		  /* 820F1CE8h */ case   27:  		/* lwz R9, <#[R9 + 16]> */
		/* 820F1CE8h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000010) );
		/* 820F1CE8h case   27:*/		return 0x820F1CEC;
		  /* 820F1CECh */ case   28:  		/* lwz R8, <#[R31 + 20]> */
		/* 820F1CECh case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1CECh case   28:*/		return 0x820F1CF0;
		  /* 820F1CF0h */ case   29:  		/* lwz R9, <#[R9]> */
		/* 820F1CF0h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 820F1CF0h case   29:*/		return 0x820F1CF4;
		  /* 820F1CF4h */ case   30:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F1CF4h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F1CF4h case   30:*/		return 0x820F1CF8;
		  /* 820F1CF8h */ case   31:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820F1CF8h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820F1CF8h case   31:*/		return 0x820F1CFC;
		  /* 820F1CFCh */ case   32:  		/* lwz R9, <#[R9 + 24]> */
		/* 820F1CFCh case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 820F1CFCh case   32:*/		return 0x820F1D00;
		  /* 820F1D00h */ case   33:  		/* stw R9, <#[R11 + 24]> */
		/* 820F1D00h case   33:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000018) );
		/* 820F1D00h case   33:*/		return 0x820F1D04;
		  /* 820F1D04h */ case   34:  		/* lwz R9, <#[R31 + 24]> */
		/* 820F1D04h case   34:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 820F1D04h case   34:*/		return 0x820F1D08;
		  /* 820F1D08h */ case   35:  		/* lwz R8, <#[R31 + 20]> */
		/* 820F1D08h case   35:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 820F1D08h case   35:*/		return 0x820F1D0C;
		  /* 820F1D0Ch */ case   36:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820F1D0Ch case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F1D0Ch case   36:*/		return 0x820F1D10;
		  /* 820F1D10h */ case   37:  		/* lwz R10, <#[R10 + 16]> */
		/* 820F1D10h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820F1D10h case   37:*/		return 0x820F1D14;
		  /* 820F1D14h */ case   38:  		/* lwz R10, <#[R10]> */
		/* 820F1D14h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820F1D14h case   38:*/		return 0x820F1D18;
		  /* 820F1D18h */ case   39:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F1D18h case   39:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F1D18h case   39:*/		return 0x820F1D1C;
		  /* 820F1D1Ch */ case   40:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820F1D1Ch case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820F1D1Ch case   40:*/		return 0x820F1D20;
		  /* 820F1D20h */ case   41:  		/* lwz R10, <#[R10 + 20]> */
		/* 820F1D20h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820F1D20h case   41:*/		return 0x820F1D24;
		  /* 820F1D24h */ case   42:  		/* stw R10, <#[R11 + 20]> */
		/* 820F1D24h case   42:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820F1D24h case   42:*/		return 0x820F1D28;
	}
	return 0x820F1D28;
} // Block from 820F1C7Ch-820F1D28h (43 instructions)

//////////////////////////////////////////////////////
// Block at 820F1D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1D28);
		  /* 820F1D28h */ case    0:  		/* cmplwi CR6, R22, 0 */
		/* 820F1D28h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820F1D28h case    0:*/		return 0x820F1D2C;
		  /* 820F1D2Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820F1D2Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820F1D38;  }
		/* 820F1D2Ch case    1:*/		return 0x820F1D30;
		  /* 820F1D30h */ case    2:  		/* lwz R11, <#[R30]> */
		/* 820F1D30h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F1D30h case    2:*/		return 0x820F1D34;
		  /* 820F1D34h */ case    3:  		/* stw R11, <#[R28]> */
		/* 820F1D34h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820F1D34h case    3:*/		return 0x820F1D38;
	}
	return 0x820F1D38;
} // Block from 820F1D28h-820F1D38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F1D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1D38);
		  /* 820F1D38h */ case    0:  		/* addi R27, R27, 1 */
		/* 820F1D38h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820F1D38h case    0:*/		return 0x820F1D3C;
		  /* 820F1D3Ch */ case    1:  		/* addi R29, R29, 1 */
		/* 820F1D3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820F1D3Ch case    1:*/		return 0x820F1D40;
		  /* 820F1D40h */ case    2:  		/* addi R30, R30, 4 */
		/* 820F1D40h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820F1D40h case    2:*/		return 0x820F1D44;
		  /* 820F1D44h */ case    3:  		/* addi R28, R28, 4 */
		/* 820F1D44h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820F1D44h case    3:*/		return 0x820F1D48;
		  /* 820F1D48h */ case    4:  		/* cmplw CR6, R27, R23 */
		/* 820F1D48h case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R23);
		/* 820F1D48h case    4:*/		return 0x820F1D4C;
		  /* 820F1D4Ch */ case    5:  		/* bc 12, CR6_LT, -236 */
		/* 820F1D4Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x820F1C60;  }
		/* 820F1D4Ch case    5:*/		return 0x820F1D50;
	}
	return 0x820F1D50;
} // Block from 820F1D38h-820F1D50h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F1D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1D50);
		  /* 820F1D50h */ case    0:  		/* mr R31, R24 */
		/* 820F1D50h case    0:*/		regs.R31 = regs.R24;
		/* 820F1D50h case    0:*/		return 0x820F1D54;
		  /* 820F1D54h */ case    1:  		/* lis R4, 9345 */
		/* 820F1D54h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F1D54h case    1:*/		return 0x820F1D58;
		  /* 820F1D58h */ case    2:  		/* mr R3, R25 */
		/* 820F1D58h case    2:*/		regs.R3 = regs.R25;
		/* 820F1D58h case    2:*/		return 0x820F1D5C;
		  /* 820F1D5Ch */ case    3:  		/* bl -432676 */
		/* 820F1D5Ch case    3:*/		regs.LR = 0x820F1D60; return 0x82088338;
		/* 820F1D5Ch case    3:*/		return 0x820F1D60;
		  /* 820F1D60h */ case    4:  		/* mr R3, R31 */
		/* 820F1D60h case    4:*/		regs.R3 = regs.R31;
		/* 820F1D60h case    4:*/		return 0x820F1D64;
		  /* 820F1D64h */ case    5:  		/* addi R1, R1, 176 */
		/* 820F1D64h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820F1D64h case    5:*/		return 0x820F1D68;
		  /* 820F1D68h */ case    6:  		/* lfd FR31, <#[R1 - 96]> */
		/* 820F1D68h case    6:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 820F1D68h case    6:*/		return 0x820F1D6C;
		  /* 820F1D6Ch */ case    7:  		/* b -395996 */
		/* 820F1D6Ch case    7:*/		return 0x82091290;
		/* 820F1D6Ch case    7:*/		return 0x820F1D70;
	}
	return 0x820F1D70;
} // Block from 820F1D50h-820F1D70h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F1D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1D70);
		  /* 820F1D70h */ case    0:  		/* lis R31, -32761 */
		/* 820F1D70h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820F1D70h case    0:*/		return 0x820F1D74;
		  /* 820F1D74h */ case    1:  		/* ori R31, R31, 14 */
		/* 820F1D74h case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820F1D74h case    1:*/		return 0x820F1D78;
		  /* 820F1D78h */ case    2:  		/* b -36 */
		/* 820F1D78h case    2:*/		return 0x820F1D54;
		/* 820F1D78h case    2:*/		return 0x820F1D7C;
		  /* 820F1D7Ch */ case    3:  		/* nop */
		/* 820F1D7Ch case    3:*/		cpu::op::nop();
		/* 820F1D7Ch case    3:*/		return 0x820F1D80;
		  /* 820F1D80h */ case    4:  		/* mr R11, R3 */
		/* 820F1D80h case    4:*/		regs.R11 = regs.R3;
		/* 820F1D80h case    4:*/		return 0x820F1D84;
		  /* 820F1D84h */ case    5:  		/* lwz R10, <#[R3 + 248]> */
		/* 820F1D84h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000000F8) );
		/* 820F1D84h case    5:*/		return 0x820F1D88;
		  /* 820F1D88h */ case    6:  		/* li R3, 0 */
		/* 820F1D88h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F1D88h case    6:*/		return 0x820F1D8C;
		  /* 820F1D8Ch */ case    7:  		/* li R8, 0 */
		/* 820F1D8Ch case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F1D8Ch case    7:*/		return 0x820F1D90;
		  /* 820F1D90h */ case    8:  		/* addi R9, R1, -16 */
		/* 820F1D90h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFFF0);
		/* 820F1D90h case    8:*/		return 0x820F1D94;
		  /* 820F1D94h */ case    9:  		/* lwz R7, <#[R11 + 244]> */
		/* 820F1D94h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x000000F4) );
		/* 820F1D94h case    9:*/		return 0x820F1D98;
		  /* 820F1D98h */ case   10:  		/* lwz R11, <#[R11 + 252]> */
		/* 820F1D98h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000FC) );
		/* 820F1D98h case   10:*/		return 0x820F1D9C;
		  /* 820F1D9Ch */ case   11:  		/* stw R10, <#[R1 - 16]> */
		/* 820F1D9Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F1D9Ch case   11:*/		return 0x820F1DA0;
		  /* 820F1DA0h */ case   12:  		/* stw R7, <#[R1 - 12]> */
		/* 820F1DA0h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 820F1DA0h case   12:*/		return 0x820F1DA4;
		  /* 820F1DA4h */ case   13:  		/* stw R11, <#[R1 - 8]> */
		/* 820F1DA4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F1DA4h case   13:*/		return 0x820F1DA8;
		  /* 820F1DA8h */ case   14:  		/* lwz R10, <#[R9]> */
		/* 820F1DA8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820F1DA8h case   14:*/		return 0x820F1DAC;
		  /* 820F1DACh */ case   15:  		/* cmplwi CR6, R10, 0 */
		/* 820F1DACh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F1DACh case   15:*/		return 0x820F1DB0;
		  /* 820F1DB0h */ case   16:  		/* bc 12, CR6_EQ, 48 */
		/* 820F1DB0h case   16:*/		if ( regs.CR[6].eq ) { return 0x820F1DE0;  }
		/* 820F1DB0h case   16:*/		return 0x820F1DB4;
		  /* 820F1DB4h */ case   17:  		/* lwz R11, <#[R10 + 16]> */
		/* 820F1DB4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820F1DB4h case   17:*/		return 0x820F1DB8;
		  /* 820F1DB8h */ case   18:  		/* mr R3, R10 */
		/* 820F1DB8h case   18:*/		regs.R3 = regs.R10;
		/* 820F1DB8h case   18:*/		return 0x820F1DBC;
		  /* 820F1DBCh */ case   19:  		/* b 20 */
		/* 820F1DBCh case   19:*/		return 0x820F1DD0;
		/* 820F1DBCh case   19:*/		return 0x820F1DC0;
		  /* 820F1DC0h */ case   20:  		/* cmplw CR6, R11, R4 */
		/* 820F1DC0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 820F1DC0h case   20:*/		return 0x820F1DC4;
		  /* 820F1DC4h */ case   21:  		/* bc 12, CR6_EQ, 20 */
		/* 820F1DC4h case   21:*/		if ( regs.CR[6].eq ) { return 0x820F1DD8;  }
		/* 820F1DC4h case   21:*/		return 0x820F1DC8;
		  /* 820F1DC8h */ case   22:  		/* addi R3, R3, 36 */
		/* 820F1DC8h case   22:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x24);
		/* 820F1DC8h case   22:*/		return 0x820F1DCC;
		  /* 820F1DCCh */ case   23:  		/* lwz R11, <#[R3 + 16]> */
		/* 820F1DCCh case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820F1DCCh case   23:*/		return 0x820F1DD0;
	}
	return 0x820F1DD0;
} // Block from 820F1D70h-820F1DD0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F1DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1DD0);
		  /* 820F1DD0h */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 820F1DD0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820F1DD0h case    0:*/		return 0x820F1DD4;
		  /* 820F1DD4h */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 820F1DD4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F1DC0;  }
		/* 820F1DD4h case    1:*/		return 0x820F1DD8;
	}
	return 0x820F1DD8;
} // Block from 820F1DD0h-820F1DD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F1DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1DD8);
		  /* 820F1DD8h */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 820F1DD8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820F1DD8h case    0:*/		return 0x820F1DDC;
		  /* 820F1DDCh */ case    1:  		/* bclr 4, CR6_EQ */
		/* 820F1DDCh case    1:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820F1DDCh case    1:*/		return 0x820F1DE0;
	}
	return 0x820F1DE0;
} // Block from 820F1DD8h-820F1DE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F1DE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1DE0);
		  /* 820F1DE0h */ case    0:  		/* addi R8, R8, 1 */
		/* 820F1DE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F1DE0h case    0:*/		return 0x820F1DE4;
		  /* 820F1DE4h */ case    1:  		/* addi R9, R9, 4 */
		/* 820F1DE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F1DE4h case    1:*/		return 0x820F1DE8;
		  /* 820F1DE8h */ case    2:  		/* cmplwi CR6, R8, 3 */
		/* 820F1DE8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000003);
		/* 820F1DE8h case    2:*/		return 0x820F1DEC;
		  /* 820F1DECh */ case    3:  		/* bc 12, CR6_LT, -68 */
		/* 820F1DECh case    3:*/		if ( regs.CR[6].lt ) { return 0x820F1DA8;  }
		/* 820F1DECh case    3:*/		return 0x820F1DF0;
		  /* 820F1DF0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820F1DF0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F1DF0h case    4:*/		return 0x820F1DF4;
	}
	return 0x820F1DF4;
} // Block from 820F1DE0h-820F1DF4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F1DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1DF4);
		  /* 820F1DF4h */ case    0:  		/* nop */
		/* 820F1DF4h case    0:*/		cpu::op::nop();
		/* 820F1DF4h case    0:*/		return 0x820F1DF8;
	}
	return 0x820F1DF8;
} // Block from 820F1DF4h-820F1DF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F1DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1DF8);
		  /* 820F1DF8h */ case    0:  		/* mfspr R12, LR */
		/* 820F1DF8h case    0:*/		regs.R12 = regs.LR;
		/* 820F1DF8h case    0:*/		return 0x820F1DFC;
		  /* 820F1DFCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F1DFCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F1DFCh case    1:*/		return 0x820F1E00;
		  /* 820F1E00h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820F1E00h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F1E00h case    2:*/		return 0x820F1E04;
		  /* 820F1E04h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820F1E04h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F1E04h case    3:*/		return 0x820F1E08;
		  /* 820F1E08h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820F1E08h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820F1E08h case    4:*/		return 0x820F1E0C;
		  /* 820F1E0Ch */ case    5:  		/* mr R31, R3 */
		/* 820F1E0Ch case    5:*/		regs.R31 = regs.R3;
		/* 820F1E0Ch case    5:*/		return 0x820F1E10;
		  /* 820F1E10h */ case    6:  		/* mr R30, R4 */
		/* 820F1E10h case    6:*/		regs.R30 = regs.R4;
		/* 820F1E10h case    6:*/		return 0x820F1E14;
		  /* 820F1E14h */ case    7:  		/* bl -16660 */
		/* 820F1E14h case    7:*/		regs.LR = 0x820F1E18; return 0x820EDD00;
		/* 820F1E14h case    7:*/		return 0x820F1E18;
	}
	return 0x820F1E18;
} // Block from 820F1DF8h-820F1E18h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F1E18h
// Function '?EmitTypeInfo@D3DXShader@@YAJPAVCCommentBlock@1@PAVCNode@1@IKPAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1E18);
		  /* 820F1E18h */ case    0:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 820F1E18h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 820F1E18h case    0:*/		return 0x820F1E1C;
		  /* 820F1E1Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820F1E1Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820F1E2C;  }
		/* 820F1E1Ch case    1:*/		return 0x820F1E20;
		  /* 820F1E20h */ case    2:  		/* lis R4, 9345 */
		/* 820F1E20h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F1E20h case    2:*/		return 0x820F1E24;
		  /* 820F1E24h */ case    3:  		/* mr R3, R31 */
		/* 820F1E24h case    3:*/		regs.R3 = regs.R31;
		/* 820F1E24h case    3:*/		return 0x820F1E28;
		  /* 820F1E28h */ case    4:  		/* bl -432880 */
		/* 820F1E28h case    4:*/		regs.LR = 0x820F1E2C; return 0x82088338;
		/* 820F1E28h case    4:*/		return 0x820F1E2C;
	}
	return 0x820F1E2C;
} // Block from 820F1E18h-820F1E2Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F1E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1E2C);
		  /* 820F1E2Ch */ case    0:  		/* mr R3, R31 */
		/* 820F1E2Ch case    0:*/		regs.R3 = regs.R31;
		/* 820F1E2Ch case    0:*/		return 0x820F1E30;
		  /* 820F1E30h */ case    1:  		/* addi R1, R1, 112 */
		/* 820F1E30h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820F1E30h case    1:*/		return 0x820F1E34;
		  /* 820F1E34h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F1E34h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F1E34h case    2:*/		return 0x820F1E38;
		  /* 820F1E38h */ case    3:  		/* mtspr LR, R12 */
		/* 820F1E38h case    3:*/		regs.LR = regs.R12;
		/* 820F1E38h case    3:*/		return 0x820F1E3C;
		  /* 820F1E3Ch */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820F1E3Ch case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F1E3Ch case    4:*/		return 0x820F1E40;
		  /* 820F1E40h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820F1E40h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F1E40h case    5:*/		return 0x820F1E44;
		  /* 820F1E44h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820F1E44h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F1E44h case    6:*/		return 0x820F1E48;
	}
	return 0x820F1E48;
} // Block from 820F1E2Ch-820F1E48h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F1E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1E48);
		  /* 820F1E48h */ case    0:  		/* mfspr R12, LR */
		/* 820F1E48h case    0:*/		regs.R12 = regs.LR;
		/* 820F1E48h case    0:*/		return 0x820F1E4C;
		  /* 820F1E4Ch */ case    1:  		/* bl -396300 */
		/* 820F1E4Ch case    1:*/		regs.LR = 0x820F1E50; return 0x82091240;
		/* 820F1E4Ch case    1:*/		return 0x820F1E50;
		  /* 820F1E50h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 820F1E50h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 820F1E50h case    2:*/		return 0x820F1E54;
		  /* 820F1E54h */ case    3:  		/* li R27, 0 */
		/* 820F1E54h case    3:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820F1E54h case    3:*/		return 0x820F1E58;
		  /* 820F1E58h */ case    4:  		/* mr R25, R3 */
		/* 820F1E58h case    4:*/		regs.R25 = regs.R3;
		/* 820F1E58h case    4:*/		return 0x820F1E5C;
		  /* 820F1E5Ch */ case    5:  		/* stw R27, <#[R7]> */
		/* 820F1E5Ch case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R7 + 0x00000000) );
		/* 820F1E5Ch case    5:*/		return 0x820F1E60;
		  /* 820F1E60h */ case    6:  		/* mr R31, R4 */
		/* 820F1E60h case    6:*/		regs.R31 = regs.R4;
		/* 820F1E60h case    6:*/		return 0x820F1E64;
		  /* 820F1E64h */ case    7:  		/* lwz R9, <#[R4 + 104]> */
		/* 820F1E64h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000068) );
		/* 820F1E64h case    7:*/		return 0x820F1E68;
		  /* 820F1E68h */ case    8:  		/* mr R26, R5 */
		/* 820F1E68h case    8:*/		regs.R26 = regs.R5;
		/* 820F1E68h case    8:*/		return 0x820F1E6C;
		  /* 820F1E6Ch */ case    9:  		/* lwz R8, <#[R4]> */
		/* 820F1E6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 820F1E6Ch case    9:*/		return 0x820F1E70;
		  /* 820F1E70h */ case   10:  		/* rlwinm R8, R8, 0, 2, 0 */
		/* 820F1E70h case   10:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R8,regs.R8);
		/* 820F1E70h case   10:*/		return 0x820F1E74;
		  /* 820F1E74h */ case   11:  		/* stw R8, <#[R4]> */
		/* 820F1E74h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 820F1E74h case   11:*/		return 0x820F1E78;
		  /* 820F1E78h */ case   12:  		/* mr R22, R6 */
		/* 820F1E78h case   12:*/		regs.R22 = regs.R6;
		/* 820F1E78h case   12:*/		return 0x820F1E7C;
		  /* 820F1E7Ch */ case   13:  		/* lwz R30, <#[R9 + 24]> */
		/* 820F1E7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000018) );
		/* 820F1E7Ch case   13:*/		return 0x820F1E80;
		  /* 820F1E80h */ case   14:  		/* mr R23, R7 */
		/* 820F1E80h case   14:*/		regs.R23 = regs.R7;
		/* 820F1E80h case   14:*/		return 0x820F1E84;
		  /* 820F1E84h */ case   15:  		/* li R10, 63 */
		/* 820F1E84h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x3F);
		/* 820F1E84h case   15:*/		return 0x820F1E88;
		  /* 820F1E88h */ case   16:  		/* mr R24, R27 */
		/* 820F1E88h case   16:*/		regs.R24 = regs.R27;
		/* 820F1E88h case   16:*/		return 0x820F1E8C;
		  /* 820F1E8Ch */ case   17:  		/* addi R11, R1, 80 */
		/* 820F1E8Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820F1E8Ch case   17:*/		return 0x820F1E90;
		  /* 820F1E90h */ case   18:  		/* mr R9, R30 */
		/* 820F1E90h case   18:*/		regs.R9 = regs.R30;
		/* 820F1E90h case   18:*/		return 0x820F1E94;
		  /* 820F1E94h */ case   19:  		/* lbz R8, <#[R9]> */
		/* 820F1E94h case   19:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820F1E94h case   19:*/		return 0x820F1E98;
		  /* 820F1E98h */ case   20:  		/* cmplwi CR0, R8, 0 */
		/* 820F1E98h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R8,0x00000000);
		/* 820F1E98h case   20:*/		return 0x820F1E9C;
		  /* 820F1E9Ch */ case   21:  		/* bc 12, CR0_EQ, 24 */
		/* 820F1E9Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x820F1EB4;  }
		/* 820F1E9Ch case   21:*/		return 0x820F1EA0;
		  /* 820F1EA0h */ case   22:  		/* stb R8, <#[R11]> */
		/* 820F1EA0h case   22:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820F1EA0h case   22:*/		return 0x820F1EA4;
		  /* 820F1EA4h */ case   23:  		/* addic. R10, R10, -1 */
		/* 820F1EA4h case   23:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820F1EA4h case   23:*/		return 0x820F1EA8;
		  /* 820F1EA8h */ case   24:  		/* addi R11, R11, 1 */
		/* 820F1EA8h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F1EA8h case   24:*/		return 0x820F1EAC;
		  /* 820F1EACh */ case   25:  		/* addi R9, R9, 1 */
		/* 820F1EACh case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F1EACh case   25:*/		return 0x820F1EB0;
		  /* 820F1EB0h */ case   26:  		/* bc 4, CR0_EQ, -28 */
		/* 820F1EB0h case   26:*/		if ( !regs.CR[0].eq ) { return 0x820F1E94;  }
		/* 820F1EB0h case   26:*/		return 0x820F1EB4;
	}
	return 0x820F1EB4;
} // Block from 820F1E48h-820F1EB4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820F1EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1EB4);
		  /* 820F1EB4h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820F1EB4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F1EB4h case    0:*/		return 0x820F1EB8;
		  /* 820F1EB8h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 820F1EB8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F1EC0;  }
		/* 820F1EB8h case    1:*/		return 0x820F1EBC;
		  /* 820F1EBCh */ case    2:  		/* addi R11, R11, -1 */
		/* 820F1EBCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820F1EBCh case    2:*/		return 0x820F1EC0;
	}
	return 0x820F1EC0;
} // Block from 820F1EB4h-820F1EC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F1EC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1EC0);
		  /* 820F1EC0h */ case    0:  		/* stb R27, <#[R11]> */
		/* 820F1EC0h case    0:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 820F1EC0h case    0:*/		return 0x820F1EC4;
		  /* 820F1EC4h */ case    1:  		/* addi R10, R1, 80 */
		/* 820F1EC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 820F1EC4h case    1:*/		return 0x820F1EC8;
		  /* 820F1EC8h */ case    2:  		/* lbz R11, <#[R1 + 80]> */
		/* 820F1EC8h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F1EC8h case    2:*/		return 0x820F1ECC;
		  /* 820F1ECCh */ case    3:  		/* b 20 */
		/* 820F1ECCh case    3:*/		return 0x820F1EE0;
		/* 820F1ECCh case    3:*/		return 0x820F1ED0;
		  /* 820F1ED0h */ case    4:  		/* lbz R11, <#[R10]> */
		/* 820F1ED0h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F1ED0h case    4:*/		return 0x820F1ED4;
		  /* 820F1ED4h */ case    5:  		/* cmplwi CR6, R11, 95 */
		/* 820F1ED4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820F1ED4h case    5:*/		return 0x820F1ED8;
		  /* 820F1ED8h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 820F1ED8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F1EE8;  }
		/* 820F1ED8h case    6:*/		return 0x820F1EDC;
		  /* 820F1EDCh */ case    7:  		/* lbzu R11, <#[R10 + 1]> */
		/* 820F1EDCh case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000001) );
		regs.R10 = (uint32)(regs.R10 + 0x00000001);
		/* 820F1EDCh case    7:*/		return 0x820F1EE0;
	}
	return 0x820F1EE0;
} // Block from 820F1EC0h-820F1EE0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F1EE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1EE0);
		  /* 820F1EE0h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 820F1EE0h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820F1EE0h case    0:*/		return 0x820F1EE4;
		  /* 820F1EE4h */ case    1:  		/* bc 4, CR0_EQ, -20 */
		/* 820F1EE4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820F1ED0;  }
		/* 820F1EE4h case    1:*/		return 0x820F1EE8;
	}
	return 0x820F1EE8;
} // Block from 820F1EE0h-820F1EE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F1EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1EE8);
		  /* 820F1EE8h */ case    0:  		/* lbz R11, <#[R10]> */
		/* 820F1EE8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F1EE8h case    0:*/		return 0x820F1EEC;
		  /* 820F1EECh */ case    1:  		/* cmplwi CR6, R11, 95 */
		/* 820F1EECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820F1EECh case    1:*/		return 0x820F1EF0;
		  /* 820F1EF0h */ case    2:  		/* bc 4, CR6_EQ, 36 */
		/* 820F1EF0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F1F14;  }
		/* 820F1EF0h case    2:*/		return 0x820F1EF4;
		  /* 820F1EF4h */ case    3:  		/* stb R27, <#[R10]> */
		/* 820F1EF4h case    3:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R10 + 0x00000000) );
		/* 820F1EF4h case    3:*/		return 0x820F1EF8;
		  /* 820F1EF8h */ case    4:  		/* lis R11, -32255 */
		/* 820F1EF8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820F1EF8h case    4:*/		return 0x820F1EFC;
		  /* 820F1EFCh */ case    5:  		/* addi R3, R10, 1 */
		/* 820F1EFCh case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0x1);
		/* 820F1EFCh case    5:*/		return 0x820F1F00;
		  /* 820F1F00h */ case    6:  		/* addi R4, R11, 4936 */
		/* 820F1F00h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1348);
		/* 820F1F00h case    6:*/		return 0x820F1F04;
		  /* 820F1F04h */ case    7:  		/* bl -387796 */
		/* 820F1F04h case    7:*/		regs.LR = 0x820F1F08; return 0x82093430;
		/* 820F1F04h case    7:*/		return 0x820F1F08;
		  /* 820F1F08h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820F1F08h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F1F08h case    8:*/		return 0x820F1F0C;
		  /* 820F1F0Ch */ case    9:  		/* bc 4, CR0_EQ, 20 */
		/* 820F1F0Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x820F1F20;  }
		/* 820F1F0Ch case    9:*/		return 0x820F1F10;
		  /* 820F1F10h */ case   10:  		/* li R24, 1 */
		/* 820F1F10h case   10:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 820F1F10h case   10:*/		return 0x820F1F14;
	}
	return 0x820F1F14;
} // Block from 820F1EE8h-820F1F14h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F1F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1F14);
		  /* 820F1F14h */ case    0:  		/* lbz R11, <#[R1 + 80]> */
		/* 820F1F14h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F1F14h case    0:*/		return 0x820F1F18;
		  /* 820F1F18h */ case    1:  		/* addi R30, R1, 80 */
		/* 820F1F18h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x50);
		/* 820F1F18h case    1:*/		return 0x820F1F1C;
		  /* 820F1F1Ch */ case    2:  		/* b 72 */
		/* 820F1F1Ch case    2:*/		return 0x820F1F64;
		/* 820F1F1Ch case    2:*/		return 0x820F1F20;
	}
	return 0x820F1F20;
} // Block from 820F1F14h-820F1F20h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F1F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1F20);
		  /* 820F1F20h */ case    0:  		/* li R11, 1 */
		/* 820F1F20h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820F1F20h case    0:*/		return 0x820F1F24;
		  /* 820F1F24h */ case    1:  		/* lis R10, -32254 */
		/* 820F1F24h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820F1F24h case    1:*/		return 0x820F1F28;
		  /* 820F1F28h */ case    2:  		/* stw R11, <#[R23]> */
		/* 820F1F28h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 820F1F28h case    2:*/		return 0x820F1F2C;
		  /* 820F1F2Ch */ case    3:  		/* mr R7, R30 */
		/* 820F1F2Ch case    3:*/		regs.R7 = regs.R30;
		/* 820F1F2Ch case    3:*/		return 0x820F1F30;
		  /* 820F1F30h */ case    4:  		/* stw R27, <#[R31 + 108]> */
		/* 820F1F30h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F1F30h case    4:*/		return 0x820F1F34;
		  /* 820F1F34h */ case    5:  		/* addi R6, R10, -16300 */
		/* 820F1F34h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFC054);
		/* 820F1F34h case    5:*/		return 0x820F1F38;
		  /* 820F1F38h */ case    6:  		/* li R5, 4502 */
		/* 820F1F38h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1196);
		/* 820F1F38h case    6:*/		return 0x820F1F3C;
		  /* 820F1F3Ch */ case    7:  		/* lwz R4, <#[R31 + 104]> */
		/* 820F1F3Ch case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000068) );
		/* 820F1F3Ch case    7:*/		return 0x820F1F40;
		  /* 820F1F40h */ case    8:  		/* mr R3, R25 */
		/* 820F1F40h case    8:*/		regs.R3 = regs.R25;
		/* 820F1F40h case    8:*/		return 0x820F1F44;
		  /* 820F1F44h */ case    9:  		/* bl 116716 */
		/* 820F1F44h case    9:*/		regs.LR = 0x820F1F48; return 0x8210E730;
		/* 820F1F44h case    9:*/		return 0x820F1F48;
		  /* 820F1F48h */ case   10:  		/* b 536 */
		/* 820F1F48h case   10:*/		return 0x820F2160;
		/* 820F1F48h case   10:*/		return 0x820F1F4C;
		  /* 820F1F4Ch */ case   11:  		/* lbz R11, <#[R30]> */
		/* 820F1F4Ch case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F1F4Ch case   11:*/		return 0x820F1F50;
		  /* 820F1F50h */ case   12:  		/* extsb R3, R11 */
		/* 820F1F50h case   12:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820F1F50h case   12:*/		return 0x820F1F54;
		  /* 820F1F54h */ case   13:  		/* bl -362596 */
		/* 820F1F54h case   13:*/		regs.LR = 0x820F1F58; return 0x820996F0;
		/* 820F1F54h case   13:*/		return 0x820F1F58;
		  /* 820F1F58h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820F1F58h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F1F58h case   14:*/		return 0x820F1F5C;
		  /* 820F1F5Ch */ case   15:  		/* bc 12, CR0_EQ, 16 */
		/* 820F1F5Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x820F1F6C;  }
		/* 820F1F5Ch case   15:*/		return 0x820F1F60;
		  /* 820F1F60h */ case   16:  		/* lbzu R11, <#[R30 + 1]> */
		/* 820F1F60h case   16:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820F1F60h case   16:*/		return 0x820F1F64;
	}
	return 0x820F1F64;
} // Block from 820F1F20h-820F1F64h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820F1F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1F64);
		  /* 820F1F64h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 820F1F64h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820F1F64h case    0:*/		return 0x820F1F68;
		  /* 820F1F68h */ case    1:  		/* bc 4, CR0_EQ, -28 */
		/* 820F1F68h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820F1F4C;  }
		/* 820F1F68h case    1:*/		return 0x820F1F6C;
	}
	return 0x820F1F6C;
} // Block from 820F1F64h-820F1F6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F1F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1F6C);
		  /* 820F1F6Ch */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820F1F6Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F1F6Ch case    0:*/		return 0x820F1F70;
		  /* 820F1F70h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820F1F70h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820F1F70h case    1:*/		return 0x820F1F74;
		  /* 820F1F74h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820F1F74h case    2:*/		if ( regs.CR[0].eq ) { return 0x820F1F88;  }
		/* 820F1F74h case    2:*/		return 0x820F1F78;
		  /* 820F1F78h */ case    3:  		/* mr R3, R30 */
		/* 820F1F78h case    3:*/		regs.R3 = regs.R30;
		/* 820F1F78h case    3:*/		return 0x820F1F7C;
		  /* 820F1F7Ch */ case    4:  		/* bl -390164 */
		/* 820F1F7Ch case    4:*/		regs.LR = 0x820F1F80; return 0x82092B68;
		/* 820F1F7Ch case    4:*/		return 0x820F1F80;
		  /* 820F1F80h */ case    5:  		/* mr R29, R3 */
		/* 820F1F80h case    5:*/		regs.R29 = regs.R3;
		/* 820F1F80h case    5:*/		return 0x820F1F84;
		  /* 820F1F84h */ case    6:  		/* b 8 */
		/* 820F1F84h case    6:*/		return 0x820F1F8C;
		/* 820F1F84h case    6:*/		return 0x820F1F88;
	}
	return 0x820F1F88;
} // Block from 820F1F6Ch-820F1F88h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F1F88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1F88);
		  /* 820F1F88h */ case    0:  		/* mr R29, R27 */
		/* 820F1F88h case    0:*/		regs.R29 = regs.R27;
		/* 820F1F88h case    0:*/		return 0x820F1F8C;
	}
	return 0x820F1F8C;
} // Block from 820F1F88h-820F1F8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F1F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1F8C);
		  /* 820F1F8Ch */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820F1F8Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F1F8Ch case    0:*/		return 0x820F1F90;
		  /* 820F1F90h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820F1F90h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820F1F90h case    1:*/		return 0x820F1F94;
		  /* 820F1F94h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 820F1F94h case    2:*/		if ( regs.CR[0].eq ) { return 0x820F1FA0;  }
		/* 820F1F94h case    2:*/		return 0x820F1F98;
		  /* 820F1F98h */ case    3:  		/* stb R27, <#[R30]> */
		/* 820F1F98h case    3:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R30 + 0x00000000) );
		/* 820F1F98h case    3:*/		return 0x820F1F9C;
		  /* 820F1F9Ch */ case    4:  		/* addi R30, R30, 1 */
		/* 820F1F9Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820F1F9Ch case    4:*/		return 0x820F1FA0;
	}
	return 0x820F1FA0;
} // Block from 820F1F8Ch-820F1FA0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F1FA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1FA0);
		  /* 820F1FA0h */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820F1FA0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F1FA0h case    0:*/		return 0x820F1FA4;
		  /* 820F1FA4h */ case    1:  		/* b 20 */
		/* 820F1FA4h case    1:*/		return 0x820F1FB8;
		/* 820F1FA4h case    1:*/		return 0x820F1FA8;
		  /* 820F1FA8h */ case    2:  		/* bl -362648 */
		/* 820F1FA8h case    2:*/		regs.LR = 0x820F1FAC; return 0x82099710;
		/* 820F1FA8h case    2:*/		return 0x820F1FAC;
		  /* 820F1FACh */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820F1FACh case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F1FACh case    3:*/		return 0x820F1FB0;
		  /* 820F1FB0h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820F1FB0h case    4:*/		if ( regs.CR[0].eq ) { return 0x820F1FC0;  }
		/* 820F1FB0h case    4:*/		return 0x820F1FB4;
		  /* 820F1FB4h */ case    5:  		/* lbzu R11, <#[R30 + 1]> */
		/* 820F1FB4h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820F1FB4h case    5:*/		return 0x820F1FB8;
	}
	return 0x820F1FB8;
} // Block from 820F1FA0h-820F1FB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F1FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1FB8);
		  /* 820F1FB8h */ case    0:  		/* extsb. R3, R11 */
		/* 820F1FB8h case    0:*/		cpu::op::extsb<1>(regs,&regs.R3,regs.R11);
		/* 820F1FB8h case    0:*/		return 0x820F1FBC;
		  /* 820F1FBCh */ case    1:  		/* bc 4, CR0_EQ, -20 */
		/* 820F1FBCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820F1FA8;  }
		/* 820F1FBCh case    1:*/		return 0x820F1FC0;
	}
	return 0x820F1FC0;
} // Block from 820F1FB8h-820F1FC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F1FC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1FC0);
		  /* 820F1FC0h */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820F1FC0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F1FC0h case    0:*/		return 0x820F1FC4;
		  /* 820F1FC4h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820F1FC4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820F1FC4h case    1:*/		return 0x820F1FC8;
		  /* 820F1FC8h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 820F1FC8h case    2:*/		if ( regs.CR[0].eq ) { return 0x820F1FD4;  }
		/* 820F1FC8h case    2:*/		return 0x820F1FCC;
		  /* 820F1FCCh */ case    3:  		/* li R28, -1 */
		/* 820F1FCCh case    3:*/		cpu::op::li<0>(regs,&regs.R28,0xFFFFFFFF);
		/* 820F1FCCh case    3:*/		return 0x820F1FD0;
		  /* 820F1FD0h */ case    4:  		/* b 16 */
		/* 820F1FD0h case    4:*/		return 0x820F1FE0;
		/* 820F1FD0h case    4:*/		return 0x820F1FD4;
	}
	return 0x820F1FD4;
} // Block from 820F1FC0h-820F1FD4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F1FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1FD4);
		  /* 820F1FD4h */ case    0:  		/* lwz R11, <#[R31 + 112]> */
		/* 820F1FD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820F1FD4h case    0:*/		return 0x820F1FD8;
		  /* 820F1FD8h */ case    1:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 820F1FD8h case    1:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 820F1FD8h case    1:*/		return 0x820F1FDC;
		  /* 820F1FDCh */ case    2:  		/* add R28, R11, R29 */
		/* 820F1FDCh case    2:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R29);
		/* 820F1FDCh case    2:*/		return 0x820F1FE0;
	}
	return 0x820F1FE0;
} // Block from 820F1FD4h-820F1FE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F1FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F1FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F1FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F1FE0);
		  /* 820F1FE0h */ case    0:  		/* mr R4, R31 */
		/* 820F1FE0h case    0:*/		regs.R4 = regs.R31;
		/* 820F1FE0h case    0:*/		return 0x820F1FE4;
		  /* 820F1FE4h */ case    1:  		/* mr R3, R25 */
		/* 820F1FE4h case    1:*/		regs.R3 = regs.R25;
		/* 820F1FE4h case    1:*/		return 0x820F1FE8;
		  /* 820F1FE8h */ case    2:  		/* bl 44560 */
		/* 820F1FE8h case    2:*/		regs.LR = 0x820F1FEC; return 0x820FCDF8;
		/* 820F1FE8h case    2:*/		return 0x820F1FEC;
		  /* 820F1FECh */ case    3:  		/* lwz R11, <#[R26 + 16]> */
		/* 820F1FECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820F1FECh case    3:*/		return 0x820F1FF0;
		  /* 820F1FF0h */ case    4:  		/* mr R29, R3 */
		/* 820F1FF0h case    4:*/		regs.R29 = regs.R3;
		/* 820F1FF0h case    4:*/		return 0x820F1FF4;
		  /* 820F1FF4h */ case    5:  		/* mr R30, R27 */
		/* 820F1FF4h case    5:*/		regs.R30 = regs.R27;
		/* 820F1FF4h case    5:*/		return 0x820F1FF8;
		  /* 820F1FF8h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 820F1FF8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820F1FF8h case    6:*/		return 0x820F1FFC;
		  /* 820F1FFCh */ case    7:  		/* bc 12, CR6_EQ, 340 */
		/* 820F1FFCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820F2150;  }
		/* 820F1FFCh case    7:*/		return 0x820F2000;
		  /* 820F2000h */ case    8:  		/* addi R4, R1, 80 */
		/* 820F2000h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F2000h case    8:*/		return 0x820F2004;
		  /* 820F2004h */ case    9:  		/* lwz R3, <#[R26]> */
		/* 820F2004h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000000) );
		/* 820F2004h case    9:*/		return 0x820F2008;
		  /* 820F2008h */ case   10:  		/* bl -388056 */
		/* 820F2008h case   10:*/		regs.LR = 0x820F200C; return 0x82093430;
		/* 820F2008h case   10:*/		return 0x820F200C;
		  /* 820F200Ch */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820F200Ch case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F200Ch case   11:*/		return 0x820F2010;
		  /* 820F2010h */ case   12:  		/* bc 4, CR0_EQ, 24 */
		/* 820F2010h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820F2028;  }
		/* 820F2010h case   12:*/		return 0x820F2014;
		  /* 820F2014h */ case   13:  		/* lhz R11, <#[R26 + 4]> */
		/* 820F2014h case   13:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 820F2014h case   13:*/		return 0x820F2018;
		  /* 820F2018h */ case   14:  		/* rlwinm R10, R22, 0, 16, 31 */
		/* 820F2018h case   14:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R22);
		/* 820F2018h case   14:*/		return 0x820F201C;
		  /* 820F201Ch */ case   15:  		/* mr R30, R26 */
		/* 820F201Ch case   15:*/		regs.R30 = regs.R26;
		/* 820F201Ch case   15:*/		return 0x820F2020;
		  /* 820F2020h */ case   16:  		/* and. R11, R11, R10 */
		/* 820F2020h case   16:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820F2020h case   16:*/		return 0x820F2024;
		  /* 820F2024h */ case   17:  		/* bc 4, CR0_EQ, 20 */
		/* 820F2024h case   17:*/		if ( !regs.CR[0].eq ) { return 0x820F2038;  }
		/* 820F2024h case   17:*/		return 0x820F2028;
	}
	return 0x820F2028;
} // Block from 820F1FE0h-820F2028h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820F2028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2028);
		  /* 820F2028h */ case    0:  		/* addi R26, R26, 36 */
		/* 820F2028h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x24);
		/* 820F2028h case    0:*/		return 0x820F202C;
		  /* 820F202Ch */ case    1:  		/* lwz R11, <#[R26 + 16]> */
		/* 820F202Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820F202Ch case    1:*/		return 0x820F2030;
		  /* 820F2030h */ case    2:  		/* cmpwi CR6, R11, -1 */
		/* 820F2030h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820F2030h case    2:*/		return 0x820F2034;
		  /* 820F2034h */ case    3:  		/* bc 4, CR6_EQ, -52 */
		/* 820F2034h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820F2000;  }
		/* 820F2034h case    3:*/		return 0x820F2038;
	}
	return 0x820F2038;
} // Block from 820F2028h-820F2038h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F2038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2038);
		  /* 820F2038h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820F2038h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F2038h case    0:*/		return 0x820F203C;
		  /* 820F203Ch */ case    1:  		/* bc 12, CR6_EQ, 276 */
		/* 820F203Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820F2150;  }
		/* 820F203Ch case    1:*/		return 0x820F2040;
		  /* 820F2040h */ case    2:  		/* lwz R11, <#[R26 + 16]> */
		/* 820F2040h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820F2040h case    2:*/		return 0x820F2044;
		  /* 820F2044h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 820F2044h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820F2044h case    3:*/		return 0x820F2048;
		  /* 820F2048h */ case    4:  		/* bc 12, CR6_EQ, 264 */
		/* 820F2048h case    4:*/		if ( regs.CR[6].eq ) { return 0x820F2150;  }
		/* 820F2048h case    4:*/		return 0x820F204C;
		  /* 820F204Ch */ case    5:  		/* cmpwi CR6, R24, 0 */
		/* 820F204Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 820F204Ch case    5:*/		return 0x820F2050;
		  /* 820F2050h */ case    6:  		/* bc 12, CR6_EQ, 28 */
		/* 820F2050h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F206C;  }
		/* 820F2050h case    6:*/		return 0x820F2054;
		  /* 820F2054h */ case    7:  		/* lwz R11, <#[R30 + 8]> */
		/* 820F2054h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820F2054h case    7:*/		return 0x820F2058;
		  /* 820F2058h */ case    8:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 820F2058h case    8:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 820F2058h case    8:*/		return 0x820F205C;
		  /* 820F205Ch */ case    9:  		/* bc 4, CR0_EQ, 16 */
		/* 820F205Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x820F206C;  }
		/* 820F205Ch case    9:*/		return 0x820F2060;
		  /* 820F2060h */ case   10:  		/* lwz R11, <#[R31]> */
		/* 820F2060h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F2060h case   10:*/		return 0x820F2064;
		  /* 820F2064h */ case   11:  		/* oris R11, R11, 16384 */
		/* 820F2064h case   11:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 820F2064h case   11:*/		return 0x820F2068;
		  /* 820F2068h */ case   12:  		/* stw R11, <#[R31]> */
		/* 820F2068h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F2068h case   12:*/		return 0x820F206C;
	}
	return 0x820F206C;
} // Block from 820F2038h-820F206Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820F206Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F206C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F206C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F206C);
		  /* 820F206Ch */ case    0:  		/* lwz R9, <#[R30 + 12]> */
		/* 820F206Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 820F206Ch case    0:*/		return 0x820F2070;
		  /* 820F2070h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 820F2070h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820F2070h case    1:*/		return 0x820F2074;
		  /* 820F2074h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820F2074h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F209C;  }
		/* 820F2074h case    2:*/		return 0x820F2078;
		  /* 820F2078h */ case    3:  		/* lis R11, -32254 */
		/* 820F2078h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F2078h case    3:*/		return 0x820F207C;
		  /* 820F207Ch */ case    4:  		/* lwz R4, <#[R31 + 104]> */
		/* 820F207Ch case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000068) );
		/* 820F207Ch case    4:*/		return 0x820F2080;
		  /* 820F2080h */ case    5:  		/* mr R10, R28 */
		/* 820F2080h case    5:*/		regs.R10 = regs.R28;
		/* 820F2080h case    5:*/		return 0x820F2084;
		  /* 820F2084h */ case    6:  		/* addi R6, R11, -16360 */
		/* 820F2084h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC018);
		/* 820F2084h case    6:*/		return 0x820F2088;
		  /* 820F2088h */ case    7:  		/* addi R8, R1, 80 */
		/* 820F2088h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 820F2088h case    7:*/		return 0x820F208C;
		  /* 820F208Ch */ case    8:  		/* mr R7, R29 */
		/* 820F208Ch case    8:*/		regs.R7 = regs.R29;
		/* 820F208Ch case    8:*/		return 0x820F2090;
		  /* 820F2090h */ case    9:  		/* li R5, 4705 */
		/* 820F2090h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x1261);
		/* 820F2090h case    9:*/		return 0x820F2094;
		  /* 820F2094h */ case   10:  		/* mr R3, R25 */
		/* 820F2094h case   10:*/		regs.R3 = regs.R25;
		/* 820F2094h case   10:*/		return 0x820F2098;
		  /* 820F2098h */ case   11:  		/* bl 116568 */
		/* 820F2098h case   11:*/		regs.LR = 0x820F209C; return 0x8210E7F0;
		/* 820F2098h case   11:*/		return 0x820F209C;
	}
	return 0x820F209C;
} // Block from 820F206Ch-820F209Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F209Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F209C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F209C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F209C);
		  /* 820F209Ch */ case    0:  		/* lwz R11, <#[R26 + 20]> */
		/* 820F209Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 820F209Ch case    0:*/		return 0x820F20A0;
		  /* 820F20A0h */ case    1:  		/* cmplw CR6, R28, R11 */
		/* 820F20A0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820F20A0h case    1:*/		return 0x820F20A4;
		  /* 820F20A4h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 820F20A4h case    2:*/		if ( regs.CR[6].lt ) { return 0x820F20B4;  }
		/* 820F20A4h case    2:*/		return 0x820F20A8;
		  /* 820F20A8h */ case    3:  		/* lwz R11, <#[R26 + 24]> */
		/* 820F20A8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 820F20A8h case    3:*/		return 0x820F20AC;
		  /* 820F20ACh */ case    4:  		/* cmplw CR6, R28, R11 */
		/* 820F20ACh case    4:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820F20ACh case    4:*/		return 0x820F20B0;
		  /* 820F20B0h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 820F20B0h case    5:*/		if ( regs.CR[6].lt ) { return 0x820F20C0;  }
		/* 820F20B0h case    5:*/		return 0x820F20B4;
	}
	return 0x820F20B4;
} // Block from 820F209Ch-820F20B4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F20B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F20B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F20B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F20B4);
		  /* 820F20B4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F20B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F20B4h case    0:*/		return 0x820F20B8;
		  /* 820F20B8h */ case    1:  		/* oris R11, R11, 16384 */
		/* 820F20B8h case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 820F20B8h case    1:*/		return 0x820F20BC;
		  /* 820F20BCh */ case    2:  		/* stw R11, <#[R31]> */
		/* 820F20BCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F20BCh case    2:*/		return 0x820F20C0;
	}
	return 0x820F20C0;
} // Block from 820F20B4h-820F20C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F20C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F20C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F20C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F20C0);
		  /* 820F20C0h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 820F20C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820F20C0h case    0:*/		return 0x820F20C4;
		  /* 820F20C4h */ case    1:  		/* lwz R10, <#[R26 + 32]> */
		/* 820F20C4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000020) );
		/* 820F20C4h case    1:*/		return 0x820F20C8;
		  /* 820F20C8h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820F20C8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F20C8h case    2:*/		return 0x820F20CC;
		  /* 820F20CCh */ case    3:  		/* bc 12, CR6_LT, 60 */
		/* 820F20CCh case    3:*/		if ( regs.CR[6].lt ) { return 0x820F2108;  }
		/* 820F20CCh case    3:*/		return 0x820F20D0;
		  /* 820F20D0h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 820F20D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F20D0h case    4:*/		return 0x820F20D4;
		  /* 820F20D4h */ case    5:  		/* li R10, 1 */
		/* 820F20D4h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820F20D4h case    5:*/		return 0x820F20D8;
		  /* 820F20D8h */ case    6:  		/* lis R9, -32254 */
		/* 820F20D8h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8202);
		/* 820F20D8h case    6:*/		return 0x820F20DC;
		  /* 820F20DCh */ case    7:  		/* oris R11, R11, 16384 */
		/* 820F20DCh case    7:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 820F20DCh case    7:*/		return 0x820F20E0;
		  /* 820F20E0h */ case    8:  		/* addi R6, R9, -16400 */
		/* 820F20E0h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R9,0xFFFFBFF0);
		/* 820F20E0h case    8:*/		return 0x820F20E4;
		  /* 820F20E4h */ case    9:  		/* stw R11, <#[R31]> */
		/* 820F20E4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F20E4h case    9:*/		return 0x820F20E8;
		  /* 820F20E8h */ case   10:  		/* mr R8, R29 */
		/* 820F20E8h case   10:*/		regs.R8 = regs.R29;
		/* 820F20E8h case   10:*/		return 0x820F20EC;
		  /* 820F20ECh */ case   11:  		/* stw R10, <#[R23]> */
		/* 820F20ECh case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R23 + 0x00000000) );
		/* 820F20ECh case   11:*/		return 0x820F20F0;
		  /* 820F20F0h */ case   12:  		/* addi R7, R1, 80 */
		/* 820F20F0h case   12:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820F20F0h case   12:*/		return 0x820F20F4;
		  /* 820F20F4h */ case   13:  		/* li R5, 4555 */
		/* 820F20F4h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x11CB);
		/* 820F20F4h case   13:*/		return 0x820F20F8;
		  /* 820F20F8h */ case   14:  		/* lwz R4, <#[R31 + 104]> */
		/* 820F20F8h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000068) );
		/* 820F20F8h case   14:*/		return 0x820F20FC;
		  /* 820F20FCh */ case   15:  		/* mr R3, R25 */
		/* 820F20FCh case   15:*/		regs.R3 = regs.R25;
		/* 820F20FCh case   15:*/		return 0x820F2100;
		  /* 820F2100h */ case   16:  		/* bl 116272 */
		/* 820F2100h case   16:*/		regs.LR = 0x820F2104; return 0x8210E730;
		/* 820F2100h case   16:*/		return 0x820F2104;
		  /* 820F2104h */ case   17:  		/* b 92 */
		/* 820F2104h case   17:*/		return 0x820F2160;
		/* 820F2104h case   17:*/		return 0x820F2108;
	}
	return 0x820F2108;
} // Block from 820F20C0h-820F2108h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820F2108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2108);
		  /* 820F2108h */ case    0:  		/* lhz R11, <#[R30 + 4]> */
		/* 820F2108h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820F2108h case    0:*/		return 0x820F210C;
		  /* 820F210Ch */ case    1:  		/* rlwinm R10, R22, 0, 16, 31 */
		/* 820F210Ch case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R22);
		/* 820F210Ch case    1:*/		return 0x820F2110;
		  /* 820F2110h */ case    2:  		/* and. R11, R11, R10 */
		/* 820F2110h case    2:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820F2110h case    2:*/		return 0x820F2114;
		  /* 820F2114h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 820F2114h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820F2124;  }
		/* 820F2114h case    3:*/		return 0x820F2118;
		  /* 820F2118h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 820F2118h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F2118h case    4:*/		return 0x820F211C;
		  /* 820F211Ch */ case    5:  		/* oris R11, R11, 16384 */
		/* 820F211Ch case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 820F211Ch case    5:*/		return 0x820F2120;
		  /* 820F2120h */ case    6:  		/* stw R11, <#[R31]> */
		/* 820F2120h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F2120h case    6:*/		return 0x820F2124;
	}
	return 0x820F2124;
} // Block from 820F2108h-820F2124h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F2124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2124);
		  /* 820F2124h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 820F2124h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820F2124h case    0:*/		return 0x820F2128;
		  /* 820F2128h */ case    1:  		/* cmpwi CR6, R24, 0 */
		/* 820F2128h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 820F2128h case    1:*/		return 0x820F212C;
		  /* 820F212Ch */ case    2:  		/* lhz R10, <#[R30 + 18]> */
		/* 820F212Ch case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000012) );
		/* 820F212Ch case    2:*/		return 0x820F2130;
	}
	return 0x820F2130;
} // Block from 820F2124h-820F2130h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F2130h
// Function '?Assure@CShaderProgram@D3DXShader@@IAAJI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2130);
		  /* 820F2130h */ case    0:  		/* add R11, R11, R28 */
		/* 820F2130h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 820F2130h case    0:*/		return 0x820F2134;
		  /* 820F2134h */ case    1:  		/* rlwinm R11, R11, 16, 0, 15 */
		/* 820F2134h case    1:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R11,regs.R11);
		/* 820F2134h case    1:*/		return 0x820F2138;
		  /* 820F2138h */ case    2:  		/* or R11, R11, R10 */
		/* 820F2138h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820F2138h case    2:*/		return 0x820F213C;
		  /* 820F213Ch */ case    3:  		/* stw R11, <#[R31 + 108]> */
		/* 820F213Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F213Ch case    3:*/		return 0x820F2140;
		  /* 820F2140h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 820F2140h case    4:*/		if ( regs.CR[6].eq ) { return 0x820F2160;  }
		/* 820F2140h case    4:*/		return 0x820F2144;
		  /* 820F2144h */ case    5:  		/* lwz R11, <#[R31]> */
		/* 820F2144h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F2144h case    5:*/		return 0x820F2148;
		  /* 820F2148h */ case    6:  		/* oris R11, R11, 256 */
		/* 820F2148h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 820F2148h case    6:*/		return 0x820F214C;
		  /* 820F214Ch */ case    7:  		/* b 16 */
		/* 820F214Ch case    7:*/		return 0x820F215C;
		/* 820F214Ch case    7:*/		return 0x820F2150;
	}
	return 0x820F2150;
} // Block from 820F2130h-820F2150h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F2150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2150);
		  /* 820F2150h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F2150h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F2150h case    0:*/		return 0x820F2154;
		  /* 820F2154h */ case    1:  		/* stw R27, <#[R31 + 108]> */
		/* 820F2154h case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F2154h case    1:*/		return 0x820F2158;
		  /* 820F2158h */ case    2:  		/* oris R11, R11, 16384 */
		/* 820F2158h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 820F2158h case    2:*/		return 0x820F215C;
	}
	return 0x820F215C;
} // Block from 820F2150h-820F215Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F215Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F215C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F215C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F215C);
		  /* 820F215Ch */ case    0:  		/* stw R11, <#[R31]> */
		/* 820F215Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F215Ch case    0:*/		return 0x820F2160;
	}
	return 0x820F2160;
} // Block from 820F215Ch-820F2160h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F2160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2160);
		  /* 820F2160h */ case    0:  		/* lwz R11, <#[R23]> */
		/* 820F2160h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 820F2160h case    0:*/		return 0x820F2164;
		  /* 820F2164h */ case    1:  		/* addic R10, R11, -1 */
		/* 820F2164h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 820F2164h case    1:*/		return 0x820F2168;
		  /* 820F2168h */ case    2:  		/* subfe R3, R10, R11 */
		/* 820F2168h case    2:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 820F2168h case    2:*/		return 0x820F216C;
		  /* 820F216Ch */ case    3:  		/* addi R1, R1, 240 */
		/* 820F216Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 820F216Ch case    3:*/		return 0x820F2170;
		  /* 820F2170h */ case    4:  		/* b -397024 */
		/* 820F2170h case    4:*/		return 0x82091290;
		/* 820F2170h case    4:*/		return 0x820F2174;
		  /* 820F2174h */ case    5:  		/* nop */
		/* 820F2174h case    5:*/		cpu::op::nop();
		/* 820F2174h case    5:*/		return 0x820F2178;
	}
	return 0x820F2178;
} // Block from 820F2160h-820F2178h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F2178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2178);
		  /* 820F2178h */ case    0:  		/* mfspr R12, LR */
		/* 820F2178h case    0:*/		regs.R12 = regs.LR;
		/* 820F2178h case    0:*/		return 0x820F217C;
		  /* 820F217Ch */ case    1:  		/* bl -397148 */
		/* 820F217Ch case    1:*/		regs.LR = 0x820F2180; return 0x82091220;
		/* 820F217Ch case    1:*/		return 0x820F2180;
		  /* 820F2180h */ case    2:  		/* stwu R1, <#[R1 - 368]> */
		/* 820F2180h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE90);
		/* 820F2180h case    2:*/		return 0x820F2184;
		  /* 820F2184h */ case    3:  		/* mr R25, R3 */
		/* 820F2184h case    3:*/		regs.R25 = regs.R3;
		/* 820F2184h case    3:*/		return 0x820F2188;
		  /* 820F2188h */ case    4:  		/* stw R7, <#[R1 + 420]> */
		/* 820F2188h case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x000001A4) );
		/* 820F2188h case    4:*/		return 0x820F218C;
		  /* 820F218Ch */ case    5:  		/* mr R22, R6 */
		/* 820F218Ch case    5:*/		regs.R22 = regs.R6;
		/* 820F218Ch case    5:*/		return 0x820F2190;
		  /* 820F2190h */ case    6:  		/* mr R20, R7 */
		/* 820F2190h case    6:*/		regs.R20 = regs.R7;
		/* 820F2190h case    6:*/		return 0x820F2194;
		  /* 820F2194h */ case    7:  		/* mr R24, R8 */
		/* 820F2194h case    7:*/		regs.R24 = regs.R8;
		/* 820F2194h case    7:*/		return 0x820F2198;
		  /* 820F2198h */ case    8:  		/* mr R23, R9 */
		/* 820F2198h case    8:*/		regs.R23 = regs.R9;
		/* 820F2198h case    8:*/		return 0x820F219C;
		  /* 820F219Ch */ case    9:  		/* cmplwi CR6, R8, 0 */
		/* 820F219Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820F219Ch case    9:*/		return 0x820F21A0;
		  /* 820F21A0h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 820F21A0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820F21A8;  }
		/* 820F21A0h case   10:*/		return 0x820F21A4;
		  /* 820F21A4h */ case   11:  		/* lwz R24, <#[R3 + 260]> */
		/* 820F21A4h case   11:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R3 + 0x00000104) );
		/* 820F21A4h case   11:*/		return 0x820F21A8;
	}
	return 0x820F21A8;
} // Block from 820F2178h-820F21A8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F21A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F21A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F21A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F21A8);
		  /* 820F21A8h */ case    0:  		/* lwz R30, <#[R24 + 16]> */
		/* 820F21A8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R24 + 0x00000010) );
		/* 820F21A8h case    0:*/		return 0x820F21AC;
		  /* 820F21ACh */ case    1:  		/* lwz R3, <#[R25 + 20]> */
		/* 820F21ACh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000014) );
		/* 820F21ACh case    1:*/		return 0x820F21B0;
		  /* 820F21B0h */ case    2:  		/* lwz R11, <#[R25 + 136]> */
		/* 820F21B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000088) );
		/* 820F21B0h case    2:*/		return 0x820F21B4;
		  /* 820F21B4h */ case    3:  		/* lwz R10, <#[R30]> */
		/* 820F21B4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820F21B4h case    3:*/		return 0x820F21B8;
		  /* 820F21B8h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F21B8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F21B8h case    4:*/		return 0x820F21BC;
		  /* 820F21BCh */ case    5:  		/* lwzx R10, <#[R10 + R3]> */
		/* 820F21BCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 820F21BCh case    5:*/		return 0x820F21C0;
		  /* 820F21C0h */ case    6:  		/* lwz R10, <#[R10 + 4]> */
		/* 820F21C0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820F21C0h case    6:*/		return 0x820F21C4;
		  /* 820F21C4h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820F21C4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F21C4h case    7:*/		return 0x820F21C8;
		  /* 820F21C8h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 820F21C8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820F21D4;  }
		/* 820F21C8h case    8:*/		return 0x820F21CC;
		  /* 820F21CCh */ case    9:  		/* li R3, 1 */
		/* 820F21CCh case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F21CCh case    9:*/		return 0x820F21D0;
		  /* 820F21D0h */ case   10:  		/* b 1580 */
		/* 820F21D0h case   10:*/		return 0x820F27FC;
		/* 820F21D0h case   10:*/		return 0x820F21D4;
	}
	return 0x820F21D4;
} // Block from 820F21A8h-820F21D4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F21D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F21D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F21D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F21D4);
		  /* 820F21D4h */ case    0:  		/* lwz R6, <#[R25 + 260]> */
		/* 820F21D4h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R25 + 0x00000104) );
		/* 820F21D4h case    0:*/		return 0x820F21D8;
	}
	return 0x820F21D8;
} // Block from 820F21D4h-820F21D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F21D8h
// Function '?TempRegister@CShaderProgram@D3DXShader@@MAAJIPAII0I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F21D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F21D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F21D8);
		  /* 820F21D8h */ case    0:  		/* li R28, 0 */
		/* 820F21D8h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820F21D8h case    0:*/		return 0x820F21DC;
		  /* 820F21DCh */ case    1:  		/* lwz R11, <#[R6]> */
		/* 820F21DCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 820F21DCh case    1:*/		return 0x820F21E0;
		  /* 820F21E0h */ case    2:  		/* lwz R10, <#[R6 + 12]> */
		/* 820F21E0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x0000000C) );
		/* 820F21E0h case    2:*/		return 0x820F21E4;
		  /* 820F21E4h */ case    3:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 820F21E4h case    3:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 820F21E4h case    3:*/		return 0x820F21E8;
		  /* 820F21E8h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820F21E8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F21E8h case    4:*/		return 0x820F21EC;
		  /* 820F21ECh */ case    5:  		/* bc 4, CR6_EQ, -32 */
		/* 820F21ECh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820F21CC;  }
		/* 820F21ECh case    5:*/		return 0x820F21F0;
		  /* 820F21F0h */ case    6:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 820F21F0h case    6:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 820F21F0h case    6:*/		return 0x820F21F4;
		  /* 820F21F4h */ case    7:  		/* li R31, 0 */
		/* 820F21F4h case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820F21F4h case    7:*/		return 0x820F21F8;
		  /* 820F21F8h */ case    8:  		/* lis R21, 8 */
		/* 820F21F8h case    8:*/		cpu::op::lis<0>(regs,&regs.R21,0x8);
		/* 820F21F8h case    8:*/		return 0x820F21FC;
		  /* 820F21FCh */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820F21FCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F21FCh case    9:*/		return 0x820F2200;
		  /* 820F2200h */ case   10:  		/* bc 4, CR6_GT, 200 */
		/* 820F2200h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820F22C8;  }
		/* 820F2200h case   10:*/		return 0x820F2204;
		  /* 820F2204h */ case   11:  		/* lwz R7, <#[R25 + 16]> */
		/* 820F2204h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000010) );
		/* 820F2204h case   11:*/		return 0x820F2208;
		  /* 820F2208h */ case   12:  		/* li R10, 0 */
		/* 820F2208h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F2208h case   12:*/		return 0x820F220C;
		  /* 820F220Ch */ case   13:  		/* lwz R8, <#[R25 + 108]> */
		/* 820F220Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x0000006C) );
		/* 820F220Ch case   13:*/		return 0x820F2210;
		  /* 820F2210h */ case   14:  		/* lwzx R11, <#[R10 + R22]> */
		/* 820F2210h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R22 + 0x00000000) );
		/* 820F2210h case   14:*/		return 0x820F2214;
		  /* 820F2214h */ case   15:  		/* rlwinm. R9, R8, 0, 18, 18 */
		/* 820F2214h case   15:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R9,regs.R8);
		/* 820F2214h case   15:*/		return 0x820F2218;
		  /* 820F2218h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F2218h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2218h case   16:*/		return 0x820F221C;
		  /* 820F221Ch */ case   17:  		/* lwzx R11, <#[R11 + R3]> */
		/* 820F221Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 820F221Ch case   17:*/		return 0x820F2220;
		  /* 820F2220h */ case   18:  		/* lwz R9, <#[R11 + 4]> */
		/* 820F2220h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820F2220h case   18:*/		return 0x820F2224;
		  /* 820F2224h */ case   19:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F2224h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F2224h case   19:*/		return 0x820F2228;
		  /* 820F2228h */ case   20:  		/* lwzx R9, <#[R9 + R7]> */
		/* 820F2228h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820F2228h case   20:*/		return 0x820F222C;
		  /* 820F222Ch */ case   21:  		/* bc 12, CR0_EQ, 28 */
		/* 820F222Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x820F2248;  }
		/* 820F222Ch case   21:*/		return 0x820F2230;
		  /* 820F2230h */ case   22:  		/* lwz R29, <#[R11 + 60]> */
		/* 820F2230h case   22:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F2230h case   22:*/		return 0x820F2234;
		  /* 820F2234h */ case   23:  		/* rlwinm. R29, R29, 0, 22, 22 */
		/* 820F2234h case   23:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R29,regs.R29);
		/* 820F2234h case   23:*/		return 0x820F2238;
		  /* 820F2238h */ case   24:  		/* bc 12, CR0_EQ, 16 */
		/* 820F2238h case   24:*/		if ( regs.CR[0].eq ) { return 0x820F2248;  }
		/* 820F2238h case   24:*/		return 0x820F223C;
		  /* 820F223Ch */ case   25:  		/* cmplw CR6, R4, R21 */
		/* 820F223Ch case   25:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R21);
		/* 820F223Ch case   25:*/		return 0x820F2240;
		  /* 820F2240h */ case   26:  		/* bc 4, CR6_EQ, 8 */
		/* 820F2240h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820F2248;  }
		/* 820F2240h case   26:*/		return 0x820F2244;
		  /* 820F2244h */ case   27:  		/* li R28, 1 */
		/* 820F2244h case   27:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820F2244h case   27:*/		return 0x820F2248;
	}
	return 0x820F2248;
} // Block from 820F21D8h-820F2248h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820F2248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2248);
		  /* 820F2248h */ case    0:  		/* lwz R11, <#[R11 + 60]> */
		/* 820F2248h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F2248h case    0:*/		return 0x820F224C;
		  /* 820F224Ch */ case    1:  		/* rlwinm. R29, R11, 0, 11, 15 */
		/* 820F224Ch case    1:*/		cpu::op::rlwinm<1,0,11,15>(regs,&regs.R29,regs.R11);
		/* 820F224Ch case    1:*/		return 0x820F2250;
		  /* 820F2250h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 820F2250h case    2:*/		if ( regs.CR[0].eq ) { return 0x820F226C;  }
		/* 820F2250h case    2:*/		return 0x820F2254;
		  /* 820F2254h */ case    3:  		/* andc R11, R11, R5 */
		/* 820F2254h case    3:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 820F2254h case    3:*/		return 0x820F2258;
		  /* 820F2258h */ case    4:  		/* rlwinm. R11, R11, 0, 11, 15 */
		/* 820F2258h case    4:*/		cpu::op::rlwinm<1,0,11,15>(regs,&regs.R11,regs.R11);
		/* 820F2258h case    4:*/		return 0x820F225C;
		  /* 820F225Ch */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820F225Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820F226C;  }
		/* 820F225Ch case    5:*/		return 0x820F2260;
		  /* 820F2260h */ case    6:  		/* cmplw CR6, R4, R21 */
		/* 820F2260h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R21);
		/* 820F2260h case    6:*/		return 0x820F2264;
		  /* 820F2264h */ case    7:  		/* bc 4, CR6_EQ, -152 */
		/* 820F2264h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820F21CC;  }
		/* 820F2264h case    7:*/		return 0x820F2268;
		  /* 820F2268h */ case    8:  		/* li R28, 1 */
		/* 820F2268h case    8:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820F2268h case    8:*/		return 0x820F226C;
	}
	return 0x820F226C;
} // Block from 820F2248h-820F226Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F226Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F226C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F226C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F226C);
		  /* 820F226Ch */ case    0:  		/* lwzx R11, <#[R30 + R10]> */
		/* 820F226Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R10 + 0x00000000) );
		/* 820F226Ch case    0:*/		return 0x820F2270;
		  /* 820F2270h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F2270h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2270h case    1:*/		return 0x820F2274;
		  /* 820F2274h */ case    2:  		/* lwzx R11, <#[R11 + R3]> */
		/* 820F2274h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 820F2274h case    2:*/		return 0x820F2278;
		  /* 820F2278h */ case    3:  		/* lwz R11, <#[R11 + 60]> */
		/* 820F2278h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F2278h case    3:*/		return 0x820F227C;
		  /* 820F227Ch */ case    4:  		/* rlwinm. R11, R11, 0, 16, 22 */
		/* 820F227Ch case    4:*/		cpu::op::rlwinm<1,0,16,22>(regs,&regs.R11,regs.R11);
		/* 820F227Ch case    4:*/		return 0x820F2280;
		  /* 820F2280h */ case    5:  		/* bc 4, CR0_EQ, -180 */
		/* 820F2280h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820F21CC;  }
		/* 820F2280h case    5:*/		return 0x820F2284;
		  /* 820F2284h */ case    6:  		/* rlwinm. R11, R8, 0, 5, 5 */
		/* 820F2284h case    6:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R11,regs.R8);
		/* 820F2284h case    6:*/		return 0x820F2288;
		  /* 820F2288h */ case    7:  		/* bc 12, CR0_EQ, 40 */
		/* 820F2288h case    7:*/		if ( regs.CR[0].eq ) { return 0x820F22B0;  }
		/* 820F2288h case    7:*/		return 0x820F228C;
		  /* 820F228Ch */ case    8:  		/* lwz R11, <#[R9 + 4]> */
		/* 820F228Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 820F228Ch case    8:*/		return 0x820F2290;
		  /* 820F2290h */ case    9:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 820F2290h case    9:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 820F2290h case    9:*/		return 0x820F2294;
		  /* 820F2294h */ case   10:  		/* bc 12, CR0_EQ, 28 */
		/* 820F2294h case   10:*/		if ( regs.CR[0].eq ) { return 0x820F22B0;  }
		/* 820F2294h case   10:*/		return 0x820F2298;
		  /* 820F2298h */ case   11:  		/* lwz R11, <#[R6]> */
		/* 820F2298h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 820F2298h case   11:*/		return 0x820F229C;
		  /* 820F229Ch */ case   12:  		/* lis R9, 4112 */
		/* 820F229Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R9,0x1010);
		/* 820F229Ch case   12:*/		return 0x820F22A0;
		  /* 820F22A0h */ case   13:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820F22A0h case   13:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820F22A0h case   13:*/		return 0x820F22A4;
		  /* 820F22A4h */ case   14:  		/* cmplw CR6, R11, R9 */
		/* 820F22A4h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F22A4h case   14:*/		return 0x820F22A8;
		  /* 820F22A8h */ case   15:  		/* bc 4, CR6_EQ, -220 */
		/* 820F22A8h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820F21CC;  }
		/* 820F22A8h case   15:*/		return 0x820F22AC;
		  /* 820F22ACh */ case   16:  		/* li R28, 1 */
		/* 820F22ACh case   16:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820F22ACh case   16:*/		return 0x820F22B0;
	}
	return 0x820F22B0;
} // Block from 820F226Ch-820F22B0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820F22B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F22B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F22B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F22B0);
		  /* 820F22B0h */ case    0:  		/* lwz R11, <#[R25 + 260]> */
		/* 820F22B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000104) );
		/* 820F22B0h case    0:*/		return 0x820F22B4;
		  /* 820F22B4h */ case    1:  		/* addi R31, R31, 1 */
		/* 820F22B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820F22B4h case    1:*/		return 0x820F22B8;
		  /* 820F22B8h */ case    2:  		/* addi R10, R10, 4 */
		/* 820F22B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F22B8h case    2:*/		return 0x820F22BC;
		  /* 820F22BCh */ case    3:  		/* lwz R11, <#[R11 + 12]> */
		/* 820F22BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F22BCh case    3:*/		return 0x820F22C0;
		  /* 820F22C0h */ case    4:  		/* cmplw CR6, R31, R11 */
		/* 820F22C0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820F22C0h case    4:*/		return 0x820F22C4;
		  /* 820F22C4h */ case    5:  		/* bc 12, CR6_LT, -180 */
		/* 820F22C4h case    5:*/		if ( regs.CR[6].lt ) { return 0x820F2210;  }
		/* 820F22C4h case    5:*/		return 0x820F22C8;
	}
	return 0x820F22C8;
} // Block from 820F22B0h-820F22C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F22C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F22C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F22C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F22C8);
		  /* 820F22C8h */ case    0:  		/* lwz R27, <#[R24 + 12]> */
		/* 820F22C8h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R24 + 0x0000000C) );
		/* 820F22C8h case    0:*/		return 0x820F22CC;
		  /* 820F22CCh */ case    1:  		/* li R4, 0 */
		/* 820F22CCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F22CCh case    1:*/		return 0x820F22D0;
		  /* 820F22D0h */ case    2:  		/* cmplwi CR6, R27, 0 */
		/* 820F22D0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820F22D0h case    2:*/		return 0x820F22D4;
		  /* 820F22D4h */ case    3:  		/* bc 12, CR6_EQ, 292 */
		/* 820F22D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820F23F8;  }
		/* 820F22D4h case    3:*/		return 0x820F22D8;
		  /* 820F22D8h */ case    4:  		/* addi R11, R1, 80 */
		/* 820F22D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820F22D8h case    4:*/		return 0x820F22DC;
		  /* 820F22DCh */ case    5:  		/* nor R5, R20, R20 */
		/* 820F22DCh case    5:*/		cpu::op::nor<0>(regs,&regs.R5,regs.R20,regs.R20);
		/* 820F22DCh case    5:*/		return 0x820F22E0;
		  /* 820F22E0h */ case    6:  		/* li R10, 0 */
		/* 820F22E0h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F22E0h case    6:*/		return 0x820F22E4;
		  /* 820F22E4h */ case    7:  		/* subf R6, R11, R22 */
		/* 820F22E4h case    7:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R11,regs.R22);
		/* 820F22E4h case    7:*/		return 0x820F22E8;
		  /* 820F22E8h */ case    8:  		/* lwz R9, <#[R24 + 16]> */
		/* 820F22E8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000010) );
		/* 820F22E8h case    8:*/		return 0x820F22EC;
		  /* 820F22ECh */ case    9:  		/* addi R11, R1, 80 */
		/* 820F22ECh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820F22ECh case    9:*/		return 0x820F22F0;
		  /* 820F22F0h */ case   10:  		/* lwz R8, <#[R25 + 20]> */
		/* 820F22F0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000014) );
		/* 820F22F0h case   10:*/		return 0x820F22F4;
		  /* 820F22F4h */ case   11:  		/* addi R3, R1, 96 */
		/* 820F22F4h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F22F4h case   11:*/		return 0x820F22F8;
		  /* 820F22F8h */ case   12:  		/* add R7, R10, R11 */
		/* 820F22F8h case   12:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 820F22F8h case   12:*/		return 0x820F22FC;
		  /* 820F22FCh */ case   13:  		/* addi R31, R1, 112 */
		/* 820F22FCh case   13:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x70);
		/* 820F22FCh case   13:*/		return 0x820F2300;
		  /* 820F2300h */ case   14:  		/* addi R30, R1, 128 */
		/* 820F2300h case   14:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x80);
		/* 820F2300h case   14:*/		return 0x820F2304;
		  /* 820F2304h */ case   15:  		/* lwzx R11, <#[R10 + R9]> */
		/* 820F2304h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F2304h case   15:*/		return 0x820F2308;
		  /* 820F2308h */ case   16:  		/* addi R29, R1, 144 */
		/* 820F2308h case   16:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R1,0x90);
		/* 820F2308h case   16:*/		return 0x820F230C;
		  /* 820F230Ch */ case   17:  		/* addi R27, R1, 160 */
		/* 820F230Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R1,0xA0);
		/* 820F230Ch case   17:*/		return 0x820F2310;
		  /* 820F2310h */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F2310h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2310h case   18:*/		return 0x820F2314;
		  /* 820F2314h */ case   19:  		/* lwzx R9, <#[R6 + R7]> */
		/* 820F2314h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 820F2314h case   19:*/		return 0x820F2318;
		  /* 820F2318h */ case   20:  		/* addi R26, R1, 176 */
		/* 820F2318h case   20:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R1,0xB0);
		/* 820F2318h case   20:*/		return 0x820F231C;
		  /* 820F231Ch */ case   21:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F231Ch case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F231Ch case   21:*/		return 0x820F2320;
		  /* 820F2320h */ case   22:  		/* addi R21, R1, 192 */
		/* 820F2320h case   22:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R1,0xC0);
		/* 820F2320h case   22:*/		return 0x820F2324;
		  /* 820F2324h */ case   23:  		/* cmpwi CR6, R28, 0 */
		/* 820F2324h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820F2324h case   23:*/		return 0x820F2328;
		  /* 820F2328h */ case   24:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820F2328h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820F2328h case   24:*/		return 0x820F232C;
		  /* 820F232Ch */ case   25:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820F232Ch case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820F232Ch case   25:*/		return 0x820F2330;
		  /* 820F2330h */ case   26:  		/* lwz R20, <#[R11 + 8]> */
		/* 820F2330h case   26:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R11 + 0x00000008) );
		/* 820F2330h case   26:*/		return 0x820F2334;
		  /* 820F2334h */ case   27:  		/* lwz R19, <#[R11 + 12]> */
		/* 820F2334h case   27:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F2334h case   27:*/		return 0x820F2338;
		  /* 820F2338h */ case   28:  		/* lwz R18, <#[R11 + 16]> */
		/* 820F2338h case   28:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R11 + 0x00000010) );
		/* 820F2338h case   28:*/		return 0x820F233C;
		  /* 820F233Ch */ case   29:  		/* lwz R17, <#[R11 + 20]> */
		/* 820F233Ch case   29:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R11 + 0x00000014) );
		/* 820F233Ch case   29:*/		return 0x820F2340;
		  /* 820F2340h */ case   30:  		/* lwz R16, <#[R11 + 24]> */
		/* 820F2340h case   30:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R11 + 0x00000018) );
		/* 820F2340h case   30:*/		return 0x820F2344;
		  /* 820F2344h */ case   31:  		/* lwz R8, <#[R11 + 60]> */
		/* 820F2344h case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F2344h case   31:*/		return 0x820F2348;
		  /* 820F2348h */ case   32:  		/* lwz R15, <#[R11 + 72]> */
		/* 820F2348h case   32:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R11 + 0x00000048) );
		/* 820F2348h case   32:*/		return 0x820F234C;
		  /* 820F234Ch */ case   33:  		/* lwz R14, <#[R11 + 104]> */
		/* 820F234Ch case   33:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R11 + 0x00000068) );
		/* 820F234Ch case   33:*/		return 0x820F2350;
		  /* 820F2350h */ case   34:  		/* stw R20, <#[R7]> */
		/* 820F2350h case   34:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R7 + 0x00000000) );
		/* 820F2350h case   34:*/		return 0x820F2354;
		  /* 820F2354h */ case   35:  		/* lwz R20, <#[R1 + 420]> */
		/* 820F2354h case   35:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x000001A4) );
		/* 820F2354h case   35:*/		return 0x820F2358;
		  /* 820F2358h */ case   36:  		/* stwx R19, <#[R10 + R3]> */
		/* 820F2358h case   36:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 820F2358h case   36:*/		return 0x820F235C;
		  /* 820F235Ch */ case   37:  		/* stwx R18, <#[R10 + R31]> */
		/* 820F235Ch case   37:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 820F235Ch case   37:*/		return 0x820F2360;
		  /* 820F2360h */ case   38:  		/* stwx R17, <#[R10 + R30]> */
		/* 820F2360h case   38:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 820F2360h case   38:*/		return 0x820F2364;
		  /* 820F2364h */ case   39:  		/* stwx R16, <#[R10 + R29]> */
		/* 820F2364h case   39:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 820F2364h case   39:*/		return 0x820F2368;
		  /* 820F2368h */ case   40:  		/* stwx R8, <#[R10 + R27]> */
		/* 820F2368h case   40:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 820F2368h case   40:*/		return 0x820F236C;
		  /* 820F236Ch */ case   41:  		/* stwx R15, <#[R10 + R26]> */
		/* 820F236Ch case   41:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 820F236Ch case   41:*/		return 0x820F2370;
		  /* 820F2370h */ case   42:  		/* stwx R14, <#[R10 + R21]> */
		/* 820F2370h case   42:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R10 + regs.R21 + 0x00000000) );
		/* 820F2370h case   42:*/		return 0x820F2374;
		  /* 820F2374h */ case   43:  		/* bc 4, CR6_EQ, 92 */
		/* 820F2374h case   43:*/		if ( !regs.CR[6].eq ) { return 0x820F23D0;  }
		/* 820F2374h case   43:*/		return 0x820F2378;
		  /* 820F2378h */ case   44:  		/* lwz R7, <#[R9 + 4]> */
		/* 820F2378h case   44:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000004) );
		/* 820F2378h case   44:*/		return 0x820F237C;
		  /* 820F237Ch */ case   45:  		/* stw R7, <#[R11 + 4]> */
		/* 820F237Ch case   45:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 820F237Ch case   45:*/		return 0x820F2380;
		  /* 820F2380h */ case   46:  		/* lwz R7, <#[R9 + 8]> */
		/* 820F2380h case   46:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000008) );
		/* 820F2380h case   46:*/		return 0x820F2384;
		  /* 820F2384h */ case   47:  		/* stw R7, <#[R11 + 8]> */
		/* 820F2384h case   47:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 820F2384h case   47:*/		return 0x820F2388;
		  /* 820F2388h */ case   48:  		/* lwz R7, <#[R9 + 12]> */
		/* 820F2388h case   48:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x0000000C) );
		/* 820F2388h case   48:*/		return 0x820F238C;
		  /* 820F238Ch */ case   49:  		/* stw R7, <#[R11 + 12]> */
		/* 820F238Ch case   49:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F238Ch case   49:*/		return 0x820F2390;
		  /* 820F2390h */ case   50:  		/* lwz R7, <#[R9 + 16]> */
		/* 820F2390h case   50:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000010) );
		/* 820F2390h case   50:*/		return 0x820F2394;
		  /* 820F2394h */ case   51:  		/* stw R7, <#[R11 + 16]> */
		/* 820F2394h case   51:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000010) );
		/* 820F2394h case   51:*/		return 0x820F2398;
		  /* 820F2398h */ case   52:  		/* lwz R7, <#[R9 + 20]> */
		/* 820F2398h case   52:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000014) );
		/* 820F2398h case   52:*/		return 0x820F239C;
		  /* 820F239Ch */ case   53:  		/* stw R7, <#[R11 + 20]> */
		/* 820F239Ch case   53:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000014) );
		/* 820F239Ch case   53:*/		return 0x820F23A0;
		  /* 820F23A0h */ case   54:  		/* lwz R7, <#[R9 + 24]> */
		/* 820F23A0h case   54:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000018) );
		/* 820F23A0h case   54:*/		return 0x820F23A4;
		  /* 820F23A4h */ case   55:  		/* stw R7, <#[R11 + 24]> */
		/* 820F23A4h case   55:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000018) );
		/* 820F23A4h case   55:*/		return 0x820F23A8;
		  /* 820F23A8h */ case   56:  		/* lwz R7, <#[R9 + 72]> */
		/* 820F23A8h case   56:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000048) );
		/* 820F23A8h case   56:*/		return 0x820F23AC;
		  /* 820F23ACh */ case   57:  		/* stw R7, <#[R11 + 72]> */
		/* 820F23ACh case   57:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000048) );
		/* 820F23ACh case   57:*/		return 0x820F23B0;
		  /* 820F23B0h */ case   58:  		/* lwz R7, <#[R9 + 104]> */
		/* 820F23B0h case   58:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000068) );
		/* 820F23B0h case   58:*/		return 0x820F23B4;
		  /* 820F23B4h */ case   59:  		/* stw R7, <#[R11 + 104]> */
		/* 820F23B4h case   59:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000068) );
		/* 820F23B4h case   59:*/		return 0x820F23B8;
		  /* 820F23B8h */ case   60:  		/* lwz R9, <#[R9 + 60]> */
		/* 820F23B8h case   60:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000003C) );
		/* 820F23B8h case   60:*/		return 0x820F23BC;
		  /* 820F23BCh */ case   61:  		/* xor R7, R9, R20 */
		/* 820F23BCh case   61:*/		cpu::op::xor<0>(regs,&regs.R7,regs.R9,regs.R20);
		/* 820F23BCh case   61:*/		return 0x820F23C0;
		  /* 820F23C0h */ case   62:  		/* and R9, R9, R5 */
		/* 820F23C0h case   62:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 820F23C0h case   62:*/		return 0x820F23C4;
		  /* 820F23C4h */ case   63:  		/* or R9, R7, R9 */
		/* 820F23C4h case   63:*/		cpu::op::or<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820F23C4h case   63:*/		return 0x820F23C8;
		  /* 820F23C8h */ case   64:  		/* or R9, R9, R8 */
		/* 820F23C8h case   64:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820F23C8h case   64:*/		return 0x820F23CC;
		  /* 820F23CCh */ case   65:  		/* b 16 */
		/* 820F23CCh case   65:*/		return 0x820F23DC;
		/* 820F23CCh case   65:*/		return 0x820F23D0;
	}
	return 0x820F23D0;
} // Block from 820F22C8h-820F23D0h (66 instructions)

//////////////////////////////////////////////////////
// Block at 820F23D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F23D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F23D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F23D0);
		  /* 820F23D0h */ case    0:  		/* and R9, R5, R8 */
		/* 820F23D0h case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R5,regs.R8);
		/* 820F23D0h case    0:*/		return 0x820F23D4;
		  /* 820F23D4h */ case    1:  		/* xor R8, R8, R20 */
		/* 820F23D4h case    1:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R8,regs.R20);
		/* 820F23D4h case    1:*/		return 0x820F23D8;
		  /* 820F23D8h */ case    2:  		/* or R9, R8, R9 */
		/* 820F23D8h case    2:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820F23D8h case    2:*/		return 0x820F23DC;
	}
	return 0x820F23DC;
} // Block from 820F23D0h-820F23DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F23DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F23DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F23DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F23DC);
		  /* 820F23DCh */ case    0:  		/* addi R4, R4, 1 */
		/* 820F23DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820F23DCh case    0:*/		return 0x820F23E0;
		  /* 820F23E0h */ case    1:  		/* stw R9, <#[R11 + 60]> */
		/* 820F23E0h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F23E0h case    1:*/		return 0x820F23E4;
		  /* 820F23E4h */ case    2:  		/* lwz R27, <#[R24 + 12]> */
		/* 820F23E4h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R24 + 0x0000000C) );
		/* 820F23E4h case    2:*/		return 0x820F23E8;
		  /* 820F23E8h */ case    3:  		/* addi R10, R10, 4 */
		/* 820F23E8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F23E8h case    3:*/		return 0x820F23EC;
		  /* 820F23ECh */ case    4:  		/* cmplw CR6, R4, R27 */
		/* 820F23ECh case    4:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R27);
		/* 820F23ECh case    4:*/		return 0x820F23F0;
		  /* 820F23F0h */ case    5:  		/* bc 12, CR6_LT, -264 */
		/* 820F23F0h case    5:*/		if ( regs.CR[6].lt ) { return 0x820F22E8;  }
		/* 820F23F0h case    5:*/		return 0x820F23F4;
		  /* 820F23F4h */ case    6:  		/* lis R21, 8 */
		/* 820F23F4h case    6:*/		cpu::op::lis<0>(regs,&regs.R21,0x8);
		/* 820F23F4h case    6:*/		return 0x820F23F8;
	}
	return 0x820F23F8;
} // Block from 820F23DCh-820F23F8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F23F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F23F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F23F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F23F8);
		  /* 820F23F8h */ case    0:  		/* li R30, 0 */
		/* 820F23F8h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820F23F8h case    0:*/		return 0x820F23FC;
		  /* 820F23FCh */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 820F23FCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820F23FCh case    1:*/		return 0x820F2400;
		  /* 820F2400h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 820F2400h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F2430;  }
		/* 820F2400h case    2:*/		return 0x820F2404;
		  /* 820F2404h */ case    3:  		/* lwz R29, <#[R24 + 16]> */
		/* 820F2404h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R24 + 0x00000010) );
		/* 820F2404h case    3:*/		return 0x820F2408;
		  /* 820F2408h */ case    4:  		/* li R31, 0 */
		/* 820F2408h case    4:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820F2408h case    4:*/		return 0x820F240C;
		  /* 820F240Ch */ case    5:  		/* mr R3, R25 */
		/* 820F240Ch case    5:*/		regs.R3 = regs.R25;
		/* 820F240Ch case    5:*/		return 0x820F2410;
		  /* 820F2410h */ case    6:  		/* lwzx R4, <#[R29 + R31]> */
		/* 820F2410h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 820F2410h case    6:*/		return 0x820F2414;
		  /* 820F2414h */ case    7:  		/* bl -7412 */
		/* 820F2414h case    7:*/		regs.LR = 0x820F2418; return 0x820F0720;
		/* 820F2414h case    7:*/		return 0x820F2418;
		  /* 820F2418h */ case    8:  		/* cmpwi CR6, R3, 1 */
		/* 820F2418h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 820F2418h case    8:*/		return 0x820F241C;
		  /* 820F241Ch */ case    9:  		/* bc 12, CR6_EQ, 628 */
		/* 820F241Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820F2690;  }
		/* 820F241Ch case    9:*/		return 0x820F2420;
		  /* 820F2420h */ case   10:  		/* addi R30, R30, 1 */
		/* 820F2420h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820F2420h case   10:*/		return 0x820F2424;
		  /* 820F2424h */ case   11:  		/* addi R31, R31, 4 */
		/* 820F2424h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820F2424h case   11:*/		return 0x820F2428;
		  /* 820F2428h */ case   12:  		/* cmplw CR6, R30, R27 */
		/* 820F2428h case   12:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R27);
		/* 820F2428h case   12:*/		return 0x820F242C;
		  /* 820F242Ch */ case   13:  		/* bc 12, CR6_LT, -32 */
		/* 820F242Ch case   13:*/		if ( regs.CR[6].lt ) { return 0x820F240C;  }
		/* 820F242Ch case   13:*/		return 0x820F2430;
	}
	return 0x820F2430;
} // Block from 820F23F8h-820F2430h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F2430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2430);
		  /* 820F2430h */ case    0:  		/* li R11, -1 */
		/* 820F2430h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820F2430h case    0:*/		return 0x820F2434;
		  /* 820F2434h */ case    1:  		/* li R26, 0 */
		/* 820F2434h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820F2434h case    1:*/		return 0x820F2438;
		  /* 820F2438h */ case    2:  		/* mr R3, R11 */
		/* 820F2438h case    2:*/		regs.R3 = regs.R11;
		/* 820F2438h case    2:*/		return 0x820F243C;
		  /* 820F243Ch */ case    3:  		/* mr R31, R11 */
		/* 820F243Ch case    3:*/		regs.R31 = regs.R11;
		/* 820F243Ch case    3:*/		return 0x820F2440;
		  /* 820F2440h */ case    4:  		/* li R29, 0 */
		/* 820F2440h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820F2440h case    4:*/		return 0x820F2444;
		  /* 820F2444h */ case    5:  		/* cmplwi CR6, R27, 0 */
		/* 820F2444h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820F2444h case    5:*/		return 0x820F2448;
		  /* 820F2448h */ case    6:  		/* bc 12, CR6_EQ, 200 */
		/* 820F2448h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F2510;  }
		/* 820F2448h case    6:*/		return 0x820F244C;
		  /* 820F244Ch */ case    7:  		/* addi R11, R1, 80 */
		/* 820F244Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820F244Ch case    7:*/		return 0x820F2450;
		  /* 820F2450h */ case    8:  		/* lwz R5, <#[R24 + 16]> */
		/* 820F2450h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R24 + 0x00000010) );
		/* 820F2450h case    8:*/		return 0x820F2454;
		  /* 820F2454h */ case    9:  		/* lwz R6, <#[R25 + 20]> */
		/* 820F2454h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R25 + 0x00000014) );
		/* 820F2454h case    9:*/		return 0x820F2458;
		  /* 820F2458h */ case   10:  		/* li R10, 0 */
		/* 820F2458h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F2458h case   10:*/		return 0x820F245C;
		  /* 820F245Ch */ case   11:  		/* lwz R30, <#[R25 + 136]> */
		/* 820F245Ch case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R25 + 0x00000088) );
		/* 820F245Ch case   11:*/		return 0x820F2460;
		  /* 820F2460h */ case   12:  		/* subf R4, R11, R22 */
		/* 820F2460h case   12:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R11,regs.R22);
		/* 820F2460h case   12:*/		return 0x820F2464;
		  /* 820F2464h */ case   13:  		/* addi R11, R1, 80 */
		/* 820F2464h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820F2464h case   13:*/		return 0x820F2468;
		  /* 820F2468h */ case   14:  		/* lwzx R9, <#[R5 + R10]> */
		/* 820F2468h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 820F2468h case   14:*/		return 0x820F246C;
		  /* 820F246Ch */ case   15:  		/* add R7, R10, R11 */
		/* 820F246Ch case   15:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 820F246Ch case   15:*/		return 0x820F2470;
		  /* 820F2470h */ case   16:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 820F2470h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 820F2470h case   16:*/		return 0x820F2474;
		  /* 820F2474h */ case   17:  		/* lwzx R8, <#[R7 + R4]> */
		/* 820F2474h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R4 + 0x00000000) );
		/* 820F2474h case   17:*/		return 0x820F2478;
		  /* 820F2478h */ case   18:  		/* lwzx R9, <#[R11 + R6]> */
		/* 820F2478h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 820F2478h case   18:*/		return 0x820F247C;
		  /* 820F247Ch */ case   19:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820F247Ch case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820F247Ch case   19:*/		return 0x820F2480;
		  /* 820F2480h */ case   20:  		/* lwz R11, <#[R9 + 84]> */
		/* 820F2480h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000054) );
		/* 820F2480h case   20:*/		return 0x820F2484;
		  /* 820F2484h */ case   21:  		/* lwzx R8, <#[R8 + R6]> */
		/* 820F2484h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 820F2484h case   21:*/		return 0x820F2488;
		  /* 820F2488h */ case   22:  		/* cmplw CR6, R11, R3 */
		/* 820F2488h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 820F2488h case   22:*/		return 0x820F248C;
		  /* 820F248Ch */ case   23:  		/* bc 4, CR6_LT, 8 */
		/* 820F248Ch case   23:*/		if ( !regs.CR[6].lt ) { return 0x820F2494;  }
		/* 820F248Ch case   23:*/		return 0x820F2490;
		  /* 820F2490h */ case   24:  		/* mr R3, R11 */
		/* 820F2490h case   24:*/		regs.R3 = regs.R11;
		/* 820F2490h case   24:*/		return 0x820F2494;
	}
	return 0x820F2494;
} // Block from 820F2430h-820F2494h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820F2494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2494);
		  /* 820F2494h */ case    0:  		/* lwz R11, <#[R9 + 88]> */
		/* 820F2494h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000058) );
		/* 820F2494h case    0:*/		return 0x820F2498;
		  /* 820F2498h */ case    1:  		/* cmplw CR6, R11, R26 */
		/* 820F2498h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820F2498h case    1:*/		return 0x820F249C;
		  /* 820F249Ch */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 820F249Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x820F24A4;  }
		/* 820F249Ch case    2:*/		return 0x820F24A0;
		  /* 820F24A0h */ case    3:  		/* mr R26, R11 */
		/* 820F24A0h case    3:*/		regs.R26 = regs.R11;
		/* 820F24A0h case    3:*/		return 0x820F24A4;
	}
	return 0x820F24A4;
} // Block from 820F2494h-820F24A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F24A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F24A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F24A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F24A4);
		  /* 820F24A4h */ case    0:  		/* lwz R11, <#[R8 + 4]> */
		/* 820F24A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 820F24A4h case    0:*/		return 0x820F24A8;
		  /* 820F24A8h */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 820F24A8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820F24A8h case    1:*/		return 0x820F24AC;
		  /* 820F24ACh */ case    2:  		/* bc 4, CR6_EQ, 68 */
		/* 820F24ACh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F24F0;  }
		/* 820F24ACh case    2:*/		return 0x820F24B0;
		  /* 820F24B0h */ case    3:  		/* lwz R11, <#[R7]> */
		/* 820F24B0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 820F24B0h case    3:*/		return 0x820F24B4;
		  /* 820F24B4h */ case    4:  		/* lwz R7, <#[R8 + 8]> */
		/* 820F24B4h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000008) );
		/* 820F24B4h case    4:*/		return 0x820F24B8;
		  /* 820F24B8h */ case    5:  		/* cmplw CR6, R11, R7 */
		/* 820F24B8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 820F24B8h case    5:*/		return 0x820F24BC;
		  /* 820F24BCh */ case    6:  		/* bc 4, CR6_EQ, 52 */
		/* 820F24BCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x820F24F0;  }
		/* 820F24BCh case    6:*/		return 0x820F24C0;
		  /* 820F24C0h */ case    7:  		/* addi R11, R1, 96 */
		/* 820F24C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820F24C0h case    7:*/		return 0x820F24C4;
		  /* 820F24C4h */ case    8:  		/* lwz R7, <#[R8 + 12]> */
		/* 820F24C4h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x0000000C) );
		/* 820F24C4h case    8:*/		return 0x820F24C8;
		  /* 820F24C8h */ case    9:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820F24C8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F24C8h case    9:*/		return 0x820F24CC;
		  /* 820F24CCh */ case   10:  		/* cmplw CR6, R11, R7 */
		/* 820F24CCh case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 820F24CCh case   10:*/		return 0x820F24D0;
		  /* 820F24D0h */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 820F24D0h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820F24F0;  }
		/* 820F24D0h case   11:*/		return 0x820F24D4;
		  /* 820F24D4h */ case   12:  		/* addi R11, R1, 112 */
		/* 820F24D4h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820F24D4h case   12:*/		return 0x820F24D8;
		  /* 820F24D8h */ case   13:  		/* lwz R7, <#[R8 + 16]> */
		/* 820F24D8h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000010) );
		/* 820F24D8h case   13:*/		return 0x820F24DC;
		  /* 820F24DCh */ case   14:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820F24DCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F24DCh case   14:*/		return 0x820F24E0;
		  /* 820F24E0h */ case   15:  		/* cmplw CR6, R11, R7 */
		/* 820F24E0h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 820F24E0h case   15:*/		return 0x820F24E4;
		  /* 820F24E4h */ case   16:  		/* bc 4, CR6_EQ, 12 */
		/* 820F24E4h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820F24F0;  }
		/* 820F24E4h case   16:*/		return 0x820F24E8;
		  /* 820F24E8h */ case   17:  		/* lwz R11, <#[R9 + 80]> */
		/* 820F24E8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000050) );
		/* 820F24E8h case   17:*/		return 0x820F24EC;
		  /* 820F24ECh */ case   18:  		/* b 8 */
		/* 820F24ECh case   18:*/		return 0x820F24F4;
		/* 820F24ECh case   18:*/		return 0x820F24F0;
	}
	return 0x820F24F0;
} // Block from 820F24A4h-820F24F0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F24F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F24F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F24F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F24F0);
		  /* 820F24F0h */ case    0:  		/* lwz R11, <#[R8 + 80]> */
		/* 820F24F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000050) );
		/* 820F24F0h case    0:*/		return 0x820F24F4;
	}
	return 0x820F24F4;
} // Block from 820F24F0h-820F24F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F24F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F24F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F24F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F24F4);
		  /* 820F24F4h */ case    0:  		/* cmplw CR6, R11, R31 */
		/* 820F24F4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820F24F4h case    0:*/		return 0x820F24F8;
		  /* 820F24F8h */ case    1:  		/* bc 4, CR6_LT, 8 */
		/* 820F24F8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820F2500;  }
		/* 820F24F8h case    1:*/		return 0x820F24FC;
		  /* 820F24FCh */ case    2:  		/* mr R31, R11 */
		/* 820F24FCh case    2:*/		regs.R31 = regs.R11;
		/* 820F24FCh case    2:*/		return 0x820F2500;
	}
	return 0x820F2500;
} // Block from 820F24F4h-820F2500h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F2500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2500);
		  /* 820F2500h */ case    0:  		/* addi R29, R29, 1 */
		/* 820F2500h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820F2500h case    0:*/		return 0x820F2504;
		  /* 820F2504h */ case    1:  		/* addi R10, R10, 4 */
		/* 820F2504h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F2504h case    1:*/		return 0x820F2508;
		  /* 820F2508h */ case    2:  		/* cmplw CR6, R29, R27 */
		/* 820F2508h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R27);
		/* 820F2508h case    2:*/		return 0x820F250C;
		  /* 820F250Ch */ case    3:  		/* bc 12, CR6_LT, -168 */
		/* 820F250Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820F2464;  }
		/* 820F250Ch case    3:*/		return 0x820F2510;
	}
	return 0x820F2510;
} // Block from 820F2500h-820F2510h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F2510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2510);
		  /* 820F2510h */ case    0:  		/* cmpwi CR6, R23, 0 */
		/* 820F2510h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 820F2510h case    0:*/		return 0x820F2514;
		  /* 820F2514h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 820F2514h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F252C;  }
		/* 820F2514h case    1:*/		return 0x820F2518;
		  /* 820F2518h */ case    2:  		/* cmplw CR6, R31, R26 */
		/* 820F2518h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 820F2518h case    2:*/		return 0x820F251C;
		  /* 820F251Ch */ case    3:  		/* bc 4, CR6_LT, 16 */
		/* 820F251Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x820F252C;  }
		/* 820F251Ch case    3:*/		return 0x820F2520;
	}
	return 0x820F2520;
} // Block from 820F2510h-820F2520h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F2520h
// Function '?FindSemantic@CShaderProgram@D3DXShader@@IAAPAUD3DX_SEMANTIC@2@K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2520);
		  /* 820F2520h */ case    0:  		/* lwz R11, <#[R25 + 108]> */
		/* 820F2520h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000006C) );
		/* 820F2520h case    0:*/		return 0x820F2524;
		  /* 820F2524h */ case    1:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820F2524h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820F2524h case    1:*/		return 0x820F2528;
		  /* 820F2528h */ case    2:  		/* bc 12, CR0_EQ, 360 */
		/* 820F2528h case    2:*/		if ( regs.CR[0].eq ) { return 0x820F2690;  }
		/* 820F2528h case    2:*/		return 0x820F252C;
	}
	return 0x820F252C;
} // Block from 820F2520h-820F252Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F252Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F252C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F252C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F252C);
		  /* 820F252Ch */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 820F252Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820F252Ch case    0:*/		return 0x820F2530;
		  /* 820F2530h */ case    1:  		/* bc 4, CR6_EQ, 692 */
		/* 820F2530h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F27E4;  }
		/* 820F2530h case    1:*/		return 0x820F2534;
		  /* 820F2534h */ case    2:  		/* mr R28, R3 */
		/* 820F2534h case    2:*/		regs.R28 = regs.R3;
		/* 820F2534h case    2:*/		return 0x820F2538;
		  /* 820F2538h */ case    3:  		/* cmplw CR6, R3, R26 */
		/* 820F2538h case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R26);
		/* 820F2538h case    3:*/		return 0x820F253C;
		  /* 820F253Ch */ case    4:  		/* bc 12, CR6_GT, 320 */
		/* 820F253Ch case    4:*/		if ( regs.CR[6].gt ) { return 0x820F267C;  }
		/* 820F253Ch case    4:*/		return 0x820F2540;
		  /* 820F2540h */ case    5:  		/* lwz R11, <#[R25 + 24]> */
		/* 820F2540h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000018) );
		/* 820F2540h case    5:*/		return 0x820F2544;
		  /* 820F2544h */ case    6:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820F2544h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820F2544h case    6:*/		return 0x820F2548;
		  /* 820F2548h */ case    7:  		/* add R29, R10, R11 */
		/* 820F2548h case    7:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R11);
		/* 820F2548h case    7:*/		return 0x820F254C;
		  /* 820F254Ch */ case    8:  		/* lwz R11, <#[R29]> */
		/* 820F254Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820F254Ch case    8:*/		return 0x820F2550;
		  /* 820F2550h */ case    9:  		/* lwz R31, <#[R11]> */
		/* 820F2550h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 820F2550h case    9:*/		return 0x820F2554;
		  /* 820F2554h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 820F2554h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820F2554h case   10:*/		return 0x820F2558;
		  /* 820F2558h */ case   11:  		/* bc 12, CR6_EQ, 276 */
		/* 820F2558h case   11:*/		if ( regs.CR[6].eq ) { return 0x820F266C;  }
		/* 820F2558h case   11:*/		return 0x820F255C;
		  /* 820F255Ch */ case   12:  		/* lwz R9, <#[R11 + 4]> */
		/* 820F255Ch case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820F255Ch case   12:*/		return 0x820F2560;
		  /* 820F2560h */ case   13:  		/* rlwinm R5, R31, 0, 12, 31 */
		/* 820F2560h case   13:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R5,regs.R31);
		/* 820F2560h case   13:*/		return 0x820F2564;
		  /* 820F2564h */ case   14:  		/* lwz R10, <#[R11 + 8]> */
		/* 820F2564h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820F2564h case   14:*/		return 0x820F2568;
		  /* 820F2568h */ case   15:  		/* li R30, 0 */
		/* 820F2568h case   15:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820F2568h case   15:*/		return 0x820F256C;
		  /* 820F256Ch */ case   16:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 820F256Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 820F256Ch case   16:*/		return 0x820F2570;
		  /* 820F2570h */ case   17:  		/* add R3, R11, R10 */
		/* 820F2570h case   17:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820F2570h case   17:*/		return 0x820F2574;
		  /* 820F2574h */ case   18:  		/* cmplw CR6, R10, R3 */
		/* 820F2574h case   18:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R3);
		/* 820F2574h case   18:*/		return 0x820F2578;
		  /* 820F2578h */ case   19:  		/* bc 4, CR6_LT, 244 */
		/* 820F2578h case   19:*/		if ( !regs.CR[6].lt ) { return 0x820F266C;  }
		/* 820F2578h case   19:*/		return 0x820F257C;
		  /* 820F257Ch */ case   20:  		/* li R4, 0 */
		/* 820F257Ch case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F257Ch case   20:*/		return 0x820F2580;
		  /* 820F2580h */ case   21:  		/* cmplwi CR6, R5, 0 */
		/* 820F2580h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820F2580h case   21:*/		return 0x820F2584;
		  /* 820F2584h */ case   22:  		/* bc 12, CR6_EQ, 140 */
		/* 820F2584h case   22:*/		if ( regs.CR[6].eq ) { return 0x820F2610;  }
		/* 820F2584h case   22:*/		return 0x820F2588;
		  /* 820F2588h */ case   23:  		/* mr R6, R10 */
		/* 820F2588h case   23:*/		regs.R6 = regs.R10;
		/* 820F2588h case   23:*/		return 0x820F258C;
		  /* 820F258Ch */ case   24:  		/* mtspr CTR, R5 */
		/* 820F258Ch case   24:*/		regs.CTR = regs.R5;
		/* 820F258Ch case   24:*/		return 0x820F2590;
		  /* 820F2590h */ case   25:  		/* li R7, 0 */
		/* 820F2590h case   25:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F2590h case   25:*/		return 0x820F2594;
		  /* 820F2594h */ case   26:  		/* cmplwi CR6, R27, 0 */
		/* 820F2594h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820F2594h case   26:*/		return 0x820F2598;
	}
	return 0x820F2598;
} // Block from 820F252Ch-820F2598h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820F2598h
// Function '??_GCShaderProgram@D3DXShader@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2598);
		  /* 820F2598h */ case    0:  		/* bc 12, CR6_EQ, 52 */
		/* 820F2598h case    0:*/		if ( regs.CR[6].eq ) { return 0x820F25CC;  }
		/* 820F2598h case    0:*/		return 0x820F259C;
		  /* 820F259Ch */ case    1:  		/* lwz R9, <#[R24 + 16]> */
		/* 820F259Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000010) );
		/* 820F259Ch case    1:*/		return 0x820F25A0;
		  /* 820F25A0h */ case    2:  		/* li R11, 0 */
		/* 820F25A0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F25A0h case    2:*/		return 0x820F25A4;
		  /* 820F25A4h */ case    3:  		/* lwz R8, <#[R6]> */
		/* 820F25A4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000000) );
		/* 820F25A4h case    3:*/		return 0x820F25A8;
		  /* 820F25A8h */ case    4:  		/* lwzx R23, <#[R9 + R11]> */
		/* 820F25A8h case    4:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F25A8h case    4:*/		return 0x820F25AC;
		  /* 820F25ACh */ case    5:  		/* cmplw CR6, R23, R8 */
		/* 820F25ACh case    5:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R8);
		/* 820F25ACh case    5:*/		return 0x820F25B0;
		  /* 820F25B0h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 820F25B0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F25C8;  }
		/* 820F25B0h case    6:*/		return 0x820F25B4;
		  /* 820F25B4h */ case    7:  		/* addi R7, R7, 1 */
		/* 820F25B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820F25B4h case    7:*/		return 0x820F25B8;
		  /* 820F25B8h */ case    8:  		/* addi R11, R11, 4 */
		/* 820F25B8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F25B8h case    8:*/		return 0x820F25BC;
		  /* 820F25BCh */ case    9:  		/* cmplw CR6, R7, R27 */
		/* 820F25BCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R27);
		/* 820F25BCh case    9:*/		return 0x820F25C0;
		  /* 820F25C0h */ case   10:  		/* bc 12, CR6_LT, -24 */
		/* 820F25C0h case   10:*/		if ( regs.CR[6].lt ) { return 0x820F25A8;  }
		/* 820F25C0h case   10:*/		return 0x820F25C4;
		  /* 820F25C4h */ case   11:  		/* b 8 */
		/* 820F25C4h case   11:*/		return 0x820F25CC;
		/* 820F25C4h case   11:*/		return 0x820F25C8;
	}
	return 0x820F25C8;
} // Block from 820F2598h-820F25C8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F25C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F25C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F25C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F25C8);
		  /* 820F25C8h */ case    0:  		/* addi R4, R4, 1 */
		/* 820F25C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820F25C8h case    0:*/		return 0x820F25CC;
	}
	return 0x820F25CC;
} // Block from 820F25C8h-820F25CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F25CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F25CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F25CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F25CC);
		  /* 820F25CCh */ case    0:  		/* addi R6, R6, 4 */
		/* 820F25CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 820F25CCh case    0:*/		return 0x820F25D0;
		  /* 820F25D0h */ case    1:  		/* bc 16, CR0_LT, -64 */
		/* 820F25D0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F2590;  }
		/* 820F25D0h case    1:*/		return 0x820F25D4;
		  /* 820F25D4h */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 820F25D4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F25D4h case    2:*/		return 0x820F25D8;
		  /* 820F25D8h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 820F25D8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820F2610;  }
		/* 820F25D8h case    3:*/		return 0x820F25DC;
		  /* 820F25DCh */ case    4:  		/* cmplw CR6, R4, R5 */
		/* 820F25DCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 820F25DCh case    4:*/		return 0x820F25E0;
		  /* 820F25E0h */ case    5:  		/* bc 4, CR6_EQ, 176 */
		/* 820F25E0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820F2690;  }
		/* 820F25E0h case    5:*/		return 0x820F25E4;
		  /* 820F25E4h */ case    6:  		/* rlwinm R11, R31, 0, 0, 11 */
		/* 820F25E4h case    6:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R31);
		/* 820F25E4h case    6:*/		return 0x820F25E8;
	}
	return 0x820F25E8;
} // Block from 820F25CCh-820F25E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F25E8h
// Function '?IndexSemanticFromTable@CShaderProgram@D3DXShader@@IAAJPAVCArgument@2@PAUD3DX_SEMANTIC@2@GPAH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F25E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F25E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F25E8);
		  /* 820F25E8h */ case    0:  		/* lis R9, 28752 */
		/* 820F25E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0x7050);
		/* 820F25E8h case    0:*/		return 0x820F25EC;
		  /* 820F25ECh */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 820F25ECh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F25ECh case    1:*/		return 0x820F25F0;
		  /* 820F25F0h */ case    2:  		/* bc 12, CR6_EQ, 160 */
		/* 820F25F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F2690;  }
		/* 820F25F0h case    2:*/		return 0x820F25F4;
		  /* 820F25F4h */ case    3:  		/* lis R9, 28768 */
		/* 820F25F4h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x7060);
		/* 820F25F4h case    3:*/		return 0x820F25F8;
		  /* 820F25F8h */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 820F25F8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F25F8h case    4:*/		return 0x820F25FC;
		  /* 820F25FCh */ case    5:  		/* bc 12, CR6_EQ, 148 */
		/* 820F25FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820F2690;  }
		/* 820F25FCh case    5:*/		return 0x820F2600;
		  /* 820F2600h */ case    6:  		/* lis R9, 28784 */
		/* 820F2600h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0x7070);
		/* 820F2600h case    6:*/		return 0x820F2604;
		  /* 820F2604h */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 820F2604h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F2604h case    7:*/		return 0x820F2608;
		  /* 820F2608h */ case    8:  		/* bc 12, CR6_EQ, 136 */
		/* 820F2608h case    8:*/		if ( regs.CR[6].eq ) { return 0x820F2690;  }
		/* 820F2608h case    8:*/		return 0x820F260C;
		  /* 820F260Ch */ case    9:  		/* li R30, 1 */
		/* 820F260Ch case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820F260Ch case    9:*/		return 0x820F2610;
	}
	return 0x820F2610;
} // Block from 820F25E8h-820F2610h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F2610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2610);
		  /* 820F2610h */ case    0:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 820F2610h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 820F2610h case    0:*/		return 0x820F2614;
		  /* 820F2614h */ case    1:  		/* add R10, R11, R10 */
		/* 820F2614h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820F2614h case    1:*/		return 0x820F2618;
		  /* 820F2618h */ case    2:  		/* cmplw CR6, R10, R3 */
		/* 820F2618h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R3);
		/* 820F2618h case    2:*/		return 0x820F261C;
		  /* 820F261Ch */ case    3:  		/* bc 12, CR6_LT, -160 */
		/* 820F261Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820F257C;  }
		/* 820F261Ch case    3:*/		return 0x820F2620;
		  /* 820F2620h */ case    4:  		/* cmpwi CR6, R30, 0 */
		/* 820F2620h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820F2620h case    4:*/		return 0x820F2624;
		  /* 820F2624h */ case    5:  		/* bc 12, CR6_EQ, 72 */
		/* 820F2624h case    5:*/		if ( regs.CR[6].eq ) { return 0x820F266C;  }
		/* 820F2624h case    5:*/		return 0x820F2628;
		  /* 820F2628h */ case    6:  		/* rlwinm R11, R31, 0, 0, 3 */
		/* 820F2628h case    6:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R31);
		/* 820F2628h case    6:*/		return 0x820F262C;
		  /* 820F262Ch */ case    7:  		/* lis R10, 24576 */
		/* 820F262Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x6000);
		/* 820F262Ch case    7:*/		return 0x820F2630;
		  /* 820F2630h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820F2630h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F2630h case    8:*/		return 0x820F2634;
		  /* 820F2634h */ case    9:  		/* bc 12, CR6_EQ, 44 */
		/* 820F2634h case    9:*/		if ( regs.CR[6].eq ) { return 0x820F2660;  }
		/* 820F2634h case    9:*/		return 0x820F2638;
		  /* 820F2638h */ case   10:  		/* rlwinm R11, R31, 0, 0, 11 */
		/* 820F2638h case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R31);
		/* 820F2638h case   10:*/		return 0x820F263C;
		  /* 820F263Ch */ case   11:  		/* lis R10, 4304 */
		/* 820F263Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x10D0);
		/* 820F263Ch case   11:*/		return 0x820F2640;
		  /* 820F2640h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 820F2640h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F2640h case   12:*/		return 0x820F2644;
		  /* 820F2644h */ case   13:  		/* bc 12, CR6_EQ, 28 */
		/* 820F2644h case   13:*/		if ( regs.CR[6].eq ) { return 0x820F2660;  }
		/* 820F2644h case   13:*/		return 0x820F2648;
		  /* 820F2648h */ case   14:  		/* lis R10, 4320 */
		/* 820F2648h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x10E0);
		/* 820F2648h case   14:*/		return 0x820F264C;
		  /* 820F264Ch */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820F264Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F264Ch case   15:*/		return 0x820F2650;
		  /* 820F2650h */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 820F2650h case   16:*/		if ( regs.CR[6].eq ) { return 0x820F2660;  }
		/* 820F2650h case   16:*/		return 0x820F2654;
		  /* 820F2654h */ case   17:  		/* lis R10, 4352 */
		/* 820F2654h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x1100);
		/* 820F2654h case   17:*/		return 0x820F2658;
		  /* 820F2658h */ case   18:  		/* cmplw CR6, R11, R10 */
		/* 820F2658h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F2658h case   18:*/		return 0x820F265C;
		  /* 820F265Ch */ case   19:  		/* bc 4, CR6_EQ, 16 */
		/* 820F265Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x820F266C;  }
		/* 820F265Ch case   19:*/		return 0x820F2660;
	}
	return 0x820F2660;
} // Block from 820F2610h-820F2660h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820F2660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2660);
		  /* 820F2660h */ case    0:  		/* lwz R11, <#[R25 + 108]> */
		/* 820F2660h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000006C) );
		/* 820F2660h case    0:*/		return 0x820F2664;
		  /* 820F2664h */ case    1:  		/* rlwinm. R11, R11, 0, 24, 24 */
		/* 820F2664h case    1:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R11);
		/* 820F2664h case    1:*/		return 0x820F2668;
		  /* 820F2668h */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 820F2668h case    2:*/		if ( regs.CR[0].eq ) { return 0x820F2690;  }
		/* 820F2668h case    2:*/		return 0x820F266C;
	}
	return 0x820F266C;
} // Block from 820F2660h-820F266Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F266Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F266C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F266C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F266C);
		  /* 820F266Ch */ case    0:  		/* addi R28, R28, 1 */
		/* 820F266Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820F266Ch case    0:*/		return 0x820F2670;
		  /* 820F2670h */ case    1:  		/* addi R29, R29, 4 */
		/* 820F2670h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820F2670h case    1:*/		return 0x820F2674;
		  /* 820F2674h */ case    2:  		/* cmplw CR6, R28, R26 */
		/* 820F2674h case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R26);
		/* 820F2674h case    2:*/		return 0x820F2678;
		  /* 820F2678h */ case    3:  		/* bc 4, CR6_GT, -300 */
		/* 820F2678h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820F254C;  }
		/* 820F2678h case    3:*/		return 0x820F267C;
	}
	return 0x820F267C;
} // Block from 820F266Ch-820F267Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F267Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F267C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F267C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F267C);
		  /* 820F267Ch */ case    0:  		/* lwz R11, <#[R25 + 352]> */
		/* 820F267Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000160) );
		/* 820F267Ch case    0:*/		return 0x820F2680;
		  /* 820F2680h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820F2680h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F2680h case    1:*/		return 0x820F2684;
		  /* 820F2684h */ case    2:  		/* bc 12, CR6_EQ, 180 */
		/* 820F2684h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F2738;  }
		/* 820F2684h case    2:*/		return 0x820F2688;
		  /* 820F2688h */ case    3:  		/* li R11, 2 */
		/* 820F2688h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820F2688h case    3:*/		return 0x820F268C;
		  /* 820F268Ch */ case    4:  		/* stw R11, <#[R25 + 352]> */
		/* 820F268Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000160) );
		/* 820F268Ch case    4:*/		return 0x820F2690;
	}
	return 0x820F2690;
} // Block from 820F267Ch-820F2690h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F2690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2690);
		  /* 820F2690h */ case    0:  		/* lwz R11, <#[R24 + 12]> */
		/* 820F2690h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820F2690h case    0:*/		return 0x820F2694;
		  /* 820F2694h */ case    1:  		/* li R10, 0 */
		/* 820F2694h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F2694h case    1:*/		return 0x820F2698;
		  /* 820F2698h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820F2698h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F2698h case    2:*/		return 0x820F269C;
		  /* 820F269Ch */ case    3:  		/* bc 4, CR6_GT, -1232 */
		/* 820F269Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x820F21CC;  }
		/* 820F269Ch case    3:*/		return 0x820F26A0;
		  /* 820F26A0h */ case    4:  		/* li R11, 0 */
		/* 820F26A0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F26A0h case    4:*/		return 0x820F26A4;
		  /* 820F26A4h */ case    5:  		/* lwz R9, <#[R24 + 16]> */
		/* 820F26A4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000010) );
		/* 820F26A4h case    5:*/		return 0x820F26A8;
		  /* 820F26A8h */ case    6:  		/* addi R29, R1, 176 */
		/* 820F26A8h case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R1,0xB0);
		/* 820F26A8h case    6:*/		return 0x820F26AC;
		  /* 820F26ACh */ case    7:  		/* lwz R7, <#[R25 + 20]> */
		/* 820F26ACh case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000014) );
		/* 820F26ACh case    7:*/		return 0x820F26B0;
		  /* 820F26B0h */ case    8:  		/* addi R8, R1, 80 */
		/* 820F26B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 820F26B0h case    8:*/		return 0x820F26B4;
		  /* 820F26B4h */ case    9:  		/* addi R6, R1, 96 */
		/* 820F26B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 820F26B4h case    9:*/		return 0x820F26B8;
		  /* 820F26B8h */ case   10:  		/* lwz R4, <#[R25 + 136]> */
		/* 820F26B8h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x00000088) );
		/* 820F26B8h case   10:*/		return 0x820F26BC;
		  /* 820F26BCh */ case   11:  		/* addi R5, R1, 112 */
		/* 820F26BCh case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820F26BCh case   11:*/		return 0x820F26C0;
		  /* 820F26C0h */ case   12:  		/* addi R3, R1, 128 */
		/* 820F26C0h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 820F26C0h case   12:*/		return 0x820F26C4;
		  /* 820F26C4h */ case   13:  		/* lwzx R9, <#[R11 + R9]> */
		/* 820F26C4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F26C4h case   13:*/		return 0x820F26C8;
		  /* 820F26C8h */ case   14:  		/* addi R31, R1, 144 */
		/* 820F26C8h case   14:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x90);
		/* 820F26C8h case   14:*/		return 0x820F26CC;
		  /* 820F26CCh */ case   15:  		/* addi R30, R1, 160 */
		/* 820F26CCh case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0xA0);
		/* 820F26CCh case   15:*/		return 0x820F26D0;
		  /* 820F26D0h */ case   16:  		/* lwzx R8, <#[R11 + R8]> */
		/* 820F26D0h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820F26D0h case   16:*/		return 0x820F26D4;
		  /* 820F26D4h */ case   17:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F26D4h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F26D4h case   17:*/		return 0x820F26D8;
		  /* 820F26D8h */ case   18:  		/* lwzx R6, <#[R11 + R6]> */
		/* 820F26D8h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 820F26D8h case   18:*/		return 0x820F26DC;
		  /* 820F26DCh */ case   19:  		/* addi R28, R1, 192 */
		/* 820F26DCh case   19:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0xC0);
		/* 820F26DCh case   19:*/		return 0x820F26E0;
		  /* 820F26E0h */ case   20:  		/* lwzx R5, <#[R11 + R5]> */
		/* 820F26E0h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820F26E0h case   20:*/		return 0x820F26E4;
		  /* 820F26E4h */ case   21:  		/* lwzx R3, <#[R11 + R3]> */
		/* 820F26E4h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 820F26E4h case   21:*/		return 0x820F26E8;
		  /* 820F26E8h */ case   22:  		/* addi R10, R10, 1 */
		/* 820F26E8h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F26E8h case   22:*/		return 0x820F26EC;
		  /* 820F26ECh */ case   23:  		/* lwzx R31, <#[R11 + R31]> */
		/* 820F26ECh case   23:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820F26ECh case   23:*/		return 0x820F26F0;
		  /* 820F26F0h */ case   24:  		/* lwzx R30, <#[R11 + R30]> */
		/* 820F26F0h case   24:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820F26F0h case   24:*/		return 0x820F26F4;
		  /* 820F26F4h */ case   25:  		/* lwzx R9, <#[R9 + R7]> */
		/* 820F26F4h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820F26F4h case   25:*/		return 0x820F26F8;
		  /* 820F26F8h */ case   26:  		/* lwzx R7, <#[R11 + R29]> */
		/* 820F26F8h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820F26F8h case   26:*/		return 0x820F26FC;
		  /* 820F26FCh */ case   27:  		/* lwzx R29, <#[R11 + R28]> */
		/* 820F26FCh case   27:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 820F26FCh case   27:*/		return 0x820F2700;
		  /* 820F2700h */ case   28:  		/* addi R11, R11, 4 */
		/* 820F2700h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F2700h case   28:*/		return 0x820F2704;
		  /* 820F2704h */ case   29:  		/* stw R4, <#[R9 + 4]> */
		/* 820F2704h case   29:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R9 + 0x00000004) );
		/* 820F2704h case   29:*/		return 0x820F2708;
		  /* 820F2708h */ case   30:  		/* stw R8, <#[R9 + 8]> */
		/* 820F2708h case   30:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000008) );
		/* 820F2708h case   30:*/		return 0x820F270C;
		  /* 820F270Ch */ case   31:  		/* stw R6, <#[R9 + 12]> */
		/* 820F270Ch case   31:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + 0x0000000C) );
		/* 820F270Ch case   31:*/		return 0x820F2710;
		  /* 820F2710h */ case   32:  		/* stw R5, <#[R9 + 16]> */
		/* 820F2710h case   32:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R9 + 0x00000010) );
		/* 820F2710h case   32:*/		return 0x820F2714;
		  /* 820F2714h */ case   33:  		/* stw R3, <#[R9 + 20]> */
		/* 820F2714h case   33:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R9 + 0x00000014) );
		/* 820F2714h case   33:*/		return 0x820F2718;
		  /* 820F2718h */ case   34:  		/* stw R31, <#[R9 + 24]> */
		/* 820F2718h case   34:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R9 + 0x00000018) );
		/* 820F2718h case   34:*/		return 0x820F271C;
		  /* 820F271Ch */ case   35:  		/* stw R30, <#[R9 + 60]> */
		/* 820F271Ch case   35:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R9 + 0x0000003C) );
		/* 820F271Ch case   35:*/		return 0x820F2720;
		  /* 820F2720h */ case   36:  		/* stw R7, <#[R9 + 72]> */
		/* 820F2720h case   36:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000048) );
		/* 820F2720h case   36:*/		return 0x820F2724;
		  /* 820F2724h */ case   37:  		/* stw R29, <#[R9 + 104]> */
		/* 820F2724h case   37:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + 0x00000068) );
		/* 820F2724h case   37:*/		return 0x820F2728;
		  /* 820F2728h */ case   38:  		/* lwz R9, <#[R24 + 12]> */
		/* 820F2728h case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x0000000C) );
		/* 820F2728h case   38:*/		return 0x820F272C;
		  /* 820F272Ch */ case   39:  		/* cmplw CR6, R10, R9 */
		/* 820F272Ch case   39:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F272Ch case   39:*/		return 0x820F2730;
		  /* 820F2730h */ case   40:  		/* bc 12, CR6_LT, -140 */
		/* 820F2730h case   40:*/		if ( regs.CR[6].lt ) { return 0x820F26A4;  }
		/* 820F2730h case   40:*/		return 0x820F2734;
		  /* 820F2734h */ case   41:  		/* b -1384 */
		/* 820F2734h case   41:*/		return 0x820F21CC;
		/* 820F2734h case   41:*/		return 0x820F2738;
	}
	return 0x820F2738;
} // Block from 820F2690h-820F2738h (42 instructions)

//////////////////////////////////////////////////////
// Block at 820F2738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2738);
		  /* 820F2738h */ case    0:  		/* li R30, 0 */
		/* 820F2738h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820F2738h case    0:*/		return 0x820F273C;
		  /* 820F273Ch */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 820F273Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820F273Ch case    1:*/		return 0x820F2740;
		  /* 820F2740h */ case    2:  		/* bc 12, CR6_EQ, 148 */
		/* 820F2740h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F27D4;  }
		/* 820F2740h case    2:*/		return 0x820F2744;
		  /* 820F2744h */ case    3:  		/* li R31, 0 */
		/* 820F2744h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820F2744h case    3:*/		return 0x820F2748;
		  /* 820F2748h */ case    4:  		/* lwzx R11, <#[R31 + R22]> */
		/* 820F2748h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R22 + 0x00000000) );
		/* 820F2748h case    4:*/		return 0x820F274C;
		  /* 820F274Ch */ case    5:  		/* lwz R9, <#[R25 + 20]> */
		/* 820F274Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000014) );
		/* 820F274Ch case    5:*/		return 0x820F2750;
		  /* 820F2750h */ case    6:  		/* lwz R10, <#[R24 + 16]> */
		/* 820F2750h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000010) );
		/* 820F2750h case    6:*/		return 0x820F2754;
		  /* 820F2754h */ case    7:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 820F2754h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 820F2754h case    7:*/		return 0x820F2758;
		  /* 820F2758h */ case    8:  		/* lwzx R10, <#[R31 + R10]> */
		/* 820F2758h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 820F2758h case    8:*/		return 0x820F275C;
		  /* 820F275Ch */ case    9:  		/* lwzx R4, <#[R8 + R9]> */
		/* 820F275Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820F275Ch case    9:*/		return 0x820F2760;
		  /* 820F2760h */ case   10:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 820F2760h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 820F2760h case   10:*/		return 0x820F2764;
		  /* 820F2764h */ case   11:  		/* lwz R10, <#[R4 + 56]> */
		/* 820F2764h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000038) );
		/* 820F2764h case   11:*/		return 0x820F2768;
		  /* 820F2768h */ case   12:  		/* lwzx R3, <#[R8 + R9]> */
		/* 820F2768h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820F2768h case   12:*/		return 0x820F276C;
		  /* 820F276Ch */ case   13:  		/* cmpwi CR6, R10, -1 */
		/* 820F276Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820F276Ch case   13:*/		return 0x820F2770;
		  /* 820F2770h */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 820F2770h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820F277C;  }
		/* 820F2770h case   14:*/		return 0x820F2774;
		  /* 820F2774h */ case   15:  		/* stw R11, <#[R3 + 56]> */
		/* 820F2774h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820F2774h case   15:*/		return 0x820F2778;
		  /* 820F2778h */ case   16:  		/* b 8 */
		/* 820F2778h case   16:*/		return 0x820F2780;
		/* 820F2778h case   16:*/		return 0x820F277C;
	}
	return 0x820F277C;
} // Block from 820F2738h-820F277Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820F277Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F277C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F277C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F277C);
		  /* 820F277Ch */ case    0:  		/* stw R10, <#[R3 + 56]> */
		/* 820F277Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000038) );
		/* 820F277Ch case    0:*/		return 0x820F2780;
	}
	return 0x820F2780;
} // Block from 820F277Ch-820F2780h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F2780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2780);
		  /* 820F2780h */ case    0:  		/* lwz R11, <#[R4]> */
		/* 820F2780h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820F2780h case    0:*/		return 0x820F2784;
		  /* 820F2784h */ case    1:  		/* cmplw CR6, R20, R21 */
		/* 820F2784h case    1:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R21);
		/* 820F2784h case    1:*/		return 0x820F2788;
		  /* 820F2788h */ case    2:  		/* stw R11, <#[R3]> */
		/* 820F2788h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F2788h case    2:*/		return 0x820F278C;
		  /* 820F278Ch */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 820F278Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820F27A4;  }
		/* 820F278Ch case    3:*/		return 0x820F2790;
		  /* 820F2790h */ case    4:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 820F2790h case    4:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 820F2790h case    4:*/		return 0x820F2794;
		  /* 820F2794h */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 820F2794h case    5:*/		if ( regs.CR[0].eq ) { return 0x820F27BC;  }
		/* 820F2794h case    5:*/		return 0x820F2798;
		  /* 820F2798h */ case    6:  		/* li R10, 1 */
		/* 820F2798h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820F2798h case    6:*/		return 0x820F279C;
		  /* 820F279Ch */ case    7:  		/* rlwimi R11, R10, 3, 28, 29 */
		/* 820F279Ch case    7:*/		cpu::op::rlwimi<0,3,28,29>(regs,&regs.R11,regs.R10);
		/* 820F279Ch case    7:*/		return 0x820F27A0;
		  /* 820F27A0h */ case    8:  		/* stw R11, <#[R3]> */
		/* 820F27A0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F27A0h case    8:*/		return 0x820F27A4;
	}
	return 0x820F27A4;
} // Block from 820F2780h-820F27A4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F27A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F27A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F27A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F27A4);
		  /* 820F27A4h */ case    0:  		/* lis R11, 16 */
		/* 820F27A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x10);
		/* 820F27A4h case    0:*/		return 0x820F27A8;
		  /* 820F27A8h */ case    1:  		/* cmplw CR6, R20, R11 */
		/* 820F27A8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R11);
		/* 820F27A8h case    1:*/		return 0x820F27AC;
		  /* 820F27ACh */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820F27ACh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F27BC;  }
		/* 820F27ACh case    2:*/		return 0x820F27B0;
		  /* 820F27B0h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820F27B0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F27B0h case    3:*/		return 0x820F27B4;
		  /* 820F27B4h */ case    4:  		/* ori R11, R11, 4 */
		/* 820F27B4h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F27B4h case    4:*/		return 0x820F27B8;
		  /* 820F27B8h */ case    5:  		/* stw R11, <#[R3]> */
		/* 820F27B8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F27B8h case    5:*/		return 0x820F27BC;
	}
	return 0x820F27BC;
} // Block from 820F27A4h-820F27BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F27BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F27BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F27BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F27BC);
		  /* 820F27BCh */ case    0:  		/* bl 42212 */
		/* 820F27BCh case    0:*/		regs.LR = 0x820F27C0; return 0x820FCCA0;
		/* 820F27BCh case    0:*/		return 0x820F27C0;
		  /* 820F27C0h */ case    1:  		/* lwz R11, <#[R24 + 12]> */
		/* 820F27C0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820F27C0h case    1:*/		return 0x820F27C4;
		  /* 820F27C4h */ case    2:  		/* addi R30, R30, 1 */
		/* 820F27C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820F27C4h case    2:*/		return 0x820F27C8;
		  /* 820F27C8h */ case    3:  		/* addi R31, R31, 4 */
		/* 820F27C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820F27C8h case    3:*/		return 0x820F27CC;
		  /* 820F27CCh */ case    4:  		/* cmplw CR6, R30, R11 */
		/* 820F27CCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820F27CCh case    4:*/		return 0x820F27D0;
		  /* 820F27D0h */ case    5:  		/* bc 12, CR6_LT, -136 */
		/* 820F27D0h case    5:*/		if ( regs.CR[6].lt ) { return 0x820F2748;  }
		/* 820F27D0h case    5:*/		return 0x820F27D4;
	}
	return 0x820F27D4;
} // Block from 820F27BCh-820F27D4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F27D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F27D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F27D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F27D4);
		  /* 820F27D4h */ case    0:  		/* lwz R11, <#[R25 + 260]> */
		/* 820F27D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000104) );
		/* 820F27D4h case    0:*/		return 0x820F27D8;
		  /* 820F27D8h */ case    1:  		/* li R10, 0 */
		/* 820F27D8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F27D8h case    1:*/		return 0x820F27DC;
		  /* 820F27DCh */ case    2:  		/* stw R10, <#[R11]> */
		/* 820F27DCh case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F27DCh case    2:*/		return 0x820F27E0;
		  /* 820F27E0h */ case    3:  		/* b 24 */
		/* 820F27E0h case    3:*/		return 0x820F27F8;
		/* 820F27E0h case    3:*/		return 0x820F27E4;
	}
	return 0x820F27E4;
} // Block from 820F27D4h-820F27E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F27E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F27E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F27E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F27E4);
		  /* 820F27E4h */ case    0:  		/* lwz R11, <#[R25 + 260]> */
		/* 820F27E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000104) );
		/* 820F27E4h case    0:*/		return 0x820F27E8;
		  /* 820F27E8h */ case    1:  		/* li R10, 1 */
		/* 820F27E8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820F27E8h case    1:*/		return 0x820F27EC;
		  /* 820F27ECh */ case    2:  		/* lwz R9, <#[R11]> */
		/* 820F27ECh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820F27ECh case    2:*/		return 0x820F27F0;
		  /* 820F27F0h */ case    3:  		/* rlwimi R9, R10, 28, 0, 11 */
		/* 820F27F0h case    3:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R9,regs.R10);
		/* 820F27F0h case    3:*/		return 0x820F27F4;
		  /* 820F27F4h */ case    4:  		/* stw R9, <#[R11]> */
		/* 820F27F4h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820F27F4h case    4:*/		return 0x820F27F8;
	}
	return 0x820F27F8;
} // Block from 820F27E4h-820F27F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F27F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F27F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F27F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F27F8);
		  /* 820F27F8h */ case    0:  		/* li R3, 0 */
		/* 820F27F8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F27F8h case    0:*/		return 0x820F27FC;
	}
	return 0x820F27FC;
} // Block from 820F27F8h-820F27FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F27FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F27FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F27FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F27FC);
		  /* 820F27FCh */ case    0:  		/* addi R1, R1, 368 */
		/* 820F27FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x170);
		/* 820F27FCh case    0:*/		return 0x820F2800;
		  /* 820F2800h */ case    1:  		/* b -398736 */
		/* 820F2800h case    1:*/		return 0x82091270;
		/* 820F2800h case    1:*/		return 0x820F2804;
		  /* 820F2804h */ case    2:  		/* nop */
		/* 820F2804h case    2:*/		cpu::op::nop();
		/* 820F2804h case    2:*/		return 0x820F2808;
	}
	return 0x820F2808;
} // Block from 820F27FCh-820F2808h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F2808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2808);
		  /* 820F2808h */ case    0:  		/* mfspr R12, LR */
		/* 820F2808h case    0:*/		regs.R12 = regs.LR;
		/* 820F2808h case    0:*/		return 0x820F280C;
		  /* 820F280Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F280Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F280Ch case    1:*/		return 0x820F2810;
		  /* 820F2810h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820F2810h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F2810h case    2:*/		return 0x820F2814;
		  /* 820F2814h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820F2814h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820F2814h case    3:*/		return 0x820F2818;
		  /* 820F2818h */ case    4:  		/* li R11, 0 */
		/* 820F2818h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F2818h case    4:*/		return 0x820F281C;
		  /* 820F281Ch */ case    5:  		/* lwz R10, <#[R3 + 260]> */
		/* 820F281Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000104) );
		/* 820F281Ch case    5:*/		return 0x820F2820;
		  /* 820F2820h */ case    6:  		/* mr R9, R4 */
		/* 820F2820h case    6:*/		regs.R9 = regs.R4;
		/* 820F2820h case    6:*/		return 0x820F2824;
		  /* 820F2824h */ case    7:  		/* stw R11, <#[R3 + 352]> */
		/* 820F2824h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000160) );
		/* 820F2824h case    7:*/		return 0x820F2828;
		  /* 820F2828h */ case    8:  		/* li R8, 0 */
		/* 820F2828h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F2828h case    8:*/		return 0x820F282C;
		  /* 820F282Ch */ case    9:  		/* lis R7, 8 */
		/* 820F282Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R7,0x8);
		/* 820F282Ch case    9:*/		return 0x820F2830;
		  /* 820F2830h */ case   10:  		/* lis R5, 14 */
		/* 820F2830h case   10:*/		cpu::op::lis<0>(regs,&regs.R5,0xE);
		/* 820F2830h case   10:*/		return 0x820F2834;
		  /* 820F2834h */ case   11:  		/* lis R4, 8 */
		/* 820F2834h case   11:*/		cpu::op::lis<0>(regs,&regs.R4,0x8);
		/* 820F2834h case   11:*/		return 0x820F2838;
		  /* 820F2838h */ case   12:  		/* lwz R6, <#[R10 + 8]> */
		/* 820F2838h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000008) );
		/* 820F2838h case   12:*/		return 0x820F283C;
		  /* 820F283Ch */ case   13:  		/* mr R31, R3 */
		/* 820F283Ch case   13:*/		regs.R31 = regs.R3;
		/* 820F283Ch case   13:*/		return 0x820F2840;
		  /* 820F2840h */ case   14:  		/* bl -1736 */
		/* 820F2840h case   14:*/		regs.LR = 0x820F2844; return 0x820F2178;
		/* 820F2840h case   14:*/		return 0x820F2844;
		  /* 820F2844h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820F2844h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F2844h case   15:*/		return 0x820F2848;
		  /* 820F2848h */ case   16:  		/* bc 12, CR0_LT, 12 */
		/* 820F2848h case   16:*/		if ( regs.CR[0].lt ) { return 0x820F2854;  }
		/* 820F2848h case   16:*/		return 0x820F284C;
		  /* 820F284Ch */ case   17:  		/* mr R3, R31 */
		/* 820F284Ch case   17:*/		regs.R3 = regs.R31;
		/* 820F284Ch case   17:*/		return 0x820F2850;
		  /* 820F2850h */ case   18:  		/* bl -50448 */
		/* 820F2850h case   18:*/		regs.LR = 0x820F2854; return 0x820E6340;
		/* 820F2850h case   18:*/		return 0x820F2854;
	}
	return 0x820F2854;
} // Block from 820F2808h-820F2854h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F2854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2854);
		  /* 820F2854h */ case    0:  		/* addi R1, R1, 96 */
		/* 820F2854h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820F2854h case    0:*/		return 0x820F2858;
		  /* 820F2858h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F2858h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F2858h case    1:*/		return 0x820F285C;
		  /* 820F285Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820F285Ch case    2:*/		regs.LR = regs.R12;
		/* 820F285Ch case    2:*/		return 0x820F2860;
		  /* 820F2860h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820F2860h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F2860h case    3:*/		return 0x820F2864;
		  /* 820F2864h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820F2864h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F2864h case    4:*/		return 0x820F2868;
	}
	return 0x820F2868;
} // Block from 820F2854h-820F2868h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F2868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2868);
		  /* 820F2868h */ case    0:  		/* mfspr R12, LR */
		/* 820F2868h case    0:*/		regs.R12 = regs.LR;
		/* 820F2868h case    0:*/		return 0x820F286C;
		  /* 820F286Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F286Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F286Ch case    1:*/		return 0x820F2870;
		  /* 820F2870h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820F2870h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F2870h case    2:*/		return 0x820F2874;
		  /* 820F2874h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820F2874h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820F2874h case    3:*/		return 0x820F2878;
		  /* 820F2878h */ case    4:  		/* lwz R10, <#[R3 + 260]> */
		/* 820F2878h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000104) );
		/* 820F2878h case    4:*/		return 0x820F287C;
		  /* 820F287Ch */ case    5:  		/* mr R31, R3 */
		/* 820F287Ch case    5:*/		regs.R31 = regs.R3;
		/* 820F287Ch case    5:*/		return 0x820F2880;
		  /* 820F2880h */ case    6:  		/* li R7, 0 */
		/* 820F2880h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F2880h case    6:*/		return 0x820F2884;
		  /* 820F2884h */ case    7:  		/* lwz R11, <#[R10 + 4]> */
		/* 820F2884h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820F2884h case    7:*/		return 0x820F2888;
		  /* 820F2888h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820F2888h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F2888h case    8:*/		return 0x820F288C;
		  /* 820F288Ch */ case    9:  		/* bc 4, CR6_GT, 80 */
		/* 820F288Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x820F28DC;  }
		/* 820F288Ch case    9:*/		return 0x820F2890;
		  /* 820F2890h */ case   10:  		/* lwz R9, <#[R3 + 20]> */
		/* 820F2890h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820F2890h case   10:*/		return 0x820F2894;
		  /* 820F2894h */ case   11:  		/* li R11, 0 */
		/* 820F2894h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F2894h case   11:*/		return 0x820F2898;
		  /* 820F2898h */ case   12:  		/* lwz R8, <#[R3 + 16]> */
		/* 820F2898h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 820F2898h case   12:*/		return 0x820F289C;
		  /* 820F289Ch */ case   13:  		/* lwz R6, <#[R10 + 8]> */
		/* 820F289Ch case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000008) );
		/* 820F289Ch case   13:*/		return 0x820F28A0;
		  /* 820F28A0h */ case   14:  		/* lwzx R6, <#[R6 + R11]> */
		/* 820F28A0h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820F28A0h case   14:*/		return 0x820F28A4;
		  /* 820F28A4h */ case   15:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F28A4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F28A4h case   15:*/		return 0x820F28A8;
		  /* 820F28A8h */ case   16:  		/* lwzx R6, <#[R6 + R9]> */
		/* 820F28A8h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R9 + 0x00000000) );
		/* 820F28A8h case   16:*/		return 0x820F28AC;
		  /* 820F28ACh */ case   17:  		/* lwz R6, <#[R6 + 4]> */
		/* 820F28ACh case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820F28ACh case   17:*/		return 0x820F28B0;
		  /* 820F28B0h */ case   18:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F28B0h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F28B0h case   18:*/		return 0x820F28B4;
		  /* 820F28B4h */ case   19:  		/* lwzx R6, <#[R6 + R8]> */
		/* 820F28B4h case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820F28B4h case   19:*/		return 0x820F28B8;
		  /* 820F28B8h */ case   20:  		/* lwz R6, <#[R6 + 4]> */
		/* 820F28B8h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820F28B8h case   20:*/		return 0x820F28BC;
		  /* 820F28BCh */ case   21:  		/* rlwinm. R6, R6, 0, 22, 22 */
		/* 820F28BCh case   21:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R6,regs.R6);
		/* 820F28BCh case   21:*/		return 0x820F28C0;
		  /* 820F28C0h */ case   22:  		/* bc 4, CR0_EQ, 104 */
		/* 820F28C0h case   22:*/		if ( !regs.CR[0].eq ) { return 0x820F2928;  }
		/* 820F28C0h case   22:*/		return 0x820F28C4;
		  /* 820F28C4h */ case   23:  		/* lwz R6, <#[R31 + 260]> */
		/* 820F28C4h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000104) );
		/* 820F28C4h case   23:*/		return 0x820F28C8;
		  /* 820F28C8h */ case   24:  		/* addi R7, R7, 1 */
		/* 820F28C8h case   24:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820F28C8h case   24:*/		return 0x820F28CC;
		  /* 820F28CCh */ case   25:  		/* addi R11, R11, 4 */
		/* 820F28CCh case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F28CCh case   25:*/		return 0x820F28D0;
		  /* 820F28D0h */ case   26:  		/* lwz R6, <#[R6 + 4]> */
		/* 820F28D0h case   26:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820F28D0h case   26:*/		return 0x820F28D4;
		  /* 820F28D4h */ case   27:  		/* cmplw CR6, R7, R6 */
		/* 820F28D4h case   27:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 820F28D4h case   27:*/		return 0x820F28D8;
		  /* 820F28D8h */ case   28:  		/* bc 12, CR6_LT, -60 */
		/* 820F28D8h case   28:*/		if ( regs.CR[6].lt ) { return 0x820F289C;  }
		/* 820F28D8h case   28:*/		return 0x820F28DC;
	}
	return 0x820F28DC;
} // Block from 820F2868h-820F28DCh (29 instructions)

//////////////////////////////////////////////////////
// Block at 820F28DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F28DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F28DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F28DC);
		  /* 820F28DCh */ case    0:  		/* li R11, 0 */
		/* 820F28DCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F28DCh case    0:*/		return 0x820F28E0;
		  /* 820F28E0h */ case    1:  		/* li R9, 0 */
		/* 820F28E0h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F28E0h case    1:*/		return 0x820F28E4;
		  /* 820F28E4h */ case    2:  		/* stw R11, <#[R31 + 352]> */
		/* 820F28E4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000160) );
		/* 820F28E4h case    2:*/		return 0x820F28E8;
		  /* 820F28E8h */ case    3:  		/* li R8, 0 */
		/* 820F28E8h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F28E8h case    3:*/		return 0x820F28EC;
		  /* 820F28ECh */ case    4:  		/* lis R7, 16 */
		/* 820F28ECh case    4:*/		cpu::op::lis<0>(regs,&regs.R7,0x10);
		/* 820F28ECh case    4:*/		return 0x820F28F0;
		  /* 820F28F0h */ case    5:  		/* lwz R6, <#[R10 + 8]> */
		/* 820F28F0h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000008) );
		/* 820F28F0h case    5:*/		return 0x820F28F4;
		  /* 820F28F4h */ case    6:  		/* li R5, 0 */
		/* 820F28F4h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F28F4h case    6:*/		return 0x820F28F8;
		  /* 820F28F8h */ case    7:  		/* lis R4, 16 */
		/* 820F28F8h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x10);
		/* 820F28F8h case    7:*/		return 0x820F28FC;
		  /* 820F28FCh */ case    8:  		/* mr R3, R31 */
		/* 820F28FCh case    8:*/		regs.R3 = regs.R31;
		/* 820F28FCh case    8:*/		return 0x820F2900;
		  /* 820F2900h */ case    9:  		/* bl -1928 */
		/* 820F2900h case    9:*/		regs.LR = 0x820F2904; return 0x820F2178;
		/* 820F2900h case    9:*/		return 0x820F2904;
		  /* 820F2904h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820F2904h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F2904h case   10:*/		return 0x820F2908;
		  /* 820F2908h */ case   11:  		/* bc 12, CR0_LT, 12 */
		/* 820F2908h case   11:*/		if ( regs.CR[0].lt ) { return 0x820F2914;  }
		/* 820F2908h case   11:*/		return 0x820F290C;
		  /* 820F290Ch */ case   12:  		/* mr R3, R31 */
		/* 820F290Ch case   12:*/		regs.R3 = regs.R31;
		/* 820F290Ch case   12:*/		return 0x820F2910;
		  /* 820F2910h */ case   13:  		/* bl -50640 */
		/* 820F2910h case   13:*/		regs.LR = 0x820F2914; return 0x820E6340;
		/* 820F2910h case   13:*/		return 0x820F2914;
	}
	return 0x820F2914;
} // Block from 820F28DCh-820F2914h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F2914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2914);
		  /* 820F2914h */ case    0:  		/* addi R1, R1, 96 */
		/* 820F2914h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820F2914h case    0:*/		return 0x820F2918;
	}
	return 0x820F2918;
} // Block from 820F2914h-820F2918h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F2918h
// Function '?MatchSourceModifier@CShaderProgram@D3DXShader@@IAAJIIPAIIPAVCInstruction@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2918);
		  /* 820F2918h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F2918h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F2918h case    0:*/		return 0x820F291C;
		  /* 820F291Ch */ case    1:  		/* mtspr LR, R12 */
		/* 820F291Ch case    1:*/		regs.LR = regs.R12;
		/* 820F291Ch case    1:*/		return 0x820F2920;
		  /* 820F2920h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 820F2920h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F2920h case    2:*/		return 0x820F2924;
		  /* 820F2924h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820F2924h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F2924h case    3:*/		return 0x820F2928;
	}
	return 0x820F2928;
} // Block from 820F2918h-820F2928h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F2928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2928);
		  /* 820F2928h */ case    0:  		/* li R3, 1 */
		/* 820F2928h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F2928h case    0:*/		return 0x820F292C;
		  /* 820F292Ch */ case    1:  		/* b -24 */
		/* 820F292Ch case    1:*/		return 0x820F2914;
		/* 820F292Ch case    1:*/		return 0x820F2930;
	}
	return 0x820F2930;
} // Block from 820F2928h-820F2930h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F2930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2930);
		  /* 820F2930h */ case    0:  		/* mfspr R12, LR */
		/* 820F2930h case    0:*/		regs.R12 = regs.LR;
		/* 820F2930h case    0:*/		return 0x820F2934;
		  /* 820F2934h */ case    1:  		/* bl -399084 */
		/* 820F2934h case    1:*/		regs.LR = 0x820F2938; return 0x82091248;
		/* 820F2934h case    1:*/		return 0x820F2938;
		  /* 820F2938h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820F2938h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820F2938h case    2:*/		return 0x820F293C;
		  /* 820F293Ch */ case    3:  		/* lwz R5, <#[R3 + 260]> */
		/* 820F293Ch case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000104) );
		/* 820F293Ch case    3:*/		return 0x820F2940;
		  /* 820F2940h */ case    4:  		/* lis R11, 8256 */
		/* 820F2940h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0x2040);
		/* 820F2940h case    4:*/		return 0x820F2944;
		  /* 820F2944h */ case    5:  		/* mr R26, R3 */
		/* 820F2944h case    5:*/		regs.R26 = regs.R3;
		/* 820F2944h case    5:*/		return 0x820F2948;
		  /* 820F2948h */ case    6:  		/* lwz R9, <#[R5]> */
		/* 820F2948h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 820F2948h case    6:*/		return 0x820F294C;
		  /* 820F294Ch */ case    7:  		/* rlwinm R10, R9, 0, 0, 11 */
		/* 820F294Ch case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R9);
		/* 820F294Ch case    7:*/		return 0x820F2950;
		  /* 820F2950h */ case    8:  		/* cmplw CR6, R10, R11 */
		/* 820F2950h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820F2950h case    8:*/		return 0x820F2954;
		  /* 820F2954h */ case    9:  		/* bc 4, CR6_EQ, 896 */
		/* 820F2954h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820F2CD4;  }
		/* 820F2954h case    9:*/		return 0x820F2958;
		  /* 820F2958h */ case   10:  		/* rlwinm R29, R9, 2, 10, 29 */
		/* 820F2958h case   10:*/		cpu::op::rlwinm<0,2,10,29>(regs,&regs.R29,regs.R9);
		/* 820F2958h case   10:*/		return 0x820F295C;
		  /* 820F295Ch */ case   11:  		/* lwz R11, <#[R5 + 8]> */
		/* 820F295Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 820F295Ch case   11:*/		return 0x820F2960;
		  /* 820F2960h */ case   12:  		/* rlwinm R25, R9, 0, 12, 31 */
		/* 820F2960h case   12:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R25,regs.R9);
		/* 820F2960h case   12:*/		return 0x820F2964;
		  /* 820F2964h */ case   13:  		/* lwz R30, <#[R3 + 20]> */
		/* 820F2964h case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000014) );
		/* 820F2964h case   13:*/		return 0x820F2968;
		  /* 820F2968h */ case   14:  		/* lwz R28, <#[R3 + 16]> */
		/* 820F2968h case   14:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000010) );
		/* 820F2968h case   14:*/		return 0x820F296C;
		  /* 820F296Ch */ case   15:  		/* li R24, 0 */
		/* 820F296Ch case   15:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820F296Ch case   15:*/		return 0x820F2970;
		  /* 820F2970h */ case   16:  		/* add R10, R29, R11 */
		/* 820F2970h case   16:*/		cpu::op::add<0>(regs,&regs.R10,regs.R29,regs.R11);
		/* 820F2970h case   16:*/		return 0x820F2974;
		  /* 820F2974h */ case   17:  		/* lwzx R9, <#[R29 + R11]> */
		/* 820F2974h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820F2974h case   17:*/		return 0x820F2978;
		  /* 820F2978h */ case   18:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F2978h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F2978h case   18:*/		return 0x820F297C;
		  /* 820F297Ch */ case   19:  		/* lwzx R9, <#[R9 + R30]> */
		/* 820F297Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 820F297Ch case   19:*/		return 0x820F2980;
		  /* 820F2980h */ case   20:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F2980h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F2980h case   20:*/		return 0x820F2984;
		  /* 820F2984h */ case   21:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F2984h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F2984h case   21:*/		return 0x820F2988;
		  /* 820F2988h */ case   22:  		/* lwzx R9, <#[R9 + R28]> */
		/* 820F2988h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R28 + 0x00000000) );
		/* 820F2988h case   22:*/		return 0x820F298C;
		  /* 820F298Ch */ case   23:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F298Ch case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F298Ch case   23:*/		return 0x820F2990;
		  /* 820F2990h */ case   24:  		/* rlwinm. R9, R9, 0, 23, 23 */
		/* 820F2990h case   24:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R9);
		/* 820F2990h case   24:*/		return 0x820F2994;
		  /* 820F2994h */ case   25:  		/* bc 12, CR0_EQ, 20 */
		/* 820F2994h case   25:*/		if ( regs.CR[0].eq ) { return 0x820F29A8;  }
		/* 820F2994h case   25:*/		return 0x820F2998;
		  /* 820F2998h */ case   26:  		/* mr R6, R11 */
		/* 820F2998h case   26:*/		regs.R6 = regs.R11;
		/* 820F2998h case   26:*/		return 0x820F299C;
		  /* 820F299Ch */ case   27:  		/* mr R31, R24 */
		/* 820F299Ch case   27:*/		regs.R31 = regs.R24;
		/* 820F299Ch case   27:*/		return 0x820F29A0;
		  /* 820F29A0h */ case   28:  		/* mr R11, R10 */
		/* 820F29A0h case   28:*/		regs.R11 = regs.R10;
		/* 820F29A0h case   28:*/		return 0x820F29A4;
		  /* 820F29A4h */ case   29:  		/* b 48 */
		/* 820F29A4h case   29:*/		return 0x820F29D4;
		/* 820F29A4h case   29:*/		return 0x820F29A8;
	}
	return 0x820F29A8;
} // Block from 820F2930h-820F29A8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820F29A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F29A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F29A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F29A8);
		  /* 820F29A8h */ case    0:  		/* lwz R9, <#[R11]> */
		/* 820F29A8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820F29A8h case    0:*/		return 0x820F29AC;
		  /* 820F29ACh */ case    1:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F29ACh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F29ACh case    1:*/		return 0x820F29B0;
		  /* 820F29B0h */ case    2:  		/* lwzx R9, <#[R9 + R30]> */
		/* 820F29B0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 820F29B0h case    2:*/		return 0x820F29B4;
		  /* 820F29B4h */ case    3:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F29B4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F29B4h case    3:*/		return 0x820F29B8;
		  /* 820F29B8h */ case    4:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F29B8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F29B8h case    4:*/		return 0x820F29BC;
		  /* 820F29BCh */ case    5:  		/* lwzx R9, <#[R9 + R28]> */
		/* 820F29BCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R28 + 0x00000000) );
		/* 820F29BCh case    5:*/		return 0x820F29C0;
		  /* 820F29C0h */ case    6:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F29C0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F29C0h case    6:*/		return 0x820F29C4;
		  /* 820F29C4h */ case    7:  		/* rlwinm. R9, R9, 0, 23, 23 */
		/* 820F29C4h case    7:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R9);
		/* 820F29C4h case    7:*/		return 0x820F29C8;
		  /* 820F29C8h */ case    8:  		/* bc 12, CR0_EQ, 780 */
		/* 820F29C8h case    8:*/		if ( regs.CR[0].eq ) { return 0x820F2CD4;  }
		/* 820F29C8h case    8:*/		return 0x820F29CC;
		  /* 820F29CCh */ case    9:  		/* li R31, 1 */
		/* 820F29CCh case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820F29CCh case    9:*/		return 0x820F29D0;
		  /* 820F29D0h */ case   10:  		/* mr R6, R10 */
		/* 820F29D0h case   10:*/		regs.R6 = regs.R10;
		/* 820F29D0h case   10:*/		return 0x820F29D4;
	}
	return 0x820F29D4;
} // Block from 820F29A8h-820F29D4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F29D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F29D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F29D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F29D4);
		  /* 820F29D4h */ case    0:  		/* mr R10, R24 */
		/* 820F29D4h case    0:*/		regs.R10 = regs.R24;
		/* 820F29D4h case    0:*/		return 0x820F29D8;
		  /* 820F29D8h */ case    1:  		/* stw R24, <#[R26 + 352]> */
		/* 820F29D8h case    1:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R26 + 0x00000160) );
		/* 820F29D8h case    1:*/		return 0x820F29DC;
		  /* 820F29DCh */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 820F29DCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820F29DCh case    2:*/		return 0x820F29E0;
		  /* 820F29E0h */ case    3:  		/* bc 12, CR6_EQ, 116 */
		/* 820F29E0h case    3:*/		if ( regs.CR[6].eq ) { return 0x820F2A54;  }
		/* 820F29E0h case    3:*/		return 0x820F29E4;
		  /* 820F29E4h */ case    4:  		/* subf R8, R6, R11 */
		/* 820F29E4h case    4:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R6,regs.R11);
		/* 820F29E4h case    4:*/		return 0x820F29E8;
		  /* 820F29E8h */ case    5:  		/* lis R11, -32254 */
		/* 820F29E8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F29E8h case    5:*/		return 0x820F29EC;
		  /* 820F29ECh */ case    6:  		/* mr R9, R6 */
		/* 820F29ECh case    6:*/		regs.R9 = regs.R6;
		/* 820F29ECh case    6:*/		return 0x820F29F0;
		  /* 820F29F0h */ case    7:  		/* lfd FR0, <#[R11 - 16184]> */
		/* 820F29F0h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFC0C8) );
		/* 820F29F0h case    7:*/		return 0x820F29F4;
		  /* 820F29F4h */ case    8:  		/* lwzx R11, <#[R8 + R9]> */
		/* 820F29F4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820F29F4h case    8:*/		return 0x820F29F8;
		  /* 820F29F8h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F29F8h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F29F8h case    9:*/		return 0x820F29FC;
		  /* 820F29FCh */ case   10:  		/* lwzx R11, <#[R11 + R30]> */
		/* 820F29FCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820F29FCh case   10:*/		return 0x820F2A00;
		  /* 820F2A00h */ case   11:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820F2A00h case   11:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820F2A00h case   11:*/		return 0x820F2A04;
		  /* 820F2A04h */ case   12:  		/* fcmpu CR6, FR13, FR0 */
		/* 820F2A04h case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820F2A04h case   12:*/		return 0x820F2A08;
		  /* 820F2A08h */ case   13:  		/* bc 4, CR6_EQ, 716 */
		/* 820F2A08h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820F2CD4;  }
		/* 820F2A08h case   13:*/		return 0x820F2A0C;
		  /* 820F2A0Ch */ case   14:  		/* lwz R11, <#[R9]> */
		/* 820F2A0Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820F2A0Ch case   14:*/		return 0x820F2A10;
		  /* 820F2A10h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F2A10h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2A10h case   15:*/		return 0x820F2A14;
		  /* 820F2A14h */ case   16:  		/* lwzx R11, <#[R11 + R30]> */
		/* 820F2A14h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820F2A14h case   16:*/		return 0x820F2A18;
		  /* 820F2A18h */ case   17:  		/* lwz R7, <#[R11 + 60]> */
		/* 820F2A18h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F2A18h case   17:*/		return 0x820F2A1C;
		  /* 820F2A1Ch */ case   18:  		/* rlwinm. R7, R7, 0, 22, 22 */
		/* 820F2A1Ch case   18:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R7,regs.R7);
		/* 820F2A1Ch case   18:*/		return 0x820F2A20;
		  /* 820F2A20h */ case   19:  		/* bc 4, CR0_EQ, 36 */
		/* 820F2A20h case   19:*/		if ( !regs.CR[0].eq ) { return 0x820F2A44;  }
		/* 820F2A20h case   19:*/		return 0x820F2A24;
		  /* 820F2A24h */ case   20:  		/* lwz R11, <#[R11]> */
		/* 820F2A24h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F2A24h case   20:*/		return 0x820F2A28;
		  /* 820F2A28h */ case   21:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820F2A28h case   21:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820F2A28h case   21:*/		return 0x820F2A2C;
		  /* 820F2A2Ch */ case   22:  		/* bc 4, CR0_EQ, 24 */
		/* 820F2A2Ch case   22:*/		if ( !regs.CR[0].eq ) { return 0x820F2A44;  }
		/* 820F2A2Ch case   22:*/		return 0x820F2A30;
		  /* 820F2A30h */ case   23:  		/* lwz R11, <#[R26 + 108]> */
		/* 820F2A30h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000006C) );
		/* 820F2A30h case   23:*/		return 0x820F2A34;
		  /* 820F2A34h */ case   24:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 820F2A34h case   24:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 820F2A34h case   24:*/		return 0x820F2A38;
		  /* 820F2A38h */ case   25:  		/* bc 12, CR0_EQ, 12 */
		/* 820F2A38h case   25:*/		if ( regs.CR[0].eq ) { return 0x820F2A44;  }
		/* 820F2A38h case   25:*/		return 0x820F2A3C;
		  /* 820F2A3Ch */ case   26:  		/* li R11, 1 */
		/* 820F2A3Ch case   26:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820F2A3Ch case   26:*/		return 0x820F2A40;
		  /* 820F2A40h */ case   27:  		/* stw R11, <#[R26 + 352]> */
		/* 820F2A40h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000160) );
		/* 820F2A40h case   27:*/		return 0x820F2A44;
	}
	return 0x820F2A44;
} // Block from 820F29D4h-820F2A44h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820F2A44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2A44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2A44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2A44);
		  /* 820F2A44h */ case    0:  		/* addi R10, R10, 1 */
		/* 820F2A44h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F2A44h case    0:*/		return 0x820F2A48;
		  /* 820F2A48h */ case    1:  		/* addi R9, R9, 4 */
		/* 820F2A48h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F2A48h case    1:*/		return 0x820F2A4C;
		  /* 820F2A4Ch */ case    2:  		/* cmplw CR6, R10, R25 */
		/* 820F2A4Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R25);
		/* 820F2A4Ch case    2:*/		return 0x820F2A50;
		  /* 820F2A50h */ case    3:  		/* bc 12, CR6_LT, -92 */
		/* 820F2A50h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F29F4;  }
		/* 820F2A50h case    3:*/		return 0x820F2A54;
	}
	return 0x820F2A54;
} // Block from 820F2A44h-820F2A54h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F2A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2A54);
		  /* 820F2A54h */ case    0:  		/* lwz R11, <#[R5 + 16]> */
		/* 820F2A54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000010) );
		/* 820F2A54h case    0:*/		return 0x820F2A58;
		  /* 820F2A58h */ case    1:  		/* lwz R10, <#[R26 + 136]> */
		/* 820F2A58h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000088) );
		/* 820F2A58h case    1:*/		return 0x820F2A5C;
		  /* 820F2A5Ch */ case    2:  		/* lwz R11, <#[R11]> */
		/* 820F2A5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F2A5Ch case    2:*/		return 0x820F2A60;
		  /* 820F2A60h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F2A60h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2A60h case    3:*/		return 0x820F2A64;
		  /* 820F2A64h */ case    4:  		/* lwzx R11, <#[R11 + R30]> */
		/* 820F2A64h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820F2A64h case    4:*/		return 0x820F2A68;
		  /* 820F2A68h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F2A68h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F2A68h case    5:*/		return 0x820F2A6C;
		  /* 820F2A6Ch */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820F2A6Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F2A6Ch case    6:*/		return 0x820F2A70;
		  /* 820F2A70h */ case    7:  		/* bc 4, CR6_EQ, 84 */
		/* 820F2A70h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820F2AC4;  }
		/* 820F2A70h case    7:*/		return 0x820F2A74;
		  /* 820F2A74h */ case    8:  		/* li R9, 0 */
		/* 820F2A74h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F2A74h case    8:*/		return 0x820F2A78;
		  /* 820F2A78h */ case    9:  		/* li R8, 0 */
		/* 820F2A78h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F2A78h case    9:*/		return 0x820F2A7C;
		  /* 820F2A7Ch */ case   10:  		/* lis R7, 2 */
		/* 820F2A7Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R7,0x2);
		/* 820F2A7Ch case   10:*/		return 0x820F2A80;
		  /* 820F2A80h */ case   11:  		/* li R5, 0 */
		/* 820F2A80h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F2A80h case   11:*/		return 0x820F2A84;
		  /* 820F2A84h */ case   12:  		/* lis R4, 2 */
		/* 820F2A84h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2);
		/* 820F2A84h case   12:*/		return 0x820F2A88;
		  /* 820F2A88h */ case   13:  		/* mr R3, R26 */
		/* 820F2A88h case   13:*/		regs.R3 = regs.R26;
		/* 820F2A88h case   13:*/		return 0x820F2A8C;
		  /* 820F2A8Ch */ case   14:  		/* bl -2324 */
		/* 820F2A8Ch case   14:*/		regs.LR = 0x820F2A90; return 0x820F2178;
		/* 820F2A8Ch case   14:*/		return 0x820F2A90;
		  /* 820F2A90h */ case   15:  		/* lwz R11, <#[R26 + 352]> */
		/* 820F2A90h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000160) );
		/* 820F2A90h case   15:*/		return 0x820F2A94;
		  /* 820F2A94h */ case   16:  		/* mr R31, R3 */
		/* 820F2A94h case   16:*/		regs.R31 = regs.R3;
		/* 820F2A94h case   16:*/		return 0x820F2A98;
		  /* 820F2A98h */ case   17:  		/* cmplwi CR6, R11, 2 */
		/* 820F2A98h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820F2A98h case   17:*/		return 0x820F2A9C;
		  /* 820F2A9Ch */ case   18:  		/* bc 4, CR6_EQ, 32 */
		/* 820F2A9Ch case   18:*/		if ( !regs.CR[6].eq ) { return 0x820F2ABC;  }
		/* 820F2A9Ch case   18:*/		return 0x820F2AA0;
		  /* 820F2AA0h */ case   19:  		/* lwz R11, <#[R26 + 260]> */
		/* 820F2AA0h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000104) );
		/* 820F2AA0h case   19:*/		return 0x820F2AA4;
		  /* 820F2AA4h */ case   20:  		/* lis R10, -32254 */
		/* 820F2AA4h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820F2AA4h case   20:*/		return 0x820F2AA8;
		  /* 820F2AA8h */ case   21:  		/* li R5, 4701 */
		/* 820F2AA8h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x125D);
		/* 820F2AA8h case   21:*/		return 0x820F2AAC;
		  /* 820F2AACh */ case   22:  		/* addi R6, R10, -16248 */
		/* 820F2AACh case   22:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFC088);
		/* 820F2AACh case   22:*/		return 0x820F2AB0;
		  /* 820F2AB0h */ case   23:  		/* mr R3, R26 */
		/* 820F2AB0h case   23:*/		regs.R3 = regs.R26;
		/* 820F2AB0h case   23:*/		return 0x820F2AB4;
		  /* 820F2AB4h */ case   24:  		/* lwz R4, <#[R11 + 60]> */
		/* 820F2AB4h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F2AB4h case   24:*/		return 0x820F2AB8;
		  /* 820F2AB8h */ case   25:  		/* bl 113976 */
		/* 820F2AB8h case   25:*/		regs.LR = 0x820F2ABC; return 0x8210E7F0;
		/* 820F2AB8h case   25:*/		return 0x820F2ABC;
	}
	return 0x820F2ABC;
} // Block from 820F2A54h-820F2ABCh (26 instructions)

//////////////////////////////////////////////////////
// Block at 820F2ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2ABC);
		  /* 820F2ABCh */ case    0:  		/* mr R3, R31 */
		/* 820F2ABCh case    0:*/		regs.R3 = regs.R31;
		/* 820F2ABCh case    0:*/		return 0x820F2AC0;
		  /* 820F2AC0h */ case    1:  		/* b 536 */
		/* 820F2AC0h case    1:*/		return 0x820F2CD8;
		/* 820F2AC0h case    1:*/		return 0x820F2AC4;
	}
	return 0x820F2AC4;
} // Block from 820F2ABCh-820F2AC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F2AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2AC4);
		  /* 820F2AC4h */ case    0:  		/* lwz R10, <#[R26 + 132]> */
		/* 820F2AC4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000084) );
		/* 820F2AC4h case    0:*/		return 0x820F2AC8;
		  /* 820F2AC8h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820F2AC8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F2AC8h case    1:*/		return 0x820F2ACC;
		  /* 820F2ACCh */ case    2:  		/* bc 4, CR6_EQ, 520 */
		/* 820F2ACCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F2CD4;  }
		/* 820F2ACCh case    2:*/		return 0x820F2AD0;
		  /* 820F2AD0h */ case    3:  		/* li R11, 129 */
		/* 820F2AD0h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x81);
		/* 820F2AD0h case    3:*/		return 0x820F2AD4;
		  /* 820F2AD4h */ case    4:  		/* mr R4, R25 */
		/* 820F2AD4h case    4:*/		regs.R4 = regs.R25;
		/* 820F2AD4h case    4:*/		return 0x820F2AD8;
		  /* 820F2AD8h */ case    5:  		/* li R7, 2 */
		/* 820F2AD8h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 820F2AD8h case    5:*/		return 0x820F2ADC;
		  /* 820F2ADCh */ case    6:  		/* rlwimi R4, R11, 22, 0, 11 */
		/* 820F2ADCh case    6:*/		cpu::op::rlwimi<0,22,0,11>(regs,&regs.R4,regs.R11);
		/* 820F2ADCh case    6:*/		return 0x820F2AE0;
		  /* 820F2AE0h */ case    7:  		/* addi R6, R1, 80 */
		/* 820F2AE0h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820F2AE0h case    7:*/		return 0x820F2AE4;
		  /* 820F2AE4h */ case    8:  		/* mr R3, R26 */
		/* 820F2AE4h case    8:*/		regs.R3 = regs.R26;
		/* 820F2AE4h case    8:*/		return 0x820F2AE8;
		  /* 820F2AE8h */ case    9:  		/* bl -25576 */
		/* 820F2AE8h case    9:*/		regs.LR = 0x820F2AEC; return 0x820EC700;
		/* 820F2AE8h case    9:*/		return 0x820F2AEC;
		  /* 820F2AECh */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820F2AECh case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F2AECh case   10:*/		return 0x820F2AF0;
		  /* 820F2AF0h */ case   11:  		/* bc 4, CR0_EQ, 488 */
		/* 820F2AF0h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820F2CD8;  }
		/* 820F2AF0h case   11:*/		return 0x820F2AF4;
		  /* 820F2AF4h */ case   12:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 820F2AF4h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 820F2AF4h case   12:*/		return 0x820F2AF8;
		  /* 820F2AF8h */ case   13:  		/* addi R10, R1, 80 */
		/* 820F2AF8h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 820F2AF8h case   13:*/		return 0x820F2AFC;
		  /* 820F2AFCh */ case   14:  		/* mr R6, R24 */
		/* 820F2AFCh case   14:*/		regs.R6 = regs.R24;
		/* 820F2AFCh case   14:*/		return 0x820F2B00;
		  /* 820F2B00h */ case   15:  		/* lwzx R27, <#[R11 + R10]> */
		/* 820F2B00h case   15:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F2B00h case   15:*/		return 0x820F2B04;
		  /* 820F2B04h */ case   16:  		/* cmplwi CR6, R27, 0 */
		/* 820F2B04h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820F2B04h case   16:*/		return 0x820F2B08;
		  /* 820F2B08h */ case   17:  		/* bc 12, CR6_EQ, 460 */
		/* 820F2B08h case   17:*/		if ( regs.CR[6].eq ) { return 0x820F2CD4;  }
		/* 820F2B08h case   17:*/		return 0x820F2B0C;
		  /* 820F2B0Ch */ case   18:  		/* mr R8, R24 */
		/* 820F2B0Ch case   18:*/		regs.R8 = regs.R24;
		/* 820F2B0Ch case   18:*/		return 0x820F2B10;
		  /* 820F2B10h */ case   19:  		/* cmplwi CR6, R25, 0 */
		/* 820F2B10h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820F2B10h case   19:*/		return 0x820F2B14;
		  /* 820F2B14h */ case   20:  		/* bc 12, CR6_EQ, 100 */
		/* 820F2B14h case   20:*/		if ( regs.CR[6].eq ) { return 0x820F2B78;  }
		/* 820F2B14h case   20:*/		return 0x820F2B18;
		  /* 820F2B18h */ case   21:  		/* lwz R7, <#[R27 + 8]> */
		/* 820F2B18h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R27 + 0x00000008) );
		/* 820F2B18h case   21:*/		return 0x820F2B1C;
		  /* 820F2B1Ch */ case   22:  		/* mr R11, R24 */
		/* 820F2B1Ch case   22:*/		regs.R11 = regs.R24;
		/* 820F2B1Ch case   22:*/		return 0x820F2B20;
		  /* 820F2B20h */ case   23:  		/* lwzx R10, <#[R7 + R11]> */
		/* 820F2B20h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 820F2B20h case   23:*/		return 0x820F2B24;
		  /* 820F2B24h */ case   24:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F2B24h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F2B24h case   24:*/		return 0x820F2B28;
		  /* 820F2B28h */ case   25:  		/* lwzx R10, <#[R10 + R30]> */
		/* 820F2B28h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 820F2B28h case   25:*/		return 0x820F2B2C;
		  /* 820F2B2Ch */ case   26:  		/* lwz R9, <#[R10 + 60]> */
		/* 820F2B2Ch case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000003C) );
		/* 820F2B2Ch case   26:*/		return 0x820F2B30;
		  /* 820F2B30h */ case   27:  		/* rlwinm. R5, R9, 0, 11, 15 */
		/* 820F2B30h case   27:*/		cpu::op::rlwinm<1,0,11,15>(regs,&regs.R5,regs.R9);
		/* 820F2B30h case   27:*/		return 0x820F2B34;
		  /* 820F2B34h */ case   28:  		/* bc 4, CR0_EQ, 68 */
		/* 820F2B34h case   28:*/		if ( !regs.CR[0].eq ) { return 0x820F2B78;  }
		/* 820F2B34h case   28:*/		return 0x820F2B38;
		  /* 820F2B38h */ case   29:  		/* lwz R5, <#[R10 + 4]> */
		/* 820F2B38h case   29:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000004) );
		/* 820F2B38h case   29:*/		return 0x820F2B3C;
		  /* 820F2B3Ch */ case   30:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 820F2B3Ch case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 820F2B3Ch case   30:*/		return 0x820F2B40;
		  /* 820F2B40h */ case   31:  		/* lwzx R5, <#[R5 + R28]> */
		/* 820F2B40h case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R28 + 0x00000000) );
		/* 820F2B40h case   31:*/		return 0x820F2B44;
		  /* 820F2B44h */ case   32:  		/* lwz R5, <#[R5 + 4]> */
		/* 820F2B44h case   32:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000004) );
		/* 820F2B44h case   32:*/		return 0x820F2B48;
		  /* 820F2B48h */ case   33:  		/* rlwinm. R5, R5, 0, 22, 22 */
		/* 820F2B48h case   33:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R5,regs.R5);
		/* 820F2B48h case   33:*/		return 0x820F2B4C;
		  /* 820F2B4Ch */ case   34:  		/* bc 4, CR0_EQ, 44 */
		/* 820F2B4Ch case   34:*/		if ( !regs.CR[0].eq ) { return 0x820F2B78;  }
		/* 820F2B4Ch case   34:*/		return 0x820F2B50;
		  /* 820F2B50h */ case   35:  		/* rlwinm. R9, R9, 0, 22, 22 */
		/* 820F2B50h case   35:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R9,regs.R9);
		/* 820F2B50h case   35:*/		return 0x820F2B54;
		  /* 820F2B54h */ case   36:  		/* bc 4, CR0_EQ, 16 */
		/* 820F2B54h case   36:*/		if ( !regs.CR[0].eq ) { return 0x820F2B64;  }
		/* 820F2B54h case   36:*/		return 0x820F2B58;
		  /* 820F2B58h */ case   37:  		/* lwz R10, <#[R10]> */
		/* 820F2B58h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820F2B58h case   37:*/		return 0x820F2B5C;
		  /* 820F2B5Ch */ case   38:  		/* rlwinm. R10, R10, 0, 29, 29 */
		/* 820F2B5Ch case   38:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R10);
		/* 820F2B5Ch case   38:*/		return 0x820F2B60;
		  /* 820F2B60h */ case   39:  		/* bc 12, CR0_EQ, 24 */
		/* 820F2B60h case   39:*/		if ( regs.CR[0].eq ) { return 0x820F2B78;  }
		/* 820F2B60h case   39:*/		return 0x820F2B64;
	}
	return 0x820F2B64;
} // Block from 820F2AC4h-820F2B64h (40 instructions)

//////////////////////////////////////////////////////
// Block at 820F2B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2B64);
		  /* 820F2B64h */ case    0:  		/* addi R8, R8, 1 */
		/* 820F2B64h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F2B64h case    0:*/		return 0x820F2B68;
		  /* 820F2B68h */ case    1:  		/* mr R6, R24 */
		/* 820F2B68h case    1:*/		regs.R6 = regs.R24;
		/* 820F2B68h case    1:*/		return 0x820F2B6C;
		  /* 820F2B6Ch */ case    2:  		/* addi R11, R11, 4 */
		/* 820F2B6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F2B6Ch case    2:*/		return 0x820F2B70;
		  /* 820F2B70h */ case    3:  		/* cmplw CR6, R8, R25 */
		/* 820F2B70h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R25);
		/* 820F2B70h case    3:*/		return 0x820F2B74;
		  /* 820F2B74h */ case    4:  		/* bc 12, CR6_LT, -84 */
		/* 820F2B74h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F2B20;  }
		/* 820F2B74h case    4:*/		return 0x820F2B78;
	}
	return 0x820F2B78;
} // Block from 820F2B64h-820F2B78h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F2B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2B78);
		  /* 820F2B78h */ case    0:  		/* cmplw CR6, R8, R25 */
		/* 820F2B78h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R25);
		/* 820F2B78h case    0:*/		return 0x820F2B7C;
		  /* 820F2B7Ch */ case    1:  		/* bc 12, CR6_EQ, 120 */
		/* 820F2B7Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820F2BF4;  }
		/* 820F2B7Ch case    1:*/		return 0x820F2B80;
		  /* 820F2B80h */ case    2:  		/* mr R7, R24 */
		/* 820F2B80h case    2:*/		regs.R7 = regs.R24;
		/* 820F2B80h case    2:*/		return 0x820F2B84;
		  /* 820F2B84h */ case    3:  		/* cmplwi CR6, R25, 0 */
		/* 820F2B84h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820F2B84h case    3:*/		return 0x820F2B88;
		  /* 820F2B88h */ case    4:  		/* bc 12, CR6_EQ, 96 */
		/* 820F2B88h case    4:*/		if ( regs.CR[6].eq ) { return 0x820F2BE8;  }
		/* 820F2B88h case    4:*/		return 0x820F2B8C;
		  /* 820F2B8Ch */ case    5:  		/* lwz R8, <#[R27 + 8]> */
		/* 820F2B8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000008) );
		/* 820F2B8Ch case    5:*/		return 0x820F2B90;
		  /* 820F2B90h */ case    6:  		/* mr R10, R29 */
		/* 820F2B90h case    6:*/		regs.R10 = regs.R29;
		/* 820F2B90h case    6:*/		return 0x820F2B94;
		  /* 820F2B94h */ case    7:  		/* lwzx R11, <#[R8 + R10]> */
		/* 820F2B94h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820F2B94h case    7:*/		return 0x820F2B98;
		  /* 820F2B98h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F2B98h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2B98h case    8:*/		return 0x820F2B9C;
		  /* 820F2B9Ch */ case    9:  		/* lwzx R11, <#[R11 + R30]> */
		/* 820F2B9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820F2B9Ch case    9:*/		return 0x820F2BA0;
		  /* 820F2BA0h */ case   10:  		/* lwz R9, <#[R11 + 60]> */
		/* 820F2BA0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F2BA0h case   10:*/		return 0x820F2BA4;
		  /* 820F2BA4h */ case   11:  		/* rlwinm. R6, R9, 0, 11, 15 */
		/* 820F2BA4h case   11:*/		cpu::op::rlwinm<1,0,11,15>(regs,&regs.R6,regs.R9);
		/* 820F2BA4h case   11:*/		return 0x820F2BA8;
		  /* 820F2BA8h */ case   12:  		/* bc 4, CR0_EQ, 64 */
		/* 820F2BA8h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820F2BE8;  }
		/* 820F2BA8h case   12:*/		return 0x820F2BAC;
		  /* 820F2BACh */ case   13:  		/* lwz R6, <#[R11 + 4]> */
		/* 820F2BACh case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 820F2BACh case   13:*/		return 0x820F2BB0;
		  /* 820F2BB0h */ case   14:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F2BB0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F2BB0h case   14:*/		return 0x820F2BB4;
		  /* 820F2BB4h */ case   15:  		/* lwzx R6, <#[R6 + R28]> */
		/* 820F2BB4h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R28 + 0x00000000) );
		/* 820F2BB4h case   15:*/		return 0x820F2BB8;
		  /* 820F2BB8h */ case   16:  		/* lwz R6, <#[R6 + 4]> */
		/* 820F2BB8h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820F2BB8h case   16:*/		return 0x820F2BBC;
		  /* 820F2BBCh */ case   17:  		/* rlwinm. R6, R6, 0, 22, 22 */
		/* 820F2BBCh case   17:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R6,regs.R6);
		/* 820F2BBCh case   17:*/		return 0x820F2BC0;
		  /* 820F2BC0h */ case   18:  		/* bc 4, CR0_EQ, 40 */
		/* 820F2BC0h case   18:*/		if ( !regs.CR[0].eq ) { return 0x820F2BE8;  }
		/* 820F2BC0h case   18:*/		return 0x820F2BC4;
		  /* 820F2BC4h */ case   19:  		/* rlwinm. R9, R9, 0, 22, 22 */
		/* 820F2BC4h case   19:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R9,regs.R9);
		/* 820F2BC4h case   19:*/		return 0x820F2BC8;
		  /* 820F2BC8h */ case   20:  		/* bc 4, CR0_EQ, 16 */
		/* 820F2BC8h case   20:*/		if ( !regs.CR[0].eq ) { return 0x820F2BD8;  }
		/* 820F2BC8h case   20:*/		return 0x820F2BCC;
		  /* 820F2BCCh */ case   21:  		/* lwz R11, <#[R11]> */
		/* 820F2BCCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F2BCCh case   21:*/		return 0x820F2BD0;
		  /* 820F2BD0h */ case   22:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820F2BD0h case   22:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820F2BD0h case   22:*/		return 0x820F2BD4;
		  /* 820F2BD4h */ case   23:  		/* bc 12, CR0_EQ, 20 */
		/* 820F2BD4h case   23:*/		if ( regs.CR[0].eq ) { return 0x820F2BE8;  }
		/* 820F2BD4h case   23:*/		return 0x820F2BD8;
	}
	return 0x820F2BD8;
} // Block from 820F2B78h-820F2BD8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F2BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2BD8);
		  /* 820F2BD8h */ case    0:  		/* addi R7, R7, 1 */
		/* 820F2BD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820F2BD8h case    0:*/		return 0x820F2BDC;
		  /* 820F2BDCh */ case    1:  		/* addi R10, R10, 4 */
		/* 820F2BDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F2BDCh case    1:*/		return 0x820F2BE0;
		  /* 820F2BE0h */ case    2:  		/* cmplw CR6, R7, R25 */
		/* 820F2BE0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R25);
		/* 820F2BE0h case    2:*/		return 0x820F2BE4;
		  /* 820F2BE4h */ case    3:  		/* bc 12, CR6_LT, -80 */
		/* 820F2BE4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F2B94;  }
		/* 820F2BE4h case    3:*/		return 0x820F2BE8;
	}
	return 0x820F2BE8;
} // Block from 820F2BD8h-820F2BE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F2BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2BE8);
		  /* 820F2BE8h */ case    0:  		/* cmplw CR6, R7, R25 */
		/* 820F2BE8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R25);
		/* 820F2BE8h case    0:*/		return 0x820F2BEC;
		  /* 820F2BECh */ case    1:  		/* bc 12, CR6_EQ, 232 */
		/* 820F2BECh case    1:*/		if ( regs.CR[6].eq ) { return 0x820F2CD4;  }
		/* 820F2BECh case    1:*/		return 0x820F2BF0;
		  /* 820F2BF0h */ case    2:  		/* mr R6, R25 */
		/* 820F2BF0h case    2:*/		regs.R6 = regs.R25;
		/* 820F2BF0h case    2:*/		return 0x820F2BF4;
	}
	return 0x820F2BF4;
} // Block from 820F2BE8h-820F2BF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F2BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2BF4);
		  /* 820F2BF4h */ case    0:  		/* mr R28, R24 */
		/* 820F2BF4h case    0:*/		regs.R28 = regs.R24;
		/* 820F2BF4h case    0:*/		return 0x820F2BF8;
		  /* 820F2BF8h */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 820F2BF8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820F2BF8h case    1:*/		return 0x820F2BFC;
		  /* 820F2BFCh */ case    2:  		/* bc 12, CR6_EQ, 188 */
		/* 820F2BFCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820F2CB8;  }
		/* 820F2BFCh case    2:*/		return 0x820F2C00;
		  /* 820F2C00h */ case    3:  		/* mr R29, R24 */
		/* 820F2C00h case    3:*/		regs.R29 = regs.R24;
		/* 820F2C00h case    3:*/		return 0x820F2C04;
		  /* 820F2C04h */ case    4:  		/* rlwinm R30, R6, 2, 0, 29 */
		/* 820F2C04h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R6);
		/* 820F2C04h case    4:*/		return 0x820F2C08;
		  /* 820F2C08h */ case    5:  		/* lwz R11, <#[R27 + 8]> */
		/* 820F2C08h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820F2C08h case    5:*/		return 0x820F2C0C;
		  /* 820F2C0Ch */ case    6:  		/* mr R3, R26 */
		/* 820F2C0Ch case    6:*/		regs.R3 = regs.R26;
		/* 820F2C0Ch case    6:*/		return 0x820F2C10;
		  /* 820F2C10h */ case    7:  		/* lwz R10, <#[R26 + 20]> */
		/* 820F2C10h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 820F2C10h case    7:*/		return 0x820F2C14;
		  /* 820F2C14h */ case    8:  		/* lwzx R11, <#[R30 + R11]> */
		/* 820F2C14h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820F2C14h case    8:*/		return 0x820F2C18;
		  /* 820F2C18h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F2C18h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2C18h case    9:*/		return 0x820F2C1C;
		  /* 820F2C1Ch */ case   10:  		/* lwzx R31, <#[R11 + R10]> */
		/* 820F2C1Ch case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F2C1Ch case   10:*/		return 0x820F2C20;
		  /* 820F2C20h */ case   11:  		/* lfd FR1, <#[R31 + 32]> */
		/* 820F2C20h case   11:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R31 + 0x00000020) );
		/* 820F2C20h case   11:*/		return 0x820F2C24;
		  /* 820F2C24h */ case   12:  		/* lwz R6, <#[R31 + 16]> */
		/* 820F2C24h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 820F2C24h case   12:*/		return 0x820F2C28;
		  /* 820F2C28h */ case   13:  		/* lwz R5, <#[R31 + 12]> */
		/* 820F2C28h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F2C28h case   13:*/		return 0x820F2C2C;
		  /* 820F2C2Ch */ case   14:  		/* lwz R4, <#[R31 + 4]> */
		/* 820F2C2Ch case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 820F2C2Ch case   14:*/		return 0x820F2C30;
		  /* 820F2C30h */ case   15:  		/* bl 42488 */
		/* 820F2C30h case   15:*/		regs.LR = 0x820F2C34; return 0x820FD228;
		/* 820F2C30h case   15:*/		return 0x820F2C34;
		  /* 820F2C34h */ case   16:  		/* addi R11, R1, 80 */
		/* 820F2C34h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820F2C34h case   16:*/		return 0x820F2C38;
		  /* 820F2C38h */ case   17:  		/* cmpwi CR6, R3, -1 */
		/* 820F2C38h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820F2C38h case   17:*/		return 0x820F2C3C;
		  /* 820F2C3Ch */ case   18:  		/* stwx R3, <#[R29 + R11]> */
		/* 820F2C3Ch case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820F2C3Ch case   18:*/		return 0x820F2C40;
		  /* 820F2C40h */ case   19:  		/* bc 12, CR6_EQ, 136 */
		/* 820F2C40h case   19:*/		if ( regs.CR[6].eq ) { return 0x820F2CC8;  }
		/* 820F2C40h case   19:*/		return 0x820F2C44;
		  /* 820F2C44h */ case   20:  		/* lwz R11, <#[R26 + 20]> */
		/* 820F2C44h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 820F2C44h case   20:*/		return 0x820F2C48;
		  /* 820F2C48h */ case   21:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820F2C48h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820F2C48h case   21:*/		return 0x820F2C4C;
		  /* 820F2C4Ch */ case   22:  		/* lwz R9, <#[R27 + 8]> */
		/* 820F2C4Ch case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000008) );
		/* 820F2C4Ch case   22:*/		return 0x820F2C50;
		  /* 820F2C50h */ case   23:  		/* addi R28, R28, 1 */
		/* 820F2C50h case   23:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820F2C50h case   23:*/		return 0x820F2C54;
		  /* 820F2C54h */ case   24:  		/* cmplw CR6, R28, R25 */
		/* 820F2C54h case   24:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R25);
		/* 820F2C54h case   24:*/		return 0x820F2C58;
		  /* 820F2C58h */ case   25:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820F2C58h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F2C58h case   25:*/		return 0x820F2C5C;
		  /* 820F2C5Ch */ case   26:  		/* lwzx R10, <#[R30 + R9]> */
		/* 820F2C5Ch case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 820F2C5Ch case   26:*/		return 0x820F2C60;
		  /* 820F2C60h */ case   27:  		/* stw R10, <#[R11 + 56]> */
		/* 820F2C60h case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 820F2C60h case   27:*/		return 0x820F2C64;
		  /* 820F2C64h */ case   28:  		/* lwz R10, <#[R31 + 72]> */
		/* 820F2C64h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000048) );
		/* 820F2C64h case   28:*/		return 0x820F2C68;
		  /* 820F2C68h */ case   29:  		/* stw R10, <#[R11 + 72]> */
		/* 820F2C68h case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000048) );
		/* 820F2C68h case   29:*/		return 0x820F2C6C;
		  /* 820F2C6Ch */ case   30:  		/* lwz R10, <#[R31 + 80]> */
		/* 820F2C6Ch case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 820F2C6Ch case   30:*/		return 0x820F2C70;
		  /* 820F2C70h */ case   31:  		/* stw R10, <#[R11 + 80]> */
		/* 820F2C70h case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 820F2C70h case   31:*/		return 0x820F2C74;
		  /* 820F2C74h */ case   32:  		/* lwz R10, <#[R31 + 84]> */
		/* 820F2C74h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000054) );
		/* 820F2C74h case   32:*/		return 0x820F2C78;
		  /* 820F2C78h */ case   33:  		/* stw R10, <#[R11 + 84]> */
		/* 820F2C78h case   33:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000054) );
		/* 820F2C78h case   33:*/		return 0x820F2C7C;
		  /* 820F2C7Ch */ case   34:  		/* lwz R10, <#[R31 + 84]> */
		/* 820F2C7Ch case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000054) );
		/* 820F2C7Ch case   34:*/		return 0x820F2C80;
		  /* 820F2C80h */ case   35:  		/* stw R10, <#[R11 + 88]> */
		/* 820F2C80h case   35:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000058) );
		/* 820F2C80h case   35:*/		return 0x820F2C84;
		  /* 820F2C84h */ case   36:  		/* lwz R10, <#[R31 + 60]> */
		/* 820F2C84h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000003C) );
		/* 820F2C84h case   36:*/		return 0x820F2C88;
		  /* 820F2C88h */ case   37:  		/* oris R10, R10, 2 */
		/* 820F2C88h case   37:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x2);
		/* 820F2C88h case   37:*/		return 0x820F2C8C;
		  /* 820F2C8Ch */ case   38:  		/* stw R10, <#[R11 + 60]> */
		/* 820F2C8Ch case   38:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F2C8Ch case   38:*/		return 0x820F2C90;
		  /* 820F2C90h */ case   39:  		/* lwz R11, <#[R27 + 8]> */
		/* 820F2C90h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820F2C90h case   39:*/		return 0x820F2C94;
		  /* 820F2C94h */ case   40:  		/* stwx R3, <#[R30 + R11]> */
		/* 820F2C94h case   40:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820F2C94h case   40:*/		return 0x820F2C98;
		  /* 820F2C98h */ case   41:  		/* addi R30, R30, 4 */
		/* 820F2C98h case   41:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820F2C98h case   41:*/		return 0x820F2C9C;
		  /* 820F2C9Ch */ case   42:  		/* lwz R11, <#[R26 + 260]> */
		/* 820F2C9Ch case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000104) );
		/* 820F2C9Ch case   42:*/		return 0x820F2CA0;
		  /* 820F2CA0h */ case   43:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F2CA0h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F2CA0h case   43:*/		return 0x820F2CA4;
		  /* 820F2CA4h */ case   44:  		/* lwzx R11, <#[R11 + R29]> */
		/* 820F2CA4h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820F2CA4h case   44:*/		return 0x820F2CA8;
		  /* 820F2CA8h */ case   45:  		/* lwz R10, <#[R27 + 16]> */
		/* 820F2CA8h case   45:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 820F2CA8h case   45:*/		return 0x820F2CAC;
		  /* 820F2CACh */ case   46:  		/* stwx R11, <#[R10 + R29]> */
		/* 820F2CACh case   46:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 820F2CACh case   46:*/		return 0x820F2CB0;
		  /* 820F2CB0h */ case   47:  		/* addi R29, R29, 4 */
		/* 820F2CB0h case   47:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820F2CB0h case   47:*/		return 0x820F2CB4;
		  /* 820F2CB4h */ case   48:  		/* bc 12, CR6_LT, -172 */
		/* 820F2CB4h case   48:*/		if ( regs.CR[6].lt ) { return 0x820F2C08;  }
		/* 820F2CB4h case   48:*/		return 0x820F2CB8;
	}
	return 0x820F2CB8;
} // Block from 820F2BF4h-820F2CB8h (49 instructions)

//////////////////////////////////////////////////////
// Block at 820F2CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2CB8);
		  /* 820F2CB8h */ case    0:  		/* lwz R11, <#[R26 + 260]> */
		/* 820F2CB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000104) );
		/* 820F2CB8h case    0:*/		return 0x820F2CBC;
		  /* 820F2CBCh */ case    1:  		/* li R3, 0 */
		/* 820F2CBCh case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F2CBCh case    1:*/		return 0x820F2CC0;
		  /* 820F2CC0h */ case    2:  		/* stw R24, <#[R11]> */
		/* 820F2CC0h case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000000) );
		/* 820F2CC0h case    2:*/		return 0x820F2CC4;
		  /* 820F2CC4h */ case    3:  		/* b 20 */
		/* 820F2CC4h case    3:*/		return 0x820F2CD8;
		/* 820F2CC4h case    3:*/		return 0x820F2CC8;
	}
	return 0x820F2CC8;
} // Block from 820F2CB8h-820F2CC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F2CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2CC8);
		  /* 820F2CC8h */ case    0:  		/* lis R3, -32761 */
		/* 820F2CC8h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820F2CC8h case    0:*/		return 0x820F2CCC;
		  /* 820F2CCCh */ case    1:  		/* ori R3, R3, 14 */
		/* 820F2CCCh case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820F2CCCh case    1:*/		return 0x820F2CD0;
		  /* 820F2CD0h */ case    2:  		/* b 8 */
		/* 820F2CD0h case    2:*/		return 0x820F2CD8;
		/* 820F2CD0h case    2:*/		return 0x820F2CD4;
	}
	return 0x820F2CD4;
} // Block from 820F2CC8h-820F2CD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F2CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2CD4);
		  /* 820F2CD4h */ case    0:  		/* li R3, 1 */
		/* 820F2CD4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F2CD4h case    0:*/		return 0x820F2CD8;
	}
	return 0x820F2CD8;
} // Block from 820F2CD4h-820F2CD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F2CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2CD8);
		  /* 820F2CD8h */ case    0:  		/* addi R1, R1, 176 */
		/* 820F2CD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820F2CD8h case    0:*/		return 0x820F2CDC;
		  /* 820F2CDCh */ case    1:  		/* b -399940 */
		/* 820F2CDCh case    1:*/		return 0x82091298;
		/* 820F2CDCh case    1:*/		return 0x820F2CE0;
		  /* 820F2CE0h */ case    2:  		/* lwz R10, <#[R3 + 260]> */
		/* 820F2CE0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000104) );
		/* 820F2CE0h case    2:*/		return 0x820F2CE4;
		  /* 820F2CE4h */ case    3:  		/* li R11, 0 */
		/* 820F2CE4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F2CE4h case    3:*/		return 0x820F2CE8;
		  /* 820F2CE8h */ case    4:  		/* lis R8, 8272 */
		/* 820F2CE8h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0x2050);
		/* 820F2CE8h case    4:*/		return 0x820F2CEC;
		  /* 820F2CECh */ case    5:  		/* stw R11, <#[R3 + 352]> */
		/* 820F2CECh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000160) );
		/* 820F2CECh case    5:*/		return 0x820F2CF0;
		  /* 820F2CF0h */ case    6:  		/* lwz R11, <#[R10]> */
		/* 820F2CF0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F2CF0h case    6:*/		return 0x820F2CF4;
		  /* 820F2CF4h */ case    7:  		/* rlwinm R9, R11, 0, 0, 11 */
		/* 820F2CF4h case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R11);
		/* 820F2CF4h case    7:*/		return 0x820F2CF8;
		  /* 820F2CF8h */ case    8:  		/* cmplw CR6, R9, R8 */
		/* 820F2CF8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820F2CF8h case    8:*/		return 0x820F2CFC;
		  /* 820F2CFCh */ case    9:  		/* bc 4, CR6_EQ, 232 */
		/* 820F2CFCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x820F2DE4;  }
		/* 820F2CFCh case    9:*/		return 0x820F2D00;
		  /* 820F2D00h */ case   10:  		/* lwz R10, <#[R10 + 8]> */
		/* 820F2D00h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820F2D00h case   10:*/		return 0x820F2D04;
		  /* 820F2D04h */ case   11:  		/* rlwinm R9, R11, 2, 10, 29 */
		/* 820F2D04h case   11:*/		cpu::op::rlwinm<0,2,10,29>(regs,&regs.R9,regs.R11);
		/* 820F2D04h case   11:*/		return 0x820F2D08;
		  /* 820F2D08h */ case   12:  		/* lwz R8, <#[R3 + 20]> */
		/* 820F2D08h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 820F2D08h case   12:*/		return 0x820F2D0C;
		  /* 820F2D0Ch */ case   13:  		/* rlwinm R7, R11, 0, 12, 31 */
		/* 820F2D0Ch case   13:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R7,regs.R11);
		/* 820F2D0Ch case   13:*/		return 0x820F2D10;
		  /* 820F2D10h */ case   14:  		/* lwz R11, <#[R3 + 16]> */
		/* 820F2D10h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820F2D10h case   14:*/		return 0x820F2D14;
		  /* 820F2D14h */ case   15:  		/* add R9, R9, R10 */
		/* 820F2D14h case   15:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 820F2D14h case   15:*/		return 0x820F2D18;
		  /* 820F2D18h */ case   16:  		/* lwz R6, <#[R10]> */
		/* 820F2D18h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820F2D18h case   16:*/		return 0x820F2D1C;
		  /* 820F2D1Ch */ case   17:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F2D1Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F2D1Ch case   17:*/		return 0x820F2D20;
		  /* 820F2D20h */ case   18:  		/* lwzx R6, <#[R6 + R8]> */
		/* 820F2D20h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820F2D20h case   18:*/		return 0x820F2D24;
		  /* 820F2D24h */ case   19:  		/* lwz R6, <#[R6 + 4]> */
		/* 820F2D24h case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820F2D24h case   19:*/		return 0x820F2D28;
		  /* 820F2D28h */ case   20:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F2D28h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F2D28h case   20:*/		return 0x820F2D2C;
		  /* 820F2D2Ch */ case   21:  		/* lwzx R6, <#[R6 + R11]> */
		/* 820F2D2Ch case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820F2D2Ch case   21:*/		return 0x820F2D30;
		  /* 820F2D30h */ case   22:  		/* lwz R6, <#[R6 + 4]> */
		/* 820F2D30h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820F2D30h case   22:*/		return 0x820F2D34;
		  /* 820F2D34h */ case   23:  		/* rlwinm. R6, R6, 0, 23, 23 */
		/* 820F2D34h case   23:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R6,regs.R6);
		/* 820F2D34h case   23:*/		return 0x820F2D38;
		  /* 820F2D38h */ case   24:  		/* bc 12, CR0_EQ, 16 */
		/* 820F2D38h case   24:*/		if ( regs.CR[0].eq ) { return 0x820F2D48;  }
		/* 820F2D38h case   24:*/		return 0x820F2D3C;
		  /* 820F2D3Ch */ case   25:  		/* mr R6, R10 */
		/* 820F2D3Ch case   25:*/		regs.R6 = regs.R10;
		/* 820F2D3Ch case   25:*/		return 0x820F2D40;
		  /* 820F2D40h */ case   26:  		/* mr R10, R9 */
		/* 820F2D40h case   26:*/		regs.R10 = regs.R9;
		/* 820F2D40h case   26:*/		return 0x820F2D44;
		  /* 820F2D44h */ case   27:  		/* b 44 */
		/* 820F2D44h case   27:*/		return 0x820F2D70;
		/* 820F2D44h case   27:*/		return 0x820F2D48;
	}
	return 0x820F2D48;
} // Block from 820F2CD8h-820F2D48h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820F2D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2D48);
		  /* 820F2D48h */ case    0:  		/* lwz R6, <#[R9]> */
		/* 820F2D48h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000000) );
		/* 820F2D48h case    0:*/		return 0x820F2D4C;
		  /* 820F2D4Ch */ case    1:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F2D4Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F2D4Ch case    1:*/		return 0x820F2D50;
		  /* 820F2D50h */ case    2:  		/* lwzx R6, <#[R6 + R8]> */
		/* 820F2D50h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820F2D50h case    2:*/		return 0x820F2D54;
		  /* 820F2D54h */ case    3:  		/* lwz R6, <#[R6 + 4]> */
		/* 820F2D54h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820F2D54h case    3:*/		return 0x820F2D58;
		  /* 820F2D58h */ case    4:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F2D58h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F2D58h case    4:*/		return 0x820F2D5C;
		  /* 820F2D5Ch */ case    5:  		/* lwzx R11, <#[R6 + R11]> */
		/* 820F2D5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820F2D5Ch case    5:*/		return 0x820F2D60;
		  /* 820F2D60h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F2D60h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F2D60h case    6:*/		return 0x820F2D64;
		  /* 820F2D64h */ case    7:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820F2D64h case    7:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820F2D64h case    7:*/		return 0x820F2D68;
		  /* 820F2D68h */ case    8:  		/* bc 12, CR0_EQ, 268 */
		/* 820F2D68h case    8:*/		if ( regs.CR[0].eq ) { return 0x820F2E74;  }
		/* 820F2D68h case    8:*/		return 0x820F2D6C;
		  /* 820F2D6Ch */ case    9:  		/* mr R6, R9 */
		/* 820F2D6Ch case    9:*/		regs.R6 = regs.R9;
		/* 820F2D6Ch case    9:*/		return 0x820F2D70;
	}
	return 0x820F2D70;
} // Block from 820F2D48h-820F2D70h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F2D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2D70);
		  /* 820F2D70h */ case    0:  		/* li R9, 0 */
		/* 820F2D70h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F2D70h case    0:*/		return 0x820F2D74;
		  /* 820F2D74h */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 820F2D74h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820F2D74h case    1:*/		return 0x820F2D78;
		  /* 820F2D78h */ case    2:  		/* bc 12, CR6_EQ, 228 */
		/* 820F2D78h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F2E5C;  }
		/* 820F2D78h case    2:*/		return 0x820F2D7C;
		  /* 820F2D7Ch */ case    3:  		/* lis R5, -32255 */
		/* 820F2D7Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8201);
		/* 820F2D7Ch case    3:*/		return 0x820F2D80;
		  /* 820F2D80h */ case    4:  		/* mr R11, R6 */
		/* 820F2D80h case    4:*/		regs.R11 = regs.R6;
		/* 820F2D80h case    4:*/		return 0x820F2D84;
		  /* 820F2D84h */ case    5:  		/* subf R10, R6, R10 */
		/* 820F2D84h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R6,regs.R10);
		/* 820F2D84h case    5:*/		return 0x820F2D88;
		  /* 820F2D88h */ case    6:  		/* lfd FR0, <#[R5 - 24504]> */
		/* 820F2D88h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R5 + 0xFFFFA048) );
		/* 820F2D88h case    6:*/		return 0x820F2D8C;
		  /* 820F2D8Ch */ case    7:  		/* lwzx R5, <#[R10 + R11]> */
		/* 820F2D8Ch case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F2D8Ch case    7:*/		return 0x820F2D90;
		  /* 820F2D90h */ case    8:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 820F2D90h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 820F2D90h case    8:*/		return 0x820F2D94;
		  /* 820F2D94h */ case    9:  		/* lwzx R5, <#[R5 + R8]> */
		/* 820F2D94h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 820F2D94h case    9:*/		return 0x820F2D98;
		  /* 820F2D98h */ case   10:  		/* lfd FR13, <#[R5 + 32]> */
		/* 820F2D98h case   10:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R5 + 0x00000020) );
		/* 820F2D98h case   10:*/		return 0x820F2D9C;
		  /* 820F2D9Ch */ case   11:  		/* fcmpu CR6, FR13, FR0 */
		/* 820F2D9Ch case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820F2D9Ch case   11:*/		return 0x820F2DA0;
		  /* 820F2DA0h */ case   12:  		/* bc 4, CR6_EQ, 212 */
		/* 820F2DA0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820F2E74;  }
		/* 820F2DA0h case   12:*/		return 0x820F2DA4;
		  /* 820F2DA4h */ case   13:  		/* lwz R5, <#[R11]> */
		/* 820F2DA4h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 820F2DA4h case   13:*/		return 0x820F2DA8;
		  /* 820F2DA8h */ case   14:  		/* lis R4, 2 */
		/* 820F2DA8h case   14:*/		cpu::op::lis<0>(regs,&regs.R4,0x2);
		/* 820F2DA8h case   14:*/		return 0x820F2DAC;
		  /* 820F2DACh */ case   15:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 820F2DACh case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 820F2DACh case   15:*/		return 0x820F2DB0;
		  /* 820F2DB0h */ case   16:  		/* lwzx R5, <#[R5 + R8]> */
		/* 820F2DB0h case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 820F2DB0h case   16:*/		return 0x820F2DB4;
		  /* 820F2DB4h */ case   17:  		/* lwz R5, <#[R5 + 60]> */
		/* 820F2DB4h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x0000003C) );
		/* 820F2DB4h case   17:*/		return 0x820F2DB8;
		  /* 820F2DB8h */ case   18:  		/* rlwinm R5, R5, 0, 11, 15 */
		/* 820F2DB8h case   18:*/		cpu::op::rlwinm<0,0,11,15>(regs,&regs.R5,regs.R5);
		/* 820F2DB8h case   18:*/		return 0x820F2DBC;
		  /* 820F2DBCh */ case   19:  		/* cmplw CR6, R5, R4 */
		/* 820F2DBCh case   19:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 820F2DBCh case   19:*/		return 0x820F2DC0;
		  /* 820F2DC0h */ case   20:  		/* bc 12, CR6_EQ, 16 */
		/* 820F2DC0h case   20:*/		if ( regs.CR[6].eq ) { return 0x820F2DD0;  }
		/* 820F2DC0h case   20:*/		return 0x820F2DC4;
		  /* 820F2DC4h */ case   21:  		/* lwz R5, <#[R3 + 108]> */
		/* 820F2DC4h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x0000006C) );
		/* 820F2DC4h case   21:*/		return 0x820F2DC8;
		  /* 820F2DC8h */ case   22:  		/* rlwinm. R5, R5, 0, 20, 20 */
		/* 820F2DC8h case   22:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R5,regs.R5);
		/* 820F2DC8h case   22:*/		return 0x820F2DCC;
		  /* 820F2DCCh */ case   23:  		/* bc 4, CR0_EQ, 168 */
		/* 820F2DCCh case   23:*/		if ( !regs.CR[0].eq ) { return 0x820F2E74;  }
		/* 820F2DCCh case   23:*/		return 0x820F2DD0;
	}
	return 0x820F2DD0;
} // Block from 820F2D70h-820F2DD0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F2DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2DD0);
		  /* 820F2DD0h */ case    0:  		/* addi R9, R9, 1 */
		/* 820F2DD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F2DD0h case    0:*/		return 0x820F2DD4;
		  /* 820F2DD4h */ case    1:  		/* addi R11, R11, 4 */
		/* 820F2DD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F2DD4h case    1:*/		return 0x820F2DD8;
		  /* 820F2DD8h */ case    2:  		/* cmplw CR6, R9, R7 */
		/* 820F2DD8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 820F2DD8h case    2:*/		return 0x820F2DDC;
		  /* 820F2DDCh */ case    3:  		/* bc 12, CR6_LT, -80 */
		/* 820F2DDCh case    3:*/		if ( regs.CR[6].lt ) { return 0x820F2D8C;  }
		/* 820F2DDCh case    3:*/		return 0x820F2DE0;
		  /* 820F2DE0h */ case    4:  		/* b 124 */
		/* 820F2DE0h case    4:*/		return 0x820F2E5C;
		/* 820F2DE0h case    4:*/		return 0x820F2DE4;
	}
	return 0x820F2DE4;
} // Block from 820F2DD0h-820F2DE4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F2DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2DE4);
		  /* 820F2DE4h */ case    0:  		/* lis R8, 8256 */
		/* 820F2DE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R8,0x2040);
		/* 820F2DE4h case    0:*/		return 0x820F2DE8;
		  /* 820F2DE8h */ case    1:  		/* cmplw CR6, R9, R8 */
		/* 820F2DE8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820F2DE8h case    1:*/		return 0x820F2DEC;
		  /* 820F2DECh */ case    2:  		/* bc 4, CR6_EQ, 136 */
		/* 820F2DECh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F2E74;  }
		/* 820F2DECh case    2:*/		return 0x820F2DF0;
		  /* 820F2DF0h */ case    3:  		/* rlwinm. R9, R11, 0, 12, 31 */
		/* 820F2DF0h case    3:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R9,regs.R11);
		/* 820F2DF0h case    3:*/		return 0x820F2DF4;
		  /* 820F2DF4h */ case    4:  		/* lwz R6, <#[R10 + 8]> */
		/* 820F2DF4h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000008) );
		/* 820F2DF4h case    4:*/		return 0x820F2DF8;
		  /* 820F2DF8h */ case    5:  		/* rlwinm R11, R11, 2, 10, 29 */
		/* 820F2DF8h case    5:*/		cpu::op::rlwinm<0,2,10,29>(regs,&regs.R11,regs.R11);
		/* 820F2DF8h case    5:*/		return 0x820F2DFC;
		  /* 820F2DFCh */ case    6:  		/* li R8, 0 */
		/* 820F2DFCh case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F2DFCh case    6:*/		return 0x820F2E00;
		  /* 820F2E00h */ case    7:  		/* add R11, R11, R6 */
		/* 820F2E00h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 820F2E00h case    7:*/		return 0x820F2E04;
		  /* 820F2E04h */ case    8:  		/* bc 12, CR0_EQ, 88 */
		/* 820F2E04h case    8:*/		if ( regs.CR[0].eq ) { return 0x820F2E5C;  }
		/* 820F2E04h case    8:*/		return 0x820F2E08;
		  /* 820F2E08h */ case    9:  		/* mr R10, R6 */
		/* 820F2E08h case    9:*/		regs.R10 = regs.R6;
		/* 820F2E08h case    9:*/		return 0x820F2E0C;
		  /* 820F2E0Ch */ case   10:  		/* subf R7, R6, R11 */
		/* 820F2E0Ch case   10:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R6,regs.R11);
		/* 820F2E0Ch case   10:*/		return 0x820F2E10;
		  /* 820F2E10h */ case   11:  		/* lwz R11, <#[R10]> */
		/* 820F2E10h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F2E10h case   11:*/		return 0x820F2E14;
		  /* 820F2E14h */ case   12:  		/* lwzx R5, <#[R7 + R10]> */
		/* 820F2E14h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820F2E14h case   12:*/		return 0x820F2E18;
		  /* 820F2E18h */ case   13:  		/* cmplw CR6, R11, R5 */
		/* 820F2E18h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 820F2E18h case   13:*/		return 0x820F2E1C;
		  /* 820F2E1Ch */ case   14:  		/* bc 4, CR6_EQ, 88 */
		/* 820F2E1Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x820F2E74;  }
		/* 820F2E1Ch case   14:*/		return 0x820F2E20;
		  /* 820F2E20h */ case   15:  		/* lwz R5, <#[R3 + 20]> */
		/* 820F2E20h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820F2E20h case   15:*/		return 0x820F2E24;
		  /* 820F2E24h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F2E24h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2E24h case   16:*/		return 0x820F2E28;
		  /* 820F2E28h */ case   17:  		/* lis R4, 2 */
		/* 820F2E28h case   17:*/		cpu::op::lis<0>(regs,&regs.R4,0x2);
		/* 820F2E28h case   17:*/		return 0x820F2E2C;
		  /* 820F2E2Ch */ case   18:  		/* lwzx R11, <#[R11 + R5]> */
		/* 820F2E2Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820F2E2Ch case   18:*/		return 0x820F2E30;
		  /* 820F2E30h */ case   19:  		/* lwz R11, <#[R11 + 60]> */
		/* 820F2E30h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F2E30h case   19:*/		return 0x820F2E34;
		  /* 820F2E34h */ case   20:  		/* rlwinm R11, R11, 0, 11, 15 */
		/* 820F2E34h case   20:*/		cpu::op::rlwinm<0,0,11,15>(regs,&regs.R11,regs.R11);
		/* 820F2E34h case   20:*/		return 0x820F2E38;
		  /* 820F2E38h */ case   21:  		/* cmplw CR6, R11, R4 */
		/* 820F2E38h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 820F2E38h case   21:*/		return 0x820F2E3C;
		  /* 820F2E3Ch */ case   22:  		/* bc 12, CR6_EQ, 16 */
		/* 820F2E3Ch case   22:*/		if ( regs.CR[6].eq ) { return 0x820F2E4C;  }
		/* 820F2E3Ch case   22:*/		return 0x820F2E40;
		  /* 820F2E40h */ case   23:  		/* lwz R11, <#[R3 + 108]> */
		/* 820F2E40h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 820F2E40h case   23:*/		return 0x820F2E44;
		  /* 820F2E44h */ case   24:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 820F2E44h case   24:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 820F2E44h case   24:*/		return 0x820F2E48;
		  /* 820F2E48h */ case   25:  		/* bc 4, CR0_EQ, 44 */
		/* 820F2E48h case   25:*/		if ( !regs.CR[0].eq ) { return 0x820F2E74;  }
		/* 820F2E48h case   25:*/		return 0x820F2E4C;
	}
	return 0x820F2E4C;
} // Block from 820F2DE4h-820F2E4Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 820F2E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2E4C);
		  /* 820F2E4Ch */ case    0:  		/* addi R8, R8, 1 */
		/* 820F2E4Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F2E4Ch case    0:*/		return 0x820F2E50;
		  /* 820F2E50h */ case    1:  		/* addi R10, R10, 4 */
		/* 820F2E50h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F2E50h case    1:*/		return 0x820F2E54;
		  /* 820F2E54h */ case    2:  		/* cmplw CR6, R8, R9 */
		/* 820F2E54h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820F2E54h case    2:*/		return 0x820F2E58;
		  /* 820F2E58h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 820F2E58h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F2E10;  }
		/* 820F2E58h case    3:*/		return 0x820F2E5C;
	}
	return 0x820F2E5C;
} // Block from 820F2E4Ch-820F2E5Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F2E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2E5C);
		  /* 820F2E5Ch */ case    0:  		/* lis R4, 4 */
		/* 820F2E5Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x4);
		/* 820F2E5Ch case    0:*/		return 0x820F2E60;
		  /* 820F2E60h */ case    1:  		/* lis R5, 2 */
		/* 820F2E60h case    1:*/		cpu::op::lis<0>(regs,&regs.R5,0x2);
		/* 820F2E60h case    1:*/		return 0x820F2E64;
		  /* 820F2E64h */ case    2:  		/* lis R7, 4 */
		/* 820F2E64h case    2:*/		cpu::op::lis<0>(regs,&regs.R7,0x4);
		/* 820F2E64h case    2:*/		return 0x820F2E68;
		  /* 820F2E68h */ case    3:  		/* li R8, 0 */
		/* 820F2E68h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F2E68h case    3:*/		return 0x820F2E6C;
		  /* 820F2E6Ch */ case    4:  		/* li R9, 0 */
		/* 820F2E6Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F2E6Ch case    4:*/		return 0x820F2E70;
		  /* 820F2E70h */ case    5:  		/* b -3320 */
		/* 820F2E70h case    5:*/		return 0x820F2178;
		/* 820F2E70h case    5:*/		return 0x820F2E74;
	}
	return 0x820F2E74;
} // Block from 820F2E5Ch-820F2E74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F2E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2E74);
		  /* 820F2E74h */ case    0:  		/* li R3, 1 */
		/* 820F2E74h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F2E74h case    0:*/		return 0x820F2E78;
		  /* 820F2E78h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820F2E78h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F2E78h case    1:*/		return 0x820F2E7C;
	}
	return 0x820F2E7C;
} // Block from 820F2E74h-820F2E7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F2E7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2E7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2E7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2E7C);
		  /* 820F2E7Ch */ case    0:  		/* nop */
		/* 820F2E7Ch case    0:*/		cpu::op::nop();
		/* 820F2E7Ch case    0:*/		return 0x820F2E80;
	}
	return 0x820F2E80;
} // Block from 820F2E7Ch-820F2E80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F2E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2E80);
		  /* 820F2E80h */ case    0:  		/* mfspr R12, LR */
		/* 820F2E80h case    0:*/		regs.R12 = regs.LR;
		/* 820F2E80h case    0:*/		return 0x820F2E84;
		  /* 820F2E84h */ case    1:  		/* bl -400428 */
		/* 820F2E84h case    1:*/		regs.LR = 0x820F2E88; return 0x82091258;
		/* 820F2E84h case    1:*/		return 0x820F2E88;
		  /* 820F2E88h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820F2E88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820F2E88h case    2:*/		return 0x820F2E8C;
		  /* 820F2E8Ch */ case    3:  		/* mr R30, R3 */
		/* 820F2E8Ch case    3:*/		regs.R30 = regs.R3;
		/* 820F2E8Ch case    3:*/		return 0x820F2E90;
		  /* 820F2E90h */ case    4:  		/* mr R8, R4 */
		/* 820F2E90h case    4:*/		regs.R8 = regs.R4;
		/* 820F2E90h case    4:*/		return 0x820F2E94;
		  /* 820F2E94h */ case    5:  		/* li R31, 0 */
		/* 820F2E94h case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820F2E94h case    5:*/		return 0x820F2E98;
		  /* 820F2E98h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 820F2E98h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F2E98h case    6:*/		return 0x820F2E9C;
		  /* 820F2E9Ch */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820F2E9Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820F2EA8;  }
		/* 820F2E9Ch case    7:*/		return 0x820F2EA0;
		  /* 820F2EA0h */ case    8:  		/* li R31, 1 */
		/* 820F2EA0h case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820F2EA0h case    8:*/		return 0x820F2EA4;
		  /* 820F2EA4h */ case    9:  		/* b 8 */
		/* 820F2EA4h case    9:*/		return 0x820F2EAC;
		/* 820F2EA4h case    9:*/		return 0x820F2EA8;
	}
	return 0x820F2EA8;
} // Block from 820F2E80h-820F2EA8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F2EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2EA8);
		  /* 820F2EA8h */ case    0:  		/* lwz R8, <#[R30 + 260]> */
		/* 820F2EA8h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000104) );
		/* 820F2EA8h case    0:*/		return 0x820F2EAC;
	}
	return 0x820F2EAC;
} // Block from 820F2EA8h-820F2EACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F2EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2EAC);
		  /* 820F2EACh */ case    0:  		/* lwz R10, <#[R8]> */
		/* 820F2EACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820F2EACh case    0:*/		return 0x820F2EB0;
		  /* 820F2EB0h */ case    1:  		/* lis R11, 8256 */
		/* 820F2EB0h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0x2040);
		/* 820F2EB0h case    1:*/		return 0x820F2EB4;
		  /* 820F2EB4h */ case    2:  		/* rlwinm R9, R10, 0, 0, 11 */
		/* 820F2EB4h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R10);
		/* 820F2EB4h case    2:*/		return 0x820F2EB8;
		  /* 820F2EB8h */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 820F2EB8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820F2EB8h case    3:*/		return 0x820F2EBC;
		  /* 820F2EBCh */ case    4:  		/* bc 4, CR6_EQ, 412 */
		/* 820F2EBCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820F3058;  }
		/* 820F2EBCh case    4:*/		return 0x820F2EC0;
		  /* 820F2EC0h */ case    5:  		/* lwz R11, <#[R8 + 8]> */
		/* 820F2EC0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 820F2EC0h case    5:*/		return 0x820F2EC4;
		  /* 820F2EC4h */ case    6:  		/* rlwinm R9, R10, 2, 10, 29 */
		/* 820F2EC4h case    6:*/		cpu::op::rlwinm<0,2,10,29>(regs,&regs.R9,regs.R10);
		/* 820F2EC4h case    6:*/		return 0x820F2EC8;
		  /* 820F2EC8h */ case    7:  		/* rlwinm R3, R10, 0, 12, 31 */
		/* 820F2EC8h case    7:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R3,regs.R10);
		/* 820F2EC8h case    7:*/		return 0x820F2ECC;
		  /* 820F2ECCh */ case    8:  		/* lwz R7, <#[R30 + 20]> */
		/* 820F2ECCh case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000014) );
		/* 820F2ECCh case    8:*/		return 0x820F2ED0;
		  /* 820F2ED0h */ case    9:  		/* add R10, R9, R11 */
		/* 820F2ED0h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R11);
		/* 820F2ED0h case    9:*/		return 0x820F2ED4;
		  /* 820F2ED4h */ case   10:  		/* lwz R9, <#[R30 + 16]> */
		/* 820F2ED4h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 820F2ED4h case   10:*/		return 0x820F2ED8;
		  /* 820F2ED8h */ case   11:  		/* lwz R6, <#[R10]> */
		/* 820F2ED8h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820F2ED8h case   11:*/		return 0x820F2EDC;
		  /* 820F2EDCh */ case   12:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F2EDCh case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F2EDCh case   12:*/		return 0x820F2EE0;
		  /* 820F2EE0h */ case   13:  		/* lwzx R6, <#[R6 + R7]> */
		/* 820F2EE0h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 820F2EE0h case   13:*/		return 0x820F2EE4;
		  /* 820F2EE4h */ case   14:  		/* lwz R6, <#[R6 + 4]> */
		/* 820F2EE4h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820F2EE4h case   14:*/		return 0x820F2EE8;
		  /* 820F2EE8h */ case   15:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F2EE8h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F2EE8h case   15:*/		return 0x820F2EEC;
		  /* 820F2EECh */ case   16:  		/* lwzx R6, <#[R6 + R9]> */
		/* 820F2EECh case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R9 + 0x00000000) );
		/* 820F2EECh case   16:*/		return 0x820F2EF0;
		  /* 820F2EF0h */ case   17:  		/* lwz R6, <#[R6 + 4]> */
		/* 820F2EF0h case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820F2EF0h case   17:*/		return 0x820F2EF4;
		  /* 820F2EF4h */ case   18:  		/* rlwinm. R6, R6, 0, 23, 23 */
		/* 820F2EF4h case   18:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R6,regs.R6);
		/* 820F2EF4h case   18:*/		return 0x820F2EF8;
		  /* 820F2EF8h */ case   19:  		/* bc 12, CR0_EQ, 16 */
		/* 820F2EF8h case   19:*/		if ( regs.CR[0].eq ) { return 0x820F2F08;  }
		/* 820F2EF8h case   19:*/		return 0x820F2EFC;
		  /* 820F2EFCh */ case   20:  		/* mr R6, R11 */
		/* 820F2EFCh case   20:*/		regs.R6 = regs.R11;
		/* 820F2EFCh case   20:*/		return 0x820F2F00;
		  /* 820F2F00h */ case   21:  		/* mr R11, R10 */
		/* 820F2F00h case   21:*/		regs.R11 = regs.R10;
		/* 820F2F00h case   21:*/		return 0x820F2F04;
		  /* 820F2F04h */ case   22:  		/* b 44 */
		/* 820F2F04h case   22:*/		return 0x820F2F30;
		/* 820F2F04h case   22:*/		return 0x820F2F08;
	}
	return 0x820F2F08;
} // Block from 820F2EACh-820F2F08h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820F2F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2F08);
		  /* 820F2F08h */ case    0:  		/* lwz R6, <#[R11]> */
		/* 820F2F08h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820F2F08h case    0:*/		return 0x820F2F0C;
		  /* 820F2F0Ch */ case    1:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F2F0Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F2F0Ch case    1:*/		return 0x820F2F10;
		  /* 820F2F10h */ case    2:  		/* lwzx R6, <#[R6 + R7]> */
		/* 820F2F10h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 820F2F10h case    2:*/		return 0x820F2F14;
		  /* 820F2F14h */ case    3:  		/* lwz R6, <#[R6 + 4]> */
		/* 820F2F14h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 820F2F14h case    3:*/		return 0x820F2F18;
		  /* 820F2F18h */ case    4:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820F2F18h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820F2F18h case    4:*/		return 0x820F2F1C;
		  /* 820F2F1Ch */ case    5:  		/* lwzx R9, <#[R6 + R9]> */
		/* 820F2F1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + regs.R9 + 0x00000000) );
		/* 820F2F1Ch case    5:*/		return 0x820F2F20;
		  /* 820F2F20h */ case    6:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F2F20h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F2F20h case    6:*/		return 0x820F2F24;
		  /* 820F2F24h */ case    7:  		/* rlwinm. R9, R9, 0, 23, 23 */
		/* 820F2F24h case    7:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R9);
		/* 820F2F24h case    7:*/		return 0x820F2F28;
		  /* 820F2F28h */ case    8:  		/* bc 12, CR0_EQ, 304 */
		/* 820F2F28h case    8:*/		if ( regs.CR[0].eq ) { return 0x820F3058;  }
		/* 820F2F28h case    8:*/		return 0x820F2F2C;
		  /* 820F2F2Ch */ case    9:  		/* mr R6, R10 */
		/* 820F2F2Ch case    9:*/		regs.R6 = regs.R10;
		/* 820F2F2Ch case    9:*/		return 0x820F2F30;
	}
	return 0x820F2F30;
} // Block from 820F2F08h-820F2F30h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F2F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2F30);
		  /* 820F2F30h */ case    0:  		/* lwz R4, <#[R30 + 260]> */
		/* 820F2F30h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000104) );
		/* 820F2F30h case    0:*/		return 0x820F2F34;
		  /* 820F2F34h */ case    1:  		/* mr R9, R6 */
		/* 820F2F34h case    1:*/		regs.R9 = regs.R6;
		/* 820F2F34h case    1:*/		return 0x820F2F38;
		  /* 820F2F38h */ case    2:  		/* cmplw CR6, R4, R8 */
		/* 820F2F38h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R8);
		/* 820F2F38h case    2:*/		return 0x820F2F3C;
		  /* 820F2F3Ch */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 820F2F3Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820F2F44;  }
		/* 820F2F3Ch case    3:*/		return 0x820F2F40;
		  /* 820F2F40h */ case    4:  		/* lwz R9, <#[R4 + 8]> */
		/* 820F2F40h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000008) );
		/* 820F2F40h case    4:*/		return 0x820F2F44;
	}
	return 0x820F2F44;
} // Block from 820F2F30h-820F2F44h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F2F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2F44);
		  /* 820F2F44h */ case    0:  		/* li R5, 0 */
		/* 820F2F44h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F2F44h case    0:*/		return 0x820F2F48;
		  /* 820F2F48h */ case    1:  		/* li R10, 0 */
		/* 820F2F48h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820F2F48h case    1:*/		return 0x820F2F4C;
		  /* 820F2F4Ch */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 820F2F4Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820F2F4Ch case    2:*/		return 0x820F2F50;
		  /* 820F2F50h */ case    3:  		/* stw R5, <#[R30 + 352]> */
		/* 820F2F50h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R30 + 0x00000160) );
		/* 820F2F50h case    3:*/		return 0x820F2F54;
		  /* 820F2F54h */ case    4:  		/* bc 12, CR6_EQ, 156 */
		/* 820F2F54h case    4:*/		if ( regs.CR[6].eq ) { return 0x820F2FF0;  }
		/* 820F2F54h case    4:*/		return 0x820F2F58;
		  /* 820F2F58h */ case    5:  		/* subf R5, R9, R11 */
		/* 820F2F58h case    5:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R9,regs.R11);
		/* 820F2F58h case    5:*/		return 0x820F2F5C;
		  /* 820F2F5Ch */ case    6:  		/* lis R11, -32256 */
		/* 820F2F5Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820F2F5Ch case    6:*/		return 0x820F2F60;
		  /* 820F2F60h */ case    7:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 820F2F60h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 820F2F60h case    7:*/		return 0x820F2F64;
		  /* 820F2F64h */ case    8:  		/* lwzx R11, <#[R5 + R9]> */
		/* 820F2F64h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 820F2F64h case    8:*/		return 0x820F2F68;
		  /* 820F2F68h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F2F68h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2F68h case    9:*/		return 0x820F2F6C;
		  /* 820F2F6Ch */ case   10:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820F2F6Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820F2F6Ch case   10:*/		return 0x820F2F70;
		  /* 820F2F70h */ case   11:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820F2F70h case   11:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820F2F70h case   11:*/		return 0x820F2F74;
		  /* 820F2F74h */ case   12:  		/* fcmpu CR6, FR13, FR0 */
		/* 820F2F74h case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820F2F74h case   12:*/		return 0x820F2F78;
		  /* 820F2F78h */ case   13:  		/* bc 4, CR6_EQ, 224 */
		/* 820F2F78h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820F3058;  }
		/* 820F2F78h case   13:*/		return 0x820F2F7C;
		  /* 820F2F7Ch */ case   14:  		/* cmpwi CR6, R31, 0 */
		/* 820F2F7Ch case   14:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 820F2F7Ch case   14:*/		return 0x820F2F80;
		  /* 820F2F80h */ case   15:  		/* bc 4, CR6_EQ, 36 */
		/* 820F2F80h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820F2FA4;  }
		/* 820F2F80h case   15:*/		return 0x820F2F84;
		  /* 820F2F84h */ case   16:  		/* lwz R11, <#[R9]> */
		/* 820F2F84h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820F2F84h case   16:*/		return 0x820F2F88;
		  /* 820F2F88h */ case   17:  		/* lis R29, 8 */
		/* 820F2F88h case   17:*/		cpu::op::lis<0>(regs,&regs.R29,0x8);
		/* 820F2F88h case   17:*/		return 0x820F2F8C;
		  /* 820F2F8Ch */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F2F8Ch case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2F8Ch case   18:*/		return 0x820F2F90;
		  /* 820F2F90h */ case   19:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820F2F90h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820F2F90h case   19:*/		return 0x820F2F94;
		  /* 820F2F94h */ case   20:  		/* lwz R11, <#[R11 + 60]> */
		/* 820F2F94h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F2F94h case   20:*/		return 0x820F2F98;
		  /* 820F2F98h */ case   21:  		/* rlwinm R11, R11, 0, 11, 15 */
		/* 820F2F98h case   21:*/		cpu::op::rlwinm<0,0,11,15>(regs,&regs.R11,regs.R11);
		/* 820F2F98h case   21:*/		return 0x820F2F9C;
		  /* 820F2F9Ch */ case   22:  		/* cmplw CR6, R11, R29 */
		/* 820F2F9Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820F2F9Ch case   22:*/		return 0x820F2FA0;
		  /* 820F2FA0h */ case   23:  		/* bc 4, CR6_EQ, 184 */
		/* 820F2FA0h case   23:*/		if ( !regs.CR[6].eq ) { return 0x820F3058;  }
		/* 820F2FA0h case   23:*/		return 0x820F2FA4;
	}
	return 0x820F2FA4;
} // Block from 820F2F44h-820F2FA4h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F2FA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2FA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2FA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2FA4);
		  /* 820F2FA4h */ case    0:  		/* lwz R11, <#[R9]> */
		/* 820F2FA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820F2FA4h case    0:*/		return 0x820F2FA8;
	}
	return 0x820F2FA8;
} // Block from 820F2FA4h-820F2FA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F2FA8h
// Function '?MatchNEG@CShaderProgram@D3DXShader@@IAAJH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2FA8);
		  /* 820F2FA8h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F2FA8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2FA8h case    0:*/		return 0x820F2FAC;
		  /* 820F2FACh */ case    1:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820F2FACh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820F2FACh case    1:*/		return 0x820F2FB0;
		  /* 820F2FB0h */ case    2:  		/* lwz R29, <#[R11 + 60]> */
		/* 820F2FB0h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F2FB0h case    2:*/		return 0x820F2FB4;
		  /* 820F2FB4h */ case    3:  		/* rlwinm. R29, R29, 0, 22, 22 */
		/* 820F2FB4h case    3:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R29,regs.R29);
		/* 820F2FB4h case    3:*/		return 0x820F2FB8;
		  /* 820F2FB8h */ case    4:  		/* bc 4, CR0_EQ, 40 */
		/* 820F2FB8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820F2FE0;  }
		/* 820F2FB8h case    4:*/		return 0x820F2FBC;
		  /* 820F2FBCh */ case    5:  		/* subfic R29, R31, 0 */
		/* 820F2FBCh case    5:*/		cpu::op::subfic<0>(regs,&regs.R29,regs.R31,0x0);
		/* 820F2FBCh case    5:*/		return 0x820F2FC0;
		  /* 820F2FC0h */ case    6:  		/* lwz R28, <#[R11]> */
		/* 820F2FC0h case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 820F2FC0h case    6:*/		return 0x820F2FC4;
		  /* 820F2FC4h */ case    7:  		/* subfe R11, R29, R29 */
		/* 820F2FC4h case    7:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R29,regs.R29);
		/* 820F2FC4h case    7:*/		return 0x820F2FC8;
		  /* 820F2FC8h */ case    8:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 820F2FC8h case    8:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 820F2FC8h case    8:*/		return 0x820F2FCC;
		  /* 820F2FCCh */ case    9:  		/* addi R11, R11, 24 */
		/* 820F2FCCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 820F2FCCh case    9:*/		return 0x820F2FD0;
		  /* 820F2FD0h */ case   10:  		/* and. R11, R11, R28 */
		/* 820F2FD0h case   10:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R28);
		/* 820F2FD0h case   10:*/		return 0x820F2FD4;
		  /* 820F2FD4h */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 820F2FD4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820F2FE0;  }
		/* 820F2FD4h case   11:*/		return 0x820F2FD8;
		  /* 820F2FD8h */ case   12:  		/* li R11, 1 */
		/* 820F2FD8h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820F2FD8h case   12:*/		return 0x820F2FDC;
		  /* 820F2FDCh */ case   13:  		/* stw R11, <#[R30 + 352]> */
		/* 820F2FDCh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000160) );
		/* 820F2FDCh case   13:*/		return 0x820F2FE0;
	}
	return 0x820F2FE0;
} // Block from 820F2FA8h-820F2FE0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F2FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2FE0);
		  /* 820F2FE0h */ case    0:  		/* addi R10, R10, 1 */
		/* 820F2FE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F2FE0h case    0:*/		return 0x820F2FE4;
		  /* 820F2FE4h */ case    1:  		/* addi R9, R9, 4 */
		/* 820F2FE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F2FE4h case    1:*/		return 0x820F2FE8;
		  /* 820F2FE8h */ case    2:  		/* cmplw CR6, R10, R3 */
		/* 820F2FE8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R3);
		/* 820F2FE8h case    2:*/		return 0x820F2FEC;
		  /* 820F2FECh */ case    3:  		/* bc 12, CR6_LT, -136 */
		/* 820F2FECh case    3:*/		if ( regs.CR[6].lt ) { return 0x820F2F64;  }
		/* 820F2FECh case    3:*/		return 0x820F2FF0;
	}
	return 0x820F2FF0;
} // Block from 820F2FE0h-820F2FF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F2FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F2FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F2FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F2FF0);
		  /* 820F2FF0h */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 820F2FF0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 820F2FF0h case    0:*/		return 0x820F2FF4;
		  /* 820F2FF4h */ case    1:  		/* li R9, 0 */
		/* 820F2FF4h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F2FF4h case    1:*/		return 0x820F2FF8;
		  /* 820F2FF8h */ case    2:  		/* mr R3, R30 */
		/* 820F2FF8h case    2:*/		regs.R3 = regs.R30;
		/* 820F2FF8h case    2:*/		return 0x820F2FFC;
		  /* 820F2FFCh */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 820F2FFCh case    3:*/		if ( regs.CR[6].eq ) { return 0x820F3010;  }
		/* 820F2FFCh case    3:*/		return 0x820F3000;
		  /* 820F3000h */ case    4:  		/* lwz R6, <#[R4 + 8]> */
		/* 820F3000h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R4 + 0x00000008) );
		/* 820F3000h case    4:*/		return 0x820F3004;
		  /* 820F3004h */ case    5:  		/* lis R7, 1 */
		/* 820F3004h case    5:*/		cpu::op::lis<0>(regs,&regs.R7,0x1);
		/* 820F3004h case    5:*/		return 0x820F3008;
	}
	return 0x820F3008;
} // Block from 820F2FF0h-820F3008h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F3008h
// Function '?MatchABSModifier@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3008);
		  /* 820F3008h */ case    0:  		/* li R5, 0 */
		/* 820F3008h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F3008h case    0:*/		return 0x820F300C;
		  /* 820F300Ch */ case    1:  		/* b 16 */
		/* 820F300Ch case    1:*/		return 0x820F301C;
		/* 820F300Ch case    1:*/		return 0x820F3010;
	}
	return 0x820F3010;
} // Block from 820F3008h-820F3010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F3010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3010);
		  /* 820F3010h */ case    0:  		/* li R8, 0 */
		/* 820F3010h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F3010h case    0:*/		return 0x820F3014;
		  /* 820F3014h */ case    1:  		/* lis R7, 9 */
		/* 820F3014h case    1:*/		cpu::op::lis<0>(regs,&regs.R7,0x9);
		/* 820F3014h case    1:*/		return 0x820F3018;
		  /* 820F3018h */ case    2:  		/* lis R5, 8 */
		/* 820F3018h case    2:*/		cpu::op::lis<0>(regs,&regs.R5,0x8);
		/* 820F3018h case    2:*/		return 0x820F301C;
	}
	return 0x820F301C;
} // Block from 820F3010h-820F301Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F301Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F301C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F301C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F301C);
		  /* 820F301Ch */ case    0:  		/* lis R4, 1 */
		/* 820F301Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x1);
		/* 820F301Ch case    0:*/		return 0x820F3020;
		  /* 820F3020h */ case    1:  		/* bl -3752 */
		/* 820F3020h case    1:*/		regs.LR = 0x820F3024; return 0x820F2178;
		/* 820F3020h case    1:*/		return 0x820F3024;
		  /* 820F3024h */ case    2:  		/* lwz R11, <#[R30 + 352]> */
		/* 820F3024h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000160) );
		/* 820F3024h case    2:*/		return 0x820F3028;
		  /* 820F3028h */ case    3:  		/* mr R31, R3 */
		/* 820F3028h case    3:*/		regs.R31 = regs.R3;
		/* 820F3028h case    3:*/		return 0x820F302C;
		  /* 820F302Ch */ case    4:  		/* cmplwi CR6, R11, 2 */
		/* 820F302Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820F302Ch case    4:*/		return 0x820F3030;
		  /* 820F3030h */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 820F3030h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820F3050;  }
		/* 820F3030h case    5:*/		return 0x820F3034;
		  /* 820F3034h */ case    6:  		/* lwz R11, <#[R30 + 260]> */
		/* 820F3034h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000104) );
		/* 820F3034h case    6:*/		return 0x820F3038;
		  /* 820F3038h */ case    7:  		/* lis R10, -32254 */
		/* 820F3038h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820F3038h case    7:*/		return 0x820F303C;
		  /* 820F303Ch */ case    8:  		/* li R5, 4702 */
		/* 820F303Ch case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x125E);
		/* 820F303Ch case    8:*/		return 0x820F3040;
		  /* 820F3040h */ case    9:  		/* addi R6, R10, -16176 */
		/* 820F3040h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFC0D0);
		/* 820F3040h case    9:*/		return 0x820F3044;
		  /* 820F3044h */ case   10:  		/* mr R3, R30 */
		/* 820F3044h case   10:*/		regs.R3 = regs.R30;
		/* 820F3044h case   10:*/		return 0x820F3048;
		  /* 820F3048h */ case   11:  		/* lwz R4, <#[R11 + 60]> */
		/* 820F3048h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F3048h case   11:*/		return 0x820F304C;
		  /* 820F304Ch */ case   12:  		/* bl 112548 */
		/* 820F304Ch case   12:*/		regs.LR = 0x820F3050; return 0x8210E7F0;
		/* 820F304Ch case   12:*/		return 0x820F3050;
	}
	return 0x820F3050;
} // Block from 820F301Ch-820F3050h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820F3050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3050);
		  /* 820F3050h */ case    0:  		/* mr R3, R31 */
		/* 820F3050h case    0:*/		regs.R3 = regs.R31;
		/* 820F3050h case    0:*/		return 0x820F3054;
		  /* 820F3054h */ case    1:  		/* b 8 */
		/* 820F3054h case    1:*/		return 0x820F305C;
		/* 820F3054h case    1:*/		return 0x820F3058;
	}
	return 0x820F3058;
} // Block from 820F3050h-820F3058h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F3058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3058);
		  /* 820F3058h */ case    0:  		/* li R3, 1 */
		/* 820F3058h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F3058h case    0:*/		return 0x820F305C;
	}
	return 0x820F305C;
} // Block from 820F3058h-820F305Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F305Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F305C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F305C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F305C);
		  /* 820F305Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 820F305Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820F305Ch case    0:*/		return 0x820F3060;
		  /* 820F3060h */ case    1:  		/* b -400824 */
		/* 820F3060h case    1:*/		return 0x820912A8;
		/* 820F3060h case    1:*/		return 0x820F3064;
		  /* 820F3064h */ case    2:  		/* nop */
		/* 820F3064h case    2:*/		cpu::op::nop();
		/* 820F3064h case    2:*/		return 0x820F3068;
	}
	return 0x820F3068;
} // Block from 820F305Ch-820F3068h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F3068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3068);
		  /* 820F3068h */ case    0:  		/* mfspr R12, LR */
		/* 820F3068h case    0:*/		regs.R12 = regs.LR;
		/* 820F3068h case    0:*/		return 0x820F306C;
		  /* 820F306Ch */ case    1:  		/* bl -400912 */
		/* 820F306Ch case    1:*/		regs.LR = 0x820F3070; return 0x8209125C;
		/* 820F306Ch case    1:*/		return 0x820F3070;
		  /* 820F3070h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820F3070h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820F3070h case    2:*/		return 0x820F3074;
		  /* 820F3074h */ case    3:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F3074h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F3074h case    3:*/		return 0x820F3078;
		  /* 820F3078h */ case    4:  		/* lis R10, 8272 */
		/* 820F3078h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x2050);
		/* 820F3078h case    4:*/		return 0x820F307C;
		  /* 820F307Ch */ case    5:  		/* mr R31, R3 */
		/* 820F307Ch case    5:*/		regs.R31 = regs.R3;
		/* 820F307Ch case    5:*/		return 0x820F3080;
		  /* 820F3080h */ case    6:  		/* li R29, 1 */
		/* 820F3080h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820F3080h case    6:*/		return 0x820F3084;
		  /* 820F3084h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820F3084h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F3084h case    7:*/		return 0x820F3088;
		  /* 820F3088h */ case    8:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820F3088h case    8:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820F3088h case    8:*/		return 0x820F308C;
		  /* 820F308Ch */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820F308Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F308Ch case    9:*/		return 0x820F3090;
		  /* 820F3090h */ case   10:  		/* bc 4, CR6_EQ, 92 */
		/* 820F3090h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820F30EC;  }
		/* 820F3090h case   10:*/		return 0x820F3094;
		  /* 820F3094h */ case   11:  		/* lwz R11, <#[R3 + 260]> */
		/* 820F3094h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000104) );
		/* 820F3094h case   11:*/		return 0x820F3098;
		  /* 820F3098h */ case   12:  		/* lwz R10, <#[R3 + 20]> */
		/* 820F3098h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 820F3098h case   12:*/		return 0x820F309C;
		  /* 820F309Ch */ case   13:  		/* lwz R9, <#[R3 + 16]> */
		/* 820F309Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 820F309Ch case   13:*/		return 0x820F30A0;
		  /* 820F30A0h */ case   14:  		/* lwz R8, <#[R11]> */
		/* 820F30A0h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820F30A0h case   14:*/		return 0x820F30A4;
		  /* 820F30A4h */ case   15:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F30A4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F30A4h case   15:*/		return 0x820F30A8;
		  /* 820F30A8h */ case   16:  		/* rlwinm R8, R8, 2, 10, 29 */
		/* 820F30A8h case   16:*/		cpu::op::rlwinm<0,2,10,29>(regs,&regs.R8,regs.R8);
		/* 820F30A8h case   16:*/		return 0x820F30AC;
		  /* 820F30ACh */ case   17:  		/* lwzx R11, <#[R8 + R11]> */
		/* 820F30ACh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820F30ACh case   17:*/		return 0x820F30B0;
		  /* 820F30B0h */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F30B0h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F30B0h case   18:*/		return 0x820F30B4;
		  /* 820F30B4h */ case   19:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F30B4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F30B4h case   19:*/		return 0x820F30B8;
		  /* 820F30B8h */ case   20:  		/* lwz R10, <#[R11 + 4]> */
		/* 820F30B8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820F30B8h case   20:*/		return 0x820F30BC;
		  /* 820F30BCh */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F30BCh case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F30BCh case   21:*/		return 0x820F30C0;
		  /* 820F30C0h */ case   22:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820F30C0h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F30C0h case   22:*/		return 0x820F30C4;
		  /* 820F30C4h */ case   23:  		/* lwz R10, <#[R10 + 4]> */
		/* 820F30C4h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820F30C4h case   23:*/		return 0x820F30C8;
		  /* 820F30C8h */ case   24:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 820F30C8h case   24:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 820F30C8h case   24:*/		return 0x820F30CC;
		  /* 820F30CCh */ case   25:  		/* bc 12, CR0_EQ, 24 */
		/* 820F30CCh case   25:*/		if ( regs.CR[0].eq ) { return 0x820F30E4;  }
		/* 820F30CCh case   25:*/		return 0x820F30D0;
	}
	return 0x820F30D0;
} // Block from 820F3068h-820F30D0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820F30D0h
// Function '?MatchBiasModifier@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F30D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F30D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F30D0);
		  /* 820F30D0h */ case    0:  		/* lis R10, -32255 */
		/* 820F30D0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820F30D0h case    0:*/		return 0x820F30D4;
		  /* 820F30D4h */ case    1:  		/* lfd FR13, <#[R11 + 32]> */
		/* 820F30D4h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 820F30D4h case    1:*/		return 0x820F30D8;
		  /* 820F30D8h */ case    2:  		/* lfd FR0, <#[R10 - 24488]> */
		/* 820F30D8h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0xFFFFA058) );
		/* 820F30D8h case    2:*/		return 0x820F30DC;
		  /* 820F30DCh */ case    3:  		/* fcmpu CR6, FR13, FR0 */
		/* 820F30DCh case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820F30DCh case    3:*/		return 0x820F30E0;
		  /* 820F30E0h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 820F30E0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820F30EC;  }
		/* 820F30E0h case    4:*/		return 0x820F30E4;
	}
	return 0x820F30E4;
} // Block from 820F30D0h-820F30E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F30E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F30E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F30E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F30E4);
		  /* 820F30E4h */ case    0:  		/* li R3, 1 */
		/* 820F30E4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F30E4h case    0:*/		return 0x820F30E8;
		  /* 820F30E8h */ case    1:  		/* b 84 */
		/* 820F30E8h case    1:*/		return 0x820F313C;
		/* 820F30E8h case    1:*/		return 0x820F30EC;
	}
	return 0x820F30EC;
} // Block from 820F30E4h-820F30ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F30ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F30EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F30EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F30EC);
		  /* 820F30ECh */ case    0:  		/* lwz R11, <#[R31 + 260]> */
		/* 820F30ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F30ECh case    0:*/		return 0x820F30F0;
		  /* 820F30F0h */ case    1:  		/* li R10, 129 */
		/* 820F30F0h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x81);
		/* 820F30F0h case    1:*/		return 0x820F30F4;
		  /* 820F30F4h */ case    2:  		/* li R8, 1 */
		/* 820F30F4h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F30F4h case    2:*/		return 0x820F30F8;
		  /* 820F30F8h */ case    3:  		/* li R7, 2 */
		/* 820F30F8h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 820F30F8h case    3:*/		return 0x820F30FC;
		  /* 820F30FCh */ case    4:  		/* li R6, 0 */
		/* 820F30FCh case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F30FCh case    4:*/		return 0x820F3100;
		  /* 820F3100h */ case    5:  		/* mr R5, R11 */
		/* 820F3100h case    5:*/		regs.R5 = regs.R11;
		/* 820F3100h case    5:*/		return 0x820F3104;
		  /* 820F3104h */ case    6:  		/* lwz R4, <#[R11]> */
		/* 820F3104h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820F3104h case    6:*/		return 0x820F3108;
		  /* 820F3108h */ case    7:  		/* mr R3, R31 */
		/* 820F3108h case    7:*/		regs.R3 = regs.R31;
		/* 820F3108h case    7:*/		return 0x820F310C;
		  /* 820F310Ch */ case    8:  		/* rlwimi R4, R10, 22, 0, 11 */
		/* 820F310Ch case    8:*/		cpu::op::rlwimi<0,22,0,11>(regs,&regs.R4,regs.R10);
		/* 820F310Ch case    8:*/		return 0x820F3110;
		  /* 820F3110h */ case    9:  		/* bl -27880 */
		/* 820F3110h case    9:*/		regs.LR = 0x820F3114; return 0x820EC428;
		/* 820F3110h case    9:*/		return 0x820F3114;
		  /* 820F3114h */ case   10:  		/* or. R30, R3, R3 */
		/* 820F3114h case   10:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F3114h case   10:*/		return 0x820F3118;
		  /* 820F3118h */ case   11:  		/* bc 12, CR0_EQ, 32 */
		/* 820F3118h case   11:*/		if ( regs.CR[0].eq ) { return 0x820F3138;  }
		/* 820F3118h case   11:*/		return 0x820F311C;
		  /* 820F311Ch */ case   12:  		/* mr R4, R30 */
		/* 820F311Ch case   12:*/		regs.R4 = regs.R30;
		/* 820F311Ch case   12:*/		return 0x820F3120;
		  /* 820F3120h */ case   13:  		/* mr R3, R31 */
		/* 820F3120h case   13:*/		regs.R3 = regs.R31;
		/* 820F3120h case   13:*/		return 0x820F3124;
		  /* 820F3124h */ case   14:  		/* bl -676 */
		/* 820F3124h case   14:*/		regs.LR = 0x820F3128; return 0x820F2E80;
		/* 820F3124h case   14:*/		return 0x820F3128;
		  /* 820F3128h */ case   15:  		/* or. R29, R3, R3 */
		/* 820F3128h case   15:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F3128h case   15:*/		return 0x820F312C;
		  /* 820F312Ch */ case   16:  		/* bc 4, CR0_EQ, 12 */
		/* 820F312Ch case   16:*/		if ( !regs.CR[0].eq ) { return 0x820F3138;  }
		/* 820F312Ch case   16:*/		return 0x820F3130;
		  /* 820F3130h */ case   17:  		/* li R11, 0 */
		/* 820F3130h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820F3130h case   17:*/		return 0x820F3134;
		  /* 820F3134h */ case   18:  		/* stw R11, <#[R30]> */
		/* 820F3134h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F3134h case   18:*/		return 0x820F3138;
	}
	return 0x820F3138;
} // Block from 820F30ECh-820F3138h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F3138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3138);
		  /* 820F3138h */ case    0:  		/* mr R3, R29 */
		/* 820F3138h case    0:*/		regs.R3 = regs.R29;
		/* 820F3138h case    0:*/		return 0x820F313C;
	}
	return 0x820F313C;
} // Block from 820F3138h-820F313Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F313Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F313C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F313C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F313C);
		  /* 820F313Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820F313Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820F313Ch case    0:*/		return 0x820F3140;
		  /* 820F3140h */ case    1:  		/* b -401044 */
		/* 820F3140h case    1:*/		return 0x820912AC;
		/* 820F3140h case    1:*/		return 0x820F3144;
		  /* 820F3144h */ case    2:  		/* nop */
		/* 820F3144h case    2:*/		cpu::op::nop();
		/* 820F3144h case    2:*/		return 0x820F3148;
	}
	return 0x820F3148;
} // Block from 820F313Ch-820F3148h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F3148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3148);
		  /* 820F3148h */ case    0:  		/* mfspr R12, LR */
		/* 820F3148h case    0:*/		regs.R12 = regs.LR;
		/* 820F3148h case    0:*/		return 0x820F314C;
		  /* 820F314Ch */ case    1:  		/* bl -401152 */
		/* 820F314Ch case    1:*/		regs.LR = 0x820F3150; return 0x8209124C;
		/* 820F314Ch case    1:*/		return 0x820F3150;
		  /* 820F3150h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820F3150h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820F3150h case    2:*/		return 0x820F3154;
		  /* 820F3154h */ case    3:  		/* lwz R5, <#[R3 + 260]> */
		/* 820F3154h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000104) );
		/* 820F3154h case    3:*/		return 0x820F3158;
		  /* 820F3158h */ case    4:  		/* li R25, 0 */
		/* 820F3158h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820F3158h case    4:*/		return 0x820F315C;
		  /* 820F315Ch */ case    5:  		/* lis R10, 8256 */
		/* 820F315Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x2040);
		/* 820F315Ch case    5:*/		return 0x820F3160;
		  /* 820F3160h */ case    6:  		/* stw R25, <#[R3 + 352]> */
		/* 820F3160h case    6:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000160) );
		/* 820F3160h case    6:*/		return 0x820F3164;
		  /* 820F3164h */ case    7:  		/* mr R29, R3 */
		/* 820F3164h case    7:*/		regs.R29 = regs.R3;
		/* 820F3164h case    7:*/		return 0x820F3168;
		  /* 820F3168h */ case    8:  		/* mr R26, R25 */
		/* 820F3168h case    8:*/		regs.R26 = regs.R25;
		/* 820F3168h case    8:*/		return 0x820F316C;
		  /* 820F316Ch */ case    9:  		/* lwz R11, <#[R5]> */
		/* 820F316Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820F316Ch case    9:*/		return 0x820F3170;
		  /* 820F3170h */ case   10:  		/* rlwinm R9, R11, 0, 0, 11 */
		/* 820F3170h case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R11);
		/* 820F3170h case   10:*/		return 0x820F3174;
		  /* 820F3174h */ case   11:  		/* cmplw CR6, R9, R10 */
		/* 820F3174h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820F3174h case   11:*/		return 0x820F3178;
		  /* 820F3178h */ case   12:  		/* bc 4, CR6_EQ, 492 */
		/* 820F3178h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820F3364;  }
		/* 820F3178h case   12:*/		return 0x820F317C;
		  /* 820F317Ch */ case   13:  		/* rlwinm. R11, R11, 0, 12, 31 */
		/* 820F317Ch case   13:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R11,regs.R11);
		/* 820F317Ch case   13:*/		return 0x820F3180;
		  /* 820F3180h */ case   14:  		/* li R27, 1 */
		/* 820F3180h case   14:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820F3180h case   14:*/		return 0x820F3184;
		  /* 820F3184h */ case   15:  		/* bc 12, CR0_EQ, 64 */
		/* 820F3184h case   15:*/		if ( regs.CR[0].eq ) { return 0x820F31C4;  }
		/* 820F3184h case   15:*/		return 0x820F3188;
		  /* 820F3188h */ case   16:  		/* lwz R8, <#[R5 + 8]> */
		/* 820F3188h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000008) );
		/* 820F3188h case   16:*/		return 0x820F318C;
		  /* 820F318Ch */ case   17:  		/* mr R10, R25 */
		/* 820F318Ch case   17:*/		regs.R10 = regs.R25;
		/* 820F318Ch case   17:*/		return 0x820F3190;
		  /* 820F3190h */ case   18:  		/* mtspr CTR, R11 */
		/* 820F3190h case   18:*/		regs.CTR = regs.R11;
		/* 820F3190h case   18:*/		return 0x820F3194;
		  /* 820F3194h */ case   19:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 820F3194h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 820F3194h case   19:*/		return 0x820F3198;
		  /* 820F3198h */ case   20:  		/* lwzx R7, <#[R10 + R8]> */
		/* 820F3198h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820F3198h case   20:*/		return 0x820F319C;
		  /* 820F319Ch */ case   21:  		/* addi R10, R10, 4 */
		/* 820F319Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F319Ch case   21:*/		return 0x820F31A0;
		  /* 820F31A0h */ case   22:  		/* lwzx R6, <#[R9 + R8]> */
		/* 820F31A0h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820F31A0h case   22:*/		return 0x820F31A4;
		  /* 820F31A4h */ case   23:  		/* addi R9, R9, 4 */
		/* 820F31A4h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F31A4h case   23:*/		return 0x820F31A8;
		  /* 820F31A8h */ case   24:  		/* subf R7, R7, R6 */
		/* 820F31A8h case   24:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R7,regs.R6);
		/* 820F31A8h case   24:*/		return 0x820F31AC;
		  /* 820F31ACh */ case   25:  		/* addic R7, R7, -1 */
		/* 820F31ACh case   25:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 820F31ACh case   25:*/		return 0x820F31B0;
		  /* 820F31B0h */ case   26:  		/* subfe R7, R7, R7 */
		/* 820F31B0h case   26:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R7,regs.R7);
		/* 820F31B0h case   26:*/		return 0x820F31B4;
		  /* 820F31B4h */ case   27:  		/* and R27, R7, R27 */
		/* 820F31B4h case   27:*/		cpu::op::and<0>(regs,&regs.R27,regs.R7,regs.R27);
		/* 820F31B4h case   27:*/		return 0x820F31B8;
		  /* 820F31B8h */ case   28:  		/* bc 16, CR0_LT, -32 */
		/* 820F31B8h case   28:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F3198;  }
		/* 820F31B8h case   28:*/		return 0x820F31BC;
		  /* 820F31BCh */ case   29:  		/* cmpwi CR6, R27, 0 */
		/* 820F31BCh case   29:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820F31BCh case   29:*/		return 0x820F31C0;
		  /* 820F31C0h */ case   30:  		/* bc 12, CR6_EQ, 52 */
		/* 820F31C0h case   30:*/		if ( regs.CR[6].eq ) { return 0x820F31F4;  }
		/* 820F31C0h case   30:*/		return 0x820F31C4;
	}
	return 0x820F31C4;
} // Block from 820F3148h-820F31C4h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820F31C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F31C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F31C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F31C4);
		  /* 820F31C4h */ case    0:  		/* li R8, 1 */
		/* 820F31C4h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F31C4h case    0:*/		return 0x820F31C8;
		  /* 820F31C8h */ case    1:  		/* li R7, 2 */
		/* 820F31C8h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 820F31C8h case    1:*/		return 0x820F31CC;
		  /* 820F31CCh */ case    2:  		/* li R6, 0 */
		/* 820F31CCh case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F31CCh case    2:*/		return 0x820F31D0;
		  /* 820F31D0h */ case    3:  		/* oris R4, R11, 8256 */
		/* 820F31D0h case    3:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R11,0x2040);
		/* 820F31D0h case    3:*/		return 0x820F31D4;
		  /* 820F31D4h */ case    4:  		/* mr R3, R29 */
		/* 820F31D4h case    4:*/		regs.R3 = regs.R29;
		/* 820F31D4h case    4:*/		return 0x820F31D8;
		  /* 820F31D8h */ case    5:  		/* bl -28080 */
		/* 820F31D8h case    5:*/		regs.LR = 0x820F31DC; return 0x820EC428;
		/* 820F31D8h case    5:*/		return 0x820F31DC;
		  /* 820F31DCh */ case    6:  		/* lis R11, -32256 */
		/* 820F31DCh case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820F31DCh case    6:*/		return 0x820F31E0;
		  /* 820F31E0h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 820F31E0h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820F31E0h case    7:*/		return 0x820F31E4;
		  /* 820F31E4h */ case    8:  		/* lfs FR0, <#[R11 + 8792]> */
		/* 820F31E4h case    8:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00002258) );
		/* 820F31E4h case    8:*/		return 0x820F31E8;
		  /* 820F31E8h */ case    9:  		/* bc 12, CR0_EQ, 380 */
		/* 820F31E8h case    9:*/		if ( regs.CR[0].eq ) { return 0x820F3364;  }
		/* 820F31E8h case    9:*/		return 0x820F31EC;
		  /* 820F31ECh */ case   10:  		/* mr R26, R3 */
		/* 820F31ECh case   10:*/		regs.R26 = regs.R3;
		/* 820F31ECh case   10:*/		return 0x820F31F0;
		  /* 820F31F0h */ case   11:  		/* b 16 */
		/* 820F31F0h case   11:*/		return 0x820F3200;
		/* 820F31F0h case   11:*/		return 0x820F31F4;
	}
	return 0x820F31F4;
} // Block from 820F31C4h-820F31F4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F31F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F31F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F31F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F31F4);
		  /* 820F31F4h */ case    0:  		/* lis R11, -32254 */
		/* 820F31F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F31F4h case    0:*/		return 0x820F31F8;
		  /* 820F31F8h */ case    1:  		/* mr R3, R5 */
		/* 820F31F8h case    1:*/		regs.R3 = regs.R5;
		/* 820F31F8h case    1:*/		return 0x820F31FC;
		  /* 820F31FCh */ case    2:  		/* lfs FR0, <#[R11 - 16100]> */
		/* 820F31FCh case    2:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFC11C) );
		/* 820F31FCh case    2:*/		return 0x820F3200;
	}
	return 0x820F3200;
} // Block from 820F31F4h-820F3200h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F3200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3200);
		  /* 820F3200h */ case    0:  		/* lwz R10, <#[R3]> */
		/* 820F3200h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820F3200h case    0:*/		return 0x820F3204;
		  /* 820F3204h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 820F3204h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820F3204h case    1:*/		return 0x820F3208;
		  /* 820F3208h */ case    2:  		/* rlwinm R31, R10, 0, 12, 31 */
		/* 820F3208h case    2:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R31,regs.R10);
		/* 820F3208h case    2:*/		return 0x820F320C;
		  /* 820F320Ch */ case    3:  		/* lwz R8, <#[R29 + 20]> */
		/* 820F320Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000014) );
		/* 820F320Ch case    3:*/		return 0x820F3210;
		  /* 820F3210h */ case    4:  		/* lwz R9, <#[R29 + 16]> */
		/* 820F3210h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000010) );
		/* 820F3210h case    4:*/		return 0x820F3214;
		  /* 820F3214h */ case    5:  		/* rlwinm R30, R31, 2, 0, 29 */
		/* 820F3214h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R31);
		/* 820F3214h case    5:*/		return 0x820F3218;
		  /* 820F3218h */ case    6:  		/* add R10, R30, R11 */
		/* 820F3218h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R30,regs.R11);
		/* 820F3218h case    6:*/		return 0x820F321C;
		  /* 820F321Ch */ case    7:  		/* lwzx R7, <#[R30 + R11]> */
		/* 820F321Ch case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820F321Ch case    7:*/		return 0x820F3220;
		  /* 820F3220h */ case    8:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820F3220h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820F3220h case    8:*/		return 0x820F3224;
		  /* 820F3224h */ case    9:  		/* lwzx R7, <#[R7 + R8]> */
		/* 820F3224h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 820F3224h case    9:*/		return 0x820F3228;
		  /* 820F3228h */ case   10:  		/* lwz R7, <#[R7 + 4]> */
		/* 820F3228h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 820F3228h case   10:*/		return 0x820F322C;
		  /* 820F322Ch */ case   11:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820F322Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820F322Ch case   11:*/		return 0x820F3230;
		  /* 820F3230h */ case   12:  		/* lwzx R7, <#[R7 + R9]> */
		/* 820F3230h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 820F3230h case   12:*/		return 0x820F3234;
		  /* 820F3234h */ case   13:  		/* lwz R7, <#[R7 + 4]> */
		/* 820F3234h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 820F3234h case   13:*/		return 0x820F3238;
		  /* 820F3238h */ case   14:  		/* rlwinm. R7, R7, 0, 23, 23 */
		/* 820F3238h case   14:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R7,regs.R7);
		/* 820F3238h case   14:*/		return 0x820F323C;
		  /* 820F323Ch */ case   15:  		/* bc 12, CR0_EQ, 16 */
		/* 820F323Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x820F324C;  }
		/* 820F323Ch case   15:*/		return 0x820F3240;
		  /* 820F3240h */ case   16:  		/* mr R28, R11 */
		/* 820F3240h case   16:*/		regs.R28 = regs.R11;
		/* 820F3240h case   16:*/		return 0x820F3244;
		  /* 820F3244h */ case   17:  		/* mr R11, R10 */
		/* 820F3244h case   17:*/		regs.R11 = regs.R10;
		/* 820F3244h case   17:*/		return 0x820F3248;
		  /* 820F3248h */ case   18:  		/* b 44 */
		/* 820F3248h case   18:*/		return 0x820F3274;
		/* 820F3248h case   18:*/		return 0x820F324C;
	}
	return 0x820F324C;
} // Block from 820F3200h-820F324Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F324Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F324C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F324C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F324C);
		  /* 820F324Ch */ case    0:  		/* lwz R7, <#[R11]> */
		/* 820F324Ch case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820F324Ch case    0:*/		return 0x820F3250;
		  /* 820F3250h */ case    1:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820F3250h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820F3250h case    1:*/		return 0x820F3254;
		  /* 820F3254h */ case    2:  		/* lwzx R7, <#[R7 + R8]> */
		/* 820F3254h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 820F3254h case    2:*/		return 0x820F3258;
		  /* 820F3258h */ case    3:  		/* lwz R7, <#[R7 + 4]> */
		/* 820F3258h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 820F3258h case    3:*/		return 0x820F325C;
		  /* 820F325Ch */ case    4:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820F325Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820F325Ch case    4:*/		return 0x820F3260;
		  /* 820F3260h */ case    5:  		/* lwzx R9, <#[R7 + R9]> */
		/* 820F3260h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 820F3260h case    5:*/		return 0x820F3264;
		  /* 820F3264h */ case    6:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F3264h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F3264h case    6:*/		return 0x820F3268;
		  /* 820F3268h */ case    7:  		/* rlwinm. R9, R9, 0, 23, 23 */
		/* 820F3268h case    7:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R9);
		/* 820F3268h case    7:*/		return 0x820F326C;
		  /* 820F326Ch */ case    8:  		/* bc 12, CR0_EQ, 248 */
		/* 820F326Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x820F3364;  }
		/* 820F326Ch case    8:*/		return 0x820F3270;
		  /* 820F3270h */ case    9:  		/* mr R28, R10 */
		/* 820F3270h case    9:*/		regs.R28 = regs.R10;
		/* 820F3270h case    9:*/		return 0x820F3274;
	}
	return 0x820F3274;
} // Block from 820F324Ch-820F3274h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F3274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3274);
		  /* 820F3274h */ case    0:  		/* mr R9, R25 */
		/* 820F3274h case    0:*/		regs.R9 = regs.R25;
		/* 820F3274h case    0:*/		return 0x820F3278;
		  /* 820F3278h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820F3278h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820F3278h case    1:*/		return 0x820F327C;
		  /* 820F327Ch */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 820F327Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820F32A8;  }
		/* 820F327Ch case    2:*/		return 0x820F3280;
		  /* 820F3280h */ case    3:  		/* lwz R10, <#[R11]> */
		/* 820F3280h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F3280h case    3:*/		return 0x820F3284;
		  /* 820F3284h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F3284h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F3284h case    4:*/		return 0x820F3288;
		  /* 820F3288h */ case    5:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820F3288h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820F3288h case    5:*/		return 0x820F328C;
		  /* 820F328Ch */ case    6:  		/* lfd FR13, <#[R10 + 32]> */
		/* 820F328Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000020) );
		/* 820F328Ch case    6:*/		return 0x820F3290;
		  /* 820F3290h */ case    7:  		/* fcmpu CR6, FR13, FR0 */
		/* 820F3290h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820F3290h case    7:*/		return 0x820F3294;
		  /* 820F3294h */ case    8:  		/* bc 4, CR6_EQ, 208 */
		/* 820F3294h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820F3364;  }
		/* 820F3294h case    8:*/		return 0x820F3298;
		  /* 820F3298h */ case    9:  		/* addi R9, R9, 1 */
		/* 820F3298h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F3298h case    9:*/		return 0x820F329C;
		  /* 820F329Ch */ case   10:  		/* addi R11, R11, 4 */
		/* 820F329Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F329Ch case   10:*/		return 0x820F32A0;
		  /* 820F32A0h */ case   11:  		/* cmplw CR6, R9, R31 */
		/* 820F32A0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 820F32A0h case   11:*/		return 0x820F32A4;
		  /* 820F32A4h */ case   12:  		/* bc 12, CR6_LT, -36 */
		/* 820F32A4h case   12:*/		if ( regs.CR[6].lt ) { return 0x820F3280;  }
		/* 820F32A4h case   12:*/		return 0x820F32A8;
	}
	return 0x820F32A8;
} // Block from 820F3274h-820F32A8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820F32A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F32A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F32A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F32A8);
		  /* 820F32A8h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 820F32A8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820F32A8h case    0:*/		return 0x820F32AC;
		  /* 820F32ACh */ case    1:  		/* bc 4, CR6_EQ, 132 */
		/* 820F32ACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F3330;  }
		/* 820F32ACh case    1:*/		return 0x820F32B0;
		  /* 820F32B0h */ case    2:  		/* lwz R5, <#[R29 + 260]> */
		/* 820F32B0h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x00000104) );
		/* 820F32B0h case    2:*/		return 0x820F32B4;
		  /* 820F32B4h */ case    3:  		/* li R11, 129 */
		/* 820F32B4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x81);
		/* 820F32B4h case    3:*/		return 0x820F32B8;
		  /* 820F32B8h */ case    4:  		/* li R8, 2 */
		/* 820F32B8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 820F32B8h case    4:*/		return 0x820F32BC;
		  /* 820F32BCh */ case    5:  		/* li R7, 2 */
		/* 820F32BCh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 820F32BCh case    5:*/		return 0x820F32C0;
		  /* 820F32C0h */ case    6:  		/* li R6, 0 */
		/* 820F32C0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820F32C0h case    6:*/		return 0x820F32C4;
		  /* 820F32C4h */ case    7:  		/* mr R3, R29 */
		/* 820F32C4h case    7:*/		regs.R3 = regs.R29;
		/* 820F32C4h case    7:*/		return 0x820F32C8;
		  /* 820F32C8h */ case    8:  		/* lwz R4, <#[R5]> */
		/* 820F32C8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x00000000) );
		/* 820F32C8h case    8:*/		return 0x820F32CC;
		  /* 820F32CCh */ case    9:  		/* rlwimi R4, R11, 22, 0, 11 */
		/* 820F32CCh case    9:*/		cpu::op::rlwimi<0,22,0,11>(regs,&regs.R4,regs.R11);
		/* 820F32CCh case    9:*/		return 0x820F32D0;
		  /* 820F32D0h */ case   10:  		/* bl -28328 */
		/* 820F32D0h case   10:*/		regs.LR = 0x820F32D4; return 0x820EC428;
		/* 820F32D0h case   10:*/		return 0x820F32D4;
		  /* 820F32D4h */ case   11:  		/* or. R8, R3, R3 */
		/* 820F32D4h case   11:*/		cpu::op::or<1>(regs,&regs.R8,regs.R3,regs.R3);
		/* 820F32D4h case   11:*/		return 0x820F32D8;
		  /* 820F32D8h */ case   12:  		/* bc 12, CR0_EQ, 140 */
		/* 820F32D8h case   12:*/		if ( regs.CR[0].eq ) { return 0x820F3364;  }
		/* 820F32D8h case   12:*/		return 0x820F32DC;
		  /* 820F32DCh */ case   13:  		/* li R7, 1 */
		/* 820F32DCh case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820F32DCh case   13:*/		return 0x820F32E0;
		  /* 820F32E0h */ case   14:  		/* cmplwi CR6, R31, 0 */
		/* 820F32E0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820F32E0h case   14:*/		return 0x820F32E4;
		  /* 820F32E4h */ case   15:  		/* bc 12, CR6_EQ, 64 */
		/* 820F32E4h case   15:*/		if ( regs.CR[6].eq ) { return 0x820F3324;  }
		/* 820F32E4h case   15:*/		return 0x820F32E8;
		  /* 820F32E8h */ case   16:  		/* lwz R9, <#[R8 + 8]> */
		/* 820F32E8h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000008) );
		/* 820F32E8h case   16:*/		return 0x820F32EC;
		  /* 820F32ECh */ case   17:  		/* mr R11, R25 */
		/* 820F32ECh case   17:*/		regs.R11 = regs.R25;
		/* 820F32ECh case   17:*/		return 0x820F32F0;
		  /* 820F32F0h */ case   18:  		/* mtspr CTR, R31 */
		/* 820F32F0h case   18:*/		regs.CTR = regs.R31;
		/* 820F32F0h case   18:*/		return 0x820F32F4;
		  /* 820F32F4h */ case   19:  		/* mr R10, R30 */
		/* 820F32F4h case   19:*/		regs.R10 = regs.R30;
		/* 820F32F4h case   19:*/		return 0x820F32F8;
		  /* 820F32F8h */ case   20:  		/* lwzx R6, <#[R11 + R9]> */
		/* 820F32F8h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F32F8h case   20:*/		return 0x820F32FC;
		  /* 820F32FCh */ case   21:  		/* addi R11, R11, 4 */
		/* 820F32FCh case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F32FCh case   21:*/		return 0x820F3300;
		  /* 820F3300h */ case   22:  		/* lwzx R5, <#[R10 + R9]> */
		/* 820F3300h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F3300h case   22:*/		return 0x820F3304;
		  /* 820F3304h */ case   23:  		/* addi R10, R10, 4 */
		/* 820F3304h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F3304h case   23:*/		return 0x820F3308;
		  /* 820F3308h */ case   24:  		/* subf R6, R6, R5 */
		/* 820F3308h case   24:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 820F3308h case   24:*/		return 0x820F330C;
		  /* 820F330Ch */ case   25:  		/* addic R6, R6, -1 */
		/* 820F330Ch case   25:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 820F330Ch case   25:*/		return 0x820F3310;
		  /* 820F3310h */ case   26:  		/* subfe R6, R6, R6 */
		/* 820F3310h case   26:*/		cpu::op::subfe<0>(regs,&regs.R6,regs.R6,regs.R6);
		/* 820F3310h case   26:*/		return 0x820F3314;
		  /* 820F3314h */ case   27:  		/* and R7, R6, R7 */
		/* 820F3314h case   27:*/		cpu::op::and<0>(regs,&regs.R7,regs.R6,regs.R7);
		/* 820F3314h case   27:*/		return 0x820F3318;
		  /* 820F3318h */ case   28:  		/* bc 16, CR0_LT, -32 */
		/* 820F3318h case   28:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F32F8;  }
		/* 820F3318h case   28:*/		return 0x820F331C;
		  /* 820F331Ch */ case   29:  		/* cmpwi CR6, R7, 0 */
		/* 820F331Ch case   29:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 820F331Ch case   29:*/		return 0x820F3320;
		  /* 820F3320h */ case   30:  		/* bc 12, CR6_EQ, 68 */
		/* 820F3320h case   30:*/		if ( regs.CR[6].eq ) { return 0x820F3364;  }
		/* 820F3320h case   30:*/		return 0x820F3324;
	}
	return 0x820F3324;
} // Block from 820F32A8h-820F3324h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820F3324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3324);
		  /* 820F3324h */ case    0:  		/* mr R6, R28 */
		/* 820F3324h case    0:*/		regs.R6 = regs.R28;
		/* 820F3324h case    0:*/		return 0x820F3328;
		  /* 820F3328h */ case    1:  		/* mr R26, R8 */
		/* 820F3328h case    1:*/		regs.R26 = regs.R8;
		/* 820F3328h case    1:*/		return 0x820F332C;
		  /* 820F332Ch */ case    2:  		/* b 16 */
		/* 820F332Ch case    2:*/		return 0x820F333C;
		/* 820F332Ch case    2:*/		return 0x820F3330;
	}
	return 0x820F3330;
} // Block from 820F3324h-820F3330h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F3330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3330);
		  /* 820F3330h */ case    0:  		/* lwz R11, <#[R29 + 260]> */
		/* 820F3330h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000104) );
		/* 820F3330h case    0:*/		return 0x820F3334;
		  /* 820F3334h */ case    1:  		/* mr R8, R26 */
		/* 820F3334h case    1:*/		regs.R8 = regs.R26;
		/* 820F3334h case    1:*/		return 0x820F3338;
		  /* 820F3338h */ case    2:  		/* lwz R6, <#[R11 + 8]> */
		/* 820F3338h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 820F3338h case    2:*/		return 0x820F333C;
	}
	return 0x820F333C;
} // Block from 820F3330h-820F333Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F333Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F333C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F333C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F333C);
		  /* 820F333Ch */ case    0:  		/* li R9, 0 */
		/* 820F333Ch case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820F333Ch case    0:*/		return 0x820F3340;
		  /* 820F3340h */ case    1:  		/* lis R7, 6 */
		/* 820F3340h case    1:*/		cpu::op::lis<0>(regs,&regs.R7,0x6);
		/* 820F3340h case    1:*/		return 0x820F3344;
		  /* 820F3344h */ case    2:  		/* li R5, 0 */
		/* 820F3344h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F3344h case    2:*/		return 0x820F3348;
		  /* 820F3348h */ case    3:  		/* lis R4, 6 */
		/* 820F3348h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x6);
		/* 820F3348h case    3:*/		return 0x820F334C;
		  /* 820F334Ch */ case    4:  		/* mr R3, R29 */
		/* 820F334Ch case    4:*/		regs.R3 = regs.R29;
		/* 820F334Ch case    4:*/		return 0x820F3350;
		  /* 820F3350h */ case    5:  		/* bl -4568 */
		/* 820F3350h case    5:*/		regs.LR = 0x820F3354; return 0x820F2178;
		/* 820F3350h case    5:*/		return 0x820F3354;
		  /* 820F3354h */ case    6:  		/* cmpwi CR6, R3, 0 */
		/* 820F3354h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820F3354h case    6:*/		return 0x820F3358;
		  /* 820F3358h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 820F3358h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820F3368;  }
		/* 820F3358h case    7:*/		return 0x820F335C;
		  /* 820F335Ch */ case    8:  		/* stw R25, <#[R26]> */
		/* 820F335Ch case    8:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R26 + 0x00000000) );
		/* 820F335Ch case    8:*/		return 0x820F3360;
		  /* 820F3360h */ case    9:  		/* b 8 */
		/* 820F3360h case    9:*/		return 0x820F3368;
		/* 820F3360h case    9:*/		return 0x820F3364;
	}
	return 0x820F3364;
} // Block from 820F333Ch-820F3364h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F3364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3364);
		  /* 820F3364h */ case    0:  		/* li R3, 1 */
		/* 820F3364h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820F3364h case    0:*/		return 0x820F3368;
	}
	return 0x820F3368;
} // Block from 820F3364h-820F3368h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F3368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3368);
		  /* 820F3368h */ case    0:  		/* addi R1, R1, 144 */
		/* 820F3368h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820F3368h case    0:*/		return 0x820F336C;
		  /* 820F336Ch */ case    1:  		/* b -401616 */
		/* 820F336Ch case    1:*/		return 0x8209129C;
		/* 820F336Ch case    1:*/		return 0x820F3370;
	}
	return 0x820F3370;
} // Block from 820F3368h-820F3370h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F3370h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3370);
		  /* 820F3370h */ case    0:  		/* mfspr R12, LR */
		/* 820F3370h case    0:*/		regs.R12 = regs.LR;
		/* 820F3370h case    0:*/		return 0x820F3374;
		  /* 820F3374h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820F3374h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F3374h case    1:*/		return 0x820F3378;
		  /* 820F3378h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820F3378h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F3378h case    2:*/		return 0x820F337C;
		  /* 820F337Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820F337Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F337Ch case    3:*/		return 0x820F3380;
		  /* 820F3380h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820F3380h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820F3380h case    4:*/		return 0x820F3384;
		  /* 820F3384h */ case    5:  		/* mr R30, R4 */
		/* 820F3384h case    5:*/		regs.R30 = regs.R4;
		/* 820F3384h case    5:*/		return 0x820F3388;
		  /* 820F3388h */ case    6:  		/* li R4, 1 */
		/* 820F3388h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820F3388h case    6:*/		return 0x820F338C;
		  /* 820F338Ch */ case    7:  		/* mr R31, R3 */
		/* 820F338Ch case    7:*/		regs.R31 = regs.R3;
		/* 820F338Ch case    7:*/		return 0x820F3390;
		  /* 820F3390h */ case    8:  		/* bl -6656 */
		/* 820F3390h case    8:*/		regs.LR = 0x820F3394; return 0x820F1990;
		/* 820F3390h case    8:*/		return 0x820F3394;
		  /* 820F3394h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820F3394h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F3394h case    9:*/		return 0x820F3398;
		  /* 820F3398h */ case   10:  		/* bc 12, CR0_LT, 36 */
		/* 820F3398h case   10:*/		if ( regs.CR[0].lt ) { return 0x820F33BC;  }
		/* 820F3398h case   10:*/		return 0x820F339C;
		  /* 820F339Ch */ case   11:  		/* lwz R11, <#[R31 + 276]> */
		/* 820F339Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820F339Ch case   11:*/		return 0x820F33A0;
		  /* 820F33A0h */ case   12:  		/* li R3, 0 */
		/* 820F33A0h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F33A0h case   12:*/		return 0x820F33A4;
		  /* 820F33A4h */ case   13:  		/* lwz R10, <#[R31 + 272]> */
		/* 820F33A4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000110) );
		/* 820F33A4h case   13:*/		return 0x820F33A8;
		  /* 820F33A8h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F33A8h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F33A8h case   14:*/		return 0x820F33AC;
		  /* 820F33ACh */ case   15:  		/* stwx R30, <#[R11 + R10]> */
		/* 820F33ACh case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F33ACh case   15:*/		return 0x820F33B0;
		  /* 820F33B0h */ case   16:  		/* lwz R11, <#[R31 + 276]> */
		/* 820F33B0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820F33B0h case   16:*/		return 0x820F33B4;
		  /* 820F33B4h */ case   17:  		/* addi R11, R11, 1 */
		/* 820F33B4h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F33B4h case   17:*/		return 0x820F33B8;
		  /* 820F33B8h */ case   18:  		/* stw R11, <#[R31 + 276]> */
		/* 820F33B8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820F33B8h case   18:*/		return 0x820F33BC;
	}
	return 0x820F33BC;
} // Block from 820F3370h-820F33BCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820F33BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F33BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F33BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F33BC);
		  /* 820F33BCh */ case    0:  		/* addi R1, R1, 112 */
		/* 820F33BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820F33BCh case    0:*/		return 0x820F33C0;
		  /* 820F33C0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820F33C0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820F33C0h case    1:*/		return 0x820F33C4;
		  /* 820F33C4h */ case    2:  		/* mtspr LR, R12 */
		/* 820F33C4h case    2:*/		regs.LR = regs.R12;
		/* 820F33C4h case    2:*/		return 0x820F33C8;
		  /* 820F33C8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820F33C8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820F33C8h case    3:*/		return 0x820F33CC;
		  /* 820F33CCh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820F33CCh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820F33CCh case    4:*/		return 0x820F33D0;
		  /* 820F33D0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820F33D0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820F33D0h case    5:*/		return 0x820F33D4;
	}
	return 0x820F33D4;
} // Block from 820F33BCh-820F33D4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F33D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F33D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F33D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F33D4);
		  /* 820F33D4h */ case    0:  		/* nop */
		/* 820F33D4h case    0:*/		cpu::op::nop();
		/* 820F33D4h case    0:*/		return 0x820F33D8;
	}
	return 0x820F33D8;
} // Block from 820F33D4h-820F33D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F33D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F33D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F33D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F33D8);
		  /* 820F33D8h */ case    0:  		/* mfspr R12, LR */
		/* 820F33D8h case    0:*/		regs.R12 = regs.LR;
		/* 820F33D8h case    0:*/		return 0x820F33DC;
		  /* 820F33DCh */ case    1:  		/* bl -401796 */
		/* 820F33DCh case    1:*/		regs.LR = 0x820F33E0; return 0x82091258;
		/* 820F33DCh case    1:*/		return 0x820F33E0;
		  /* 820F33E0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820F33E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820F33E0h case    2:*/		return 0x820F33E4;
		  /* 820F33E4h */ case    3:  		/* li R28, 0 */
		/* 820F33E4h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820F33E4h case    3:*/		return 0x820F33E8;
		  /* 820F33E8h */ case    4:  		/* lis R4, 21317 */
		/* 820F33E8h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x5345);
		/* 820F33E8h case    4:*/		return 0x820F33EC;
		  /* 820F33ECh */ case    5:  		/* stw R28, <#[R1 + 80]> */
		/* 820F33ECh case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 820F33ECh case    5:*/		return 0x820F33F0;
		  /* 820F33F0h */ case    6:  		/* mr R31, R3 */
		/* 820F33F0h case    6:*/		regs.R31 = regs.R3;
		/* 820F33F0h case    6:*/		return 0x820F33F4;
		  /* 820F33F4h */ case    7:  		/* addi R3, R1, 96 */
		/* 820F33F4h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F33F4h case    7:*/		return 0x820F33F8;
		  /* 820F33F8h */ case    8:  		/* ori R4, R4, 21072 */
		/* 820F33F8h case    8:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x5250);
		/* 820F33F8h case    8:*/		return 0x820F33FC;
		  /* 820F33FCh */ case    9:  		/* bl -152124 */
		/* 820F33FCh case    9:*/		regs.LR = 0x820F3400; return 0x820CE1C0;
		/* 820F33FCh case    9:*/		return 0x820F3400;
		  /* 820F3400h */ case   10:  		/* mr R3, R31 */
		/* 820F3400h case   10:*/		regs.R3 = regs.R31;
		/* 820F3400h case   10:*/		return 0x820F3404;
		  /* 820F3404h */ case   11:  		/* bl 114844 */
		/* 820F3404h case   11:*/		regs.LR = 0x820F3408; return 0x8210F4A0;
		/* 820F3404h case   11:*/		return 0x820F3408;
		  /* 820F3408h */ case   12:  		/* or. R30, R3, R3 */
		/* 820F3408h case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F3408h case   12:*/		return 0x820F340C;
		  /* 820F340Ch */ case   13:  		/* bc 12, CR0_LT, 296 */
		/* 820F340Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x820F3534;  }
		/* 820F340Ch case   13:*/		return 0x820F3410;
		  /* 820F3410h */ case   14:  		/* lwz R3, <#[R31 + 228]> */
		/* 820F3410h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000E4) );
		/* 820F3410h case   14:*/		return 0x820F3414;
		  /* 820F3414h */ case   15:  		/* addi R4, R1, 80 */
		/* 820F3414h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F3414h case   15:*/		return 0x820F3418;
		  /* 820F3418h */ case   16:  		/* lwz R11, <#[R3]> */
		/* 820F3418h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F3418h case   16:*/		return 0x820F341C;
		  /* 820F341Ch */ case   17:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F341Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F341Ch case   17:*/		return 0x820F3420;
		  /* 820F3420h */ case   18:  		/* mtspr CTR, R11 */
		/* 820F3420h case   18:*/		regs.CTR = regs.R11;
		/* 820F3420h case   18:*/		return 0x820F3424;
		  /* 820F3424h */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 820F3424h case   19:*/		if ( 1 ) { regs.LR = 0x820F3428; return (uint32)regs.CTR; }
		/* 820F3424h case   19:*/		return 0x820F3428;
		  /* 820F3428h */ case   20:  		/* or. R30, R3, R3 */
		/* 820F3428h case   20:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F3428h case   20:*/		return 0x820F342C;
		  /* 820F342Ch */ case   21:  		/* bc 12, CR0_LT, 264 */
		/* 820F342Ch case   21:*/		if ( regs.CR[0].lt ) { return 0x820F3534;  }
		/* 820F342Ch case   21:*/		return 0x820F3430;
		  /* 820F3430h */ case   22:  		/* cmpwi CR6, R30, 0 */
		/* 820F3430h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820F3430h case   22:*/		return 0x820F3434;
		  /* 820F3434h */ case   23:  		/* bc 4, CR6_EQ, 88 */
		/* 820F3434h case   23:*/		if ( !regs.CR[6].eq ) { return 0x820F348C;  }
		/* 820F3434h case   23:*/		return 0x820F3438;
		  /* 820F3438h */ case   24:  		/* lwz R3, <#[R1 + 80]> */
		/* 820F3438h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820F3438h case   24:*/		return 0x820F343C;
		  /* 820F343Ch */ case   25:  		/* lwz R11, <#[R3]> */
		/* 820F343Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F343Ch case   25:*/		return 0x820F3440;
		  /* 820F3440h */ case   26:  		/* lwz R11, <#[R11 + 16]> */
		/* 820F3440h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820F3440h case   26:*/		return 0x820F3444;
		  /* 820F3444h */ case   27:  		/* mtspr CTR, R11 */
		/* 820F3444h case   27:*/		regs.CTR = regs.R11;
		/* 820F3444h case   27:*/		return 0x820F3448;
		  /* 820F3448h */ case   28:  		/* bcctrl 20, CR0_LT */
		/* 820F3448h case   28:*/		if ( 1 ) { regs.LR = 0x820F344C; return (uint32)regs.CTR; }
		/* 820F3448h case   28:*/		return 0x820F344C;
		  /* 820F344Ch */ case   29:  		/* lwz R11, <#[R1 + 80]> */
		/* 820F344Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820F344Ch case   29:*/		return 0x820F3450;
		  /* 820F3450h */ case   30:  		/* mr R30, R3 */
		/* 820F3450h case   30:*/		regs.R30 = regs.R3;
		/* 820F3450h case   30:*/		return 0x820F3454;
		  /* 820F3454h */ case   31:  		/* mr R3, R11 */
		/* 820F3454h case   31:*/		regs.R3 = regs.R11;
		/* 820F3454h case   31:*/		return 0x820F3458;
		  /* 820F3458h */ case   32:  		/* lwz R10, <#[R11]> */
		/* 820F3458h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F3458h case   32:*/		return 0x820F345C;
		  /* 820F345Ch */ case   33:  		/* lwz R11, <#[R10 + 12]> */
		/* 820F345Ch case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F345Ch case   33:*/		return 0x820F3460;
		  /* 820F3460h */ case   34:  		/* mtspr CTR, R11 */
		/* 820F3460h case   34:*/		regs.CTR = regs.R11;
		/* 820F3460h case   34:*/		return 0x820F3464;
		  /* 820F3464h */ case   35:  		/* bcctrl 20, CR0_LT */
		/* 820F3464h case   35:*/		if ( 1 ) { regs.LR = 0x820F3468; return (uint32)regs.CTR; }
		/* 820F3464h case   35:*/		return 0x820F3468;
		  /* 820F3468h */ case   36:  		/* mr R4, R3 */
		/* 820F3468h case   36:*/		regs.R4 = regs.R3;
		/* 820F3468h case   36:*/		return 0x820F346C;
		  /* 820F346Ch */ case   37:  		/* addi R3, R1, 96 */
		/* 820F346Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F346Ch case   37:*/		return 0x820F3470;
		  /* 820F3470h */ case   38:  		/* mr R5, R30 */
		/* 820F3470h case   38:*/		regs.R5 = regs.R30;
		/* 820F3470h case   38:*/		return 0x820F3474;
		  /* 820F3474h */ case   39:  		/* li R6, 1 */
		/* 820F3474h case   39:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F3474h case   39:*/		return 0x820F3478;
		  /* 820F3478h */ case   40:  		/* li R7, 0 */
		/* 820F3478h case   40:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F3478h case   40:*/		return 0x820F347C;
		  /* 820F347Ch */ case   41:  		/* li R8, 0 */
		/* 820F347Ch case   41:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F347Ch case   41:*/		return 0x820F3480;
	}
	return 0x820F3480;
} // Block from 820F33D8h-820F3480h (42 instructions)

//////////////////////////////////////////////////////
// Block at 820F3480h
// Function '?MatchX2Modifier@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3480);
		  /* 820F3480h */ case    0:  		/* bl -152080 */
		/* 820F3480h case    0:*/		regs.LR = 0x820F3484; return 0x820CE270;
		/* 820F3480h case    0:*/		return 0x820F3484;
		  /* 820F3484h */ case    1:  		/* or. R30, R3, R3 */
		/* 820F3484h case    1:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F3484h case    1:*/		return 0x820F3488;
		  /* 820F3488h */ case    2:  		/* bc 12, CR0_LT, 172 */
		/* 820F3488h case    2:*/		if ( regs.CR[0].lt ) { return 0x820F3534;  }
		/* 820F3488h case    2:*/		return 0x820F348C;
	}
	return 0x820F348C;
} // Block from 820F3480h-820F348Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F348Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F348C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F348C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F348C);
		  /* 820F348Ch */ case    0:  		/* addi R3, R1, 96 */
		/* 820F348Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F348Ch case    0:*/		return 0x820F3490;
		  /* 820F3490h */ case    1:  		/* bl -152240 */
		/* 820F3490h case    1:*/		regs.LR = 0x820F3494; return 0x820CE1E0;
		/* 820F3490h case    1:*/		return 0x820F3494;
		  /* 820F3494h */ case    2:  		/* mr R29, R3 */
		/* 820F3494h case    2:*/		regs.R29 = regs.R3;
		/* 820F3494h case    2:*/		return 0x820F3498;
		  /* 820F3498h */ case    3:  		/* cmplwi CR6, R3, 32768 */
		/* 820F3498h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00008000);
		/* 820F3498h case    3:*/		return 0x820F349C;
		  /* 820F349Ch */ case    4:  		/* mr R3, R31 */
		/* 820F349Ch case    4:*/		regs.R3 = regs.R31;
		/* 820F349Ch case    4:*/		return 0x820F34A0;
		  /* 820F34A0h */ case    5:  		/* bc 12, CR6_GT, 120 */
		/* 820F34A0h case    5:*/		if ( regs.CR[6].gt ) { return 0x820F3518;  }
		/* 820F34A0h case    5:*/		return 0x820F34A4;
		  /* 820F34A4h */ case    6:  		/* mr R4, R29 */
		/* 820F34A4h case    6:*/		regs.R4 = regs.R29;
		/* 820F34A4h case    6:*/		return 0x820F34A8;
		  /* 820F34A8h */ case    7:  		/* bl -6936 */
		/* 820F34A8h case    7:*/		regs.LR = 0x820F34AC; return 0x820F1990;
		/* 820F34A8h case    7:*/		return 0x820F34AC;
		  /* 820F34ACh */ case    8:  		/* or. R30, R3, R3 */
		/* 820F34ACh case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F34ACh case    8:*/		return 0x820F34B0;
		  /* 820F34B0h */ case    9:  		/* bc 12, CR0_LT, 132 */
		/* 820F34B0h case    9:*/		if ( regs.CR[0].lt ) { return 0x820F3534;  }
		/* 820F34B0h case    9:*/		return 0x820F34B4;
		  /* 820F34B4h */ case   10:  		/* lwz R9, <#[R31 + 276]> */
		/* 820F34B4h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000114) );
		/* 820F34B4h case   10:*/		return 0x820F34B8;
		  /* 820F34B8h */ case   11:  		/* addi R10, R29, 1 */
		/* 820F34B8h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x1);
		/* 820F34B8h case   11:*/		return 0x820F34BC;
		  /* 820F34BCh */ case   12:  		/* lwz R11, <#[R31 + 272]> */
		/* 820F34BCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000110) );
		/* 820F34BCh case   12:*/		return 0x820F34C0;
		  /* 820F34C0h */ case   13:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F34C0h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F34C0h case   13:*/		return 0x820F34C4;
		  /* 820F34C4h */ case   14:  		/* addi R9, R9, -1 */
		/* 820F34C4h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 820F34C4h case   14:*/		return 0x820F34C8;
		  /* 820F34C8h */ case   15:  		/* addi R4, R11, 4 */
		/* 820F34C8h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 820F34C8h case   15:*/		return 0x820F34CC;
		  /* 820F34CCh */ case   16:  		/* add R3, R10, R11 */
		/* 820F34CCh case   16:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 820F34CCh case   16:*/		return 0x820F34D0;
		  /* 820F34D0h */ case   17:  		/* rlwinm R5, R9, 2, 0, 29 */
		/* 820F34D0h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R9);
		/* 820F34D0h case   17:*/		return 0x820F34D4;
		  /* 820F34D4h */ case   18:  		/* bl -398772 */
		/* 820F34D4h case   18:*/		regs.LR = 0x820F34D8; return 0x82091F20;
		/* 820F34D4h case   18:*/		return 0x820F34D8;
		  /* 820F34D8h */ case   19:  		/* lwz R11, <#[R31 + 272]> */
		/* 820F34D8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000110) );
		/* 820F34D8h case   19:*/		return 0x820F34DC;
		  /* 820F34DCh */ case   20:  		/* mr R5, R29 */
		/* 820F34DCh case   20:*/		regs.R5 = regs.R29;
		/* 820F34DCh case   20:*/		return 0x820F34E0;
		  /* 820F34E0h */ case   21:  		/* addi R3, R1, 96 */
		/* 820F34E0h case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F34E0h case   21:*/		return 0x820F34E4;
		  /* 820F34E4h */ case   22:  		/* addi R4, R11, 4 */
		/* 820F34E4h case   22:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 820F34E4h case   22:*/		return 0x820F34E8;
		  /* 820F34E8h */ case   23:  		/* bl -151440 */
		/* 820F34E8h case   23:*/		regs.LR = 0x820F34EC; return 0x820CE558;
		/* 820F34E8h case   23:*/		return 0x820F34EC;
		  /* 820F34ECh */ case   24:  		/* or. R30, R3, R3 */
		/* 820F34ECh case   24:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F34ECh case   24:*/		return 0x820F34F0;
		  /* 820F34F0h */ case   25:  		/* bc 12, CR0_LT, 68 */
		/* 820F34F0h case   25:*/		if ( regs.CR[0].lt ) { return 0x820F3534;  }
		/* 820F34F0h case   25:*/		return 0x820F34F4;
		  /* 820F34F4h */ case   26:  		/* lwz R11, <#[R31 + 276]> */
		/* 820F34F4h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820F34F4h case   26:*/		return 0x820F34F8;
		  /* 820F34F8h */ case   27:  		/* mr R30, R28 */
		/* 820F34F8h case   27:*/		regs.R30 = regs.R28;
		/* 820F34F8h case   27:*/		return 0x820F34FC;
		  /* 820F34FCh */ case   28:  		/* lwz R10, <#[R31 + 292]> */
		/* 820F34FCh case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000124) );
		/* 820F34FCh case   28:*/		return 0x820F3500;
		  /* 820F3500h */ case   29:  		/* add R11, R11, R29 */
		/* 820F3500h case   29:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 820F3500h case   29:*/		return 0x820F3504;
		  /* 820F3504h */ case   30:  		/* add R10, R29, R10 */
		/* 820F3504h case   30:*/		cpu::op::add<0>(regs,&regs.R10,regs.R29,regs.R10);
		/* 820F3504h case   30:*/		return 0x820F3508;
		  /* 820F3508h */ case   31:  		/* stw R11, <#[R31 + 276]> */
		/* 820F3508h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 820F3508h case   31:*/		return 0x820F350C;
		  /* 820F350Ch */ case   32:  		/* stw R10, <#[R31 + 292]> */
		/* 820F350Ch case   32:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000124) );
		/* 820F350Ch case   32:*/		return 0x820F3510;
		  /* 820F3510h */ case   33:  		/* stw R11, <#[R31 + 288]> */
		/* 820F3510h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000120) );
		/* 820F3510h case   33:*/		return 0x820F3514;
		  /* 820F3514h */ case   34:  		/* b 32 */
		/* 820F3514h case   34:*/		return 0x820F3534;
		/* 820F3514h case   34:*/		return 0x820F3518;
	}
	return 0x820F3518;
} // Block from 820F348Ch-820F3518h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820F3518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3518);
		  /* 820F3518h */ case    0:  		/* lis R11, -32254 */
		/* 820F3518h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F3518h case    0:*/		return 0x820F351C;
		  /* 820F351Ch */ case    1:  		/* li R5, 4548 */
		/* 820F351Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x11C4);
		/* 820F351Ch case    1:*/		return 0x820F3520;
		  /* 820F3520h */ case    2:  		/* addi R6, R11, -16096 */
		/* 820F3520h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC120);
		/* 820F3520h case    2:*/		return 0x820F3524;
		  /* 820F3524h */ case    3:  		/* li R4, 0 */
		/* 820F3524h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F3524h case    3:*/		return 0x820F3528;
		  /* 820F3528h */ case    4:  		/* bl 111112 */
		/* 820F3528h case    4:*/		regs.LR = 0x820F352C; return 0x8210E730;
		/* 820F3528h case    4:*/		return 0x820F352C;
		  /* 820F352Ch */ case    5:  		/* lis R30, -32768 */
		/* 820F352Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8000);
		/* 820F352Ch case    5:*/		return 0x820F3530;
		  /* 820F3530h */ case    6:  		/* ori R30, R30, 16389 */
		/* 820F3530h case    6:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x4005);
		/* 820F3530h case    6:*/		return 0x820F3534;
	}
	return 0x820F3534;
} // Block from 820F3518h-820F3534h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F3534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3534);
		  /* 820F3534h */ case    0:  		/* lwz R3, <#[R1 + 80]> */
		/* 820F3534h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820F3534h case    0:*/		return 0x820F3538;
		  /* 820F3538h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820F3538h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820F3538h case    1:*/		return 0x820F353C;
		  /* 820F353Ch */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820F353Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820F3554;  }
		/* 820F353Ch case    2:*/		return 0x820F3540;
		  /* 820F3540h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820F3540h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F3540h case    3:*/		return 0x820F3544;
		  /* 820F3544h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F3544h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F3544h case    4:*/		return 0x820F3548;
		  /* 820F3548h */ case    5:  		/* mtspr CTR, R11 */
		/* 820F3548h case    5:*/		regs.CTR = regs.R11;
		/* 820F3548h case    5:*/		return 0x820F354C;
		  /* 820F354Ch */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820F354Ch case    6:*/		if ( 1 ) { regs.LR = 0x820F3550; return (uint32)regs.CTR; }
		/* 820F354Ch case    6:*/		return 0x820F3550;
		  /* 820F3550h */ case    7:  		/* stw R28, <#[R1 + 80]> */
		/* 820F3550h case    7:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 820F3550h case    7:*/		return 0x820F3554;
	}
	return 0x820F3554;
} // Block from 820F3534h-820F3554h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F3554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3554);
		  /* 820F3554h */ case    0:  		/* addi R3, R1, 96 */
		/* 820F3554h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F3554h case    0:*/		return 0x820F3558;
		  /* 820F3558h */ case    1:  		/* bl -152416 */
		/* 820F3558h case    1:*/		regs.LR = 0x820F355C; return 0x820CE1F8;
		/* 820F3558h case    1:*/		return 0x820F355C;
		  /* 820F355Ch */ case    2:  		/* mr R3, R30 */
		/* 820F355Ch case    2:*/		regs.R3 = regs.R30;
		/* 820F355Ch case    2:*/		return 0x820F3560;
		  /* 820F3560h */ case    3:  		/* addi R1, R1, 160 */
		/* 820F3560h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820F3560h case    3:*/		return 0x820F3564;
		  /* 820F3564h */ case    4:  		/* b -402108 */
		/* 820F3564h case    4:*/		return 0x820912A8;
		/* 820F3564h case    4:*/		return 0x820F3568;
	}
	return 0x820F3568;
} // Block from 820F3554h-820F3568h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F3568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3568);
		  /* 820F3568h */ case    0:  		/* mfspr R12, LR */
		/* 820F3568h case    0:*/		regs.R12 = regs.LR;
		/* 820F3568h case    0:*/		return 0x820F356C;
		  /* 820F356Ch */ case    1:  		/* bl -402252 */
		/* 820F356Ch case    1:*/		regs.LR = 0x820F3570; return 0x82091220;
		/* 820F356Ch case    1:*/		return 0x820F3570;
		  /* 820F3570h */ case    2:  		/* stfd FR29, <#[R1 - 176]> */
		/* 820F3570h case    2:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0xFFFFFF50) );
		/* 820F3570h case    2:*/		return 0x820F3574;
		  /* 820F3574h */ case    3:  		/* stfd FR30, <#[R1 - 168]> */
		/* 820F3574h case    3:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 820F3574h case    3:*/		return 0x820F3578;
		  /* 820F3578h */ case    4:  		/* stfd FR31, <#[R1 - 160]> */
		/* 820F3578h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820F3578h case    4:*/		return 0x820F357C;
		  /* 820F357Ch */ case    5:  		/* stwu R1, <#[R1 - 624]> */
		/* 820F357Ch case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFD90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFD90);
		/* 820F357Ch case    5:*/		return 0x820F3580;
		  /* 820F3580h */ case    6:  		/* lwz R11, <#[R3 + 348]> */
		/* 820F3580h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000015C) );
		/* 820F3580h case    6:*/		return 0x820F3584;
		  /* 820F3584h */ case    7:  		/* mr R18, R3 */
		/* 820F3584h case    7:*/		regs.R18 = regs.R3;
		/* 820F3584h case    7:*/		return 0x820F3588;
		  /* 820F3588h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 820F3588h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F3588h case    8:*/		return 0x820F358C;
		  /* 820F358Ch */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 820F358Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820F359C;  }
		/* 820F358Ch case    9:*/		return 0x820F3590;
		  /* 820F3590h */ case   10:  		/* lis R4, 17998 */
		/* 820F3590h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x464E);
		/* 820F3590h case   10:*/		return 0x820F3594;
		  /* 820F3594h */ case   11:  		/* ori R4, R4, 18758 */
		/* 820F3594h case   11:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x4946);
		/* 820F3594h case   11:*/		return 0x820F3598;
		  /* 820F3598h */ case   12:  		/* b 12 */
		/* 820F3598h case   12:*/		return 0x820F35A4;
		/* 820F3598h case   12:*/		return 0x820F359C;
	}
	return 0x820F359C;
} // Block from 820F3568h-820F359Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820F359Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F359C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F359C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F359C);
		  /* 820F359Ch */ case    0:  		/* lis R4, 16961 */
		/* 820F359Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x4241);
		/* 820F359Ch case    0:*/		return 0x820F35A0;
		  /* 820F35A0h */ case    1:  		/* ori R4, R4, 21571 */
		/* 820F35A0h case    1:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x5443);
		/* 820F35A0h case    1:*/		return 0x820F35A4;
	}
	return 0x820F35A4;
} // Block from 820F359Ch-820F35A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F35A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F35A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F35A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F35A4);
		  /* 820F35A4h */ case    0:  		/* addi R3, R1, 96 */
		/* 820F35A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F35A4h case    0:*/		return 0x820F35A8;
		  /* 820F35A8h */ case    1:  		/* bl -152552 */
		/* 820F35A8h case    1:*/		regs.LR = 0x820F35AC; return 0x820CE1C0;
		/* 820F35A8h case    1:*/		return 0x820F35AC;
		  /* 820F35ACh */ case    2:  		/* addi R11, R1, 128 */
		/* 820F35ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820F35ACh case    2:*/		return 0x820F35B0;
		  /* 820F35B0h */ case    3:  		/* li R15, 0 */
		/* 820F35B0h case    3:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 820F35B0h case    3:*/		return 0x820F35B4;
		  /* 820F35B4h */ case    4:  		/* li R10, 28 */
		/* 820F35B4h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x1C);
		/* 820F35B4h case    4:*/		return 0x820F35B8;
		  /* 820F35B8h */ case    5:  		/* li R8, 3 */
		/* 820F35B8h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 820F35B8h case    5:*/		return 0x820F35BC;
		  /* 820F35BCh */ case    6:  		/* stw R15, <#[R1 + 80]> */
		/* 820F35BCh case    6:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000050) );
		/* 820F35BCh case    6:*/		return 0x820F35C0;
		  /* 820F35C0h */ case    7:  		/* li R7, 0 */
		/* 820F35C0h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F35C0h case    7:*/		return 0x820F35C4;
		  /* 820F35C4h */ case    8:  		/* stw R15, <#[R1 + 84]> */
		/* 820F35C4h case    8:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000054) );
		/* 820F35C4h case    8:*/		return 0x820F35C8;
		  /* 820F35C8h */ case    9:  		/* std R15, <#[R11]> */
		/* 820F35C8h case    9:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000000) );
		/* 820F35C8h case    9:*/		return 0x820F35CC;
		  /* 820F35CCh */ case   10:  		/* li R6, 1 */
		/* 820F35CCh case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F35CCh case   10:*/		return 0x820F35D0;
		  /* 820F35D0h */ case   11:  		/* std R15, <#[R11 + 8]> */
		/* 820F35D0h case   11:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000008) );
		/* 820F35D0h case   11:*/		return 0x820F35D4;
		  /* 820F35D4h */ case   12:  		/* li R5, 28 */
		/* 820F35D4h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 820F35D4h case   12:*/		return 0x820F35D8;
		  /* 820F35D8h */ case   13:  		/* std R15, <#[R11 + 16]> */
		/* 820F35D8h case   13:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000010) );
		/* 820F35D8h case   13:*/		return 0x820F35DC;
		  /* 820F35DCh */ case   14:  		/* stw R15, <#[R11 + 24]> */
		/* 820F35DCh case   14:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000018) );
		/* 820F35DCh case   14:*/		return 0x820F35E0;
		  /* 820F35E0h */ case   15:  		/* addi R4, R1, 128 */
		/* 820F35E0h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 820F35E0h case   15:*/		return 0x820F35E4;
		  /* 820F35E4h */ case   16:  		/* stw R10, <#[R1 + 128]> */
		/* 820F35E4h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 820F35E4h case   16:*/		return 0x820F35E8;
		  /* 820F35E8h */ case   17:  		/* addi R3, R1, 96 */
		/* 820F35E8h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F35E8h case   17:*/		return 0x820F35EC;
		  /* 820F35ECh */ case   18:  		/* mr R25, R15 */
		/* 820F35ECh case   18:*/		regs.R25 = regs.R15;
		/* 820F35ECh case   18:*/		return 0x820F35F0;
		  /* 820F35F0h */ case   19:  		/* stw R15, <#[R1 + 88]> */
		/* 820F35F0h case   19:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000058) );
		/* 820F35F0h case   19:*/		return 0x820F35F4;
		  /* 820F35F4h */ case   20:  		/* mr R19, R15 */
		/* 820F35F4h case   20:*/		regs.R19 = regs.R15;
		/* 820F35F4h case   20:*/		return 0x820F35F8;
		  /* 820F35F8h */ case   21:  		/* stw R15, <#[R1 + 112]> */
		/* 820F35F8h case   21:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000070) );
		/* 820F35F8h case   21:*/		return 0x820F35FC;
		  /* 820F35FCh */ case   22:  		/* mr R14, R15 */
		/* 820F35FCh case   22:*/		regs.R14 = regs.R15;
		/* 820F35FCh case   22:*/		return 0x820F3600;
		  /* 820F3600h */ case   23:  		/* lwz R11, <#[R18 + 200]> */
		/* 820F3600h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x000000C8) );
		/* 820F3600h case   23:*/		return 0x820F3604;
		  /* 820F3604h */ case   24:  		/* lwz R10, <#[R18 + 204]> */
		/* 820F3604h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x000000CC) );
		/* 820F3604h case   24:*/		return 0x820F3608;
		  /* 820F3608h */ case   25:  		/* stw R11, <#[R1 + 136]> */
		/* 820F3608h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 820F3608h case   25:*/		return 0x820F360C;
		  /* 820F360Ch */ case   26:  		/* stw R10, <#[R1 + 148]> */
		/* 820F360Ch case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000094) );
		/* 820F360Ch case   26:*/		return 0x820F3610;
		  /* 820F3610h */ case   27:  		/* bl -152480 */
		/* 820F3610h case   27:*/		regs.LR = 0x820F3614; return 0x820CE270;
		/* 820F3610h case   27:*/		return 0x820F3614;
		  /* 820F3614h */ case   28:  		/* or. R31, R3, R3 */
		/* 820F3614h case   28:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F3614h case   28:*/		return 0x820F3618;
		  /* 820F3618h */ case   29:  		/* bc 12, CR0_LT, 2904 */
		/* 820F3618h case   29:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F3618h case   29:*/		return 0x820F361C;
		  /* 820F361Ch */ case   30:  		/* lwz R11, <#[R18 + 8]> */
		/* 820F361Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000008) );
		/* 820F361Ch case   30:*/		return 0x820F3620;
	}
	return 0x820F3620;
} // Block from 820F35A4h-820F3620h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820F3620h
// Function '?MatchCompModifier@CShaderProgram@D3DXShader@@IAAJPAVCInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3620);
		  /* 820F3620h */ case    0:  		/* mr R29, R15 */
		/* 820F3620h case    0:*/		regs.R29 = regs.R15;
		/* 820F3620h case    0:*/		return 0x820F3624;
		  /* 820F3624h */ case    1:  		/* mr R9, R15 */
		/* 820F3624h case    1:*/		regs.R9 = regs.R15;
		/* 820F3624h case    1:*/		return 0x820F3628;
		  /* 820F3628h */ case    2:  		/* mr R8, R15 */
		/* 820F3628h case    2:*/		regs.R8 = regs.R15;
		/* 820F3628h case    2:*/		return 0x820F362C;
		  /* 820F362Ch */ case    3:  		/* mr R6, R15 */
		/* 820F362Ch case    3:*/		regs.R6 = regs.R15;
		/* 820F362Ch case    3:*/		return 0x820F3630;
		  /* 820F3630h */ case    4:  		/* mr R3, R15 */
		/* 820F3630h case    4:*/		regs.R3 = regs.R15;
		/* 820F3630h case    4:*/		return 0x820F3634;
		  /* 820F3634h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820F3634h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F3634h case    5:*/		return 0x820F3638;
		  /* 820F3638h */ case    6:  		/* bc 4, CR6_GT, 172 */
		/* 820F3638h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820F36E4;  }
		/* 820F3638h case    6:*/		return 0x820F363C;
		  /* 820F363Ch */ case    7:  		/* lwz R5, <#[R18 + 20]> */
		/* 820F363Ch case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R18 + 0x00000014) );
		/* 820F363Ch case    7:*/		return 0x820F3640;
		  /* 820F3640h */ case    8:  		/* mr R7, R15 */
		/* 820F3640h case    8:*/		regs.R7 = regs.R15;
		/* 820F3640h case    8:*/		return 0x820F3644;
		  /* 820F3644h */ case    9:  		/* lwz R4, <#[R18 + 16]> */
		/* 820F3644h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R18 + 0x00000010) );
		/* 820F3644h case    9:*/		return 0x820F3648;
		  /* 820F3648h */ case   10:  		/* rlwinm R31, R11, 0, 0, 31 */
		/* 820F3648h case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R31,regs.R11);
		/* 820F3648h case   10:*/		return 0x820F364C;
		  /* 820F364Ch */ case   11:  		/* lwzx R11, <#[R5 + R7]> */
		/* 820F364Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R7 + 0x00000000) );
		/* 820F364Ch case   11:*/		return 0x820F3650;
		  /* 820F3650h */ case   12:  		/* lwz R10, <#[R11 + 4]> */
		/* 820F3650h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820F3650h case   12:*/		return 0x820F3654;
		  /* 820F3654h */ case   13:  		/* lwz R30, <#[R11]> */
		/* 820F3654h case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820F3654h case   13:*/		return 0x820F3658;
		  /* 820F3658h */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F3658h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F3658h case   14:*/		return 0x820F365C;
		  /* 820F365Ch */ case   15:  		/* rlwinm. R30, R30, 0, 3, 3 */
		/* 820F365Ch case   15:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R30,regs.R30);
		/* 820F365Ch case   15:*/		return 0x820F3660;
		  /* 820F3660h */ case   16:  		/* lwzx R10, <#[R10 + R4]> */
		/* 820F3660h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 820F3660h case   16:*/		return 0x820F3664;
		  /* 820F3664h */ case   17:  		/* bc 4, CR0_EQ, 112 */
		/* 820F3664h case   17:*/		if ( !regs.CR[0].eq ) { return 0x820F36D4;  }
		/* 820F3664h case   17:*/		return 0x820F3668;
		  /* 820F3668h */ case   18:  		/* lwz R10, <#[R10 + 4]> */
		/* 820F3668h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820F3668h case   18:*/		return 0x820F366C;
		  /* 820F366Ch */ case   19:  		/* rlwinm. R30, R10, 0, 22, 22 */
		/* 820F366Ch case   19:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R30,regs.R10);
		/* 820F366Ch case   19:*/		return 0x820F3670;
		  /* 820F3670h */ case   20:  		/* bc 12, CR0_EQ, 100 */
		/* 820F3670h case   20:*/		if ( regs.CR[0].eq ) { return 0x820F36D4;  }
		/* 820F3670h case   20:*/		return 0x820F3674;
		  /* 820F3674h */ case   21:  		/* rlwinm. R30, R10, 0, 23, 23 */
		/* 820F3674h case   21:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R30,regs.R10);
		/* 820F3674h case   21:*/		return 0x820F3678;
		  /* 820F3678h */ case   22:  		/* bc 4, CR0_EQ, 92 */
		/* 820F3678h case   22:*/		if ( !regs.CR[0].eq ) { return 0x820F36D4;  }
		/* 820F3678h case   22:*/		return 0x820F367C;
		  /* 820F367Ch */ case   23:  		/* lwz R11, <#[R11 + 12]> */
		/* 820F367Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F367Ch case   23:*/		return 0x820F3680;
		  /* 820F3680h */ case   24:  		/* rlwinm. R30, R10, 0, 24, 24 */
		/* 820F3680h case   24:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R30,regs.R10);
		/* 820F3680h case   24:*/		return 0x820F3684;
		  /* 820F3684h */ case   25:  		/* bc 12, CR0_EQ, 20 */
		/* 820F3684h case   25:*/		if ( regs.CR[0].eq ) { return 0x820F3698;  }
		/* 820F3684h case   25:*/		return 0x820F3688;
		  /* 820F3688h */ case   26:  		/* cmplw CR6, R8, R11 */
		/* 820F3688h case   26:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820F3688h case   26:*/		return 0x820F368C;
		  /* 820F368Ch */ case   27:  		/* bc 12, CR6_GT, 72 */
		/* 820F368Ch case   27:*/		if ( regs.CR[6].gt ) { return 0x820F36D4;  }
		/* 820F368Ch case   27:*/		return 0x820F3690;
		  /* 820F3690h */ case   28:  		/* addi R8, R11, 1 */
		/* 820F3690h case   28:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x1);
		/* 820F3690h case   28:*/		return 0x820F3694;
		  /* 820F3694h */ case   29:  		/* b 64 */
		/* 820F3694h case   29:*/		return 0x820F36D4;
		/* 820F3694h case   29:*/		return 0x820F3698;
	}
	return 0x820F3698;
} // Block from 820F3620h-820F3698h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820F3698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3698);
		  /* 820F3698h */ case    0:  		/* rlwinm. R30, R10, 0, 18, 18 */
		/* 820F3698h case    0:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R30,regs.R10);
		/* 820F3698h case    0:*/		return 0x820F369C;
		  /* 820F369Ch */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820F369Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820F36B0;  }
		/* 820F369Ch case    1:*/		return 0x820F36A0;
		  /* 820F36A0h */ case    2:  		/* cmplw CR6, R29, R11 */
		/* 820F36A0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820F36A0h case    2:*/		return 0x820F36A4;
		  /* 820F36A4h */ case    3:  		/* bc 12, CR6_GT, 48 */
		/* 820F36A4h case    3:*/		if ( regs.CR[6].gt ) { return 0x820F36D4;  }
		/* 820F36A4h case    3:*/		return 0x820F36A8;
		  /* 820F36A8h */ case    4:  		/* addi R29, R11, 1 */
		/* 820F36A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1);
		/* 820F36A8h case    4:*/		return 0x820F36AC;
		  /* 820F36ACh */ case    5:  		/* b 40 */
		/* 820F36ACh case    5:*/		return 0x820F36D4;
		/* 820F36ACh case    5:*/		return 0x820F36B0;
	}
	return 0x820F36B0;
} // Block from 820F3698h-820F36B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F36B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F36B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F36B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F36B0);
		  /* 820F36B0h */ case    0:  		/* rlwinm. R10, R10, 0, 13, 13 */
		/* 820F36B0h case    0:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R10,regs.R10);
		/* 820F36B0h case    0:*/		return 0x820F36B4;
		  /* 820F36B4h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820F36B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820F36C8;  }
		/* 820F36B4h case    1:*/		return 0x820F36B8;
		  /* 820F36B8h */ case    2:  		/* cmplw CR6, R6, R11 */
		/* 820F36B8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820F36B8h case    2:*/		return 0x820F36BC;
		  /* 820F36BCh */ case    3:  		/* bc 12, CR6_GT, 24 */
		/* 820F36BCh case    3:*/		if ( regs.CR[6].gt ) { return 0x820F36D4;  }
		/* 820F36BCh case    3:*/		return 0x820F36C0;
		  /* 820F36C0h */ case    4:  		/* addi R6, R11, 1 */
		/* 820F36C0h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1);
		/* 820F36C0h case    4:*/		return 0x820F36C4;
		  /* 820F36C4h */ case    5:  		/* b 16 */
		/* 820F36C4h case    5:*/		return 0x820F36D4;
		/* 820F36C4h case    5:*/		return 0x820F36C8;
	}
	return 0x820F36C8;
} // Block from 820F36B0h-820F36C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F36C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F36C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F36C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F36C8);
		  /* 820F36C8h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 820F36C8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820F36C8h case    0:*/		return 0x820F36CC;
		  /* 820F36CCh */ case    1:  		/* bc 12, CR6_GT, 8 */
		/* 820F36CCh case    1:*/		if ( regs.CR[6].gt ) { return 0x820F36D4;  }
		/* 820F36CCh case    1:*/		return 0x820F36D0;
		  /* 820F36D0h */ case    2:  		/* addi R9, R11, 1 */
		/* 820F36D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 820F36D0h case    2:*/		return 0x820F36D4;
	}
	return 0x820F36D4;
} // Block from 820F36C8h-820F36D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F36D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F36D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F36D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F36D4);
		  /* 820F36D4h */ case    0:  		/* addi R3, R3, 1 */
		/* 820F36D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820F36D4h case    0:*/		return 0x820F36D8;
		  /* 820F36D8h */ case    1:  		/* addi R7, R7, 4 */
		/* 820F36D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820F36D8h case    1:*/		return 0x820F36DC;
		  /* 820F36DCh */ case    2:  		/* cmplw CR6, R3, R31 */
		/* 820F36DCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R31);
		/* 820F36DCh case    2:*/		return 0x820F36E0;
		  /* 820F36E0h */ case    3:  		/* bc 12, CR6_LT, -148 */
		/* 820F36E0h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F364C;  }
		/* 820F36E0h case    3:*/		return 0x820F36E4;
	}
	return 0x820F36E4;
} // Block from 820F36D4h-820F36E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F36E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F36E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F36E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F36E4);
		  /* 820F36E4h */ case    0:  		/* add R11, R6, R8 */
		/* 820F36E4h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R6,regs.R8);
		/* 820F36E4h case    0:*/		return 0x820F36E8;
		  /* 820F36E8h */ case    1:  		/* add R10, R8, R9 */
		/* 820F36E8h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R9);
		/* 820F36E8h case    1:*/		return 0x820F36EC;
		  /* 820F36ECh */ case    2:  		/* add R11, R11, R9 */
		/* 820F36ECh case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820F36ECh case    2:*/		return 0x820F36F0;
		  /* 820F36F0h */ case    3:  		/* lis R4, 9345 */
		/* 820F36F0h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F36F0h case    3:*/		return 0x820F36F4;
		  /* 820F36F4h */ case    4:  		/* add R30, R11, R29 */
		/* 820F36F4h case    4:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R29);
		/* 820F36F4h case    4:*/		return 0x820F36F8;
		  /* 820F36F8h */ case    5:  		/* add R28, R9, R29 */
		/* 820F36F8h case    5:*/		cpu::op::add<0>(regs,&regs.R28,regs.R9,regs.R29);
		/* 820F36F8h case    5:*/		return 0x820F36FC;
		  /* 820F36FCh */ case    6:  		/* rlwinm R31, R30, 2, 0, 29 */
		/* 820F36FCh case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R30);
		/* 820F36FCh case    6:*/		return 0x820F3700;
		  /* 820F3700h */ case    7:  		/* add R27, R10, R29 */
		/* 820F3700h case    7:*/		cpu::op::add<0>(regs,&regs.R27,regs.R10,regs.R29);
		/* 820F3700h case    7:*/		return 0x820F3704;
		  /* 820F3704h */ case    8:  		/* mr R3, R31 */
		/* 820F3704h case    8:*/		regs.R3 = regs.R31;
		/* 820F3704h case    8:*/		return 0x820F3708;
		  /* 820F3708h */ case    9:  		/* bl -439560 */
		/* 820F3708h case    9:*/		regs.LR = 0x820F370C; return 0x82088200;
		/* 820F3708h case    9:*/		return 0x820F370C;
		  /* 820F370Ch */ case   10:  		/* or. R19, R3, R3 */
		/* 820F370Ch case   10:*/		cpu::op::or<1>(regs,&regs.R19,regs.R3,regs.R3);
		/* 820F370Ch case   10:*/		return 0x820F3710;
		  /* 820F3710h */ case   11:  		/* bc 12, CR0_EQ, 2616 */
		/* 820F3710h case   11:*/		if ( regs.CR[0].eq ) { return 0x820F4148;  }
		/* 820F3710h case   11:*/		return 0x820F3714;
		  /* 820F3714h */ case   12:  		/* lis R4, 9345 */
		/* 820F3714h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F3714h case   12:*/		return 0x820F3718;
		  /* 820F3718h */ case   13:  		/* mr R3, R31 */
		/* 820F3718h case   13:*/		regs.R3 = regs.R31;
		/* 820F3718h case   13:*/		return 0x820F371C;
		  /* 820F371Ch */ case   14:  		/* bl -439580 */
		/* 820F371Ch case   14:*/		regs.LR = 0x820F3720; return 0x82088200;
		/* 820F371Ch case   14:*/		return 0x820F3720;
		  /* 820F3720h */ case   15:  		/* or. R26, R3, R3 */
		/* 820F3720h case   15:*/		cpu::op::or<1>(regs,&regs.R26,regs.R3,regs.R3);
		/* 820F3720h case   15:*/		return 0x820F3724;
		  /* 820F3724h */ case   16:  		/* stw R26, <#[R1 + 112]> */
		/* 820F3724h case   16:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000070) );
		/* 820F3724h case   16:*/		return 0x820F3728;
		  /* 820F3728h */ case   17:  		/* bc 12, CR0_EQ, 2592 */
		/* 820F3728h case   17:*/		if ( regs.CR[0].eq ) { return 0x820F4148;  }
		/* 820F3728h case   17:*/		return 0x820F372C;
		  /* 820F372Ch */ case   18:  		/* mr R5, R31 */
		/* 820F372Ch case   18:*/		regs.R5 = regs.R31;
		/* 820F372Ch case   18:*/		return 0x820F3730;
		  /* 820F3730h */ case   19:  		/* li R4, 0 */
		/* 820F3730h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F3730h case   19:*/		return 0x820F3734;
		  /* 820F3734h */ case   20:  		/* mr R3, R19 */
		/* 820F3734h case   20:*/		regs.R3 = regs.R19;
		/* 820F3734h case   20:*/		return 0x820F3738;
		  /* 820F3738h */ case   21:  		/* bl -402424 */
		/* 820F3738h case   21:*/		regs.LR = 0x820F373C; return 0x82091340;
		/* 820F3738h case   21:*/		return 0x820F373C;
		  /* 820F373Ch */ case   22:  		/* lwz R11, <#[R18 + 8]> */
		/* 820F373Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000008) );
		/* 820F373Ch case   22:*/		return 0x820F3740;
		  /* 820F3740h */ case   23:  		/* mr R5, R15 */
		/* 820F3740h case   23:*/		regs.R5 = regs.R15;
		/* 820F3740h case   23:*/		return 0x820F3744;
		  /* 820F3744h */ case   24:  		/* cmplwi CR6, R11, 0 */
		/* 820F3744h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F3744h case   24:*/		return 0x820F3748;
		  /* 820F3748h */ case   25:  		/* bc 4, CR6_GT, 224 */
		/* 820F3748h case   25:*/		if ( !regs.CR[6].gt ) { return 0x820F3828;  }
		/* 820F3748h case   25:*/		return 0x820F374C;
		  /* 820F374Ch */ case   26:  		/* mr R6, R15 */
		/* 820F374Ch case   26:*/		regs.R6 = regs.R15;
		/* 820F374Ch case   26:*/		return 0x820F3750;
		  /* 820F3750h */ case   27:  		/* lwz R11, <#[R18 + 20]> */
		/* 820F3750h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000014) );
		/* 820F3750h case   27:*/		return 0x820F3754;
		  /* 820F3754h */ case   28:  		/* lwz R10, <#[R18 + 16]> */
		/* 820F3754h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000010) );
		/* 820F3754h case   28:*/		return 0x820F3758;
		  /* 820F3758h */ case   29:  		/* lwzx R8, <#[R6 + R11]> */
		/* 820F3758h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820F3758h case   29:*/		return 0x820F375C;
		  /* 820F375Ch */ case   30:  		/* lwz R11, <#[R8 + 4]> */
		/* 820F375Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 820F375Ch case   30:*/		return 0x820F3760;
		  /* 820F3760h */ case   31:  		/* lwz R9, <#[R8]> */
		/* 820F3760h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 820F3760h case   31:*/		return 0x820F3764;
		  /* 820F3764h */ case   32:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F3764h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F3764h case   32:*/		return 0x820F3768;
		  /* 820F3768h */ case   33:  		/* rlwinm. R9, R9, 0, 3, 3 */
		/* 820F3768h case   33:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R9,regs.R9);
		/* 820F3768h case   33:*/		return 0x820F376C;
		  /* 820F376Ch */ case   34:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F376Ch case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F376Ch case   34:*/		return 0x820F3770;
		  /* 820F3770h */ case   35:  		/* bc 4, CR0_EQ, 164 */
		/* 820F3770h case   35:*/		if ( !regs.CR[0].eq ) { return 0x820F3814;  }
		/* 820F3770h case   35:*/		return 0x820F3774;
		  /* 820F3774h */ case   36:  		/* lwz R10, <#[R8 + 96]> */
		/* 820F3774h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000060) );
		/* 820F3774h case   36:*/		return 0x820F3778;
		  /* 820F3778h */ case   37:  		/* cmplwi CR6, R10, 0 */
		/* 820F3778h case   37:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F3778h case   37:*/		return 0x820F377C;
		  /* 820F377Ch */ case   38:  		/* bc 12, CR6_EQ, 152 */
		/* 820F377Ch case   38:*/		if ( regs.CR[6].eq ) { return 0x820F3814;  }
		/* 820F377Ch case   38:*/		return 0x820F3780;
		  /* 820F3780h */ case   39:  		/* lwz R10, <#[R8 + 8]> */
		/* 820F3780h case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000008) );
		/* 820F3780h case   39:*/		return 0x820F3784;
		  /* 820F3784h */ case   40:  		/* cmpwi CR6, R10, -1 */
		/* 820F3784h case   40:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820F3784h case   40:*/		return 0x820F3788;
		  /* 820F3788h */ case   41:  		/* bc 4, CR6_EQ, 140 */
		/* 820F3788h case   41:*/		if ( !regs.CR[6].eq ) { return 0x820F3814;  }
		/* 820F3788h case   41:*/		return 0x820F378C;
		  /* 820F378Ch */ case   42:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F378Ch case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F378Ch case   42:*/		return 0x820F3790;
		  /* 820F3790h */ case   43:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 820F3790h case   43:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 820F3790h case   43:*/		return 0x820F3794;
		  /* 820F3794h */ case   44:  		/* bc 12, CR0_EQ, 128 */
		/* 820F3794h case   44:*/		if ( regs.CR[0].eq ) { return 0x820F3814;  }
		/* 820F3794h case   44:*/		return 0x820F3798;
		  /* 820F3798h */ case   45:  		/* rlwinm. R10, R11, 0, 23, 23 */
		/* 820F3798h case   45:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R11);
		/* 820F3798h case   45:*/		return 0x820F379C;
		  /* 820F379Ch */ case   46:  		/* bc 4, CR0_EQ, 120 */
		/* 820F379Ch case   46:*/		if ( !regs.CR[0].eq ) { return 0x820F3814;  }
		/* 820F379Ch case   46:*/		return 0x820F37A0;
		  /* 820F37A0h */ case   47:  		/* rlwinm. R10, R11, 0, 24, 24 */
		/* 820F37A0h case   47:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R11);
		/* 820F37A0h case   47:*/		return 0x820F37A4;
		  /* 820F37A4h */ case   48:  		/* bc 12, CR0_EQ, 12 */
		/* 820F37A4h case   48:*/		if ( regs.CR[0].eq ) { return 0x820F37B0;  }
		/* 820F37A4h case   48:*/		return 0x820F37A8;
		  /* 820F37A8h */ case   49:  		/* mr R11, R28 */
		/* 820F37A8h case   49:*/		regs.R11 = regs.R28;
		/* 820F37A8h case   49:*/		return 0x820F37AC;
		  /* 820F37ACh */ case   50:  		/* b 36 */
		/* 820F37ACh case   50:*/		return 0x820F37D0;
		/* 820F37ACh case   50:*/		return 0x820F37B0;
	}
	return 0x820F37B0;
} // Block from 820F36E4h-820F37B0h (51 instructions)

//////////////////////////////////////////////////////
// Block at 820F37B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F37B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F37B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F37B0);
		  /* 820F37B0h */ case    0:  		/* rlwinm. R10, R11, 0, 18, 18 */
		/* 820F37B0h case    0:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R10,regs.R11);
		/* 820F37B0h case    0:*/		return 0x820F37B4;
		  /* 820F37B4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820F37B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820F37C0;  }
		/* 820F37B4h case    1:*/		return 0x820F37B8;
		  /* 820F37B8h */ case    2:  		/* mr R11, R15 */
		/* 820F37B8h case    2:*/		regs.R11 = regs.R15;
		/* 820F37B8h case    2:*/		return 0x820F37BC;
		  /* 820F37BCh */ case    3:  		/* b 20 */
		/* 820F37BCh case    3:*/		return 0x820F37D0;
		/* 820F37BCh case    3:*/		return 0x820F37C0;
	}
	return 0x820F37C0;
} // Block from 820F37B0h-820F37C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F37C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F37C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F37C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F37C0);
		  /* 820F37C0h */ case    0:  		/* rlwinm. R11, R11, 0, 13, 13 */
		/* 820F37C0h case    0:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R11);
		/* 820F37C0h case    0:*/		return 0x820F37C4;
		  /* 820F37C4h */ case    1:  		/* mr R11, R27 */
		/* 820F37C4h case    1:*/		regs.R11 = regs.R27;
		/* 820F37C4h case    1:*/		return 0x820F37C8;
		  /* 820F37C8h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 820F37C8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820F37D0;  }
		/* 820F37C8h case    2:*/		return 0x820F37CC;
		  /* 820F37CCh */ case    3:  		/* mr R11, R29 */
		/* 820F37CCh case    3:*/		regs.R11 = regs.R29;
		/* 820F37CCh case    3:*/		return 0x820F37D0;
	}
	return 0x820F37D0;
} // Block from 820F37C0h-820F37D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F37D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F37D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F37D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F37D0);
		  /* 820F37D0h */ case    0:  		/* lwz R10, <#[R8 + 12]> */
		/* 820F37D0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x0000000C) );
		/* 820F37D0h case    0:*/		return 0x820F37D4;
		  /* 820F37D4h */ case    1:  		/* lwz R9, <#[R8 + 112]> */
		/* 820F37D4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000070) );
		/* 820F37D4h case    1:*/		return 0x820F37D8;
		  /* 820F37D8h */ case    2:  		/* add R10, R10, R11 */
		/* 820F37D8h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820F37D8h case    2:*/		return 0x820F37DC;
		  /* 820F37DCh */ case    3:  		/* rlwinm R9, R9, 30, 2, 31 */
		/* 820F37DCh case    3:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R9,regs.R9);
		/* 820F37DCh case    3:*/		return 0x820F37E0;
		  /* 820F37E0h */ case    4:  		/* addi R11, R10, 1 */
		/* 820F37E0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 820F37E0h case    4:*/		return 0x820F37E4;
		  /* 820F37E4h */ case    5:  		/* subf R9, R9, R10 */
		/* 820F37E4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 820F37E4h case    5:*/		return 0x820F37E8;
		  /* 820F37E8h */ case    6:  		/* cmplw CR6, R11, R9 */
		/* 820F37E8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F37E8h case    6:*/		return 0x820F37EC;
		  /* 820F37ECh */ case    7:  		/* bc 4, CR6_GT, 40 */
		/* 820F37ECh case    7:*/		if ( !regs.CR[6].gt ) { return 0x820F3814;  }
		/* 820F37ECh case    7:*/		return 0x820F37F0;
		  /* 820F37F0h */ case    8:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 820F37F0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820F37F0h case    8:*/		return 0x820F37F4;
		  /* 820F37F4h */ case    9:  		/* add R10, R10, R19 */
		/* 820F37F4h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R19);
		/* 820F37F4h case    9:*/		return 0x820F37F8;
		  /* 820F37F8h */ case   10:  		/* lwzu R7, <#[R10 - 4]> */
		/* 820F37F8h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0xFFFFFFFC) );
		regs.R10 = (uint32)(regs.R10 + 0xFFFFFFFC);
		/* 820F37F8h case   10:*/		return 0x820F37FC;
		  /* 820F37FCh */ case   11:  		/* addi R11, R11, -1 */
		/* 820F37FCh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820F37FCh case   11:*/		return 0x820F3800;
		  /* 820F3800h */ case   12:  		/* cmplwi CR6, R7, 0 */
		/* 820F3800h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820F3800h case   12:*/		return 0x820F3804;
		  /* 820F3804h */ case   13:  		/* bc 4, CR6_EQ, 16 */
		/* 820F3804h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820F3814;  }
		/* 820F3804h case   13:*/		return 0x820F3808;
	}
	return 0x820F3808;
} // Block from 820F37D0h-820F3808h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F3808h
// Function '?MatchComplexComp@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3808);
		  /* 820F3808h */ case    0:  		/* stw R8, <#[R10]> */
		/* 820F3808h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820F3808h case    0:*/		return 0x820F380C;
		  /* 820F380Ch */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 820F380Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F380Ch case    1:*/		return 0x820F3810;
		  /* 820F3810h */ case    2:  		/* bc 12, CR6_GT, -24 */
		/* 820F3810h case    2:*/		if ( regs.CR[6].gt ) { return 0x820F37F8;  }
		/* 820F3810h case    2:*/		return 0x820F3814;
	}
	return 0x820F3814;
} // Block from 820F3808h-820F3814h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F3814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3814);
		  /* 820F3814h */ case    0:  		/* lwz R11, <#[R18 + 8]> */
		/* 820F3814h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000008) );
		/* 820F3814h case    0:*/		return 0x820F3818;
		  /* 820F3818h */ case    1:  		/* addi R5, R5, 1 */
		/* 820F3818h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820F3818h case    1:*/		return 0x820F381C;
		  /* 820F381Ch */ case    2:  		/* addi R6, R6, 4 */
		/* 820F381Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 820F381Ch case    2:*/		return 0x820F3820;
		  /* 820F3820h */ case    3:  		/* cmplw CR6, R5, R11 */
		/* 820F3820h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 820F3820h case    3:*/		return 0x820F3824;
		  /* 820F3824h */ case    4:  		/* bc 12, CR6_LT, -212 */
		/* 820F3824h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F3750;  }
		/* 820F3824h case    4:*/		return 0x820F3828;
	}
	return 0x820F3828;
} // Block from 820F3814h-820F3828h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F3828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3828);
		  /* 820F3828h */ case    0:  		/* mr R16, R15 */
		/* 820F3828h case    0:*/		regs.R16 = regs.R15;
		/* 820F3828h case    0:*/		return 0x820F382C;
		  /* 820F382Ch */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 820F382Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820F382Ch case    1:*/		return 0x820F3830;
		  /* 820F3830h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 820F3830h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F385C;  }
		/* 820F3830h case    2:*/		return 0x820F3834;
		  /* 820F3834h */ case    3:  		/* addi R11, R19, -4 */
		/* 820F3834h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R19,0xFFFFFFFC);
		/* 820F3834h case    3:*/		return 0x820F3838;
		  /* 820F3838h */ case    4:  		/* mtspr CTR, R30 */
		/* 820F3838h case    4:*/		regs.CTR = regs.R30;
		/* 820F3838h case    4:*/		return 0x820F383C;
		  /* 820F383Ch */ case    5:  		/* mr R9, R19 */
		/* 820F383Ch case    5:*/		regs.R9 = regs.R19;
		/* 820F383Ch case    5:*/		return 0x820F3840;
		  /* 820F3840h */ case    6:  		/* lwz R10, <#[R9]> */
		/* 820F3840h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820F3840h case    6:*/		return 0x820F3844;
		  /* 820F3844h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 820F3844h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F3844h case    7:*/		return 0x820F3848;
		  /* 820F3848h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 820F3848h case    8:*/		if ( regs.CR[6].eq ) { return 0x820F3854;  }
		/* 820F3848h case    8:*/		return 0x820F384C;
		  /* 820F384Ch */ case    9:  		/* stwu R10, <#[R11 + 4]> */
		/* 820F384Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820F384Ch case    9:*/		return 0x820F3850;
		  /* 820F3850h */ case   10:  		/* addi R16, R16, 1 */
		/* 820F3850h case   10:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x1);
		/* 820F3850h case   10:*/		return 0x820F3854;
	}
	return 0x820F3854;
} // Block from 820F3828h-820F3854h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F3854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3854);
		  /* 820F3854h */ case    0:  		/* addi R9, R9, 4 */
		/* 820F3854h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F3854h case    0:*/		return 0x820F3858;
		  /* 820F3858h */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 820F3858h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F3840;  }
		/* 820F3858h case    1:*/		return 0x820F385C;
	}
	return 0x820F385C;
} // Block from 820F3854h-820F385Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F385Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F385C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F385C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F385C);
		  /* 820F385Ch */ case    0:  		/* mr R17, R15 */
		/* 820F385Ch case    0:*/		regs.R17 = regs.R15;
		/* 820F385Ch case    0:*/		return 0x820F3860;
		  /* 820F3860h */ case    1:  		/* mr R9, R15 */
		/* 820F3860h case    1:*/		regs.R9 = regs.R15;
		/* 820F3860h case    1:*/		return 0x820F3864;
		  /* 820F3864h */ case    2:  		/* mr R6, R15 */
		/* 820F3864h case    2:*/		regs.R6 = regs.R15;
		/* 820F3864h case    2:*/		return 0x820F3868;
		  /* 820F3868h */ case    3:  		/* cmplwi CR6, R16, 0 */
		/* 820F3868h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 820F3868h case    3:*/		return 0x820F386C;
		  /* 820F386Ch */ case    4:  		/* bc 12, CR6_EQ, 224 */
		/* 820F386Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820F394C;  }
		/* 820F386Ch case    4:*/		return 0x820F3870;
		  /* 820F3870h */ case    5:  		/* addi R7, R26, -4 */
		/* 820F3870h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R26,0xFFFFFFFC);
		/* 820F3870h case    5:*/		return 0x820F3874;
		  /* 820F3874h */ case    6:  		/* mtspr CTR, R16 */
		/* 820F3874h case    6:*/		regs.CTR = regs.R16;
		/* 820F3874h case    6:*/		return 0x820F3878;
		  /* 820F3878h */ case    7:  		/* mr R8, R19 */
		/* 820F3878h case    7:*/		regs.R8 = regs.R19;
		/* 820F3878h case    7:*/		return 0x820F387C;
		  /* 820F387Ch */ case    8:  		/* cmplwi CR6, R9, 0 */
		/* 820F387Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820F387Ch case    8:*/		return 0x820F3880;
		  /* 820F3880h */ case    9:  		/* bc 12, CR6_EQ, 84 */
		/* 820F3880h case    9:*/		if ( regs.CR[6].eq ) { return 0x820F38D4;  }
		/* 820F3880h case    9:*/		return 0x820F3884;
		  /* 820F3884h */ case   10:  		/* lwz R11, <#[R8]> */
		/* 820F3884h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820F3884h case   10:*/		return 0x820F3888;
		  /* 820F3888h */ case   11:  		/* lwz R10, <#[R9 + 4]> */
		/* 820F3888h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 820F3888h case   11:*/		return 0x820F388C;
		  /* 820F388Ch */ case   12:  		/* lwz R5, <#[R11 + 4]> */
		/* 820F388Ch case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000004) );
		/* 820F388Ch case   12:*/		return 0x820F3890;
		  /* 820F3890h */ case   13:  		/* cmplw CR6, R5, R10 */
		/* 820F3890h case   13:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 820F3890h case   13:*/		return 0x820F3894;
		  /* 820F3894h */ case   14:  		/* bc 4, CR6_EQ, 64 */
		/* 820F3894h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820F38D4;  }
		/* 820F3894h case   14:*/		return 0x820F3898;
		  /* 820F3898h */ case   15:  		/* lwz R11, <#[R11 + 96]> */
		/* 820F3898h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 820F3898h case   15:*/		return 0x820F389C;
		  /* 820F389Ch */ case   16:  		/* lwz R10, <#[R9 + 96]> */
		/* 820F389Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000060) );
		/* 820F389Ch case   16:*/		return 0x820F38A0;
		  /* 820F38A0h */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 820F38A0h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F38A0h case   17:*/		return 0x820F38A4;
		  /* 820F38A4h */ case   18:  		/* bc 4, CR6_EQ, 48 */
		/* 820F38A4h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820F38D4;  }
		/* 820F38A4h case   18:*/		return 0x820F38A8;
		  /* 820F38A8h */ case   19:  		/* lwz R11, <#[R8]> */
		/* 820F38A8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820F38A8h case   19:*/		return 0x820F38AC;
		  /* 820F38ACh */ case   20:  		/* lwz R10, <#[R9 + 112]> */
		/* 820F38ACh case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000070) );
		/* 820F38ACh case   20:*/		return 0x820F38B0;
		  /* 820F38B0h */ case   21:  		/* lwz R5, <#[R9 + 12]> */
		/* 820F38B0h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x0000000C) );
		/* 820F38B0h case   21:*/		return 0x820F38B4;
		  /* 820F38B4h */ case   22:  		/* rlwinm R10, R10, 30, 2, 31 */
		/* 820F38B4h case   22:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R10);
		/* 820F38B4h case   22:*/		return 0x820F38B8;
		  /* 820F38B8h */ case   23:  		/* lwz R4, <#[R11 + 112]> */
		/* 820F38B8h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000070) );
		/* 820F38B8h case   23:*/		return 0x820F38BC;
		  /* 820F38BCh */ case   24:  		/* subf R10, R10, R5 */
		/* 820F38BCh case   24:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 820F38BCh case   24:*/		return 0x820F38C0;
		  /* 820F38C0h */ case   25:  		/* lwz R11, <#[R11 + 12]> */
		/* 820F38C0h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F38C0h case   25:*/		return 0x820F38C4;
		  /* 820F38C4h */ case   26:  		/* rlwinm R5, R4, 30, 2, 31 */
		/* 820F38C4h case   26:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R5,regs.R4);
		/* 820F38C4h case   26:*/		return 0x820F38C8;
		  /* 820F38C8h */ case   27:  		/* subf R11, R5, R11 */
		/* 820F38C8h case   27:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 820F38C8h case   27:*/		return 0x820F38CC;
		  /* 820F38CCh */ case   28:  		/* cmplw CR6, R11, R10 */
		/* 820F38CCh case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F38CCh case   28:*/		return 0x820F38D0;
		  /* 820F38D0h */ case   29:  		/* bc 12, CR6_EQ, 112 */
		/* 820F38D0h case   29:*/		if ( regs.CR[6].eq ) { return 0x820F3940;  }
		/* 820F38D0h case   29:*/		return 0x820F38D4;
	}
	return 0x820F38D4;
} // Block from 820F385Ch-820F38D4h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820F38D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F38D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F38D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F38D4);
		  /* 820F38D4h */ case    0:  		/* lwz R9, <#[R8]> */
		/* 820F38D4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 820F38D4h case    0:*/		return 0x820F38D8;
		  /* 820F38D8h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 820F38D8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820F38D8h case    1:*/		return 0x820F38DC;
		  /* 820F38DCh */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 820F38DCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820F3940;  }
		/* 820F38DCh case    2:*/		return 0x820F38E0;
		  /* 820F38E0h */ case    3:  		/* lwz R11, <#[R9 + 96]> */
		/* 820F38E0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000060) );
		/* 820F38E0h case    3:*/		return 0x820F38E4;
		  /* 820F38E4h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 820F38E4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820F38E4h case    4:*/		return 0x820F38E8;
	}
	return 0x820F38E8;
} // Block from 820F38D4h-820F38E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F38E8h
// Function '?MatchComplexBX2@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F38E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F38E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F38E8);
		  /* 820F38E8h */ case    0:  		/* cmpwi CR6, R10, 6 */
		/* 820F38E8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000006);
		/* 820F38E8h case    0:*/		return 0x820F38EC;
		  /* 820F38ECh */ case    1:  		/* bc 4, CR6_EQ, 84 */
		/* 820F38ECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F3940;  }
		/* 820F38ECh case    1:*/		return 0x820F38F0;
		  /* 820F38F0h */ case    2:  		/* lwz R10, <#[R11 + 20]> */
		/* 820F38F0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820F38F0h case    2:*/		return 0x820F38F4;
		  /* 820F38F4h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 820F38F4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F38F4h case    3:*/		return 0x820F38F8;
		  /* 820F38F8h */ case    4:  		/* bc 12, CR6_EQ, 72 */
		/* 820F38F8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820F3940;  }
		/* 820F38F8h case    4:*/		return 0x820F38FC;
		  /* 820F38FCh */ case    5:  		/* lwz R5, <#[R10 + 4]> */
		/* 820F38FCh case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000004) );
		/* 820F38FCh case    5:*/		return 0x820F3900;
		  /* 820F3900h */ case    6:  		/* cmpwi CR6, R5, 3 */
		/* 820F3900h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000003);
		/* 820F3900h case    6:*/		return 0x820F3904;
		  /* 820F3904h */ case    7:  		/* bc 4, CR6_EQ, 60 */
		/* 820F3904h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820F3940;  }
		/* 820F3904h case    7:*/		return 0x820F3908;
		  /* 820F3908h */ case    8:  		/* lwz R11, <#[R11 + 24]> */
		/* 820F3908h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820F3908h case    8:*/		return 0x820F390C;
		  /* 820F390Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820F390Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F390Ch case    9:*/		return 0x820F3910;
		  /* 820F3910h */ case   10:  		/* bc 12, CR6_EQ, 48 */
		/* 820F3910h case   10:*/		if ( regs.CR[6].eq ) { return 0x820F3940;  }
		/* 820F3910h case   10:*/		return 0x820F3914;
		  /* 820F3914h */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F3914h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F3914h case   11:*/		return 0x820F3918;
		  /* 820F3918h */ case   12:  		/* cmpwi CR6, R11, 11 */
		/* 820F3918h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820F3918h case   12:*/		return 0x820F391C;
		  /* 820F391Ch */ case   13:  		/* bc 4, CR6_EQ, 36 */
		/* 820F391Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x820F3940;  }
		/* 820F391Ch case   13:*/		return 0x820F3920;
		  /* 820F3920h */ case   14:  		/* lwz R11, <#[R10 + 16]> */
		/* 820F3920h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820F3920h case   14:*/		return 0x820F3924;
		  /* 820F3924h */ case   15:  		/* cmpwi CR6, R11, 11 */
		/* 820F3924h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820F3924h case   15:*/		return 0x820F3928;
		  /* 820F3928h */ case   16:  		/* bc 4, CR6_EQ, 24 */
		/* 820F3928h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820F3940;  }
		/* 820F3928h case   16:*/		return 0x820F392C;
		  /* 820F392Ch */ case   17:  		/* lwz R11, <#[R10 + 24]> */
		/* 820F392Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 820F392Ch case   17:*/		return 0x820F3930;
		  /* 820F3930h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 820F3930h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F3930h case   18:*/		return 0x820F3934;
		  /* 820F3934h */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 820F3934h case   19:*/		if ( regs.CR[6].eq ) { return 0x820F3940;  }
		/* 820F3934h case   19:*/		return 0x820F3938;
		  /* 820F3938h */ case   20:  		/* stwu R6, <#[R7 + 4]> */
		/* 820F3938h case   20:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820F3938h case   20:*/		return 0x820F393C;
		  /* 820F393Ch */ case   21:  		/* addi R17, R17, 1 */
		/* 820F393Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 820F393Ch case   21:*/		return 0x820F3940;
	}
	return 0x820F3940;
} // Block from 820F38E8h-820F3940h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F3940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3940);
		  /* 820F3940h */ case    0:  		/* addi R6, R6, 1 */
		/* 820F3940h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820F3940h case    0:*/		return 0x820F3944;
		  /* 820F3944h */ case    1:  		/* addi R8, R8, 4 */
		/* 820F3944h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820F3944h case    1:*/		return 0x820F3948;
		  /* 820F3948h */ case    2:  		/* bc 16, CR0_LT, -204 */
		/* 820F3948h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F387C;  }
		/* 820F3948h case    2:*/		return 0x820F394C;
	}
	return 0x820F394C;
} // Block from 820F3940h-820F394Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F394Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F394C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F394C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F394C);
		  /* 820F394Ch */ case    0:  		/* mr R7, R15 */
		/* 820F394Ch case    0:*/		regs.R7 = regs.R15;
		/* 820F394Ch case    0:*/		return 0x820F3950;
		  /* 820F3950h */ case    1:  		/* cmplwi CR6, R17, 0 */
		/* 820F3950h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 820F3950h case    1:*/		return 0x820F3954;
		  /* 820F3954h */ case    2:  		/* bc 12, CR6_EQ, 216 */
		/* 820F3954h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F3A2C;  }
		/* 820F3954h case    2:*/		return 0x820F3958;
		  /* 820F3958h */ case    3:  		/* mr R31, R26 */
		/* 820F3958h case    3:*/		regs.R31 = regs.R26;
		/* 820F3958h case    3:*/		return 0x820F395C;
		  /* 820F395Ch */ case    4:  		/* lwz R30, <#[R31]> */
		/* 820F395Ch case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 820F395Ch case    4:*/		return 0x820F3960;
		  /* 820F3960h */ case    5:  		/* mr R9, R15 */
		/* 820F3960h case    5:*/		regs.R9 = regs.R15;
		/* 820F3960h case    5:*/		return 0x820F3964;
		  /* 820F3964h */ case    6:  		/* cmplwi CR6, R7, 0 */
		/* 820F3964h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820F3964h case    6:*/		return 0x820F3968;
		  /* 820F3968h */ case    7:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820F3968h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820F3968h case    7:*/		return 0x820F396C;
		  /* 820F396Ch */ case    8:  		/* lwzx R4, <#[R11 + R19]> */
		/* 820F396Ch case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R19 + 0x00000000) );
		/* 820F396Ch case    8:*/		return 0x820F3970;
		  /* 820F3970h */ case    9:  		/* lwz R11, <#[R4 + 96]> */
		/* 820F3970h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000060) );
		/* 820F3970h case    9:*/		return 0x820F3974;
		  /* 820F3974h */ case   10:  		/* lwz R11, <#[R11 + 20]> */
		/* 820F3974h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820F3974h case   10:*/		return 0x820F3978;
		  /* 820F3978h */ case   11:  		/* lwz R3, <#[R11 + 24]> */
		/* 820F3978h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000018) );
		/* 820F3978h case   11:*/		return 0x820F397C;
		  /* 820F397Ch */ case   12:  		/* bc 12, CR6_EQ, 160 */
		/* 820F397Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820F3A1C;  }
		/* 820F397Ch case   12:*/		return 0x820F3980;
		  /* 820F3980h */ case   13:  		/* mr R5, R26 */
		/* 820F3980h case   13:*/		regs.R5 = regs.R26;
		/* 820F3980h case   13:*/		return 0x820F3984;
		  /* 820F3984h */ case   14:  		/* lwz R10, <#[R5]> */
		/* 820F3984h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 820F3984h case   14:*/		return 0x820F3988;
		  /* 820F3988h */ case   15:  		/* mr R11, R3 */
		/* 820F3988h case   15:*/		regs.R11 = regs.R3;
		/* 820F3988h case   15:*/		return 0x820F398C;
		  /* 820F398Ch */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F398Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F398Ch case   16:*/		return 0x820F3990;
		  /* 820F3990h */ case   17:  		/* lwzx R6, <#[R10 + R19]> */
		/* 820F3990h case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R19 + 0x00000000) );
		/* 820F3990h case   17:*/		return 0x820F3994;
		  /* 820F3994h */ case   18:  		/* lwz R10, <#[R6 + 96]> */
		/* 820F3994h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000060) );
		/* 820F3994h case   18:*/		return 0x820F3998;
		  /* 820F3998h */ case   19:  		/* lwz R10, <#[R10 + 20]> */
		/* 820F3998h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820F3998h case   19:*/		return 0x820F399C;
		  /* 820F399Ch */ case   20:  		/* lwz R10, <#[R10 + 24]> */
		/* 820F399Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 820F399Ch case   20:*/		return 0x820F39A0;
		  /* 820F39A0h */ case   21:  		/* lbz R8, <#[R11]> */
		/* 820F39A0h case   21:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820F39A0h case   21:*/		return 0x820F39A4;
		  /* 820F39A4h */ case   22:  		/* lbz R29, <#[R10]> */
		/* 820F39A4h case   22:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000000) );
		/* 820F39A4h case   22:*/		return 0x820F39A8;
		  /* 820F39A8h */ case   23:  		/* cmpwi CR0, R8, 0 */
		/* 820F39A8h case   23:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820F39A8h case   23:*/		return 0x820F39AC;
		  /* 820F39ACh */ case   24:  		/* subf R8, R29, R8 */
		/* 820F39ACh case   24:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R29,regs.R8);
		/* 820F39ACh case   24:*/		return 0x820F39B0;
		  /* 820F39B0h */ case   25:  		/* bc 12, CR0_EQ, 20 */
		/* 820F39B0h case   25:*/		if ( regs.CR[0].eq ) { return 0x820F39C4;  }
		/* 820F39B0h case   25:*/		return 0x820F39B4;
		  /* 820F39B4h */ case   26:  		/* addi R11, R11, 1 */
		/* 820F39B4h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F39B4h case   26:*/		return 0x820F39B8;
		  /* 820F39B8h */ case   27:  		/* addi R10, R10, 1 */
		/* 820F39B8h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F39B8h case   27:*/		return 0x820F39BC;
		  /* 820F39BCh */ case   28:  		/* cmpwi CR6, R8, 0 */
		/* 820F39BCh case   28:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820F39BCh case   28:*/		return 0x820F39C0;
		  /* 820F39C0h */ case   29:  		/* bc 12, CR6_EQ, -32 */
		/* 820F39C0h case   29:*/		if ( regs.CR[6].eq ) { return 0x820F39A0;  }
		/* 820F39C0h case   29:*/		return 0x820F39C4;
	}
	return 0x820F39C4;
} // Block from 820F394Ch-820F39C4h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820F39C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F39C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F39C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F39C4);
		  /* 820F39C4h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820F39C4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820F39C4h case    0:*/		return 0x820F39C8;
		  /* 820F39C8h */ case    1:  		/* bc 12, CR0_LT, 44 */
		/* 820F39C8h case    1:*/		if ( regs.CR[0].lt ) { return 0x820F39F4;  }
		/* 820F39C8h case    1:*/		return 0x820F39CC;
		  /* 820F39CCh */ case    2:  		/* cmpwi CR6, R8, 0 */
		/* 820F39CCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820F39CCh case    2:*/		return 0x820F39D0;
		  /* 820F39D0h */ case    3:  		/* bc 12, CR6_GT, 20 */
		/* 820F39D0h case    3:*/		if ( regs.CR[6].gt ) { return 0x820F39E4;  }
		/* 820F39D0h case    3:*/		return 0x820F39D4;
		  /* 820F39D4h */ case    4:  		/* lwz R11, <#[R4 + 4]> */
		/* 820F39D4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820F39D4h case    4:*/		return 0x820F39D8;
		  /* 820F39D8h */ case    5:  		/* lwz R10, <#[R6 + 4]> */
		/* 820F39D8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000004) );
		/* 820F39D8h case    5:*/		return 0x820F39DC;
		  /* 820F39DCh */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820F39DCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F39DCh case    6:*/		return 0x820F39E0;
		  /* 820F39E0h */ case    7:  		/* bc 12, CR6_LT, 20 */
		/* 820F39E0h case    7:*/		if ( regs.CR[6].lt ) { return 0x820F39F4;  }
		/* 820F39E0h case    7:*/		return 0x820F39E4;
	}
	return 0x820F39E4;
} // Block from 820F39C4h-820F39E4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820F39E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F39E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F39E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F39E4);
		  /* 820F39E4h */ case    0:  		/* addi R9, R9, 1 */
		/* 820F39E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F39E4h case    0:*/		return 0x820F39E8;
		  /* 820F39E8h */ case    1:  		/* addi R5, R5, 4 */
		/* 820F39E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 820F39E8h case    1:*/		return 0x820F39EC;
		  /* 820F39ECh */ case    2:  		/* cmplw CR6, R9, R7 */
		/* 820F39ECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 820F39ECh case    2:*/		return 0x820F39F0;
		  /* 820F39F0h */ case    3:  		/* bc 12, CR6_LT, -108 */
		/* 820F39F0h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F3984;  }
		/* 820F39F0h case    3:*/		return 0x820F39F4;
	}
	return 0x820F39F4;
} // Block from 820F39E4h-820F39F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F39F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F39F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F39F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F39F4);
		  /* 820F39F4h */ case    0:  		/* cmplw CR6, R7, R9 */
		/* 820F39F4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 820F39F4h case    0:*/		return 0x820F39F8;
		  /* 820F39F8h */ case    1:  		/* bc 4, CR6_GT, 36 */
		/* 820F39F8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820F3A1C;  }
		/* 820F39F8h case    1:*/		return 0x820F39FC;
		  /* 820F39FCh */ case    2:  		/* subf R10, R9, R7 */
		/* 820F39FCh case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R7);
		/* 820F39FCh case    2:*/		return 0x820F3A00;
		  /* 820F3A00h */ case    3:  		/* addi R11, R31, 4 */
		/* 820F3A00h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x4);
		/* 820F3A00h case    3:*/		return 0x820F3A04;
		  /* 820F3A04h */ case    4:  		/* mtspr CTR, R10 */
		/* 820F3A04h case    4:*/		regs.CTR = regs.R10;
		/* 820F3A04h case    4:*/		return 0x820F3A08;
		  /* 820F3A08h */ case    5:  		/* lwz R10, <#[R11 - 8]> */
		/* 820F3A08h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 820F3A08h case    5:*/		return 0x820F3A0C;
		  /* 820F3A0Ch */ case    6:  		/* stwu R10, <#[R11 - 4]> */
		/* 820F3A0Ch case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0xFFFFFFFC) );
		regs.R11 = (uint32)(regs.R11 + 0xFFFFFFFC);
		/* 820F3A0Ch case    6:*/		return 0x820F3A10;
		  /* 820F3A10h */ case    7:  		/* bc 16, CR0_LT, -8 */
		/* 820F3A10h case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F3A08;  }
		/* 820F3A10h case    7:*/		return 0x820F3A14;
		  /* 820F3A14h */ case    8:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 820F3A14h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 820F3A14h case    8:*/		return 0x820F3A18;
		  /* 820F3A18h */ case    9:  		/* stwx R30, <#[R11 + R26]> */
		/* 820F3A18h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 820F3A18h case    9:*/		return 0x820F3A1C;
	}
	return 0x820F3A1C;
} // Block from 820F39F4h-820F3A1Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F3A1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3A1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3A1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3A1C);
		  /* 820F3A1Ch */ case    0:  		/* addi R7, R7, 1 */
		/* 820F3A1Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820F3A1Ch case    0:*/		return 0x820F3A20;
		  /* 820F3A20h */ case    1:  		/* addi R31, R31, 4 */
		/* 820F3A20h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820F3A20h case    1:*/		return 0x820F3A24;
		  /* 820F3A24h */ case    2:  		/* cmplw CR6, R7, R17 */
		/* 820F3A24h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R17);
		/* 820F3A24h case    2:*/		return 0x820F3A28;
		  /* 820F3A28h */ case    3:  		/* bc 12, CR6_LT, -204 */
		/* 820F3A28h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F395C;  }
		/* 820F3A28h case    3:*/		return 0x820F3A2C;
	}
	return 0x820F3A2C;
} // Block from 820F3A1Ch-820F3A2Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F3A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3A2C);
		  /* 820F3A2Ch */ case    0:  		/* lwz R11, <#[R18]> */
		/* 820F3A2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 820F3A2Ch case    0:*/		return 0x820F3A30;
		  /* 820F3A30h */ case    1:  		/* mr R3, R18 */
		/* 820F3A30h case    1:*/		regs.R3 = regs.R18;
		/* 820F3A30h case    1:*/		return 0x820F3A34;
		  /* 820F3A34h */ case    2:  		/* lwz R11, <#[R11 + 352]> */
		/* 820F3A34h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000160) );
		/* 820F3A34h case    2:*/		return 0x820F3A38;
		  /* 820F3A38h */ case    3:  		/* mtspr CTR, R11 */
		/* 820F3A38h case    3:*/		regs.CTR = regs.R11;
		/* 820F3A38h case    3:*/		return 0x820F3A3C;
		  /* 820F3A3Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820F3A3Ch case    4:*/		if ( 1 ) { regs.LR = 0x820F3A40; return (uint32)regs.CTR; }
		/* 820F3A3Ch case    4:*/		return 0x820F3A40;
		  /* 820F3A40h */ case    5:  		/* add. R30, R3, R17 */
		/* 820F3A40h case    5:*/		cpu::op::add<1>(regs,&regs.R30,regs.R3,regs.R17);
		/* 820F3A40h case    5:*/		return 0x820F3A44;
		  /* 820F3A44h */ case    6:  		/* li R20, -1 */
		/* 820F3A44h case    6:*/		cpu::op::li<0>(regs,&regs.R20,0xFFFFFFFF);
		/* 820F3A44h case    6:*/		return 0x820F3A48;
		  /* 820F3A48h */ case    7:  		/* bc 12, CR0_EQ, 1500 */
		/* 820F3A48h case    7:*/		if ( regs.CR[0].eq ) { return 0x820F4024;  }
		/* 820F3A48h case    7:*/		return 0x820F3A4C;
		  /* 820F3A4Ch */ case    8:  		/* mulli R31, R30, 20 */
		/* 820F3A4Ch case    8:*/		cpu::op::mulli<0>(regs,&regs.R31,regs.R30,0x14);
		/* 820F3A4Ch case    8:*/		return 0x820F3A50;
		  /* 820F3A50h */ case    9:  		/* lis R4, 9345 */
		/* 820F3A50h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F3A50h case    9:*/		return 0x820F3A54;
		  /* 820F3A54h */ case   10:  		/* mr R3, R31 */
		/* 820F3A54h case   10:*/		regs.R3 = regs.R31;
		/* 820F3A54h case   10:*/		return 0x820F3A58;
		  /* 820F3A58h */ case   11:  		/* bl -440408 */
		/* 820F3A58h case   11:*/		regs.LR = 0x820F3A5C; return 0x82088200;
		/* 820F3A58h case   11:*/		return 0x820F3A5C;
		  /* 820F3A5Ch */ case   12:  		/* or. R25, R3, R3 */
		/* 820F3A5Ch case   12:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 820F3A5Ch case   12:*/		return 0x820F3A60;
		  /* 820F3A60h */ case   13:  		/* stw R25, <#[R1 + 88]> */
		/* 820F3A60h case   13:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000058) );
		/* 820F3A60h case   13:*/		return 0x820F3A64;
		  /* 820F3A64h */ case   14:  		/* bc 12, CR0_EQ, 1764 */
		/* 820F3A64h case   14:*/		if ( regs.CR[0].eq ) { return 0x820F4148;  }
		/* 820F3A64h case   14:*/		return 0x820F3A68;
		  /* 820F3A68h */ case   15:  		/* mr R5, R31 */
		/* 820F3A68h case   15:*/		regs.R5 = regs.R31;
		/* 820F3A68h case   15:*/		return 0x820F3A6C;
		  /* 820F3A6Ch */ case   16:  		/* li R4, 0 */
		/* 820F3A6Ch case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F3A6Ch case   16:*/		return 0x820F3A70;
		  /* 820F3A70h */ case   17:  		/* mr R3, R25 */
		/* 820F3A70h case   17:*/		regs.R3 = regs.R25;
		/* 820F3A70h case   17:*/		return 0x820F3A74;
		  /* 820F3A74h */ case   18:  		/* bl -403252 */
		/* 820F3A74h case   18:*/		regs.LR = 0x820F3A78; return 0x82091340;
		/* 820F3A74h case   18:*/		return 0x820F3A78;
		  /* 820F3A78h */ case   19:  		/* li R8, 2 */
		/* 820F3A78h case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 820F3A78h case   19:*/		return 0x820F3A7C;
		  /* 820F3A7Ch */ case   20:  		/* addi R7, R1, 144 */
		/* 820F3A7Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x90);
		/* 820F3A7Ch case   20:*/		return 0x820F3A80;
		  /* 820F3A80h */ case   21:  		/* li R6, 1 */
		/* 820F3A80h case   21:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F3A80h case   21:*/		return 0x820F3A84;
		  /* 820F3A84h */ case   22:  		/* mr R5, R31 */
		/* 820F3A84h case   22:*/		regs.R5 = regs.R31;
		/* 820F3A84h case   22:*/		return 0x820F3A88;
		  /* 820F3A88h */ case   23:  		/* mr R4, R25 */
		/* 820F3A88h case   23:*/		regs.R4 = regs.R25;
		/* 820F3A88h case   23:*/		return 0x820F3A8C;
		  /* 820F3A8Ch */ case   24:  		/* addi R3, R1, 96 */
		/* 820F3A8Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F3A8Ch case   24:*/		return 0x820F3A90;
		  /* 820F3A90h */ case   25:  		/* bl -153632 */
		/* 820F3A90h case   25:*/		regs.LR = 0x820F3A94; return 0x820CE270;
		/* 820F3A90h case   25:*/		return 0x820F3A94;
		  /* 820F3A94h */ case   26:  		/* or. R31, R3, R3 */
		/* 820F3A94h case   26:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F3A94h case   26:*/		return 0x820F3A98;
		  /* 820F3A98h */ case   27:  		/* bc 12, CR0_LT, 1752 */
		/* 820F3A98h case   27:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F3A98h case   27:*/		return 0x820F3A9C;
		  /* 820F3A9Ch */ case   28:  		/* stw R30, <#[R1 + 140]> */
		/* 820F3A9Ch case   28:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000008C) );
		/* 820F3A9Ch case   28:*/		return 0x820F3AA0;
		  /* 820F3AA0h */ case   29:  		/* mr R21, R15 */
		/* 820F3AA0h case   29:*/		regs.R21 = regs.R15;
		/* 820F3AA0h case   29:*/		return 0x820F3AA4;
		  /* 820F3AA4h */ case   30:  		/* cmplwi CR6, R17, 0 */
		/* 820F3AA4h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 820F3AA4h case   30:*/		return 0x820F3AA8;
		  /* 820F3AA8h */ case   31:  		/* bc 12, CR6_EQ, 1404 */
		/* 820F3AA8h case   31:*/		if ( regs.CR[6].eq ) { return 0x820F4024;  }
		/* 820F3AA8h case   31:*/		return 0x820F3AAC;
		  /* 820F3AACh */ case   32:  		/* lis R8, -32256 */
		/* 820F3AACh case   32:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 820F3AACh case   32:*/		return 0x820F3AB0;
		  /* 820F3AB0h */ case   33:  		/* lis R7, -32256 */
		/* 820F3AB0h case   33:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8200);
		/* 820F3AB0h case   33:*/		return 0x820F3AB4;
		  /* 820F3AB4h */ case   34:  		/* lis R6, -32256 */
		/* 820F3AB4h case   34:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8200);
		/* 820F3AB4h case   34:*/		return 0x820F3AB8;
		  /* 820F3AB8h */ case   35:  		/* lis R11, -32254 */
		/* 820F3AB8h case   35:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F3AB8h case   35:*/		return 0x820F3ABC;
		  /* 820F3ABCh */ case   36:  		/* lis R10, -32254 */
		/* 820F3ABCh case   36:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8202);
		/* 820F3ABCh case   36:*/		return 0x820F3AC0;
		  /* 820F3AC0h */ case   37:  		/* lfd FR29, <#[R8 + 1808]> */
		/* 820F3AC0h case   37:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R8 + 0x00000710) );
		/* 820F3AC0h case   37:*/		return 0x820F3AC4;
		  /* 820F3AC4h */ case   38:  		/* lis R9, -32254 */
		/* 820F3AC4h case   38:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8202);
		/* 820F3AC4h case   38:*/		return 0x820F3AC8;
		  /* 820F3AC8h */ case   39:  		/* lis R8, -32254 */
		/* 820F3AC8h case   39:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8202);
		/* 820F3AC8h case   39:*/		return 0x820F3ACC;
		  /* 820F3ACCh */ case   40:  		/* lfs FR30, <#[R7 + 1816]> */
		/* 820F3ACCh case   40:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R7 + 0x00000718) );
		/* 820F3ACCh case   40:*/		return 0x820F3AD0;
		  /* 820F3AD0h */ case   41:  		/* addi R27, R25, 4 */
		/* 820F3AD0h case   41:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R25,0x4);
		/* 820F3AD0h case   41:*/		return 0x820F3AD4;
		  /* 820F3AD4h */ case   42:  		/* lfs FR31, <#[R6 + 1792]> */
		/* 820F3AD4h case   42:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R6 + 0x00000700) );
		/* 820F3AD4h case   42:*/		return 0x820F3AD8;
		  /* 820F3AD8h */ case   43:  		/* addi R24, R11, -16020 */
		/* 820F3AD8h case   43:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0xFFFFC16C);
		/* 820F3AD8h case   43:*/		return 0x820F3ADC;
		  /* 820F3ADCh */ case   44:  		/* addi R23, R10, -16028 */
		/* 820F3ADCh case   44:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0xFFFFC164);
		/* 820F3ADCh case   44:*/		return 0x820F3AE0;
		  /* 820F3AE0h */ case   45:  		/* addi R22, R9, -16036 */
		/* 820F3AE0h case   45:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R9,0xFFFFC15C);
		/* 820F3AE0h case   45:*/		return 0x820F3AE4;
		  /* 820F3AE4h */ case   46:  		/* addi R25, R8, -16044 */
		/* 820F3AE4h case   46:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R8,0xFFFFC154);
		/* 820F3AE4h case   46:*/		return 0x820F3AE8;
		  /* 820F3AE8h */ case   47:  		/* lwz R11, <#[R26]> */
		/* 820F3AE8h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820F3AE8h case   47:*/		return 0x820F3AEC;
		  /* 820F3AECh */ case   48:  		/* lwz R9, <#[R18 + 348]> */
		/* 820F3AECh case   48:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R18 + 0x0000015C) );
		/* 820F3AECh case   48:*/		return 0x820F3AF0;
		  /* 820F3AF0h */ case   49:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F3AF0h case   49:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F3AF0h case   49:*/		return 0x820F3AF4;
		  /* 820F3AF4h */ case   50:  		/* lwz R10, <#[R18 + 16]> */
		/* 820F3AF4h case   50:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000010) );
		/* 820F3AF4h case   50:*/		return 0x820F3AF8;
		  /* 820F3AF8h */ case   51:  		/* cmpwi CR6, R9, 0 */
		/* 820F3AF8h case   51:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820F3AF8h case   51:*/		return 0x820F3AFC;
		  /* 820F3AFCh */ case   52:  		/* lwzx R11, <#[R11 + R19]> */
		/* 820F3AFCh case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R19 + 0x00000000) );
		/* 820F3AFCh case   52:*/		return 0x820F3B00;
		  /* 820F3B00h */ case   53:  		/* lwz R9, <#[R11 + 96]> */
		/* 820F3B00h case   53:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000060) );
		/* 820F3B00h case   53:*/		return 0x820F3B04;
		  /* 820F3B04h */ case   54:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F3B04h case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F3B04h case   54:*/		return 0x820F3B08;
		  /* 820F3B08h */ case   55:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F3B08h case   55:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F3B08h case   55:*/		return 0x820F3B0C;
		  /* 820F3B0Ch */ case   56:  		/* lwz R8, <#[R9 + 20]> */
		/* 820F3B0Ch case   56:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000014) );
		/* 820F3B0Ch case   56:*/		return 0x820F3B10;
	}
	return 0x820F3B10;
} // Block from 820F3A2Ch-820F3B10h (57 instructions)

//////////////////////////////////////////////////////
// Block at 820F3B10h
// Function '?Emit@CShaderProgram@D3DXShader@@IAAJK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3B10);
		  /* 820F3B10h */ case    0:  		/* lwz R28, <#[R9 + 24]> */
		/* 820F3B10h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R9 + 0x00000018) );
		/* 820F3B10h case    0:*/		return 0x820F3B14;
		  /* 820F3B14h */ case    1:  		/* lwzx R29, <#[R11 + R10]> */
		/* 820F3B14h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F3B14h case    1:*/		return 0x820F3B18;
		  /* 820F3B18h */ case    2:  		/* lwz R4, <#[R8 + 24]> */
		/* 820F3B18h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + 0x00000018) );
		/* 820F3B18h case    2:*/		return 0x820F3B1C;
		  /* 820F3B1Ch */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 820F3B1Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820F3B28;  }
		/* 820F3B1Ch case    3:*/		return 0x820F3B20;
		  /* 820F3B20h */ case    4:  		/* li R6, 7 */
		/* 820F3B20h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 820F3B20h case    4:*/		return 0x820F3B24;
		  /* 820F3B24h */ case    5:  		/* b 84 */
		/* 820F3B24h case    5:*/		return 0x820F3B78;
		/* 820F3B24h case    5:*/		return 0x820F3B28;
	}
	return 0x820F3B28;
} // Block from 820F3B10h-820F3B28h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F3B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3B28);
		  /* 820F3B28h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 820F3B28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820F3B28h case    0:*/		return 0x820F3B2C;
		  /* 820F3B2Ch */ case    1:  		/* mr R5, R25 */
		/* 820F3B2Ch case    1:*/		regs.R5 = regs.R25;
		/* 820F3B2Ch case    1:*/		return 0x820F3B30;
		  /* 820F3B30h */ case    2:  		/* rlwinm. R10, R11, 0, 18, 18 */
		/* 820F3B30h case    2:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R10,regs.R11);
		/* 820F3B30h case    2:*/		return 0x820F3B34;
		  /* 820F3B34h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 820F3B34h case    3:*/		if ( regs.CR[0].eq ) { return 0x820F3B40;  }
		/* 820F3B34h case    3:*/		return 0x820F3B38;
		  /* 820F3B38h */ case    4:  		/* mr R5, R22 */
		/* 820F3B38h case    4:*/		regs.R5 = regs.R22;
		/* 820F3B38h case    4:*/		return 0x820F3B3C;
		  /* 820F3B3Ch */ case    5:  		/* b 32 */
		/* 820F3B3Ch case    5:*/		return 0x820F3B5C;
		/* 820F3B3Ch case    5:*/		return 0x820F3B40;
	}
	return 0x820F3B40;
} // Block from 820F3B28h-820F3B40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F3B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3B40);
		  /* 820F3B40h */ case    0:  		/* rlwinm. R10, R11, 0, 13, 13 */
		/* 820F3B40h case    0:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R10,regs.R11);
		/* 820F3B40h case    0:*/		return 0x820F3B44;
		  /* 820F3B44h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820F3B44h case    1:*/		if ( regs.CR[0].eq ) { return 0x820F3B50;  }
		/* 820F3B44h case    1:*/		return 0x820F3B48;
		  /* 820F3B48h */ case    2:  		/* mr R5, R23 */
		/* 820F3B48h case    2:*/		regs.R5 = regs.R23;
		/* 820F3B48h case    2:*/		return 0x820F3B4C;
		  /* 820F3B4Ch */ case    3:  		/* b 16 */
		/* 820F3B4Ch case    3:*/		return 0x820F3B5C;
		/* 820F3B4Ch case    3:*/		return 0x820F3B50;
	}
	return 0x820F3B50;
} // Block from 820F3B40h-820F3B50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F3B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3B50);
		  /* 820F3B50h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 24 */
		/* 820F3B50h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R11);
		/* 820F3B50h case    0:*/		return 0x820F3B54;
		  /* 820F3B54h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 820F3B54h case    1:*/		if ( regs.CR[0].eq ) { return 0x820F3B5C;  }
		/* 820F3B54h case    1:*/		return 0x820F3B58;
		  /* 820F3B58h */ case    2:  		/* mr R5, R24 */
		/* 820F3B58h case    2:*/		regs.R5 = regs.R24;
		/* 820F3B58h case    2:*/		return 0x820F3B5C;
	}
	return 0x820F3B5C;
} // Block from 820F3B50h-820F3B5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F3B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3B5C);
		  /* 820F3B5Ch */ case    0:  		/* mr R6, R4 */
		/* 820F3B5Ch case    0:*/		regs.R6 = regs.R4;
		/* 820F3B5Ch case    0:*/		return 0x820F3B60;
		  /* 820F3B60h */ case    1:  		/* li R4, 255 */
		/* 820F3B60h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 820F3B60h case    1:*/		return 0x820F3B64;
		  /* 820F3B64h */ case    2:  		/* addi R3, R1, 192 */
		/* 820F3B64h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xC0);
		/* 820F3B64h case    2:*/		return 0x820F3B68;
		  /* 820F3B68h */ case    3:  		/* bl -333096 */
		/* 820F3B68h case    3:*/		regs.LR = 0x820F3B6C; return 0x820A2640;
		/* 820F3B68h case    3:*/		return 0x820F3B6C;
		  /* 820F3B6Ch */ case    4:  		/* stb R15, <#[R1 + 446]> */
		/* 820F3B6Ch case    4:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R1 + 0x000001BE) );
		/* 820F3B6Ch case    4:*/		return 0x820F3B70;
		  /* 820F3B70h */ case    5:  		/* li R6, 6 */
		/* 820F3B70h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x6);
		/* 820F3B70h case    5:*/		return 0x820F3B74;
		  /* 820F3B74h */ case    6:  		/* addi R4, R1, 192 */
		/* 820F3B74h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xC0);
		/* 820F3B74h case    6:*/		return 0x820F3B78;
	}
	return 0x820F3B78;
} // Block from 820F3B5Ch-820F3B78h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F3B78h
// Function '?EmitPreShader@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3B78);
		  /* 820F3B78h */ case    0:  		/* addi R30, R27, -4 */
		/* 820F3B78h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R27,0xFFFFFFFC);
		/* 820F3B78h case    0:*/		return 0x820F3B7C;
		  /* 820F3B7Ch */ case    1:  		/* li R8, 1 */
		/* 820F3B7Ch case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F3B7Ch case    1:*/		return 0x820F3B80;
		  /* 820F3B80h */ case    2:  		/* mr R7, R30 */
		/* 820F3B80h case    2:*/		regs.R7 = regs.R30;
		/* 820F3B80h case    2:*/		return 0x820F3B84;
		  /* 820F3B84h */ case    3:  		/* mr R5, R20 */
		/* 820F3B84h case    3:*/		regs.R5 = regs.R20;
		/* 820F3B84h case    3:*/		return 0x820F3B88;
		  /* 820F3B88h */ case    4:  		/* addi R3, R1, 96 */
		/* 820F3B88h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F3B88h case    4:*/		return 0x820F3B8C;
		  /* 820F3B8Ch */ case    5:  		/* bl -153884 */
		/* 820F3B8Ch case    5:*/		regs.LR = 0x820F3B90; return 0x820CE270;
		/* 820F3B8Ch case    5:*/		return 0x820F3B90;
		  /* 820F3B90h */ case    6:  		/* or. R31, R3, R3 */
		/* 820F3B90h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F3B90h case    6:*/		return 0x820F3B94;
		  /* 820F3B94h */ case    7:  		/* bc 12, CR0_LT, 1500 */
		/* 820F3B94h case    7:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F3B94h case    7:*/		return 0x820F3B98;
		  /* 820F3B98h */ case    8:  		/* lwz R9, <#[R26]> */
		/* 820F3B98h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000000) );
		/* 820F3B98h case    8:*/		return 0x820F3B9C;
		  /* 820F3B9Ch */ case    9:  		/* li R10, 1 */
		/* 820F3B9Ch case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820F3B9Ch case    9:*/		return 0x820F3BA0;
		  /* 820F3BA0h */ case   10:  		/* addi R11, R9, 1 */
		/* 820F3BA0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x1);
		/* 820F3BA0h case   10:*/		return 0x820F3BA4;
		  /* 820F3BA4h */ case   11:  		/* b 156 */
		/* 820F3BA4h case   11:*/		return 0x820F3C40;
		/* 820F3BA4h case   11:*/		return 0x820F3BA8;
		  /* 820F3BA8h */ case   12:  		/* lwz R11, <#[R26]> */
		/* 820F3BA8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820F3BA8h case   12:*/		return 0x820F3BAC;
		  /* 820F3BACh */ case   13:  		/* add R8, R10, R11 */
		/* 820F3BACh case   13:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 820F3BACh case   13:*/		return 0x820F3BB0;
		  /* 820F3BB0h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F3BB0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F3BB0h case   14:*/		return 0x820F3BB4;
		  /* 820F3BB4h */ case   15:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820F3BB4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820F3BB4h case   15:*/		return 0x820F3BB8;
		  /* 820F3BB8h */ case   16:  		/* lwzx R11, <#[R11 + R19]> */
		/* 820F3BB8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R19 + 0x00000000) );
		/* 820F3BB8h case   16:*/		return 0x820F3BBC;
		  /* 820F3BBCh */ case   17:  		/* lwzx R8, <#[R8 + R19]> */
		/* 820F3BBCh case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R19 + 0x00000000) );
		/* 820F3BBCh case   17:*/		return 0x820F3BC0;
		  /* 820F3BC0h */ case   18:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F3BC0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F3BC0h case   18:*/		return 0x820F3BC4;
		  /* 820F3BC4h */ case   19:  		/* lwz R8, <#[R8 + 4]> */
		/* 820F3BC4h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 820F3BC4h case   19:*/		return 0x820F3BC8;
		  /* 820F3BC8h */ case   20:  		/* cmplw CR6, R11, R8 */
		/* 820F3BC8h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820F3BC8h case   20:*/		return 0x820F3BCC;
		  /* 820F3BCCh */ case   21:  		/* bc 4, CR6_EQ, 124 */
		/* 820F3BCCh case   21:*/		if ( !regs.CR[6].eq ) { return 0x820F3C48;  }
		/* 820F3BCCh case   21:*/		return 0x820F3BD0;
		  /* 820F3BD0h */ case   22:  		/* lwz R11, <#[R26]> */
		/* 820F3BD0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820F3BD0h case   22:*/		return 0x820F3BD4;
		  /* 820F3BD4h */ case   23:  		/* add R8, R10, R11 */
		/* 820F3BD4h case   23:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 820F3BD4h case   23:*/		return 0x820F3BD8;
		  /* 820F3BD8h */ case   24:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F3BD8h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F3BD8h case   24:*/		return 0x820F3BDC;
		  /* 820F3BDCh */ case   25:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820F3BDCh case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820F3BDCh case   25:*/		return 0x820F3BE0;
		  /* 820F3BE0h */ case   26:  		/* lwzx R11, <#[R11 + R19]> */
		/* 820F3BE0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R19 + 0x00000000) );
		/* 820F3BE0h case   26:*/		return 0x820F3BE4;
		  /* 820F3BE4h */ case   27:  		/* lwzx R8, <#[R8 + R19]> */
		/* 820F3BE4h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R19 + 0x00000000) );
		/* 820F3BE4h case   27:*/		return 0x820F3BE8;
		  /* 820F3BE8h */ case   28:  		/* lwz R11, <#[R11 + 96]> */
		/* 820F3BE8h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 820F3BE8h case   28:*/		return 0x820F3BEC;
		  /* 820F3BECh */ case   29:  		/* lwz R8, <#[R8 + 96]> */
		/* 820F3BECh case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000060) );
		/* 820F3BECh case   29:*/		return 0x820F3BF0;
		  /* 820F3BF0h */ case   30:  		/* cmplw CR6, R11, R8 */
		/* 820F3BF0h case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820F3BF0h case   30:*/		return 0x820F3BF4;
		  /* 820F3BF4h */ case   31:  		/* bc 4, CR6_EQ, 84 */
		/* 820F3BF4h case   31:*/		if ( !regs.CR[6].eq ) { return 0x820F3C48;  }
		/* 820F3BF4h case   31:*/		return 0x820F3BF8;
		  /* 820F3BF8h */ case   32:  		/* lwz R11, <#[R26]> */
		/* 820F3BF8h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820F3BF8h case   32:*/		return 0x820F3BFC;
		  /* 820F3BFCh */ case   33:  		/* add R8, R11, R10 */
		/* 820F3BFCh case   33:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R10);
		/* 820F3BFCh case   33:*/		return 0x820F3C00;
		  /* 820F3C00h */ case   34:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F3C00h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F3C00h case   34:*/		return 0x820F3C04;
		  /* 820F3C04h */ case   35:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820F3C04h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820F3C04h case   35:*/		return 0x820F3C08;
		  /* 820F3C08h */ case   36:  		/* lwzx R11, <#[R11 + R19]> */
		/* 820F3C08h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R19 + 0x00000000) );
		/* 820F3C08h case   36:*/		return 0x820F3C0C;
		  /* 820F3C0Ch */ case   37:  		/* lwzx R8, <#[R8 + R19]> */
		/* 820F3C0Ch case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R19 + 0x00000000) );
		/* 820F3C0Ch case   37:*/		return 0x820F3C10;
		  /* 820F3C10h */ case   38:  		/* lwz R7, <#[R11 + 112]> */
		/* 820F3C10h case   38:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000070) );
		/* 820F3C10h case   38:*/		return 0x820F3C14;
		  /* 820F3C14h */ case   39:  		/* lwz R6, <#[R8 + 112]> */
		/* 820F3C14h case   39:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000070) );
		/* 820F3C14h case   39:*/		return 0x820F3C18;
		  /* 820F3C18h */ case   40:  		/* lwz R11, <#[R11 + 12]> */
		/* 820F3C18h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F3C18h case   40:*/		return 0x820F3C1C;
		  /* 820F3C1Ch */ case   41:  		/* rlwinm R7, R7, 30, 2, 31 */
		/* 820F3C1Ch case   41:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R7,regs.R7);
		/* 820F3C1Ch case   41:*/		return 0x820F3C20;
		  /* 820F3C20h */ case   42:  		/* lwz R8, <#[R8 + 12]> */
		/* 820F3C20h case   42:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 820F3C20h case   42:*/		return 0x820F3C24;
		  /* 820F3C24h */ case   43:  		/* rlwinm R6, R6, 30, 2, 31 */
		/* 820F3C24h case   43:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R6,regs.R6);
		/* 820F3C24h case   43:*/		return 0x820F3C28;
		  /* 820F3C28h */ case   44:  		/* subf R11, R7, R11 */
		/* 820F3C28h case   44:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 820F3C28h case   44:*/		return 0x820F3C2C;
		  /* 820F3C2Ch */ case   45:  		/* subf R8, R6, R8 */
		/* 820F3C2Ch case   45:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R6,regs.R8);
		/* 820F3C2Ch case   45:*/		return 0x820F3C30;
		  /* 820F3C30h */ case   46:  		/* cmplw CR6, R11, R8 */
		/* 820F3C30h case   46:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820F3C30h case   46:*/		return 0x820F3C34;
		  /* 820F3C34h */ case   47:  		/* bc 4, CR6_EQ, 20 */
		/* 820F3C34h case   47:*/		if ( !regs.CR[6].eq ) { return 0x820F3C48;  }
		/* 820F3C34h case   47:*/		return 0x820F3C38;
		  /* 820F3C38h */ case   48:  		/* addi R10, R10, 1 */
		/* 820F3C38h case   48:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F3C38h case   48:*/		return 0x820F3C3C;
		  /* 820F3C3Ch */ case   49:  		/* add R11, R9, R10 */
		/* 820F3C3Ch case   49:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 820F3C3Ch case   49:*/		return 0x820F3C40;
	}
	return 0x820F3C40;
} // Block from 820F3B78h-820F3C40h (50 instructions)

//////////////////////////////////////////////////////
// Block at 820F3C40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3C40);
		  /* 820F3C40h */ case    0:  		/* cmplw CR6, R11, R16 */
		/* 820F3C40h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 820F3C40h case    0:*/		return 0x820F3C44;
		  /* 820F3C44h */ case    1:  		/* bc 12, CR6_LT, -156 */
		/* 820F3C44h case    1:*/		if ( regs.CR[6].lt ) { return 0x820F3BA8;  }
		/* 820F3C44h case    1:*/		return 0x820F3C48;
	}
	return 0x820F3C48;
} // Block from 820F3C40h-820F3C48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F3C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3C48);
		  /* 820F3C48h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 820F3C48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820F3C48h case    0:*/		return 0x820F3C4C;
		  /* 820F3C4Ch */ case    1:  		/* rlwinm. R9, R11, 0, 24, 24 */
		/* 820F3C4Ch case    1:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R9,regs.R11);
		/* 820F3C4Ch case    1:*/		return 0x820F3C50;
		  /* 820F3C50h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 820F3C50h case    2:*/		if ( regs.CR[0].eq ) { return 0x820F3C5C;  }
		/* 820F3C50h case    2:*/		return 0x820F3C54;
		  /* 820F3C54h */ case    3:  		/* li R11, 3 */
		/* 820F3C54h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820F3C54h case    3:*/		return 0x820F3C58;
		  /* 820F3C58h */ case    4:  		/* b 36 */
		/* 820F3C58h case    4:*/		return 0x820F3C7C;
		/* 820F3C58h case    4:*/		return 0x820F3C5C;
	}
	return 0x820F3C5C;
} // Block from 820F3C48h-820F3C5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F3C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3C5C);
		  /* 820F3C5Ch */ case    0:  		/* rlwinm. R9, R11, 0, 18, 18 */
		/* 820F3C5Ch case    0:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R9,regs.R11);
		/* 820F3C5Ch case    0:*/		return 0x820F3C60;
		  /* 820F3C60h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820F3C60h case    1:*/		if ( regs.CR[0].eq ) { return 0x820F3C6C;  }
		/* 820F3C60h case    1:*/		return 0x820F3C64;
		  /* 820F3C64h */ case    2:  		/* mr R11, R15 */
		/* 820F3C64h case    2:*/		regs.R11 = regs.R15;
		/* 820F3C64h case    2:*/		return 0x820F3C68;
		  /* 820F3C68h */ case    3:  		/* b 20 */
		/* 820F3C68h case    3:*/		return 0x820F3C7C;
		/* 820F3C68h case    3:*/		return 0x820F3C6C;
	}
	return 0x820F3C6C;
} // Block from 820F3C5Ch-820F3C6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F3C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3C6C);
		  /* 820F3C6Ch */ case    0:  		/* rlwinm R11, R11, 0, 13, 13 */
		/* 820F3C6Ch case    0:*/		cpu::op::rlwinm<0,0,13,13>(regs,&regs.R11,regs.R11);
		/* 820F3C6Ch case    0:*/		return 0x820F3C70;
		  /* 820F3C70h */ case    1:  		/* cntlzw R11, R11 */
		/* 820F3C70h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820F3C70h case    1:*/		return 0x820F3C74;
		  /* 820F3C74h */ case    2:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 820F3C74h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820F3C74h case    2:*/		return 0x820F3C78;
		  /* 820F3C78h */ case    3:  		/* addi R11, R11, 1 */
		/* 820F3C78h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F3C78h case    3:*/		return 0x820F3C7C;
	}
	return 0x820F3C7C;
} // Block from 820F3C6Ch-820F3C7Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F3C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3C7C);
		  /* 820F3C7Ch */ case    0:  		/* sth R11, <#[R27]> */
		/* 820F3C7Ch case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820F3C7Ch case    0:*/		return 0x820F3C80;
		  /* 820F3C80h */ case    1:  		/* addi R11, R27, 4 */
		/* 820F3C80h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x4);
		/* 820F3C80h case    1:*/		return 0x820F3C84;
		  /* 820F3C84h */ case    2:  		/* lwz R9, <#[R26]> */
		/* 820F3C84h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000000) );
		/* 820F3C84h case    2:*/		return 0x820F3C88;
		  /* 820F3C88h */ case    3:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F3C88h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F3C88h case    3:*/		return 0x820F3C8C;
		  /* 820F3C8Ch */ case    4:  		/* lwzx R9, <#[R9 + R19]> */
		/* 820F3C8Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R19 + 0x00000000) );
		/* 820F3C8Ch case    4:*/		return 0x820F3C90;
		  /* 820F3C90h */ case    5:  		/* lwz R8, <#[R9 + 12]> */
		/* 820F3C90h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 820F3C90h case    5:*/		return 0x820F3C94;
		  /* 820F3C94h */ case    6:  		/* lwz R9, <#[R9 + 112]> */
		/* 820F3C94h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000070) );
		/* 820F3C94h case    6:*/		return 0x820F3C98;
		  /* 820F3C98h */ case    7:  		/* rlwinm R9, R9, 30, 2, 31 */
		/* 820F3C98h case    7:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R9,regs.R9);
		/* 820F3C98h case    7:*/		return 0x820F3C9C;
		  /* 820F3C9Ch */ case    8:  		/* subf R9, R9, R8 */
		/* 820F3C9Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820F3C9Ch case    8:*/		return 0x820F3CA0;
		  /* 820F3CA0h */ case    9:  		/* sth R10, <#[R27 + 4]> */
		/* 820F3CA0h case    9:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R27 + 0x00000004) );
		/* 820F3CA0h case    9:*/		return 0x820F3CA4;
		  /* 820F3CA4h */ case   10:  		/* sth R9, <#[R27 + 2]> */
		/* 820F3CA4h case   10:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R27 + 0x00000002) );
		/* 820F3CA4h case   10:*/		return 0x820F3CA8;
		  /* 820F3CA8h */ case   11:  		/* lwz R4, <#[R28 + 48]> */
		/* 820F3CA8h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000030) );
		/* 820F3CA8h case   11:*/		return 0x820F3CAC;
		  /* 820F3CACh */ case   12:  		/* cmplwi CR6, R4, 0 */
		/* 820F3CACh case   12:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F3CACh case   12:*/		return 0x820F3CB0;
		  /* 820F3CB0h */ case   13:  		/* bc 12, CR6_EQ, 48 */
		/* 820F3CB0h case   13:*/		if ( regs.CR[6].eq ) { return 0x820F3CE0;  }
		/* 820F3CB0h case   13:*/		return 0x820F3CB4;
		  /* 820F3CB4h */ case   14:  		/* lwz R10, <#[R26]> */
		/* 820F3CB4h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820F3CB4h case   14:*/		return 0x820F3CB8;
		  /* 820F3CB8h */ case   15:  		/* addi R7, R11, 4 */
		/* 820F3CB8h case   15:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x4);
		/* 820F3CB8h case   15:*/		return 0x820F3CBC;
		  /* 820F3CBCh */ case   16:  		/* li R5, 1 */
		/* 820F3CBCh case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820F3CBCh case   16:*/		return 0x820F3CC0;
		  /* 820F3CC0h */ case   17:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 820F3CC0h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 820F3CC0h case   17:*/		return 0x820F3CC4;
		  /* 820F3CC4h */ case   18:  		/* addi R3, R1, 96 */
		/* 820F3CC4h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F3CC4h case   18:*/		return 0x820F3CC8;
		  /* 820F3CC8h */ case   19:  		/* lwzx R11, <#[R11 + R19]> */
		/* 820F3CC8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R19 + 0x00000000) );
		/* 820F3CC8h case   19:*/		return 0x820F3CCC;
		  /* 820F3CCCh */ case   20:  		/* lwz R11, <#[R11 + 60]> */
		/* 820F3CCCh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F3CCCh case   20:*/		return 0x820F3CD0;
		  /* 820F3CD0h */ case   21:  		/* rlwinm R6, R11, 0, 8, 10 */
		/* 820F3CD0h case   21:*/		cpu::op::rlwinm<0,0,8,10>(regs,&regs.R6,regs.R11);
		/* 820F3CD0h case   21:*/		return 0x820F3CD4;
		  /* 820F3CD4h */ case   22:  		/* bl -9820 */
		/* 820F3CD4h case   22:*/		regs.LR = 0x820F3CD8; return 0x820F1678;
		/* 820F3CD4h case   22:*/		return 0x820F3CD8;
		  /* 820F3CD8h */ case   23:  		/* or. R31, R3, R3 */
		/* 820F3CD8h case   23:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F3CD8h case   23:*/		return 0x820F3CDC;
		  /* 820F3CDCh */ case   24:  		/* bc 12, CR0_LT, 1172 */
		/* 820F3CDCh case   24:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F3CDCh case   24:*/		return 0x820F3CE0;
	}
	return 0x820F3CE0;
} // Block from 820F3C7Ch-820F3CE0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820F3CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3CE0);
		  /* 820F3CE0h */ case    0:  		/* lwz R11, <#[R28 + 64]> */
		/* 820F3CE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000040) );
		/* 820F3CE0h case    0:*/		return 0x820F3CE4;
		  /* 820F3CE4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820F3CE4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F3CE4h case    1:*/		return 0x820F3CE8;
		  /* 820F3CE8h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820F3CE8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F3D10;  }
		/* 820F3CE8h case    2:*/		return 0x820F3CEC;
		  /* 820F3CECh */ case    3:  		/* lwz R11, <#[R18]> */
		/* 820F3CECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 820F3CECh case    3:*/		return 0x820F3CF0;
		  /* 820F3CF0h */ case    4:  		/* mr R5, R30 */
		/* 820F3CF0h case    4:*/		regs.R5 = regs.R30;
		/* 820F3CF0h case    4:*/		return 0x820F3CF4;
		  /* 820F3CF4h */ case    5:  		/* mr R4, R28 */
		/* 820F3CF4h case    5:*/		regs.R4 = regs.R28;
		/* 820F3CF4h case    5:*/		return 0x820F3CF8;
		  /* 820F3CF8h */ case    6:  		/* mr R3, R18 */
		/* 820F3CF8h case    6:*/		regs.R3 = regs.R18;
		/* 820F3CF8h case    6:*/		return 0x820F3CFC;
		  /* 820F3CFCh */ case    7:  		/* lwz R11, <#[R11 + 360]> */
		/* 820F3CFCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000168) );
		/* 820F3CFCh case    7:*/		return 0x820F3D00;
		  /* 820F3D00h */ case    8:  		/* mtspr CTR, R11 */
		/* 820F3D00h case    8:*/		regs.CTR = regs.R11;
		/* 820F3D00h case    8:*/		return 0x820F3D04;
		  /* 820F3D04h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820F3D04h case    9:*/		if ( 1 ) { regs.LR = 0x820F3D08; return (uint32)regs.CTR; }
		/* 820F3D04h case    9:*/		return 0x820F3D08;
	}
	return 0x820F3D08;
} // Block from 820F3CE0h-820F3D08h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F3D08h
// Function '?EmitSymbolTable@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3D08);
		  /* 820F3D08h */ case    0:  		/* or. R31, R3, R3 */
		/* 820F3D08h case    0:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F3D08h case    0:*/		return 0x820F3D0C;
		  /* 820F3D0Ch */ case    1:  		/* bc 12, CR0_LT, 1124 */
		/* 820F3D0Ch case    1:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F3D0Ch case    1:*/		return 0x820F3D10;
	}
	return 0x820F3D10;
} // Block from 820F3D08h-820F3D10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F3D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3D10);
		  /* 820F3D10h */ case    0:  		/* lwz R11, <#[R28 + 76]> */
		/* 820F3D10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000004C) );
		/* 820F3D10h case    0:*/		return 0x820F3D14;
		  /* 820F3D14h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820F3D14h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F3D14h case    1:*/		return 0x820F3D18;
		  /* 820F3D18h */ case    2:  		/* bc 12, CR6_EQ, 756 */
		/* 820F3D18h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F400C;  }
		/* 820F3D18h case    2:*/		return 0x820F3D1C;
		  /* 820F3D1Ch */ case    3:  		/* lhz R10, <#[R27]> */
		/* 820F3D1Ch case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 820F3D1Ch case    3:*/		return 0x820F3D20;
		  /* 820F3D20h */ case    4:  		/* cmplwi CR6, R10, 1 */
		/* 820F3D20h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820F3D20h case    4:*/		return 0x820F3D24;
		  /* 820F3D24h */ case    5:  		/* bc 4, CR6_EQ, 256 */
		/* 820F3D24h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820F3E24;  }
		/* 820F3D24h case    5:*/		return 0x820F3D28;
		  /* 820F3D28h */ case    6:  		/* addi R11, R11, 3 */
		/* 820F3D28h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820F3D28h case    6:*/		return 0x820F3D2C;
		  /* 820F3D2Ch */ case    7:  		/* lis R4, 9345 */
		/* 820F3D2Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F3D2Ch case    7:*/		return 0x820F3D30;
		  /* 820F3D30h */ case    8:  		/* rlwinm R31, R11, 0, 0, 29 */
		/* 820F3D30h case    8:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R31,regs.R11);
		/* 820F3D30h case    8:*/		return 0x820F3D34;
		  /* 820F3D34h */ case    9:  		/* rlwinm R30, R31, 2, 0, 29 */
		/* 820F3D34h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R31);
		/* 820F3D34h case    9:*/		return 0x820F3D38;
		  /* 820F3D38h */ case   10:  		/* mr R3, R30 */
		/* 820F3D38h case   10:*/		regs.R3 = regs.R30;
		/* 820F3D38h case   10:*/		return 0x820F3D3C;
		  /* 820F3D3Ch */ case   11:  		/* bl -441148 */
		/* 820F3D3Ch case   11:*/		regs.LR = 0x820F3D40; return 0x82088200;
		/* 820F3D3Ch case   11:*/		return 0x820F3D40;
		  /* 820F3D40h */ case   12:  		/* or. R14, R3, R3 */
		/* 820F3D40h case   12:*/		cpu::op::or<1>(regs,&regs.R14,regs.R3,regs.R3);
		/* 820F3D40h case   12:*/		return 0x820F3D44;
		  /* 820F3D44h */ case   13:  		/* bc 12, CR0_EQ, 1028 */
		/* 820F3D44h case   13:*/		if ( regs.CR[0].eq ) { return 0x820F4148;  }
		/* 820F3D44h case   13:*/		return 0x820F3D48;
		  /* 820F3D48h */ case   14:  		/* mr R5, R30 */
		/* 820F3D48h case   14:*/		regs.R5 = regs.R30;
		/* 820F3D48h case   14:*/		return 0x820F3D4C;
		  /* 820F3D4Ch */ case   15:  		/* li R4, 0 */
		/* 820F3D4Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F3D4Ch case   15:*/		return 0x820F3D50;
		  /* 820F3D50h */ case   16:  		/* mr R3, R14 */
		/* 820F3D50h case   16:*/		regs.R3 = regs.R14;
		/* 820F3D50h case   16:*/		return 0x820F3D54;
		  /* 820F3D54h */ case   17:  		/* bl -403988 */
		/* 820F3D54h case   17:*/		regs.LR = 0x820F3D58; return 0x82091340;
		/* 820F3D54h case   17:*/		return 0x820F3D58;
		  /* 820F3D58h */ case   18:  		/* rlwinm. R10, R31, 30, 2, 31 */
		/* 820F3D58h case   18:*/		cpu::op::rlwinm<1,30,2,31>(regs,&regs.R10,regs.R31);
		/* 820F3D58h case   18:*/		return 0x820F3D5C;
		  /* 820F3D5Ch */ case   19:  		/* mr R11, R15 */
		/* 820F3D5Ch case   19:*/		regs.R11 = regs.R15;
		/* 820F3D5Ch case   19:*/		return 0x820F3D60;
		  /* 820F3D60h */ case   20:  		/* bc 12, CR0_EQ, 28 */
		/* 820F3D60h case   20:*/		if ( regs.CR[0].eq ) { return 0x820F3D7C;  }
		/* 820F3D60h case   20:*/		return 0x820F3D64;
		  /* 820F3D64h */ case   21:  		/* addi R9, R14, -8 */
		/* 820F3D64h case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R14,0xFFFFFFF8);
		/* 820F3D64h case   21:*/		return 0x820F3D68;
		  /* 820F3D68h */ case   22:  		/* addi R11, R11, 1 */
		/* 820F3D68h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F3D68h case   22:*/		return 0x820F3D6C;
		  /* 820F3D6Ch */ case   23:  		/* li R8, 1 */
		/* 820F3D6Ch case   23:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F3D6Ch case   23:*/		return 0x820F3D70;
		  /* 820F3D70h */ case   24:  		/* cmplw CR6, R11, R10 */
		/* 820F3D70h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F3D70h case   24:*/		return 0x820F3D74;
		  /* 820F3D74h */ case   25:  		/* stwu R8, <#[R9 + 16]> */
		/* 820F3D74h case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000010) );
		regs.R9 = (uint32)(regs.R9 + 0x00000010);
		/* 820F3D74h case   25:*/		return 0x820F3D78;
		  /* 820F3D78h */ case   26:  		/* bc 12, CR6_LT, -16 */
		/* 820F3D78h case   26:*/		if ( regs.CR[6].lt ) { return 0x820F3D68;  }
		/* 820F3D78h case   26:*/		return 0x820F3D7C;
	}
	return 0x820F3D7C;
} // Block from 820F3D10h-820F3D7Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 820F3D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3D7C);
		  /* 820F3D7Ch */ case    0:  		/* lwz R11, <#[R28 + 76]> */
		/* 820F3D7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000004C) );
		/* 820F3D7Ch case    0:*/		return 0x820F3D80;
		  /* 820F3D80h */ case    1:  		/* mr R8, R15 */
		/* 820F3D80h case    1:*/		regs.R8 = regs.R15;
		/* 820F3D80h case    1:*/		return 0x820F3D84;
		  /* 820F3D84h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820F3D84h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F3D84h case    2:*/		return 0x820F3D88;
		  /* 820F3D88h */ case    3:  		/* bc 4, CR6_GT, 112 */
		/* 820F3D88h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820F3DF8;  }
		/* 820F3D88h case    3:*/		return 0x820F3D8C;
		  /* 820F3D8Ch */ case    4:  		/* mr R11, R15 */
		/* 820F3D8Ch case    4:*/		regs.R11 = regs.R15;
		/* 820F3D8Ch case    4:*/		return 0x820F3D90;
		  /* 820F3D90h */ case    5:  		/* lwz R10, <#[R28 + 80]> */
		/* 820F3D90h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000050) );
		/* 820F3D90h case    5:*/		return 0x820F3D94;
		  /* 820F3D94h */ case    6:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820F3D94h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F3D94h case    6:*/		return 0x820F3D98;
		  /* 820F3D98h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 820F3D98h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F3D98h case    7:*/		return 0x820F3D9C;
		  /* 820F3D9Ch */ case    8:  		/* bc 12, CR6_EQ, 72 */
		/* 820F3D9Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820F3DE4;  }
		/* 820F3D9Ch case    8:*/		return 0x820F3DA0;
		  /* 820F3DA0h */ case    9:  		/* lwz R9, <#[R10]> */
		/* 820F3DA0h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820F3DA0h case    9:*/		return 0x820F3DA4;
		  /* 820F3DA4h */ case   10:  		/* cmplwi CR6, R9, 1 */
		/* 820F3DA4h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820F3DA4h case   10:*/		return 0x820F3DA8;
		  /* 820F3DA8h */ case   11:  		/* bc 12, CR6_LT, 44 */
		/* 820F3DA8h case   11:*/		if ( regs.CR[6].lt ) { return 0x820F3DD4;  }
		/* 820F3DA8h case   11:*/		return 0x820F3DAC;
		  /* 820F3DACh */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 820F3DACh case   12:*/		if ( regs.CR[6].eq ) { return 0x820F3DCC;  }
		/* 820F3DACh case   12:*/		return 0x820F3DB0;
		  /* 820F3DB0h */ case   13:  		/* cmplwi CR6, R9, 3 */
		/* 820F3DB0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000003);
		/* 820F3DB0h case   13:*/		return 0x820F3DB4;
		  /* 820F3DB4h */ case   14:  		/* bc 12, CR6_LT, 24 */
		/* 820F3DB4h case   14:*/		if ( regs.CR[6].lt ) { return 0x820F3DCC;  }
		/* 820F3DB4h case   14:*/		return 0x820F3DB8;
		  /* 820F3DB8h */ case   15:  		/* bc 4, CR6_EQ, 44 */
		/* 820F3DB8h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820F3DE4;  }
		/* 820F3DB8h case   15:*/		return 0x820F3DBC;
		  /* 820F3DBCh */ case   16:  		/* lfd FR0, <#[R10 + 8]> */
		/* 820F3DBCh case   16:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000008) );
		/* 820F3DBCh case   16:*/		return 0x820F3DC0;
		  /* 820F3DC0h */ case   17:  		/* fctiwz FR0, FR0 */
		/* 820F3DC0h case   17:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 820F3DC0h case   17:*/		return 0x820F3DC4;
		  /* 820F3DC4h */ case   18:  		/* stfiwx FR0, <#[R11 + R14]> */
		/* 820F3DC4h case   18:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R11 + regs.R14 + 0x00000000) );
		/* 820F3DC4h case   18:*/		return 0x820F3DC8;
		  /* 820F3DC8h */ case   19:  		/* b 28 */
		/* 820F3DC8h case   19:*/		return 0x820F3DE4;
		/* 820F3DC8h case   19:*/		return 0x820F3DCC;
	}
	return 0x820F3DCC;
} // Block from 820F3D7Ch-820F3DCCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 820F3DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3DCC);
		  /* 820F3DCCh */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 820F3DCCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820F3DCCh case    0:*/		return 0x820F3DD0;
		  /* 820F3DD0h */ case    1:  		/* b 16 */
		/* 820F3DD0h case    1:*/		return 0x820F3DE0;
		/* 820F3DD0h case    1:*/		return 0x820F3DD4;
	}
	return 0x820F3DD4;
} // Block from 820F3DCCh-820F3DD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F3DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3DD4);
		  /* 820F3DD4h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 820F3DD4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820F3DD4h case    0:*/		return 0x820F3DD8;
		  /* 820F3DD8h */ case    1:  		/* addic R9, R10, -1 */
		/* 820F3DD8h case    1:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 820F3DD8h case    1:*/		return 0x820F3DDC;
		  /* 820F3DDCh */ case    2:  		/* subfe R10, R9, R10 */
		/* 820F3DDCh case    2:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820F3DDCh case    2:*/		return 0x820F3DE0;
	}
	return 0x820F3DE0;
} // Block from 820F3DD4h-820F3DE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F3DE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3DE0);
		  /* 820F3DE0h */ case    0:  		/* stwx R10, <#[R11 + R14]> */
		/* 820F3DE0h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R14 + 0x00000000) );
		/* 820F3DE0h case    0:*/		return 0x820F3DE4;
	}
	return 0x820F3DE4;
} // Block from 820F3DE0h-820F3DE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F3DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3DE4);
		  /* 820F3DE4h */ case    0:  		/* lwz R10, <#[R28 + 76]> */
		/* 820F3DE4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000004C) );
		/* 820F3DE4h case    0:*/		return 0x820F3DE8;
		  /* 820F3DE8h */ case    1:  		/* addi R8, R8, 1 */
		/* 820F3DE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F3DE8h case    1:*/		return 0x820F3DEC;
		  /* 820F3DECh */ case    2:  		/* addi R11, R11, 4 */
		/* 820F3DECh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F3DECh case    2:*/		return 0x820F3DF0;
		  /* 820F3DF0h */ case    3:  		/* cmplw CR6, R8, R10 */
		/* 820F3DF0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 820F3DF0h case    3:*/		return 0x820F3DF4;
		  /* 820F3DF4h */ case    4:  		/* bc 12, CR6_LT, -100 */
		/* 820F3DF4h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F3D90;  }
		/* 820F3DF4h case    4:*/		return 0x820F3DF8;
	}
	return 0x820F3DF8;
} // Block from 820F3DE4h-820F3DF8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F3DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3DF8);
		  /* 820F3DF8h */ case    0:  		/* li R8, 0 */
		/* 820F3DF8h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F3DF8h case    0:*/		return 0x820F3DFC;
		  /* 820F3DFCh */ case    1:  		/* addi R7, R27, 12 */
		/* 820F3DFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R27,0xC);
		/* 820F3DFCh case    1:*/		return 0x820F3E00;
		  /* 820F3E00h */ case    2:  		/* li R6, 11 */
		/* 820F3E00h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0xB);
		/* 820F3E00h case    2:*/		return 0x820F3E04;
		  /* 820F3E04h */ case    3:  		/* mr R5, R30 */
		/* 820F3E04h case    3:*/		regs.R5 = regs.R30;
		/* 820F3E04h case    3:*/		return 0x820F3E08;
		  /* 820F3E08h */ case    4:  		/* mr R4, R14 */
		/* 820F3E08h case    4:*/		regs.R4 = regs.R14;
		/* 820F3E08h case    4:*/		return 0x820F3E0C;
		  /* 820F3E0Ch */ case    5:  		/* addi R3, R1, 96 */
		/* 820F3E0Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F3E0Ch case    5:*/		return 0x820F3E10;
		  /* 820F3E10h */ case    6:  		/* bl -154528 */
		/* 820F3E10h case    6:*/		regs.LR = 0x820F3E14; return 0x820CE270;
		/* 820F3E10h case    6:*/		return 0x820F3E14;
		  /* 820F3E14h */ case    7:  		/* or. R31, R3, R3 */
		/* 820F3E14h case    7:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F3E14h case    7:*/		return 0x820F3E18;
		  /* 820F3E18h */ case    8:  		/* bc 12, CR0_LT, 856 */
		/* 820F3E18h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F3E18h case    8:*/		return 0x820F3E1C;
		  /* 820F3E1Ch */ case    9:  		/* mr R14, R15 */
		/* 820F3E1Ch case    9:*/		regs.R14 = regs.R15;
		/* 820F3E1Ch case    9:*/		return 0x820F3E20;
		  /* 820F3E20h */ case   10:  		/* b 492 */
		/* 820F3E20h case   10:*/		return 0x820F400C;
		/* 820F3E20h case   10:*/		return 0x820F3E24;
	}
	return 0x820F3E24;
} // Block from 820F3DF8h-820F3E24h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F3E24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3E24);
		  /* 820F3E24h */ case    0:  		/* cmplwi CR6, R10, 2 */
		/* 820F3E24h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820F3E24h case    0:*/		return 0x820F3E28;
		  /* 820F3E28h */ case    1:  		/* bc 4, CR6_EQ, 260 */
		/* 820F3E28h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F3F2C;  }
		/* 820F3E28h case    1:*/		return 0x820F3E2C;
		  /* 820F3E2Ch */ case    2:  		/* addi R11, R11, 3 */
		/* 820F3E2Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820F3E2Ch case    2:*/		return 0x820F3E30;
		  /* 820F3E30h */ case    3:  		/* lis R4, 9345 */
		/* 820F3E30h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F3E30h case    3:*/		return 0x820F3E34;
		  /* 820F3E34h */ case    4:  		/* rlwinm R31, R11, 2, 0, 27 */
		/* 820F3E34h case    4:*/		cpu::op::rlwinm<0,2,0,27>(regs,&regs.R31,regs.R11);
		/* 820F3E34h case    4:*/		return 0x820F3E38;
		  /* 820F3E38h */ case    5:  		/* mr R3, R31 */
		/* 820F3E38h case    5:*/		regs.R3 = regs.R31;
		/* 820F3E38h case    5:*/		return 0x820F3E3C;
		  /* 820F3E3Ch */ case    6:  		/* bl -441404 */
		/* 820F3E3Ch case    6:*/		regs.LR = 0x820F3E40; return 0x82088200;
		/* 820F3E3Ch case    6:*/		return 0x820F3E40;
		  /* 820F3E40h */ case    7:  		/* stw R3, <#[R1 + 80]> */
		/* 820F3E40h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820F3E40h case    7:*/		return 0x820F3E44;
		  /* 820F3E44h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 820F3E44h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820F3E44h case    8:*/		return 0x820F3E48;
		  /* 820F3E48h */ case    9:  		/* bc 12, CR0_EQ, 768 */
		/* 820F3E48h case    9:*/		if ( regs.CR[0].eq ) { return 0x820F4148;  }
		/* 820F3E48h case    9:*/		return 0x820F3E4C;
		  /* 820F3E4Ch */ case   10:  		/* rlwinm R30, R3, 0, 0, 31 */
		/* 820F3E4Ch case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R30,regs.R3);
		/* 820F3E4Ch case   10:*/		return 0x820F3E50;
		  /* 820F3E50h */ case   11:  		/* mr R5, R31 */
		/* 820F3E50h case   11:*/		regs.R5 = regs.R31;
		/* 820F3E50h case   11:*/		return 0x820F3E54;
		  /* 820F3E54h */ case   12:  		/* li R4, 0 */
		/* 820F3E54h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F3E54h case   12:*/		return 0x820F3E58;
		  /* 820F3E58h */ case   13:  		/* mr R3, R30 */
		/* 820F3E58h case   13:*/		regs.R3 = regs.R30;
		/* 820F3E58h case   13:*/		return 0x820F3E5C;
		  /* 820F3E5Ch */ case   14:  		/* bl -404252 */
		/* 820F3E5Ch case   14:*/		regs.LR = 0x820F3E60; return 0x82091340;
		/* 820F3E5Ch case   14:*/		return 0x820F3E60;
		  /* 820F3E60h */ case   15:  		/* lwz R11, <#[R28 + 76]> */
		/* 820F3E60h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000004C) );
		/* 820F3E60h case   15:*/		return 0x820F3E64;
		  /* 820F3E64h */ case   16:  		/* mr R8, R15 */
		/* 820F3E64h case   16:*/		regs.R8 = regs.R15;
		/* 820F3E64h case   16:*/		return 0x820F3E68;
		  /* 820F3E68h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 820F3E68h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F3E68h case   17:*/		return 0x820F3E6C;
		  /* 820F3E6Ch */ case   18:  		/* bc 4, CR6_GT, 148 */
		/* 820F3E6Ch case   18:*/		if ( !regs.CR[6].gt ) { return 0x820F3F00;  }
		/* 820F3E6Ch case   18:*/		return 0x820F3E70;
		  /* 820F3E70h */ case   19:  		/* mr R11, R15 */
		/* 820F3E70h case   19:*/		regs.R11 = regs.R15;
		/* 820F3E70h case   19:*/		return 0x820F3E74;
		  /* 820F3E74h */ case   20:  		/* lwz R10, <#[R28 + 80]> */
		/* 820F3E74h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000050) );
		/* 820F3E74h case   20:*/		return 0x820F3E78;
		  /* 820F3E78h */ case   21:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820F3E78h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F3E78h case   21:*/		return 0x820F3E7C;
		  /* 820F3E7Ch */ case   22:  		/* cmplwi CR6, R10, 0 */
		/* 820F3E7Ch case   22:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F3E7Ch case   22:*/		return 0x820F3E80;
		  /* 820F3E80h */ case   23:  		/* bc 12, CR6_EQ, 108 */
		/* 820F3E80h case   23:*/		if ( regs.CR[6].eq ) { return 0x820F3EEC;  }
		/* 820F3E80h case   23:*/		return 0x820F3E84;
		  /* 820F3E84h */ case   24:  		/* lwz R9, <#[R10]> */
		/* 820F3E84h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820F3E84h case   24:*/		return 0x820F3E88;
		  /* 820F3E88h */ case   25:  		/* cmplwi CR6, R9, 1 */
		/* 820F3E88h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820F3E88h case   25:*/		return 0x820F3E8C;
		  /* 820F3E8Ch */ case   26:  		/* bc 12, CR6_LT, 68 */
		/* 820F3E8Ch case   26:*/		if ( regs.CR[6].lt ) { return 0x820F3ED0;  }
		/* 820F3E8Ch case   26:*/		return 0x820F3E90;
		  /* 820F3E90h */ case   27:  		/* bc 12, CR6_EQ, 48 */
		/* 820F3E90h case   27:*/		if ( regs.CR[6].eq ) { return 0x820F3EC0;  }
		/* 820F3E90h case   27:*/		return 0x820F3E94;
		  /* 820F3E94h */ case   28:  		/* cmplwi CR6, R9, 3 */
		/* 820F3E94h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000003);
		/* 820F3E94h case   28:*/		return 0x820F3E98;
		  /* 820F3E98h */ case   29:  		/* bc 12, CR6_LT, 20 */
		/* 820F3E98h case   29:*/		if ( regs.CR[6].lt ) { return 0x820F3EAC;  }
		/* 820F3E98h case   29:*/		return 0x820F3E9C;
		  /* 820F3E9Ch */ case   30:  		/* bc 4, CR6_EQ, 80 */
		/* 820F3E9Ch case   30:*/		if ( !regs.CR[6].eq ) { return 0x820F3EEC;  }
		/* 820F3E9Ch case   30:*/		return 0x820F3EA0;
		  /* 820F3EA0h */ case   31:  		/* lfd FR0, <#[R10 + 8]> */
		/* 820F3EA0h case   31:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000008) );
		/* 820F3EA0h case   31:*/		return 0x820F3EA4;
		  /* 820F3EA4h */ case   32:  		/* frsp FR0, FR0 */
		/* 820F3EA4h case   32:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820F3EA4h case   32:*/		return 0x820F3EA8;
		  /* 820F3EA8h */ case   33:  		/* b 64 */
		/* 820F3EA8h case   33:*/		return 0x820F3EE8;
		/* 820F3EA8h case   33:*/		return 0x820F3EAC;
	}
	return 0x820F3EAC;
} // Block from 820F3E24h-820F3EACh (34 instructions)

//////////////////////////////////////////////////////
// Block at 820F3EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3EAC);
		  /* 820F3EACh */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 820F3EACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820F3EACh case    0:*/		return 0x820F3EB0;
		  /* 820F3EB0h */ case    1:  		/* std R10, <#[R1 + 160]> */
		/* 820F3EB0h case    1:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x000000A0) );
		/* 820F3EB0h case    1:*/		return 0x820F3EB4;
		  /* 820F3EB4h */ case    2:  		/* lfd FR0, <#[R1 + 160]> */
		/* 820F3EB4h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000A0) );
		/* 820F3EB4h case    2:*/		return 0x820F3EB8;
		  /* 820F3EB8h */ case    3:  		/* fcfid FR0, FR0 */
		/* 820F3EB8h case    3:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820F3EB8h case    3:*/		return 0x820F3EBC;
		  /* 820F3EBCh */ case    4:  		/* b -24 */
		/* 820F3EBCh case    4:*/		return 0x820F3EA4;
		/* 820F3EBCh case    4:*/		return 0x820F3EC0;
	}
	return 0x820F3EC0;
} // Block from 820F3EACh-820F3EC0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F3EC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3EC0);
		  /* 820F3EC0h */ case    0:  		/* lwa R10, <#[R10 + 8]> */
		/* 820F3EC0h case    0:*/		cpu::mem::load32a( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820F3EC0h case    0:*/		return 0x820F3EC4;
		  /* 820F3EC4h */ case    1:  		/* std R10, <#[R1 + 184]> */
		/* 820F3EC4h case    1:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x000000B8) );
		/* 820F3EC4h case    1:*/		return 0x820F3EC8;
		  /* 820F3EC8h */ case    2:  		/* lfd FR0, <#[R1 + 184]> */
		/* 820F3EC8h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000B8) );
		/* 820F3EC8h case    2:*/		return 0x820F3ECC;
		  /* 820F3ECCh */ case    3:  		/* b -20 */
		/* 820F3ECCh case    3:*/		return 0x820F3EB8;
		/* 820F3ECCh case    3:*/		return 0x820F3ED0;
	}
	return 0x820F3ED0;
} // Block from 820F3EC0h-820F3ED0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F3ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3ED0);
		  /* 820F3ED0h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 820F3ED0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820F3ED0h case    0:*/		return 0x820F3ED4;
		  /* 820F3ED4h */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 820F3ED4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820F3ED4h case    1:*/		return 0x820F3ED8;
		  /* 820F3ED8h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820F3ED8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F3EE4;  }
		/* 820F3ED8h case    2:*/		return 0x820F3EDC;
		  /* 820F3EDCh */ case    3:  		/* fmr FR0, FR31 */
		/* 820F3EDCh case    3:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR31);
		/* 820F3EDCh case    3:*/		return 0x820F3EE0;
		  /* 820F3EE0h */ case    4:  		/* b 8 */
		/* 820F3EE0h case    4:*/		return 0x820F3EE8;
		/* 820F3EE0h case    4:*/		return 0x820F3EE4;
	}
	return 0x820F3EE4;
} // Block from 820F3ED0h-820F3EE4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F3EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3EE4);
		  /* 820F3EE4h */ case    0:  		/* fmr FR0, FR30 */
		/* 820F3EE4h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR30);
		/* 820F3EE4h case    0:*/		return 0x820F3EE8;
	}
	return 0x820F3EE8;
} // Block from 820F3EE4h-820F3EE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F3EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3EE8);
		  /* 820F3EE8h */ case    0:  		/* stfsx FR0, <#[R11 + R30]> */
		/* 820F3EE8h case    0:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820F3EE8h case    0:*/		return 0x820F3EEC;
	}
	return 0x820F3EEC;
} // Block from 820F3EE8h-820F3EECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F3EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3EEC);
		  /* 820F3EECh */ case    0:  		/* lwz R10, <#[R28 + 76]> */
		/* 820F3EECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000004C) );
		/* 820F3EECh case    0:*/		return 0x820F3EF0;
		  /* 820F3EF0h */ case    1:  		/* addi R8, R8, 1 */
		/* 820F3EF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F3EF0h case    1:*/		return 0x820F3EF4;
		  /* 820F3EF4h */ case    2:  		/* addi R11, R11, 4 */
		/* 820F3EF4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F3EF4h case    2:*/		return 0x820F3EF8;
		  /* 820F3EF8h */ case    3:  		/* cmplw CR6, R8, R10 */
		/* 820F3EF8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 820F3EF8h case    3:*/		return 0x820F3EFC;
		  /* 820F3EFCh */ case    4:  		/* bc 12, CR6_LT, -136 */
		/* 820F3EFCh case    4:*/		if ( regs.CR[6].lt ) { return 0x820F3E74;  }
		/* 820F3EFCh case    4:*/		return 0x820F3F00;
	}
	return 0x820F3F00;
} // Block from 820F3EECh-820F3F00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F3F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3F00);
		  /* 820F3F00h */ case    0:  		/* li R8, 0 */
		/* 820F3F00h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F3F00h case    0:*/		return 0x820F3F04;
		  /* 820F3F04h */ case    1:  		/* addi R7, R27, 12 */
		/* 820F3F04h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R27,0xC);
		/* 820F3F04h case    1:*/		return 0x820F3F08;
		  /* 820F3F08h */ case    2:  		/* li R6, 11 */
		/* 820F3F08h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0xB);
		/* 820F3F08h case    2:*/		return 0x820F3F0C;
		  /* 820F3F0Ch */ case    3:  		/* mr R5, R31 */
		/* 820F3F0Ch case    3:*/		regs.R5 = regs.R31;
		/* 820F3F0Ch case    3:*/		return 0x820F3F10;
		  /* 820F3F10h */ case    4:  		/* mr R4, R30 */
		/* 820F3F10h case    4:*/		regs.R4 = regs.R30;
		/* 820F3F10h case    4:*/		return 0x820F3F14;
		  /* 820F3F14h */ case    5:  		/* addi R3, R1, 96 */
		/* 820F3F14h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F3F14h case    5:*/		return 0x820F3F18;
		  /* 820F3F18h */ case    6:  		/* bl -154792 */
		/* 820F3F18h case    6:*/		regs.LR = 0x820F3F1C; return 0x820CE270;
		/* 820F3F18h case    6:*/		return 0x820F3F1C;
		  /* 820F3F1Ch */ case    7:  		/* or. R31, R3, R3 */
		/* 820F3F1Ch case    7:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F3F1Ch case    7:*/		return 0x820F3F20;
		  /* 820F3F20h */ case    8:  		/* bc 12, CR0_LT, 592 */
		/* 820F3F20h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F3F20h case    8:*/		return 0x820F3F24;
		  /* 820F3F24h */ case    9:  		/* stw R15, <#[R1 + 80]> */
		/* 820F3F24h case    9:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000050) );
		/* 820F3F24h case    9:*/		return 0x820F3F28;
		  /* 820F3F28h */ case   10:  		/* b 228 */
		/* 820F3F28h case   10:*/		return 0x820F400C;
		/* 820F3F28h case   10:*/		return 0x820F3F2C;
	}
	return 0x820F3F2C;
} // Block from 820F3F00h-820F3F2Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F3F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3F2C);
		  /* 820F3F2Ch */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820F3F2Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F3F2Ch case    0:*/		return 0x820F3F30;
		  /* 820F3F30h */ case    1:  		/* bc 4, CR6_EQ, 220 */
		/* 820F3F30h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F400C;  }
		/* 820F3F30h case    1:*/		return 0x820F3F34;
		  /* 820F3F34h */ case    2:  		/* lwz R11, <#[R28 + 20]> */
		/* 820F3F34h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 820F3F34h case    2:*/		return 0x820F3F38;
		  /* 820F3F38h */ case    3:  		/* lis R4, 9345 */
		/* 820F3F38h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F3F38h case    3:*/		return 0x820F3F3C;
		  /* 820F3F3Ch */ case    4:  		/* rlwinm R31, R11, 2, 0, 29 */
		/* 820F3F3Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R11);
		/* 820F3F3Ch case    4:*/		return 0x820F3F40;
		  /* 820F3F40h */ case    5:  		/* mr R3, R31 */
		/* 820F3F40h case    5:*/		regs.R3 = regs.R31;
		/* 820F3F40h case    5:*/		return 0x820F3F44;
		  /* 820F3F44h */ case    6:  		/* bl -441668 */
		/* 820F3F44h case    6:*/		regs.LR = 0x820F3F48; return 0x82088200;
		/* 820F3F44h case    6:*/		return 0x820F3F48;
		  /* 820F3F48h */ case    7:  		/* stw R3, <#[R1 + 84]> */
		/* 820F3F48h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820F3F48h case    7:*/		return 0x820F3F4C;
		  /* 820F3F4Ch */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 820F3F4Ch case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820F3F4Ch case    8:*/		return 0x820F3F50;
		  /* 820F3F50h */ case    9:  		/* bc 12, CR0_EQ, 504 */
		/* 820F3F50h case    9:*/		if ( regs.CR[0].eq ) { return 0x820F4148;  }
		/* 820F3F50h case    9:*/		return 0x820F3F54;
		  /* 820F3F54h */ case   10:  		/* rlwinm R30, R3, 0, 0, 31 */
		/* 820F3F54h case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R30,regs.R3);
		/* 820F3F54h case   10:*/		return 0x820F3F58;
		  /* 820F3F58h */ case   11:  		/* mr R5, R31 */
		/* 820F3F58h case   11:*/		regs.R5 = regs.R31;
		/* 820F3F58h case   11:*/		return 0x820F3F5C;
		  /* 820F3F5Ch */ case   12:  		/* li R4, 0 */
		/* 820F3F5Ch case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F3F5Ch case   12:*/		return 0x820F3F60;
		  /* 820F3F60h */ case   13:  		/* mr R3, R30 */
		/* 820F3F60h case   13:*/		regs.R3 = regs.R30;
		/* 820F3F60h case   13:*/		return 0x820F3F64;
		  /* 820F3F64h */ case   14:  		/* bl -404516 */
		/* 820F3F64h case   14:*/		regs.LR = 0x820F3F68; return 0x82091340;
		/* 820F3F64h case   14:*/		return 0x820F3F68;
		  /* 820F3F68h */ case   15:  		/* lwz R11, <#[R28 + 20]> */
		/* 820F3F68h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 820F3F68h case   15:*/		return 0x820F3F6C;
		  /* 820F3F6Ch */ case   16:  		/* mr R8, R15 */
		/* 820F3F6Ch case   16:*/		regs.R8 = regs.R15;
		/* 820F3F6Ch case   16:*/		return 0x820F3F70;
		  /* 820F3F70h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 820F3F70h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F3F70h case   17:*/		return 0x820F3F74;
		  /* 820F3F74h */ case   18:  		/* bc 4, CR6_GT, 112 */
		/* 820F3F74h case   18:*/		if ( !regs.CR[6].gt ) { return 0x820F3FE4;  }
		/* 820F3F74h case   18:*/		return 0x820F3F78;
		  /* 820F3F78h */ case   19:  		/* mr R10, R15 */
		/* 820F3F78h case   19:*/		regs.R10 = regs.R15;
		/* 820F3F78h case   19:*/		return 0x820F3F7C;
		  /* 820F3F7Ch */ case   20:  		/* lwz R11, <#[R28 + 84]> */
		/* 820F3F7Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000054) );
		/* 820F3F7Ch case   20:*/		return 0x820F3F80;
		  /* 820F3F80h */ case   21:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820F3F80h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F3F80h case   21:*/		return 0x820F3F84;
		  /* 820F3F84h */ case   22:  		/* cmplwi CR6, R11, 0 */
		/* 820F3F84h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F3F84h case   22:*/		return 0x820F3F88;
		  /* 820F3F88h */ case   23:  		/* bc 12, CR6_EQ, 72 */
		/* 820F3F88h case   23:*/		if ( regs.CR[6].eq ) { return 0x820F3FD0;  }
		/* 820F3F88h case   23:*/		return 0x820F3F8C;
		  /* 820F3F8Ch */ case   24:  		/* lwz R9, <#[R11]> */
		/* 820F3F8Ch case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820F3F8Ch case   24:*/		return 0x820F3F90;
		  /* 820F3F90h */ case   25:  		/* cmplwi CR6, R9, 1 */
		/* 820F3F90h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820F3F90h case   25:*/		return 0x820F3F94;
		  /* 820F3F94h */ case   26:  		/* bc 12, CR6_LT, 44 */
		/* 820F3F94h case   26:*/		if ( regs.CR[6].lt ) { return 0x820F3FC0;  }
		/* 820F3F94h case   26:*/		return 0x820F3F98;
		  /* 820F3F98h */ case   27:  		/* bc 12, CR6_EQ, 40 */
		/* 820F3F98h case   27:*/		if ( regs.CR[6].eq ) { return 0x820F3FC0;  }
		/* 820F3F98h case   27:*/		return 0x820F3F9C;
		  /* 820F3F9Ch */ case   28:  		/* cmplwi CR6, R9, 3 */
		/* 820F3F9Ch case   28:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000003);
		/* 820F3F9Ch case   28:*/		return 0x820F3FA0;
		  /* 820F3FA0h */ case   29:  		/* bc 12, CR6_LT, 32 */
		/* 820F3FA0h case   29:*/		if ( regs.CR[6].lt ) { return 0x820F3FC0;  }
		/* 820F3FA0h case   29:*/		return 0x820F3FA4;
		  /* 820F3FA4h */ case   30:  		/* bc 4, CR6_EQ, 44 */
		/* 820F3FA4h case   30:*/		if ( !regs.CR[6].eq ) { return 0x820F3FD0;  }
		/* 820F3FA4h case   30:*/		return 0x820F3FA8;
		  /* 820F3FA8h */ case   31:  		/* lfd FR0, <#[R11 + 8]> */
		/* 820F3FA8h case   31:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000008) );
		/* 820F3FA8h case   31:*/		return 0x820F3FAC;
		  /* 820F3FACh */ case   32:  		/* li R11, 1 */
		/* 820F3FACh case   32:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820F3FACh case   32:*/		return 0x820F3FB0;
		  /* 820F3FB0h */ case   33:  		/* fcmpu CR6, FR0, FR29 */
		/* 820F3FB0h case   33:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 820F3FB0h case   33:*/		return 0x820F3FB4;
		  /* 820F3FB4h */ case   34:  		/* bc 4, CR6_EQ, 24 */
		/* 820F3FB4h case   34:*/		if ( !regs.CR[6].eq ) { return 0x820F3FCC;  }
		/* 820F3FB4h case   34:*/		return 0x820F3FB8;
		  /* 820F3FB8h */ case   35:  		/* mr R11, R15 */
		/* 820F3FB8h case   35:*/		regs.R11 = regs.R15;
		/* 820F3FB8h case   35:*/		return 0x820F3FBC;
		  /* 820F3FBCh */ case   36:  		/* b 16 */
		/* 820F3FBCh case   36:*/		return 0x820F3FCC;
		/* 820F3FBCh case   36:*/		return 0x820F3FC0;
	}
	return 0x820F3FC0;
} // Block from 820F3F2Ch-820F3FC0h (37 instructions)

//////////////////////////////////////////////////////
// Block at 820F3FC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3FC0);
		  /* 820F3FC0h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 820F3FC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820F3FC0h case    0:*/		return 0x820F3FC4;
		  /* 820F3FC4h */ case    1:  		/* addic R9, R11, -1 */
		/* 820F3FC4h case    1:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 820F3FC4h case    1:*/		return 0x820F3FC8;
		  /* 820F3FC8h */ case    2:  		/* subfe R11, R9, R11 */
		/* 820F3FC8h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820F3FC8h case    2:*/		return 0x820F3FCC;
	}
	return 0x820F3FCC;
} // Block from 820F3FC0h-820F3FCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F3FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3FCC);
		  /* 820F3FCCh */ case    0:  		/* stwx R11, <#[R10 + R30]> */
		/* 820F3FCCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 820F3FCCh case    0:*/		return 0x820F3FD0;
	}
	return 0x820F3FD0;
} // Block from 820F3FCCh-820F3FD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F3FD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3FD0);
		  /* 820F3FD0h */ case    0:  		/* lwz R11, <#[R28 + 20]> */
		/* 820F3FD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 820F3FD0h case    0:*/		return 0x820F3FD4;
		  /* 820F3FD4h */ case    1:  		/* addi R8, R8, 1 */
		/* 820F3FD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F3FD4h case    1:*/		return 0x820F3FD8;
		  /* 820F3FD8h */ case    2:  		/* addi R10, R10, 4 */
		/* 820F3FD8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F3FD8h case    2:*/		return 0x820F3FDC;
		  /* 820F3FDCh */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 820F3FDCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820F3FDCh case    3:*/		return 0x820F3FE0;
		  /* 820F3FE0h */ case    4:  		/* bc 12, CR6_LT, -100 */
		/* 820F3FE0h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F3F7C;  }
		/* 820F3FE0h case    4:*/		return 0x820F3FE4;
	}
	return 0x820F3FE4;
} // Block from 820F3FD0h-820F3FE4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F3FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F3FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F3FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F3FE4);
		  /* 820F3FE4h */ case    0:  		/* li R8, 0 */
		/* 820F3FE4h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F3FE4h case    0:*/		return 0x820F3FE8;
		  /* 820F3FE8h */ case    1:  		/* addi R7, R27, 12 */
		/* 820F3FE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R27,0xC);
		/* 820F3FE8h case    1:*/		return 0x820F3FEC;
		  /* 820F3FECh */ case    2:  		/* li R6, 11 */
		/* 820F3FECh case    2:*/		cpu::op::li<0>(regs,&regs.R6,0xB);
		/* 820F3FECh case    2:*/		return 0x820F3FF0;
		  /* 820F3FF0h */ case    3:  		/* mr R5, R31 */
		/* 820F3FF0h case    3:*/		regs.R5 = regs.R31;
		/* 820F3FF0h case    3:*/		return 0x820F3FF4;
		  /* 820F3FF4h */ case    4:  		/* mr R4, R30 */
		/* 820F3FF4h case    4:*/		regs.R4 = regs.R30;
		/* 820F3FF4h case    4:*/		return 0x820F3FF8;
		  /* 820F3FF8h */ case    5:  		/* addi R3, R1, 96 */
		/* 820F3FF8h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F3FF8h case    5:*/		return 0x820F3FFC;
		  /* 820F3FFCh */ case    6:  		/* bl -155020 */
		/* 820F3FFCh case    6:*/		regs.LR = 0x820F4000; return 0x820CE270;
		/* 820F3FFCh case    6:*/		return 0x820F4000;
		  /* 820F4000h */ case    7:  		/* or. R31, R3, R3 */
		/* 820F4000h case    7:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F4000h case    7:*/		return 0x820F4004;
		  /* 820F4004h */ case    8:  		/* bc 12, CR0_LT, 364 */
		/* 820F4004h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F4004h case    8:*/		return 0x820F4008;
		  /* 820F4008h */ case    9:  		/* stw R15, <#[R1 + 84]> */
		/* 820F4008h case    9:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000054) );
		/* 820F4008h case    9:*/		return 0x820F400C;
	}
	return 0x820F400C;
} // Block from 820F3FE4h-820F400Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F400Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F400C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F400C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F400C);
		  /* 820F400Ch */ case    0:  		/* addi R21, R21, 1 */
		/* 820F400Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 820F400Ch case    0:*/		return 0x820F4010;
		  /* 820F4010h */ case    1:  		/* addi R26, R26, 4 */
		/* 820F4010h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 820F4010h case    1:*/		return 0x820F4014;
		  /* 820F4014h */ case    2:  		/* addi R27, R27, 20 */
		/* 820F4014h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x14);
		/* 820F4014h case    2:*/		return 0x820F4018;
		  /* 820F4018h */ case    3:  		/* cmplw CR6, R21, R17 */
		/* 820F4018h case    3:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R17);
		/* 820F4018h case    3:*/		return 0x820F401C;
		  /* 820F401Ch */ case    4:  		/* bc 12, CR6_LT, -1332 */
		/* 820F401Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820F3AE8;  }
		/* 820F401Ch case    4:*/		return 0x820F4020;
		  /* 820F4020h */ case    5:  		/* lwz R25, <#[R1 + 88]> */
		/* 820F4020h case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000058) );
		/* 820F4020h case    5:*/		return 0x820F4024;
	}
	return 0x820F4024;
} // Block from 820F400Ch-820F4024h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F4024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4024);
		  /* 820F4024h */ case    0:  		/* lwz R11, <#[R18]> */
		/* 820F4024h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 820F4024h case    0:*/		return 0x820F4028;
		  /* 820F4028h */ case    1:  		/* mr R6, R17 */
		/* 820F4028h case    1:*/		regs.R6 = regs.R17;
		/* 820F4028h case    1:*/		return 0x820F402C;
		  /* 820F402Ch */ case    2:  		/* mr R5, R25 */
		/* 820F402Ch case    2:*/		regs.R5 = regs.R25;
		/* 820F402Ch case    2:*/		return 0x820F4030;
		  /* 820F4030h */ case    3:  		/* addi R4, R1, 96 */
		/* 820F4030h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820F4030h case    3:*/		return 0x820F4034;
		  /* 820F4034h */ case    4:  		/* mr R3, R18 */
		/* 820F4034h case    4:*/		regs.R3 = regs.R18;
		/* 820F4034h case    4:*/		return 0x820F4038;
		  /* 820F4038h */ case    5:  		/* lwz R11, <#[R11 + 356]> */
		/* 820F4038h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000164) );
		/* 820F4038h case    5:*/		return 0x820F403C;
		  /* 820F403Ch */ case    6:  		/* mtspr CTR, R11 */
		/* 820F403Ch case    6:*/		regs.CTR = regs.R11;
		/* 820F403Ch case    6:*/		return 0x820F4040;
		  /* 820F4040h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820F4040h case    7:*/		if ( 1 ) { regs.LR = 0x820F4044; return (uint32)regs.CTR; }
		/* 820F4040h case    7:*/		return 0x820F4044;
		  /* 820F4044h */ case    8:  		/* or. R31, R3, R3 */
		/* 820F4044h case    8:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F4044h case    8:*/		return 0x820F4048;
		  /* 820F4048h */ case    9:  		/* bc 12, CR0_LT, 296 */
		/* 820F4048h case    9:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F4048h case    9:*/		return 0x820F404C;
		  /* 820F404Ch */ case   10:  		/* addi R11, R1, 168 */
		/* 820F404Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA8);
		/* 820F404Ch case   10:*/		return 0x820F4050;
		  /* 820F4050h */ case   11:  		/* lwz R3, <#[R18 + 268]> */
		/* 820F4050h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R18 + 0x0000010C) );
		/* 820F4050h case   11:*/		return 0x820F4054;
		  /* 820F4054h */ case   12:  		/* addi R5, R1, 168 */
		/* 820F4054h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xA8);
		/* 820F4054h case   12:*/		return 0x820F4058;
		  /* 820F4058h */ case   13:  		/* li R4, 0 */
		/* 820F4058h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F4058h case   13:*/		return 0x820F405C;
		  /* 820F405Ch */ case   14:  		/* std R15, <#[R11]> */
		/* 820F405Ch case   14:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R11 + 0x00000000) );
		/* 820F405Ch case   14:*/		return 0x820F4060;
		  /* 820F4060h */ case   15:  		/* stw R15, <#[R11 + 8]> */
		/* 820F4060h case   15:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000008) );
		/* 820F4060h case   15:*/		return 0x820F4064;
		  /* 820F4064h */ case   16:  		/* bl -348668 */
		/* 820F4064h case   16:*/		regs.LR = 0x820F4068; return 0x8209EE68;
		/* 820F4064h case   16:*/		return 0x820F4068;
		  /* 820F4068h */ case   17:  		/* or. R31, R3, R3 */
		/* 820F4068h case   17:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F4068h case   17:*/		return 0x820F406C;
		  /* 820F406Ch */ case   18:  		/* bc 12, CR0_LT, 260 */
		/* 820F406Ch case   18:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F406Ch case   18:*/		return 0x820F4070;
		  /* 820F4070h */ case   19:  		/* li R8, 1 */
		/* 820F4070h case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F4070h case   19:*/		return 0x820F4074;
		  /* 820F4074h */ case   20:  		/* lwz R4, <#[R1 + 168]> */
		/* 820F4074h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000A8) );
		/* 820F4074h case   20:*/		return 0x820F4078;
		  /* 820F4078h */ case   21:  		/* addi R7, R1, 152 */
		/* 820F4078h case   21:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x98);
		/* 820F4078h case   21:*/		return 0x820F407C;
		  /* 820F407Ch */ case   22:  		/* li R6, 5 */
		/* 820F407Ch case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 820F407Ch case   22:*/		return 0x820F4080;
		  /* 820F4080h */ case   23:  		/* mr R5, R20 */
		/* 820F4080h case   23:*/		regs.R5 = regs.R20;
		/* 820F4080h case   23:*/		return 0x820F4084;
		  /* 820F4084h */ case   24:  		/* addi R3, R1, 96 */
		/* 820F4084h case   24:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F4084h case   24:*/		return 0x820F4088;
		  /* 820F4088h */ case   25:  		/* bl -155160 */
		/* 820F4088h case   25:*/		regs.LR = 0x820F408C; return 0x820CE270;
		/* 820F4088h case   25:*/		return 0x820F408C;
		  /* 820F408Ch */ case   26:  		/* or. R31, R3, R3 */
		/* 820F408Ch case   26:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F408Ch case   26:*/		return 0x820F4090;
		  /* 820F4090h */ case   27:  		/* bc 12, CR0_LT, 224 */
		/* 820F4090h case   27:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F4090h case   27:*/		return 0x820F4094;
		  /* 820F4094h */ case   28:  		/* lis R11, -32256 */
		/* 820F4094h case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820F4094h case   28:*/		return 0x820F4098;
		  /* 820F4098h */ case   29:  		/* li R8, 1 */
		/* 820F4098h case   29:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F4098h case   29:*/		return 0x820F409C;
		  /* 820F409Ch */ case   30:  		/* addi R4, R11, 4485 */
		/* 820F409Ch case   30:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1185);
		/* 820F409Ch case   30:*/		return 0x820F40A0;
		  /* 820F40A0h */ case   31:  		/* addi R7, R1, 132 */
		/* 820F40A0h case   31:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x84);
		/* 820F40A0h case   31:*/		return 0x820F40A4;
		  /* 820F40A4h */ case   32:  		/* li R6, 5 */
		/* 820F40A4h case   32:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 820F40A4h case   32:*/		return 0x820F40A8;
		  /* 820F40A8h */ case   33:  		/* mr R5, R20 */
		/* 820F40A8h case   33:*/		regs.R5 = regs.R20;
		/* 820F40A8h case   33:*/		return 0x820F40AC;
		  /* 820F40ACh */ case   34:  		/* addi R3, R1, 96 */
		/* 820F40ACh case   34:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F40ACh case   34:*/		return 0x820F40B0;
		  /* 820F40B0h */ case   35:  		/* bl -155200 */
		/* 820F40B0h case   35:*/		regs.LR = 0x820F40B4; return 0x820CE270;
		/* 820F40B0h case   35:*/		return 0x820F40B4;
		  /* 820F40B4h */ case   36:  		/* or. R31, R3, R3 */
		/* 820F40B4h case   36:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F40B4h case   36:*/		return 0x820F40B8;
		  /* 820F40B8h */ case   37:  		/* bc 12, CR0_LT, 184 */
		/* 820F40B8h case   37:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F40B8h case   37:*/		return 0x820F40BC;
		  /* 820F40BCh */ case   38:  		/* addi R3, R1, 96 */
		/* 820F40BCh case   38:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F40BCh case   38:*/		return 0x820F40C0;
		  /* 820F40C0h */ case   39:  		/* bl -155360 */
		/* 820F40C0h case   39:*/		regs.LR = 0x820F40C4; return 0x820CE1E0;
		/* 820F40C0h case   39:*/		return 0x820F40C4;
		  /* 820F40C4h */ case   40:  		/* mr R30, R3 */
		/* 820F40C4h case   40:*/		regs.R30 = regs.R3;
		/* 820F40C4h case   40:*/		return 0x820F40C8;
		  /* 820F40C8h */ case   41:  		/* cmplwi CR6, R3, 32768 */
		/* 820F40C8h case   41:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00008000);
		/* 820F40C8h case   41:*/		return 0x820F40CC;
		  /* 820F40CCh */ case   42:  		/* mr R3, R18 */
		/* 820F40CCh case   42:*/		regs.R3 = regs.R18;
		/* 820F40CCh case   42:*/		return 0x820F40D0;
		  /* 820F40D0h */ case   43:  		/* bc 12, CR6_GT, 132 */
		/* 820F40D0h case   43:*/		if ( regs.CR[6].gt ) { return 0x820F4154;  }
		/* 820F40D0h case   43:*/		return 0x820F40D4;
		  /* 820F40D4h */ case   44:  		/* mr R4, R30 */
		/* 820F40D4h case   44:*/		regs.R4 = regs.R30;
		/* 820F40D4h case   44:*/		return 0x820F40D8;
		  /* 820F40D8h */ case   45:  		/* bl -10056 */
		/* 820F40D8h case   45:*/		regs.LR = 0x820F40DC; return 0x820F1990;
		/* 820F40D8h case   45:*/		return 0x820F40DC;
		  /* 820F40DCh */ case   46:  		/* or. R31, R3, R3 */
		/* 820F40DCh case   46:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F40DCh case   46:*/		return 0x820F40E0;
		  /* 820F40E0h */ case   47:  		/* bc 12, CR0_LT, 144 */
		/* 820F40E0h case   47:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F40E0h case   47:*/		return 0x820F40E4;
		  /* 820F40E4h */ case   48:  		/* lwz R9, <#[R18 + 276]> */
		/* 820F40E4h case   48:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R18 + 0x00000114) );
		/* 820F40E4h case   48:*/		return 0x820F40E8;
		  /* 820F40E8h */ case   49:  		/* addi R10, R30, 1 */
		/* 820F40E8h case   49:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x1);
		/* 820F40E8h case   49:*/		return 0x820F40EC;
		  /* 820F40ECh */ case   50:  		/* lwz R11, <#[R18 + 272]> */
		/* 820F40ECh case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000110) );
		/* 820F40ECh case   50:*/		return 0x820F40F0;
		  /* 820F40F0h */ case   51:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F40F0h case   51:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F40F0h case   51:*/		return 0x820F40F4;
		  /* 820F40F4h */ case   52:  		/* addi R9, R9, -1 */
		/* 820F40F4h case   52:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 820F40F4h case   52:*/		return 0x820F40F8;
		  /* 820F40F8h */ case   53:  		/* addi R4, R11, 4 */
		/* 820F40F8h case   53:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 820F40F8h case   53:*/		return 0x820F40FC;
		  /* 820F40FCh */ case   54:  		/* add R3, R10, R11 */
		/* 820F40FCh case   54:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 820F40FCh case   54:*/		return 0x820F4100;
		  /* 820F4100h */ case   55:  		/* rlwinm R5, R9, 2, 0, 29 */
		/* 820F4100h case   55:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R9);
		/* 820F4100h case   55:*/		return 0x820F4104;
		  /* 820F4104h */ case   56:  		/* bl -401892 */
		/* 820F4104h case   56:*/		regs.LR = 0x820F4108; return 0x82091F20;
		/* 820F4104h case   56:*/		return 0x820F4108;
		  /* 820F4108h */ case   57:  		/* lwz R11, <#[R18 + 272]> */
		/* 820F4108h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000110) );
		/* 820F4108h case   57:*/		return 0x820F410C;
		  /* 820F410Ch */ case   58:  		/* mr R5, R30 */
		/* 820F410Ch case   58:*/		regs.R5 = regs.R30;
		/* 820F410Ch case   58:*/		return 0x820F4110;
		  /* 820F4110h */ case   59:  		/* addi R3, R1, 96 */
		/* 820F4110h case   59:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F4110h case   59:*/		return 0x820F4114;
		  /* 820F4114h */ case   60:  		/* addi R4, R11, 4 */
		/* 820F4114h case   60:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 820F4114h case   60:*/		return 0x820F4118;
		  /* 820F4118h */ case   61:  		/* bl -154560 */
		/* 820F4118h case   61:*/		regs.LR = 0x820F411C; return 0x820CE558;
		/* 820F4118h case   61:*/		return 0x820F411C;
		  /* 820F411Ch */ case   62:  		/* or. R31, R3, R3 */
		/* 820F411Ch case   62:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820F411Ch case   62:*/		return 0x820F4120;
		  /* 820F4120h */ case   63:  		/* bc 12, CR0_LT, 80 */
		/* 820F4120h case   63:*/		if ( regs.CR[0].lt ) { return 0x820F4170;  }
		/* 820F4120h case   63:*/		return 0x820F4124;
		  /* 820F4124h */ case   64:  		/* lwz R11, <#[R18 + 276]> */
		/* 820F4124h case   64:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000114) );
		/* 820F4124h case   64:*/		return 0x820F4128;
		  /* 820F4128h */ case   65:  		/* mr R31, R15 */
		/* 820F4128h case   65:*/		regs.R31 = regs.R15;
		/* 820F4128h case   65:*/		return 0x820F412C;
		  /* 820F412Ch */ case   66:  		/* lwz R10, <#[R18 + 292]> */
		/* 820F412Ch case   66:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000124) );
		/* 820F412Ch case   66:*/		return 0x820F4130;
		  /* 820F4130h */ case   67:  		/* add R11, R11, R30 */
		/* 820F4130h case   67:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820F4130h case   67:*/		return 0x820F4134;
		  /* 820F4134h */ case   68:  		/* add R10, R30, R10 */
		/* 820F4134h case   68:*/		cpu::op::add<0>(regs,&regs.R10,regs.R30,regs.R10);
		/* 820F4134h case   68:*/		return 0x820F4138;
		  /* 820F4138h */ case   69:  		/* stw R11, <#[R18 + 276]> */
		/* 820F4138h case   69:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R18 + 0x00000114) );
		/* 820F4138h case   69:*/		return 0x820F413C;
		  /* 820F413Ch */ case   70:  		/* stw R10, <#[R18 + 292]> */
		/* 820F413Ch case   70:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R18 + 0x00000124) );
		/* 820F413Ch case   70:*/		return 0x820F4140;
		  /* 820F4140h */ case   71:  		/* stw R11, <#[R18 + 288]> */
		/* 820F4140h case   71:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R18 + 0x00000120) );
		/* 820F4140h case   71:*/		return 0x820F4144;
		  /* 820F4144h */ case   72:  		/* b 44 */
		/* 820F4144h case   72:*/		return 0x820F4170;
		/* 820F4144h case   72:*/		return 0x820F4148;
	}
	return 0x820F4148;
} // Block from 820F4024h-820F4148h (73 instructions)

//////////////////////////////////////////////////////
// Block at 820F4148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4148);
		  /* 820F4148h */ case    0:  		/* lis R31, -32761 */
		/* 820F4148h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820F4148h case    0:*/		return 0x820F414C;
		  /* 820F414Ch */ case    1:  		/* ori R31, R31, 14 */
		/* 820F414Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820F414Ch case    1:*/		return 0x820F4150;
		  /* 820F4150h */ case    2:  		/* b 32 */
		/* 820F4150h case    2:*/		return 0x820F4170;
		/* 820F4150h case    2:*/		return 0x820F4154;
	}
	return 0x820F4154;
} // Block from 820F4148h-820F4154h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F4154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4154);
		  /* 820F4154h */ case    0:  		/* lis R11, -32254 */
		/* 820F4154h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F4154h case    0:*/		return 0x820F4158;
		  /* 820F4158h */ case    1:  		/* li R5, 4548 */
		/* 820F4158h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x11C4);
		/* 820F4158h case    1:*/		return 0x820F415C;
		  /* 820F415Ch */ case    2:  		/* addi R6, R11, -16096 */
		/* 820F415Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC120);
		/* 820F415Ch case    2:*/		return 0x820F4160;
		  /* 820F4160h */ case    3:  		/* li R4, 0 */
		/* 820F4160h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F4160h case    3:*/		return 0x820F4164;
		  /* 820F4164h */ case    4:  		/* bl 107980 */
		/* 820F4164h case    4:*/		regs.LR = 0x820F4168; return 0x8210E730;
		/* 820F4164h case    4:*/		return 0x820F4168;
		  /* 820F4168h */ case    5:  		/* lis R31, -32768 */
		/* 820F4168h case    5:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8000);
		/* 820F4168h case    5:*/		return 0x820F416C;
		  /* 820F416Ch */ case    6:  		/* ori R31, R31, 16389 */
		/* 820F416Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x4005);
		/* 820F416Ch case    6:*/		return 0x820F4170;
	}
	return 0x820F4170;
} // Block from 820F4154h-820F4170h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F4170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4170);
		  /* 820F4170h */ case    0:  		/* lis R4, 9345 */
		/* 820F4170h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4170h case    0:*/		return 0x820F4174;
		  /* 820F4174h */ case    1:  		/* lwz R3, <#[R1 + 88]> */
		/* 820F4174h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 820F4174h case    1:*/		return 0x820F4178;
		  /* 820F4178h */ case    2:  		/* bl -441920 */
		/* 820F4178h case    2:*/		regs.LR = 0x820F417C; return 0x82088338;
		/* 820F4178h case    2:*/		return 0x820F417C;
		  /* 820F417Ch */ case    3:  		/* lis R4, 9345 */
		/* 820F417Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F417Ch case    3:*/		return 0x820F4180;
		  /* 820F4180h */ case    4:  		/* mr R3, R19 */
		/* 820F4180h case    4:*/		regs.R3 = regs.R19;
		/* 820F4180h case    4:*/		return 0x820F4184;
		  /* 820F4184h */ case    5:  		/* bl -441932 */
		/* 820F4184h case    5:*/		regs.LR = 0x820F4188; return 0x82088338;
		/* 820F4184h case    5:*/		return 0x820F4188;
		  /* 820F4188h */ case    6:  		/* lis R4, 9345 */
		/* 820F4188h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4188h case    6:*/		return 0x820F418C;
		  /* 820F418Ch */ case    7:  		/* lwz R3, <#[R1 + 80]> */
		/* 820F418Ch case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820F418Ch case    7:*/		return 0x820F4190;
		  /* 820F4190h */ case    8:  		/* bl -441944 */
		/* 820F4190h case    8:*/		regs.LR = 0x820F4194; return 0x82088338;
		/* 820F4190h case    8:*/		return 0x820F4194;
		  /* 820F4194h */ case    9:  		/* lis R4, 9345 */
		/* 820F4194h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4194h case    9:*/		return 0x820F4198;
		  /* 820F4198h */ case   10:  		/* lwz R3, <#[R1 + 84]> */
		/* 820F4198h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820F4198h case   10:*/		return 0x820F419C;
		  /* 820F419Ch */ case   11:  		/* bl -441956 */
		/* 820F419Ch case   11:*/		regs.LR = 0x820F41A0; return 0x82088338;
		/* 820F419Ch case   11:*/		return 0x820F41A0;
		  /* 820F41A0h */ case   12:  		/* lis R4, 9345 */
		/* 820F41A0h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F41A0h case   12:*/		return 0x820F41A4;
		  /* 820F41A4h */ case   13:  		/* mr R3, R14 */
		/* 820F41A4h case   13:*/		regs.R3 = regs.R14;
		/* 820F41A4h case   13:*/		return 0x820F41A8;
		  /* 820F41A8h */ case   14:  		/* bl -441968 */
		/* 820F41A8h case   14:*/		regs.LR = 0x820F41AC; return 0x82088338;
		/* 820F41A8h case   14:*/		return 0x820F41AC;
		  /* 820F41ACh */ case   15:  		/* lis R4, 9345 */
		/* 820F41ACh case   15:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F41ACh case   15:*/		return 0x820F41B0;
		  /* 820F41B0h */ case   16:  		/* lwz R3, <#[R1 + 112]> */
		/* 820F41B0h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 820F41B0h case   16:*/		return 0x820F41B4;
		  /* 820F41B4h */ case   17:  		/* bl -441980 */
		/* 820F41B4h case   17:*/		regs.LR = 0x820F41B8; return 0x82088338;
		/* 820F41B4h case   17:*/		return 0x820F41B8;
		  /* 820F41B8h */ case   18:  		/* addi R3, R1, 96 */
		/* 820F41B8h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F41B8h case   18:*/		return 0x820F41BC;
		  /* 820F41BCh */ case   19:  		/* bl -155588 */
		/* 820F41BCh case   19:*/		regs.LR = 0x820F41C0; return 0x820CE1F8;
		/* 820F41BCh case   19:*/		return 0x820F41C0;
		  /* 820F41C0h */ case   20:  		/* mr R3, R31 */
		/* 820F41C0h case   20:*/		regs.R3 = regs.R31;
		/* 820F41C0h case   20:*/		return 0x820F41C4;
		  /* 820F41C4h */ case   21:  		/* addi R1, R1, 624 */
		/* 820F41C4h case   21:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x270);
		/* 820F41C4h case   21:*/		return 0x820F41C8;
		  /* 820F41C8h */ case   22:  		/* lfd FR29, <#[R1 - 176]> */
		/* 820F41C8h case   22:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R1 + 0xFFFFFF50) );
		/* 820F41C8h case   22:*/		return 0x820F41CC;
		  /* 820F41CCh */ case   23:  		/* lfd FR30, <#[R1 - 168]> */
		/* 820F41CCh case   23:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 820F41CCh case   23:*/		return 0x820F41D0;
		  /* 820F41D0h */ case   24:  		/* lfd FR31, <#[R1 - 160]> */
		/* 820F41D0h case   24:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820F41D0h case   24:*/		return 0x820F41D4;
		  /* 820F41D4h */ case   25:  		/* b -405348 */
		/* 820F41D4h case   25:*/		return 0x82091270;
		/* 820F41D4h case   25:*/		return 0x820F41D8;
	}
	return 0x820F41D8;
} // Block from 820F4170h-820F41D8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820F41D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F41D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F41D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F41D8);
		  /* 820F41D8h */ case    0:  		/* mfspr R12, LR */
		/* 820F41D8h case    0:*/		regs.R12 = regs.LR;
		/* 820F41D8h case    0:*/		return 0x820F41DC;
		  /* 820F41DCh */ case    1:  		/* bl -405432 */
		/* 820F41DCh case    1:*/		regs.LR = 0x820F41E0; return 0x82091224;
		/* 820F41DCh case    1:*/		return 0x820F41E0;
		  /* 820F41E0h */ case    2:  		/* stwu R1, <#[R1 - 304]> */
		/* 820F41E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFED0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFED0);
		/* 820F41E0h case    2:*/		return 0x820F41E4;
		  /* 820F41E4h */ case    3:  		/* lis R4, 18261 */
		/* 820F41E4h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x4755);
		/* 820F41E4h case    3:*/		return 0x820F41E8;
		  /* 820F41E8h */ case    4:  		/* mr R27, R3 */
		/* 820F41E8h case    4:*/		regs.R27 = regs.R3;
		/* 820F41E8h case    4:*/		return 0x820F41EC;
		  /* 820F41ECh */ case    5:  		/* addi R3, R1, 96 */
		/* 820F41ECh case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F41ECh case    5:*/		return 0x820F41F0;
		  /* 820F41F0h */ case    6:  		/* ori R4, R4, 16964 */
		/* 820F41F0h case    6:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x4244);
		/* 820F41F0h case    6:*/		return 0x820F41F4;
		  /* 820F41F4h */ case    7:  		/* bl -155700 */
		/* 820F41F4h case    7:*/		regs.LR = 0x820F41F8; return 0x820CE1C0;
		/* 820F41F4h case    7:*/		return 0x820F41F8;
		  /* 820F41F8h */ case    8:  		/* addi R11, R1, 112 */
		/* 820F41F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820F41F8h case    8:*/		return 0x820F41FC;
		  /* 820F41FCh */ case    9:  		/* li R19, 0 */
		/* 820F41FCh case    9:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 820F41FCh case    9:*/		return 0x820F4200;
		  /* 820F4200h */ case   10:  		/* li R10, 40 */
		/* 820F4200h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x28);
		/* 820F4200h case   10:*/		return 0x820F4204;
		  /* 820F4204h */ case   11:  		/* li R8, 9 */
		/* 820F4204h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x9);
		/* 820F4204h case   11:*/		return 0x820F4208;
		  /* 820F4208h */ case   12:  		/* li R7, 0 */
		/* 820F4208h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F4208h case   12:*/		return 0x820F420C;
		  /* 820F420Ch */ case   13:  		/* std R19, <#[R11]> */
		/* 820F420Ch case   13:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R11 + 0x00000000) );
		/* 820F420Ch case   13:*/		return 0x820F4210;
		  /* 820F4210h */ case   14:  		/* li R6, 1 */
		/* 820F4210h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F4210h case   14:*/		return 0x820F4214;
		  /* 820F4214h */ case   15:  		/* std R19, <#[R11 + 8]> */
		/* 820F4214h case   15:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R11 + 0x00000008) );
		/* 820F4214h case   15:*/		return 0x820F4218;
		  /* 820F4218h */ case   16:  		/* li R5, 40 */
		/* 820F4218h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x28);
		/* 820F4218h case   16:*/		return 0x820F421C;
		  /* 820F421Ch */ case   17:  		/* std R19, <#[R11 + 16]> */
		/* 820F421Ch case   17:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R11 + 0x00000010) );
		/* 820F421Ch case   17:*/		return 0x820F4220;
		  /* 820F4220h */ case   18:  		/* addi R4, R1, 112 */
		/* 820F4220h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820F4220h case   18:*/		return 0x820F4224;
		  /* 820F4224h */ case   19:  		/* std R19, <#[R11 + 24]> */
		/* 820F4224h case   19:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R11 + 0x00000018) );
		/* 820F4224h case   19:*/		return 0x820F4228;
		  /* 820F4228h */ case   20:  		/* addi R3, R1, 96 */
		/* 820F4228h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F4228h case   20:*/		return 0x820F422C;
		  /* 820F422Ch */ case   21:  		/* std R19, <#[R11 + 32]> */
		/* 820F422Ch case   21:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R11 + 0x00000020) );
		/* 820F422Ch case   21:*/		return 0x820F4230;
		  /* 820F4230h */ case   22:  		/* stw R10, <#[R1 + 112]> */
		/* 820F4230h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 820F4230h case   22:*/		return 0x820F4234;
		  /* 820F4234h */ case   23:  		/* mr R15, R19 */
		/* 820F4234h case   23:*/		regs.R15 = regs.R19;
		/* 820F4234h case   23:*/		return 0x820F4238;
		  /* 820F4238h */ case   24:  		/* mr R16, R19 */
		/* 820F4238h case   24:*/		regs.R16 = regs.R19;
		/* 820F4238h case   24:*/		return 0x820F423C;
		  /* 820F423Ch */ case   25:  		/* mr R17, R19 */
		/* 820F423Ch case   25:*/		regs.R17 = regs.R19;
		/* 820F423Ch case   25:*/		return 0x820F4240;
		  /* 820F4240h */ case   26:  		/* mr R20, R19 */
		/* 820F4240h case   26:*/		regs.R20 = regs.R19;
		/* 820F4240h case   26:*/		return 0x820F4244;
		  /* 820F4244h */ case   27:  		/* mr R21, R19 */
		/* 820F4244h case   27:*/		regs.R21 = regs.R19;
		/* 820F4244h case   27:*/		return 0x820F4248;
		  /* 820F4248h */ case   28:  		/* mr R24, R19 */
		/* 820F4248h case   28:*/		regs.R24 = regs.R19;
		/* 820F4248h case   28:*/		return 0x820F424C;
		  /* 820F424Ch */ case   29:  		/* bl -155612 */
		/* 820F424Ch case   29:*/		regs.LR = 0x820F4250; return 0x820CE270;
		/* 820F424Ch case   29:*/		return 0x820F4250;
		  /* 820F4250h */ case   30:  		/* or. R29, R3, R3 */
		/* 820F4250h case   30:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F4250h case   30:*/		return 0x820F4254;
		  /* 820F4254h */ case   31:  		/* bc 12, CR0_LT, 1872 */
		/* 820F4254h case   31:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F4254h case   31:*/		return 0x820F4258;
		  /* 820F4258h */ case   32:  		/* lwz R11, <#[R27 + 300]> */
		/* 820F4258h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000012C) );
		/* 820F4258h case   32:*/		return 0x820F425C;
		  /* 820F425Ch */ case   33:  		/* li R18, -1 */
		/* 820F425Ch case   33:*/		cpu::op::li<0>(regs,&regs.R18,0xFFFFFFFF);
		/* 820F425Ch case   33:*/		return 0x820F4260;
		  /* 820F4260h */ case   34:  		/* cmplwi CR6, R11, 0 */
		/* 820F4260h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F4260h case   34:*/		return 0x820F4264;
		  /* 820F4264h */ case   35:  		/* stw R11, <#[R1 + 132]> */
		/* 820F4264h case   35:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820F4264h case   35:*/		return 0x820F4268;
		  /* 820F4268h */ case   36:  		/* bc 12, CR6_EQ, 1452 */
		/* 820F4268h case   36:*/		if ( regs.CR[6].eq ) { return 0x820F4814;  }
		/* 820F4268h case   36:*/		return 0x820F426C;
		  /* 820F426Ch */ case   37:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820F426Ch case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820F426Ch case   37:*/		return 0x820F4270;
		  /* 820F4270h */ case   38:  		/* lis R4, 9345 */
		/* 820F4270h case   38:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4270h case   38:*/		return 0x820F4274;
		  /* 820F4274h */ case   39:  		/* bl -442484 */
		/* 820F4274h case   39:*/		regs.LR = 0x820F4278; return 0x82088200;
		/* 820F4274h case   39:*/		return 0x820F4278;
		  /* 820F4278h */ case   40:  		/* or. R15, R3, R3 */
		/* 820F4278h case   40:*/		cpu::op::or<1>(regs,&regs.R15,regs.R3,regs.R3);
		/* 820F4278h case   40:*/		return 0x820F427C;
		  /* 820F427Ch */ case   41:  		/* bc 12, CR0_EQ, 1796 */
		/* 820F427Ch case   41:*/		if ( regs.CR[0].eq ) { return 0x820F4980;  }
		/* 820F427Ch case   41:*/		return 0x820F4280;
		  /* 820F4280h */ case   42:  		/* lwz R11, <#[R1 + 132]> */
		/* 820F4280h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820F4280h case   42:*/		return 0x820F4284;
		  /* 820F4284h */ case   43:  		/* li R4, 0 */
		/* 820F4284h case   43:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F4284h case   43:*/		return 0x820F4288;
		  /* 820F4288h */ case   44:  		/* mr R3, R15 */
		/* 820F4288h case   44:*/		regs.R3 = regs.R15;
		/* 820F4288h case   44:*/		return 0x820F428C;
		  /* 820F428Ch */ case   45:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820F428Ch case   45:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820F428Ch case   45:*/		return 0x820F4290;
		  /* 820F4290h */ case   46:  		/* bl -405328 */
		/* 820F4290h case   46:*/		regs.LR = 0x820F4294; return 0x82091340;
		/* 820F4290h case   46:*/		return 0x820F4294;
		  /* 820F4294h */ case   47:  		/* lwz R11, <#[R1 + 132]> */
		/* 820F4294h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820F4294h case   47:*/		return 0x820F4298;
		  /* 820F4298h */ case   48:  		/* lis R4, 9345 */
		/* 820F4298h case   48:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4298h case   48:*/		return 0x820F429C;
		  /* 820F429Ch */ case   49:  		/* rlwinm R3, R11, 3, 0, 28 */
		/* 820F429Ch case   49:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R3,regs.R11);
		/* 820F429Ch case   49:*/		return 0x820F42A0;
		  /* 820F42A0h */ case   50:  		/* bl -442528 */
		/* 820F42A0h case   50:*/		regs.LR = 0x820F42A4; return 0x82088200;
		/* 820F42A0h case   50:*/		return 0x820F42A4;
		  /* 820F42A4h */ case   51:  		/* or. R16, R3, R3 */
		/* 820F42A4h case   51:*/		cpu::op::or<1>(regs,&regs.R16,regs.R3,regs.R3);
		/* 820F42A4h case   51:*/		return 0x820F42A8;
		  /* 820F42A8h */ case   52:  		/* bc 12, CR0_EQ, 1752 */
		/* 820F42A8h case   52:*/		if ( regs.CR[0].eq ) { return 0x820F4980;  }
		/* 820F42A8h case   52:*/		return 0x820F42AC;
		  /* 820F42ACh */ case   53:  		/* lwz R11, <#[R1 + 132]> */
		/* 820F42ACh case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820F42ACh case   53:*/		return 0x820F42B0;
		  /* 820F42B0h */ case   54:  		/* li R4, 0 */
		/* 820F42B0h case   54:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F42B0h case   54:*/		return 0x820F42B4;
		  /* 820F42B4h */ case   55:  		/* mr R3, R16 */
		/* 820F42B4h case   55:*/		regs.R3 = regs.R16;
		/* 820F42B4h case   55:*/		return 0x820F42B8;
		  /* 820F42B8h */ case   56:  		/* rlwinm R25, R11, 3, 0, 28 */
		/* 820F42B8h case   56:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R25,regs.R11);
		/* 820F42B8h case   56:*/		return 0x820F42BC;
		  /* 820F42BCh */ case   57:  		/* mr R5, R25 */
		/* 820F42BCh case   57:*/		regs.R5 = regs.R25;
		/* 820F42BCh case   57:*/		return 0x820F42C0;
		  /* 820F42C0h */ case   58:  		/* bl -405376 */
		/* 820F42C0h case   58:*/		regs.LR = 0x820F42C4; return 0x82091340;
		/* 820F42C0h case   58:*/		return 0x820F42C4;
		  /* 820F42C4h */ case   59:  		/* lwz R11, <#[R1 + 132]> */
		/* 820F42C4h case   59:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820F42C4h case   59:*/		return 0x820F42C8;
		  /* 820F42C8h */ case   60:  		/* lis R4, 9345 */
		/* 820F42C8h case   60:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F42C8h case   60:*/		return 0x820F42CC;
		  /* 820F42CCh */ case   61:  		/* rlwinm R3, R11, 4, 0, 27 */
		/* 820F42CCh case   61:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R3,regs.R11);
		/* 820F42CCh case   61:*/		return 0x820F42D0;
		  /* 820F42D0h */ case   62:  		/* bl -442576 */
		/* 820F42D0h case   62:*/		regs.LR = 0x820F42D4; return 0x82088200;
		/* 820F42D0h case   62:*/		return 0x820F42D4;
		  /* 820F42D4h */ case   63:  		/* or. R21, R3, R3 */
		/* 820F42D4h case   63:*/		cpu::op::or<1>(regs,&regs.R21,regs.R3,regs.R3);
		/* 820F42D4h case   63:*/		return 0x820F42D8;
		  /* 820F42D8h */ case   64:  		/* bc 12, CR0_EQ, 1704 */
		/* 820F42D8h case   64:*/		if ( regs.CR[0].eq ) { return 0x820F4980;  }
		/* 820F42D8h case   64:*/		return 0x820F42DC;
		  /* 820F42DCh */ case   65:  		/* lwz R11, <#[R1 + 132]> */
		/* 820F42DCh case   65:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820F42DCh case   65:*/		return 0x820F42E0;
		  /* 820F42E0h */ case   66:  		/* li R4, 0 */
		/* 820F42E0h case   66:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F42E0h case   66:*/		return 0x820F42E4;
		  /* 820F42E4h */ case   67:  		/* mr R3, R21 */
		/* 820F42E4h case   67:*/		regs.R3 = regs.R21;
		/* 820F42E4h case   67:*/		return 0x820F42E8;
		  /* 820F42E8h */ case   68:  		/* rlwinm R5, R11, 4, 0, 27 */
		/* 820F42E8h case   68:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R5,regs.R11);
		/* 820F42E8h case   68:*/		return 0x820F42EC;
		  /* 820F42ECh */ case   69:  		/* bl -405420 */
		/* 820F42ECh case   69:*/		regs.LR = 0x820F42F0; return 0x82091340;
		/* 820F42ECh case   69:*/		return 0x820F42F0;
		  /* 820F42F0h */ case   70:  		/* lwz R11, <#[R1 + 132]> */
		/* 820F42F0h case   70:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820F42F0h case   70:*/		return 0x820F42F4;
		  /* 820F42F4h */ case   71:  		/* mr R26, R19 */
		/* 820F42F4h case   71:*/		regs.R26 = regs.R19;
		/* 820F42F4h case   71:*/		return 0x820F42F8;
		  /* 820F42F8h */ case   72:  		/* cmplwi CR6, R11, 0 */
		/* 820F42F8h case   72:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F42F8h case   72:*/		return 0x820F42FC;
		  /* 820F42FCh */ case   73:  		/* bc 12, CR6_EQ, 332 */
		/* 820F42FCh case   73:*/		if ( regs.CR[6].eq ) { return 0x820F4448;  }
		/* 820F42FCh case   73:*/		return 0x820F4300;
		  /* 820F4300h */ case   74:  		/* mr R30, R19 */
		/* 820F4300h case   74:*/		regs.R30 = regs.R19;
		/* 820F4300h case   74:*/		return 0x820F4304;
		  /* 820F4304h */ case   75:  		/* li R28, 2 */
		/* 820F4304h case   75:*/		cpu::op::li<0>(regs,&regs.R28,0x2);
		/* 820F4304h case   75:*/		return 0x820F4308;
		  /* 820F4308h */ case   76:  		/* addi R31, R16, 2 */
		/* 820F4308h case   76:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R16,0x2);
		/* 820F4308h case   76:*/		return 0x820F430C;
		  /* 820F430Ch */ case   77:  		/* li R11, -1 */
		/* 820F430Ch case   77:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820F430Ch case   77:*/		return 0x820F4310;
		  /* 820F4310h */ case   78:  		/* sth R19, <#[R31 - 2]> */
		/* 820F4310h case   78:*/		cpu::mem::store16( regs, regs.R19, (uint32)(regs.R31 + 0xFFFFFFFE) );
		/* 820F4310h case   78:*/		return 0x820F4314;
		  /* 820F4314h */ case   79:  		/* rlwinm R10, R24, 2, 0, 29 */
		/* 820F4314h case   79:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R24);
		/* 820F4314h case   79:*/		return 0x820F4318;
		  /* 820F4318h */ case   80:  		/* sth R11, <#[R31]> */
		/* 820F4318h case   80:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F4318h case   80:*/		return 0x820F431C;
		  /* 820F431Ch */ case   81:  		/* li R11, 4 */
		/* 820F431Ch case   81:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820F431Ch case   81:*/		return 0x820F4320;
		  /* 820F4320h */ case   82:  		/* lwz R9, <#[R27 + 296]> */
		/* 820F4320h case   82:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000128) );
		/* 820F4320h case   82:*/		return 0x820F4324;
		  /* 820F4324h */ case   83:  		/* add R9, R30, R9 */
		/* 820F4324h case   83:*/		cpu::op::add<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 820F4324h case   83:*/		return 0x820F4328;
		  /* 820F4328h */ case   84:  		/* add R10, R10, R21 */
		/* 820F4328h case   84:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R21);
		/* 820F4328h case   84:*/		return 0x820F432C;
		  /* 820F432Ch */ case   85:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F432Ch case   85:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F432Ch case   85:*/		return 0x820F4330;
		  /* 820F4330h */ case   86:  		/* mr R8, R19 */
		/* 820F4330h case   86:*/		regs.R8 = regs.R19;
		/* 820F4330h case   86:*/		return 0x820F4334;
		  /* 820F4334h */ case   87:  		/* mtspr CTR, R11 */
		/* 820F4334h case   87:*/		regs.CTR = regs.R11;
		/* 820F4334h case   87:*/		return 0x820F4338;
		  /* 820F4338h */ case   88:  		/* addi R10, R10, -4 */
		/* 820F4338h case   88:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 820F4338h case   88:*/		return 0x820F433C;
		  /* 820F433Ch */ case   89:  		/* stw R9, <#[R31 + 2]> */
		/* 820F433Ch case   89:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000002) );
		/* 820F433Ch case   89:*/		return 0x820F4340;
		  /* 820F4340h */ case   90:  		/* add R11, R28, R8 */
		/* 820F4340h case   90:*/		cpu::op::add<0>(regs,&regs.R11,regs.R28,regs.R8);
		/* 820F4340h case   90:*/		return 0x820F4344;
		  /* 820F4344h */ case   91:  		/* lwz R7, <#[R27 + 296]> */
		/* 820F4344h case   91:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R27 + 0x00000128) );
		/* 820F4344h case   91:*/		return 0x820F4348;
		  /* 820F4348h */ case   92:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 820F4348h case   92:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 820F4348h case   92:*/		return 0x820F434C;
		  /* 820F434Ch */ case   93:  		/* lwzx R11, <#[R7 + R9]> */
		/* 820F434Ch case   93:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 820F434Ch case   93:*/		return 0x820F4350;
		  /* 820F4350h */ case   94:  		/* cmpwi CR6, R11, -1 */
		/* 820F4350h case   94:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820F4350h case   94:*/		return 0x820F4354;
		  /* 820F4354h */ case   95:  		/* bc 12, CR6_EQ, 48 */
		/* 820F4354h case   95:*/		if ( regs.CR[6].eq ) { return 0x820F4384;  }
		/* 820F4354h case   95:*/		return 0x820F4358;
		  /* 820F4358h */ case   96:  		/* lwz R7, <#[R27 + 20]> */
		/* 820F4358h case   96:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R27 + 0x00000014) );
		/* 820F4358h case   96:*/		return 0x820F435C;
		  /* 820F435Ch */ case   97:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F435Ch case   97:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F435Ch case   97:*/		return 0x820F4360;
		  /* 820F4360h */ case   98:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820F4360h case   98:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820F4360h case   98:*/		return 0x820F4364;
		  /* 820F4364h */ case   99:  		/* lwz R7, <#[R11 + 96]> */
		/* 820F4364h case   99:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000060) );
		/* 820F4364h case   99:*/		return 0x820F4368;
		  /* 820F4368h */ case  100:  		/* stw R26, <#[R11 + 116]> */
		/* 820F4368h case  100:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000074) );
		/* 820F4368h case  100:*/		return 0x820F436C;
		  /* 820F436Ch */ case  101:  		/* cmplwi CR6, R7, 0 */
		/* 820F436Ch case  101:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820F436Ch case  101:*/		return 0x820F4370;
		  /* 820F4370h */ case  102:  		/* bc 12, CR6_EQ, 20 */
		/* 820F4370h case  102:*/		if ( regs.CR[6].eq ) { return 0x820F4384;  }
		/* 820F4370h case  102:*/		return 0x820F4374;
		  /* 820F4374h */ case  103:  		/* lwz R11, <#[R27 + 296]> */
		/* 820F4374h case  103:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000128) );
		/* 820F4374h case  103:*/		return 0x820F4378;
		  /* 820F4378h */ case  104:  		/* addi R24, R24, 1 */
		/* 820F4378h case  104:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 820F4378h case  104:*/		return 0x820F437C;
		  /* 820F437Ch */ case  105:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F437Ch case  105:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F437Ch case  105:*/		return 0x820F4380;
		  /* 820F4380h */ case  106:  		/* stwu R11, <#[R10 + 4]> */
		/* 820F4380h case  106:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820F4380h case  106:*/		return 0x820F4384;
	}
	return 0x820F4384;
} // Block from 820F41D8h-820F4384h (107 instructions)

//////////////////////////////////////////////////////
// Block at 820F4384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4384);
		  /* 820F4384h */ case    0:  		/* addi R8, R8, 1 */
		/* 820F4384h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F4384h case    0:*/		return 0x820F4388;
		  /* 820F4388h */ case    1:  		/* bc 16, CR0_LT, -72 */
		/* 820F4388h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F4340;  }
		/* 820F4388h case    1:*/		return 0x820F438C;
		  /* 820F438Ch */ case    2:  		/* lwz R11, <#[R27 + 296]> */
		/* 820F438Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000128) );
		/* 820F438Ch case    2:*/		return 0x820F4390;
		  /* 820F4390h */ case    3:  		/* lwzx R11, <#[R30 + R11]> */
		/* 820F4390h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820F4390h case    3:*/		return 0x820F4394;
		  /* 820F4394h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820F4394h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F4394h case    4:*/		return 0x820F4398;
		  /* 820F4398h */ case    5:  		/* bc 12, CR6_EQ, 148 */
		/* 820F4398h case    5:*/		if ( regs.CR[6].eq ) { return 0x820F442C;  }
		/* 820F4398h case    5:*/		return 0x820F439C;
		  /* 820F439Ch */ case    6:  		/* lwz R11, <#[R11 + 24]> */
		/* 820F439Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820F439Ch case    6:*/		return 0x820F43A0;
		  /* 820F43A0h */ case    7:  		/* sth R11, <#[R31 - 2]> */
		/* 820F43A0h case    7:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0xFFFFFFFE) );
		/* 820F43A0h case    7:*/		return 0x820F43A4;
		  /* 820F43A4h */ case    8:  		/* lwz R11, <#[R27 + 296]> */
		/* 820F43A4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000128) );
		/* 820F43A4h case    8:*/		return 0x820F43A8;
		  /* 820F43A8h */ case    9:  		/* lwzx R11, <#[R30 + R11]> */
		/* 820F43A8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820F43A8h case    9:*/		return 0x820F43AC;
		  /* 820F43ACh */ case   10:  		/* lwz R4, <#[R11 + 16]> */
		/* 820F43ACh case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000010) );
		/* 820F43ACh case   10:*/		return 0x820F43B0;
		  /* 820F43B0h */ case   11:  		/* cmplwi CR6, R4, 0 */
		/* 820F43B0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F43B0h case   11:*/		return 0x820F43B4;
		  /* 820F43B4h */ case   12:  		/* bc 12, CR6_EQ, 120 */
		/* 820F43B4h case   12:*/		if ( regs.CR[6].eq ) { return 0x820F442C;  }
		/* 820F43B4h case   12:*/		return 0x820F43B8;
		  /* 820F43B8h */ case   13:  		/* li R8, 1 */
		/* 820F43B8h case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F43B8h case   13:*/		return 0x820F43BC;
		  /* 820F43BCh */ case   14:  		/* addi R7, R1, 80 */
		/* 820F43BCh case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820F43BCh case   14:*/		return 0x820F43C0;
		  /* 820F43C0h */ case   15:  		/* li R6, 7 */
		/* 820F43C0h case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 820F43C0h case   15:*/		return 0x820F43C4;
		  /* 820F43C4h */ case   16:  		/* mr R5, R18 */
		/* 820F43C4h case   16:*/		regs.R5 = regs.R18;
		/* 820F43C4h case   16:*/		return 0x820F43C8;
		  /* 820F43C8h */ case   17:  		/* addi R3, R1, 96 */
		/* 820F43C8h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F43C8h case   17:*/		return 0x820F43CC;
		  /* 820F43CCh */ case   18:  		/* bl -155996 */
		/* 820F43CCh case   18:*/		regs.LR = 0x820F43D0; return 0x820CE270;
		/* 820F43CCh case   18:*/		return 0x820F43D0;
		  /* 820F43D0h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820F43D0h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F43D0h case   19:*/		return 0x820F43D4;
		  /* 820F43D4h */ case   20:  		/* bc 12, CR0_LT, 1488 */
		/* 820F43D4h case   20:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F43D4h case   20:*/		return 0x820F43D8;
		  /* 820F43D8h */ case   21:  		/* lwz R9, <#[R1 + 124]> */
		/* 820F43D8h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000007C) );
		/* 820F43D8h case   21:*/		return 0x820F43DC;
		  /* 820F43DCh */ case   22:  		/* mr R10, R19 */
		/* 820F43DCh case   22:*/		regs.R10 = regs.R19;
		/* 820F43DCh case   22:*/		return 0x820F43E0;
		  /* 820F43E0h */ case   23:  		/* lwz R8, <#[R1 + 80]> */
		/* 820F43E0h case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 820F43E0h case   23:*/		return 0x820F43E4;
		  /* 820F43E4h */ case   24:  		/* cmplwi CR6, R9, 0 */
		/* 820F43E4h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820F43E4h case   24:*/		return 0x820F43E8;
		  /* 820F43E8h */ case   25:  		/* bc 12, CR6_EQ, 36 */
		/* 820F43E8h case   25:*/		if ( regs.CR[6].eq ) { return 0x820F440C;  }
		/* 820F43E8h case   25:*/		return 0x820F43EC;
		  /* 820F43ECh */ case   26:  		/* mr R11, R15 */
		/* 820F43ECh case   26:*/		regs.R11 = regs.R15;
		/* 820F43ECh case   26:*/		return 0x820F43F0;
		  /* 820F43F0h */ case   27:  		/* lwz R7, <#[R11]> */
		/* 820F43F0h case   27:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820F43F0h case   27:*/		return 0x820F43F4;
		  /* 820F43F4h */ case   28:  		/* cmplw CR6, R7, R8 */
		/* 820F43F4h case   28:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 820F43F4h case   28:*/		return 0x820F43F8;
		  /* 820F43F8h */ case   29:  		/* bc 12, CR6_EQ, 20 */
		/* 820F43F8h case   29:*/		if ( regs.CR[6].eq ) { return 0x820F440C;  }
		/* 820F43F8h case   29:*/		return 0x820F43FC;
		  /* 820F43FCh */ case   30:  		/* addi R10, R10, 1 */
		/* 820F43FCh case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F43FCh case   30:*/		return 0x820F4400;
		  /* 820F4400h */ case   31:  		/* addi R11, R11, 4 */
		/* 820F4400h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F4400h case   31:*/		return 0x820F4404;
		  /* 820F4404h */ case   32:  		/* cmplw CR6, R10, R9 */
		/* 820F4404h case   32:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F4404h case   32:*/		return 0x820F4408;
		  /* 820F4408h */ case   33:  		/* bc 12, CR6_LT, -24 */
		/* 820F4408h case   33:*/		if ( regs.CR[6].lt ) { return 0x820F43F0;  }
		/* 820F4408h case   33:*/		return 0x820F440C;
	}
	return 0x820F440C;
} // Block from 820F4384h-820F440Ch (34 instructions)

//////////////////////////////////////////////////////
// Block at 820F440Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F440C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F440C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F440C);
		  /* 820F440Ch */ case    0:  		/* cmplw CR6, R10, R9 */
		/* 820F440Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F440Ch case    0:*/		return 0x820F4410;
		  /* 820F4410h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 820F4410h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F4428;  }
		/* 820F4410h case    1:*/		return 0x820F4414;
		  /* 820F4414h */ case    2:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 820F4414h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 820F4414h case    2:*/		return 0x820F4418;
		  /* 820F4418h */ case    3:  		/* stwx R8, <#[R11 + R15]> */
		/* 820F4418h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R15 + 0x00000000) );
		/* 820F4418h case    3:*/		return 0x820F441C;
		  /* 820F441Ch */ case    4:  		/* lwz R11, <#[R1 + 124]> */
		/* 820F441Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820F441Ch case    4:*/		return 0x820F4420;
		  /* 820F4420h */ case    5:  		/* addi R11, R11, 1 */
		/* 820F4420h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F4420h case    5:*/		return 0x820F4424;
		  /* 820F4424h */ case    6:  		/* stw R11, <#[R1 + 124]> */
		/* 820F4424h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820F4424h case    6:*/		return 0x820F4428;
	}
	return 0x820F4428;
} // Block from 820F440Ch-820F4428h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F4428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4428);
		  /* 820F4428h */ case    0:  		/* sth R10, <#[R31]> */
		/* 820F4428h case    0:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820F4428h case    0:*/		return 0x820F442C;
	}
	return 0x820F442C;
} // Block from 820F4428h-820F442Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F442Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F442C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F442C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F442C);
		  /* 820F442Ch */ case    0:  		/* lwz R11, <#[R1 + 132]> */
		/* 820F442Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820F442Ch case    0:*/		return 0x820F4430;
		  /* 820F4430h */ case    1:  		/* addi R26, R26, 1 */
		/* 820F4430h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820F4430h case    1:*/		return 0x820F4434;
		  /* 820F4434h */ case    2:  		/* addi R28, R28, 6 */
		/* 820F4434h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x6);
		/* 820F4434h case    2:*/		return 0x820F4438;
		  /* 820F4438h */ case    3:  		/* addi R30, R30, 24 */
		/* 820F4438h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x18);
		/* 820F4438h case    3:*/		return 0x820F443C;
		  /* 820F443Ch */ case    4:  		/* addi R31, R31, 8 */
		/* 820F443Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 820F443Ch case    4:*/		return 0x820F4440;
		  /* 820F4440h */ case    5:  		/* cmplw CR6, R26, R11 */
		/* 820F4440h case    5:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 820F4440h case    5:*/		return 0x820F4444;
		  /* 820F4444h */ case    6:  		/* bc 12, CR6_LT, -312 */
		/* 820F4444h case    6:*/		if ( regs.CR[6].lt ) { return 0x820F430C;  }
		/* 820F4444h case    6:*/		return 0x820F4448;
	}
	return 0x820F4448;
} // Block from 820F442Ch-820F4448h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F4448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4448);
		  /* 820F4448h */ case    0:  		/* lwz R11, <#[R1 + 124]> */
		/* 820F4448h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820F4448h case    0:*/		return 0x820F444C;
		  /* 820F444Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820F444Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F444Ch case    1:*/		return 0x820F4450;
		  /* 820F4450h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820F4450h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F4478;  }
		/* 820F4450h case    2:*/		return 0x820F4454;
		  /* 820F4454h */ case    3:  		/* li R8, 10 */
		/* 820F4454h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0xA);
		/* 820F4454h case    3:*/		return 0x820F4458;
		  /* 820F4458h */ case    4:  		/* addi R7, R1, 128 */
		/* 820F4458h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x80);
		/* 820F4458h case    4:*/		return 0x820F445C;
		  /* 820F445Ch */ case    5:  		/* li R6, 1 */
		/* 820F445Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F445Ch case    5:*/		return 0x820F4460;
		  /* 820F4460h */ case    6:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820F4460h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820F4460h case    6:*/		return 0x820F4464;
		  /* 820F4464h */ case    7:  		/* mr R4, R15 */
		/* 820F4464h case    7:*/		regs.R4 = regs.R15;
		/* 820F4464h case    7:*/		return 0x820F4468;
		  /* 820F4468h */ case    8:  		/* addi R3, R1, 96 */
		/* 820F4468h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F4468h case    8:*/		return 0x820F446C;
		  /* 820F446Ch */ case    9:  		/* bl -156156 */
		/* 820F446Ch case    9:*/		regs.LR = 0x820F4470; return 0x820CE270;
		/* 820F446Ch case    9:*/		return 0x820F4470;
		  /* 820F4470h */ case   10:  		/* or. R29, R3, R3 */
		/* 820F4470h case   10:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F4470h case   10:*/		return 0x820F4474;
		  /* 820F4474h */ case   11:  		/* bc 12, CR0_LT, 1328 */
		/* 820F4474h case   11:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F4474h case   11:*/		return 0x820F4478;
	}
	return 0x820F4478;
} // Block from 820F4448h-820F4478h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F4478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4478);
		  /* 820F4478h */ case    0:  		/* li R8, 5 */
		/* 820F4478h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x5);
		/* 820F4478h case    0:*/		return 0x820F447C;
		  /* 820F447Ch */ case    1:  		/* addi R7, R1, 136 */
		/* 820F447Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x88);
		/* 820F447Ch case    1:*/		return 0x820F4480;
		  /* 820F4480h */ case    2:  		/* li R6, 1 */
		/* 820F4480h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F4480h case    2:*/		return 0x820F4484;
		  /* 820F4484h */ case    3:  		/* mr R5, R25 */
		/* 820F4484h case    3:*/		regs.R5 = regs.R25;
		/* 820F4484h case    3:*/		return 0x820F4488;
		  /* 820F4488h */ case    4:  		/* mr R4, R16 */
		/* 820F4488h case    4:*/		regs.R4 = regs.R16;
		/* 820F4488h case    4:*/		return 0x820F448C;
		  /* 820F448Ch */ case    5:  		/* addi R3, R1, 96 */
		/* 820F448Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F448Ch case    5:*/		return 0x820F4490;
		  /* 820F4490h */ case    6:  		/* bl -156192 */
		/* 820F4490h case    6:*/		regs.LR = 0x820F4494; return 0x820CE270;
		/* 820F4490h case    6:*/		return 0x820F4494;
		  /* 820F4494h */ case    7:  		/* or. R29, R3, R3 */
		/* 820F4494h case    7:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F4494h case    7:*/		return 0x820F4498;
		  /* 820F4498h */ case    8:  		/* bc 12, CR0_LT, 1292 */
		/* 820F4498h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F4498h case    8:*/		return 0x820F449C;
		  /* 820F449Ch */ case    9:  		/* cmplwi CR6, R24, 0 */
		/* 820F449Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820F449Ch case    9:*/		return 0x820F44A0;
		  /* 820F44A0h */ case   10:  		/* bc 12, CR6_EQ, 884 */
		/* 820F44A0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820F4814;  }
		/* 820F44A0h case   10:*/		return 0x820F44A4;
		  /* 820F44A4h */ case   11:  		/* lis R11, -32242 */
		/* 820F44A4h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820E);
		/* 820F44A4h case   11:*/		return 0x820F44A8;
		  /* 820F44A8h */ case   12:  		/* mr R6, R27 */
		/* 820F44A8h case   12:*/		regs.R6 = regs.R27;
		/* 820F44A8h case   12:*/		return 0x820F44AC;
		  /* 820F44ACh */ case   13:  		/* mr R5, R24 */
		/* 820F44ACh case   13:*/		regs.R5 = regs.R24;
		/* 820F44ACh case   13:*/		return 0x820F44B0;
		  /* 820F44B0h */ case   14:  		/* mr R4, R21 */
		/* 820F44B0h case   14:*/		regs.R4 = regs.R21;
		/* 820F44B0h case   14:*/		return 0x820F44B4;
		  /* 820F44B4h */ case   15:  		/* addi R3, R11, 14560 */
		/* 820F44B4h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x38E0);
		/* 820F44B4h case   15:*/		return 0x820F44B8;
		  /* 820F44B8h */ case   16:  		/* bl 39400 */
		/* 820F44B8h case   16:*/		regs.LR = 0x820F44BC; return 0x820FDEA0;
		/* 820F44B8h case   16:*/		return 0x820F44BC;
		  /* 820F44BCh */ case   17:  		/* li R8, 1 */
		/* 820F44BCh case   17:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F44BCh case   17:*/		return 0x820F44C0;
		  /* 820F44C0h */ case   18:  		/* cmplwi CR6, R24, 1 */
		/* 820F44C0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000001);
		/* 820F44C0h case   18:*/		return 0x820F44C4;
		  /* 820F44C4h */ case   19:  		/* stw R8, <#[R1 + 140]> */
		/* 820F44C4h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000008C) );
		/* 820F44C4h case   19:*/		return 0x820F44C8;
		  /* 820F44C8h */ case   20:  		/* bc 4, CR6_GT, 76 */
		/* 820F44C8h case   20:*/		if ( !regs.CR[6].gt ) { return 0x820F4514;  }
		/* 820F44C8h case   20:*/		return 0x820F44CC;
		  /* 820F44CCh */ case   21:  		/* addi R11, R24, -1 */
		/* 820F44CCh case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0xFFFFFFFF);
		/* 820F44CCh case   21:*/		return 0x820F44D0;
		  /* 820F44D0h */ case   22:  		/* lwz R9, <#[R27 + 20]> */
		/* 820F44D0h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 820F44D0h case   22:*/		return 0x820F44D4;
		  /* 820F44D4h */ case   23:  		/* addi R10, R21, 4 */
		/* 820F44D4h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R21,0x4);
		/* 820F44D4h case   23:*/		return 0x820F44D8;
		  /* 820F44D8h */ case   24:  		/* mtspr CTR, R11 */
		/* 820F44D8h case   24:*/		regs.CTR = regs.R11;
		/* 820F44D8h case   24:*/		return 0x820F44DC;
		  /* 820F44DCh */ case   25:  		/* lwz R11, <#[R10]> */
		/* 820F44DCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F44DCh case   25:*/		return 0x820F44E0;
		  /* 820F44E0h */ case   26:  		/* lwz R7, <#[R10 - 4]> */
		/* 820F44E0h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 820F44E0h case   26:*/		return 0x820F44E4;
		  /* 820F44E4h */ case   27:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F44E4h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F44E4h case   27:*/		return 0x820F44E8;
		  /* 820F44E8h */ case   28:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820F44E8h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820F44E8h case   28:*/		return 0x820F44EC;
		  /* 820F44ECh */ case   29:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F44ECh case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F44ECh case   29:*/		return 0x820F44F0;
		  /* 820F44F0h */ case   30:  		/* lwzx R7, <#[R7 + R9]> */
		/* 820F44F0h case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 820F44F0h case   30:*/		return 0x820F44F4;
		  /* 820F44F4h */ case   31:  		/* lwz R11, <#[R11 + 96]> */
		/* 820F44F4h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 820F44F4h case   31:*/		return 0x820F44F8;
		  /* 820F44F8h */ case   32:  		/* lwz R7, <#[R7 + 96]> */
		/* 820F44F8h case   32:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000060) );
		/* 820F44F8h case   32:*/		return 0x820F44FC;
		  /* 820F44FCh */ case   33:  		/* cmplw CR6, R7, R11 */
		/* 820F44FCh case   33:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820F44FCh case   33:*/		return 0x820F4500;
		  /* 820F4500h */ case   34:  		/* bc 12, CR6_EQ, 12 */
		/* 820F4500h case   34:*/		if ( regs.CR[6].eq ) { return 0x820F450C;  }
		/* 820F4500h case   34:*/		return 0x820F4504;
		  /* 820F4504h */ case   35:  		/* addi R8, R8, 1 */
		/* 820F4504h case   35:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F4504h case   35:*/		return 0x820F4508;
		  /* 820F4508h */ case   36:  		/* stw R8, <#[R1 + 140]> */
		/* 820F4508h case   36:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000008C) );
		/* 820F4508h case   36:*/		return 0x820F450C;
	}
	return 0x820F450C;
} // Block from 820F4478h-820F450Ch (37 instructions)

//////////////////////////////////////////////////////
// Block at 820F450Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F450C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F450C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F450C);
		  /* 820F450Ch */ case    0:  		/* addi R10, R10, 4 */
		/* 820F450Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F450Ch case    0:*/		return 0x820F4510;
		  /* 820F4510h */ case    1:  		/* bc 16, CR0_LT, -52 */
		/* 820F4510h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F44DC;  }
		/* 820F4510h case    1:*/		return 0x820F4514;
	}
	return 0x820F4514;
} // Block from 820F450Ch-820F4514h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F4514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4514);
		  /* 820F4514h */ case    0:  		/* mulli R3, R8, 20 */
		/* 820F4514h case    0:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R8,0x14);
		/* 820F4514h case    0:*/		return 0x820F4518;
		  /* 820F4518h */ case    1:  		/* lis R4, 9345 */
		/* 820F4518h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4518h case    1:*/		return 0x820F451C;
		  /* 820F451Ch */ case    2:  		/* bl -443164 */
		/* 820F451Ch case    2:*/		regs.LR = 0x820F4520; return 0x82088200;
		/* 820F451Ch case    2:*/		return 0x820F4520;
		  /* 820F4520h */ case    3:  		/* or. R17, R3, R3 */
		/* 820F4520h case    3:*/		cpu::op::or<1>(regs,&regs.R17,regs.R3,regs.R3);
		/* 820F4520h case    3:*/		return 0x820F4524;
		  /* 820F4524h */ case    4:  		/* bc 12, CR0_EQ, 1116 */
		/* 820F4524h case    4:*/		if ( regs.CR[0].eq ) { return 0x820F4980;  }
		/* 820F4524h case    4:*/		return 0x820F4528;
		  /* 820F4528h */ case    5:  		/* lwz R11, <#[R1 + 140]> */
		/* 820F4528h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 820F4528h case    5:*/		return 0x820F452C;
		  /* 820F452Ch */ case    6:  		/* li R4, 0 */
		/* 820F452Ch case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F452Ch case    6:*/		return 0x820F4530;
		  /* 820F4530h */ case    7:  		/* mr R3, R17 */
		/* 820F4530h case    7:*/		regs.R3 = regs.R17;
		/* 820F4530h case    7:*/		return 0x820F4534;
		  /* 820F4534h */ case    8:  		/* mulli R22, R11, 20 */
		/* 820F4534h case    8:*/		cpu::op::mulli<0>(regs,&regs.R22,regs.R11,0x14);
		/* 820F4534h case    8:*/		return 0x820F4538;
		  /* 820F4538h */ case    9:  		/* mr R5, R22 */
		/* 820F4538h case    9:*/		regs.R5 = regs.R22;
		/* 820F4538h case    9:*/		return 0x820F453C;
		  /* 820F453Ch */ case   10:  		/* bl -406012 */
		/* 820F453Ch case   10:*/		regs.LR = 0x820F4540; return 0x82091340;
		/* 820F453Ch case   10:*/		return 0x820F4540;
		  /* 820F4540h */ case   11:  		/* lwz R11, <#[R1 + 140]> */
		/* 820F4540h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 820F4540h case   11:*/		return 0x820F4544;
		  /* 820F4544h */ case   12:  		/* mr R31, R19 */
		/* 820F4544h case   12:*/		regs.R31 = regs.R19;
		/* 820F4544h case   12:*/		return 0x820F4548;
		  /* 820F4548h */ case   13:  		/* mr R23, R19 */
		/* 820F4548h case   13:*/		regs.R23 = regs.R19;
		/* 820F4548h case   13:*/		return 0x820F454C;
		  /* 820F454Ch */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 820F454Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F454Ch case   14:*/		return 0x820F4550;
		  /* 820F4550h */ case   15:  		/* bc 12, CR6_EQ, 672 */
		/* 820F4550h case   15:*/		if ( regs.CR[6].eq ) { return 0x820F47F0;  }
		/* 820F4550h case   15:*/		return 0x820F4554;
		  /* 820F4554h */ case   16:  		/* addi R30, R17, 12 */
		/* 820F4554h case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R17,0xC);
		/* 820F4554h case   16:*/		return 0x820F4558;
		  /* 820F4558h */ case   17:  		/* li R25, -1 */
		/* 820F4558h case   17:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 820F4558h case   17:*/		return 0x820F455C;
		  /* 820F455Ch */ case   18:  		/* rlwinm R28, R31, 2, 0, 29 */
		/* 820F455Ch case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R31);
		/* 820F455Ch case   18:*/		return 0x820F4560;
		  /* 820F4560h */ case   19:  		/* lwz R11, <#[R27 + 20]> */
		/* 820F4560h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 820F4560h case   19:*/		return 0x820F4564;
		  /* 820F4564h */ case   20:  		/* lwzx R10, <#[R28 + R21]> */
		/* 820F4564h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + regs.R21 + 0x00000000) );
		/* 820F4564h case   20:*/		return 0x820F4568;
		  /* 820F4568h */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F4568h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F4568h case   21:*/		return 0x820F456C;
		  /* 820F456Ch */ case   22:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820F456Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F456Ch case   22:*/		return 0x820F4570;
		  /* 820F4570h */ case   23:  		/* lwz R26, <#[R11 + 96]> */
		/* 820F4570h case   23:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x00000060) );
		/* 820F4570h case   23:*/		return 0x820F4574;
		  /* 820F4574h */ case   24:  		/* lwz R4, <#[R26 + 36]> */
		/* 820F4574h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000024) );
		/* 820F4574h case   24:*/		return 0x820F4578;
		  /* 820F4578h */ case   25:  		/* cmplwi CR6, R4, 0 */
		/* 820F4578h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F4578h case   25:*/		return 0x820F457C;
		  /* 820F457Ch */ case   26:  		/* bc 12, CR6_EQ, 36 */
		/* 820F457Ch case   26:*/		if ( regs.CR[6].eq ) { return 0x820F45A0;  }
		/* 820F457Ch case   26:*/		return 0x820F4580;
		  /* 820F4580h */ case   27:  		/* li R8, 1 */
		/* 820F4580h case   27:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F4580h case   27:*/		return 0x820F4584;
		  /* 820F4584h */ case   28:  		/* addi R7, R30, -12 */
		/* 820F4584h case   28:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R30,0xFFFFFFF4);
		/* 820F4584h case   28:*/		return 0x820F4588;
		  /* 820F4588h */ case   29:  		/* li R6, 7 */
		/* 820F4588h case   29:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 820F4588h case   29:*/		return 0x820F458C;
		  /* 820F458Ch */ case   30:  		/* mr R5, R18 */
		/* 820F458Ch case   30:*/		regs.R5 = regs.R18;
		/* 820F458Ch case   30:*/		return 0x820F4590;
		  /* 820F4590h */ case   31:  		/* addi R3, R1, 96 */
		/* 820F4590h case   31:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F4590h case   31:*/		return 0x820F4594;
		  /* 820F4594h */ case   32:  		/* bl -156452 */
		/* 820F4594h case   32:*/		regs.LR = 0x820F4598; return 0x820CE270;
		/* 820F4594h case   32:*/		return 0x820F4598;
		  /* 820F4598h */ case   33:  		/* or. R29, R3, R3 */
		/* 820F4598h case   33:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F4598h case   33:*/		return 0x820F459C;
		  /* 820F459Ch */ case   34:  		/* bc 12, CR0_LT, 1032 */
		/* 820F459Ch case   34:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F459Ch case   34:*/		return 0x820F45A0;
	}
	return 0x820F45A0;
} // Block from 820F4514h-820F45A0h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820F45A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F45A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F45A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F45A0);
		  /* 820F45A0h */ case    0:  		/* lwz R11, <#[R26 + 20]> */
		/* 820F45A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 820F45A0h case    0:*/		return 0x820F45A4;
		  /* 820F45A4h */ case    1:  		/* lwz R4, <#[R11 + 24]> */
		/* 820F45A4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000018) );
		/* 820F45A4h case    1:*/		return 0x820F45A8;
		  /* 820F45A8h */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 820F45A8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F45A8h case    2:*/		return 0x820F45AC;
		  /* 820F45ACh */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 820F45ACh case    3:*/		if ( regs.CR[6].eq ) { return 0x820F45D0;  }
		/* 820F45ACh case    3:*/		return 0x820F45B0;
		  /* 820F45B0h */ case    4:  		/* li R8, 1 */
		/* 820F45B0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F45B0h case    4:*/		return 0x820F45B4;
		  /* 820F45B4h */ case    5:  		/* addi R7, R30, -8 */
		/* 820F45B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R30,0xFFFFFFF8);
		/* 820F45B4h case    5:*/		return 0x820F45B8;
		  /* 820F45B8h */ case    6:  		/* li R6, 7 */
		/* 820F45B8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 820F45B8h case    6:*/		return 0x820F45BC;
		  /* 820F45BCh */ case    7:  		/* mr R5, R18 */
		/* 820F45BCh case    7:*/		regs.R5 = regs.R18;
		/* 820F45BCh case    7:*/		return 0x820F45C0;
		  /* 820F45C0h */ case    8:  		/* addi R3, R1, 96 */
		/* 820F45C0h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F45C0h case    8:*/		return 0x820F45C4;
		  /* 820F45C4h */ case    9:  		/* bl -156500 */
		/* 820F45C4h case    9:*/		regs.LR = 0x820F45C8; return 0x820CE270;
		/* 820F45C4h case    9:*/		return 0x820F45C8;
		  /* 820F45C8h */ case   10:  		/* or. R29, R3, R3 */
		/* 820F45C8h case   10:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F45C8h case   10:*/		return 0x820F45CC;
		  /* 820F45CCh */ case   11:  		/* bc 12, CR0_LT, 984 */
		/* 820F45CCh case   11:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F45CCh case   11:*/		return 0x820F45D0;
	}
	return 0x820F45D0;
} // Block from 820F45A0h-820F45D0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F45D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F45D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F45D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F45D0);
		  /* 820F45D0h */ case    0:  		/* lwz R11, <#[R26 + 16]> */
		/* 820F45D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820F45D0h case    0:*/		return 0x820F45D4;
		  /* 820F45D4h */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 820F45D4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820F45D4h case    1:*/		return 0x820F45D8;
		  /* 820F45D8h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820F45D8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F45E8;  }
		/* 820F45D8h case    2:*/		return 0x820F45DC;
		  /* 820F45DCh */ case    3:  		/* lwz R9, <#[R26 + 24]> */
		/* 820F45DCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000018) );
		/* 820F45DCh case    3:*/		return 0x820F45E0;
		  /* 820F45E0h */ case    4:  		/* lwz R4, <#[R9 + 48]> */
		/* 820F45E0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + 0x00000030) );
		/* 820F45E0h case    4:*/		return 0x820F45E4;
		  /* 820F45E4h */ case    5:  		/* b 20 */
		/* 820F45E4h case    5:*/		return 0x820F45F8;
		/* 820F45E4h case    5:*/		return 0x820F45E8;
	}
	return 0x820F45E8;
} // Block from 820F45D0h-820F45E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F45E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F45E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F45E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F45E8);
		  /* 820F45E8h */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 820F45E8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820F45E8h case    0:*/		return 0x820F45EC;
		  /* 820F45ECh */ case    1:  		/* bc 4, CR6_EQ, 60 */
		/* 820F45ECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F4628;  }
		/* 820F45ECh case    1:*/		return 0x820F45F0;
		  /* 820F45F0h */ case    2:  		/* lwz R9, <#[R26 + 24]> */
		/* 820F45F0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000018) );
		/* 820F45F0h case    2:*/		return 0x820F45F4;
		  /* 820F45F4h */ case    3:  		/* lwz R4, <#[R9 + 40]> */
		/* 820F45F4h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + 0x00000028) );
		/* 820F45F4h case    3:*/		return 0x820F45F8;
	}
	return 0x820F45F8;
} // Block from 820F45E8h-820F45F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F45F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F45F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F45F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F45F8);
		  /* 820F45F8h */ case    0:  		/* lwzx R11, <#[R28 + R21]> */
		/* 820F45F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R21 + 0x00000000) );
		/* 820F45F8h case    0:*/		return 0x820F45FC;
		  /* 820F45FCh */ case    1:  		/* addi R7, R30, -4 */
		/* 820F45FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R30,0xFFFFFFFC);
		/* 820F45FCh case    1:*/		return 0x820F4600;
		  /* 820F4600h */ case    2:  		/* lwz R10, <#[R27 + 20]> */
		/* 820F4600h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 820F4600h case    2:*/		return 0x820F4604;
		  /* 820F4604h */ case    3:  		/* li R5, 1 */
		/* 820F4604h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820F4604h case    3:*/		return 0x820F4608;
		  /* 820F4608h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F4608h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F4608h case    4:*/		return 0x820F460C;
		  /* 820F460Ch */ case    5:  		/* addi R3, R1, 96 */
		/* 820F460Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F460Ch case    5:*/		return 0x820F4610;
		  /* 820F4610h */ case    6:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F4610h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F4610h case    6:*/		return 0x820F4614;
		  /* 820F4614h */ case    7:  		/* lwz R11, <#[R11 + 60]> */
		/* 820F4614h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F4614h case    7:*/		return 0x820F4618;
		  /* 820F4618h */ case    8:  		/* rlwinm R6, R11, 0, 8, 10 */
		/* 820F4618h case    8:*/		cpu::op::rlwinm<0,0,8,10>(regs,&regs.R6,regs.R11);
		/* 820F4618h case    8:*/		return 0x820F461C;
		  /* 820F461Ch */ case    9:  		/* bl -12196 */
		/* 820F461Ch case    9:*/		regs.LR = 0x820F4620; return 0x820F1678;
		/* 820F461Ch case    9:*/		return 0x820F4620;
		  /* 820F4620h */ case   10:  		/* or. R29, R3, R3 */
		/* 820F4620h case   10:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F4620h case   10:*/		return 0x820F4624;
		  /* 820F4624h */ case   11:  		/* bc 12, CR0_LT, 896 */
		/* 820F4624h case   11:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F4624h case   11:*/		return 0x820F4628;
	}
	return 0x820F4628;
} // Block from 820F45F8h-820F4628h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F4628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4628);
		  /* 820F4628h */ case    0:  		/* mr R29, R31 */
		/* 820F4628h case    0:*/		regs.R29 = regs.R31;
		/* 820F4628h case    0:*/		return 0x820F462C;
		  /* 820F462Ch */ case    1:  		/* b 112 */
		/* 820F462Ch case    1:*/		return 0x820F469C;
		/* 820F462Ch case    1:*/		return 0x820F4630;
		  /* 820F4630h */ case    2:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 820F4630h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 820F4630h case    2:*/		return 0x820F4634;
		  /* 820F4634h */ case    3:  		/* lwz R9, <#[R27 + 20]> */
		/* 820F4634h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 820F4634h case    3:*/		return 0x820F4638;
		  /* 820F4638h */ case    4:  		/* add R10, R11, R21 */
		/* 820F4638h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R21);
		/* 820F4638h case    4:*/		return 0x820F463C;
		  /* 820F463Ch */ case    5:  		/* lwzx R11, <#[R11 + R21]> */
		/* 820F463Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R21 + 0x00000000) );
		/* 820F463Ch case    5:*/		return 0x820F4640;
		  /* 820F4640h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F4640h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F4640h case    6:*/		return 0x820F4644;
		  /* 820F4644h */ case    7:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F4644h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F4644h case    7:*/		return 0x820F4648;
		  /* 820F4648h */ case    8:  		/* lwz R8, <#[R11 + 96]> */
		/* 820F4648h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000060) );
		/* 820F4648h case    8:*/		return 0x820F464C;
		  /* 820F464Ch */ case    9:  		/* cmplw CR6, R26, R8 */
		/* 820F464Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R8);
		/* 820F464Ch case    9:*/		return 0x820F4650;
		  /* 820F4650h */ case   10:  		/* bc 4, CR6_EQ, 84 */
		/* 820F4650h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820F46A4;  }
		/* 820F4650h case   10:*/		return 0x820F4654;
		  /* 820F4654h */ case   11:  		/* lwz R8, <#[R11 + 116]> */
		/* 820F4654h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000074) );
		/* 820F4654h case   11:*/		return 0x820F4658;
		  /* 820F4658h */ case   12:  		/* b 48 */
		/* 820F4658h case   12:*/		return 0x820F4688;
		/* 820F4658h case   12:*/		return 0x820F465C;
		  /* 820F465Ch */ case   13:  		/* lwz R11, <#[R10]> */
		/* 820F465Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F465Ch case   13:*/		return 0x820F4660;
		  /* 820F4660h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F4660h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F4660h case   14:*/		return 0x820F4664;
		  /* 820F4664h */ case   15:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F4664h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F4664h case   15:*/		return 0x820F4668;
		  /* 820F4668h */ case   16:  		/* lwz R7, <#[R11 + 96]> */
		/* 820F4668h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000060) );
		/* 820F4668h case   16:*/		return 0x820F466C;
		  /* 820F466Ch */ case   17:  		/* cmplw CR6, R26, R7 */
		/* 820F466Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R7);
		/* 820F466Ch case   17:*/		return 0x820F4670;
		  /* 820F4670h */ case   18:  		/* bc 4, CR6_EQ, 32 */
		/* 820F4670h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820F4690;  }
		/* 820F4670h case   18:*/		return 0x820F4674;
		  /* 820F4674h */ case   19:  		/* lwz R11, <#[R11 + 116]> */
		/* 820F4674h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000074) );
		/* 820F4674h case   19:*/		return 0x820F4678;
		  /* 820F4678h */ case   20:  		/* cmplw CR6, R8, R11 */
		/* 820F4678h case   20:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820F4678h case   20:*/		return 0x820F467C;
		  /* 820F467Ch */ case   21:  		/* bc 4, CR6_EQ, 20 */
		/* 820F467Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x820F4690;  }
		/* 820F467Ch case   21:*/		return 0x820F4680;
		  /* 820F4680h */ case   22:  		/* addi R31, R31, 1 */
		/* 820F4680h case   22:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820F4680h case   22:*/		return 0x820F4684;
		  /* 820F4684h */ case   23:  		/* addi R10, R10, 4 */
		/* 820F4684h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F4684h case   23:*/		return 0x820F4688;
	}
	return 0x820F4688;
} // Block from 820F4628h-820F4688h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F4688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4688);
		  /* 820F4688h */ case    0:  		/* cmplw CR6, R31, R24 */
		/* 820F4688h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R24);
		/* 820F4688h case    0:*/		return 0x820F468C;
		  /* 820F468Ch */ case    1:  		/* bc 12, CR6_LT, -48 */
		/* 820F468Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x820F465C;  }
		/* 820F468Ch case    1:*/		return 0x820F4690;
	}
	return 0x820F4690;
} // Block from 820F4688h-820F4690h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F4690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4690);
		  /* 820F4690h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820F4690h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F4690h case    0:*/		return 0x820F4694;
		  /* 820F4694h */ case    1:  		/* addi R11, R11, 1 */
		/* 820F4694h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F4694h case    1:*/		return 0x820F4698;
		  /* 820F4698h */ case    2:  		/* stw R11, <#[R30]> */
		/* 820F4698h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F4698h case    2:*/		return 0x820F469C;
	}
	return 0x820F469C;
} // Block from 820F4690h-820F469Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F469Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F469C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F469C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F469C);
		  /* 820F469Ch */ case    0:  		/* cmplw CR6, R31, R24 */
		/* 820F469Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R24);
		/* 820F469Ch case    0:*/		return 0x820F46A0;
		  /* 820F46A0h */ case    1:  		/* bc 12, CR6_LT, -112 */
		/* 820F46A0h case    1:*/		if ( regs.CR[6].lt ) { return 0x820F4630;  }
		/* 820F46A0h case    1:*/		return 0x820F46A4;
	}
	return 0x820F46A4;
} // Block from 820F469Ch-820F46A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F46A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F46A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F46A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F46A4);
		  /* 820F46A4h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820F46A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F46A4h case    0:*/		return 0x820F46A8;
		  /* 820F46A8h */ case    1:  		/* lis R4, 9345 */
		/* 820F46A8h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F46A8h case    1:*/		return 0x820F46AC;
		  /* 820F46ACh */ case    2:  		/* mulli R3, R11, 12 */
		/* 820F46ACh case    2:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R11,0xC);
		/* 820F46ACh case    2:*/		return 0x820F46B0;
		  /* 820F46B0h */ case    3:  		/* bl -443568 */
		/* 820F46B0h case    3:*/		regs.LR = 0x820F46B4; return 0x82088200;
		/* 820F46B0h case    3:*/		return 0x820F46B4;
		  /* 820F46B4h */ case    4:  		/* or. R20, R3, R3 */
		/* 820F46B4h case    4:*/		cpu::op::or<1>(regs,&regs.R20,regs.R3,regs.R3);
		/* 820F46B4h case    4:*/		return 0x820F46B8;
		  /* 820F46B8h */ case    5:  		/* bc 12, CR0_EQ, 712 */
		/* 820F46B8h case    5:*/		if ( regs.CR[0].eq ) { return 0x820F4980;  }
		/* 820F46B8h case    5:*/		return 0x820F46BC;
		  /* 820F46BCh */ case    6:  		/* lwz R11, <#[R30]> */
		/* 820F46BCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F46BCh case    6:*/		return 0x820F46C0;
		  /* 820F46C0h */ case    7:  		/* li R4, 0 */
		/* 820F46C0h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F46C0h case    7:*/		return 0x820F46C4;
		  /* 820F46C4h */ case    8:  		/* mr R3, R20 */
		/* 820F46C4h case    8:*/		regs.R3 = regs.R20;
		/* 820F46C4h case    8:*/		return 0x820F46C8;
		  /* 820F46C8h */ case    9:  		/* mulli R28, R11, 12 */
		/* 820F46C8h case    9:*/		cpu::op::mulli<0>(regs,&regs.R28,regs.R11,0xC);
		/* 820F46C8h case    9:*/		return 0x820F46CC;
		  /* 820F46CCh */ case   10:  		/* mr R5, R28 */
		/* 820F46CCh case   10:*/		regs.R5 = regs.R28;
		/* 820F46CCh case   10:*/		return 0x820F46D0;
		  /* 820F46D0h */ case   11:  		/* bl -406416 */
		/* 820F46D0h case   11:*/		regs.LR = 0x820F46D4; return 0x82091340;
		/* 820F46D0h case   11:*/		return 0x820F46D4;
		  /* 820F46D4h */ case   12:  		/* mr R31, R29 */
		/* 820F46D4h case   12:*/		regs.R31 = regs.R29;
		/* 820F46D4h case   12:*/		return 0x820F46D8;
		  /* 820F46D8h */ case   13:  		/* stw R19, <#[R30]> */
		/* 820F46D8h case   13:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R30 + 0x00000000) );
		/* 820F46D8h case   13:*/		return 0x820F46DC;
		  /* 820F46DCh */ case   14:  		/* cmplw CR6, R29, R24 */
		/* 820F46DCh case   14:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R24);
		/* 820F46DCh case   14:*/		return 0x820F46E0;
		  /* 820F46E0h */ case   15:  		/* bc 4, CR6_LT, 212 */
		/* 820F46E0h case   15:*/		if ( !regs.CR[6].lt ) { return 0x820F47B4;  }
		/* 820F46E0h case   15:*/		return 0x820F46E4;
		  /* 820F46E4h */ case   16:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 820F46E4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 820F46E4h case   16:*/		return 0x820F46E8;
		  /* 820F46E8h */ case   17:  		/* lwz R10, <#[R27 + 20]> */
		/* 820F46E8h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 820F46E8h case   17:*/		return 0x820F46EC;
		  /* 820F46ECh */ case   18:  		/* add R9, R11, R21 */
		/* 820F46ECh case   18:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R21);
		/* 820F46ECh case   18:*/		return 0x820F46F0;
		  /* 820F46F0h */ case   19:  		/* lwzx R11, <#[R11 + R21]> */
		/* 820F46F0h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R21 + 0x00000000) );
		/* 820F46F0h case   19:*/		return 0x820F46F4;
		  /* 820F46F4h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F46F4h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F46F4h case   20:*/		return 0x820F46F8;
		  /* 820F46F8h */ case   21:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F46F8h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F46F8h case   21:*/		return 0x820F46FC;
		  /* 820F46FCh */ case   22:  		/* lwz R10, <#[R11 + 96]> */
		/* 820F46FCh case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 820F46FCh case   22:*/		return 0x820F4700;
		  /* 820F4700h */ case   23:  		/* cmplw CR6, R26, R10 */
		/* 820F4700h case   23:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 820F4700h case   23:*/		return 0x820F4704;
		  /* 820F4704h */ case   24:  		/* bc 4, CR6_EQ, 176 */
		/* 820F4704h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820F47B4;  }
		/* 820F4704h case   24:*/		return 0x820F4708;
		  /* 820F4708h */ case   25:  		/* lwz R10, <#[R30]> */
		/* 820F4708h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820F4708h case   25:*/		return 0x820F470C;
		  /* 820F470Ch */ case   26:  		/* cmplw CR6, R31, R24 */
		/* 820F470Ch case   26:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R24);
		/* 820F470Ch case   26:*/		return 0x820F4710;
		  /* 820F4710h */ case   27:  		/* lwz R8, <#[R11 + 116]> */
		/* 820F4710h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000074) );
		/* 820F4710h case   27:*/		return 0x820F4714;
		  /* 820F4714h */ case   28:  		/* mulli R11, R10, 12 */
		/* 820F4714h case   28:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R10,0xC);
		/* 820F4714h case   28:*/		return 0x820F4718;
		  /* 820F4718h */ case   29:  		/* stwx R8, <#[R11 + R20]> */
		/* 820F4718h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 820F4718h case   29:*/		return 0x820F471C;
		  /* 820F471Ch */ case   30:  		/* lwz R11, <#[R30]> */
		/* 820F471Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F471Ch case   30:*/		return 0x820F4720;
		  /* 820F4720h */ case   31:  		/* mulli R11, R11, 12 */
		/* 820F4720h case   31:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 820F4720h case   31:*/		return 0x820F4724;
		  /* 820F4724h */ case   32:  		/* add R11, R11, R20 */
		/* 820F4724h case   32:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R20);
		/* 820F4724h case   32:*/		return 0x820F4728;
		  /* 820F4728h */ case   33:  		/* addi R10, R11, 4 */
		/* 820F4728h case   33:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 820F4728h case   33:*/		return 0x820F472C;
		  /* 820F472Ch */ case   34:  		/* stw R25, <#[R11 + 4]> */
		/* 820F472Ch case   34:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000004) );
		/* 820F472Ch case   34:*/		return 0x820F4730;
		  /* 820F4730h */ case   35:  		/* stw R25, <#[R11 + 8]> */
		/* 820F4730h case   35:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000008) );
		/* 820F4730h case   35:*/		return 0x820F4734;
		  /* 820F4734h */ case   36:  		/* bc 4, CR6_LT, 108 */
		/* 820F4734h case   36:*/		if ( !regs.CR[6].lt ) { return 0x820F47A0;  }
		/* 820F4734h case   36:*/		return 0x820F4738;
		  /* 820F4738h */ case   37:  		/* addi R11, R9, -4 */
		/* 820F4738h case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFC);
		/* 820F4738h case   37:*/		return 0x820F473C;
		  /* 820F473Ch */ case   38:  		/* lwz R10, <#[R11 + 4]> */
		/* 820F473Ch case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820F473Ch case   38:*/		return 0x820F4740;
		  /* 820F4740h */ case   39:  		/* lwz R9, <#[R27 + 20]> */
		/* 820F4740h case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000014) );
		/* 820F4740h case   39:*/		return 0x820F4744;
		  /* 820F4744h */ case   40:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F4744h case   40:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F4744h case   40:*/		return 0x820F4748;
		  /* 820F4748h */ case   41:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820F4748h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F4748h case   41:*/		return 0x820F474C;
		  /* 820F474Ch */ case   42:  		/* lwz R7, <#[R10 + 96]> */
		/* 820F474Ch case   42:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000060) );
		/* 820F474Ch case   42:*/		return 0x820F4750;
		  /* 820F4750h */ case   43:  		/* cmplw CR6, R26, R7 */
		/* 820F4750h case   43:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R7);
		/* 820F4750h case   43:*/		return 0x820F4754;
		  /* 820F4754h */ case   44:  		/* bc 4, CR6_EQ, 76 */
		/* 820F4754h case   44:*/		if ( !regs.CR[6].eq ) { return 0x820F47A0;  }
		/* 820F4754h case   44:*/		return 0x820F4758;
		  /* 820F4758h */ case   45:  		/* lwz R10, <#[R10 + 116]> */
		/* 820F4758h case   45:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000074) );
		/* 820F4758h case   45:*/		return 0x820F475C;
		  /* 820F475Ch */ case   46:  		/* cmplw CR6, R8, R10 */
		/* 820F475Ch case   46:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 820F475Ch case   46:*/		return 0x820F4760;
		  /* 820F4760h */ case   47:  		/* bc 4, CR6_EQ, 64 */
		/* 820F4760h case   47:*/		if ( !regs.CR[6].eq ) { return 0x820F47A0;  }
		/* 820F4760h case   47:*/		return 0x820F4764;
		  /* 820F4764h */ case   48:  		/* lwzu R10, <#[R11 + 4]> */
		/* 820F4764h case   48:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820F4764h case   48:*/		return 0x820F4768;
		  /* 820F4768h */ case   49:  		/* addi R31, R31, 1 */
		/* 820F4768h case   49:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820F4768h case   49:*/		return 0x820F476C;
		  /* 820F476Ch */ case   50:  		/* lwz R7, <#[R30]> */
		/* 820F476Ch case   50:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000000) );
		/* 820F476Ch case   50:*/		return 0x820F4770;
		  /* 820F4770h */ case   51:  		/* rlwinm R6, R10, 2, 0, 29 */
		/* 820F4770h case   51:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R10);
		/* 820F4770h case   51:*/		return 0x820F4774;
		  /* 820F4774h */ case   52:  		/* mulli R10, R7, 6 */
		/* 820F4774h case   52:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R7,0x6);
		/* 820F4774h case   52:*/		return 0x820F4778;
		  /* 820F4778h */ case   53:  		/* lwzx R7, <#[R6 + R9]> */
		/* 820F4778h case   53:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + regs.R9 + 0x00000000) );
		/* 820F4778h case   53:*/		return 0x820F477C;
		  /* 820F477Ch */ case   54:  		/* cmplw CR6, R31, R24 */
		/* 820F477Ch case   54:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R24);
		/* 820F477Ch case   54:*/		return 0x820F4780;
		  /* 820F4780h */ case   55:  		/* lwz R9, <#[R7 + 16]> */
		/* 820F4780h case   55:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000010) );
		/* 820F4780h case   55:*/		return 0x820F4784;
		  /* 820F4784h */ case   56:  		/* lwz R7, <#[R7 + 100]> */
		/* 820F4784h case   56:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000064) );
		/* 820F4784h case   56:*/		return 0x820F4788;
		  /* 820F4788h */ case   57:  		/* add R10, R9, R10 */
		/* 820F4788h case   57:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820F4788h case   57:*/		return 0x820F478C;
		  /* 820F478Ch */ case   58:  		/* rlwinm R9, R7, 0, 16, 31 */
		/* 820F478Ch case   58:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R7);
		/* 820F478Ch case   58:*/		return 0x820F4790;
		  /* 820F4790h */ case   59:  		/* addi R10, R10, 2 */
		/* 820F4790h case   59:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 820F4790h case   59:*/		return 0x820F4794;
		  /* 820F4794h */ case   60:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 820F4794h case   60:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 820F4794h case   60:*/		return 0x820F4798;
		  /* 820F4798h */ case   61:  		/* sthx R9, <#[R10 + R20]> */
		/* 820F4798h case   61:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + regs.R20 + 0x00000000) );
		/* 820F4798h case   61:*/		return 0x820F479C;
		  /* 820F479Ch */ case   62:  		/* bc 12, CR6_LT, -96 */
		/* 820F479Ch case   62:*/		if ( regs.CR[6].lt ) { return 0x820F473C;  }
		/* 820F479Ch case   62:*/		return 0x820F47A0;
	}
	return 0x820F47A0;
} // Block from 820F46A4h-820F47A0h (63 instructions)

//////////////////////////////////////////////////////
// Block at 820F47A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F47A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F47A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F47A0);
		  /* 820F47A0h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820F47A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F47A0h case    0:*/		return 0x820F47A4;
		  /* 820F47A4h */ case    1:  		/* cmplw CR6, R31, R24 */
		/* 820F47A4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R24);
		/* 820F47A4h case    1:*/		return 0x820F47A8;
		  /* 820F47A8h */ case    2:  		/* addi R11, R11, 1 */
		/* 820F47A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F47A8h case    2:*/		return 0x820F47AC;
		  /* 820F47ACh */ case    3:  		/* stw R11, <#[R30]> */
		/* 820F47ACh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820F47ACh case    3:*/		return 0x820F47B0;
		  /* 820F47B0h */ case    4:  		/* bc 12, CR6_LT, -204 */
		/* 820F47B0h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F46E4;  }
		/* 820F47B0h case    4:*/		return 0x820F47B4;
	}
	return 0x820F47B4;
} // Block from 820F47A0h-820F47B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F47B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F47B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F47B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F47B4);
		  /* 820F47B4h */ case    0:  		/* li R8, 8 */
		/* 820F47B4h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x8);
		/* 820F47B4h case    0:*/		return 0x820F47B8;
		  /* 820F47B8h */ case    1:  		/* addi R7, R30, 4 */
		/* 820F47B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R30,0x4);
		/* 820F47B8h case    1:*/		return 0x820F47BC;
		  /* 820F47BCh */ case    2:  		/* li R6, 11 */
		/* 820F47BCh case    2:*/		cpu::op::li<0>(regs,&regs.R6,0xB);
		/* 820F47BCh case    2:*/		return 0x820F47C0;
		  /* 820F47C0h */ case    3:  		/* mr R5, R28 */
		/* 820F47C0h case    3:*/		regs.R5 = regs.R28;
		/* 820F47C0h case    3:*/		return 0x820F47C4;
		  /* 820F47C4h */ case    4:  		/* mr R4, R20 */
		/* 820F47C4h case    4:*/		regs.R4 = regs.R20;
		/* 820F47C4h case    4:*/		return 0x820F47C8;
		  /* 820F47C8h */ case    5:  		/* addi R3, R1, 96 */
		/* 820F47C8h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F47C8h case    5:*/		return 0x820F47CC;
		  /* 820F47CCh */ case    6:  		/* bl -157020 */
		/* 820F47CCh case    6:*/		regs.LR = 0x820F47D0; return 0x820CE270;
		/* 820F47CCh case    6:*/		return 0x820F47D0;
		  /* 820F47D0h */ case    7:  		/* or. R29, R3, R3 */
		/* 820F47D0h case    7:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F47D0h case    7:*/		return 0x820F47D4;
		  /* 820F47D4h */ case    8:  		/* bc 12, CR0_LT, 464 */
		/* 820F47D4h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F47D4h case    8:*/		return 0x820F47D8;
		  /* 820F47D8h */ case    9:  		/* lwz R11, <#[R1 + 140]> */
		/* 820F47D8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 820F47D8h case    9:*/		return 0x820F47DC;
		  /* 820F47DCh */ case   10:  		/* addi R23, R23, 1 */
		/* 820F47DCh case   10:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 820F47DCh case   10:*/		return 0x820F47E0;
		  /* 820F47E0h */ case   11:  		/* mr R20, R19 */
		/* 820F47E0h case   11:*/		regs.R20 = regs.R19;
		/* 820F47E0h case   11:*/		return 0x820F47E4;
		  /* 820F47E4h */ case   12:  		/* addi R30, R30, 20 */
		/* 820F47E4h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x14);
		/* 820F47E4h case   12:*/		return 0x820F47E8;
		  /* 820F47E8h */ case   13:  		/* cmplw CR6, R23, R11 */
		/* 820F47E8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R11);
		/* 820F47E8h case   13:*/		return 0x820F47EC;
		  /* 820F47ECh */ case   14:  		/* bc 12, CR6_LT, -656 */
		/* 820F47ECh case   14:*/		if ( regs.CR[6].lt ) { return 0x820F455C;  }
		/* 820F47ECh case   14:*/		return 0x820F47F0;
	}
	return 0x820F47F0;
} // Block from 820F47B4h-820F47F0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820F47F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F47F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F47F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F47F0);
		  /* 820F47F0h */ case    0:  		/* li R8, 7 */
		/* 820F47F0h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x7);
		/* 820F47F0h case    0:*/		return 0x820F47F4;
		  /* 820F47F4h */ case    1:  		/* addi R7, R1, 144 */
		/* 820F47F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x90);
		/* 820F47F4h case    1:*/		return 0x820F47F8;
		  /* 820F47F8h */ case    2:  		/* li R6, 1 */
		/* 820F47F8h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F47F8h case    2:*/		return 0x820F47FC;
		  /* 820F47FCh */ case    3:  		/* mr R5, R22 */
		/* 820F47FCh case    3:*/		regs.R5 = regs.R22;
		/* 820F47FCh case    3:*/		return 0x820F4800;
		  /* 820F4800h */ case    4:  		/* mr R4, R17 */
		/* 820F4800h case    4:*/		regs.R4 = regs.R17;
		/* 820F4800h case    4:*/		return 0x820F4804;
		  /* 820F4804h */ case    5:  		/* addi R3, R1, 96 */
		/* 820F4804h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F4804h case    5:*/		return 0x820F4808;
		  /* 820F4808h */ case    6:  		/* bl -157080 */
		/* 820F4808h case    6:*/		regs.LR = 0x820F480C; return 0x820CE270;
		/* 820F4808h case    6:*/		return 0x820F480C;
		  /* 820F480Ch */ case    7:  		/* or. R29, R3, R3 */
		/* 820F480Ch case    7:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F480Ch case    7:*/		return 0x820F4810;
		  /* 820F4810h */ case    8:  		/* bc 12, CR0_LT, 404 */
		/* 820F4810h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F4810h case    8:*/		return 0x820F4814;
	}
	return 0x820F4814;
} // Block from 820F47F0h-820F4814h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F4814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4814);
		  /* 820F4814h */ case    0:  		/* lwz R4, <#[R27 + 208]> */
		/* 820F4814h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x000000D0) );
		/* 820F4814h case    0:*/		return 0x820F4818;
		  /* 820F4818h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 820F4818h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F4818h case    1:*/		return 0x820F481C;
		  /* 820F481Ch */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820F481Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820F4840;  }
		/* 820F481Ch case    2:*/		return 0x820F4820;
		  /* 820F4820h */ case    3:  		/* li R8, 1 */
		/* 820F4820h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F4820h case    3:*/		return 0x820F4824;
		  /* 820F4824h */ case    4:  		/* addi R7, R1, 148 */
		/* 820F4824h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x94);
		/* 820F4824h case    4:*/		return 0x820F4828;
		  /* 820F4828h */ case    5:  		/* li R6, 7 */
		/* 820F4828h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 820F4828h case    5:*/		return 0x820F482C;
		  /* 820F482Ch */ case    6:  		/* mr R5, R18 */
		/* 820F482Ch case    6:*/		regs.R5 = regs.R18;
		/* 820F482Ch case    6:*/		return 0x820F4830;
		  /* 820F4830h */ case    7:  		/* addi R3, R1, 96 */
		/* 820F4830h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F4830h case    7:*/		return 0x820F4834;
		  /* 820F4834h */ case    8:  		/* bl -157124 */
		/* 820F4834h case    8:*/		regs.LR = 0x820F4838; return 0x820CE270;
		/* 820F4834h case    8:*/		return 0x820F4838;
		  /* 820F4838h */ case    9:  		/* or. R29, R3, R3 */
		/* 820F4838h case    9:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F4838h case    9:*/		return 0x820F483C;
		  /* 820F483Ch */ case   10:  		/* bc 12, CR0_LT, 360 */
		/* 820F483Ch case   10:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F483Ch case   10:*/		return 0x820F4840;
	}
	return 0x820F4840;
} // Block from 820F4814h-820F4840h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F4840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4840);
		  /* 820F4840h */ case    0:  		/* lwz R4, <#[R27 + 308]> */
		/* 820F4840h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000134) );
		/* 820F4840h case    0:*/		return 0x820F4844;
		  /* 820F4844h */ case    1:  		/* lis R11, -32256 */
		/* 820F4844h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820F4844h case    1:*/		return 0x820F4848;
		  /* 820F4848h */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 820F4848h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820F4848h case    2:*/		return 0x820F484C;
		  /* 820F484Ch */ case    3:  		/* addi R31, R11, 4485 */
		/* 820F484Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x1185);
		/* 820F484Ch case    3:*/		return 0x820F4850;
		  /* 820F4850h */ case    4:  		/* bc 12, CR6_EQ, 72 */
		/* 820F4850h case    4:*/		if ( regs.CR[6].eq ) { return 0x820F4898;  }
		/* 820F4850h case    4:*/		return 0x820F4854;
		  /* 820F4854h */ case    5:  		/* li R8, 1 */
		/* 820F4854h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F4854h case    5:*/		return 0x820F4858;
		  /* 820F4858h */ case    6:  		/* lwz R5, <#[R27 + 312]> */
		/* 820F4858h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x00000138) );
		/* 820F4858h case    6:*/		return 0x820F485C;
		  /* 820F485Ch */ case    7:  		/* addi R7, R1, 120 */
		/* 820F485Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x78);
		/* 820F485Ch case    7:*/		return 0x820F4860;
		  /* 820F4860h */ case    8:  		/* li R6, 5 */
		/* 820F4860h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 820F4860h case    8:*/		return 0x820F4864;
		  /* 820F4864h */ case    9:  		/* addi R3, R1, 96 */
		/* 820F4864h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F4864h case    9:*/		return 0x820F4868;
		  /* 820F4868h */ case   10:  		/* bl -157176 */
		/* 820F4868h case   10:*/		regs.LR = 0x820F486C; return 0x820CE270;
		/* 820F4868h case   10:*/		return 0x820F486C;
		  /* 820F486Ch */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820F486Ch case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F486Ch case   11:*/		return 0x820F4870;
		  /* 820F4870h */ case   12:  		/* bc 12, CR0_LT, 308 */
		/* 820F4870h case   12:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F4870h case   12:*/		return 0x820F4874;
		  /* 820F4874h */ case   13:  		/* mr R4, R31 */
		/* 820F4874h case   13:*/		regs.R4 = regs.R31;
		/* 820F4874h case   13:*/		return 0x820F4878;
		  /* 820F4878h */ case   14:  		/* li R8, 1 */
		/* 820F4878h case   14:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F4878h case   14:*/		return 0x820F487C;
		  /* 820F487Ch */ case   15:  		/* li R7, 0 */
		/* 820F487Ch case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F487Ch case   15:*/		return 0x820F4880;
		  /* 820F4880h */ case   16:  		/* li R6, 5 */
		/* 820F4880h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 820F4880h case   16:*/		return 0x820F4884;
		  /* 820F4884h */ case   17:  		/* li R5, 1 */
		/* 820F4884h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820F4884h case   17:*/		return 0x820F4888;
		  /* 820F4888h */ case   18:  		/* addi R3, R1, 96 */
		/* 820F4888h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F4888h case   18:*/		return 0x820F488C;
		  /* 820F488Ch */ case   19:  		/* bl -157212 */
		/* 820F488Ch case   19:*/		regs.LR = 0x820F4890; return 0x820CE270;
		/* 820F488Ch case   19:*/		return 0x820F4890;
		  /* 820F4890h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820F4890h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F4890h case   20:*/		return 0x820F4894;
		  /* 820F4894h */ case   21:  		/* bc 12, CR0_LT, 272 */
		/* 820F4894h case   21:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F4894h case   21:*/		return 0x820F4898;
	}
	return 0x820F4898;
} // Block from 820F4840h-820F4898h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820F4898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4898);
		  /* 820F4898h */ case    0:  		/* mr R4, R31 */
		/* 820F4898h case    0:*/		regs.R4 = regs.R31;
		/* 820F4898h case    0:*/		return 0x820F489C;
		  /* 820F489Ch */ case    1:  		/* li R8, 1 */
		/* 820F489Ch case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F489Ch case    1:*/		return 0x820F48A0;
		  /* 820F48A0h */ case    2:  		/* addi R7, R1, 116 */
		/* 820F48A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x74);
		/* 820F48A0h case    2:*/		return 0x820F48A4;
		  /* 820F48A4h */ case    3:  		/* li R6, 5 */
		/* 820F48A4h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 820F48A4h case    3:*/		return 0x820F48A8;
		  /* 820F48A8h */ case    4:  		/* mr R5, R18 */
		/* 820F48A8h case    4:*/		regs.R5 = regs.R18;
		/* 820F48A8h case    4:*/		return 0x820F48AC;
		  /* 820F48ACh */ case    5:  		/* addi R3, R1, 96 */
		/* 820F48ACh case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F48ACh case    5:*/		return 0x820F48B0;
		  /* 820F48B0h */ case    6:  		/* bl -157248 */
		/* 820F48B0h case    6:*/		regs.LR = 0x820F48B4; return 0x820CE270;
		/* 820F48B0h case    6:*/		return 0x820F48B4;
		  /* 820F48B4h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F48B4h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F48B4h case    7:*/		return 0x820F48B8;
		  /* 820F48B8h */ case    8:  		/* bc 12, CR0_LT, 236 */
		/* 820F48B8h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F48B8h case    8:*/		return 0x820F48BC;
		  /* 820F48BCh */ case    9:  		/* addi R3, R1, 96 */
		/* 820F48BCh case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F48BCh case    9:*/		return 0x820F48C0;
		  /* 820F48C0h */ case   10:  		/* bl -157408 */
		/* 820F48C0h case   10:*/		regs.LR = 0x820F48C4; return 0x820CE1E0;
		/* 820F48C0h case   10:*/		return 0x820F48C4;
		  /* 820F48C4h */ case   11:  		/* mr R31, R3 */
		/* 820F48C4h case   11:*/		regs.R31 = regs.R3;
		/* 820F48C4h case   11:*/		return 0x820F48C8;
		  /* 820F48C8h */ case   12:  		/* cmplwi CR6, R3, 32768 */
		/* 820F48C8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00008000);
		/* 820F48C8h case   12:*/		return 0x820F48CC;
		  /* 820F48CCh */ case   13:  		/* mr R3, R27 */
		/* 820F48CCh case   13:*/		regs.R3 = regs.R27;
		/* 820F48CCh case   13:*/		return 0x820F48D0;
		  /* 820F48D0h */ case   14:  		/* bc 12, CR6_GT, 188 */
		/* 820F48D0h case   14:*/		if ( regs.CR[6].gt ) { return 0x820F498C;  }
		/* 820F48D0h case   14:*/		return 0x820F48D4;
		  /* 820F48D4h */ case   15:  		/* mr R4, R31 */
		/* 820F48D4h case   15:*/		regs.R4 = regs.R31;
		/* 820F48D4h case   15:*/		return 0x820F48D8;
		  /* 820F48D8h */ case   16:  		/* bl -12104 */
		/* 820F48D8h case   16:*/		regs.LR = 0x820F48DC; return 0x820F1990;
		/* 820F48D8h case   16:*/		return 0x820F48DC;
		  /* 820F48DCh */ case   17:  		/* or. R29, R3, R3 */
		/* 820F48DCh case   17:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F48DCh case   17:*/		return 0x820F48E0;
		  /* 820F48E0h */ case   18:  		/* bc 12, CR0_LT, 196 */
		/* 820F48E0h case   18:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F48E0h case   18:*/		return 0x820F48E4;
		  /* 820F48E4h */ case   19:  		/* lwz R10, <#[R27 + 276]> */
		/* 820F48E4h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000114) );
		/* 820F48E4h case   19:*/		return 0x820F48E8;
		  /* 820F48E8h */ case   20:  		/* addi R9, R31, 1 */
		/* 820F48E8h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x1);
		/* 820F48E8h case   20:*/		return 0x820F48EC;
		  /* 820F48ECh */ case   21:  		/* lwz R11, <#[R27 + 272]> */
		/* 820F48ECh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000110) );
		/* 820F48ECh case   21:*/		return 0x820F48F0;
		  /* 820F48F0h */ case   22:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F48F0h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F48F0h case   22:*/		return 0x820F48F4;
		  /* 820F48F4h */ case   23:  		/* addi R10, R10, -1 */
		/* 820F48F4h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820F48F4h case   23:*/		return 0x820F48F8;
		  /* 820F48F8h */ case   24:  		/* addi R4, R11, 4 */
		/* 820F48F8h case   24:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 820F48F8h case   24:*/		return 0x820F48FC;
		  /* 820F48FCh */ case   25:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 820F48FCh case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 820F48FCh case   25:*/		return 0x820F4900;
		  /* 820F4900h */ case   26:  		/* add R3, R9, R11 */
		/* 820F4900h case   26:*/		cpu::op::add<0>(regs,&regs.R3,regs.R9,regs.R11);
		/* 820F4900h case   26:*/		return 0x820F4904;
		  /* 820F4904h */ case   27:  		/* bl -403940 */
		/* 820F4904h case   27:*/		regs.LR = 0x820F4908; return 0x82091F20;
		/* 820F4904h case   27:*/		return 0x820F4908;
		  /* 820F4908h */ case   28:  		/* lwz R10, <#[R1 + 132]> */
		/* 820F4908h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000084) );
		/* 820F4908h case   28:*/		return 0x820F490C;
		  /* 820F490Ch */ case   29:  		/* mr R11, R19 */
		/* 820F490Ch case   29:*/		regs.R11 = regs.R19;
		/* 820F490Ch case   29:*/		return 0x820F4910;
		  /* 820F4910h */ case   30:  		/* cmplwi CR6, R10, 0 */
		/* 820F4910h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F4910h case   30:*/		return 0x820F4914;
		  /* 820F4914h */ case   31:  		/* bc 12, CR6_EQ, 48 */
		/* 820F4914h case   31:*/		if ( regs.CR[6].eq ) { return 0x820F4944;  }
		/* 820F4914h case   31:*/		return 0x820F4918;
		  /* 820F4918h */ case   32:  		/* addi R10, R16, -4 */
		/* 820F4918h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R16,0xFFFFFFFC);
		/* 820F4918h case   32:*/		return 0x820F491C;
		  /* 820F491Ch */ case   33:  		/* lwz R9, <#[R27 + 292]> */
		/* 820F491Ch case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000124) );
		/* 820F491Ch case   33:*/		return 0x820F4920;
		  /* 820F4920h */ case   34:  		/* addi R11, R11, 1 */
		/* 820F4920h case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F4920h case   34:*/		return 0x820F4924;
		  /* 820F4924h */ case   35:  		/* lwz R8, <#[R10 + 8]> */
		/* 820F4924h case   35:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 820F4924h case   35:*/		return 0x820F4928;
		  /* 820F4928h */ case   36:  		/* add R9, R31, R9 */
		/* 820F4928h case   36:*/		cpu::op::add<0>(regs,&regs.R9,regs.R31,regs.R9);
		/* 820F4928h case   36:*/		return 0x820F492C;
		  /* 820F492Ch */ case   37:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F492Ch case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F492Ch case   37:*/		return 0x820F4930;
		  /* 820F4930h */ case   38:  		/* add R9, R9, R8 */
		/* 820F4930h case   38:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820F4930h case   38:*/		return 0x820F4934;
		  /* 820F4934h */ case   39:  		/* stwu R9, <#[R10 + 8]> */
		/* 820F4934h case   39:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820F4934h case   39:*/		return 0x820F4938;
		  /* 820F4938h */ case   40:  		/* lwz R9, <#[R1 + 132]> */
		/* 820F4938h case   40:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000084) );
		/* 820F4938h case   40:*/		return 0x820F493C;
		  /* 820F493Ch */ case   41:  		/* cmplw CR6, R11, R9 */
		/* 820F493Ch case   41:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F493Ch case   41:*/		return 0x820F4940;
		  /* 820F4940h */ case   42:  		/* bc 12, CR6_LT, -36 */
		/* 820F4940h case   42:*/		if ( regs.CR[6].lt ) { return 0x820F491C;  }
		/* 820F4940h case   42:*/		return 0x820F4944;
	}
	return 0x820F4944;
} // Block from 820F4898h-820F4944h (43 instructions)

//////////////////////////////////////////////////////
// Block at 820F4944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4944);
		  /* 820F4944h */ case    0:  		/* lwz R11, <#[R27 + 272]> */
		/* 820F4944h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000110) );
		/* 820F4944h case    0:*/		return 0x820F4948;
		  /* 820F4948h */ case    1:  		/* mr R5, R31 */
		/* 820F4948h case    1:*/		regs.R5 = regs.R31;
		/* 820F4948h case    1:*/		return 0x820F494C;
		  /* 820F494Ch */ case    2:  		/* addi R3, R1, 96 */
		/* 820F494Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F494Ch case    2:*/		return 0x820F4950;
		  /* 820F4950h */ case    3:  		/* addi R4, R11, 4 */
		/* 820F4950h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 820F4950h case    3:*/		return 0x820F4954;
		  /* 820F4954h */ case    4:  		/* bl -156668 */
		/* 820F4954h case    4:*/		regs.LR = 0x820F4958; return 0x820CE558;
		/* 820F4954h case    4:*/		return 0x820F4958;
		  /* 820F4958h */ case    5:  		/* or. R29, R3, R3 */
		/* 820F4958h case    5:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820F4958h case    5:*/		return 0x820F495C;
		  /* 820F495Ch */ case    6:  		/* bc 12, CR0_LT, 72 */
		/* 820F495Ch case    6:*/		if ( regs.CR[0].lt ) { return 0x820F49A4;  }
		/* 820F495Ch case    6:*/		return 0x820F4960;
		  /* 820F4960h */ case    7:  		/* lwz R11, <#[R27 + 276]> */
		/* 820F4960h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000114) );
		/* 820F4960h case    7:*/		return 0x820F4964;
		  /* 820F4964h */ case    8:  		/* lwz R10, <#[R27 + 292]> */
		/* 820F4964h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000124) );
		/* 820F4964h case    8:*/		return 0x820F4968;
		  /* 820F4968h */ case    9:  		/* add R11, R11, R31 */
		/* 820F4968h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820F4968h case    9:*/		return 0x820F496C;
		  /* 820F496Ch */ case   10:  		/* add R10, R31, R10 */
		/* 820F496Ch case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R31,regs.R10);
		/* 820F496Ch case   10:*/		return 0x820F4970;
		  /* 820F4970h */ case   11:  		/* stw R11, <#[R27 + 276]> */
		/* 820F4970h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000114) );
		/* 820F4970h case   11:*/		return 0x820F4974;
		  /* 820F4974h */ case   12:  		/* stw R11, <#[R27 + 288]> */
		/* 820F4974h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000120) );
		/* 820F4974h case   12:*/		return 0x820F4978;
	}
	return 0x820F4978;
} // Block from 820F4944h-820F4978h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820F4978h
// Function '?EmitDebugInfo@CShaderProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4978);
		  /* 820F4978h */ case    0:  		/* stw R10, <#[R27 + 292]> */
		/* 820F4978h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000124) );
		/* 820F4978h case    0:*/		return 0x820F497C;
		  /* 820F497Ch */ case    1:  		/* b 36 */
		/* 820F497Ch case    1:*/		return 0x820F49A0;
		/* 820F497Ch case    1:*/		return 0x820F4980;
	}
	return 0x820F4980;
} // Block from 820F4978h-820F4980h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F4980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4980);
		  /* 820F4980h */ case    0:  		/* lis R29, -32761 */
		/* 820F4980h case    0:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8007);
		/* 820F4980h case    0:*/		return 0x820F4984;
		  /* 820F4984h */ case    1:  		/* ori R29, R29, 14 */
		/* 820F4984h case    1:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0xE);
		/* 820F4984h case    1:*/		return 0x820F4988;
		  /* 820F4988h */ case    2:  		/* b 28 */
		/* 820F4988h case    2:*/		return 0x820F49A4;
		/* 820F4988h case    2:*/		return 0x820F498C;
	}
	return 0x820F498C;
} // Block from 820F4980h-820F498Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F498Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F498C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F498C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F498C);
		  /* 820F498Ch */ case    0:  		/* lis R11, -32255 */
		/* 820F498Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820F498Ch case    0:*/		return 0x820F4990;
		  /* 820F4990h */ case    1:  		/* li R5, 4547 */
		/* 820F4990h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x11C3);
		/* 820F4990h case    1:*/		return 0x820F4994;
		  /* 820F4994h */ case    2:  		/* addi R6, R11, 4280 */
		/* 820F4994h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x10B8);
		/* 820F4994h case    2:*/		return 0x820F4998;
		  /* 820F4998h */ case    3:  		/* li R4, 0 */
		/* 820F4998h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F4998h case    3:*/		return 0x820F499C;
		  /* 820F499Ch */ case    4:  		/* bl 106068 */
		/* 820F499Ch case    4:*/		regs.LR = 0x820F49A0; return 0x8210E7F0;
		/* 820F499Ch case    4:*/		return 0x820F49A0;
	}
	return 0x820F49A0;
} // Block from 820F498Ch-820F49A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F49A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F49A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F49A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F49A0);
		  /* 820F49A0h */ case    0:  		/* mr R29, R19 */
		/* 820F49A0h case    0:*/		regs.R29 = regs.R19;
		/* 820F49A0h case    0:*/		return 0x820F49A4;
	}
	return 0x820F49A4;
} // Block from 820F49A0h-820F49A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F49A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F49A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F49A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F49A4);
		  /* 820F49A4h */ case    0:  		/* lis R4, 9345 */
		/* 820F49A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F49A4h case    0:*/		return 0x820F49A8;
		  /* 820F49A8h */ case    1:  		/* mr R3, R15 */
		/* 820F49A8h case    1:*/		regs.R3 = regs.R15;
		/* 820F49A8h case    1:*/		return 0x820F49AC;
		  /* 820F49ACh */ case    2:  		/* bl -444020 */
		/* 820F49ACh case    2:*/		regs.LR = 0x820F49B0; return 0x82088338;
		/* 820F49ACh case    2:*/		return 0x820F49B0;
		  /* 820F49B0h */ case    3:  		/* lis R4, 9345 */
		/* 820F49B0h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F49B0h case    3:*/		return 0x820F49B4;
		  /* 820F49B4h */ case    4:  		/* mr R3, R16 */
		/* 820F49B4h case    4:*/		regs.R3 = regs.R16;
		/* 820F49B4h case    4:*/		return 0x820F49B8;
		  /* 820F49B8h */ case    5:  		/* bl -444032 */
		/* 820F49B8h case    5:*/		regs.LR = 0x820F49BC; return 0x82088338;
		/* 820F49B8h case    5:*/		return 0x820F49BC;
		  /* 820F49BCh */ case    6:  		/* lis R4, 9345 */
		/* 820F49BCh case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F49BCh case    6:*/		return 0x820F49C0;
		  /* 820F49C0h */ case    7:  		/* mr R3, R17 */
		/* 820F49C0h case    7:*/		regs.R3 = regs.R17;
		/* 820F49C0h case    7:*/		return 0x820F49C4;
		  /* 820F49C4h */ case    8:  		/* bl -444044 */
		/* 820F49C4h case    8:*/		regs.LR = 0x820F49C8; return 0x82088338;
		/* 820F49C4h case    8:*/		return 0x820F49C8;
		  /* 820F49C8h */ case    9:  		/* lis R4, 9345 */
		/* 820F49C8h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F49C8h case    9:*/		return 0x820F49CC;
		  /* 820F49CCh */ case   10:  		/* mr R3, R20 */
		/* 820F49CCh case   10:*/		regs.R3 = regs.R20;
		/* 820F49CCh case   10:*/		return 0x820F49D0;
		  /* 820F49D0h */ case   11:  		/* bl -444056 */
		/* 820F49D0h case   11:*/		regs.LR = 0x820F49D4; return 0x82088338;
		/* 820F49D0h case   11:*/		return 0x820F49D4;
		  /* 820F49D4h */ case   12:  		/* lis R4, 9345 */
		/* 820F49D4h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F49D4h case   12:*/		return 0x820F49D8;
		  /* 820F49D8h */ case   13:  		/* mr R3, R21 */
		/* 820F49D8h case   13:*/		regs.R3 = regs.R21;
		/* 820F49D8h case   13:*/		return 0x820F49DC;
		  /* 820F49DCh */ case   14:  		/* bl -444068 */
		/* 820F49DCh case   14:*/		regs.LR = 0x820F49E0; return 0x82088338;
		/* 820F49DCh case   14:*/		return 0x820F49E0;
		  /* 820F49E0h */ case   15:  		/* addi R3, R1, 96 */
		/* 820F49E0h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F49E0h case   15:*/		return 0x820F49E4;
		  /* 820F49E4h */ case   16:  		/* bl -157676 */
		/* 820F49E4h case   16:*/		regs.LR = 0x820F49E8; return 0x820CE1F8;
		/* 820F49E4h case   16:*/		return 0x820F49E8;
		  /* 820F49E8h */ case   17:  		/* mr R3, R29 */
		/* 820F49E8h case   17:*/		regs.R3 = regs.R29;
		/* 820F49E8h case   17:*/		return 0x820F49EC;
		  /* 820F49ECh */ case   18:  		/* addi R1, R1, 304 */
		/* 820F49ECh case   18:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x130);
		/* 820F49ECh case   18:*/		return 0x820F49F0;
		  /* 820F49F0h */ case   19:  		/* b -407420 */
		/* 820F49F0h case   19:*/		return 0x82091274;
		/* 820F49F0h case   19:*/		return 0x820F49F4;
		  /* 820F49F4h */ case   20:  		/* nop */
		/* 820F49F4h case   20:*/		cpu::op::nop();
		/* 820F49F4h case   20:*/		return 0x820F49F8;
	}
	return 0x820F49F8;
} // Block from 820F49A4h-820F49F8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820F49F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F49F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F49F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F49F8);
		  /* 820F49F8h */ case    0:  		/* mfspr R12, LR */
		/* 820F49F8h case    0:*/		regs.R12 = regs.LR;
		/* 820F49F8h case    0:*/		return 0x820F49FC;
		  /* 820F49FCh */ case    1:  		/* bl -407484 */
		/* 820F49FCh case    1:*/		regs.LR = 0x820F4A00; return 0x82091240;
		/* 820F49FCh case    1:*/		return 0x820F4A00;
		  /* 820F4A00h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 820F4A00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 820F4A00h case    2:*/		return 0x820F4A04;
		  /* 820F4A04h */ case    3:  		/* lwz R11, <#[R3 + 348]> */
		/* 820F4A04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000015C) );
		/* 820F4A04h case    3:*/		return 0x820F4A08;
		  /* 820F4A08h */ case    4:  		/* li R23, 0 */
		/* 820F4A08h case    4:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820F4A08h case    4:*/		return 0x820F4A0C;
		  /* 820F4A0Ch */ case    5:  		/* mr R31, R3 */
		/* 820F4A0Ch case    5:*/		regs.R31 = regs.R3;
		/* 820F4A0Ch case    5:*/		return 0x820F4A10;
		  /* 820F4A10h */ case    6:  		/* mr R22, R4 */
		/* 820F4A10h case    6:*/		regs.R22 = regs.R4;
		/* 820F4A10h case    6:*/		return 0x820F4A14;
		  /* 820F4A14h */ case    7:  		/* mr R25, R5 */
		/* 820F4A14h case    7:*/		regs.R25 = regs.R5;
		/* 820F4A14h case    7:*/		return 0x820F4A18;
		  /* 820F4A18h */ case    8:  		/* mr R24, R6 */
		/* 820F4A18h case    8:*/		regs.R24 = regs.R6;
		/* 820F4A18h case    8:*/		return 0x820F4A1C;
		  /* 820F4A1Ch */ case    9:  		/* mr R30, R23 */
		/* 820F4A1Ch case    9:*/		regs.R30 = regs.R23;
		/* 820F4A1Ch case    9:*/		return 0x820F4A20;
		  /* 820F4A20h */ case   10:  		/* mr R26, R23 */
		/* 820F4A20h case   10:*/		regs.R26 = regs.R23;
		/* 820F4A20h case   10:*/		return 0x820F4A24;
		  /* 820F4A24h */ case   11:  		/* cmpwi CR6, R11, 0 */
		/* 820F4A24h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F4A24h case   11:*/		return 0x820F4A28;
		  /* 820F4A28h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 820F4A28h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820F4A34;  }
		/* 820F4A28h case   12:*/		return 0x820F4A2C;
		  /* 820F4A2Ch */ case   13:  		/* li R3, 0 */
		/* 820F4A2Ch case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820F4A2Ch case   13:*/		return 0x820F4A30;
		  /* 820F4A30h */ case   14:  		/* b 496 */
		/* 820F4A30h case   14:*/		return 0x820F4C20;
		/* 820F4A30h case   14:*/		return 0x820F4A34;
	}
	return 0x820F4A34;
} // Block from 820F49F8h-820F4A34h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820F4A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4A34);
		  /* 820F4A34h */ case    0:  		/* lwz R11, <#[R31 + 500]> */
		/* 820F4A34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000001F4) );
		/* 820F4A34h case    0:*/		return 0x820F4A38;
		  /* 820F4A38h */ case    1:  		/* lwz R10, <#[R31 + 468]> */
		/* 820F4A38h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000001D4) );
		/* 820F4A38h case    1:*/		return 0x820F4A3C;
		  /* 820F4A3Ch */ case    2:  		/* lwz R9, <#[R31 + 504]> */
		/* 820F4A3Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000001F8) );
		/* 820F4A3Ch case    2:*/		return 0x820F4A40;
		  /* 820F4A40h */ case    3:  		/* add R11, R10, R11 */
		/* 820F4A40h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820F4A40h case    3:*/		return 0x820F4A44;
		  /* 820F4A44h */ case    4:  		/* add. R11, R11, R9 */
		/* 820F4A44h case    4:*/		cpu::op::add<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820F4A44h case    4:*/		return 0x820F4A48;
		  /* 820F4A48h */ case    5:  		/* bc 12, CR0_EQ, 456 */
		/* 820F4A48h case    5:*/		if ( regs.CR[0].eq ) { return 0x820F4C10;  }
		/* 820F4A48h case    5:*/		return 0x820F4A4C;
		  /* 820F4A4Ch */ case    6:  		/* lis R4, 9345 */
		/* 820F4A4Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4A4Ch case    6:*/		return 0x820F4A50;
		  /* 820F4A50h */ case    7:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820F4A50h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820F4A50h case    7:*/		return 0x820F4A54;
		  /* 820F4A54h */ case    8:  		/* bl -444500 */
		/* 820F4A54h case    8:*/		regs.LR = 0x820F4A58; return 0x82088200;
		/* 820F4A54h case    8:*/		return 0x820F4A58;
		  /* 820F4A58h */ case    9:  		/* or. R26, R3, R3 */
		/* 820F4A58h case    9:*/		cpu::op::or<1>(regs,&regs.R26,regs.R3,regs.R3);
		/* 820F4A58h case    9:*/		return 0x820F4A5C;
		  /* 820F4A5Ch */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 820F4A5Ch case   10:*/		if ( !regs.CR[0].eq ) { return 0x820F4A6C;  }
		/* 820F4A5Ch case   10:*/		return 0x820F4A60;
		  /* 820F4A60h */ case   11:  		/* lis R30, -32761 */
		/* 820F4A60h case   11:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8007);
		/* 820F4A60h case   11:*/		return 0x820F4A64;
		  /* 820F4A64h */ case   12:  		/* ori R30, R30, 14 */
		/* 820F4A64h case   12:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xE);
		/* 820F4A64h case   12:*/		return 0x820F4A68;
		  /* 820F4A68h */ case   13:  		/* b 424 */
		/* 820F4A68h case   13:*/		return 0x820F4C10;
		/* 820F4A68h case   13:*/		return 0x820F4A6C;
	}
	return 0x820F4A6C;
} // Block from 820F4A34h-820F4A6Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F4A6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4A6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4A6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4A6C);
		  /* 820F4A6Ch */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 820F4A6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820F4A6Ch case    0:*/		return 0x820F4A70;
		  /* 820F4A70h */ case    1:  		/* mr R29, R23 */
		/* 820F4A70h case    1:*/		regs.R29 = regs.R23;
		/* 820F4A70h case    1:*/		return 0x820F4A74;
		  /* 820F4A74h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820F4A74h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F4A74h case    2:*/		return 0x820F4A78;
		  /* 820F4A78h */ case    3:  		/* bc 4, CR6_GT, 80 */
		/* 820F4A78h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820F4AC8;  }
		/* 820F4A78h case    3:*/		return 0x820F4A7C;
		  /* 820F4A7Ch */ case    4:  		/* lis R11, -32254 */
		/* 820F4A7Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F4A7Ch case    4:*/		return 0x820F4A80;
		  /* 820F4A80h */ case    5:  		/* addi R27, R31, 440 */
		/* 820F4A80h case    5:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R31,0x1B8);
		/* 820F4A80h case    5:*/		return 0x820F4A84;
		  /* 820F4A84h */ case    6:  		/* addi R28, R11, -16012 */
		/* 820F4A84h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFC174);
		/* 820F4A84h case    6:*/		return 0x820F4A88;
		  /* 820F4A88h */ case    7:  		/* mr R5, R28 */
		/* 820F4A88h case    7:*/		regs.R5 = regs.R28;
		/* 820F4A88h case    7:*/		return 0x820F4A8C;
		  /* 820F4A8Ch */ case    8:  		/* mr R6, R29 */
		/* 820F4A8Ch case    8:*/		regs.R6 = regs.R29;
		/* 820F4A8Ch case    8:*/		return 0x820F4A90;
		  /* 820F4A90h */ case    9:  		/* li R4, 32 */
		/* 820F4A90h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 820F4A90h case    9:*/		return 0x820F4A94;
		  /* 820F4A94h */ case   10:  		/* addi R3, R1, 96 */
		/* 820F4A94h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820F4A94h case   10:*/		return 0x820F4A98;
		  /* 820F4A98h */ case   11:  		/* bl -336984 */
		/* 820F4A98h case   11:*/		regs.LR = 0x820F4A9C; return 0x820A2640;
		/* 820F4A98h case   11:*/		return 0x820F4A9C;
		  /* 820F4A9Ch */ case   12:  		/* li R6, 1 */
		/* 820F4A9Ch case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820F4A9Ch case   12:*/		return 0x820F4AA0;
		  /* 820F4AA0h */ case   13:  		/* mr R5, R29 */
		/* 820F4AA0h case   13:*/		regs.R5 = regs.R29;
		/* 820F4AA0h case   13:*/		return 0x820F4AA4;
		  /* 820F4AA4h */ case   14:  		/* addi R4, R1, 96 */
		/* 820F4AA4h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820F4AA4h case   14:*/		return 0x820F4AA8;
		  /* 820F4AA8h */ case   15:  		/* mr R3, R27 */
		/* 820F4AA8h case   15:*/		regs.R3 = regs.R27;
		/* 820F4AA8h case   15:*/		return 0x820F4AAC;
		  /* 820F4AACh */ case   16:  		/* bl -308532 */
		/* 820F4AACh case   16:*/		regs.LR = 0x820F4AB0; return 0x820A9578;
		/* 820F4AACh case   16:*/		return 0x820F4AB0;
		  /* 820F4AB0h */ case   17:  		/* or. R30, R3, R3 */
		/* 820F4AB0h case   17:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F4AB0h case   17:*/		return 0x820F4AB4;
		  /* 820F4AB4h */ case   18:  		/* bc 12, CR0_LT, 348 */
		/* 820F4AB4h case   18:*/		if ( regs.CR[0].lt ) { return 0x820F4C10;  }
		/* 820F4AB4h case   18:*/		return 0x820F4AB8;
		  /* 820F4AB8h */ case   19:  		/* lwz R11, <#[R31 + 44]> */
		/* 820F4AB8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820F4AB8h case   19:*/		return 0x820F4ABC;
		  /* 820F4ABCh */ case   20:  		/* addi R29, R29, 1 */
		/* 820F4ABCh case   20:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820F4ABCh case   20:*/		return 0x820F4AC0;
		  /* 820F4AC0h */ case   21:  		/* cmplw CR6, R29, R11 */
		/* 820F4AC0h case   21:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820F4AC0h case   21:*/		return 0x820F4AC4;
		  /* 820F4AC4h */ case   22:  		/* bc 12, CR6_LT, -60 */
		/* 820F4AC4h case   22:*/		if ( regs.CR[6].lt ) { return 0x820F4A88;  }
		/* 820F4AC4h case   22:*/		return 0x820F4AC8;
	}
	return 0x820F4AC8;
} // Block from 820F4A6Ch-820F4AC8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820F4AC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4AC8);
		  /* 820F4AC8h */ case    0:  		/* mr R4, R26 */
		/* 820F4AC8h case    0:*/		regs.R4 = regs.R26;
		/* 820F4AC8h case    0:*/		return 0x820F4ACC;
		  /* 820F4ACCh */ case    1:  		/* addi R3, R31, 440 */
		/* 820F4ACCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x1B8);
		/* 820F4ACCh case    1:*/		return 0x820F4AD0;
		  /* 820F4AD0h */ case    2:  		/* bl -310888 */
		/* 820F4AD0h case    2:*/		regs.LR = 0x820F4AD4; return 0x820A8C68;
		/* 820F4AD0h case    2:*/		return 0x820F4AD4;
		  /* 820F4AD4h */ case    3:  		/* lwz R11, <#[R31 + 468]> */
		/* 820F4AD4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000001D4) );
		/* 820F4AD4h case    3:*/		return 0x820F4AD8;
		  /* 820F4AD8h */ case    4:  		/* lwz R10, <#[R31 + 504]> */
		/* 820F4AD8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000001F8) );
		/* 820F4AD8h case    4:*/		return 0x820F4ADC;
		  /* 820F4ADCh */ case    5:  		/* addi R3, R31, 472 */
		/* 820F4ADCh case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x1D8);
		/* 820F4ADCh case    5:*/		return 0x820F4AE0;
		  /* 820F4AE0h */ case    6:  		/* add R30, R11, R10 */
		/* 820F4AE0h case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 820F4AE0h case    6:*/		return 0x820F4AE4;
		  /* 820F4AE4h */ case    7:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820F4AE4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820F4AE4h case    7:*/		return 0x820F4AE8;
		  /* 820F4AE8h */ case    8:  		/* add R4, R11, R26 */
		/* 820F4AE8h case    8:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R26);
		/* 820F4AE8h case    8:*/		return 0x820F4AEC;
		  /* 820F4AECh */ case    9:  		/* bl -310916 */
		/* 820F4AECh case    9:*/		regs.LR = 0x820F4AF0; return 0x820A8C68;
		/* 820F4AECh case    9:*/		return 0x820F4AF0;
		  /* 820F4AF0h */ case   10:  		/* lwz R11, <#[R31 + 500]> */
		/* 820F4AF0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000001F4) );
		/* 820F4AF0h case   10:*/		return 0x820F4AF4;
		  /* 820F4AF4h */ case   11:  		/* lis R10, -32245 */
		/* 820F4AF4h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF820B);
		/* 820F4AF4h case   11:*/		return 0x820F4AF8;
		  /* 820F4AF8h */ case   12:  		/* add R29, R11, R30 */
		/* 820F4AF8h case   12:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R30);
		/* 820F4AF8h case   12:*/		return 0x820F4AFC;
		  /* 820F4AFCh */ case   13:  		/* li R5, 4 */
		/* 820F4AFCh case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820F4AFCh case   13:*/		return 0x820F4B00;
		  /* 820F4B00h */ case   14:  		/* addi R6, R10, -28656 */
		/* 820F4B00h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFF9010);
		/* 820F4B00h case   14:*/		return 0x820F4B04;
		  /* 820F4B04h */ case   15:  		/* mr R3, R26 */
		/* 820F4B04h case   15:*/		regs.R3 = regs.R26;
		/* 820F4B04h case   15:*/		return 0x820F4B08;
		  /* 820F4B08h */ case   16:  		/* mr R4, R29 */
		/* 820F4B08h case   16:*/		regs.R4 = regs.R29;
		/* 820F4B08h case   16:*/		return 0x820F4B0C;
		  /* 820F4B0Ch */ case   17:  		/* bl -404268 */
		/* 820F4B0Ch case   17:*/		regs.LR = 0x820F4B10; return 0x82091FE0;
		/* 820F4B0Ch case   17:*/		return 0x820F4B10;
		  /* 820F4B10h */ case   18:  		/* mulli R11, R24, 20 */
		/* 820F4B10h case   18:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R24,0x14);
		/* 820F4B10h case   18:*/		return 0x820F4B14;
		  /* 820F4B14h */ case   19:  		/* sth R23, <#[R1 + 90]> */
		/* 820F4B14h case   19:*/		cpu::mem::store16( regs, regs.R23, (uint32)(regs.R1 + 0x0000005A) );
		/* 820F4B14h case   19:*/		return 0x820F4B18;
		  /* 820F4B18h */ case   20:  		/* stw R23, <#[R1 + 92]> */
		/* 820F4B18h case   20:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F4B18h case   20:*/		return 0x820F4B1C;
		  /* 820F4B1Ch */ case   21:  		/* li R28, 1 */
		/* 820F4B1Ch case   21:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820F4B1Ch case   21:*/		return 0x820F4B20;
		  /* 820F4B20h */ case   22:  		/* li R10, 3 */
		/* 820F4B20h case   22:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820F4B20h case   22:*/		return 0x820F4B24;
		  /* 820F4B24h */ case   23:  		/* li R9, 4 */
		/* 820F4B24h case   23:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820F4B24h case   23:*/		return 0x820F4B28;
		  /* 820F4B28h */ case   24:  		/* sth R28, <#[R1 + 80]> */
		/* 820F4B28h case   24:*/		cpu::mem::store16( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 820F4B28h case   24:*/		return 0x820F4B2C;
		  /* 820F4B2Ch */ case   25:  		/* add R31, R11, R25 */
		/* 820F4B2Ch case   25:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R25);
		/* 820F4B2Ch case   25:*/		return 0x820F4B30;
		  /* 820F4B30h */ case   26:  		/* sth R10, <#[R1 + 82]> */
		/* 820F4B30h case   26:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000052) );
		/* 820F4B30h case   26:*/		return 0x820F4B34;
		  /* 820F4B34h */ case   27:  		/* sth R28, <#[R1 + 84]> */
		/* 820F4B34h case   27:*/		cpu::mem::store16( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820F4B34h case   27:*/		return 0x820F4B38;
		  /* 820F4B38h */ case   28:  		/* mr R25, R23 */
		/* 820F4B38h case   28:*/		regs.R25 = regs.R23;
		/* 820F4B38h case   28:*/		return 0x820F4B3C;
		  /* 820F4B3Ch */ case   29:  		/* sth R9, <#[R1 + 86]> */
		/* 820F4B3Ch case   29:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x00000056) );
		/* 820F4B3Ch case   29:*/		return 0x820F4B40;
		  /* 820F4B40h */ case   30:  		/* cmplwi CR6, R29, 0 */
		/* 820F4B40h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820F4B40h case   30:*/		return 0x820F4B44;
		  /* 820F4B44h */ case   31:  		/* sth R28, <#[R1 + 88]> */
		/* 820F4B44h case   31:*/		cpu::mem::store16( regs, regs.R28, (uint32)(regs.R1 + 0x00000058) );
		/* 820F4B44h case   31:*/		return 0x820F4B48;
		  /* 820F4B48h */ case   32:  		/* bc 12, CR6_EQ, 196 */
		/* 820F4B48h case   32:*/		if ( regs.CR[6].eq ) { return 0x820F4C0C;  }
		/* 820F4B48h case   32:*/		return 0x820F4B4C;
		  /* 820F4B4Ch */ case   33:  		/* addi R27, R26, -4 */
		/* 820F4B4Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R26,0xFFFFFFFC);
		/* 820F4B4Ch case   33:*/		return 0x820F4B50;
		  /* 820F4B50h */ case   34:  		/* lwz R11, <#[R27 + 4]> */
		/* 820F4B50h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 820F4B50h case   34:*/		return 0x820F4B54;
		  /* 820F4B54h */ case   35:  		/* li R8, 1 */
		/* 820F4B54h case   35:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820F4B54h case   35:*/		return 0x820F4B58;
		  /* 820F4B58h */ case   36:  		/* mr R7, R31 */
		/* 820F4B58h case   36:*/		regs.R7 = regs.R31;
		/* 820F4B58h case   36:*/		return 0x820F4B5C;
		  /* 820F4B5Ch */ case   37:  		/* li R6, 7 */
		/* 820F4B5Ch case   37:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 820F4B5Ch case   37:*/		return 0x820F4B60;
		  /* 820F4B60h */ case   38:  		/* li R5, -1 */
		/* 820F4B60h case   38:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 820F4B60h case   38:*/		return 0x820F4B64;
		  /* 820F4B64h */ case   39:  		/* mr R3, R22 */
		/* 820F4B64h case   39:*/		regs.R3 = regs.R22;
		/* 820F4B64h case   39:*/		return 0x820F4B68;
		  /* 820F4B68h */ case   40:  		/* lwz R4, <#[R11]> */
		/* 820F4B68h case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820F4B68h case   40:*/		return 0x820F4B6C;
		  /* 820F4B6Ch */ case   41:  		/* bl -157948 */
		/* 820F4B6Ch case   41:*/		regs.LR = 0x820F4B70; return 0x820CE270;
		/* 820F4B6Ch case   41:*/		return 0x820F4B70;
		  /* 820F4B70h */ case   42:  		/* or. R30, R3, R3 */
		/* 820F4B70h case   42:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F4B70h case   42:*/		return 0x820F4B74;
		  /* 820F4B74h */ case   43:  		/* bc 12, CR0_LT, 156 */
		/* 820F4B74h case   43:*/		if ( regs.CR[0].lt ) { return 0x820F4C10;  }
		/* 820F4B74h case   43:*/		return 0x820F4B78;
		  /* 820F4B78h */ case   44:  		/* li R8, 0 */
		/* 820F4B78h case   44:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F4B78h case   44:*/		return 0x820F4B7C;
		  /* 820F4B7Ch */ case   45:  		/* addi R7, R31, 12 */
		/* 820F4B7Ch case   45:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R31,0xC);
		/* 820F4B7Ch case   45:*/		return 0x820F4B80;
		  /* 820F4B80h */ case   46:  		/* li R6, 6 */
		/* 820F4B80h case   46:*/		cpu::op::li<0>(regs,&regs.R6,0x6);
		/* 820F4B80h case   46:*/		return 0x820F4B84;
		  /* 820F4B84h */ case   47:  		/* li R5, 16 */
		/* 820F4B84h case   47:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820F4B84h case   47:*/		return 0x820F4B88;
		  /* 820F4B88h */ case   48:  		/* addi R4, R1, 80 */
		/* 820F4B88h case   48:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820F4B88h case   48:*/		return 0x820F4B8C;
		  /* 820F4B8Ch */ case   49:  		/* mr R3, R22 */
		/* 820F4B8Ch case   49:*/		regs.R3 = regs.R22;
		/* 820F4B8Ch case   49:*/		return 0x820F4B90;
		  /* 820F4B90h */ case   50:  		/* bl -157984 */
		/* 820F4B90h case   50:*/		regs.LR = 0x820F4B94; return 0x820CE270;
		/* 820F4B90h case   50:*/		return 0x820F4B94;
		  /* 820F4B94h */ case   51:  		/* or. R30, R3, R3 */
		/* 820F4B94h case   51:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F4B94h case   51:*/		return 0x820F4B98;
		  /* 820F4B98h */ case   52:  		/* bc 12, CR0_LT, 120 */
		/* 820F4B98h case   52:*/		if ( regs.CR[0].lt ) { return 0x820F4C10;  }
		/* 820F4B98h case   52:*/		return 0x820F4B9C;
		  /* 820F4B9Ch */ case   53:  		/* lwz R11, <#[R27 + 4]> */
		/* 820F4B9Ch case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 820F4B9Ch case   53:*/		return 0x820F4BA0;
		  /* 820F4BA0h */ case   54:  		/* lwz R11, <#[R11 + 12]> */
		/* 820F4BA0h case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F4BA0h case   54:*/		return 0x820F4BA4;
		  /* 820F4BA4h */ case   55:  		/* cmpwi CR6, R11, 0 */
		/* 820F4BA4h case   55:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F4BA4h case   55:*/		return 0x820F4BA8;
		  /* 820F4BA8h */ case   56:  		/* bc 12, CR6_EQ, 56 */
		/* 820F4BA8h case   56:*/		if ( regs.CR[6].eq ) { return 0x820F4BE0;  }
		/* 820F4BA8h case   56:*/		return 0x820F4BAC;
		  /* 820F4BACh */ case   57:  		/* lhz R11, <#[R31 + 10]> */
		/* 820F4BACh case   57:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000A) );
		/* 820F4BACh case   57:*/		return 0x820F4BB0;
		  /* 820F4BB0h */ case   58:  		/* li R8, 0 */
		/* 820F4BB0h case   58:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820F4BB0h case   58:*/		return 0x820F4BB4;
		  /* 820F4BB4h */ case   59:  		/* addi R7, R31, 16 */
		/* 820F4BB4h case   59:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R31,0x10);
		/* 820F4BB4h case   59:*/		return 0x820F4BB8;
		  /* 820F4BB8h */ case   60:  		/* ori R11, R11, 1 */
		/* 820F4BB8h case   60:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F4BB8h case   60:*/		return 0x820F4BBC;
		  /* 820F4BBCh */ case   61:  		/* li R6, 7 */
		/* 820F4BBCh case   61:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 820F4BBCh case   61:*/		return 0x820F4BC0;
		  /* 820F4BC0h */ case   62:  		/* sth R11, <#[R31 + 10]> */
		/* 820F4BC0h case   62:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x0000000A) );
		/* 820F4BC0h case   62:*/		return 0x820F4BC4;
		  /* 820F4BC4h */ case   63:  		/* li R5, 16 */
		/* 820F4BC4h case   63:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820F4BC4h case   63:*/		return 0x820F4BC8;
		  /* 820F4BC8h */ case   64:  		/* lwz R11, <#[R27 + 4]> */
		/* 820F4BC8h case   64:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 820F4BC8h case   64:*/		return 0x820F4BCC;
		  /* 820F4BCCh */ case   65:  		/* mr R3, R22 */
		/* 820F4BCCh case   65:*/		regs.R3 = regs.R22;
		/* 820F4BCCh case   65:*/		return 0x820F4BD0;
		  /* 820F4BD0h */ case   66:  		/* addi R4, R11, 16 */
		/* 820F4BD0h case   66:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x10);
		/* 820F4BD0h case   66:*/		return 0x820F4BD4;
		  /* 820F4BD4h */ case   67:  		/* bl -158052 */
		/* 820F4BD4h case   67:*/		regs.LR = 0x820F4BD8; return 0x820CE270;
		/* 820F4BD4h case   67:*/		return 0x820F4BD8;
		  /* 820F4BD8h */ case   68:  		/* or. R30, R3, R3 */
		/* 820F4BD8h case   68:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F4BD8h case   68:*/		return 0x820F4BDC;
		  /* 820F4BDCh */ case   69:  		/* bc 12, CR0_LT, 52 */
		/* 820F4BDCh case   69:*/		if ( regs.CR[0].lt ) { return 0x820F4C10;  }
		/* 820F4BDCh case   69:*/		return 0x820F4BE0;
	}
	return 0x820F4BE0;
} // Block from 820F4AC8h-820F4BE0h (70 instructions)

//////////////////////////////////////////////////////
// Block at 820F4BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4BE0);
		  /* 820F4BE0h */ case    0:  		/* li R11, 2 */
		/* 820F4BE0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820F4BE0h case    0:*/		return 0x820F4BE4;
		  /* 820F4BE4h */ case    1:  		/* addi R25, R25, 1 */
		/* 820F4BE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 820F4BE4h case    1:*/		return 0x820F4BE8;
		  /* 820F4BE8h */ case    2:  		/* sth R11, <#[R31 + 4]> */
		/* 820F4BE8h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820F4BE8h case    2:*/		return 0x820F4BEC;
		  /* 820F4BECh */ case    3:  		/* lwzu R11, <#[R27 + 4]> */
		/* 820F4BECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		regs.R27 = (uint32)(regs.R27 + 0x00000004);
		/* 820F4BECh case    3:*/		return 0x820F4BF0;
		  /* 820F4BF0h */ case    4:  		/* cmplw CR6, R25, R29 */
		/* 820F4BF0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R29);
		/* 820F4BF0h case    4:*/		return 0x820F4BF4;
		  /* 820F4BF4h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F4BF4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F4BF4h case    5:*/		return 0x820F4BF8;
		  /* 820F4BF8h */ case    6:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 820F4BF8h case    6:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 820F4BF8h case    6:*/		return 0x820F4BFC;
		  /* 820F4BFCh */ case    7:  		/* sth R11, <#[R31 + 6]> */
		/* 820F4BFCh case    7:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000006) );
		/* 820F4BFCh case    7:*/		return 0x820F4C00;
		  /* 820F4C00h */ case    8:  		/* sth R28, <#[R31 + 8]> */
		/* 820F4C00h case    8:*/		cpu::mem::store16( regs, regs.R28, (uint32)(regs.R31 + 0x00000008) );
		/* 820F4C00h case    8:*/		return 0x820F4C04;
		  /* 820F4C04h */ case    9:  		/* addi R31, R31, 20 */
		/* 820F4C04h case    9:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x14);
		/* 820F4C04h case    9:*/		return 0x820F4C08;
		  /* 820F4C08h */ case   10:  		/* bc 12, CR6_LT, -184 */
		/* 820F4C08h case   10:*/		if ( regs.CR[6].lt ) { return 0x820F4B50;  }
		/* 820F4C08h case   10:*/		return 0x820F4C0C;
	}
	return 0x820F4C0C;
} // Block from 820F4BE0h-820F4C0Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F4C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4C0C);
		  /* 820F4C0Ch */ case    0:  		/* mr R30, R23 */
		/* 820F4C0Ch case    0:*/		regs.R30 = regs.R23;
		/* 820F4C0Ch case    0:*/		return 0x820F4C10;
	}
	return 0x820F4C10;
} // Block from 820F4C0Ch-820F4C10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F4C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4C10);
		  /* 820F4C10h */ case    0:  		/* lis R4, 9345 */
		/* 820F4C10h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4C10h case    0:*/		return 0x820F4C14;
		  /* 820F4C14h */ case    1:  		/* mr R3, R26 */
		/* 820F4C14h case    1:*/		regs.R3 = regs.R26;
		/* 820F4C14h case    1:*/		return 0x820F4C18;
		  /* 820F4C18h */ case    2:  		/* bl -444640 */
		/* 820F4C18h case    2:*/		regs.LR = 0x820F4C1C; return 0x82088338;
		/* 820F4C18h case    2:*/		return 0x820F4C1C;
		  /* 820F4C1Ch */ case    3:  		/* mr R3, R30 */
		/* 820F4C1Ch case    3:*/		regs.R3 = regs.R30;
		/* 820F4C1Ch case    3:*/		return 0x820F4C20;
	}
	return 0x820F4C20;
} // Block from 820F4C10h-820F4C20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F4C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4C20);
		  /* 820F4C20h */ case    0:  		/* addi R1, R1, 224 */
		/* 820F4C20h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 820F4C20h case    0:*/		return 0x820F4C24;
		  /* 820F4C24h */ case    1:  		/* b -407956 */
		/* 820F4C24h case    1:*/		return 0x82091290;
		/* 820F4C24h case    1:*/		return 0x820F4C28;
	}
	return 0x820F4C28;
} // Block from 820F4C20h-820F4C28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F4C28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4C28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4C28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4C28);
		  /* 820F4C28h */ case    0:  		/* mfspr R12, LR */
		/* 820F4C28h case    0:*/		regs.R12 = regs.LR;
		/* 820F4C28h case    0:*/		return 0x820F4C2C;
		  /* 820F4C2Ch */ case    1:  		/* bl -408076 */
		/* 820F4C2Ch case    1:*/		regs.LR = 0x820F4C30; return 0x82091220;
		/* 820F4C2Ch case    1:*/		return 0x820F4C30;
		  /* 820F4C30h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 820F4C30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 820F4C30h case    2:*/		return 0x820F4C34;
		  /* 820F4C34h */ case    3:  		/* li R23, 0 */
		/* 820F4C34h case    3:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820F4C34h case    3:*/		return 0x820F4C38;
		  /* 820F4C38h */ case    4:  		/* stw R4, <#[R1 + 300]> */
		/* 820F4C38h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000012C) );
		/* 820F4C38h case    4:*/		return 0x820F4C3C;
		  /* 820F4C3Ch */ case    5:  		/* mr R31, R3 */
		/* 820F4C3Ch case    5:*/		regs.R31 = regs.R3;
		/* 820F4C3Ch case    5:*/		return 0x820F4C40;
		  /* 820F4C40h */ case    6:  		/* stw R23, <#[R3 + 264]> */
		/* 820F4C40h case    6:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000108) );
		/* 820F4C40h case    6:*/		return 0x820F4C44;
		  /* 820F4C44h */ case    7:  		/* mr R22, R23 */
		/* 820F4C44h case    7:*/		regs.R22 = regs.R23;
		/* 820F4C44h case    7:*/		return 0x820F4C48;
		  /* 820F4C48h */ case    8:  		/* stw R23, <#[R1 + 92]> */
		/* 820F4C48h case    8:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F4C48h case    8:*/		return 0x820F4C4C;
		  /* 820F4C4Ch */ case    9:  		/* mr R19, R23 */
		/* 820F4C4Ch case    9:*/		regs.R19 = regs.R23;
		/* 820F4C4Ch case    9:*/		return 0x820F4C50;
		  /* 820F4C50h */ case   10:  		/* stw R23, <#[R1 + 84]> */
		/* 820F4C50h case   10:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000054) );
		/* 820F4C50h case   10:*/		return 0x820F4C54;
		  /* 820F4C54h */ case   11:  		/* mr R26, R23 */
		/* 820F4C54h case   11:*/		regs.R26 = regs.R23;
		/* 820F4C54h case   11:*/		return 0x820F4C58;
		  /* 820F4C58h */ case   12:  		/* stw R23, <#[R1 + 80]> */
		/* 820F4C58h case   12:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000050) );
		/* 820F4C58h case   12:*/		return 0x820F4C5C;
		  /* 820F4C5Ch */ case   13:  		/* mr R21, R23 */
		/* 820F4C5Ch case   13:*/		regs.R21 = regs.R23;
		/* 820F4C5Ch case   13:*/		return 0x820F4C60;
		  /* 820F4C60h */ case   14:  		/* mr R14, R23 */
		/* 820F4C60h case   14:*/		regs.R14 = regs.R23;
		/* 820F4C60h case   14:*/		return 0x820F4C64;
		  /* 820F4C64h */ case   15:  		/* mr R20, R23 */
		/* 820F4C64h case   15:*/		regs.R20 = regs.R23;
		/* 820F4C64h case   15:*/		return 0x820F4C68;
		  /* 820F4C68h */ case   16:  		/* mr R18, R23 */
		/* 820F4C68h case   16:*/		regs.R18 = regs.R23;
		/* 820F4C68h case   16:*/		return 0x820F4C6C;
		  /* 820F4C6Ch */ case   17:  		/* mr R15, R23 */
		/* 820F4C6Ch case   17:*/		regs.R15 = regs.R23;
		/* 820F4C6Ch case   17:*/		return 0x820F4C70;
		  /* 820F4C70h */ case   18:  		/* mr R17, R23 */
		/* 820F4C70h case   18:*/		regs.R17 = regs.R23;
		/* 820F4C70h case   18:*/		return 0x820F4C74;
		  /* 820F4C74h */ case   19:  		/* mr R16, R23 */
		/* 820F4C74h case   19:*/		regs.R16 = regs.R23;
		/* 820F4C74h case   19:*/		return 0x820F4C78;
		  /* 820F4C78h */ case   20:  		/* bl 143792 */
		/* 820F4C78h case   20:*/		regs.LR = 0x820F4C7C; return 0x82117E28;
		/* 820F4C78h case   20:*/		return 0x820F4C7C;
		  /* 820F4C7Ch */ case   21:  		/* or. R30, R3, R3 */
		/* 820F4C7Ch case   21:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F4C7Ch case   21:*/		return 0x820F4C80;
		  /* 820F4C80h */ case   22:  		/* bc 12, CR0_LT, 4244 */
		/* 820F4C80h case   22:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F4C80h case   22:*/		return 0x820F4C84;
		  /* 820F4C84h */ case   23:  		/* lis R11, -32255 */
		/* 820F4C84h case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820F4C84h case   23:*/		return 0x820F4C88;
		  /* 820F4C88h */ case   24:  		/* li R24, -1 */
		/* 820F4C88h case   24:*/		cpu::op::li<0>(regs,&regs.R24,0xFFFFFFFF);
		/* 820F4C88h case   24:*/		return 0x820F4C8C;
		  /* 820F4C8Ch */ case   25:  		/* lis R5, 4 */
		/* 820F4C8Ch case   25:*/		cpu::op::lis<0>(regs,&regs.R5,0x4);
		/* 820F4C8Ch case   25:*/		return 0x820F4C90;
		  /* 820F4C90h */ case   26:  		/* li R7, 4 */
		/* 820F4C90h case   26:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 820F4C90h case   26:*/		return 0x820F4C94;
		  /* 820F4C94h */ case   27:  		/* addi R4, R11, -8780 */
		/* 820F4C94h case   27:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFDDB4);
		/* 820F4C94h case   27:*/		return 0x820F4C98;
		  /* 820F4C98h */ case   28:  		/* mr R6, R24 */
		/* 820F4C98h case   28:*/		regs.R6 = regs.R24;
		/* 820F4C98h case   28:*/		return 0x820F4C9C;
		  /* 820F4C9Ch */ case   29:  		/* ori R5, R5, 785 */
		/* 820F4C9Ch case   29:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x311);
		/* 820F4C9Ch case   29:*/		return 0x820F4CA0;
		  /* 820F4CA0h */ case   30:  		/* mr R3, R31 */
		/* 820F4CA0h case   30:*/		regs.R3 = regs.R31;
		/* 820F4CA0h case   30:*/		return 0x820F4CA4;
		  /* 820F4CA4h */ case   31:  		/* bl 34020 */
		/* 820F4CA4h case   31:*/		regs.LR = 0x820F4CA8; return 0x820FD188;
		/* 820F4CA4h case   31:*/		return 0x820F4CA8;
		  /* 820F4CA8h */ case   32:  		/* stw R3, <#[R31 + 392]> */
		/* 820F4CA8h case   32:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000188) );
		/* 820F4CA8h case   32:*/		return 0x820F4CAC;
		  /* 820F4CACh */ case   33:  		/* cmpwi CR6, R3, -1 */
		/* 820F4CACh case   33:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820F4CACh case   33:*/		return 0x820F4CB0;
		  /* 820F4CB0h */ case   34:  		/* bc 12, CR6_EQ, 2684 */
		/* 820F4CB0h case   34:*/		if ( regs.CR[6].eq ) { return 0x820F572C;  }
		/* 820F4CB0h case   34:*/		return 0x820F4CB4;
		  /* 820F4CB4h */ case   35:  		/* lwz R11, <#[R31]> */
		/* 820F4CB4h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F4CB4h case   35:*/		return 0x820F4CB8;
		  /* 820F4CB8h */ case   36:  		/* mr R3, R31 */
		/* 820F4CB8h case   36:*/		regs.R3 = regs.R31;
		/* 820F4CB8h case   36:*/		return 0x820F4CBC;
		  /* 820F4CBCh */ case   37:  		/* lwz R11, <#[R11 + 372]> */
		/* 820F4CBCh case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000174) );
		/* 820F4CBCh case   37:*/		return 0x820F4CC0;
		  /* 820F4CC0h */ case   38:  		/* mtspr CTR, R11 */
		/* 820F4CC0h case   38:*/		regs.CTR = regs.R11;
		/* 820F4CC0h case   38:*/		return 0x820F4CC4;
		  /* 820F4CC4h */ case   39:  		/* bcctrl 20, CR0_LT */
		/* 820F4CC4h case   39:*/		if ( 1 ) { regs.LR = 0x820F4CC8; return (uint32)regs.CTR; }
		/* 820F4CC4h case   39:*/		return 0x820F4CC8;
		  /* 820F4CC8h */ case   40:  		/* cmpwi CR0, R3, 0 */
		/* 820F4CC8h case   40:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F4CC8h case   40:*/		return 0x820F4CCC;
		  /* 820F4CCCh */ case   41:  		/* bc 12, CR0_LT, 3852 */
		/* 820F4CCCh case   41:*/		if ( regs.CR[0].lt ) { return 0x820F5BD8;  }
		/* 820F4CCCh case   41:*/		return 0x820F4CD0;
		  /* 820F4CD0h */ case   42:  		/* stw R23, <#[R31 + 272]> */
		/* 820F4CD0h case   42:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000110) );
		/* 820F4CD0h case   42:*/		return 0x820F4CD4;
		  /* 820F4CD4h */ case   43:  		/* stw R23, <#[R31 + 276]> */
		/* 820F4CD4h case   43:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000114) );
		/* 820F4CD4h case   43:*/		return 0x820F4CD8;
		  /* 820F4CD8h */ case   44:  		/* stw R23, <#[R31 + 280]> */
		/* 820F4CD8h case   44:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000118) );
		/* 820F4CD8h case   44:*/		return 0x820F4CDC;
		  /* 820F4CDCh */ case   45:  		/* stw R23, <#[R31 + 288]> */
		/* 820F4CDCh case   45:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000120) );
		/* 820F4CDCh case   45:*/		return 0x820F4CE0;
		  /* 820F4CE0h */ case   46:  		/* stw R23, <#[R31 + 292]> */
		/* 820F4CE0h case   46:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000124) );
		/* 820F4CE0h case   46:*/		return 0x820F4CE4;
		  /* 820F4CE4h */ case   47:  		/* lwz R3, <#[R31 + 436]> */
		/* 820F4CE4h case   47:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000001B4) );
		/* 820F4CE4h case   47:*/		return 0x820F4CE8;
		  /* 820F4CE8h */ case   48:  		/* cmplwi CR6, R3, 0 */
		/* 820F4CE8h case   48:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820F4CE8h case   48:*/		return 0x820F4CEC;
		  /* 820F4CECh */ case   49:  		/* bc 12, CR6_EQ, 24 */
		/* 820F4CECh case   49:*/		if ( regs.CR[6].eq ) { return 0x820F4D04;  }
		/* 820F4CECh case   49:*/		return 0x820F4CF0;
		  /* 820F4CF0h */ case   50:  		/* lwz R11, <#[R3]> */
		/* 820F4CF0h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820F4CF0h case   50:*/		return 0x820F4CF4;
		  /* 820F4CF4h */ case   51:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F4CF4h case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F4CF4h case   51:*/		return 0x820F4CF8;
		  /* 820F4CF8h */ case   52:  		/* mtspr CTR, R11 */
		/* 820F4CF8h case   52:*/		regs.CTR = regs.R11;
		/* 820F4CF8h case   52:*/		return 0x820F4CFC;
		  /* 820F4CFCh */ case   53:  		/* bcctrl 20, CR0_LT */
		/* 820F4CFCh case   53:*/		if ( 1 ) { regs.LR = 0x820F4D00; return (uint32)regs.CTR; }
		/* 820F4CFCh case   53:*/		return 0x820F4D00;
		  /* 820F4D00h */ case   54:  		/* stw R23, <#[R31 + 436]> */
		/* 820F4D00h case   54:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x000001B4) );
		/* 820F4D00h case   54:*/		return 0x820F4D04;
	}
	return 0x820F4D04;
} // Block from 820F4C28h-820F4D04h (55 instructions)

//////////////////////////////////////////////////////
// Block at 820F4D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4D04);
		  /* 820F4D04h */ case    0:  		/* lwz R11, <#[R31 + 204]> */
		/* 820F4D04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 820F4D04h case    0:*/		return 0x820F4D08;
		  /* 820F4D08h */ case    1:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 820F4D08h case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 820F4D08h case    1:*/		return 0x820F4D0C;
		  /* 820F4D0Ch */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 820F4D0Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820F4D14;  }
		/* 820F4D0Ch case    2:*/		return 0x820F4D10;
		  /* 820F4D10h */ case    3:  		/* stw R23, <#[R31 + 436]> */
		/* 820F4D10h case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x000001B4) );
		/* 820F4D10h case    3:*/		return 0x820F4D14;
	}
	return 0x820F4D14;
} // Block from 820F4D04h-820F4D14h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F4D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4D14);
		  /* 820F4D14h */ case    0:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820F4D14h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820F4D14h case    0:*/		return 0x820F4D18;
		  /* 820F4D18h */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 820F4D18h case    1:*/		if ( regs.CR[0].eq ) { return 0x820F4D48;  }
		/* 820F4D18h case    1:*/		return 0x820F4D1C;
		  /* 820F4D1Ch */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 820F4D1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F4D1Ch case    2:*/		return 0x820F4D20;
		  /* 820F4D20h */ case    3:  		/* lis R4, 9345 */
		/* 820F4D20h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4D20h case    3:*/		return 0x820F4D24;
		  /* 820F4D24h */ case    4:  		/* mulli R3, R11, 48 */
		/* 820F4D24h case    4:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R11,0x30);
		/* 820F4D24h case    4:*/		return 0x820F4D28;
		  /* 820F4D28h */ case    5:  		/* bl -445224 */
		/* 820F4D28h case    5:*/		regs.LR = 0x820F4D2C; return 0x82088200;
		/* 820F4D28h case    5:*/		return 0x820F4D2C;
		  /* 820F4D2Ch */ case    6:  		/* stw R3, <#[R31 + 296]> */
		/* 820F4D2Ch case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000128) );
		/* 820F4D2Ch case    6:*/		return 0x820F4D30;
		  /* 820F4D30h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 820F4D30h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820F4D30h case    7:*/		return 0x820F4D34;
		  /* 820F4D34h */ case    8:  		/* bc 12, CR0_EQ, 2552 */
		/* 820F4D34h case    8:*/		if ( regs.CR[0].eq ) { return 0x820F572C;  }
		/* 820F4D34h case    8:*/		return 0x820F4D38;
		  /* 820F4D38h */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 820F4D38h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F4D38h case    9:*/		return 0x820F4D3C;
		  /* 820F4D3Ch */ case   10:  		/* stw R23, <#[R31 + 300]> */
		/* 820F4D3Ch case   10:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x0000012C) );
		/* 820F4D3Ch case   10:*/		return 0x820F4D40;
		  /* 820F4D40h */ case   11:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 820F4D40h case   11:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 820F4D40h case   11:*/		return 0x820F4D44;
		  /* 820F4D44h */ case   12:  		/* stw R11, <#[R31 + 304]> */
		/* 820F4D44h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000130) );
		/* 820F4D44h case   12:*/		return 0x820F4D48;
	}
	return 0x820F4D48;
} // Block from 820F4D14h-820F4D48h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820F4D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4D48);
		  /* 820F4D48h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 820F4D48h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820F4D48h case    0:*/		return 0x820F4D4C;
		  /* 820F4D4Ch */ case    1:  		/* mr R11, R23 */
		/* 820F4D4Ch case    1:*/		regs.R11 = regs.R23;
		/* 820F4D4Ch case    1:*/		return 0x820F4D50;
		  /* 820F4D50h */ case    2:  		/* stw R24, <#[R31 + 316]> */
		/* 820F4D50h case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x0000013C) );
		/* 820F4D50h case    2:*/		return 0x820F4D54;
		  /* 820F4D54h */ case    3:  		/* stw R23, <#[R31 + 336]> */
		/* 820F4D54h case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000150) );
		/* 820F4D54h case    3:*/		return 0x820F4D58;
		  /* 820F4D58h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 820F4D58h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F4D58h case    4:*/		return 0x820F4D5C;
		  /* 820F4D5Ch */ case    5:  		/* bc 4, CR6_GT, 40 */
		/* 820F4D5Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x820F4D84;  }
		/* 820F4D5Ch case    5:*/		return 0x820F4D60;
		  /* 820F4D60h */ case    6:  		/* mr R10, R23 */
		/* 820F4D60h case    6:*/		regs.R10 = regs.R23;
		/* 820F4D60h case    6:*/		return 0x820F4D64;
		  /* 820F4D64h */ case    7:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F4D64h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F4D64h case    7:*/		return 0x820F4D68;
		  /* 820F4D68h */ case    8:  		/* addi R11, R11, 1 */
		/* 820F4D68h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F4D68h case    8:*/		return 0x820F4D6C;
		  /* 820F4D6Ch */ case    9:  		/* lwzx R9, <#[R10 + R9]> */
		/* 820F4D6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820F4D6Ch case    9:*/		return 0x820F4D70;
		  /* 820F4D70h */ case   10:  		/* addi R10, R10, 4 */
		/* 820F4D70h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F4D70h case   10:*/		return 0x820F4D74;
		  /* 820F4D74h */ case   11:  		/* stw R23, <#[R9 + 48]> */
		/* 820F4D74h case   11:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R9 + 0x00000030) );
		/* 820F4D74h case   11:*/		return 0x820F4D78;
		  /* 820F4D78h */ case   12:  		/* lwz R9, <#[R31 + 8]> */
		/* 820F4D78h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820F4D78h case   12:*/		return 0x820F4D7C;
		  /* 820F4D7Ch */ case   13:  		/* cmplw CR6, R11, R9 */
		/* 820F4D7Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820F4D7Ch case   13:*/		return 0x820F4D80;
		  /* 820F4D80h */ case   14:  		/* bc 12, CR6_LT, -28 */
		/* 820F4D80h case   14:*/		if ( regs.CR[6].lt ) { return 0x820F4D64;  }
		/* 820F4D80h case   14:*/		return 0x820F4D84;
	}
	return 0x820F4D84;
} // Block from 820F4D48h-820F4D84h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820F4D84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4D84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4D84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4D84);
		  /* 820F4D84h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F4D84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F4D84h case    0:*/		return 0x820F4D88;
		  /* 820F4D88h */ case    1:  		/* mr R27, R23 */
		/* 820F4D88h case    1:*/		regs.R27 = regs.R23;
		/* 820F4D88h case    1:*/		return 0x820F4D8C;
		  /* 820F4D8Ch */ case    2:  		/* mr R28, R23 */
		/* 820F4D8Ch case    2:*/		regs.R28 = regs.R23;
		/* 820F4D8Ch case    2:*/		return 0x820F4D90;
		  /* 820F4D90h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820F4D90h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F4D90h case    3:*/		return 0x820F4D94;
		  /* 820F4D94h */ case    4:  		/* bc 4, CR6_GT, 132 */
		/* 820F4D94h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820F4E18;  }
		/* 820F4D94h case    4:*/		return 0x820F4D98;
		  /* 820F4D98h */ case    5:  		/* mr R30, R23 */
		/* 820F4D98h case    5:*/		regs.R30 = regs.R23;
		/* 820F4D98h case    5:*/		return 0x820F4D9C;
		  /* 820F4D9Ch */ case    6:  		/* lwz R11, <#[R31 + 20]> */
		/* 820F4D9Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820F4D9Ch case    6:*/		return 0x820F4DA0;
		  /* 820F4DA0h */ case    7:  		/* lwz R10, <#[R31 + 16]> */
		/* 820F4DA0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820F4DA0h case    7:*/		return 0x820F4DA4;
		  /* 820F4DA4h */ case    8:  		/* lwzx R4, <#[R30 + R11]> */
		/* 820F4DA4h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820F4DA4h case    8:*/		return 0x820F4DA8;
		  /* 820F4DA8h */ case    9:  		/* lwz R11, <#[R4 + 4]> */
		/* 820F4DA8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820F4DA8h case    9:*/		return 0x820F4DAC;
		  /* 820F4DACh */ case   10:  		/* lwz R9, <#[R4]> */
		/* 820F4DACh case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000000) );
		/* 820F4DACh case   10:*/		return 0x820F4DB0;
		  /* 820F4DB0h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F4DB0h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F4DB0h case   11:*/		return 0x820F4DB4;
		  /* 820F4DB4h */ case   12:  		/* rlwinm. R9, R9, 0, 3, 3 */
		/* 820F4DB4h case   12:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R9,regs.R9);
		/* 820F4DB4h case   12:*/		return 0x820F4DB8;
		  /* 820F4DB8h */ case   13:  		/* lwzx R29, <#[R11 + R10]> */
		/* 820F4DB8h case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F4DB8h case   13:*/		return 0x820F4DBC;
		  /* 820F4DBCh */ case   14:  		/* bc 4, CR0_EQ, 72 */
		/* 820F4DBCh case   14:*/		if ( !regs.CR[0].eq ) { return 0x820F4E04;  }
		/* 820F4DBCh case   14:*/		return 0x820F4DC0;
		  /* 820F4DC0h */ case   15:  		/* lwz R11, <#[R29 + 4]> */
		/* 820F4DC0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820F4DC0h case   15:*/		return 0x820F4DC4;
		  /* 820F4DC4h */ case   16:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820F4DC4h case   16:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820F4DC4h case   16:*/		return 0x820F4DC8;
		  /* 820F4DC8h */ case   17:  		/* bc 12, CR0_EQ, 12 */
		/* 820F4DC8h case   17:*/		if ( regs.CR[0].eq ) { return 0x820F4DD4;  }
		/* 820F4DC8h case   17:*/		return 0x820F4DCC;
		  /* 820F4DCCh */ case   18:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 820F4DCCh case   18:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 820F4DCCh case   18:*/		return 0x820F4DD0;
		  /* 820F4DD0h */ case   19:  		/* bc 12, CR0_EQ, 12 */
		/* 820F4DD0h case   19:*/		if ( regs.CR[0].eq ) { return 0x820F4DDC;  }
		/* 820F4DD0h case   19:*/		return 0x820F4DD4;
	}
	return 0x820F4DD4;
} // Block from 820F4D84h-820F4DD4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820F4DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4DD4);
		  /* 820F4DD4h */ case    0:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820F4DD4h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820F4DD4h case    0:*/		return 0x820F4DD8;
		  /* 820F4DD8h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 820F4DD8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820F4DF4;  }
		/* 820F4DD8h case    1:*/		return 0x820F4DDC;
	}
	return 0x820F4DDC;
} // Block from 820F4DD4h-820F4DDCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F4DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4DDC);
		  /* 820F4DDCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820F4DDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F4DDCh case    0:*/		return 0x820F4DE0;
		  /* 820F4DE0h */ case    1:  		/* li R5, 0 */
		/* 820F4DE0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F4DE0h case    1:*/		return 0x820F4DE4;
		  /* 820F4DE4h */ case    2:  		/* mr R3, R31 */
		/* 820F4DE4h case    2:*/		regs.R3 = regs.R31;
		/* 820F4DE4h case    2:*/		return 0x820F4DE8;
		  /* 820F4DE8h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F4DE8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F4DE8h case    3:*/		return 0x820F4DEC;
		  /* 820F4DECh */ case    4:  		/* mtspr CTR, R11 */
		/* 820F4DECh case    4:*/		regs.CTR = regs.R11;
		/* 820F4DECh case    4:*/		return 0x820F4DF0;
		  /* 820F4DF0h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820F4DF0h case    5:*/		if ( 1 ) { regs.LR = 0x820F4DF4; return (uint32)regs.CTR; }
		/* 820F4DF0h case    5:*/		return 0x820F4DF4;
	}
	return 0x820F4DF4;
} // Block from 820F4DDCh-820F4DF4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F4DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4DF4);
		  /* 820F4DF4h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 820F4DF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820F4DF4h case    0:*/		return 0x820F4DF8;
		  /* 820F4DF8h */ case    1:  		/* rlwinm. R11, R11, 0, 24, 24 */
		/* 820F4DF8h case    1:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R11);
		/* 820F4DF8h case    1:*/		return 0x820F4DFC;
		  /* 820F4DFCh */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 820F4DFCh case    2:*/		if ( regs.CR[0].eq ) { return 0x820F4E04;  }
		/* 820F4DFCh case    2:*/		return 0x820F4E00;
		  /* 820F4E00h */ case    3:  		/* addi R27, R27, 1 */
		/* 820F4E00h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820F4E00h case    3:*/		return 0x820F4E04;
	}
	return 0x820F4E04;
} // Block from 820F4DF4h-820F4E04h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F4E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4E04);
		  /* 820F4E04h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F4E04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F4E04h case    0:*/		return 0x820F4E08;
		  /* 820F4E08h */ case    1:  		/* addi R28, R28, 1 */
		/* 820F4E08h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820F4E08h case    1:*/		return 0x820F4E0C;
		  /* 820F4E0Ch */ case    2:  		/* addi R30, R30, 4 */
		/* 820F4E0Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820F4E0Ch case    2:*/		return 0x820F4E10;
		  /* 820F4E10h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 820F4E10h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820F4E10h case    3:*/		return 0x820F4E14;
		  /* 820F4E14h */ case    4:  		/* bc 12, CR6_LT, -120 */
		/* 820F4E14h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F4D9C;  }
		/* 820F4E14h case    4:*/		return 0x820F4E18;
	}
	return 0x820F4E18;
} // Block from 820F4E04h-820F4E18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F4E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4E18);
		  /* 820F4E18h */ case    0:  		/* lwz R11, <#[R31 + 76]> */
		/* 820F4E18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820F4E18h case    0:*/		return 0x820F4E1C;
		  /* 820F4E1Ch */ case    1:  		/* cmplw CR6, R27, R11 */
		/* 820F4E1Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820F4E1Ch case    1:*/		return 0x820F4E20;
		  /* 820F4E20h */ case    2:  		/* bc 4, CR6_GT, 92 */
		/* 820F4E20h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820F4E7C;  }
		/* 820F4E20h case    2:*/		return 0x820F4E24;
		  /* 820F4E24h */ case    3:  		/* addi R5, R1, 96 */
		/* 820F4E24h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 820F4E24h case    3:*/		return 0x820F4E28;
		  /* 820F4E28h */ case    4:  		/* lwz R3, <#[R31 + 200]> */
		/* 820F4E28h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C8) );
		/* 820F4E28h case    4:*/		return 0x820F4E2C;
		  /* 820F4E2Ch */ case    5:  		/* li R4, 0 */
		/* 820F4E2Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F4E2Ch case    5:*/		return 0x820F4E30;
		  /* 820F4E30h */ case    6:  		/* bl -352200 */
		/* 820F4E30h case    6:*/		regs.LR = 0x820F4E34; return 0x8209EE68;
		/* 820F4E30h case    6:*/		return 0x820F4E34;
		  /* 820F4E34h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820F4E34h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820F4E34h case    7:*/		return 0x820F4E38;
		  /* 820F4E38h */ case    8:  		/* bc 12, CR0_LT, 3488 */
		/* 820F4E38h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F5BD8;  }
		/* 820F4E38h case    8:*/		return 0x820F4E3C;
		  /* 820F4E3Ch */ case    9:  		/* lwz R8, <#[R31 + 76]> */
		/* 820F4E3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000004C) );
		/* 820F4E3Ch case    9:*/		return 0x820F4E40;
		  /* 820F4E40h */ case   10:  		/* li R4, 0 */
		/* 820F4E40h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F4E40h case   10:*/		return 0x820F4E44;
		  /* 820F4E44h */ case   11:  		/* lwz R7, <#[R1 + 96]> */
		/* 820F4E44h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000060) );
		/* 820F4E44h case   11:*/		return 0x820F4E48;
		  /* 820F4E48h */ case   12:  		/* mr R3, R31 */
		/* 820F4E48h case   12:*/		regs.R3 = regs.R31;
		/* 820F4E48h case   12:*/		return 0x820F4E4C;
		  /* 820F4E4Ch */ case   13:  		/* cmplwi CR6, R8, 0 */
		/* 820F4E4Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820F4E4Ch case   13:*/		return 0x820F4E50;
		  /* 820F4E50h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 820F4E50h case   14:*/		if ( regs.CR[6].eq ) { return 0x820F4E68;  }
		/* 820F4E50h case   14:*/		return 0x820F4E54;
		  /* 820F4E54h */ case   15:  		/* lis R11, -32254 */
		/* 820F4E54h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F4E54h case   15:*/		return 0x820F4E58;
		  /* 820F4E58h */ case   16:  		/* li R5, 4510 */
		/* 820F4E58h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x119E);
		/* 820F4E58h case   16:*/		return 0x820F4E5C;
		  /* 820F4E5Ch */ case   17:  		/* addi R6, R11, -15720 */
		/* 820F4E5Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC298);
		/* 820F4E5Ch case   17:*/		return 0x820F4E60;
		  /* 820F4E60h */ case   18:  		/* bl 104656 */
		/* 820F4E60h case   18:*/		regs.LR = 0x820F4E64; return 0x8210E730;
		/* 820F4E60h case   18:*/		return 0x820F4E64;
		  /* 820F4E64h */ case   19:  		/* b 3444 */
		/* 820F4E64h case   19:*/		return 0x820F5BD8;
		/* 820F4E64h case   19:*/		return 0x820F4E68;
	}
	return 0x820F4E68;
} // Block from 820F4E18h-820F4E68h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820F4E68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4E68);
		  /* 820F4E68h */ case    0:  		/* lis R11, -32254 */
		/* 820F4E68h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F4E68h case    0:*/		return 0x820F4E6C;
		  /* 820F4E6Ch */ case    1:  		/* li R5, 4545 */
		/* 820F4E6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x11C1);
		/* 820F4E6Ch case    1:*/		return 0x820F4E70;
		  /* 820F4E70h */ case    2:  		/* addi R6, R11, -15768 */
		/* 820F4E70h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC268);
		/* 820F4E70h case    2:*/		return 0x820F4E74;
		  /* 820F4E74h */ case    3:  		/* bl 104636 */
		/* 820F4E74h case    3:*/		regs.LR = 0x820F4E78; return 0x8210E730;
		/* 820F4E74h case    3:*/		return 0x820F4E78;
		  /* 820F4E78h */ case    4:  		/* b 3424 */
		/* 820F4E78h case    4:*/		return 0x820F5BD8;
		/* 820F4E78h case    4:*/		return 0x820F4E7C;
	}
	return 0x820F4E7C;
} // Block from 820F4E68h-820F4E7Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F4E7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4E7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4E7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4E7C);
		  /* 820F4E7Ch */ case    0:  		/* lwz R11, <#[R31 + 200]> */
		/* 820F4E7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C8) );
		/* 820F4E7Ch case    0:*/		return 0x820F4E80;
		  /* 820F4E80h */ case    1:  		/* lis R10, -2 */
		/* 820F4E80h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820F4E80h case    1:*/		return 0x820F4E84;
		  /* 820F4E84h */ case    2:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 820F4E84h case    2:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 820F4E84h case    2:*/		return 0x820F4E88;
		  /* 820F4E88h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820F4E88h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F4E88h case    3:*/		return 0x820F4E8C;
		  /* 820F4E8Ch */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 820F4E8Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820F4EB4;  }
		/* 820F4E8Ch case    4:*/		return 0x820F4E90;
		  /* 820F4E90h */ case    5:  		/* li R8, 118 */
		/* 820F4E90h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x76);
		/* 820F4E90h case    5:*/		return 0x820F4E94;
		  /* 820F4E94h */ case    6:  		/* lwz R5, <#[R31 + 40]> */
		/* 820F4E94h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000028) );
		/* 820F4E94h case    6:*/		return 0x820F4E98;
		  /* 820F4E98h */ case    7:  		/* li R7, 516 */
		/* 820F4E98h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x204);
		/* 820F4E98h case    7:*/		return 0x820F4E9C;
		  /* 820F4E9Ch */ case    8:  		/* lwz R4, <#[R31 + 128]> */
		/* 820F4E9Ch case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000080) );
		/* 820F4E9Ch case    8:*/		return 0x820F4EA0;
		  /* 820F4EA0h */ case    9:  		/* li R6, 16 */
		/* 820F4EA0h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x10);
		/* 820F4EA0h case    9:*/		return 0x820F4EA4;
		  /* 820F4EA4h */ case   10:  		/* mr R3, R31 */
		/* 820F4EA4h case   10:*/		regs.R3 = regs.R31;
		/* 820F4EA4h case   10:*/		return 0x820F4EA8;
		  /* 820F4EA8h */ case   11:  		/* bl -28888 */
		/* 820F4EA8h case   11:*/		regs.LR = 0x820F4EAC; return 0x820EDDD0;
		/* 820F4EA8h case   11:*/		return 0x820F4EAC;
		  /* 820F4EACh */ case   12:  		/* or. R30, R3, R3 */
		/* 820F4EACh case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F4EACh case   12:*/		return 0x820F4EB0;
		  /* 820F4EB0h */ case   13:  		/* bc 12, CR0_LT, 3684 */
		/* 820F4EB0h case   13:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F4EB0h case   13:*/		return 0x820F4EB4;
	}
	return 0x820F4EB4;
} // Block from 820F4E7Ch-820F4EB4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F4EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4EB4);
		  /* 820F4EB4h */ case    0:  		/* lwz R11, <#[R31 + 200]> */
		/* 820F4EB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C8) );
		/* 820F4EB4h case    0:*/		return 0x820F4EB8;
		  /* 820F4EB8h */ case    1:  		/* lis R10, -1 */
		/* 820F4EB8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820F4EB8h case    1:*/		return 0x820F4EBC;
		  /* 820F4EBCh */ case    2:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 820F4EBCh case    2:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 820F4EBCh case    2:*/		return 0x820F4EC0;
		  /* 820F4EC0h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820F4EC0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820F4EC0h case    3:*/		return 0x820F4EC4;
		  /* 820F4EC4h */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 820F4EC4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820F4EEC;  }
		/* 820F4EC4h case    4:*/		return 0x820F4EC8;
		  /* 820F4EC8h */ case    5:  		/* li R8, 115 */
		/* 820F4EC8h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x73);
		/* 820F4EC8h case    5:*/		return 0x820F4ECC;
		  /* 820F4ECCh */ case    6:  		/* lwz R5, <#[R31 + 76]> */
		/* 820F4ECCh case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000004C) );
		/* 820F4ECCh case    6:*/		return 0x820F4ED0;
		  /* 820F4ED0h */ case    7:  		/* li R7, 0 */
		/* 820F4ED0h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820F4ED0h case    7:*/		return 0x820F4ED4;
		  /* 820F4ED4h */ case    8:  		/* li R6, 128 */
		/* 820F4ED4h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x80);
		/* 820F4ED4h case    8:*/		return 0x820F4ED8;
		  /* 820F4ED8h */ case    9:  		/* mr R4, R24 */
		/* 820F4ED8h case    9:*/		regs.R4 = regs.R24;
		/* 820F4ED8h case    9:*/		return 0x820F4EDC;
		  /* 820F4EDCh */ case   10:  		/* mr R3, R31 */
		/* 820F4EDCh case   10:*/		regs.R3 = regs.R31;
		/* 820F4EDCh case   10:*/		return 0x820F4EE0;
		  /* 820F4EE0h */ case   11:  		/* bl -28944 */
		/* 820F4EE0h case   11:*/		regs.LR = 0x820F4EE4; return 0x820EDDD0;
		/* 820F4EE0h case   11:*/		return 0x820F4EE4;
		  /* 820F4EE4h */ case   12:  		/* or. R30, R3, R3 */
		/* 820F4EE4h case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F4EE4h case   12:*/		return 0x820F4EE8;
		  /* 820F4EE8h */ case   13:  		/* bc 12, CR0_LT, 3628 */
		/* 820F4EE8h case   13:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F4EE8h case   13:*/		return 0x820F4EEC;
	}
	return 0x820F4EEC;
} // Block from 820F4EB4h-820F4EECh (14 instructions)

//////////////////////////////////////////////////////
// Block at 820F4EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4EEC);
		  /* 820F4EECh */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F4EECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F4EECh case    0:*/		return 0x820F4EF0;
		  /* 820F4EF0h */ case    1:  		/* mr R5, R23 */
		/* 820F4EF0h case    1:*/		regs.R5 = regs.R23;
		/* 820F4EF0h case    1:*/		return 0x820F4EF4;
		  /* 820F4EF4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820F4EF4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F4EF4h case    2:*/		return 0x820F4EF8;
		  /* 820F4EF8h */ case    3:  		/* bc 4, CR6_GT, 204 */
		/* 820F4EF8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820F4FC4;  }
		/* 820F4EF8h case    3:*/		return 0x820F4EFC;
		  /* 820F4EFCh */ case    4:  		/* lwz R7, <#[R31 + 20]> */
		/* 820F4EFCh case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 820F4EFCh case    4:*/		return 0x820F4F00;
		  /* 820F4F00h */ case    5:  		/* mr R8, R23 */
		/* 820F4F00h case    5:*/		regs.R8 = regs.R23;
		/* 820F4F00h case    5:*/		return 0x820F4F04;
		  /* 820F4F04h */ case    6:  		/* rlwinm R6, R11, 0, 0, 31 */
		/* 820F4F04h case    6:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R6,regs.R11);
		/* 820F4F04h case    6:*/		return 0x820F4F08;
		  /* 820F4F08h */ case    7:  		/* lwzx R11, <#[R7 + R8]> */
		/* 820F4F08h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 820F4F08h case    7:*/		return 0x820F4F0C;
		  /* 820F4F0Ch */ case    8:  		/* lwz R10, <#[R11]> */
		/* 820F4F0Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F4F0Ch case    8:*/		return 0x820F4F10;
		  /* 820F4F10h */ case    9:  		/* rlwinm. R10, R10, 0, 3, 3 */
		/* 820F4F10h case    9:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R10);
		/* 820F4F10h case    9:*/		return 0x820F4F14;
		  /* 820F4F14h */ case   10:  		/* bc 4, CR0_EQ, 160 */
		/* 820F4F14h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820F4FB4;  }
		/* 820F4F14h case   10:*/		return 0x820F4F18;
		  /* 820F4F18h */ case   11:  		/* lwz R9, <#[R11 + 4]> */
		/* 820F4F18h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820F4F18h case   11:*/		return 0x820F4F1C;
		  /* 820F4F1Ch */ case   12:  		/* lwz R10, <#[R31 + 136]> */
		/* 820F4F1Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000088) );
		/* 820F4F1Ch case   12:*/		return 0x820F4F20;
		  /* 820F4F20h */ case   13:  		/* cmplw CR6, R10, R9 */
		/* 820F4F20h case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F4F20h case   13:*/		return 0x820F4F24;
		  /* 820F4F24h */ case   14:  		/* bc 4, CR6_EQ, 28 */
		/* 820F4F24h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820F4F40;  }
		/* 820F4F24h case   14:*/		return 0x820F4F28;
		  /* 820F4F28h */ case   15:  		/* lwz R10, <#[R11 + 12]> */
		/* 820F4F28h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F4F28h case   15:*/		return 0x820F4F2C;
		  /* 820F4F2Ch */ case   16:  		/* addi R10, R10, 1 */
		/* 820F4F2Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F4F2Ch case   16:*/		return 0x820F4F30;
		  /* 820F4F30h */ case   17:  		/* cmplw CR6, R10, R26 */
		/* 820F4F30h case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R26);
		/* 820F4F30h case   17:*/		return 0x820F4F34;
		  /* 820F4F34h */ case   18:  		/* bc 4, CR6_GT, 12 */
		/* 820F4F34h case   18:*/		if ( !regs.CR[6].gt ) { return 0x820F4F40;  }
		/* 820F4F34h case   18:*/		return 0x820F4F38;
		  /* 820F4F38h */ case   19:  		/* mr R26, R10 */
		/* 820F4F38h case   19:*/		regs.R26 = regs.R10;
		/* 820F4F38h case   19:*/		return 0x820F4F3C;
		  /* 820F4F3Ch */ case   20:  		/* b 120 */
		/* 820F4F3Ch case   20:*/		return 0x820F4FB4;
		/* 820F4F3Ch case   20:*/		return 0x820F4F40;
	}
	return 0x820F4F40;
} // Block from 820F4EECh-820F4F40h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820F4F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4F40);
		  /* 820F4F40h */ case    0:  		/* lwz R10, <#[R31 + 128]> */
		/* 820F4F40h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000080) );
		/* 820F4F40h case    0:*/		return 0x820F4F44;
		  /* 820F4F44h */ case    1:  		/* cmplw CR6, R10, R9 */
		/* 820F4F44h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F4F44h case    1:*/		return 0x820F4F48;
		  /* 820F4F48h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 820F4F48h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F4F64;  }
		/* 820F4F48h case    2:*/		return 0x820F4F4C;
		  /* 820F4F4Ch */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 820F4F4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F4F4Ch case    3:*/		return 0x820F4F50;
		  /* 820F4F50h */ case    4:  		/* addi R10, R10, 1 */
		/* 820F4F50h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F4F50h case    4:*/		return 0x820F4F54;
		  /* 820F4F54h */ case    5:  		/* cmplw CR6, R10, R22 */
		/* 820F4F54h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R22);
		/* 820F4F54h case    5:*/		return 0x820F4F58;
		  /* 820F4F58h */ case    6:  		/* bc 4, CR6_GT, 12 */
		/* 820F4F58h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820F4F64;  }
		/* 820F4F58h case    6:*/		return 0x820F4F5C;
		  /* 820F4F5Ch */ case    7:  		/* mr R22, R10 */
		/* 820F4F5Ch case    7:*/		regs.R22 = regs.R10;
		/* 820F4F5Ch case    7:*/		return 0x820F4F60;
		  /* 820F4F60h */ case    8:  		/* b 84 */
		/* 820F4F60h case    8:*/		return 0x820F4FB4;
		/* 820F4F60h case    8:*/		return 0x820F4F64;
	}
	return 0x820F4F64;
} // Block from 820F4F40h-820F4F64h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F4F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4F64);
		  /* 820F4F64h */ case    0:  		/* lwz R10, <#[R31 + 132]> */
		/* 820F4F64h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 820F4F64h case    0:*/		return 0x820F4F68;
		  /* 820F4F68h */ case    1:  		/* cmplw CR6, R10, R9 */
		/* 820F4F68h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820F4F68h case    1:*/		return 0x820F4F6C;
		  /* 820F4F6Ch */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 820F4F6Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F4F88;  }
		/* 820F4F6Ch case    2:*/		return 0x820F4F70;
		  /* 820F4F70h */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 820F4F70h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F4F70h case    3:*/		return 0x820F4F74;
		  /* 820F4F74h */ case    4:  		/* addi R10, R10, 1 */
		/* 820F4F74h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820F4F74h case    4:*/		return 0x820F4F78;
		  /* 820F4F78h */ case    5:  		/* cmplw CR6, R10, R19 */
		/* 820F4F78h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R19);
		/* 820F4F78h case    5:*/		return 0x820F4F7C;
		  /* 820F4F7Ch */ case    6:  		/* bc 4, CR6_GT, 12 */
		/* 820F4F7Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x820F4F88;  }
		/* 820F4F7Ch case    6:*/		return 0x820F4F80;
		  /* 820F4F80h */ case    7:  		/* mr R19, R10 */
		/* 820F4F80h case    7:*/		regs.R19 = regs.R10;
		/* 820F4F80h case    7:*/		return 0x820F4F84;
		  /* 820F4F84h */ case    8:  		/* b 48 */
		/* 820F4F84h case    8:*/		return 0x820F4FB4;
		/* 820F4F84h case    8:*/		return 0x820F4F88;
	}
	return 0x820F4F88;
} // Block from 820F4F64h-820F4F88h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F4F88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4F88);
		  /* 820F4F88h */ case    0:  		/* lwz R10, <#[R31 + 16]> */
		/* 820F4F88h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820F4F88h case    0:*/		return 0x820F4F8C;
		  /* 820F4F8Ch */ case    1:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F4F8Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F4F8Ch case    1:*/		return 0x820F4F90;
		  /* 820F4F90h */ case    2:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820F4F90h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820F4F90h case    2:*/		return 0x820F4F94;
		  /* 820F4F94h */ case    3:  		/* lwz R10, <#[R10 + 4]> */
		/* 820F4F94h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820F4F94h case    3:*/		return 0x820F4F98;
		  /* 820F4F98h */ case    4:  		/* rlwinm. R10, R10, 0, 24, 24 */
		/* 820F4F98h case    4:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R10);
		/* 820F4F98h case    4:*/		return 0x820F4F9C;
		  /* 820F4F9Ch */ case    5:  		/* bc 12, CR0_EQ, 24 */
		/* 820F4F9Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820F4FB4;  }
		/* 820F4F9Ch case    5:*/		return 0x820F4FA0;
		  /* 820F4FA0h */ case    6:  		/* lwz R11, <#[R11 + 12]> */
		/* 820F4FA0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F4FA0h case    6:*/		return 0x820F4FA4;
		  /* 820F4FA4h */ case    7:  		/* addi R11, R11, 1 */
		/* 820F4FA4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F4FA4h case    7:*/		return 0x820F4FA8;
		  /* 820F4FA8h */ case    8:  		/* cmplw CR6, R11, R21 */
		/* 820F4FA8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 820F4FA8h case    8:*/		return 0x820F4FAC;
		  /* 820F4FACh */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 820F4FACh case    9:*/		if ( !regs.CR[6].gt ) { return 0x820F4FB4;  }
		/* 820F4FACh case    9:*/		return 0x820F4FB0;
		  /* 820F4FB0h */ case   10:  		/* mr R21, R11 */
		/* 820F4FB0h case   10:*/		regs.R21 = regs.R11;
		/* 820F4FB0h case   10:*/		return 0x820F4FB4;
	}
	return 0x820F4FB4;
} // Block from 820F4F88h-820F4FB4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F4FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4FB4);
		  /* 820F4FB4h */ case    0:  		/* addi R5, R5, 1 */
		/* 820F4FB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820F4FB4h case    0:*/		return 0x820F4FB8;
		  /* 820F4FB8h */ case    1:  		/* addi R8, R8, 4 */
		/* 820F4FB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820F4FB8h case    1:*/		return 0x820F4FBC;
		  /* 820F4FBCh */ case    2:  		/* cmplw CR6, R5, R6 */
		/* 820F4FBCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 820F4FBCh case    2:*/		return 0x820F4FC0;
		  /* 820F4FC0h */ case    3:  		/* bc 12, CR6_LT, -184 */
		/* 820F4FC0h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F4F08;  }
		/* 820F4FC0h case    3:*/		return 0x820F4FC4;
	}
	return 0x820F4FC4;
} // Block from 820F4FB4h-820F4FC4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F4FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F4FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F4FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F4FC4);
		  /* 820F4FC4h */ case    0:  		/* rlwinm R28, R22, 2, 0, 29 */
		/* 820F4FC4h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R22);
		/* 820F4FC4h case    0:*/		return 0x820F4FC8;
		  /* 820F4FC8h */ case    1:  		/* lis R4, 9345 */
		/* 820F4FC8h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4FC8h case    1:*/		return 0x820F4FCC;
		  /* 820F4FCCh */ case    2:  		/* mr R3, R28 */
		/* 820F4FCCh case    2:*/		regs.R3 = regs.R28;
		/* 820F4FCCh case    2:*/		return 0x820F4FD0;
		  /* 820F4FD0h */ case    3:  		/* bl -445904 */
		/* 820F4FD0h case    3:*/		regs.LR = 0x820F4FD4; return 0x82088200;
		/* 820F4FD0h case    3:*/		return 0x820F4FD4;
		  /* 820F4FD4h */ case    4:  		/* or. R20, R3, R3 */
		/* 820F4FD4h case    4:*/		cpu::op::or<1>(regs,&regs.R20,regs.R3,regs.R3);
		/* 820F4FD4h case    4:*/		return 0x820F4FD8;
		  /* 820F4FD8h */ case    5:  		/* bc 12, CR0_EQ, 1876 */
		/* 820F4FD8h case    5:*/		if ( regs.CR[0].eq ) { return 0x820F572C;  }
		/* 820F4FD8h case    5:*/		return 0x820F4FDC;
		  /* 820F4FDCh */ case    6:  		/* rlwinm R30, R19, 2, 0, 29 */
		/* 820F4FDCh case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R19);
		/* 820F4FDCh case    6:*/		return 0x820F4FE0;
		  /* 820F4FE0h */ case    7:  		/* lis R4, 9345 */
		/* 820F4FE0h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4FE0h case    7:*/		return 0x820F4FE4;
		  /* 820F4FE4h */ case    8:  		/* mr R3, R30 */
		/* 820F4FE4h case    8:*/		regs.R3 = regs.R30;
		/* 820F4FE4h case    8:*/		return 0x820F4FE8;
		  /* 820F4FE8h */ case    9:  		/* bl -445928 */
		/* 820F4FE8h case    9:*/		regs.LR = 0x820F4FEC; return 0x82088200;
		/* 820F4FE8h case    9:*/		return 0x820F4FEC;
		  /* 820F4FECh */ case   10:  		/* or. R18, R3, R3 */
		/* 820F4FECh case   10:*/		cpu::op::or<1>(regs,&regs.R18,regs.R3,regs.R3);
		/* 820F4FECh case   10:*/		return 0x820F4FF0;
		  /* 820F4FF0h */ case   11:  		/* bc 12, CR0_EQ, 1852 */
		/* 820F4FF0h case   11:*/		if ( regs.CR[0].eq ) { return 0x820F572C;  }
		/* 820F4FF0h case   11:*/		return 0x820F4FF4;
		  /* 820F4FF4h */ case   12:  		/* rlwinm R29, R21, 2, 0, 29 */
		/* 820F4FF4h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R21);
		/* 820F4FF4h case   12:*/		return 0x820F4FF8;
		  /* 820F4FF8h */ case   13:  		/* lis R4, 9345 */
		/* 820F4FF8h case   13:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F4FF8h case   13:*/		return 0x820F4FFC;
		  /* 820F4FFCh */ case   14:  		/* mr R3, R29 */
		/* 820F4FFCh case   14:*/		regs.R3 = regs.R29;
		/* 820F4FFCh case   14:*/		return 0x820F5000;
		  /* 820F5000h */ case   15:  		/* bl -445952 */
		/* 820F5000h case   15:*/		regs.LR = 0x820F5004; return 0x82088200;
		/* 820F5000h case   15:*/		return 0x820F5004;
		  /* 820F5004h */ case   16:  		/* or. R27, R3, R3 */
		/* 820F5004h case   16:*/		cpu::op::or<1>(regs,&regs.R27,regs.R3,regs.R3);
		/* 820F5004h case   16:*/		return 0x820F5008;
		  /* 820F5008h */ case   17:  		/* stw R27, <#[R1 + 84]> */
		/* 820F5008h case   17:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 820F5008h case   17:*/		return 0x820F500C;
		  /* 820F500Ch */ case   18:  		/* bc 12, CR0_EQ, 1824 */
		/* 820F500Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x820F572C;  }
		/* 820F500Ch case   18:*/		return 0x820F5010;
		  /* 820F5010h */ case   19:  		/* lis R4, 9345 */
		/* 820F5010h case   19:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5010h case   19:*/		return 0x820F5014;
		  /* 820F5014h */ case   20:  		/* mr R3, R28 */
		/* 820F5014h case   20:*/		regs.R3 = regs.R28;
		/* 820F5014h case   20:*/		return 0x820F5018;
		  /* 820F5018h */ case   21:  		/* bl -445976 */
		/* 820F5018h case   21:*/		regs.LR = 0x820F501C; return 0x82088200;
		/* 820F5018h case   21:*/		return 0x820F501C;
		  /* 820F501Ch */ case   22:  		/* stw R3, <#[R1 + 80]> */
		/* 820F501Ch case   22:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820F501Ch case   22:*/		return 0x820F5020;
		  /* 820F5020h */ case   23:  		/* cmplwi CR0, R3, 0 */
		/* 820F5020h case   23:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820F5020h case   23:*/		return 0x820F5024;
		  /* 820F5024h */ case   24:  		/* bc 12, CR0_EQ, 1800 */
		/* 820F5024h case   24:*/		if ( regs.CR[0].eq ) { return 0x820F572C;  }
		/* 820F5024h case   24:*/		return 0x820F5028;
		  /* 820F5028h */ case   25:  		/* lis R4, 9345 */
		/* 820F5028h case   25:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5028h case   25:*/		return 0x820F502C;
		  /* 820F502Ch */ case   26:  		/* mr R3, R30 */
		/* 820F502Ch case   26:*/		regs.R3 = regs.R30;
		/* 820F502Ch case   26:*/		return 0x820F5030;
		  /* 820F5030h */ case   27:  		/* bl -446000 */
		/* 820F5030h case   27:*/		regs.LR = 0x820F5034; return 0x82088200;
		/* 820F5030h case   27:*/		return 0x820F5034;
		  /* 820F5034h */ case   28:  		/* or. R15, R3, R3 */
		/* 820F5034h case   28:*/		cpu::op::or<1>(regs,&regs.R15,regs.R3,regs.R3);
		/* 820F5034h case   28:*/		return 0x820F5038;
		  /* 820F5038h */ case   29:  		/* bc 12, CR0_EQ, 1780 */
		/* 820F5038h case   29:*/		if ( regs.CR[0].eq ) { return 0x820F572C;  }
		/* 820F5038h case   29:*/		return 0x820F503C;
		  /* 820F503Ch */ case   30:  		/* mr R5, R28 */
		/* 820F503Ch case   30:*/		regs.R5 = regs.R28;
		/* 820F503Ch case   30:*/		return 0x820F5040;
		  /* 820F5040h */ case   31:  		/* li R4, 0 */
		/* 820F5040h case   31:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F5040h case   31:*/		return 0x820F5044;
		  /* 820F5044h */ case   32:  		/* mr R3, R20 */
		/* 820F5044h case   32:*/		regs.R3 = regs.R20;
		/* 820F5044h case   32:*/		return 0x820F5048;
		  /* 820F5048h */ case   33:  		/* bl -408840 */
		/* 820F5048h case   33:*/		regs.LR = 0x820F504C; return 0x82091340;
		/* 820F5048h case   33:*/		return 0x820F504C;
		  /* 820F504Ch */ case   34:  		/* mr R5, R30 */
		/* 820F504Ch case   34:*/		regs.R5 = regs.R30;
		/* 820F504Ch case   34:*/		return 0x820F5050;
		  /* 820F5050h */ case   35:  		/* li R4, 0 */
		/* 820F5050h case   35:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F5050h case   35:*/		return 0x820F5054;
		  /* 820F5054h */ case   36:  		/* mr R3, R18 */
		/* 820F5054h case   36:*/		regs.R3 = regs.R18;
		/* 820F5054h case   36:*/		return 0x820F5058;
		  /* 820F5058h */ case   37:  		/* bl -408856 */
		/* 820F5058h case   37:*/		regs.LR = 0x820F505C; return 0x82091340;
		/* 820F5058h case   37:*/		return 0x820F505C;
		  /* 820F505Ch */ case   38:  		/* mr R5, R29 */
		/* 820F505Ch case   38:*/		regs.R5 = regs.R29;
		/* 820F505Ch case   38:*/		return 0x820F5060;
		  /* 820F5060h */ case   39:  		/* li R4, 0 */
		/* 820F5060h case   39:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F5060h case   39:*/		return 0x820F5064;
		  /* 820F5064h */ case   40:  		/* mr R3, R27 */
		/* 820F5064h case   40:*/		regs.R3 = regs.R27;
		/* 820F5064h case   40:*/		return 0x820F5068;
		  /* 820F5068h */ case   41:  		/* bl -408872 */
		/* 820F5068h case   41:*/		regs.LR = 0x820F506C; return 0x82091340;
		/* 820F5068h case   41:*/		return 0x820F506C;
		  /* 820F506Ch */ case   42:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F506Ch case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F506Ch case   42:*/		return 0x820F5070;
		  /* 820F5070h */ case   43:  		/* mr R9, R23 */
		/* 820F5070h case   43:*/		regs.R9 = regs.R23;
		/* 820F5070h case   43:*/		return 0x820F5074;
		  /* 820F5074h */ case   44:  		/* cmplwi CR6, R11, 0 */
		/* 820F5074h case   44:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F5074h case   44:*/		return 0x820F5078;
		  /* 820F5078h */ case   45:  		/* bc 4, CR6_GT, 168 */
		/* 820F5078h case   45:*/		if ( !regs.CR[6].gt ) { return 0x820F5120;  }
		/* 820F5078h case   45:*/		return 0x820F507C;
		  /* 820F507Ch */ case   46:  		/* mr R8, R23 */
		/* 820F507Ch case   46:*/		regs.R8 = regs.R23;
		/* 820F507Ch case   46:*/		return 0x820F5080;
		  /* 820F5080h */ case   47:  		/* lwz R11, <#[R31 + 20]> */
		/* 820F5080h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820F5080h case   47:*/		return 0x820F5084;
		  /* 820F5084h */ case   48:  		/* lwzx R11, <#[R8 + R11]> */
		/* 820F5084h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820F5084h case   48:*/		return 0x820F5088;
		  /* 820F5088h */ case   49:  		/* lwz R10, <#[R11]> */
		/* 820F5088h case   49:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F5088h case   49:*/		return 0x820F508C;
		  /* 820F508Ch */ case   50:  		/* rlwinm. R10, R10, 0, 3, 3 */
		/* 820F508Ch case   50:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R10);
		/* 820F508Ch case   50:*/		return 0x820F5090;
		  /* 820F5090h */ case   51:  		/* bc 4, CR0_EQ, 124 */
		/* 820F5090h case   51:*/		if ( !regs.CR[0].eq ) { return 0x820F510C;  }
		/* 820F5090h case   51:*/		return 0x820F5094;
		  /* 820F5094h */ case   52:  		/* lwz R10, <#[R11 + 4]> */
		/* 820F5094h case   52:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820F5094h case   52:*/		return 0x820F5098;
		  /* 820F5098h */ case   53:  		/* lwz R7, <#[R31 + 132]> */
		/* 820F5098h case   53:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000084) );
		/* 820F5098h case   53:*/		return 0x820F509C;
		  /* 820F509Ch */ case   54:  		/* cmplw CR6, R7, R10 */
		/* 820F509Ch case   54:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 820F509Ch case   54:*/		return 0x820F50A0;
		  /* 820F50A0h */ case   55:  		/* bc 4, CR6_EQ, 32 */
		/* 820F50A0h case   55:*/		if ( !regs.CR[6].eq ) { return 0x820F50C0;  }
		/* 820F50A0h case   55:*/		return 0x820F50A4;
		  /* 820F50A4h */ case   56:  		/* lwz R10, <#[R11 + 108]> */
		/* 820F50A4h case   56:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F50A4h case   56:*/		return 0x820F50A8;
		  /* 820F50A8h */ case   57:  		/* cmpwi CR6, R10, -1 */
		/* 820F50A8h case   57:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820F50A8h case   57:*/		return 0x820F50AC;
		  /* 820F50ACh */ case   58:  		/* bc 12, CR6_EQ, 964 */
		/* 820F50ACh case   58:*/		if ( regs.CR[6].eq ) { return 0x820F5470;  }
		/* 820F50ACh case   58:*/		return 0x820F50B0;
		  /* 820F50B0h */ case   59:  		/* lwz R10, <#[R11 + 12]> */
		/* 820F50B0h case   59:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F50B0h case   59:*/		return 0x820F50B4;
		  /* 820F50B4h */ case   60:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F50B4h case   60:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F50B4h case   60:*/		return 0x820F50B8;
		  /* 820F50B8h */ case   61:  		/* stwx R11, <#[R10 + R18]> */
		/* 820F50B8h case   61:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R18 + 0x00000000) );
		/* 820F50B8h case   61:*/		return 0x820F50BC;
		  /* 820F50BCh */ case   62:  		/* b 80 */
		/* 820F50BCh case   62:*/		return 0x820F510C;
		/* 820F50BCh case   62:*/		return 0x820F50C0;
	}
	return 0x820F50C0;
} // Block from 820F4FC4h-820F50C0h (63 instructions)

//////////////////////////////////////////////////////
// Block at 820F50C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F50C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F50C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F50C0);
		  /* 820F50C0h */ case    0:  		/* lwz R7, <#[R31 + 128]> */
		/* 820F50C0h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000080) );
		/* 820F50C0h case    0:*/		return 0x820F50C4;
		  /* 820F50C4h */ case    1:  		/* cmplw CR6, R7, R10 */
		/* 820F50C4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 820F50C4h case    1:*/		return 0x820F50C8;
		  /* 820F50C8h */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 820F50C8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820F50E8;  }
		/* 820F50C8h case    2:*/		return 0x820F50CC;
		  /* 820F50CCh */ case    3:  		/* lwz R10, <#[R11 + 108]> */
		/* 820F50CCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F50CCh case    3:*/		return 0x820F50D0;
		  /* 820F50D0h */ case    4:  		/* cmpwi CR6, R10, -1 */
		/* 820F50D0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820F50D0h case    4:*/		return 0x820F50D4;
		  /* 820F50D4h */ case    5:  		/* bc 12, CR6_EQ, 936 */
		/* 820F50D4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820F547C;  }
		/* 820F50D4h case    5:*/		return 0x820F50D8;
		  /* 820F50D8h */ case    6:  		/* lwz R10, <#[R11 + 12]> */
		/* 820F50D8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F50D8h case    6:*/		return 0x820F50DC;
		  /* 820F50DCh */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F50DCh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F50DCh case    7:*/		return 0x820F50E0;
		  /* 820F50E0h */ case    8:  		/* stwx R11, <#[R10 + R20]> */
		/* 820F50E0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R20 + 0x00000000) );
		/* 820F50E0h case    8:*/		return 0x820F50E4;
		  /* 820F50E4h */ case    9:  		/* b 40 */
		/* 820F50E4h case    9:*/		return 0x820F510C;
		/* 820F50E4h case    9:*/		return 0x820F50E8;
	}
	return 0x820F50E8;
} // Block from 820F50C0h-820F50E8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820F50E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F50E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F50E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F50E8);
		  /* 820F50E8h */ case    0:  		/* lwz R7, <#[R31 + 16]> */
		/* 820F50E8h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 820F50E8h case    0:*/		return 0x820F50EC;
		  /* 820F50ECh */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F50ECh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F50ECh case    1:*/		return 0x820F50F0;
		  /* 820F50F0h */ case    2:  		/* lwzx R10, <#[R10 + R7]> */
		/* 820F50F0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 820F50F0h case    2:*/		return 0x820F50F4;
		  /* 820F50F4h */ case    3:  		/* lwz R10, <#[R10 + 4]> */
		/* 820F50F4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820F50F4h case    3:*/		return 0x820F50F8;
		  /* 820F50F8h */ case    4:  		/* rlwinm. R10, R10, 0, 24, 24 */
		/* 820F50F8h case    4:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R10);
		/* 820F50F8h case    4:*/		return 0x820F50FC;
		  /* 820F50FCh */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820F50FCh case    5:*/		if ( regs.CR[0].eq ) { return 0x820F510C;  }
		/* 820F50FCh case    5:*/		return 0x820F5100;
		  /* 820F5100h */ case    6:  		/* lwz R10, <#[R11 + 12]> */
		/* 820F5100h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F5100h case    6:*/		return 0x820F5104;
		  /* 820F5104h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820F5104h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820F5104h case    7:*/		return 0x820F5108;
		  /* 820F5108h */ case    8:  		/* stwx R11, <#[R10 + R27]> */
		/* 820F5108h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 820F5108h case    8:*/		return 0x820F510C;
	}
	return 0x820F510C;
} // Block from 820F50E8h-820F510Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820F510Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F510C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F510C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F510C);
		  /* 820F510Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F510Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F510Ch case    0:*/		return 0x820F5110;
		  /* 820F5110h */ case    1:  		/* addi R9, R9, 1 */
		/* 820F5110h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F5110h case    1:*/		return 0x820F5114;
		  /* 820F5114h */ case    2:  		/* addi R8, R8, 4 */
		/* 820F5114h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820F5114h case    2:*/		return 0x820F5118;
		  /* 820F5118h */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 820F5118h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820F5118h case    3:*/		return 0x820F511C;
		  /* 820F511Ch */ case    4:  		/* bc 12, CR6_LT, -156 */
		/* 820F511Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820F5080;  }
		/* 820F511Ch case    4:*/		return 0x820F5120;
	}
	return 0x820F5120;
} // Block from 820F510Ch-820F5120h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F5120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5120);
		  /* 820F5120h */ case    0:  		/* lwz R11, <#[R31 + 108]> */
		/* 820F5120h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F5120h case    0:*/		return 0x820F5124;
		  /* 820F5124h */ case    1:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 820F5124h case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 820F5124h case    1:*/		return 0x820F5128;
		  /* 820F5128h */ case    2:  		/* bc 12, CR0_EQ, 160 */
		/* 820F5128h case    2:*/		if ( regs.CR[0].eq ) { return 0x820F51C8;  }
		/* 820F5128h case    2:*/		return 0x820F512C;
		  /* 820F512Ch */ case    3:  		/* mr R7, R23 */
		/* 820F512Ch case    3:*/		regs.R7 = regs.R23;
		/* 820F512Ch case    3:*/		return 0x820F5130;
		  /* 820F5130h */ case    4:  		/* mr R6, R23 */
		/* 820F5130h case    4:*/		regs.R6 = regs.R23;
		/* 820F5130h case    4:*/		return 0x820F5134;
		  /* 820F5134h */ case    5:  		/* cmplwi CR6, R22, 0 */
		/* 820F5134h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820F5134h case    5:*/		return 0x820F5138;
		  /* 820F5138h */ case    6:  		/* bc 12, CR6_EQ, 140 */
		/* 820F5138h case    6:*/		if ( regs.CR[6].eq ) { return 0x820F51C4;  }
		/* 820F5138h case    6:*/		return 0x820F513C;
		  /* 820F513Ch */ case    7:  		/* mr R8, R20 */
		/* 820F513Ch case    7:*/		regs.R8 = regs.R20;
		/* 820F513Ch case    7:*/		return 0x820F5140;
		  /* 820F5140h */ case    8:  		/* mr R5, R20 */
		/* 820F5140h case    8:*/		regs.R5 = regs.R20;
		/* 820F5140h case    8:*/		return 0x820F5144;
		  /* 820F5144h */ case    9:  		/* lwz R11, <#[R5]> */
		/* 820F5144h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820F5144h case    9:*/		return 0x820F5148;
		  /* 820F5148h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 820F5148h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F5148h case   10:*/		return 0x820F514C;
		  /* 820F514Ch */ case   11:  		/* bc 12, CR6_EQ, 104 */
		/* 820F514Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820F51B4;  }
		/* 820F514Ch case   11:*/		return 0x820F5150;
		  /* 820F5150h */ case   12:  		/* cmplw CR6, R6, R7 */
		/* 820F5150h case   12:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 820F5150h case   12:*/		return 0x820F5154;
		  /* 820F5154h */ case   13:  		/* bc 12, CR6_EQ, 88 */
		/* 820F5154h case   13:*/		if ( regs.CR[6].eq ) { return 0x820F51AC;  }
		/* 820F5154h case   13:*/		return 0x820F5158;
		  /* 820F5158h */ case   14:  		/* stw R11, <#[R8]> */
		/* 820F5158h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820F5158h case   14:*/		return 0x820F515C;
		  /* 820F515Ch */ case   15:  		/* mr R9, R23 */
		/* 820F515Ch case   15:*/		regs.R9 = regs.R23;
		/* 820F515Ch case   15:*/		return 0x820F5160;
		  /* 820F5160h */ case   16:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F5160h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F5160h case   16:*/		return 0x820F5164;
		  /* 820F5164h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 820F5164h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F5164h case   17:*/		return 0x820F5168;
		  /* 820F5168h */ case   18:  		/* bc 4, CR6_GT, 68 */
		/* 820F5168h case   18:*/		if ( !regs.CR[6].gt ) { return 0x820F51AC;  }
		/* 820F5168h case   18:*/		return 0x820F516C;
		  /* 820F516Ch */ case   19:  		/* mr R10, R23 */
		/* 820F516Ch case   19:*/		regs.R10 = regs.R23;
		/* 820F516Ch case   19:*/		return 0x820F5170;
		  /* 820F5170h */ case   20:  		/* lwz R11, <#[R31 + 20]> */
		/* 820F5170h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820F5170h case   20:*/		return 0x820F5174;
		  /* 820F5174h */ case   21:  		/* lwz R4, <#[R31 + 128]> */
		/* 820F5174h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000080) );
		/* 820F5174h case   21:*/		return 0x820F5178;
		  /* 820F5178h */ case   22:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820F5178h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820F5178h case   22:*/		return 0x820F517C;
		  /* 820F517Ch */ case   23:  		/* lwz R3, <#[R11 + 4]> */
		/* 820F517Ch case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 820F517Ch case   23:*/		return 0x820F5180;
		  /* 820F5180h */ case   24:  		/* cmplw CR6, R3, R4 */
		/* 820F5180h case   24:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 820F5180h case   24:*/		return 0x820F5184;
		  /* 820F5184h */ case   25:  		/* bc 4, CR6_EQ, 20 */
		/* 820F5184h case   25:*/		if ( !regs.CR[6].eq ) { return 0x820F5198;  }
		/* 820F5184h case   25:*/		return 0x820F5188;
		  /* 820F5188h */ case   26:  		/* lwz R4, <#[R11 + 12]> */
		/* 820F5188h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F5188h case   26:*/		return 0x820F518C;
		  /* 820F518Ch */ case   27:  		/* cmplw CR6, R4, R6 */
		/* 820F518Ch case   27:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R6);
		/* 820F518Ch case   27:*/		return 0x820F5190;
		  /* 820F5190h */ case   28:  		/* bc 4, CR6_EQ, 8 */
		/* 820F5190h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820F5198;  }
		/* 820F5190h case   28:*/		return 0x820F5194;
		  /* 820F5194h */ case   29:  		/* stw R7, <#[R11 + 12]> */
		/* 820F5194h case   29:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F5194h case   29:*/		return 0x820F5198;
	}
	return 0x820F5198;
} // Block from 820F5120h-820F5198h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820F5198h
// Function '?AddExtraSymbolTableEntries@CShaderProgram@D3DXShader@@MAAJPAVCCommentBlock@2@PAU_D3DXSHADER_CONSTANTINFO@@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5198);
		  /* 820F5198h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F5198h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F5198h case    0:*/		return 0x820F519C;
		  /* 820F519Ch */ case    1:  		/* addi R9, R9, 1 */
		/* 820F519Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F519Ch case    1:*/		return 0x820F51A0;
		  /* 820F51A0h */ case    2:  		/* addi R10, R10, 4 */
		/* 820F51A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F51A0h case    2:*/		return 0x820F51A4;
		  /* 820F51A4h */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 820F51A4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820F51A4h case    3:*/		return 0x820F51A8;
		  /* 820F51A8h */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 820F51A8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F5170;  }
		/* 820F51A8h case    4:*/		return 0x820F51AC;
	}
	return 0x820F51AC;
} // Block from 820F5198h-820F51ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F51ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F51AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F51AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F51AC);
		  /* 820F51ACh */ case    0:  		/* addi R8, R8, 4 */
		/* 820F51ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820F51ACh case    0:*/		return 0x820F51B0;
		  /* 820F51B0h */ case    1:  		/* addi R7, R7, 1 */
		/* 820F51B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820F51B0h case    1:*/		return 0x820F51B4;
	}
	return 0x820F51B4;
} // Block from 820F51ACh-820F51B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F51B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F51B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F51B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F51B4);
		  /* 820F51B4h */ case    0:  		/* addi R6, R6, 1 */
		/* 820F51B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820F51B4h case    0:*/		return 0x820F51B8;
		  /* 820F51B8h */ case    1:  		/* addi R5, R5, 4 */
		/* 820F51B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 820F51B8h case    1:*/		return 0x820F51BC;
		  /* 820F51BCh */ case    2:  		/* cmplw CR6, R6, R22 */
		/* 820F51BCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R22);
		/* 820F51BCh case    2:*/		return 0x820F51C0;
		  /* 820F51C0h */ case    3:  		/* bc 12, CR6_LT, -124 */
		/* 820F51C0h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F5144;  }
		/* 820F51C0h case    3:*/		return 0x820F51C4;
	}
	return 0x820F51C4;
} // Block from 820F51B4h-820F51C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F51C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F51C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F51C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F51C4);
		  /* 820F51C4h */ case    0:  		/* mr R22, R7 */
		/* 820F51C4h case    0:*/		regs.R22 = regs.R7;
		/* 820F51C4h case    0:*/		return 0x820F51C8;
	}
	return 0x820F51C8;
} // Block from 820F51C4h-820F51C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F51C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F51C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F51C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F51C8);
		  /* 820F51C8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F51C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F51C8h case    0:*/		return 0x820F51CC;
		  /* 820F51CCh */ case    1:  		/* mr R6, R23 */
		/* 820F51CCh case    1:*/		regs.R6 = regs.R23;
		/* 820F51CCh case    1:*/		return 0x820F51D0;
		  /* 820F51D0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820F51D0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F51D0h case    2:*/		return 0x820F51D4;
		  /* 820F51D4h */ case    3:  		/* bc 4, CR6_GT, 116 */
		/* 820F51D4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820F5248;  }
		/* 820F51D4h case    3:*/		return 0x820F51D8;
		  /* 820F51D8h */ case    4:  		/* mr R7, R23 */
		/* 820F51D8h case    4:*/		regs.R7 = regs.R23;
		/* 820F51D8h case    4:*/		return 0x820F51DC;
		  /* 820F51DCh */ case    5:  		/* lwz R11, <#[R31 + 20]> */
		/* 820F51DCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820F51DCh case    5:*/		return 0x820F51E0;
		  /* 820F51E0h */ case    6:  		/* lwz R10, <#[R31 + 128]> */
		/* 820F51E0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000080) );
		/* 820F51E0h case    6:*/		return 0x820F51E4;
		  /* 820F51E4h */ case    7:  		/* lwzx R8, <#[R11 + R7]> */
		/* 820F51E4h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820F51E4h case    7:*/		return 0x820F51E8;
		  /* 820F51E8h */ case    8:  		/* lwz R11, <#[R8 + 4]> */
		/* 820F51E8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 820F51E8h case    8:*/		return 0x820F51EC;
		  /* 820F51ECh */ case    9:  		/* cmplw CR6, R10, R11 */
		/* 820F51ECh case    9:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820F51ECh case    9:*/		return 0x820F51F0;
		  /* 820F51F0h */ case   10:  		/* bc 4, CR6_EQ, 68 */
		/* 820F51F0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820F5234;  }
		/* 820F51F0h case   10:*/		return 0x820F51F4;
		  /* 820F51F4h */ case   11:  		/* mr R9, R23 */
		/* 820F51F4h case   11:*/		regs.R9 = regs.R23;
		/* 820F51F4h case   11:*/		return 0x820F51F8;
		  /* 820F51F8h */ case   12:  		/* cmplwi CR6, R22, 0 */
		/* 820F51F8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820F51F8h case   12:*/		return 0x820F51FC;
		  /* 820F51FCh */ case   13:  		/* bc 12, CR6_EQ, 56 */
		/* 820F51FCh case   13:*/		if ( regs.CR[6].eq ) { return 0x820F5234;  }
		/* 820F51FCh case   13:*/		return 0x820F5200;
		  /* 820F5200h */ case   14:  		/* mr R10, R20 */
		/* 820F5200h case   14:*/		regs.R10 = regs.R20;
		/* 820F5200h case   14:*/		return 0x820F5204;
		  /* 820F5204h */ case   15:  		/* mtspr CTR, R22 */
		/* 820F5204h case   15:*/		regs.CTR = regs.R22;
		/* 820F5204h case   15:*/		return 0x820F5208;
		  /* 820F5208h */ case   16:  		/* lwz R11, <#[R10]> */
		/* 820F5208h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820F5208h case   16:*/		return 0x820F520C;
		  /* 820F520Ch */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 820F520Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F520Ch case   17:*/		return 0x820F5210;
		  /* 820F5210h */ case   18:  		/* bc 12, CR6_EQ, 24 */
		/* 820F5210h case   18:*/		if ( regs.CR[6].eq ) { return 0x820F5228;  }
		/* 820F5210h case   18:*/		return 0x820F5214;
		  /* 820F5214h */ case   19:  		/* lwz R5, <#[R8 + 108]> */
		/* 820F5214h case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x0000006C) );
		/* 820F5214h case   19:*/		return 0x820F5218;
		  /* 820F5218h */ case   20:  		/* lwz R11, <#[R11 + 108]> */
		/* 820F5218h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000006C) );
		/* 820F5218h case   20:*/		return 0x820F521C;
		  /* 820F521Ch */ case   21:  		/* cmplw CR6, R5, R11 */
		/* 820F521Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 820F521Ch case   21:*/		return 0x820F5220;
		  /* 820F5220h */ case   22:  		/* bc 4, CR6_EQ, 8 */
		/* 820F5220h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820F5228;  }
		/* 820F5220h case   22:*/		return 0x820F5224;
		  /* 820F5224h */ case   23:  		/* stw R9, <#[R8 + 12]> */
		/* 820F5224h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x0000000C) );
		/* 820F5224h case   23:*/		return 0x820F5228;
	}
	return 0x820F5228;
} // Block from 820F51C8h-820F5228h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F5228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5228);
		  /* 820F5228h */ case    0:  		/* addi R9, R9, 1 */
		/* 820F5228h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820F5228h case    0:*/		return 0x820F522C;
		  /* 820F522Ch */ case    1:  		/* addi R10, R10, 4 */
		/* 820F522Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F522Ch case    1:*/		return 0x820F5230;
		  /* 820F5230h */ case    2:  		/* bc 16, CR0_LT, -40 */
		/* 820F5230h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F5208;  }
		/* 820F5230h case    2:*/		return 0x820F5234;
	}
	return 0x820F5234;
} // Block from 820F5228h-820F5234h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F5234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5234);
		  /* 820F5234h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F5234h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F5234h case    0:*/		return 0x820F5238;
		  /* 820F5238h */ case    1:  		/* addi R6, R6, 1 */
		/* 820F5238h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820F5238h case    1:*/		return 0x820F523C;
		  /* 820F523Ch */ case    2:  		/* addi R7, R7, 4 */
		/* 820F523Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820F523Ch case    2:*/		return 0x820F5240;
		  /* 820F5240h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 820F5240h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820F5240h case    3:*/		return 0x820F5244;
		  /* 820F5244h */ case    4:  		/* bc 12, CR6_LT, -104 */
		/* 820F5244h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F51DC;  }
		/* 820F5244h case    4:*/		return 0x820F5248;
	}
	return 0x820F5248;
} // Block from 820F5234h-820F5248h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F5248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5248);
		  /* 820F5248h */ case    0:  		/* rlwinm R5, R22, 2, 0, 29 */
		/* 820F5248h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R22);
		/* 820F5248h case    0:*/		return 0x820F524C;
		  /* 820F524Ch */ case    1:  		/* li R4, 0 */
		/* 820F524Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F524Ch case    1:*/		return 0x820F5250;
		  /* 820F5250h */ case    2:  		/* mr R3, R20 */
		/* 820F5250h case    2:*/		regs.R3 = regs.R20;
		/* 820F5250h case    2:*/		return 0x820F5254;
		  /* 820F5254h */ case    3:  		/* bl -409364 */
		/* 820F5254h case    3:*/		regs.LR = 0x820F5258; return 0x82091340;
		/* 820F5254h case    3:*/		return 0x820F5258;
		  /* 820F5258h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F5258h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F5258h case    4:*/		return 0x820F525C;
		  /* 820F525Ch */ case    5:  		/* mr R8, R23 */
		/* 820F525Ch case    5:*/		regs.R8 = regs.R23;
		/* 820F525Ch case    5:*/		return 0x820F5260;
		  /* 820F5260h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820F5260h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F5260h case    6:*/		return 0x820F5264;
		  /* 820F5264h */ case    7:  		/* bc 4, CR6_GT, 88 */
		/* 820F5264h case    7:*/		if ( !regs.CR[6].gt ) { return 0x820F52BC;  }
		/* 820F5264h case    7:*/		return 0x820F5268;
		  /* 820F5268h */ case    8:  		/* mr R10, R23 */
		/* 820F5268h case    8:*/		regs.R10 = regs.R23;
		/* 820F5268h case    8:*/		return 0x820F526C;
		  /* 820F526Ch */ case    9:  		/* lwz R11, <#[R31 + 20]> */
		/* 820F526Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820F526Ch case    9:*/		return 0x820F5270;
		  /* 820F5270h */ case   10:  		/* lwz R9, <#[R31 + 16]> */
		/* 820F5270h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820F5270h case   10:*/		return 0x820F5274;
		  /* 820F5274h */ case   11:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820F5274h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820F5274h case   11:*/		return 0x820F5278;
		  /* 820F5278h */ case   12:  		/* lwz R7, <#[R11 + 4]> */
		/* 820F5278h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 820F5278h case   12:*/		return 0x820F527C;
		  /* 820F527Ch */ case   13:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820F527Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820F527Ch case   13:*/		return 0x820F5280;
		  /* 820F5280h */ case   14:  		/* lwzx R9, <#[R7 + R9]> */
		/* 820F5280h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 820F5280h case   14:*/		return 0x820F5284;
		  /* 820F5284h */ case   15:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F5284h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F5284h case   15:*/		return 0x820F5288;
		  /* 820F5288h */ case   16:  		/* rlwinm. R7, R9, 0, 27, 27 */
		/* 820F5288h case   16:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R7,regs.R9);
		/* 820F5288h case   16:*/		return 0x820F528C;
		  /* 820F528Ch */ case   17:  		/* bc 12, CR0_EQ, 28 */
		/* 820F528Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x820F52A8;  }
		/* 820F528Ch case   17:*/		return 0x820F5290;
		  /* 820F5290h */ case   18:  		/* andi. R9, R9, 516 */
		/* 820F5290h case   18:*/		cpu::op::andi<1>(regs,&regs.R9,regs.R9,0x204);
		/* 820F5290h case   18:*/		return 0x820F5294;
		  /* 820F5294h */ case   19:  		/* cmplwi CR0, R9, 0 */
		/* 820F5294h case   19:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820F5294h case   19:*/		return 0x820F5298;
		  /* 820F5298h */ case   20:  		/* bc 4, CR0_EQ, 16 */
		/* 820F5298h case   20:*/		if ( !regs.CR[0].eq ) { return 0x820F52A8;  }
		/* 820F5298h case   20:*/		return 0x820F529C;
		  /* 820F529Ch */ case   21:  		/* lwz R9, <#[R11 + 12]> */
		/* 820F529Ch case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 820F529Ch case   21:*/		return 0x820F52A0;
		  /* 820F52A0h */ case   22:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F52A0h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F52A0h case   22:*/		return 0x820F52A4;
		  /* 820F52A4h */ case   23:  		/* stwx R11, <#[R9 + R20]> */
		/* 820F52A4h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R20 + 0x00000000) );
		/* 820F52A4h case   23:*/		return 0x820F52A8;
	}
	return 0x820F52A8;
} // Block from 820F5248h-820F52A8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820F52A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F52A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F52A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F52A8);
		  /* 820F52A8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F52A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F52A8h case    0:*/		return 0x820F52AC;
		  /* 820F52ACh */ case    1:  		/* addi R8, R8, 1 */
		/* 820F52ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820F52ACh case    1:*/		return 0x820F52B0;
		  /* 820F52B0h */ case    2:  		/* addi R10, R10, 4 */
		/* 820F52B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820F52B0h case    2:*/		return 0x820F52B4;
		  /* 820F52B4h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 820F52B4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820F52B4h case    3:*/		return 0x820F52B8;
		  /* 820F52B8h */ case    4:  		/* bc 12, CR6_LT, -76 */
		/* 820F52B8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F526C;  }
		/* 820F52B8h case    4:*/		return 0x820F52BC;
	}
	return 0x820F52BC;
} // Block from 820F52A8h-820F52BCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F52BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F52BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F52BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F52BC);
		  /* 820F52BCh */ case    0:  		/* mr R25, R23 */
		/* 820F52BCh case    0:*/		regs.R25 = regs.R23;
		/* 820F52BCh case    0:*/		return 0x820F52C0;
		  /* 820F52C0h */ case    1:  		/* cmplwi CR6, R22, 0 */
		/* 820F52C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820F52C0h case    1:*/		return 0x820F52C4;
		  /* 820F52C4h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 820F52C4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F52F4;  }
		/* 820F52C4h case    2:*/		return 0x820F52C8;
		  /* 820F52C8h */ case    3:  		/* mr R11, R20 */
		/* 820F52C8h case    3:*/		regs.R11 = regs.R20;
		/* 820F52C8h case    3:*/		return 0x820F52CC;
		  /* 820F52CCh */ case    4:  		/* mtspr CTR, R22 */
		/* 820F52CCh case    4:*/		regs.CTR = regs.R22;
		/* 820F52CCh case    4:*/		return 0x820F52D0;
		  /* 820F52D0h */ case    5:  		/* lwz R10, <#[R11]> */
		/* 820F52D0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820F52D0h case    5:*/		return 0x820F52D4;
		  /* 820F52D4h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 820F52D4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820F52D4h case    6:*/		return 0x820F52D8;
		  /* 820F52D8h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820F52D8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820F52EC;  }
		/* 820F52D8h case    7:*/		return 0x820F52DC;
		  /* 820F52DCh */ case    8:  		/* lwz R10, <#[R10]> */
		/* 820F52DCh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820F52DCh case    8:*/		return 0x820F52E0;
		  /* 820F52E0h */ case    9:  		/* rlwinm. R10, R10, 0, 3, 3 */
		/* 820F52E0h case    9:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R10);
		/* 820F52E0h case    9:*/		return 0x820F52E4;
		  /* 820F52E4h */ case   10:  		/* bc 4, CR0_EQ, 8 */
		/* 820F52E4h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820F52EC;  }
		/* 820F52E4h case   10:*/		return 0x820F52E8;
		  /* 820F52E8h */ case   11:  		/* addi R25, R25, 1 */
		/* 820F52E8h case   11:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 820F52E8h case   11:*/		return 0x820F52EC;
	}
	return 0x820F52EC;
} // Block from 820F52BCh-820F52ECh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F52ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F52EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F52EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F52EC);
		  /* 820F52ECh */ case    0:  		/* addi R11, R11, 4 */
		/* 820F52ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F52ECh case    0:*/		return 0x820F52F0;
		  /* 820F52F0h */ case    1:  		/* bc 16, CR0_LT, -32 */
		/* 820F52F0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820F52D0;  }
		/* 820F52F0h case    1:*/		return 0x820F52F4;
	}
	return 0x820F52F4;
} // Block from 820F52ECh-820F52F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F52F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F52F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F52F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F52F4);
		  /* 820F52F4h */ case    0:  		/* mr R3, R31 */
		/* 820F52F4h case    0:*/		regs.R3 = regs.R31;
		/* 820F52F4h case    0:*/		return 0x820F52F8;
		  /* 820F52F8h */ case    1:  		/* bl -25360 */
		/* 820F52F8h case    1:*/		regs.LR = 0x820F52FC; return 0x820EEFE8;
		/* 820F52F8h case    1:*/		return 0x820F52FC;
		  /* 820F52FCh */ case    2:  		/* or. R30, R3, R3 */
		/* 820F52FCh case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F52FCh case    2:*/		return 0x820F5300;
		  /* 820F5300h */ case    3:  		/* bc 12, CR0_LT, 2580 */
		/* 820F5300h case    3:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5300h case    3:*/		return 0x820F5304;
		  /* 820F5304h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 820F5304h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5304h case    4:*/		return 0x820F5308;
		  /* 820F5308h */ case    5:  		/* mr R3, R31 */
		/* 820F5308h case    5:*/		regs.R3 = regs.R31;
		/* 820F5308h case    5:*/		return 0x820F530C;
		  /* 820F530Ch */ case    6:  		/* lwz R11, <#[R11 + 44]> */
		/* 820F530Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 820F530Ch case    6:*/		return 0x820F5310;
		  /* 820F5310h */ case    7:  		/* mtspr CTR, R11 */
		/* 820F5310h case    7:*/		regs.CTR = regs.R11;
		/* 820F5310h case    7:*/		return 0x820F5314;
		  /* 820F5314h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820F5314h case    8:*/		if ( 1 ) { regs.LR = 0x820F5318; return (uint32)regs.CTR; }
		/* 820F5314h case    8:*/		return 0x820F5318;
		  /* 820F5318h */ case    9:  		/* or. R30, R3, R3 */
		/* 820F5318h case    9:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5318h case    9:*/		return 0x820F531C;
		  /* 820F531Ch */ case   10:  		/* bc 12, CR0_LT, 2552 */
		/* 820F531Ch case   10:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F531Ch case   10:*/		return 0x820F5320;
		  /* 820F5320h */ case   11:  		/* lwz R11, <#[R31 + 204]> */
		/* 820F5320h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 820F5320h case   11:*/		return 0x820F5324;
		  /* 820F5324h */ case   12:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820F5324h case   12:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820F5324h case   12:*/		return 0x820F5328;
		  /* 820F5328h */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 820F5328h case   13:*/		if ( regs.CR[0].eq ) { return 0x820F5338;  }
		/* 820F5328h case   13:*/		return 0x820F532C;
		  /* 820F532Ch */ case   14:  		/* lwz R11, <#[R31 + 108]> */
		/* 820F532Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 820F532Ch case   14:*/		return 0x820F5330;
		  /* 820F5330h */ case   15:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 820F5330h case   15:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 820F5330h case   15:*/		return 0x820F5334;
		  /* 820F5334h */ case   16:  		/* bc 12, CR0_EQ, 48 */
		/* 820F5334h case   16:*/		if ( regs.CR[0].eq ) { return 0x820F5364;  }
		/* 820F5334h case   16:*/		return 0x820F5338;
	}
	return 0x820F5338;
} // Block from 820F52F4h-820F5338h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820F5338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5338);
		  /* 820F5338h */ case    0:  		/* mr R3, R31 */
		/* 820F5338h case    0:*/		regs.R3 = regs.R31;
		/* 820F5338h case    0:*/		return 0x820F533C;
		  /* 820F533Ch */ case    1:  		/* bl -68444 */
		/* 820F533Ch case    1:*/		regs.LR = 0x820F5340; return 0x820E47E0;
		/* 820F533Ch case    1:*/		return 0x820F5340;
		  /* 820F5340h */ case    2:  		/* or. R30, R3, R3 */
		/* 820F5340h case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5340h case    2:*/		return 0x820F5344;
		  /* 820F5344h */ case    3:  		/* bc 12, CR0_LT, 2512 */
		/* 820F5344h case    3:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5344h case    3:*/		return 0x820F5348;
		  /* 820F5348h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 820F5348h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5348h case    4:*/		return 0x820F534C;
		  /* 820F534Ch */ case    5:  		/* mr R3, R31 */
		/* 820F534Ch case    5:*/		regs.R3 = regs.R31;
		/* 820F534Ch case    5:*/		return 0x820F5350;
		  /* 820F5350h */ case    6:  		/* lwz R11, <#[R11 + 40]> */
		/* 820F5350h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 820F5350h case    6:*/		return 0x820F5354;
		  /* 820F5354h */ case    7:  		/* mtspr CTR, R11 */
		/* 820F5354h case    7:*/		regs.CTR = regs.R11;
		/* 820F5354h case    7:*/		return 0x820F5358;
		  /* 820F5358h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820F5358h case    8:*/		if ( 1 ) { regs.LR = 0x820F535C; return (uint32)regs.CTR; }
		/* 820F5358h case    8:*/		return 0x820F535C;
		  /* 820F535Ch */ case    9:  		/* or. R30, R3, R3 */
		/* 820F535Ch case    9:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F535Ch case    9:*/		return 0x820F5360;
		  /* 820F5360h */ case   10:  		/* bc 12, CR0_LT, 2484 */
		/* 820F5360h case   10:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5360h case   10:*/		return 0x820F5364;
	}
	return 0x820F5364;
} // Block from 820F5338h-820F5364h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820F5364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5364);
		  /* 820F5364h */ case    0:  		/* lwz R11, <#[R31 + 400]> */
		/* 820F5364h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000190) );
		/* 820F5364h case    0:*/		return 0x820F5368;
		  /* 820F5368h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820F5368h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F5368h case    1:*/		return 0x820F536C;
		  /* 820F536Ch */ case    2:  		/* bc 12, CR6_EQ, 116 */
		/* 820F536Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820F53E0;  }
		/* 820F536Ch case    2:*/		return 0x820F5370;
		  /* 820F5370h */ case    3:  		/* lis R11, -32255 */
		/* 820F5370h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820F5370h case    3:*/		return 0x820F5374;
		  /* 820F5374h */ case    4:  		/* li R7, 4 */
		/* 820F5374h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 820F5374h case    4:*/		return 0x820F5378;
		  /* 820F5378h */ case    5:  		/* addi R4, R11, -8824 */
		/* 820F5378h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFDD88);
		/* 820F5378h case    5:*/		return 0x820F537C;
		  /* 820F537Ch */ case    6:  		/* mr R6, R24 */
		/* 820F537Ch case    6:*/		regs.R6 = regs.R24;
		/* 820F537Ch case    6:*/		return 0x820F5380;
		  /* 820F5380h */ case    7:  		/* li R5, 849 */
		/* 820F5380h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x351);
		/* 820F5380h case    7:*/		return 0x820F5384;
		  /* 820F5384h */ case    8:  		/* mr R3, R31 */
		/* 820F5384h case    8:*/		regs.R3 = regs.R31;
		/* 820F5384h case    8:*/		return 0x820F5388;
		  /* 820F5388h */ case    9:  		/* bl 32256 */
		/* 820F5388h case    9:*/		regs.LR = 0x820F538C; return 0x820FD188;
		/* 820F5388h case    9:*/		return 0x820F538C;
		  /* 820F538Ch */ case   10:  		/* mr R27, R3 */
		/* 820F538Ch case   10:*/		regs.R27 = regs.R3;
		/* 820F538Ch case   10:*/		return 0x820F5390;
		  /* 820F5390h */ case   11:  		/* cmpwi CR6, R3, -1 */
		/* 820F5390h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820F5390h case   11:*/		return 0x820F5394;
		  /* 820F5394h */ case   12:  		/* bc 12, CR6_EQ, 920 */
		/* 820F5394h case   12:*/		if ( regs.CR[6].eq ) { return 0x820F572C;  }
		/* 820F5394h case   12:*/		return 0x820F5398;
		  /* 820F5398h */ case   13:  		/* lis R11, -32254 */
		/* 820F5398h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F5398h case   13:*/		return 0x820F539C;
		  /* 820F539Ch */ case   14:  		/* mr R30, R23 */
		/* 820F539Ch case   14:*/		regs.R30 = regs.R23;
		/* 820F539Ch case   14:*/		return 0x820F53A0;
		  /* 820F53A0h */ case   15:  		/* addi R28, R11, -15832 */
		/* 820F53A0h case   15:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFC228);
		/* 820F53A0h case   15:*/		return 0x820F53A4;
		  /* 820F53A4h */ case   16:  		/* addi R29, R31, 404 */
		/* 820F53A4h case   16:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x194);
		/* 820F53A4h case   16:*/		return 0x820F53A8;
		  /* 820F53A8h */ case   17:  		/* rlwinm R6, R30, 0, 30, 31 */
		/* 820F53A8h case   17:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R30);
		/* 820F53A8h case   17:*/		return 0x820F53AC;
		  /* 820F53ACh */ case   18:  		/* lfd FR1, <#[R28]> */
		/* 820F53ACh case   18:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R28 + 0x00000000) );
		/* 820F53ACh case   18:*/		return 0x820F53B0;
		  /* 820F53B0h */ case   19:  		/* rlwinm R5, R30, 30, 2, 31 */
		/* 820F53B0h case   19:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R5,regs.R30);
		/* 820F53B0h case   19:*/		return 0x820F53B4;
		  /* 820F53B4h */ case   20:  		/* mr R4, R27 */
		/* 820F53B4h case   20:*/		regs.R4 = regs.R27;
		/* 820F53B4h case   20:*/		return 0x820F53B8;
		  /* 820F53B8h */ case   21:  		/* mr R3, R31 */
		/* 820F53B8h case   21:*/		regs.R3 = regs.R31;
		/* 820F53B8h case   21:*/		return 0x820F53BC;
		  /* 820F53BCh */ case   22:  		/* bl 32364 */
		/* 820F53BCh case   22:*/		regs.LR = 0x820F53C0; return 0x820FD228;
		/* 820F53BCh case   22:*/		return 0x820F53C0;
		  /* 820F53C0h */ case   23:  		/* stw R3, <#[R29]> */
		/* 820F53C0h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 820F53C0h case   23:*/		return 0x820F53C4;
		  /* 820F53C4h */ case   24:  		/* cmpwi CR6, R3, -1 */
		/* 820F53C4h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820F53C4h case   24:*/		return 0x820F53C8;
	}
	return 0x820F53C8;
} // Block from 820F5364h-820F53C8h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820F53C8h
// Function '?GenerateCode@CShaderProgram@D3DXShader@@UAAJPAPAUID3DXBuffer@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F53C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F53C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F53C8);
		  /* 820F53C8h */ case    0:  		/* bc 12, CR6_EQ, 868 */
		/* 820F53C8h case    0:*/		if ( regs.CR[6].eq ) { return 0x820F572C;  }
		/* 820F53C8h case    0:*/		return 0x820F53CC;
		  /* 820F53CCh */ case    1:  		/* addi R30, R30, 1 */
		/* 820F53CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820F53CCh case    1:*/		return 0x820F53D0;
		  /* 820F53D0h */ case    2:  		/* addi R29, R29, 4 */
		/* 820F53D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820F53D0h case    2:*/		return 0x820F53D4;
		  /* 820F53D4h */ case    3:  		/* addi R28, R28, 8 */
		/* 820F53D4h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 820F53D4h case    3:*/		return 0x820F53D8;
		  /* 820F53D8h */ case    4:  		/* cmplwi CR6, R30, 8 */
		/* 820F53D8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000008);
		/* 820F53D8h case    4:*/		return 0x820F53DC;
		  /* 820F53DCh */ case    5:  		/* bc 12, CR6_LT, -52 */
		/* 820F53DCh case    5:*/		if ( regs.CR[6].lt ) { return 0x820F53A8;  }
		/* 820F53DCh case    5:*/		return 0x820F53E0;
	}
	return 0x820F53E0;
} // Block from 820F53C8h-820F53E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F53E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F53E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F53E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F53E0);
		  /* 820F53E0h */ case    0:  		/* lis R7, 4 */
		/* 820F53E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0x4);
		/* 820F53E0h case    0:*/		return 0x820F53E4;
		  /* 820F53E4h */ case    1:  		/* lwz R5, <#[R31 + 56]> */
		/* 820F53E4h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000038) );
		/* 820F53E4h case    1:*/		return 0x820F53E8;
		  /* 820F53E8h */ case    2:  		/* li R8, 99 */
		/* 820F53E8h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x63);
		/* 820F53E8h case    2:*/		return 0x820F53EC;
		  /* 820F53ECh */ case    3:  		/* lwz R4, <#[R31 + 124]> */
		/* 820F53ECh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000007C) );
		/* 820F53ECh case    3:*/		return 0x820F53F0;
		  /* 820F53F0h */ case    4:  		/* ori R7, R7, 8320 */
		/* 820F53F0h case    4:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x2080);
		/* 820F53F0h case    4:*/		return 0x820F53F4;
		  /* 820F53F4h */ case    5:  		/* li R6, 512 */
		/* 820F53F4h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x200);
		/* 820F53F4h case    5:*/		return 0x820F53F8;
		  /* 820F53F8h */ case    6:  		/* mr R3, R31 */
		/* 820F53F8h case    6:*/		regs.R3 = regs.R31;
		/* 820F53F8h case    6:*/		return 0x820F53FC;
		  /* 820F53FCh */ case    7:  		/* bl -30252 */
		/* 820F53FCh case    7:*/		regs.LR = 0x820F5400; return 0x820EDDD0;
		/* 820F53FCh case    7:*/		return 0x820F5400;
		  /* 820F5400h */ case    8:  		/* or. R30, R3, R3 */
		/* 820F5400h case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5400h case    8:*/		return 0x820F5404;
		  /* 820F5404h */ case    9:  		/* bc 12, CR0_LT, 2320 */
		/* 820F5404h case    9:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5404h case    9:*/		return 0x820F5408;
		  /* 820F5408h */ case   10:  		/* li R8, 98 */
		/* 820F5408h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x62);
		/* 820F5408h case   10:*/		return 0x820F540C;
		  /* 820F540Ch */ case   11:  		/* lwz R5, <#[R31 + 96]> */
		/* 820F540Ch case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000060) );
		/* 820F540Ch case   11:*/		return 0x820F5410;
		  /* 820F5410h */ case   12:  		/* li R7, 128 */
		/* 820F5410h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x80);
		/* 820F5410h case   12:*/		return 0x820F5414;
		  /* 820F5414h */ case   13:  		/* lwz R4, <#[R31 + 156]> */
		/* 820F5414h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000009C) );
		/* 820F5414h case   13:*/		return 0x820F5418;
		  /* 820F5418h */ case   14:  		/* li R6, 8704 */
		/* 820F5418h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x2200);
		/* 820F5418h case   14:*/		return 0x820F541C;
		  /* 820F541Ch */ case   15:  		/* mr R3, R31 */
		/* 820F541Ch case   15:*/		regs.R3 = regs.R31;
		/* 820F541Ch case   15:*/		return 0x820F5420;
		  /* 820F5420h */ case   16:  		/* bl -30288 */
		/* 820F5420h case   16:*/		regs.LR = 0x820F5424; return 0x820EDDD0;
		/* 820F5420h case   16:*/		return 0x820F5424;
		  /* 820F5424h */ case   17:  		/* or. R30, R3, R3 */
		/* 820F5424h case   17:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5424h case   17:*/		return 0x820F5428;
		  /* 820F5428h */ case   18:  		/* bc 12, CR0_LT, 2284 */
		/* 820F5428h case   18:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5428h case   18:*/		return 0x820F542C;
		  /* 820F542Ch */ case   19:  		/* lis R6, 4 */
		/* 820F542Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R6,0x4);
		/* 820F542Ch case   19:*/		return 0x820F5430;
		  /* 820F5430h */ case   20:  		/* lwz R5, <#[R31 + 64]> */
		/* 820F5430h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000040) );
		/* 820F5430h case   20:*/		return 0x820F5434;
		  /* 820F5434h */ case   21:  		/* li R8, 105 */
		/* 820F5434h case   21:*/		cpu::op::li<0>(regs,&regs.R8,0x69);
		/* 820F5434h case   21:*/		return 0x820F5438;
		  /* 820F5438h */ case   22:  		/* lwz R4, <#[R31 + 176]> */
		/* 820F5438h case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000000B0) );
		/* 820F5438h case   22:*/		return 0x820F543C;
		  /* 820F543Ch */ case   23:  		/* li R7, 128 */
		/* 820F543Ch case   23:*/		cpu::op::li<0>(regs,&regs.R7,0x80);
		/* 820F543Ch case   23:*/		return 0x820F5440;
		  /* 820F5440h */ case   24:  		/* ori R6, R6, 512 */
		/* 820F5440h case   24:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x200);
		/* 820F5440h case   24:*/		return 0x820F5444;
		  /* 820F5444h */ case   25:  		/* mr R3, R31 */
		/* 820F5444h case   25:*/		regs.R3 = regs.R31;
		/* 820F5444h case   25:*/		return 0x820F5448;
		  /* 820F5448h */ case   26:  		/* bl -30328 */
		/* 820F5448h case   26:*/		regs.LR = 0x820F544C; return 0x820EDDD0;
		/* 820F5448h case   26:*/		return 0x820F544C;
		  /* 820F544Ch */ case   27:  		/* or. R30, R3, R3 */
		/* 820F544Ch case   27:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F544Ch case   27:*/		return 0x820F5450;
		  /* 820F5450h */ case   28:  		/* bc 12, CR0_LT, 2244 */
		/* 820F5450h case   28:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5450h case   28:*/		return 0x820F5454;
		  /* 820F5454h */ case   29:  		/* lwz R11, <#[R31 + 12]> */
		/* 820F5454h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820F5454h case   29:*/		return 0x820F5458;
		  /* 820F5458h */ case   30:  		/* stw R23, <#[R31 + 264]> */
		/* 820F5458h case   30:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000108) );
		/* 820F5458h case   30:*/		return 0x820F545C;
		  /* 820F545Ch */ case   31:  		/* cmplwi CR6, R11, 0 */
		/* 820F545Ch case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F545Ch case   31:*/		return 0x820F5460;
		  /* 820F5460h */ case   32:  		/* bc 4, CR6_GT, 48 */
		/* 820F5460h case   32:*/		if ( !regs.CR[6].gt ) { return 0x820F5490;  }
		/* 820F5460h case   32:*/		return 0x820F5464;
		  /* 820F5464h */ case   33:  		/* lwz R11, <#[R31 + 24]> */
		/* 820F5464h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820F5464h case   33:*/		return 0x820F5468;
		  /* 820F5468h */ case   34:  		/* lwz R11, <#[R11]> */
		/* 820F5468h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820F5468h case   34:*/		return 0x820F546C;
		  /* 820F546Ch */ case   35:  		/* b 40 */
		/* 820F546Ch case   35:*/		return 0x820F5494;
		/* 820F546Ch case   35:*/		return 0x820F5470;
	}
	return 0x820F5470;
} // Block from 820F53E0h-820F5470h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820F5470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5470);
		  /* 820F5470h */ case    0:  		/* lis R11, -32254 */
		/* 820F5470h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F5470h case    0:*/		return 0x820F5474;
		  /* 820F5474h */ case    1:  		/* addi R6, R11, -15884 */
		/* 820F5474h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC1F4);
		/* 820F5474h case    1:*/		return 0x820F5478;
		  /* 820F5478h */ case    2:  		/* b 12 */
		/* 820F5478h case    2:*/		return 0x820F5484;
		/* 820F5478h case    2:*/		return 0x820F547C;
	}
	return 0x820F547C;
} // Block from 820F5470h-820F547Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F547Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F547C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F547C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F547C);
		  /* 820F547Ch */ case    0:  		/* lis R11, -32254 */
		/* 820F547Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 820F547Ch case    0:*/		return 0x820F5480;
		  /* 820F5480h */ case    1:  		/* addi R6, R11, -15932 */
		/* 820F5480h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC1C4);
		/* 820F5480h case    1:*/		return 0x820F5484;
	}
	return 0x820F5484;
} // Block from 820F547Ch-820F5484h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820F5484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5484);
		  /* 820F5484h */ case    0:  		/* li R5, 0 */
		/* 820F5484h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820F5484h case    0:*/		return 0x820F5488;
		  /* 820F5488h */ case    1:  		/* li R4, 0 */
		/* 820F5488h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F5488h case    1:*/		return 0x820F548C;
		  /* 820F548Ch */ case    2:  		/* b 1896 */
		/* 820F548Ch case    2:*/		return 0x820F5BF4;
		/* 820F548Ch case    2:*/		return 0x820F5490;
	}
	return 0x820F5490;
} // Block from 820F5484h-820F5490h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820F5490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5490);
		  /* 820F5490h */ case    0:  		/* mr R11, R23 */
		/* 820F5490h case    0:*/		regs.R11 = regs.R23;
		/* 820F5490h case    0:*/		return 0x820F5494;
	}
	return 0x820F5494;
} // Block from 820F5490h-820F5494h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F5494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5494);
		  /* 820F5494h */ case    0:  		/* stw R11, <#[R31 + 260]> */
		/* 820F5494h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 820F5494h case    0:*/		return 0x820F5498;
		  /* 820F5498h */ case    1:  		/* mr R3, R31 */
		/* 820F5498h case    1:*/		regs.R3 = regs.R31;
		/* 820F5498h case    1:*/		return 0x820F549C;
		  /* 820F549Ch */ case    2:  		/* stw R23, <#[R31 + 256]> */
		/* 820F549Ch case    2:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000100) );
		/* 820F549Ch case    2:*/		return 0x820F54A0;
		  /* 820F54A0h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820F54A0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F54A0h case    3:*/		return 0x820F54A4;
		  /* 820F54A4h */ case    4:  		/* lwz R11, <#[R11 + 56]> */
		/* 820F54A4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000038) );
		/* 820F54A4h case    4:*/		return 0x820F54A8;
		  /* 820F54A8h */ case    5:  		/* mtspr CTR, R11 */
		/* 820F54A8h case    5:*/		regs.CTR = regs.R11;
		/* 820F54A8h case    5:*/		return 0x820F54AC;
		  /* 820F54ACh */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820F54ACh case    6:*/		if ( 1 ) { regs.LR = 0x820F54B0; return (uint32)regs.CTR; }
		/* 820F54ACh case    6:*/		return 0x820F54B0;
		  /* 820F54B0h */ case    7:  		/* or. R30, R3, R3 */
		/* 820F54B0h case    7:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F54B0h case    7:*/		return 0x820F54B4;
		  /* 820F54B4h */ case    8:  		/* bc 12, CR0_LT, 2144 */
		/* 820F54B4h case    8:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F54B4h case    8:*/		return 0x820F54B8;
		  /* 820F54B8h */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F54B8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F54B8h case    9:*/		return 0x820F54BC;
		  /* 820F54BCh */ case   10:  		/* mr R30, R23 */
		/* 820F54BCh case   10:*/		regs.R30 = regs.R23;
		/* 820F54BCh case   10:*/		return 0x820F54C0;
		  /* 820F54C0h */ case   11:  		/* mr R26, R23 */
		/* 820F54C0h case   11:*/		regs.R26 = regs.R23;
		/* 820F54C0h case   11:*/		return 0x820F54C4;
		  /* 820F54C4h */ case   12:  		/* mr R5, R23 */
		/* 820F54C4h case   12:*/		regs.R5 = regs.R23;
		/* 820F54C4h case   12:*/		return 0x820F54C8;
		  /* 820F54C8h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 820F54C8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F54C8h case   13:*/		return 0x820F54CC;
		  /* 820F54CCh */ case   14:  		/* bc 4, CR6_GT, 100 */
		/* 820F54CCh case   14:*/		if ( !regs.CR[6].gt ) { return 0x820F5530;  }
		/* 820F54CCh case   14:*/		return 0x820F54D0;
		  /* 820F54D0h */ case   15:  		/* lwz R8, <#[R31 + 20]> */
		/* 820F54D0h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 820F54D0h case   15:*/		return 0x820F54D4;
		  /* 820F54D4h */ case   16:  		/* mr R11, R23 */
		/* 820F54D4h case   16:*/		regs.R11 = regs.R23;
		/* 820F54D4h case   16:*/		return 0x820F54D8;
		  /* 820F54D8h */ case   17:  		/* lwz R7, <#[R31 + 16]> */
		/* 820F54D8h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 820F54D8h case   17:*/		return 0x820F54DC;
		  /* 820F54DCh */ case   18:  		/* lwz R6, <#[R31 + 8]> */
		/* 820F54DCh case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 820F54DCh case   18:*/		return 0x820F54E0;
		  /* 820F54E0h */ case   19:  		/* lwzx R10, <#[R8 + R11]> */
		/* 820F54E0h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820F54E0h case   19:*/		return 0x820F54E4;
		  /* 820F54E4h */ case   20:  		/* lwz R9, <#[R10 + 4]> */
		/* 820F54E4h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820F54E4h case   20:*/		return 0x820F54E8;
		  /* 820F54E8h */ case   21:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820F54E8h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820F54E8h case   21:*/		return 0x820F54EC;
		  /* 820F54ECh */ case   22:  		/* lwzx R9, <#[R9 + R7]> */
		/* 820F54ECh case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820F54ECh case   22:*/		return 0x820F54F0;
		  /* 820F54F0h */ case   23:  		/* lwz R9, <#[R9 + 4]> */
		/* 820F54F0h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 820F54F0h case   23:*/		return 0x820F54F4;
		  /* 820F54F4h */ case   24:  		/* rlwinm. R4, R9, 0, 23, 23 */
		/* 820F54F4h case   24:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R4,regs.R9);
		/* 820F54F4h case   24:*/		return 0x820F54F8;
		  /* 820F54F8h */ case   25:  		/* bc 12, CR0_EQ, 40 */
		/* 820F54F8h case   25:*/		if ( regs.CR[0].eq ) { return 0x820F5520;  }
		/* 820F54F8h case   25:*/		return 0x820F54FC;
		  /* 820F54FCh */ case   26:  		/* lwz R10, <#[R10 + 8]> */
		/* 820F54FCh case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820F54FCh case   26:*/		return 0x820F5500;
		  /* 820F5500h */ case   27:  		/* cmpwi CR6, R10, -1 */
		/* 820F5500h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820F5500h case   27:*/		return 0x820F5504;
		  /* 820F5504h */ case   28:  		/* bc 4, CR6_EQ, 28 */
		/* 820F5504h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820F5520;  }
		/* 820F5504h case   28:*/		return 0x820F5508;
		  /* 820F5508h */ case   29:  		/* rlwinm. R10, R9, 0, 20, 20 */
		/* 820F5508h case   29:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R9);
		/* 820F5508h case   29:*/		return 0x820F550C;
		  /* 820F550Ch */ case   30:  		/* bc 12, CR0_EQ, 16 */
		/* 820F550Ch case   30:*/		if ( regs.CR[0].eq ) { return 0x820F551C;  }
		/* 820F550Ch case   30:*/		return 0x820F5510;
		  /* 820F5510h */ case   31:  		/* lwz R10, <#[R31 + 348]> */
		/* 820F5510h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000015C) );
		/* 820F5510h case   31:*/		return 0x820F5514;
		  /* 820F5514h */ case   32:  		/* cmpwi CR6, R10, 0 */
		/* 820F5514h case   32:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820F5514h case   32:*/		return 0x820F5518;
		  /* 820F5518h */ case   33:  		/* bc 12, CR6_EQ, 8 */
		/* 820F5518h case   33:*/		if ( regs.CR[6].eq ) { return 0x820F5520;  }
		/* 820F5518h case   33:*/		return 0x820F551C;
	}
	return 0x820F551C;
} // Block from 820F5494h-820F551Ch (34 instructions)

//////////////////////////////////////////////////////
// Block at 820F551Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F551C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F551C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F551C);
		  /* 820F551Ch */ case    0:  		/* addi R30, R30, 1 */
		/* 820F551Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820F551Ch case    0:*/		return 0x820F5520;
	}
	return 0x820F5520;
} // Block from 820F551Ch-820F5520h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820F5520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5520);
		  /* 820F5520h */ case    0:  		/* addi R5, R5, 1 */
		/* 820F5520h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820F5520h case    0:*/		return 0x820F5524;
		  /* 820F5524h */ case    1:  		/* addi R11, R11, 4 */
		/* 820F5524h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F5524h case    1:*/		return 0x820F5528;
		  /* 820F5528h */ case    2:  		/* cmplw CR6, R5, R6 */
		/* 820F5528h case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 820F5528h case    2:*/		return 0x820F552C;
		  /* 820F552Ch */ case    3:  		/* bc 12, CR6_LT, -76 */
		/* 820F552Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820F54E0;  }
		/* 820F552Ch case    3:*/		return 0x820F5530;
	}
	return 0x820F5530;
} // Block from 820F5520h-820F5530h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820F5530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5530);
		  /* 820F5530h */ case    0:  		/* rlwinm R29, R30, 4, 0, 27 */
		/* 820F5530h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R29,regs.R30);
		/* 820F5530h case    0:*/		return 0x820F5534;
		  /* 820F5534h */ case    1:  		/* lis R4, 9345 */
		/* 820F5534h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F5534h case    1:*/		return 0x820F5538;
		  /* 820F5538h */ case    2:  		/* mr R3, R29 */
		/* 820F5538h case    2:*/		regs.R3 = regs.R29;
		/* 820F5538h case    2:*/		return 0x820F553C;
		  /* 820F553Ch */ case    3:  		/* bl -447292 */
		/* 820F553Ch case    3:*/		regs.LR = 0x820F5540; return 0x82088200;
		/* 820F553Ch case    3:*/		return 0x820F5540;
		  /* 820F5540h */ case    4:  		/* or. R17, R3, R3 */
		/* 820F5540h case    4:*/		cpu::op::or<1>(regs,&regs.R17,regs.R3,regs.R3);
		/* 820F5540h case    4:*/		return 0x820F5544;
		  /* 820F5544h */ case    5:  		/* bc 12, CR0_EQ, 488 */
		/* 820F5544h case    5:*/		if ( regs.CR[0].eq ) { return 0x820F572C;  }
		/* 820F5544h case    5:*/		return 0x820F5548;
		  /* 820F5548h */ case    6:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820F5548h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820F5548h case    6:*/		return 0x820F554C;
		  /* 820F554Ch */ case    7:  		/* lis R4, 9345 */
		/* 820F554Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820F554Ch case    7:*/		return 0x820F5550;
		  /* 820F5550h */ case    8:  		/* mr R3, R30 */
		/* 820F5550h case    8:*/		regs.R3 = regs.R30;
		/* 820F5550h case    8:*/		return 0x820F5554;
		  /* 820F5554h */ case    9:  		/* bl -447316 */
		/* 820F5554h case    9:*/		regs.LR = 0x820F5558; return 0x82088200;
		/* 820F5554h case    9:*/		return 0x820F5558;
		  /* 820F5558h */ case   10:  		/* or. R28, R3, R3 */
		/* 820F5558h case   10:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820F5558h case   10:*/		return 0x820F555C;
		  /* 820F555Ch */ case   11:  		/* stw R28, <#[R1 + 92]> */
		/* 820F555Ch case   11:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 820F555Ch case   11:*/		return 0x820F5560;
		  /* 820F5560h */ case   12:  		/* bc 12, CR0_EQ, 1656 */
		/* 820F5560h case   12:*/		if ( regs.CR[0].eq ) { return 0x820F5BD8;  }
		/* 820F5560h case   12:*/		return 0x820F5564;
		  /* 820F5564h */ case   13:  		/* mr R5, R29 */
		/* 820F5564h case   13:*/		regs.R5 = regs.R29;
		/* 820F5564h case   13:*/		return 0x820F5568;
		  /* 820F5568h */ case   14:  		/* li R4, 0 */
		/* 820F5568h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F5568h case   14:*/		return 0x820F556C;
		  /* 820F556Ch */ case   15:  		/* mr R3, R17 */
		/* 820F556Ch case   15:*/		regs.R3 = regs.R17;
		/* 820F556Ch case   15:*/		return 0x820F5570;
		  /* 820F5570h */ case   16:  		/* bl -410160 */
		/* 820F5570h case   16:*/		regs.LR = 0x820F5574; return 0x82091340;
		/* 820F5570h case   16:*/		return 0x820F5574;
		  /* 820F5574h */ case   17:  		/* mr R5, R30 */
		/* 820F5574h case   17:*/		regs.R5 = regs.R30;
		/* 820F5574h case   17:*/		return 0x820F5578;
		  /* 820F5578h */ case   18:  		/* li R4, 0 */
		/* 820F5578h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820F5578h case   18:*/		return 0x820F557C;
		  /* 820F557Ch */ case   19:  		/* mr R3, R28 */
		/* 820F557Ch case   19:*/		regs.R3 = regs.R28;
		/* 820F557Ch case   19:*/		return 0x820F5580;
		  /* 820F5580h */ case   20:  		/* bl -410176 */
		/* 820F5580h case   20:*/		regs.LR = 0x820F5584; return 0x82091340;
		/* 820F5580h case   20:*/		return 0x820F5584;
		  /* 820F5584h */ case   21:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F5584h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F5584h case   21:*/		return 0x820F5588;
		  /* 820F5588h */ case   22:  		/* mr R6, R23 */
		/* 820F5588h case   22:*/		regs.R6 = regs.R23;
		/* 820F5588h case   22:*/		return 0x820F558C;
		  /* 820F558Ch */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 820F558Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F558Ch case   23:*/		return 0x820F5590;
		  /* 820F5590h */ case   24:  		/* bc 4, CR6_GT, 216 */
		/* 820F5590h case   24:*/		if ( !regs.CR[6].gt ) { return 0x820F5668;  }
		/* 820F5590h case   24:*/		return 0x820F5594;
		  /* 820F5594h */ case   25:  		/* mr R7, R23 */
		/* 820F5594h case   25:*/		regs.R7 = regs.R23;
		/* 820F5594h case   25:*/		return 0x820F5598;
		  /* 820F5598h */ case   26:  		/* lwz R11, <#[R31 + 20]> */
		/* 820F5598h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820F5598h case   26:*/		return 0x820F559C;
		  /* 820F559Ch */ case   27:  		/* lwz R9, <#[R31 + 16]> */
		/* 820F559Ch case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820F559Ch case   27:*/		return 0x820F55A0;
		  /* 820F55A0h */ case   28:  		/* lwzx R10, <#[R11 + R7]> */
		/* 820F55A0h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820F55A0h case   28:*/		return 0x820F55A4;
		  /* 820F55A4h */ case   29:  		/* lwz R11, <#[R10 + 4]> */
		/* 820F55A4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820F55A4h case   29:*/		return 0x820F55A8;
		  /* 820F55A8h */ case   30:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F55A8h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F55A8h case   30:*/		return 0x820F55AC;
		  /* 820F55ACh */ case   31:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820F55ACh case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820F55ACh case   31:*/		return 0x820F55B0;
		  /* 820F55B0h */ case   32:  		/* lwz R11, <#[R11 + 4]> */
		/* 820F55B0h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820F55B0h case   32:*/		return 0x820F55B4;
		  /* 820F55B4h */ case   33:  		/* rlwinm. R9, R11, 0, 23, 23 */
		/* 820F55B4h case   33:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R11);
		/* 820F55B4h case   33:*/		return 0x820F55B8;
		  /* 820F55B8h */ case   34:  		/* bc 12, CR0_EQ, 156 */
		/* 820F55B8h case   34:*/		if ( regs.CR[0].eq ) { return 0x820F5654;  }
		/* 820F55B8h case   34:*/		return 0x820F55BC;
		  /* 820F55BCh */ case   35:  		/* lwz R9, <#[R10 + 8]> */
		/* 820F55BCh case   35:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 820F55BCh case   35:*/		return 0x820F55C0;
		  /* 820F55C0h */ case   36:  		/* cmpwi CR6, R9, -1 */
		/* 820F55C0h case   36:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820F55C0h case   36:*/		return 0x820F55C4;
		  /* 820F55C4h */ case   37:  		/* bc 4, CR6_EQ, 144 */
		/* 820F55C4h case   37:*/		if ( !regs.CR[6].eq ) { return 0x820F5654;  }
		/* 820F55C4h case   37:*/		return 0x820F55C8;
		  /* 820F55C8h */ case   38:  		/* lwz R9, <#[R10 + 56]> */
		/* 820F55C8h case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000038) );
		/* 820F55C8h case   38:*/		return 0x820F55CC;
		  /* 820F55CCh */ case   39:  		/* cmpwi CR6, R9, -1 */
		/* 820F55CCh case   39:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820F55CCh case   39:*/		return 0x820F55D0;
		  /* 820F55D0h */ case   40:  		/* bc 4, CR6_EQ, 132 */
		/* 820F55D0h case   40:*/		if ( !regs.CR[6].eq ) { return 0x820F5654;  }
		/* 820F55D0h case   40:*/		return 0x820F55D4;
		  /* 820F55D4h */ case   41:  		/* rlwinm. R9, R11, 0, 13, 13 */
		/* 820F55D4h case   41:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R9,regs.R11);
		/* 820F55D4h case   41:*/		return 0x820F55D8;
		  /* 820F55D8h */ case   42:  		/* bc 4, CR0_EQ, 124 */
		/* 820F55D8h case   42:*/		if ( !regs.CR[0].eq ) { return 0x820F5654;  }
		/* 820F55D8h case   42:*/		return 0x820F55DC;
		  /* 820F55DCh */ case   43:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 820F55DCh case   43:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 820F55DCh case   43:*/		return 0x820F55E0;
		  /* 820F55E0h */ case   44:  		/* bc 12, CR0_EQ, 16 */
		/* 820F55E0h case   44:*/		if ( regs.CR[0].eq ) { return 0x820F55F0;  }
		/* 820F55E0h case   44:*/		return 0x820F55E4;
		  /* 820F55E4h */ case   45:  		/* lwz R11, <#[R31 + 348]> */
		/* 820F55E4h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000015C) );
		/* 820F55E4h case   45:*/		return 0x820F55E8;
		  /* 820F55E8h */ case   46:  		/* cmpwi CR6, R11, 0 */
		/* 820F55E8h case   46:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820F55E8h case   46:*/		return 0x820F55EC;
		  /* 820F55ECh */ case   47:  		/* bc 12, CR6_EQ, 104 */
		/* 820F55ECh case   47:*/		if ( regs.CR[6].eq ) { return 0x820F5654;  }
		/* 820F55ECh case   47:*/		return 0x820F55F0;
	}
	return 0x820F55F0;
} // Block from 820F5530h-820F55F0h (48 instructions)

//////////////////////////////////////////////////////
// Block at 820F55F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F55F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F55F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F55F0);
		  /* 820F55F0h */ case    0:  		/* mr R11, R23 */
		/* 820F55F0h case    0:*/		regs.R11 = regs.R23;
		/* 820F55F0h case    0:*/		return 0x820F55F4;
		  /* 820F55F4h */ case    1:  		/* cmplwi CR6, R26, 0 */
		/* 820F55F4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820F55F4h case    1:*/		return 0x820F55F8;
		  /* 820F55F8h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820F55F8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F5620;  }
		/* 820F55F8h case    2:*/		return 0x820F55FC;
		  /* 820F55FCh */ case    3:  		/* lwz R8, <#[R10 + 12]> */
		/* 820F55FCh case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F55FCh case    3:*/		return 0x820F5600;
		  /* 820F5600h */ case    4:  		/* mr R9, R28 */
		/* 820F5600h case    4:*/		regs.R9 = regs.R28;
		/* 820F5600h case    4:*/		return 0x820F5604;
		  /* 820F5604h */ case    5:  		/* lwz R5, <#[R9]> */
		/* 820F5604h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000000) );
		/* 820F5604h case    5:*/		return 0x820F5608;
		  /* 820F5608h */ case    6:  		/* cmplw CR6, R5, R8 */
		/* 820F5608h case    6:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R8);
		/* 820F5608h case    6:*/		return 0x820F560C;
		  /* 820F560Ch */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820F560Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820F5620;  }
		/* 820F560Ch case    7:*/		return 0x820F5610;
		  /* 820F5610h */ case    8:  		/* addi R11, R11, 1 */
		/* 820F5610h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820F5610h case    8:*/		return 0x820F5614;
		  /* 820F5614h */ case    9:  		/* addi R9, R9, 4 */
		/* 820F5614h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820F5614h case    9:*/		return 0x820F5618;
		  /* 820F5618h */ case   10:  		/* cmplw CR6, R11, R26 */
		/* 820F5618h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820F5618h case   10:*/		return 0x820F561C;
		  /* 820F561Ch */ case   11:  		/* bc 12, CR6_LT, -24 */
		/* 820F561Ch case   11:*/		if ( regs.CR[6].lt ) { return 0x820F5604;  }
		/* 820F561Ch case   11:*/		return 0x820F5620;
	}
	return 0x820F5620;
} // Block from 820F55F0h-820F5620h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820F5620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5620);
		  /* 820F5620h */ case    0:  		/* cmplw CR6, R11, R26 */
		/* 820F5620h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 820F5620h case    0:*/		return 0x820F5624;
		  /* 820F5624h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 820F5624h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820F5638;  }
		/* 820F5624h case    1:*/		return 0x820F5628;
		  /* 820F5628h */ case    2:  		/* lwz R9, <#[R10 + 12]> */
		/* 820F5628h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 820F5628h case    2:*/		return 0x820F562C;
		  /* 820F562Ch */ case    3:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 820F562Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 820F562Ch case    3:*/		return 0x820F5630;
		  /* 820F5630h */ case    4:  		/* addi R26, R26, 1 */
		/* 820F5630h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820F5630h case    4:*/		return 0x820F5634;
		  /* 820F5634h */ case    5:  		/* stwx R9, <#[R8 + R28]> */
		/* 820F5634h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R28 + 0x00000000) );
		/* 820F5634h case    5:*/		return 0x820F5638;
	}
	return 0x820F5638;
} // Block from 820F5620h-820F5638h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820F5638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5638);
		  /* 820F5638h */ case    0:  		/* lwz R9, <#[R10 + 16]> */
		/* 820F5638h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 820F5638h case    0:*/		return 0x820F563C;
		  /* 820F563Ch */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F563Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F563Ch case    1:*/		return 0x820F5640;
		  /* 820F5640h */ case    2:  		/* lfd FR0, <#[R10 + 32]> */
		/* 820F5640h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820F5640h case    2:*/		return 0x820F5644;
		  /* 820F5644h */ case    3:  		/* add R11, R11, R9 */
		/* 820F5644h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820F5644h case    3:*/		return 0x820F5648;
		  /* 820F5648h */ case    4:  		/* frsp FR0, FR0 */
		/* 820F5648h case    4:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820F5648h case    4:*/		return 0x820F564C;
		  /* 820F564Ch */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820F564Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820F564Ch case    5:*/		return 0x820F5650;
		  /* 820F5650h */ case    6:  		/* stfsx FR0, <#[R11 + R17]> */
		/* 820F5650h case    6:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + regs.R17 + 0x00000000) );
		/* 820F5650h case    6:*/		return 0x820F5654;
	}
	return 0x820F5654;
} // Block from 820F5638h-820F5654h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820F5654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5654);
		  /* 820F5654h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F5654h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F5654h case    0:*/		return 0x820F5658;
		  /* 820F5658h */ case    1:  		/* addi R6, R6, 1 */
		/* 820F5658h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820F5658h case    1:*/		return 0x820F565C;
		  /* 820F565Ch */ case    2:  		/* addi R7, R7, 4 */
		/* 820F565Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820F565Ch case    2:*/		return 0x820F5660;
		  /* 820F5660h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 820F5660h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820F5660h case    3:*/		return 0x820F5664;
		  /* 820F5664h */ case    4:  		/* bc 12, CR6_LT, -204 */
		/* 820F5664h case    4:*/		if ( regs.CR[6].lt ) { return 0x820F5598;  }
		/* 820F5664h case    4:*/		return 0x820F5668;
	}
	return 0x820F5668;
} // Block from 820F5654h-820F5668h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820F5668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5668);
		  /* 820F5668h */ case    0:  		/* mr R27, R23 */
		/* 820F5668h case    0:*/		regs.R27 = regs.R23;
		/* 820F5668h case    0:*/		return 0x820F566C;
		  /* 820F566Ch */ case    1:  		/* cmplwi CR6, R26, 0 */
		/* 820F566Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820F566Ch case    1:*/		return 0x820F5670;
		  /* 820F5670h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 820F5670h case    2:*/		if ( regs.CR[6].eq ) { return 0x820F56B0;  }
		/* 820F5670h case    2:*/		return 0x820F5674;
		  /* 820F5674h */ case    3:  		/* mr R29, R17 */
		/* 820F5674h case    3:*/		regs.R29 = regs.R17;
		/* 820F5674h case    3:*/		return 0x820F5678;
		  /* 820F5678h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 820F5678h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820F5678h case    4:*/		return 0x820F567C;
		  /* 820F567Ch */ case    5:  		/* mr R5, R29 */
		/* 820F567Ch case    5:*/		regs.R5 = regs.R29;
		/* 820F567Ch case    5:*/		return 0x820F5680;
		  /* 820F5680h */ case    6:  		/* mr R3, R31 */
		/* 820F5680h case    6:*/		regs.R3 = regs.R31;
		/* 820F5680h case    6:*/		return 0x820F5684;
		  /* 820F5684h */ case    7:  		/* lwz R4, <#[R28]> */
		/* 820F5684h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 820F5684h case    7:*/		return 0x820F5688;
		  /* 820F5688h */ case    8:  		/* lwz R11, <#[R11 + 60]> */
		/* 820F5688h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 820F5688h case    8:*/		return 0x820F568C;
		  /* 820F568Ch */ case    9:  		/* mtspr CTR, R11 */
		/* 820F568Ch case    9:*/		regs.CTR = regs.R11;
		/* 820F568Ch case    9:*/		return 0x820F5690;
		  /* 820F5690h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820F5690h case   10:*/		if ( 1 ) { regs.LR = 0x820F5694; return (uint32)regs.CTR; }
		/* 820F5690h case   10:*/		return 0x820F5694;
		  /* 820F5694h */ case   11:  		/* or. R30, R3, R3 */
		/* 820F5694h case   11:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820F5694h case   11:*/		return 0x820F5698;
		  /* 820F5698h */ case   12:  		/* bc 12, CR0_LT, 1660 */
		/* 820F5698h case   12:*/		if ( regs.CR[0].lt ) { return 0x820F5D14;  }
		/* 820F5698h case   12:*/		return 0x820F569C;
		  /* 820F569Ch */ case   13:  		/* addi R27, R27, 1 */
		/* 820F569Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820F569Ch case   13:*/		return 0x820F56A0;
		  /* 820F56A0h */ case   14:  		/* addi R29, R29, 16 */
		/* 820F56A0h case   14:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x10);
		/* 820F56A0h case   14:*/		return 0x820F56A4;
		  /* 820F56A4h */ case   15:  		/* addi R28, R28, 4 */
		/* 820F56A4h case   15:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820F56A4h case   15:*/		return 0x820F56A8;
		  /* 820F56A8h */ case   16:  		/* cmplw CR6, R27, R26 */
		/* 820F56A8h case   16:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R26);
		/* 820F56A8h case   16:*/		return 0x820F56AC;
		  /* 820F56ACh */ case   17:  		/* bc 12, CR6_LT, -52 */
		/* 820F56ACh case   17:*/		if ( regs.CR[6].lt ) { return 0x820F5678;  }
		/* 820F56ACh case   17:*/		return 0x820F56B0;
	}
	return 0x820F56B0;
} // Block from 820F5668h-820F56B0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820F56B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F56B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F56B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F56B0);
		  /* 820F56B0h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820F56B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820F56B0h case    0:*/		return 0x820F56B4;
		  /* 820F56B4h */ case    1:  		/* mr R30, R23 */
		/* 820F56B4h case    1:*/		regs.R30 = regs.R23;
		/* 820F56B4h case    1:*/		return 0x820F56B8;
		  /* 820F56B8h */ case    2:  		/* mr R26, R23 */
		/* 820F56B8h case    2:*/		regs.R26 = regs.R23;
		/* 820F56B8h case    2:*/		return 0x820F56BC;
		  /* 820F56BCh */ case    3:  		/* mr R6, R23 */
		/* 820F56BCh case    3:*/		regs.R6 = regs.R23;
		/* 820F56BCh case    3:*/		return 0x820F56C0;
		  /* 820F56C0h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820F56C0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820F56C0h case    4:*/		return 0x820F56C4;
		  /* 820F56C4h */ case    5:  		/* bc 4, CR6_GT, 80 */
		/* 820F56C4h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820F5714;  }
		/* 820F56C4h case    5:*/		return 0x820F56C8;
		  /* 820F56C8h */ case    6:  		/* lwz R9, <#[R31 + 20]> */
		/* 820F56C8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820F56C8h case    6:*/		return 0x820F56CC;
		  /* 820F56CCh */ case    7:  		/* mr R11, R23 */
		/* 820F56CCh case    7:*/		regs.R11 = regs.R23;
		/* 820F56CCh case    7:*/		return 0x820F56D0;
		  /* 820F56D0h */ case    8:  		/* lwz R8, <#[R31 + 16]> */
		/* 820F56D0h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 820F56D0h case    8:*/		return 0x820F56D4;
		  /* 820F56D4h */ case    9:  		/* lwz R7, <#[R31 + 8]> */
		/* 820F56D4h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 820F56D4h case    9:*/		return 0x820F56D8;
		  /* 820F56D8h */ case   10:  		/* lwzx R10, <#[R9 + R11]> */
		/* 820F56D8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820F56D8h case   10:*/		return 0x820F56DC;
		  /* 820F56DCh */ case   11:  		/* lwz R5, <#[R10 + 4]> */
		/* 820F56DCh case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000004) );
		/* 820F56DCh case   11:*/		return 0x820F56E0;
		  /* 820F56E0h */ case   12:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 820F56E0h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 820F56E0h case   12:*/		return 0x820F56E4;
		  /* 820F56E4h */ case   13:  		/* lwzx R5, <#[R5 + R8]> */
		/* 820F56E4h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 820F56E4h case   13:*/		return 0x820F56E8;
		  /* 820F56E8h */ case   14:  		/* lwz R5, <#[R5 + 4]> */
		/* 820F56E8h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000004) );
		/* 820F56E8h case   14:*/		return 0x820F56EC;
		  /* 820F56ECh */ case   15:  		/* rlwinm. R5, R5, 0, 23, 23 */
		/* 820F56ECh case   15:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R5,regs.R5);
		/* 820F56ECh case   15:*/		return 0x820F56F0;
		  /* 820F56F0h */ case   16:  		/* bc 12, CR0_EQ, 20 */
		/* 820F56F0h case   16:*/		if ( regs.CR[0].eq ) { return 0x820F5704;  }
		/* 820F56F0h case   16:*/		return 0x820F56F4;
		  /* 820F56F4h */ case   17:  		/* lwz R10, <#[R10 + 8]> */
		/* 820F56F4h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820F56F4h case   17:*/		return 0x820F56F8;
		  /* 820F56F8h */ case   18:  		/* cmpwi CR6, R10, -1 */
		/* 820F56F8h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820F56F8h case   18:*/		return 0x820F56FC;
		  /* 820F56FCh */ case   19:  		/* bc 4, CR6_EQ, 8 */
		/* 820F56FCh case   19:*/		if ( !regs.CR[6].eq ) { return 0x820F5704;  }
		/* 820F56FCh case   19:*/		return 0x820F5700;
		  /* 820F5700h */ case   20:  		/* addi R30, R30, 1 */
		/* 820F5700h case   20:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820F5700h case   20:*/		return 0x820F5704;
	}
	return 0x820F5704;
} // Block from 820F56B0h-820F5704h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820F5704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820F5704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820F5704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820F5704);
		  /* 820F5704h */ case    0:  		/* addi R6, R6, 1 */
		/* 820F5704h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820F5704h case    0:*/		return 0x820F5708;
		  /* 820F5708h */ case    1:  		/* addi R11, R11, 4 */
		/* 820F5708h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820F5708h case    1:*/		return 0x820F570C;
		  /* 820F570Ch */ case    2:  		/* cmplw CR6, R6, R7 */
		/* 820F570Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 820F570Ch case    2:*/		return 0x820F5710;
		  /* 820F5710h */ case    3:  		/* bc 12, CR6_LT, -56 */
		/* 820F5710h case    3:*/		if ( regs.CR[6].lt ) { return 0x820F56D8;  }
		/* 820F5710h case    3:*/		return 0x820F5714;
	}
	return 0x820F5714;
} // Block from 820F5704h-820F5714h (4 instructions)

