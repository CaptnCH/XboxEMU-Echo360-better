#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 820A0124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0124);
		  /* 820A0124h */ case    0:  		/* li R10, 0 */
		/* 820A0124h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A0124h case    0:*/		return 0x820A0128;
	}
	return 0x820A0128;
} // Block from 820A0124h-820A0128h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0128);
		  /* 820A0128h */ case    0:  		/* stw R10, <#[R31 + 1656]> */
		/* 820A0128h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000678) );
		/* 820A0128h case    0:*/		return 0x820A012C;
		  /* 820A012Ch */ case    1:  		/* li R3, 0 */
		/* 820A012Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A012Ch case    1:*/		return 0x820A0130;
		  /* 820A0130h */ case    2:  		/* stw R9, <#[R11]> */
		/* 820A0130h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0130h case    2:*/		return 0x820A0134;
		  /* 820A0134h */ case    3:  		/* stw R9, <#[R11 + 8]> */
		/* 820A0134h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820A0134h case    3:*/		return 0x820A0138;
	}
	return 0x820A0138;
} // Block from 820A0128h-820A0138h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0138);
		  /* 820A0138h */ case    0:  		/* addi R1, R1, 96 */
		/* 820A0138h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A0138h case    0:*/		return 0x820A013C;
		  /* 820A013Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A013Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A013Ch case    1:*/		return 0x820A0140;
		  /* 820A0140h */ case    2:  		/* mtspr LR, R12 */
		/* 820A0140h case    2:*/		regs.LR = regs.R12;
		/* 820A0140h case    2:*/		return 0x820A0144;
		  /* 820A0144h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A0144h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A0144h case    3:*/		return 0x820A0148;
		  /* 820A0148h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A0148h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A0148h case    4:*/		return 0x820A014C;
	}
	return 0x820A014C;
} // Block from 820A0138h-820A014Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A014Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A014C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A014C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A014C);
		  /* 820A014Ch */ case    0:  		/* nop */
		/* 820A014Ch case    0:*/		cpu::op::nop();
		/* 820A014Ch case    0:*/		return 0x820A0150;
	}
	return 0x820A0150;
} // Block from 820A014Ch-820A0150h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0150);
		  /* 820A0150h */ case    0:  		/* mfspr R12, LR */
		/* 820A0150h case    0:*/		regs.R12 = regs.LR;
		/* 820A0150h case    0:*/		return 0x820A0154;
		  /* 820A0154h */ case    1:  		/* bl -61184 */
		/* 820A0154h case    1:*/		regs.LR = 0x820A0158; return 0x82091254;
		/* 820A0154h case    1:*/		return 0x820A0158;
		  /* 820A0158h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820A0158h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820A0158h case    2:*/		return 0x820A015C;
		  /* 820A015Ch */ case    3:  		/* addi R30, R3, 2216 */
		/* 820A015Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x8A8);
		/* 820A015Ch case    3:*/		return 0x820A0160;
		  /* 820A0160h */ case    4:  		/* lwz R4, <#[R3 + 2256]> */
		/* 820A0160h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x000008D0) );
		/* 820A0160h case    4:*/		return 0x820A0164;
		  /* 820A0164h */ case    5:  		/* mr R29, R3 */
		/* 820A0164h case    5:*/		regs.R29 = regs.R3;
		/* 820A0164h case    5:*/		return 0x820A0168;
		  /* 820A0168h */ case    6:  		/* lwz R3, <#[R3 + 2204]> */
		/* 820A0168h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000089C) );
		/* 820A0168h case    6:*/		return 0x820A016C;
		  /* 820A016Ch */ case    7:  		/* mr R5, R30 */
		/* 820A016Ch case    7:*/		regs.R5 = regs.R30;
		/* 820A016Ch case    7:*/		return 0x820A0170;
		  /* 820A0170h */ case    8:  		/* bl 32904 */
		/* 820A0170h case    8:*/		regs.LR = 0x820A0174; return 0x820A81F8;
		/* 820A0170h case    8:*/		return 0x820A0174;
		  /* 820A0174h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820A0174h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A0174h case    9:*/		return 0x820A0178;
		  /* 820A0178h */ case   10:  		/* bc 12, CR0_LT, 448 */
		/* 820A0178h case   10:*/		if ( regs.CR[0].lt ) { return 0x820A0338;  }
		/* 820A0178h case   10:*/		return 0x820A017C;
		  /* 820A017Ch */ case   11:  		/* lwz R8, <#[R30]> */
		/* 820A017Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 820A017Ch case   11:*/		return 0x820A0180;
		  /* 820A0180h */ case   12:  		/* li R27, 0 */
		/* 820A0180h case   12:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820A0180h case   12:*/		return 0x820A0184;
		  /* 820A0184h */ case   13:  		/* cmpwi CR6, R8, 1 */
		/* 820A0184h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820A0184h case   13:*/		return 0x820A0188;
		  /* 820A0188h */ case   14:  		/* bc 4, CR6_EQ, 396 */
		/* 820A0188h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820A0314;  }
		/* 820A0188h case   14:*/		return 0x820A018C;
		  /* 820A018Ch */ case   15:  		/* addi R31, R29, 2224 */
		/* 820A018Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R29,0x8B0);
		/* 820A018Ch case   15:*/		return 0x820A0190;
		  /* 820A0190h */ case   16:  		/* lis R10, -32255 */
		/* 820A0190h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A0190h case   16:*/		return 0x820A0194;
		  /* 820A0194h */ case   17:  		/* mr R11, R31 */
		/* 820A0194h case   17:*/		regs.R11 = regs.R31;
		/* 820A0194h case   17:*/		return 0x820A0198;
		  /* 820A0198h */ case   18:  		/* addi R10, R10, -10828 */
		/* 820A0198h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD5B4);
		/* 820A0198h case   18:*/		return 0x820A019C;
		  /* 820A019Ch */ case   19:  		/* lbz R9, <#[R11]> */
		/* 820A019Ch case   19:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A019Ch case   19:*/		return 0x820A01A0;
		  /* 820A01A0h */ case   20:  		/* lbz R7, <#[R10]> */
		/* 820A01A0h case   20:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A01A0h case   20:*/		return 0x820A01A4;
		  /* 820A01A4h */ case   21:  		/* cmpwi CR0, R9, 0 */
		/* 820A01A4h case   21:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A01A4h case   21:*/		return 0x820A01A8;
		  /* 820A01A8h */ case   22:  		/* subf R9, R7, R9 */
		/* 820A01A8h case   22:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A01A8h case   22:*/		return 0x820A01AC;
		  /* 820A01ACh */ case   23:  		/* bc 12, CR0_EQ, 20 */
		/* 820A01ACh case   23:*/		if ( regs.CR[0].eq ) { return 0x820A01C0;  }
		/* 820A01ACh case   23:*/		return 0x820A01B0;
		  /* 820A01B0h */ case   24:  		/* addi R11, R11, 1 */
		/* 820A01B0h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A01B0h case   24:*/		return 0x820A01B4;
		  /* 820A01B4h */ case   25:  		/* addi R10, R10, 1 */
		/* 820A01B4h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A01B4h case   25:*/		return 0x820A01B8;
		  /* 820A01B8h */ case   26:  		/* cmpwi CR6, R9, 0 */
		/* 820A01B8h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A01B8h case   26:*/		return 0x820A01BC;
		  /* 820A01BCh */ case   27:  		/* bc 12, CR6_EQ, -32 */
		/* 820A01BCh case   27:*/		if ( regs.CR[6].eq ) { return 0x820A019C;  }
		/* 820A01BCh case   27:*/		return 0x820A01C0;
	}
	return 0x820A01C0;
} // Block from 820A0150h-820A01C0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820A01C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A01C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A01C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A01C0);
		  /* 820A01C0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A01C0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A01C0h case    0:*/		return 0x820A01C4;
		  /* 820A01C4h */ case    1:  		/* bc 4, CR0_EQ, 336 */
		/* 820A01C4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A0314;  }
		/* 820A01C4h case    1:*/		return 0x820A01C8;
		  /* 820A01C8h */ case    2:  		/* mr R5, R30 */
		/* 820A01C8h case    2:*/		regs.R5 = regs.R30;
		/* 820A01C8h case    2:*/		return 0x820A01CC;
		  /* 820A01CCh */ case    3:  		/* lwz R4, <#[R29 + 2256]> */
		/* 820A01CCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000008D0) );
		/* 820A01CCh case    3:*/		return 0x820A01D0;
		  /* 820A01D0h */ case    4:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A01D0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A01D0h case    4:*/		return 0x820A01D4;
		  /* 820A01D4h */ case    5:  		/* bl 32804 */
		/* 820A01D4h case    5:*/		regs.LR = 0x820A01D8; return 0x820A81F8;
		/* 820A01D4h case    5:*/		return 0x820A01D8;
		  /* 820A01D8h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820A01D8h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A01D8h case    6:*/		return 0x820A01DC;
		  /* 820A01DCh */ case    7:  		/* bc 12, CR0_LT, 348 */
		/* 820A01DCh case    7:*/		if ( regs.CR[0].lt ) { return 0x820A0338;  }
		/* 820A01DCh case    7:*/		return 0x820A01E0;
		  /* 820A01E0h */ case    8:  		/* lwz R11, <#[R30]> */
		/* 820A01E0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A01E0h case    8:*/		return 0x820A01E4;
		  /* 820A01E4h */ case    9:  		/* cmpwi CR6, R11, 11 */
		/* 820A01E4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820A01E4h case    9:*/		return 0x820A01E8;
		  /* 820A01E8h */ case   10:  		/* bc 4, CR6_EQ, 36 */
		/* 820A01E8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820A020C;  }
		/* 820A01E8h case   10:*/		return 0x820A01EC;
		  /* 820A01ECh */ case   11:  		/* mr R5, R30 */
		/* 820A01ECh case   11:*/		regs.R5 = regs.R30;
		/* 820A01ECh case   11:*/		return 0x820A01F0;
		  /* 820A01F0h */ case   12:  		/* lwz R28, <#[R31]> */
		/* 820A01F0h case   12:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 820A01F0h case   12:*/		return 0x820A01F4;
		  /* 820A01F4h */ case   13:  		/* lwz R4, <#[R29 + 2256]> */
		/* 820A01F4h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000008D0) );
		/* 820A01F4h case   13:*/		return 0x820A01F8;
		  /* 820A01F8h */ case   14:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A01F8h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A01F8h case   14:*/		return 0x820A01FC;
		  /* 820A01FCh */ case   15:  		/* bl 32764 */
		/* 820A01FCh case   15:*/		regs.LR = 0x820A0200; return 0x820A81F8;
		/* 820A01FCh case   15:*/		return 0x820A0200;
		  /* 820A0200h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820A0200h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A0200h case   16:*/		return 0x820A0204;
		  /* 820A0204h */ case   17:  		/* bc 12, CR0_LT, 308 */
		/* 820A0204h case   17:*/		if ( regs.CR[0].lt ) { return 0x820A0338;  }
		/* 820A0204h case   17:*/		return 0x820A0208;
		  /* 820A0208h */ case   18:  		/* b 8 */
		/* 820A0208h case   18:*/		return 0x820A0210;
		/* 820A0208h case   18:*/		return 0x820A020C;
	}
	return 0x820A020C;
} // Block from 820A01C0h-820A020Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A020Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A020C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A020C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A020C);
		  /* 820A020Ch */ case    0:  		/* mr R28, R27 */
		/* 820A020Ch case    0:*/		regs.R28 = regs.R27;
		/* 820A020Ch case    0:*/		return 0x820A0210;
	}
	return 0x820A0210;
} // Block from 820A020Ch-820A0210h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0210);
		  /* 820A0210h */ case    0:  		/* lwz R8, <#[R30]> */
		/* 820A0210h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 820A0210h case    0:*/		return 0x820A0214;
		  /* 820A0214h */ case    1:  		/* cmpwi CR6, R8, 1 */
		/* 820A0214h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820A0214h case    1:*/		return 0x820A0218;
		  /* 820A0218h */ case    2:  		/* bc 4, CR6_EQ, 252 */
		/* 820A0218h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A0314;  }
		/* 820A0218h case    2:*/		return 0x820A021C;
		  /* 820A021Ch */ case    3:  		/* lis R10, -32255 */
		/* 820A021Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A021Ch case    3:*/		return 0x820A0220;
		  /* 820A0220h */ case    4:  		/* mr R11, R31 */
		/* 820A0220h case    4:*/		regs.R11 = regs.R31;
		/* 820A0220h case    4:*/		return 0x820A0224;
		  /* 820A0224h */ case    5:  		/* addi R10, R10, -10832 */
		/* 820A0224h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD5B0);
		/* 820A0224h case    5:*/		return 0x820A0228;
		  /* 820A0228h */ case    6:  		/* lbz R9, <#[R11]> */
		/* 820A0228h case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0228h case    6:*/		return 0x820A022C;
		  /* 820A022Ch */ case    7:  		/* lbz R7, <#[R10]> */
		/* 820A022Ch case    7:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A022Ch case    7:*/		return 0x820A0230;
		  /* 820A0230h */ case    8:  		/* cmpwi CR0, R9, 0 */
		/* 820A0230h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0230h case    8:*/		return 0x820A0234;
		  /* 820A0234h */ case    9:  		/* subf R9, R7, R9 */
		/* 820A0234h case    9:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A0234h case    9:*/		return 0x820A0238;
		  /* 820A0238h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 820A0238h case   10:*/		if ( regs.CR[0].eq ) { return 0x820A024C;  }
		/* 820A0238h case   10:*/		return 0x820A023C;
		  /* 820A023Ch */ case   11:  		/* addi R11, R11, 1 */
		/* 820A023Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A023Ch case   11:*/		return 0x820A0240;
		  /* 820A0240h */ case   12:  		/* addi R10, R10, 1 */
		/* 820A0240h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0240h case   12:*/		return 0x820A0244;
		  /* 820A0244h */ case   13:  		/* cmpwi CR6, R9, 0 */
		/* 820A0244h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0244h case   13:*/		return 0x820A0248;
		  /* 820A0248h */ case   14:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0248h case   14:*/		if ( regs.CR[6].eq ) { return 0x820A0228;  }
		/* 820A0248h case   14:*/		return 0x820A024C;
	}
	return 0x820A024C;
} // Block from 820A0210h-820A024Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A024Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A024C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A024C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A024C);
		  /* 820A024Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A024Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A024Ch case    0:*/		return 0x820A0250;
		  /* 820A0250h */ case    1:  		/* bc 4, CR0_EQ, 196 */
		/* 820A0250h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A0314;  }
		/* 820A0250h case    1:*/		return 0x820A0254;
		  /* 820A0254h */ case    2:  		/* mr R5, R30 */
		/* 820A0254h case    2:*/		regs.R5 = regs.R30;
		/* 820A0254h case    2:*/		return 0x820A0258;
		  /* 820A0258h */ case    3:  		/* lwz R4, <#[R29 + 2256]> */
		/* 820A0258h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000008D0) );
		/* 820A0258h case    3:*/		return 0x820A025C;
		  /* 820A025Ch */ case    4:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A025Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A025Ch case    4:*/		return 0x820A0260;
		  /* 820A0260h */ case    5:  		/* bl 32664 */
		/* 820A0260h case    5:*/		regs.LR = 0x820A0264; return 0x820A81F8;
		/* 820A0260h case    5:*/		return 0x820A0264;
		  /* 820A0264h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820A0264h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A0264h case    6:*/		return 0x820A0268;
		  /* 820A0268h */ case    7:  		/* bc 12, CR0_LT, 208 */
		/* 820A0268h case    7:*/		if ( regs.CR[0].lt ) { return 0x820A0338;  }
		/* 820A0268h case    7:*/		return 0x820A026C;
		  /* 820A026Ch */ case    8:  		/* lwz R8, <#[R30]> */
		/* 820A026Ch case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 820A026Ch case    8:*/		return 0x820A0270;
	}
	return 0x820A0270;
} // Block from 820A024Ch-820A0270h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A0270h
// Function '?D3DXCompileShader_Common@@YAJPAVPreProcessorInitializer@D3DXShader@@PBDPAPBDKPAPAUID3DXBuffer@@3PAPAUID3DXConstantTable@@PAU_D3DXSHADER_COMPILE_PARAMETERSA@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0270);
		  /* 820A0270h */ case    0:  		/* cmpwi CR6, R8, 16 */
		/* 820A0270h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000010);
		/* 820A0270h case    0:*/		return 0x820A0274;
		  /* 820A0274h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0274h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A0280;  }
		/* 820A0274h case    1:*/		return 0x820A0278;
		  /* 820A0278h */ case    2:  		/* cmpwi CR6, R8, 17 */
		/* 820A0278h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000011);
		/* 820A0278h case    2:*/		return 0x820A027C;
		  /* 820A027Ch */ case    3:  		/* bc 4, CR6_EQ, 152 */
		/* 820A027Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A0314;  }
		/* 820A027Ch case    3:*/		return 0x820A0280;
	}
	return 0x820A0280;
} // Block from 820A0270h-820A0280h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0280);
		  /* 820A0280h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820A0280h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820A0280h case    0:*/		return 0x820A0284;
		  /* 820A0284h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820A0284h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A0290;  }
		/* 820A0284h case    1:*/		return 0x820A0288;
		  /* 820A0288h */ case    2:  		/* stw R27, <#[R29 + 64]> */
		/* 820A0288h case    2:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R29 + 0x00000040) );
		/* 820A0288h case    2:*/		return 0x820A028C;
		  /* 820A028Ch */ case    3:  		/* b 168 */
		/* 820A028Ch case    3:*/		return 0x820A0334;
		/* 820A028Ch case    3:*/		return 0x820A0290;
	}
	return 0x820A0290;
} // Block from 820A0280h-820A0290h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0290);
		  /* 820A0290h */ case    0:  		/* lis R10, -32255 */
		/* 820A0290h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A0290h case    0:*/		return 0x820A0294;
		  /* 820A0294h */ case    1:  		/* mr R11, R28 */
		/* 820A0294h case    1:*/		regs.R11 = regs.R28;
		/* 820A0294h case    1:*/		return 0x820A0298;
		  /* 820A0298h */ case    2:  		/* addi R10, R10, -10844 */
		/* 820A0298h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD5A4);
		/* 820A0298h case    2:*/		return 0x820A029C;
		  /* 820A029Ch */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A029Ch case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A029Ch case    3:*/		return 0x820A02A0;
		  /* 820A02A0h */ case    4:  		/* lbz R7, <#[R10]> */
		/* 820A02A0h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A02A0h case    4:*/		return 0x820A02A4;
		  /* 820A02A4h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A02A4h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A02A4h case    5:*/		return 0x820A02A8;
		  /* 820A02A8h */ case    6:  		/* subf R9, R7, R9 */
		/* 820A02A8h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A02A8h case    6:*/		return 0x820A02AC;
		  /* 820A02ACh */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A02ACh case    7:*/		if ( regs.CR[0].eq ) { return 0x820A02C0;  }
		/* 820A02ACh case    7:*/		return 0x820A02B0;
		  /* 820A02B0h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A02B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A02B0h case    8:*/		return 0x820A02B4;
		  /* 820A02B4h */ case    9:  		/* addi R10, R10, 1 */
		/* 820A02B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A02B4h case    9:*/		return 0x820A02B8;
		  /* 820A02B8h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A02B8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A02B8h case   10:*/		return 0x820A02BC;
		  /* 820A02BCh */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A02BCh case   11:*/		if ( regs.CR[6].eq ) { return 0x820A029C;  }
		/* 820A02BCh case   11:*/		return 0x820A02C0;
	}
	return 0x820A02C0;
} // Block from 820A0290h-820A02C0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A02C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A02C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A02C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A02C0);
		  /* 820A02C0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A02C0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A02C0h case    0:*/		return 0x820A02C4;
		  /* 820A02C4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A02C4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A02D0;  }
		/* 820A02C4h case    1:*/		return 0x820A02C8;
		  /* 820A02C8h */ case    2:  		/* li R11, 1024 */
		/* 820A02C8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x400);
		/* 820A02C8h case    2:*/		return 0x820A02CC;
		  /* 820A02CCh */ case    3:  		/* b 64 */
		/* 820A02CCh case    3:*/		return 0x820A030C;
		/* 820A02CCh case    3:*/		return 0x820A02D0;
	}
	return 0x820A02D0;
} // Block from 820A02C0h-820A02D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A02D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A02D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A02D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A02D0);
		  /* 820A02D0h */ case    0:  		/* lis R10, -32255 */
		/* 820A02D0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A02D0h case    0:*/		return 0x820A02D4;
		  /* 820A02D4h */ case    1:  		/* mr R11, R28 */
		/* 820A02D4h case    1:*/		regs.R11 = regs.R28;
		/* 820A02D4h case    1:*/		return 0x820A02D8;
		  /* 820A02D8h */ case    2:  		/* addi R10, R10, -10860 */
		/* 820A02D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD594);
		/* 820A02D8h case    2:*/		return 0x820A02DC;
		  /* 820A02DCh */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A02DCh case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A02DCh case    3:*/		return 0x820A02E0;
		  /* 820A02E0h */ case    4:  		/* lbz R7, <#[R10]> */
		/* 820A02E0h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A02E0h case    4:*/		return 0x820A02E4;
		  /* 820A02E4h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A02E4h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A02E4h case    5:*/		return 0x820A02E8;
	}
	return 0x820A02E8;
} // Block from 820A02D0h-820A02E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A02E8h
// Function '?D3DXCompileShader_Imp@@YAJPAVPreProcessorInitializer@D3DXShader@@PBD1KPAPAUID3DXBuffer@@2PAPAUID3DXConstantTable@@PAU_D3DXSHADER_COMPILE_PARAMETERSA@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A02E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A02E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A02E8);
		  /* 820A02E8h */ case    0:  		/* subf R9, R7, R9 */
		/* 820A02E8h case    0:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A02E8h case    0:*/		return 0x820A02EC;
		  /* 820A02ECh */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820A02ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x820A0300;  }
		/* 820A02ECh case    1:*/		return 0x820A02F0;
		  /* 820A02F0h */ case    2:  		/* addi R11, R11, 1 */
		/* 820A02F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A02F0h case    2:*/		return 0x820A02F4;
		  /* 820A02F4h */ case    3:  		/* addi R10, R10, 1 */
		/* 820A02F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A02F4h case    3:*/		return 0x820A02F8;
		  /* 820A02F8h */ case    4:  		/* cmpwi CR6, R9, 0 */
		/* 820A02F8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A02F8h case    4:*/		return 0x820A02FC;
		  /* 820A02FCh */ case    5:  		/* bc 12, CR6_EQ, -32 */
		/* 820A02FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820A02DC;  }
		/* 820A02FCh case    5:*/		return 0x820A0300;
	}
	return 0x820A0300;
} // Block from 820A02E8h-820A0300h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A0300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0300);
		  /* 820A0300h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0300h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0300h case    0:*/		return 0x820A0304;
		  /* 820A0304h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A0304h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A0314;  }
		/* 820A0304h case    1:*/		return 0x820A0308;
		  /* 820A0308h */ case    2:  		/* li R11, 2048 */
		/* 820A0308h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x800);
		/* 820A0308h case    2:*/		return 0x820A030C;
	}
	return 0x820A030C;
} // Block from 820A0300h-820A030Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A030Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A030C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A030C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A030C);
		  /* 820A030Ch */ case    0:  		/* stw R11, <#[R29 + 64]> */
		/* 820A030Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000040) );
		/* 820A030Ch case    0:*/		return 0x820A0310;
		  /* 820A0310h */ case    1:  		/* b 36 */
		/* 820A0310h case    1:*/		return 0x820A0334;
		/* 820A0310h case    1:*/		return 0x820A0314;
	}
	return 0x820A0314;
} // Block from 820A030Ch-820A0314h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0314);
		  /* 820A0314h */ case    0:  		/* cmpwi CR6, R8, 16 */
		/* 820A0314h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000010);
		/* 820A0314h case    0:*/		return 0x820A0318;
		  /* 820A0318h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820A0318h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A0330;  }
		/* 820A0318h case    1:*/		return 0x820A031C;
		  /* 820A031Ch */ case    2:  		/* cmpwi CR6, R8, 17 */
		/* 820A031Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000011);
		/* 820A031Ch case    2:*/		return 0x820A0320;
		  /* 820A0320h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 820A0320h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A0330;  }
		/* 820A0320h case    3:*/		return 0x820A0324;
		  /* 820A0324h */ case    4:  		/* li R4, 0 */
		/* 820A0324h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A0324h case    4:*/		return 0x820A0328;
		  /* 820A0328h */ case    5:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A0328h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A0328h case    5:*/		return 0x820A032C;
		  /* 820A032Ch */ case    6:  		/* bl 29236 */
		/* 820A032Ch case    6:*/		regs.LR = 0x820A0330; return 0x820A7560;
		/* 820A032Ch case    6:*/		return 0x820A0330;
	}
	return 0x820A0330;
} // Block from 820A0314h-820A0330h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A0330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0330);
		  /* 820A0330h */ case    0:  		/* stw R27, <#[R29 + 2252]> */
		/* 820A0330h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R29 + 0x000008CC) );
		/* 820A0330h case    0:*/		return 0x820A0334;
	}
	return 0x820A0334;
} // Block from 820A0330h-820A0334h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0334);
		  /* 820A0334h */ case    0:  		/* mr R3, R27 */
		/* 820A0334h case    0:*/		regs.R3 = regs.R27;
		/* 820A0334h case    0:*/		return 0x820A0338;
	}
	return 0x820A0338;
} // Block from 820A0334h-820A0338h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0338);
		  /* 820A0338h */ case    0:  		/* li R11, 1 */
		/* 820A0338h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A0338h case    0:*/		return 0x820A033C;
		  /* 820A033Ch */ case    1:  		/* stw R11, <#[R29 + 1636]> */
		/* 820A033Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000664) );
		/* 820A033Ch case    1:*/		return 0x820A0340;
		  /* 820A0340h */ case    2:  		/* addi R1, R1, 128 */
		/* 820A0340h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820A0340h case    2:*/		return 0x820A0344;
		  /* 820A0344h */ case    3:  		/* b -61600 */
		/* 820A0344h case    3:*/		return 0x820912A4;
		/* 820A0344h case    3:*/		return 0x820A0348;
	}
	return 0x820A0348;
} // Block from 820A0338h-820A0348h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0348);
		  /* 820A0348h */ case    0:  		/* mfspr R12, LR */
		/* 820A0348h case    0:*/		regs.R12 = regs.LR;
		/* 820A0348h case    0:*/		return 0x820A034C;
		  /* 820A034Ch */ case    1:  		/* bl -61740 */
		/* 820A034Ch case    1:*/		regs.LR = 0x820A0350; return 0x82091220;
		/* 820A034Ch case    1:*/		return 0x820A0350;
		  /* 820A0350h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 820A0350h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 820A0350h case    2:*/		return 0x820A0354;
		  /* 820A0354h */ case    3:  		/* addi R24, R3, 2216 */
		/* 820A0354h case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R3,0x8A8);
		/* 820A0354h case    3:*/		return 0x820A0358;
		  /* 820A0358h */ case    4:  		/* lwz R4, <#[R3 + 2256]> */
		/* 820A0358h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x000008D0) );
		/* 820A0358h case    4:*/		return 0x820A035C;
		  /* 820A035Ch */ case    5:  		/* li R30, 0 */
		/* 820A035Ch case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A035Ch case    5:*/		return 0x820A0360;
		  /* 820A0360h */ case    6:  		/* mr R5, R24 */
		/* 820A0360h case    6:*/		regs.R5 = regs.R24;
		/* 820A0360h case    6:*/		return 0x820A0364;
		  /* 820A0364h */ case    7:  		/* mr R26, R3 */
		/* 820A0364h case    7:*/		regs.R26 = regs.R3;
		/* 820A0364h case    7:*/		return 0x820A0368;
		  /* 820A0368h */ case    8:  		/* lwz R3, <#[R3 + 2204]> */
		/* 820A0368h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000089C) );
		/* 820A0368h case    8:*/		return 0x820A036C;
		  /* 820A036Ch */ case    9:  		/* stw R30, <#[R1 + 80]> */
		/* 820A036Ch case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 820A036Ch case    9:*/		return 0x820A0370;
		  /* 820A0370h */ case   10:  		/* li R14, 0 */
		/* 820A0370h case   10:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 820A0370h case   10:*/		return 0x820A0374;
		  /* 820A0374h */ case   11:  		/* bl 32388 */
		/* 820A0374h case   11:*/		regs.LR = 0x820A0378; return 0x820A81F8;
		/* 820A0374h case   11:*/		return 0x820A0378;
		  /* 820A0378h */ case   12:  		/* or. R31, R3, R3 */
		/* 820A0378h case   12:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A0378h case   12:*/		return 0x820A037C;
		  /* 820A037Ch */ case   13:  		/* bc 12, CR0_LT, 1184 */
		/* 820A037Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x820A081C;  }
		/* 820A037Ch case   13:*/		return 0x820A0380;
		  /* 820A0380h */ case   14:  		/* lwz R7, <#[R24]> */
		/* 820A0380h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R24 + 0x00000000) );
		/* 820A0380h case   14:*/		return 0x820A0384;
		  /* 820A0384h */ case   15:  		/* cmpwi CR6, R7, 1 */
		/* 820A0384h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000001);
		/* 820A0384h case   15:*/		return 0x820A0388;
		  /* 820A0388h */ case   16:  		/* bc 4, CR6_EQ, 1136 */
		/* 820A0388h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820A07F8;  }
		/* 820A0388h case   16:*/		return 0x820A038C;
		  /* 820A038Ch */ case   17:  		/* addi R27, R26, 2224 */
		/* 820A038Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R26,0x8B0);
		/* 820A038Ch case   17:*/		return 0x820A0390;
		  /* 820A0390h */ case   18:  		/* lis R10, -32255 */
		/* 820A0390h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A0390h case   18:*/		return 0x820A0394;
		  /* 820A0394h */ case   19:  		/* mr R11, R27 */
		/* 820A0394h case   19:*/		regs.R11 = regs.R27;
		/* 820A0394h case   19:*/		return 0x820A0398;
		  /* 820A0398h */ case   20:  		/* addi R10, R10, -10828 */
		/* 820A0398h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD5B4);
		/* 820A0398h case   20:*/		return 0x820A039C;
		  /* 820A039Ch */ case   21:  		/* lbz R9, <#[R11]> */
		/* 820A039Ch case   21:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A039Ch case   21:*/		return 0x820A03A0;
		  /* 820A03A0h */ case   22:  		/* lbz R8, <#[R10]> */
		/* 820A03A0h case   22:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A03A0h case   22:*/		return 0x820A03A4;
		  /* 820A03A4h */ case   23:  		/* cmpwi CR0, R9, 0 */
		/* 820A03A4h case   23:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A03A4h case   23:*/		return 0x820A03A8;
		  /* 820A03A8h */ case   24:  		/* subf R9, R8, R9 */
		/* 820A03A8h case   24:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A03A8h case   24:*/		return 0x820A03AC;
		  /* 820A03ACh */ case   25:  		/* bc 12, CR0_EQ, 20 */
		/* 820A03ACh case   25:*/		if ( regs.CR[0].eq ) { return 0x820A03C0;  }
		/* 820A03ACh case   25:*/		return 0x820A03B0;
		  /* 820A03B0h */ case   26:  		/* addi R11, R11, 1 */
		/* 820A03B0h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A03B0h case   26:*/		return 0x820A03B4;
		  /* 820A03B4h */ case   27:  		/* addi R10, R10, 1 */
		/* 820A03B4h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A03B4h case   27:*/		return 0x820A03B8;
		  /* 820A03B8h */ case   28:  		/* cmpwi CR6, R9, 0 */
		/* 820A03B8h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A03B8h case   28:*/		return 0x820A03BC;
		  /* 820A03BCh */ case   29:  		/* bc 12, CR6_EQ, -32 */
		/* 820A03BCh case   29:*/		if ( regs.CR[6].eq ) { return 0x820A039C;  }
		/* 820A03BCh case   29:*/		return 0x820A03C0;
	}
	return 0x820A03C0;
} // Block from 820A0348h-820A03C0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820A03C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A03C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A03C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A03C0);
		  /* 820A03C0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A03C0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A03C0h case    0:*/		return 0x820A03C4;
		  /* 820A03C4h */ case    1:  		/* bc 4, CR0_EQ, 1076 */
		/* 820A03C4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A07F8;  }
		/* 820A03C4h case    1:*/		return 0x820A03C8;
		  /* 820A03C8h */ case    2:  		/* mr R5, R24 */
		/* 820A03C8h case    2:*/		regs.R5 = regs.R24;
		/* 820A03C8h case    2:*/		return 0x820A03CC;
		  /* 820A03CCh */ case    3:  		/* lwz R4, <#[R26 + 2256]> */
		/* 820A03CCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x000008D0) );
		/* 820A03CCh case    3:*/		return 0x820A03D0;
		  /* 820A03D0h */ case    4:  		/* lwz R3, <#[R26 + 2204]> */
		/* 820A03D0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x0000089C) );
		/* 820A03D0h case    4:*/		return 0x820A03D4;
		  /* 820A03D4h */ case    5:  		/* bl 32292 */
		/* 820A03D4h case    5:*/		regs.LR = 0x820A03D8; return 0x820A81F8;
		/* 820A03D4h case    5:*/		return 0x820A03D8;
		  /* 820A03D8h */ case    6:  		/* or. R31, R3, R3 */
		/* 820A03D8h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A03D8h case    6:*/		return 0x820A03DC;
		  /* 820A03DCh */ case    7:  		/* bc 12, CR0_LT, 1088 */
		/* 820A03DCh case    7:*/		if ( regs.CR[0].lt ) { return 0x820A081C;  }
		/* 820A03DCh case    7:*/		return 0x820A03E0;
		  /* 820A03E0h */ case    8:  		/* lis R4, 16383 */
		/* 820A03E0h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x3FFF);
		/* 820A03E0h case    8:*/		return 0x820A03E4;
		  /* 820A03E4h */ case    9:  		/* lis R11, -32255 */
		/* 820A03E4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A03E4h case    9:*/		return 0x820A03E8;
		  /* 820A03E8h */ case   10:  		/* lis R10, -32255 */
		/* 820A03E8h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A03E8h case   10:*/		return 0x820A03EC;
		  /* 820A03ECh */ case   11:  		/* lis R9, -32255 */
		/* 820A03ECh case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A03ECh case   11:*/		return 0x820A03F0;
		  /* 820A03F0h */ case   12:  		/* lis R8, -32255 */
		/* 820A03F0h case   12:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 820A03F0h case   12:*/		return 0x820A03F4;
		  /* 820A03F4h */ case   13:  		/* lis R7, -32255 */
		/* 820A03F4h case   13:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8201);
		/* 820A03F4h case   13:*/		return 0x820A03F8;
		  /* 820A03F8h */ case   14:  		/* lis R6, -32255 */
		/* 820A03F8h case   14:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8201);
		/* 820A03F8h case   14:*/		return 0x820A03FC;
		  /* 820A03FCh */ case   15:  		/* lis R5, -32255 */
		/* 820A03FCh case   15:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8201);
		/* 820A03FCh case   15:*/		return 0x820A0400;
		  /* 820A0400h */ case   16:  		/* li R25, 0 */
		/* 820A0400h case   16:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820A0400h case   16:*/		return 0x820A0404;
		  /* 820A0404h */ case   17:  		/* ori R16, R4, 65535 */
		/* 820A0404h case   17:*/		cpu::op::ori<0>(regs,&regs.R16,regs.R4,0xFFFF);
		/* 820A0404h case   17:*/		return 0x820A0408;
		  /* 820A0408h */ case   18:  		/* li R15, -1 */
		/* 820A0408h case   18:*/		cpu::op::li<0>(regs,&regs.R15,0xFFFFFFFF);
		/* 820A0408h case   18:*/		return 0x820A040C;
		  /* 820A040Ch */ case   19:  		/* addi R22, R11, -10788 */
		/* 820A040Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R11,0xFFFFD5DC);
		/* 820A040Ch case   19:*/		return 0x820A0410;
		  /* 820A0410h */ case   20:  		/* addi R20, R10, -10792 */
		/* 820A0410h case   20:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R10,0xFFFFD5D8);
		/* 820A0410h case   20:*/		return 0x820A0414;
		  /* 820A0414h */ case   21:  		/* addi R19, R9, -10800 */
		/* 820A0414h case   21:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R9,0xFFFFD5D0);
		/* 820A0414h case   21:*/		return 0x820A0418;
		  /* 820A0418h */ case   22:  		/* addi R18, R8, -10808 */
		/* 820A0418h case   22:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R8,0xFFFFD5C8);
		/* 820A0418h case   22:*/		return 0x820A041C;
		  /* 820A041Ch */ case   23:  		/* addi R17, R7, -10816 */
		/* 820A041Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R7,0xFFFFD5C0);
		/* 820A041Ch case   23:*/		return 0x820A0420;
		  /* 820A0420h */ case   24:  		/* addi R21, R6, -10824 */
		/* 820A0420h case   24:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R6,0xFFFFD5B8);
		/* 820A0420h case   24:*/		return 0x820A0424;
		  /* 820A0424h */ case   25:  		/* addi R23, R5, -10832 */
		/* 820A0424h case   25:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R5,0xFFFFD5B0);
		/* 820A0424h case   25:*/		return 0x820A0428;
		  /* 820A0428h */ case   26:  		/* lwz R7, <#[R24]> */
		/* 820A0428h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R24 + 0x00000000) );
		/* 820A0428h case   26:*/		return 0x820A042C;
		  /* 820A042Ch */ case   27:  		/* cmpwi CR6, R7, 1 */
		/* 820A042Ch case   27:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000001);
		/* 820A042Ch case   27:*/		return 0x820A0430;
		  /* 820A0430h */ case   28:  		/* bc 4, CR6_EQ, 56 */
		/* 820A0430h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820A0468;  }
		/* 820A0430h case   28:*/		return 0x820A0434;
		  /* 820A0434h */ case   29:  		/* mr R10, R23 */
		/* 820A0434h case   29:*/		regs.R10 = regs.R23;
		/* 820A0434h case   29:*/		return 0x820A0438;
		  /* 820A0438h */ case   30:  		/* mr R11, R27 */
		/* 820A0438h case   30:*/		regs.R11 = regs.R27;
		/* 820A0438h case   30:*/		return 0x820A043C;
		  /* 820A043Ch */ case   31:  		/* lbz R9, <#[R11]> */
		/* 820A043Ch case   31:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A043Ch case   31:*/		return 0x820A0440;
		  /* 820A0440h */ case   32:  		/* lbz R8, <#[R10]> */
		/* 820A0440h case   32:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0440h case   32:*/		return 0x820A0444;
		  /* 820A0444h */ case   33:  		/* cmpwi CR0, R9, 0 */
		/* 820A0444h case   33:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0444h case   33:*/		return 0x820A0448;
		  /* 820A0448h */ case   34:  		/* subf R9, R8, R9 */
		/* 820A0448h case   34:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A0448h case   34:*/		return 0x820A044C;
		  /* 820A044Ch */ case   35:  		/* bc 12, CR0_EQ, 20 */
		/* 820A044Ch case   35:*/		if ( regs.CR[0].eq ) { return 0x820A0460;  }
		/* 820A044Ch case   35:*/		return 0x820A0450;
		  /* 820A0450h */ case   36:  		/* addi R11, R11, 1 */
		/* 820A0450h case   36:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0450h case   36:*/		return 0x820A0454;
		  /* 820A0454h */ case   37:  		/* addi R10, R10, 1 */
		/* 820A0454h case   37:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0454h case   37:*/		return 0x820A0458;
		  /* 820A0458h */ case   38:  		/* cmpwi CR6, R9, 0 */
		/* 820A0458h case   38:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0458h case   38:*/		return 0x820A045C;
		  /* 820A045Ch */ case   39:  		/* bc 12, CR6_EQ, -32 */
		/* 820A045Ch case   39:*/		if ( regs.CR[6].eq ) { return 0x820A043C;  }
		/* 820A045Ch case   39:*/		return 0x820A0460;
	}
	return 0x820A0460;
} // Block from 820A03C0h-820A0460h (40 instructions)

//////////////////////////////////////////////////////
// Block at 820A0460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0460);
		  /* 820A0460h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0460h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0460h case    0:*/		return 0x820A0464;
		  /* 820A0464h */ case    1:  		/* bc 12, CR0_EQ, 996 */
		/* 820A0464h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A0848;  }
		/* 820A0464h case    1:*/		return 0x820A0468;
	}
	return 0x820A0468;
} // Block from 820A0460h-820A0468h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0468);
		  /* 820A0468h */ case    0:  		/* cmpwi CR6, R7, 11 */
		/* 820A0468h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x0000000B);
		/* 820A0468h case    0:*/		return 0x820A046C;
		  /* 820A046Ch */ case    1:  		/* bc 4, CR6_EQ, 248 */
		/* 820A046Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A0564;  }
		/* 820A046Ch case    1:*/		return 0x820A0470;
	}
	return 0x820A0470;
} // Block from 820A0468h-820A0470h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0470h
// Function 'D3DXGetShaderConstantTableByTarget'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0470);
		  /* 820A0470h */ case    0:  		/* lwz R8, <#[R27]> */
		/* 820A0470h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000000) );
		/* 820A0470h case    0:*/		return 0x820A0474;
		  /* 820A0474h */ case    1:  		/* mr R10, R21 */
		/* 820A0474h case    1:*/		regs.R10 = regs.R21;
		/* 820A0474h case    1:*/		return 0x820A0478;
		  /* 820A0478h */ case    2:  		/* mr R11, R8 */
		/* 820A0478h case    2:*/		regs.R11 = regs.R8;
		/* 820A0478h case    2:*/		return 0x820A047C;
		  /* 820A047Ch */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A047Ch case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A047Ch case    3:*/		return 0x820A0480;
		  /* 820A0480h */ case    4:  		/* lbz R6, <#[R10]> */
		/* 820A0480h case    4:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0480h case    4:*/		return 0x820A0484;
		  /* 820A0484h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A0484h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0484h case    5:*/		return 0x820A0488;
		  /* 820A0488h */ case    6:  		/* subf R9, R6, R9 */
		/* 820A0488h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820A0488h case    6:*/		return 0x820A048C;
		  /* 820A048Ch */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A048Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820A04A0;  }
		/* 820A048Ch case    7:*/		return 0x820A0490;
		  /* 820A0490h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A0490h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0490h case    8:*/		return 0x820A0494;
		  /* 820A0494h */ case    9:  		/* addi R10, R10, 1 */
		/* 820A0494h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0494h case    9:*/		return 0x820A0498;
		  /* 820A0498h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A0498h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0498h case   10:*/		return 0x820A049C;
		  /* 820A049Ch */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A049Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820A047C;  }
		/* 820A049Ch case   11:*/		return 0x820A04A0;
	}
	return 0x820A04A0;
} // Block from 820A0470h-820A04A0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A04A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A04A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A04A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A04A0);
		  /* 820A04A0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A04A0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A04A0h case    0:*/		return 0x820A04A4;
		  /* 820A04A4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A04A4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A04B0;  }
		/* 820A04A4h case    1:*/		return 0x820A04A8;
		  /* 820A04A8h */ case    2:  		/* li R28, 16 */
		/* 820A04A8h case    2:*/		cpu::op::li<0>(regs,&regs.R28,0x10);
		/* 820A04A8h case    2:*/		return 0x820A04AC;
		  /* 820A04ACh */ case    3:  		/* b 232 */
		/* 820A04ACh case    3:*/		return 0x820A0594;
		/* 820A04ACh case    3:*/		return 0x820A04B0;
	}
	return 0x820A04B0;
} // Block from 820A04A0h-820A04B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A04B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A04B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A04B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A04B0);
		  /* 820A04B0h */ case    0:  		/* mr R10, R17 */
		/* 820A04B0h case    0:*/		regs.R10 = regs.R17;
		/* 820A04B0h case    0:*/		return 0x820A04B4;
		  /* 820A04B4h */ case    1:  		/* mr R11, R8 */
		/* 820A04B4h case    1:*/		regs.R11 = regs.R8;
		/* 820A04B4h case    1:*/		return 0x820A04B8;
		  /* 820A04B8h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A04B8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A04B8h case    2:*/		return 0x820A04BC;
		  /* 820A04BCh */ case    3:  		/* lbz R6, <#[R10]> */
		/* 820A04BCh case    3:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820A04BCh case    3:*/		return 0x820A04C0;
		  /* 820A04C0h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A04C0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A04C0h case    4:*/		return 0x820A04C4;
		  /* 820A04C4h */ case    5:  		/* subf R9, R6, R9 */
		/* 820A04C4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820A04C4h case    5:*/		return 0x820A04C8;
		  /* 820A04C8h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820A04C8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A04DC;  }
		/* 820A04C8h case    6:*/		return 0x820A04CC;
		  /* 820A04CCh */ case    7:  		/* addi R11, R11, 1 */
		/* 820A04CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A04CCh case    7:*/		return 0x820A04D0;
		  /* 820A04D0h */ case    8:  		/* addi R10, R10, 1 */
		/* 820A04D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A04D0h case    8:*/		return 0x820A04D4;
		  /* 820A04D4h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820A04D4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A04D4h case    9:*/		return 0x820A04D8;
		  /* 820A04D8h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820A04D8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A04B8;  }
		/* 820A04D8h case   10:*/		return 0x820A04DC;
	}
	return 0x820A04DC;
} // Block from 820A04B0h-820A04DCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A04DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A04DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A04DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A04DC);
		  /* 820A04DCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A04DCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A04DCh case    0:*/		return 0x820A04E0;
		  /* 820A04E0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A04E0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A04EC;  }
		/* 820A04E0h case    1:*/		return 0x820A04E4;
		  /* 820A04E4h */ case    2:  		/* li R28, 15 */
		/* 820A04E4h case    2:*/		cpu::op::li<0>(regs,&regs.R28,0xF);
		/* 820A04E4h case    2:*/		return 0x820A04E8;
		  /* 820A04E8h */ case    3:  		/* b 172 */
		/* 820A04E8h case    3:*/		return 0x820A0594;
		/* 820A04E8h case    3:*/		return 0x820A04EC;
	}
	return 0x820A04EC;
} // Block from 820A04DCh-820A04ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A04ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A04EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A04EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A04EC);
		  /* 820A04ECh */ case    0:  		/* mr R10, R18 */
		/* 820A04ECh case    0:*/		regs.R10 = regs.R18;
		/* 820A04ECh case    0:*/		return 0x820A04F0;
		  /* 820A04F0h */ case    1:  		/* mr R11, R8 */
		/* 820A04F0h case    1:*/		regs.R11 = regs.R8;
		/* 820A04F0h case    1:*/		return 0x820A04F4;
		  /* 820A04F4h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A04F4h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A04F4h case    2:*/		return 0x820A04F8;
		  /* 820A04F8h */ case    3:  		/* lbz R6, <#[R10]> */
		/* 820A04F8h case    3:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820A04F8h case    3:*/		return 0x820A04FC;
		  /* 820A04FCh */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A04FCh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A04FCh case    4:*/		return 0x820A0500;
		  /* 820A0500h */ case    5:  		/* subf R9, R6, R9 */
		/* 820A0500h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820A0500h case    5:*/		return 0x820A0504;
		  /* 820A0504h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820A0504h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A0518;  }
		/* 820A0504h case    6:*/		return 0x820A0508;
		  /* 820A0508h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A0508h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0508h case    7:*/		return 0x820A050C;
		  /* 820A050Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820A050Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A050Ch case    8:*/		return 0x820A0510;
		  /* 820A0510h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820A0510h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0510h case    9:*/		return 0x820A0514;
		  /* 820A0514h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0514h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A04F4;  }
		/* 820A0514h case   10:*/		return 0x820A0518;
	}
	return 0x820A0518;
} // Block from 820A04ECh-820A0518h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A0518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0518);
		  /* 820A0518h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0518h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0518h case    0:*/		return 0x820A051C;
		  /* 820A051Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A051Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A0528;  }
		/* 820A051Ch case    1:*/		return 0x820A0520;
		  /* 820A0520h */ case    2:  		/* li R28, 0 */
		/* 820A0520h case    2:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820A0520h case    2:*/		return 0x820A0524;
		  /* 820A0524h */ case    3:  		/* b 112 */
		/* 820A0524h case    3:*/		return 0x820A0594;
		/* 820A0524h case    3:*/		return 0x820A0528;
	}
	return 0x820A0528;
} // Block from 820A0518h-820A0528h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0528);
		  /* 820A0528h */ case    0:  		/* mr R10, R19 */
		/* 820A0528h case    0:*/		regs.R10 = regs.R19;
		/* 820A0528h case    0:*/		return 0x820A052C;
		  /* 820A052Ch */ case    1:  		/* mr R11, R8 */
		/* 820A052Ch case    1:*/		regs.R11 = regs.R8;
		/* 820A052Ch case    1:*/		return 0x820A0530;
		  /* 820A0530h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A0530h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0530h case    2:*/		return 0x820A0534;
		  /* 820A0534h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A0534h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0534h case    3:*/		return 0x820A0538;
		  /* 820A0538h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A0538h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0538h case    4:*/		return 0x820A053C;
		  /* 820A053Ch */ case    5:  		/* subf R9, R8, R9 */
		/* 820A053Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A053Ch case    5:*/		return 0x820A0540;
		  /* 820A0540h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820A0540h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A0554;  }
		/* 820A0540h case    6:*/		return 0x820A0544;
		  /* 820A0544h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A0544h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0544h case    7:*/		return 0x820A0548;
		  /* 820A0548h */ case    8:  		/* addi R10, R10, 1 */
		/* 820A0548h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0548h case    8:*/		return 0x820A054C;
		  /* 820A054Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820A054Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A054Ch case    9:*/		return 0x820A0550;
		  /* 820A0550h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0550h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A0530;  }
		/* 820A0550h case   10:*/		return 0x820A0554;
	}
	return 0x820A0554;
} // Block from 820A0528h-820A0554h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A0554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0554);
		  /* 820A0554h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0554h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0554h case    0:*/		return 0x820A0558;
	}
	return 0x820A0558;
} // Block from 820A0554h-820A0558h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0558h
// Function 'D3DXGetShaderConstantTable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0558);
		  /* 820A0558h */ case    0:  		/* bc 4, CR0_EQ, 672 */
		/* 820A0558h case    0:*/		if ( !regs.CR[0].eq ) { return 0x820A07F8;  }
		/* 820A0558h case    0:*/		return 0x820A055C;
		  /* 820A055Ch */ case    1:  		/* li R28, 255 */
		/* 820A055Ch case    1:*/		cpu::op::li<0>(regs,&regs.R28,0xFF);
		/* 820A055Ch case    1:*/		return 0x820A0560;
	}
	return 0x820A0560;
} // Block from 820A0558h-820A0560h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0560h
// Function 'D3DXCompileShader'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0560);
		  /* 820A0560h */ case    0:  		/* b 52 */
		/* 820A0560h case    0:*/		return 0x820A0594;
		/* 820A0560h case    0:*/		return 0x820A0564;
	}
	return 0x820A0564;
} // Block from 820A0560h-820A0564h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0564);
		  /* 820A0564h */ case    0:  		/* cmpwi CR6, R7, 2 */
		/* 820A0564h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000002);
		/* 820A0564h case    0:*/		return 0x820A0568;
		  /* 820A0568h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820A0568h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A057C;  }
		/* 820A0568h case    1:*/		return 0x820A056C;
		  /* 820A056Ch */ case    2:  		/* cmpwi CR6, R7, 3 */
		/* 820A056Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000003);
		/* 820A056Ch case    2:*/		return 0x820A0570;
		  /* 820A0570h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0570h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A057C;  }
		/* 820A0570h case    3:*/		return 0x820A0574;
		  /* 820A0574h */ case    4:  		/* cmpwi CR6, R7, 4 */
		/* 820A0574h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000004);
		/* 820A0574h case    4:*/		return 0x820A0578;
		  /* 820A0578h */ case    5:  		/* bc 4, CR6_EQ, 640 */
		/* 820A0578h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A07F8;  }
		/* 820A0578h case    5:*/		return 0x820A057C;
	}
	return 0x820A057C;
} // Block from 820A0564h-820A057Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A057Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A057C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A057C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A057C);
		  /* 820A057Ch */ case    0:  		/* lwz R11, <#[R27]> */
		/* 820A057Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A057Ch case    0:*/		return 0x820A0580;
		  /* 820A0580h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 820A0580h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820A0580h case    1:*/		return 0x820A0584;
		  /* 820A0584h */ case    2:  		/* bc 12, CR6_LT, 628 */
		/* 820A0584h case    2:*/		if ( regs.CR[6].lt ) { return 0x820A07F8;  }
		/* 820A0584h case    2:*/		return 0x820A0588;
		  /* 820A0588h */ case    3:  		/* cmplwi CR6, R11, 4 */
		/* 820A0588h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820A0588h case    3:*/		return 0x820A058C;
		  /* 820A058Ch */ case    4:  		/* bc 12, CR6_GT, 620 */
		/* 820A058Ch case    4:*/		if ( regs.CR[6].gt ) { return 0x820A07F8;  }
		/* 820A058Ch case    4:*/		return 0x820A0590;
		  /* 820A0590h */ case    5:  		/* mr R28, R11 */
		/* 820A0590h case    5:*/		regs.R28 = regs.R11;
		/* 820A0590h case    5:*/		return 0x820A0594;
	}
	return 0x820A0594;
} // Block from 820A057Ch-820A0594h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A0594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0594);
		  /* 820A0594h */ case    0:  		/* mr R5, R24 */
		/* 820A0594h case    0:*/		regs.R5 = regs.R24;
		/* 820A0594h case    0:*/		return 0x820A0598;
		  /* 820A0598h */ case    1:  		/* lwz R4, <#[R26 + 2256]> */
		/* 820A0598h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x000008D0) );
		/* 820A0598h case    1:*/		return 0x820A059C;
		  /* 820A059Ch */ case    2:  		/* lwz R3, <#[R26 + 2204]> */
		/* 820A059Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x0000089C) );
		/* 820A059Ch case    2:*/		return 0x820A05A0;
		  /* 820A05A0h */ case    3:  		/* bl 31832 */
		/* 820A05A0h case    3:*/		regs.LR = 0x820A05A4; return 0x820A81F8;
		/* 820A05A0h case    3:*/		return 0x820A05A4;
		  /* 820A05A4h */ case    4:  		/* or. R31, R3, R3 */
		/* 820A05A4h case    4:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A05A4h case    4:*/		return 0x820A05A8;
		  /* 820A05A8h */ case    5:  		/* bc 12, CR0_LT, 628 */
		/* 820A05A8h case    5:*/		if ( regs.CR[0].lt ) { return 0x820A081C;  }
		/* 820A05A8h case    5:*/		return 0x820A05AC;
		  /* 820A05ACh */ case    6:  		/* lwz R7, <#[R24]> */
		/* 820A05ACh case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R24 + 0x00000000) );
		/* 820A05ACh case    6:*/		return 0x820A05B0;
		  /* 820A05B0h */ case    7:  		/* cmpwi CR6, R7, 1 */
		/* 820A05B0h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000001);
		/* 820A05B0h case    7:*/		return 0x820A05B4;
		  /* 820A05B4h */ case    8:  		/* bc 4, CR6_EQ, 580 */
		/* 820A05B4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A07F8;  }
		/* 820A05B4h case    8:*/		return 0x820A05B8;
		  /* 820A05B8h */ case    9:  		/* mr R10, R20 */
		/* 820A05B8h case    9:*/		regs.R10 = regs.R20;
		/* 820A05B8h case    9:*/		return 0x820A05BC;
		  /* 820A05BCh */ case   10:  		/* mr R11, R27 */
		/* 820A05BCh case   10:*/		regs.R11 = regs.R27;
		/* 820A05BCh case   10:*/		return 0x820A05C0;
		  /* 820A05C0h */ case   11:  		/* lbz R9, <#[R11]> */
		/* 820A05C0h case   11:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A05C0h case   11:*/		return 0x820A05C4;
		  /* 820A05C4h */ case   12:  		/* lbz R8, <#[R10]> */
		/* 820A05C4h case   12:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A05C4h case   12:*/		return 0x820A05C8;
	}
	return 0x820A05C8;
} // Block from 820A0594h-820A05C8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A05C8h
// Function '??0CPPInclude@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A05C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A05C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A05C8);
		  /* 820A05C8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A05C8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A05C8h case    0:*/		return 0x820A05CC;
		  /* 820A05CCh */ case    1:  		/* subf R9, R8, R9 */
		/* 820A05CCh case    1:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A05CCh case    1:*/		return 0x820A05D0;
		  /* 820A05D0h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820A05D0h case    2:*/		if ( regs.CR[0].eq ) { return 0x820A05E4;  }
		/* 820A05D0h case    2:*/		return 0x820A05D4;
		  /* 820A05D4h */ case    3:  		/* addi R11, R11, 1 */
		/* 820A05D4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A05D4h case    3:*/		return 0x820A05D8;
		  /* 820A05D8h */ case    4:  		/* addi R10, R10, 1 */
		/* 820A05D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A05D8h case    4:*/		return 0x820A05DC;
		  /* 820A05DCh */ case    5:  		/* cmpwi CR6, R9, 0 */
		/* 820A05DCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A05DCh case    5:*/		return 0x820A05E0;
		  /* 820A05E0h */ case    6:  		/* bc 12, CR6_EQ, -32 */
		/* 820A05E0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A05C0;  }
		/* 820A05E0h case    6:*/		return 0x820A05E4;
	}
	return 0x820A05E4;
} // Block from 820A05C8h-820A05E4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A05E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A05E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A05E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A05E4);
		  /* 820A05E4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A05E4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A05E4h case    0:*/		return 0x820A05E8;
		  /* 820A05E8h */ case    1:  		/* bc 4, CR0_EQ, 528 */
		/* 820A05E8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A07F8;  }
		/* 820A05E8h case    1:*/		return 0x820A05EC;
		  /* 820A05ECh */ case    2:  		/* mr R5, R24 */
		/* 820A05ECh case    2:*/		regs.R5 = regs.R24;
		/* 820A05ECh case    2:*/		return 0x820A05F0;
		  /* 820A05F0h */ case    3:  		/* lwz R4, <#[R26 + 2256]> */
		/* 820A05F0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x000008D0) );
		/* 820A05F0h case    3:*/		return 0x820A05F4;
		  /* 820A05F4h */ case    4:  		/* lwz R3, <#[R26 + 2204]> */
		/* 820A05F4h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x0000089C) );
		/* 820A05F4h case    4:*/		return 0x820A05F8;
		  /* 820A05F8h */ case    5:  		/* bl 31744 */
		/* 820A05F8h case    5:*/		regs.LR = 0x820A05FC; return 0x820A81F8;
		/* 820A05F8h case    5:*/		return 0x820A05FC;
		  /* 820A05FCh */ case    6:  		/* or. R31, R3, R3 */
		/* 820A05FCh case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A05FCh case    6:*/		return 0x820A0600;
		  /* 820A0600h */ case    7:  		/* bc 12, CR0_LT, 540 */
		/* 820A0600h case    7:*/		if ( regs.CR[0].lt ) { return 0x820A081C;  }
		/* 820A0600h case    7:*/		return 0x820A0604;
		  /* 820A0604h */ case    8:  		/* lwz R7, <#[R24]> */
		/* 820A0604h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R24 + 0x00000000) );
		/* 820A0604h case    8:*/		return 0x820A0608;
		  /* 820A0608h */ case    9:  		/* cmpwi CR6, R7, 2 */
		/* 820A0608h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000002);
		/* 820A0608h case    9:*/		return 0x820A060C;
		  /* 820A060Ch */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 820A060Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820A0620;  }
		/* 820A060Ch case   10:*/		return 0x820A0610;
		  /* 820A0610h */ case   11:  		/* cmpwi CR6, R7, 3 */
		/* 820A0610h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000003);
		/* 820A0610h case   11:*/		return 0x820A0614;
		  /* 820A0614h */ case   12:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0614h case   12:*/		if ( regs.CR[6].eq ) { return 0x820A0620;  }
		/* 820A0614h case   12:*/		return 0x820A0618;
		  /* 820A0618h */ case   13:  		/* cmpwi CR6, R7, 4 */
		/* 820A0618h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000004);
		/* 820A0618h case   13:*/		return 0x820A061C;
		  /* 820A061Ch */ case   14:  		/* bc 4, CR6_EQ, 476 */
		/* 820A061Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x820A07F8;  }
		/* 820A061Ch case   14:*/		return 0x820A0620;
	}
	return 0x820A0620;
} // Block from 820A05E4h-820A0620h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A0620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0620);
		  /* 820A0620h */ case    0:  		/* nor R11, R25, R25 */
		/* 820A0620h case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R25,regs.R25);
		/* 820A0620h case    0:*/		return 0x820A0624;
		  /* 820A0624h */ case    1:  		/* lwz R29, <#[R27]> */
		/* 820A0624h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R27 + 0x00000000) );
		/* 820A0624h case    1:*/		return 0x820A0628;
	}
	return 0x820A0628;
} // Block from 820A0620h-820A0628h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0628h
// Function '?InitializePathFromFileName@CPPInclude@D3DXShader@@QAAJPAVCAlloc@D3DXCore@@PBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0628);
		  /* 820A0628h */ case    0:  		/* addi R11, R11, 1 */
		/* 820A0628h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0628h case    0:*/		return 0x820A062C;
		  /* 820A062Ch */ case    1:  		/* and R11, R11, R25 */
		/* 820A062Ch case    1:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 820A062Ch case    1:*/		return 0x820A0630;
		  /* 820A0630h */ case    2:  		/* cmplw CR6, R25, R11 */
		/* 820A0630h case    2:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 820A0630h case    2:*/		return 0x820A0634;
		  /* 820A0634h */ case    3:  		/* bc 4, CR6_EQ, 156 */
		/* 820A0634h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A06D0;  }
		/* 820A0634h case    3:*/		return 0x820A0638;
		  /* 820A0638h */ case    4:  		/* cmplwi CR6, R25, 0 */
		/* 820A0638h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820A0638h case    4:*/		return 0x820A063C;
		  /* 820A063Ch */ case    5:  		/* rlwinm R11, R25, 1, 0, 30 */
		/* 820A063Ch case    5:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R25);
		/* 820A063Ch case    5:*/		return 0x820A0640;
		  /* 820A0640h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 820A0640h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A0648;  }
		/* 820A0640h case    6:*/		return 0x820A0644;
		  /* 820A0644h */ case    7:  		/* li R11, 1 */
		/* 820A0644h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A0644h case    7:*/		return 0x820A0648;
	}
	return 0x820A0648;
} // Block from 820A0628h-820A0648h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A0648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0648);
		  /* 820A0648h */ case    0:  		/* cmplw CR6, R11, R16 */
		/* 820A0648h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 820A0648h case    0:*/		return 0x820A064C;
		  /* 820A064Ch */ case    1:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820A064Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820A064Ch case    1:*/		return 0x820A0650;
		  /* 820A0650h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 820A0650h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820A0658;  }
		/* 820A0650h case    2:*/		return 0x820A0654;
		  /* 820A0654h */ case    3:  		/* mr R3, R15 */
		/* 820A0654h case    3:*/		regs.R3 = regs.R15;
		/* 820A0654h case    3:*/		return 0x820A0658;
	}
	return 0x820A0658;
} // Block from 820A0648h-820A0658h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0658);
		  /* 820A0658h */ case    0:  		/* bl -53008 */
		/* 820A0658h case    0:*/		regs.LR = 0x820A065C; return 0x82093748;
		/* 820A0658h case    0:*/		return 0x820A065C;
		  /* 820A065Ch */ case    1:  		/* or. R31, R3, R3 */
		/* 820A065Ch case    1:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A065Ch case    1:*/		return 0x820A0660;
		  /* 820A0660h */ case    2:  		/* bc 12, CR0_EQ, 608 */
		/* 820A0660h case    2:*/		if ( regs.CR[0].eq ) { return 0x820A08C0;  }
		/* 820A0660h case    2:*/		return 0x820A0664;
		  /* 820A0664h */ case    3:  		/* rlwinm R30, R25, 2, 0, 29 */
		/* 820A0664h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R25);
		/* 820A0664h case    3:*/		return 0x820A0668;
		  /* 820A0668h */ case    4:  		/* lwz R4, <#[R1 + 80]> */
		/* 820A0668h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820A0668h case    4:*/		return 0x820A066C;
		  /* 820A066Ch */ case    5:  		/* mr R3, R31 */
		/* 820A066Ch case    5:*/		regs.R3 = regs.R31;
		/* 820A066Ch case    5:*/		return 0x820A0670;
		  /* 820A0670h */ case    6:  		/* mr R5, R30 */
		/* 820A0670h case    6:*/		regs.R5 = regs.R30;
		/* 820A0670h case    6:*/		return 0x820A0674;
		  /* 820A0674h */ case    7:  		/* bl -60612 */
		/* 820A0674h case    7:*/		regs.LR = 0x820A0678; return 0x820919B0;
		/* 820A0674h case    7:*/		return 0x820A0678;
		  /* 820A0678h */ case    8:  		/* lwz R3, <#[R1 + 80]> */
		/* 820A0678h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820A0678h case    8:*/		return 0x820A067C;
		  /* 820A067Ch */ case    9:  		/* bl -58132 */
		/* 820A067Ch case    9:*/		regs.LR = 0x820A0680; return 0x82092368;
		/* 820A067Ch case    9:*/		return 0x820A0680;
		  /* 820A0680h */ case   10:  		/* stw R31, <#[R1 + 80]> */
		/* 820A0680h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 820A0680h case   10:*/		return 0x820A0684;
		  /* 820A0684h */ case   11:  		/* cmplwi CR6, R25, 0 */
		/* 820A0684h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820A0684h case   11:*/		return 0x820A0688;
		  /* 820A0688h */ case   12:  		/* rlwinm R11, R25, 1, 0, 30 */
		/* 820A0688h case   12:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R25);
		/* 820A0688h case   12:*/		return 0x820A068C;
		  /* 820A068Ch */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 820A068Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A0694;  }
		/* 820A068Ch case   13:*/		return 0x820A0690;
		  /* 820A0690h */ case   14:  		/* li R11, 1 */
		/* 820A0690h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A0690h case   14:*/		return 0x820A0694;
	}
	return 0x820A0694;
} // Block from 820A0658h-820A0694h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A0694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0694);
		  /* 820A0694h */ case    0:  		/* cmplw CR6, R11, R16 */
		/* 820A0694h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 820A0694h case    0:*/		return 0x820A0698;
		  /* 820A0698h */ case    1:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820A0698h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820A0698h case    1:*/		return 0x820A069C;
		  /* 820A069Ch */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 820A069Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x820A06A4;  }
		/* 820A069Ch case    2:*/		return 0x820A06A0;
		  /* 820A06A0h */ case    3:  		/* mr R3, R15 */
		/* 820A06A0h case    3:*/		regs.R3 = regs.R15;
		/* 820A06A0h case    3:*/		return 0x820A06A4;
	}
	return 0x820A06A4;
} // Block from 820A0694h-820A06A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A06A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A06A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A06A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A06A4);
		  /* 820A06A4h */ case    0:  		/* bl -53084 */
		/* 820A06A4h case    0:*/		regs.LR = 0x820A06A8; return 0x82093748;
		/* 820A06A4h case    0:*/		return 0x820A06A8;
		  /* 820A06A8h */ case    1:  		/* or. R31, R3, R3 */
		/* 820A06A8h case    1:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A06A8h case    1:*/		return 0x820A06AC;
		  /* 820A06ACh */ case    2:  		/* bc 12, CR0_EQ, 532 */
		/* 820A06ACh case    2:*/		if ( regs.CR[0].eq ) { return 0x820A08C0;  }
		/* 820A06ACh case    2:*/		return 0x820A06B0;
		  /* 820A06B0h */ case    3:  		/* mr R5, R30 */
		/* 820A06B0h case    3:*/		regs.R5 = regs.R30;
		/* 820A06B0h case    3:*/		return 0x820A06B4;
		  /* 820A06B4h */ case    4:  		/* mr R4, R14 */
		/* 820A06B4h case    4:*/		regs.R4 = regs.R14;
		/* 820A06B4h case    4:*/		return 0x820A06B8;
		  /* 820A06B8h */ case    5:  		/* mr R3, R31 */
		/* 820A06B8h case    5:*/		regs.R3 = regs.R31;
		/* 820A06B8h case    5:*/		return 0x820A06BC;
		  /* 820A06BCh */ case    6:  		/* bl -60684 */
		/* 820A06BCh case    6:*/		regs.LR = 0x820A06C0; return 0x820919B0;
		/* 820A06BCh case    6:*/		return 0x820A06C0;
		  /* 820A06C0h */ case    7:  		/* mr R3, R14 */
		/* 820A06C0h case    7:*/		regs.R3 = regs.R14;
		/* 820A06C0h case    7:*/		return 0x820A06C4;
		  /* 820A06C4h */ case    8:  		/* bl -58204 */
		/* 820A06C4h case    8:*/		regs.LR = 0x820A06C8; return 0x82092368;
		/* 820A06C4h case    8:*/		return 0x820A06C8;
		  /* 820A06C8h */ case    9:  		/* lwz R30, <#[R1 + 80]> */
		/* 820A06C8h case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 820A06C8h case    9:*/		return 0x820A06CC;
		  /* 820A06CCh */ case   10:  		/* mr R14, R31 */
		/* 820A06CCh case   10:*/		regs.R14 = regs.R31;
		/* 820A06CCh case   10:*/		return 0x820A06D0;
	}
	return 0x820A06D0;
} // Block from 820A06A4h-820A06D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A06D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A06D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A06D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A06D0);
		  /* 820A06D0h */ case    0:  		/* rlwinm R11, R25, 2, 0, 29 */
		/* 820A06D0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R25);
		/* 820A06D0h case    0:*/		return 0x820A06D4;
		  /* 820A06D4h */ case    1:  		/* mr R5, R24 */
		/* 820A06D4h case    1:*/		regs.R5 = regs.R24;
		/* 820A06D4h case    1:*/		return 0x820A06D8;
		  /* 820A06D8h */ case    2:  		/* addi R25, R25, 1 */
		/* 820A06D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 820A06D8h case    2:*/		return 0x820A06DC;
		  /* 820A06DCh */ case    3:  		/* stwx R29, <#[R11 + R14]> */
		/* 820A06DCh case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + regs.R14 + 0x00000000) );
		/* 820A06DCh case    3:*/		return 0x820A06E0;
		  /* 820A06E0h */ case    4:  		/* stwx R28, <#[R11 + R30]> */
		/* 820A06E0h case    4:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820A06E0h case    4:*/		return 0x820A06E4;
		  /* 820A06E4h */ case    5:  		/* lwz R4, <#[R26 + 2256]> */
		/* 820A06E4h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x000008D0) );
		/* 820A06E4h case    5:*/		return 0x820A06E8;
		  /* 820A06E8h */ case    6:  		/* lwz R3, <#[R26 + 2204]> */
		/* 820A06E8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x0000089C) );
		/* 820A06E8h case    6:*/		return 0x820A06EC;
		  /* 820A06ECh */ case    7:  		/* bl 31500 */
		/* 820A06ECh case    7:*/		regs.LR = 0x820A06F0; return 0x820A81F8;
		/* 820A06ECh case    7:*/		return 0x820A06F0;
		  /* 820A06F0h */ case    8:  		/* or. R31, R3, R3 */
		/* 820A06F0h case    8:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A06F0h case    8:*/		return 0x820A06F4;
		  /* 820A06F4h */ case    9:  		/* bc 12, CR0_LT, 296 */
		/* 820A06F4h case    9:*/		if ( regs.CR[0].lt ) { return 0x820A081C;  }
		/* 820A06F4h case    9:*/		return 0x820A06F8;
		  /* 820A06F8h */ case   10:  		/* lwz R11, <#[R24]> */
		/* 820A06F8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 820A06F8h case   10:*/		return 0x820A06FC;
		  /* 820A06FCh */ case   11:  		/* cmpwi CR6, R11, 1 */
		/* 820A06FCh case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820A06FCh case   11:*/		return 0x820A0700;
		  /* 820A0700h */ case   12:  		/* bc 4, CR6_EQ, -252 */
		/* 820A0700h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A0604;  }
		/* 820A0700h case   12:*/		return 0x820A0704;
		  /* 820A0704h */ case   13:  		/* mr R10, R22 */
		/* 820A0704h case   13:*/		regs.R10 = regs.R22;
		/* 820A0704h case   13:*/		return 0x820A0708;
	}
	return 0x820A0708;
} // Block from 820A06D0h-820A0708h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A0708h
// Function '?CallClose@CPPInclude@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0708);
		  /* 820A0708h */ case    0:  		/* mr R11, R27 */
		/* 820A0708h case    0:*/		regs.R11 = regs.R27;
		/* 820A0708h case    0:*/		return 0x820A070C;
		  /* 820A070Ch */ case    1:  		/* lbz R9, <#[R11]> */
		/* 820A070Ch case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A070Ch case    1:*/		return 0x820A0710;
		  /* 820A0710h */ case    2:  		/* lbz R8, <#[R10]> */
		/* 820A0710h case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0710h case    2:*/		return 0x820A0714;
		  /* 820A0714h */ case    3:  		/* cmpwi CR0, R9, 0 */
		/* 820A0714h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0714h case    3:*/		return 0x820A0718;
		  /* 820A0718h */ case    4:  		/* subf R9, R8, R9 */
		/* 820A0718h case    4:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A0718h case    4:*/		return 0x820A071C;
		  /* 820A071Ch */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 820A071Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820A0730;  }
		/* 820A071Ch case    5:*/		return 0x820A0720;
		  /* 820A0720h */ case    6:  		/* addi R11, R11, 1 */
		/* 820A0720h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0720h case    6:*/		return 0x820A0724;
		  /* 820A0724h */ case    7:  		/* addi R10, R10, 1 */
		/* 820A0724h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0724h case    7:*/		return 0x820A0728;
		  /* 820A0728h */ case    8:  		/* cmpwi CR6, R9, 0 */
		/* 820A0728h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0728h case    8:*/		return 0x820A072C;
		  /* 820A072Ch */ case    9:  		/* bc 12, CR6_EQ, -32 */
		/* 820A072Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820A070C;  }
		/* 820A072Ch case    9:*/		return 0x820A0730;
	}
	return 0x820A0730;
} // Block from 820A0708h-820A0730h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A0730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0730);
		  /* 820A0730h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0730h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0730h case    0:*/		return 0x820A0734;
		  /* 820A0734h */ case    1:  		/* bc 12, CR0_EQ, 56 */
		/* 820A0734h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A076C;  }
		/* 820A0734h case    1:*/		return 0x820A0738;
		  /* 820A0738h */ case    2:  		/* mr R10, R23 */
		/* 820A0738h case    2:*/		regs.R10 = regs.R23;
		/* 820A0738h case    2:*/		return 0x820A073C;
		  /* 820A073Ch */ case    3:  		/* mr R11, R27 */
		/* 820A073Ch case    3:*/		regs.R11 = regs.R27;
		/* 820A073Ch case    3:*/		return 0x820A0740;
		  /* 820A0740h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820A0740h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0740h case    4:*/		return 0x820A0744;
		  /* 820A0744h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820A0744h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0744h case    5:*/		return 0x820A0748;
		  /* 820A0748h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820A0748h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0748h case    6:*/		return 0x820A074C;
		  /* 820A074Ch */ case    7:  		/* subf R9, R8, R9 */
		/* 820A074Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A074Ch case    7:*/		return 0x820A0750;
		  /* 820A0750h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820A0750h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A0764;  }
		/* 820A0750h case    8:*/		return 0x820A0754;
		  /* 820A0754h */ case    9:  		/* addi R11, R11, 1 */
		/* 820A0754h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0754h case    9:*/		return 0x820A0758;
		  /* 820A0758h */ case   10:  		/* addi R10, R10, 1 */
		/* 820A0758h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0758h case   10:*/		return 0x820A075C;
		  /* 820A075Ch */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820A075Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A075Ch case   11:*/		return 0x820A0760;
	}
	return 0x820A0760;
} // Block from 820A0730h-820A0760h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A0760h
// Function '?RtlEnterCriticalSection@CPreProcessor@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0760);
		  /* 820A0760h */ case    0:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0760h case    0:*/		if ( regs.CR[6].eq ) { return 0x820A0740;  }
		/* 820A0760h case    0:*/		return 0x820A0764;
	}
	return 0x820A0764;
} // Block from 820A0760h-820A0764h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0764);
		  /* 820A0764h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0764h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0764h case    0:*/		return 0x820A0768;
		  /* 820A0768h */ case    1:  		/* bc 4, CR0_EQ, -356 */
		/* 820A0768h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A0604;  }
		/* 820A0768h case    1:*/		return 0x820A076C;
	}
	return 0x820A076C;
} // Block from 820A0764h-820A076Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A076Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A076C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A076C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A076C);
		  /* 820A076Ch */ case    0:  		/* mr R10, R22 */
		/* 820A076Ch case    0:*/		regs.R10 = regs.R22;
		/* 820A076Ch case    0:*/		return 0x820A0770;
		  /* 820A0770h */ case    1:  		/* mr R11, R27 */
		/* 820A0770h case    1:*/		regs.R11 = regs.R27;
		/* 820A0770h case    1:*/		return 0x820A0774;
		  /* 820A0774h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A0774h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0774h case    2:*/		return 0x820A0778;
		  /* 820A0778h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A0778h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0778h case    3:*/		return 0x820A077C;
		  /* 820A077Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A077Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A077Ch case    4:*/		return 0x820A0780;
		  /* 820A0780h */ case    5:  		/* subf R9, R8, R9 */
		/* 820A0780h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A0780h case    5:*/		return 0x820A0784;
		  /* 820A0784h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820A0784h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A0798;  }
		/* 820A0784h case    6:*/		return 0x820A0788;
		  /* 820A0788h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A0788h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0788h case    7:*/		return 0x820A078C;
		  /* 820A078Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820A078Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A078Ch case    8:*/		return 0x820A0790;
		  /* 820A0790h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820A0790h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0790h case    9:*/		return 0x820A0794;
		  /* 820A0794h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0794h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A0774;  }
		/* 820A0794h case   10:*/		return 0x820A0798;
	}
	return 0x820A0798;
} // Block from 820A076Ch-820A0798h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A0798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0798);
		  /* 820A0798h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0798h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0798h case    0:*/		return 0x820A079C;
		  /* 820A079Ch */ case    1:  		/* bc 4, CR0_EQ, -884 */
		/* 820A079Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A0428;  }
		/* 820A079Ch case    1:*/		return 0x820A07A0;
		  /* 820A07A0h */ case    2:  		/* mr R5, R24 */
		/* 820A07A0h case    2:*/		regs.R5 = regs.R24;
		/* 820A07A0h case    2:*/		return 0x820A07A4;
		  /* 820A07A4h */ case    3:  		/* lwz R4, <#[R26 + 2256]> */
		/* 820A07A4h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x000008D0) );
		/* 820A07A4h case    3:*/		return 0x820A07A8;
		  /* 820A07A8h */ case    4:  		/* lwz R3, <#[R26 + 2204]> */
		/* 820A07A8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x0000089C) );
		/* 820A07A8h case    4:*/		return 0x820A07AC;
		  /* 820A07ACh */ case    5:  		/* bl 31308 */
		/* 820A07ACh case    5:*/		regs.LR = 0x820A07B0; return 0x820A81F8;
		/* 820A07ACh case    5:*/		return 0x820A07B0;
		  /* 820A07B0h */ case    6:  		/* or. R31, R3, R3 */
		/* 820A07B0h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A07B0h case    6:*/		return 0x820A07B4;
		  /* 820A07B4h */ case    7:  		/* bc 12, CR0_LT, 104 */
		/* 820A07B4h case    7:*/		if ( regs.CR[0].lt ) { return 0x820A081C;  }
		/* 820A07B4h case    7:*/		return 0x820A07B8;
	}
	return 0x820A07B8;
} // Block from 820A0798h-820A07B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A07B8h
// Function '?RtlLeaveCriticalSection@CPreProcessor@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A07B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A07B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A07B8);
		  /* 820A07B8h */ case    0:  		/* lwz R7, <#[R24]> */
		/* 820A07B8h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R24 + 0x00000000) );
		/* 820A07B8h case    0:*/		return 0x820A07BC;
		  /* 820A07BCh */ case    1:  		/* cmpwi CR6, R7, 1 */
		/* 820A07BCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000001);
		/* 820A07BCh case    1:*/		return 0x820A07C0;
		  /* 820A07C0h */ case    2:  		/* bc 4, CR6_EQ, -920 */
		/* 820A07C0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A0428;  }
		/* 820A07C0h case    2:*/		return 0x820A07C4;
		  /* 820A07C4h */ case    3:  		/* mr R10, R23 */
		/* 820A07C4h case    3:*/		regs.R10 = regs.R23;
		/* 820A07C4h case    3:*/		return 0x820A07C8;
		  /* 820A07C8h */ case    4:  		/* mr R11, R27 */
		/* 820A07C8h case    4:*/		regs.R11 = regs.R27;
		/* 820A07C8h case    4:*/		return 0x820A07CC;
		  /* 820A07CCh */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820A07CCh case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A07CCh case    5:*/		return 0x820A07D0;
		  /* 820A07D0h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820A07D0h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A07D0h case    6:*/		return 0x820A07D4;
		  /* 820A07D4h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820A07D4h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A07D4h case    7:*/		return 0x820A07D8;
		  /* 820A07D8h */ case    8:  		/* subf R9, R8, R9 */
		/* 820A07D8h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A07D8h case    8:*/		return 0x820A07DC;
		  /* 820A07DCh */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820A07DCh case    9:*/		if ( regs.CR[0].eq ) { return 0x820A07F0;  }
		/* 820A07DCh case    9:*/		return 0x820A07E0;
		  /* 820A07E0h */ case   10:  		/* addi R11, R11, 1 */
		/* 820A07E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A07E0h case   10:*/		return 0x820A07E4;
		  /* 820A07E4h */ case   11:  		/* addi R10, R10, 1 */
		/* 820A07E4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A07E4h case   11:*/		return 0x820A07E8;
		  /* 820A07E8h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820A07E8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A07E8h case   12:*/		return 0x820A07EC;
		  /* 820A07ECh */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820A07ECh case   13:*/		if ( regs.CR[6].eq ) { return 0x820A07CC;  }
		/* 820A07ECh case   13:*/		return 0x820A07F0;
	}
	return 0x820A07F0;
} // Block from 820A07B8h-820A07F0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A07F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A07F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A07F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A07F0);
		  /* 820A07F0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A07F0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A07F0h case    0:*/		return 0x820A07F4;
		  /* 820A07F4h */ case    1:  		/* bc 4, CR0_EQ, -972 */
		/* 820A07F4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A0428;  }
		/* 820A07F4h case    1:*/		return 0x820A07F8;
	}
	return 0x820A07F8;
} // Block from 820A07F0h-820A07F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A07F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A07F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A07F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A07F8);
		  /* 820A07F8h */ case    0:  		/* cmpwi CR6, R7, 16 */
		/* 820A07F8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000010);
		/* 820A07F8h case    0:*/		return 0x820A07FC;
		  /* 820A07FCh */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820A07FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820A0814;  }
		/* 820A07FCh case    1:*/		return 0x820A0800;
	}
	return 0x820A0800;
} // Block from 820A07F8h-820A0800h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0800h
// Function '?GetFileLine@CPreProcessor@D3DXShader@@QAAJPAPBDPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0800);
		  /* 820A0800h */ case    0:  		/* cmpwi CR6, R7, 17 */
		/* 820A0800h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000011);
		/* 820A0800h case    0:*/		return 0x820A0804;
		  /* 820A0804h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820A0804h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A0814;  }
		/* 820A0804h case    1:*/		return 0x820A0808;
		  /* 820A0808h */ case    2:  		/* li R4, 0 */
		/* 820A0808h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A0808h case    2:*/		return 0x820A080C;
		  /* 820A080Ch */ case    3:  		/* lwz R3, <#[R26 + 2204]> */
		/* 820A080Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x0000089C) );
		/* 820A080Ch case    3:*/		return 0x820A0810;
		  /* 820A0810h */ case    4:  		/* bl 27984 */
		/* 820A0810h case    4:*/		regs.LR = 0x820A0814; return 0x820A7560;
		/* 820A0810h case    4:*/		return 0x820A0814;
	}
	return 0x820A0814;
} // Block from 820A0800h-820A0814h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0814);
		  /* 820A0814h */ case    0:  		/* li R31, 0 */
		/* 820A0814h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820A0814h case    0:*/		return 0x820A0818;
		  /* 820A0818h */ case    1:  		/* stw R31, <#[R26 + 2252]> */
		/* 820A0818h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R26 + 0x000008CC) );
		/* 820A0818h case    1:*/		return 0x820A081C;
	}
	return 0x820A081C;
} // Block from 820A0814h-820A081Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A081Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A081C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A081C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A081C);
		  /* 820A081Ch */ case    0:  		/* lwz R3, <#[R1 + 80]> */
		/* 820A081Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820A081Ch case    0:*/		return 0x820A0820;
		  /* 820A0820h */ case    1:  		/* bl -58552 */
		/* 820A0820h case    1:*/		regs.LR = 0x820A0824; return 0x82092368;
		/* 820A0820h case    1:*/		return 0x820A0824;
		  /* 820A0824h */ case    2:  		/* mr R3, R14 */
		/* 820A0824h case    2:*/		regs.R3 = regs.R14;
		/* 820A0824h case    2:*/		return 0x820A0828;
		  /* 820A0828h */ case    3:  		/* bl -58560 */
		/* 820A0828h case    3:*/		regs.LR = 0x820A082C; return 0x82092368;
		/* 820A0828h case    3:*/		return 0x820A082C;
		  /* 820A082Ch */ case    4:  		/* li R3, 0 */
		/* 820A082Ch case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A082Ch case    4:*/		return 0x820A0830;
	}
	return 0x820A0830;
} // Block from 820A081Ch-820A0830h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0830h
// Function '?GetBufferPointer@CPreProcessor@D3DXShader@@QAAJPAPBDPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0830);
		  /* 820A0830h */ case    0:  		/* bl -58568 */
		/* 820A0830h case    0:*/		regs.LR = 0x820A0834; return 0x82092368;
		/* 820A0830h case    0:*/		return 0x820A0834;
		  /* 820A0834h */ case    1:  		/* li R11, 1 */
		/* 820A0834h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A0834h case    1:*/		return 0x820A0838;
		  /* 820A0838h */ case    2:  		/* mr R3, R31 */
		/* 820A0838h case    2:*/		regs.R3 = regs.R31;
		/* 820A0838h case    2:*/		return 0x820A083C;
		  /* 820A083Ch */ case    3:  		/* stw R11, <#[R26 + 1636]> */
		/* 820A083Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000664) );
		/* 820A083Ch case    3:*/		return 0x820A0840;
		  /* 820A0840h */ case    4:  		/* addi R1, R1, 240 */
		/* 820A0840h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 820A0840h case    4:*/		return 0x820A0844;
		  /* 820A0844h */ case    5:  		/* b -62932 */
		/* 820A0844h case    5:*/		return 0x82091270;
		/* 820A0844h case    5:*/		return 0x820A0848;
	}
	return 0x820A0848;
} // Block from 820A0830h-820A0848h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A0848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0848);
		  /* 820A0848h */ case    0:  		/* mr R5, R24 */
		/* 820A0848h case    0:*/		regs.R5 = regs.R24;
		/* 820A0848h case    0:*/		return 0x820A084C;
		  /* 820A084Ch */ case    1:  		/* lwz R4, <#[R26 + 2256]> */
		/* 820A084Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x000008D0) );
		/* 820A084Ch case    1:*/		return 0x820A0850;
		  /* 820A0850h */ case    2:  		/* lwz R3, <#[R26 + 2204]> */
		/* 820A0850h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x0000089C) );
		/* 820A0850h case    2:*/		return 0x820A0854;
		  /* 820A0854h */ case    3:  		/* bl 31140 */
		/* 820A0854h case    3:*/		regs.LR = 0x820A0858; return 0x820A81F8;
		/* 820A0854h case    3:*/		return 0x820A0858;
		  /* 820A0858h */ case    4:  		/* or. R31, R3, R3 */
		/* 820A0858h case    4:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A0858h case    4:*/		return 0x820A085C;
		  /* 820A085Ch */ case    5:  		/* bc 12, CR0_LT, -64 */
		/* 820A085Ch case    5:*/		if ( regs.CR[0].lt ) { return 0x820A081C;  }
		/* 820A085Ch case    5:*/		return 0x820A0860;
		  /* 820A0860h */ case    6:  		/* lwz R7, <#[R24]> */
		/* 820A0860h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R24 + 0x00000000) );
		/* 820A0860h case    6:*/		return 0x820A0864;
		  /* 820A0864h */ case    7:  		/* cmpwi CR6, R7, 16 */
		/* 820A0864h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000010);
		/* 820A0864h case    7:*/		return 0x820A0868;
		  /* 820A0868h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0868h case    8:*/		if ( regs.CR[6].eq ) { return 0x820A0874;  }
		/* 820A0868h case    8:*/		return 0x820A086C;
		  /* 820A086Ch */ case    9:  		/* cmpwi CR6, R7, 17 */
		/* 820A086Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000011);
		/* 820A086Ch case    9:*/		return 0x820A0870;
		  /* 820A0870h */ case   10:  		/* bc 4, CR6_EQ, -120 */
		/* 820A0870h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820A07F8;  }
		/* 820A0870h case   10:*/		return 0x820A0874;
	}
	return 0x820A0874;
} // Block from 820A0848h-820A0874h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A0874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0874);
		  /* 820A0874h */ case    0:  		/* li R27, 0 */
		/* 820A0874h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820A0874h case    0:*/		return 0x820A0878;
		  /* 820A0878h */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 820A0878h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820A0878h case    1:*/		return 0x820A087C;
		  /* 820A087Ch */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 820A087Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820A08B8;  }
		/* 820A087Ch case    2:*/		return 0x820A0880;
		  /* 820A0880h */ case    3:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A0880h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A0880h case    3:*/		return 0x820A0884;
		  /* 820A0884h */ case    4:  		/* addi R29, R26, 24 */
		/* 820A0884h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R26,0x18);
		/* 820A0884h case    4:*/		return 0x820A0888;
	}
	return 0x820A0888;
} // Block from 820A0874h-820A0888h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0888h
// Function '?DoError@CPreProcessor@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0888);
		  /* 820A0888h */ case    0:  		/* mr R30, R14 */
		/* 820A0888h case    0:*/		regs.R30 = regs.R14;
		/* 820A0888h case    0:*/		return 0x820A088C;
		  /* 820A088Ch */ case    1:  		/* subf R28, R14, R11 */
		/* 820A088Ch case    1:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R14,regs.R11);
		/* 820A088Ch case    1:*/		return 0x820A0890;
		  /* 820A0890h */ case    2:  		/* mr R3, R29 */
		/* 820A0890h case    2:*/		regs.R3 = regs.R29;
		/* 820A0890h case    2:*/		return 0x820A0894;
		  /* 820A0894h */ case    3:  		/* lwzx R5, <#[R28 + R30]> */
		/* 820A0894h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + regs.R30 + 0x00000000) );
		/* 820A0894h case    3:*/		return 0x820A0898;
		  /* 820A0898h */ case    4:  		/* lwz R4, <#[R30]> */
		/* 820A0898h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 820A0898h case    4:*/		return 0x820A089C;
		  /* 820A089Ch */ case    5:  		/* bl 25844 */
		/* 820A089Ch case    5:*/		regs.LR = 0x820A08A0; return 0x820A6D90;
		/* 820A089Ch case    5:*/		return 0x820A08A0;
		  /* 820A08A0h */ case    6:  		/* or. R31, R3, R3 */
		/* 820A08A0h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A08A0h case    6:*/		return 0x820A08A4;
		  /* 820A08A4h */ case    7:  		/* bc 12, CR0_LT, -136 */
		/* 820A08A4h case    7:*/		if ( regs.CR[0].lt ) { return 0x820A081C;  }
		/* 820A08A4h case    7:*/		return 0x820A08A8;
		  /* 820A08A8h */ case    8:  		/* addi R27, R27, 1 */
		/* 820A08A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820A08A8h case    8:*/		return 0x820A08AC;
		  /* 820A08ACh */ case    9:  		/* addi R30, R30, 4 */
		/* 820A08ACh case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820A08ACh case    9:*/		return 0x820A08B0;
		  /* 820A08B0h */ case   10:  		/* cmplw CR6, R27, R25 */
		/* 820A08B0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R25);
		/* 820A08B0h case   10:*/		return 0x820A08B4;
		  /* 820A08B4h */ case   11:  		/* bc 12, CR6_LT, -36 */
		/* 820A08B4h case   11:*/		if ( regs.CR[6].lt ) { return 0x820A0890;  }
		/* 820A08B4h case   11:*/		return 0x820A08B8;
	}
	return 0x820A08B8;
} // Block from 820A0888h-820A08B8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A08B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A08B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A08B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A08B8);
		  /* 820A08B8h */ case    0:  		/* li R31, 0 */
		/* 820A08B8h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820A08B8h case    0:*/		return 0x820A08BC;
		  /* 820A08BCh */ case    1:  		/* b -160 */
		/* 820A08BCh case    1:*/		return 0x820A081C;
		/* 820A08BCh case    1:*/		return 0x820A08C0;
	}
	return 0x820A08C0;
} // Block from 820A08B8h-820A08C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A08C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A08C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A08C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A08C0);
		  /* 820A08C0h */ case    0:  		/* lis R31, -32761 */
		/* 820A08C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820A08C0h case    0:*/		return 0x820A08C4;
		  /* 820A08C4h */ case    1:  		/* ori R31, R31, 14 */
		/* 820A08C4h case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820A08C4h case    1:*/		return 0x820A08C8;
		  /* 820A08C8h */ case    2:  		/* b -172 */
		/* 820A08C8h case    2:*/		return 0x820A081C;
		/* 820A08C8h case    2:*/		return 0x820A08CC;
		  /* 820A08CCh */ case    3:  		/* nop */
		/* 820A08CCh case    3:*/		cpu::op::nop();
		/* 820A08CCh case    3:*/		return 0x820A08D0;
		  /* 820A08D0h */ case    4:  		/* lis R10, 1586 */
		/* 820A08D0h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x632);
		/* 820A08D0h case    4:*/		return 0x820A08D4;
		  /* 820A08D4h */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 820A08D4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A08D4h case    5:*/		return 0x820A08D8;
		  /* 820A08D8h */ case    6:  		/* ori R10, R10, 55311 */
		/* 820A08D8h case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xD80F);
		/* 820A08D8h case    6:*/		return 0x820A08DC;
		  /* 820A08DCh */ case    7:  		/* bc 12, CR6_EQ, 56 */
		/* 820A08DCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820A0914;  }
		/* 820A08DCh case    7:*/		return 0x820A08E0;
		  /* 820A08E0h */ case    8:  		/* lbz R11, <#[R4]> */
		/* 820A08E0h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820A08E0h case    8:*/		return 0x820A08E4;
		  /* 820A08E4h */ case    9:  		/* extsb. R11, R11 */
		/* 820A08E4h case    9:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R11);
		/* 820A08E4h case    9:*/		return 0x820A08E8;
		  /* 820A08E8h */ case   10:  		/* bc 12, CR0_EQ, 44 */
		/* 820A08E8h case   10:*/		if ( regs.CR[0].eq ) { return 0x820A0914;  }
		/* 820A08E8h case   10:*/		return 0x820A08EC;
		  /* 820A08ECh */ case   11:  		/* mulli R10, R10, 19 */
		/* 820A08ECh case   11:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x13);
		/* 820A08ECh case   11:*/		return 0x820A08F0;
		  /* 820A08F0h */ case   12:  		/* lbzu R9, <#[R4 + 1]> */
		/* 820A08F0h case   12:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000001) );
		regs.R4 = (uint32)(regs.R4 + 0x00000001);
		/* 820A08F0h case   12:*/		return 0x820A08F4;
		  /* 820A08F4h */ case   13:  		/* add R10, R10, R11 */
		/* 820A08F4h case   13:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820A08F4h case   13:*/		return 0x820A08F8;
		  /* 820A08F8h */ case   14:  		/* extsb. R11, R9 */
		/* 820A08F8h case   14:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R9);
		/* 820A08F8h case   14:*/		return 0x820A08FC;
		  /* 820A08FCh */ case   15:  		/* bc 4, CR0_EQ, -16 */
		/* 820A08FCh case   15:*/		if ( !regs.CR[0].eq ) { return 0x820A08EC;  }
		/* 820A08FCh case   15:*/		return 0x820A0900;
		  /* 820A0900h */ case   16:  		/* li R11, 127 */
		/* 820A0900h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x7F);
		/* 820A0900h case   16:*/		return 0x820A0904;
		  /* 820A0904h */ case   17:  		/* divwu R11, R10, R11 */
		/* 820A0904h case   17:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A0904h case   17:*/		return 0x820A0908;
		  /* 820A0908h */ case   18:  		/* mulli R11, R11, 127 */
		/* 820A0908h case   18:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x7F);
		/* 820A0908h case   18:*/		return 0x820A090C;
		  /* 820A090Ch */ case   19:  		/* subf R3, R11, R10 */
		/* 820A090Ch case   19:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820A090Ch case   19:*/		return 0x820A0910;
		  /* 820A0910h */ case   20:  		/* bclr 20, CR0_LT */
		/* 820A0910h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A0910h case   20:*/		return 0x820A0914;
	}
	return 0x820A0914;
} // Block from 820A08C0h-820A0914h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820A0914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0914);
		  /* 820A0914h */ case    0:  		/* li R3, 0 */
		/* 820A0914h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A0914h case    0:*/		return 0x820A0918;
		  /* 820A0918h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820A0918h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A0918h case    1:*/		return 0x820A091C;
	}
	return 0x820A091C;
} // Block from 820A0914h-820A091Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A091Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A091C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A091C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A091C);
		  /* 820A091Ch */ case    0:  		/* nop */
		/* 820A091Ch case    0:*/		cpu::op::nop();
		/* 820A091Ch case    0:*/		return 0x820A0920;
	}
	return 0x820A0920;
} // Block from 820A091Ch-820A0920h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0920);
		  /* 820A0920h */ case    0:  		/* mfspr R12, LR */
		/* 820A0920h case    0:*/		regs.R12 = regs.LR;
		/* 820A0920h case    0:*/		return 0x820A0924;
		  /* 820A0924h */ case    1:  		/* bl -63176 */
		/* 820A0924h case    1:*/		regs.LR = 0x820A0928; return 0x8209125C;
		/* 820A0924h case    1:*/		return 0x820A0928;
		  /* 820A0928h */ case    2:  		/* lwz R10, <#[R5]> */
		/* 820A0928h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 820A0928h case    2:*/		return 0x820A092C;
		  /* 820A092Ch */ case    3:  		/* lwz R11, <#[R4]> */
		/* 820A092Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820A092Ch case    3:*/		return 0x820A0930;
		  /* 820A0930h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820A0930h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0930h case    4:*/		return 0x820A0934;
		  /* 820A0934h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820A0934h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0934h case    5:*/		return 0x820A0938;
		  /* 820A0938h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820A0938h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0938h case    6:*/		return 0x820A093C;
		  /* 820A093Ch */ case    7:  		/* subf R9, R8, R9 */
		/* 820A093Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A093Ch case    7:*/		return 0x820A0940;
		  /* 820A0940h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820A0940h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A0954;  }
		/* 820A0940h case    8:*/		return 0x820A0944;
		  /* 820A0944h */ case    9:  		/* addi R11, R11, 1 */
		/* 820A0944h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0944h case    9:*/		return 0x820A0948;
		  /* 820A0948h */ case   10:  		/* addi R10, R10, 1 */
		/* 820A0948h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0948h case   10:*/		return 0x820A094C;
		  /* 820A094Ch */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820A094Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A094Ch case   11:*/		return 0x820A0950;
		  /* 820A0950h */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0950h case   12:*/		if ( regs.CR[6].eq ) { return 0x820A0930;  }
		/* 820A0950h case   12:*/		return 0x820A0954;
	}
	return 0x820A0954;
} // Block from 820A0920h-820A0954h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A0954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0954);
		  /* 820A0954h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0954h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0954h case    0:*/		return 0x820A0958;
		  /* 820A0958h */ case    1:  		/* bc 4, CR0_EQ, 628 */
		/* 820A0958h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A0BCC;  }
		/* 820A0958h case    1:*/		return 0x820A095C;
		  /* 820A095Ch */ case    2:  		/* lwz R31, <#[R4 + 4]> */
		/* 820A095Ch case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000004) );
		/* 820A095Ch case    2:*/		return 0x820A0960;
		  /* 820A0960h */ case    3:  		/* lwz R30, <#[R5 + 4]> */
		/* 820A0960h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R5 + 0x00000004) );
		/* 820A0960h case    3:*/		return 0x820A0964;
		  /* 820A0964h */ case    4:  		/* mr R11, R31 */
		/* 820A0964h case    4:*/		regs.R11 = regs.R31;
		/* 820A0964h case    4:*/		return 0x820A0968;
		  /* 820A0968h */ case    5:  		/* mr R10, R30 */
		/* 820A0968h case    5:*/		regs.R10 = regs.R30;
		/* 820A0968h case    5:*/		return 0x820A096C;
		  /* 820A096Ch */ case    6:  		/* cmplwi CR0, R31, 0 */
		/* 820A096Ch case    6:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820A096Ch case    6:*/		return 0x820A0970;
		  /* 820A0970h */ case    7:  		/* bc 12, CR0_EQ, 36 */
		/* 820A0970h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A0994;  }
		/* 820A0970h case    7:*/		return 0x820A0974;
		  /* 820A0974h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 820A0974h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A0974h case    8:*/		return 0x820A0978;
		  /* 820A0978h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 820A0978h case    9:*/		if ( regs.CR[6].eq ) { return 0x820A098C;  }
		/* 820A0978h case    9:*/		return 0x820A097C;
		  /* 820A097Ch */ case   10:  		/* lwz R11, <#[R11 + 12]> */
		/* 820A097Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A097Ch case   10:*/		return 0x820A0980;
		  /* 820A0980h */ case   11:  		/* lwz R10, <#[R10 + 12]> */
		/* 820A0980h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820A0980h case   11:*/		return 0x820A0984;
		  /* 820A0984h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 820A0984h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A0984h case   12:*/		return 0x820A0988;
		  /* 820A0988h */ case   13:  		/* bc 4, CR6_EQ, -20 */
		/* 820A0988h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A0974;  }
		/* 820A0988h case   13:*/		return 0x820A098C;
	}
	return 0x820A098C;
} // Block from 820A0954h-820A098Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A098Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A098C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A098C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A098C);
		  /* 820A098Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820A098Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A098Ch case    0:*/		return 0x820A0990;
		  /* 820A0990h */ case    1:  		/* bc 4, CR6_EQ, 572 */
		/* 820A0990h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A0BCC;  }
		/* 820A0990h case    1:*/		return 0x820A0994;
	}
	return 0x820A0994;
} // Block from 820A098Ch-820A0994h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0994);
		  /* 820A0994h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820A0994h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A0994h case    0:*/		return 0x820A0998;
		  /* 820A0998h */ case    1:  		/* bc 4, CR6_EQ, 564 */
		/* 820A0998h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A0BCC;  }
		/* 820A0998h case    1:*/		return 0x820A099C;
		  /* 820A099Ch */ case    2:  		/* lwz R4, <#[R4 + 8]> */
		/* 820A099Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000008) );
		/* 820A099Ch case    2:*/		return 0x820A09A0;
		  /* 820A09A0h */ case    3:  		/* lwz R3, <#[R5 + 8]> */
		/* 820A09A0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R5 + 0x00000008) );
		/* 820A09A0h case    3:*/		return 0x820A09A4;
		  /* 820A09A4h */ case    4:  		/* b 532 */
		/* 820A09A4h case    4:*/		return 0x820A0BB8;
		/* 820A09A4h case    4:*/		return 0x820A09A8;
		  /* 820A09A8h */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 820A09A8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A09A8h case    5:*/		return 0x820A09AC;
		  /* 820A09ACh */ case    6:  		/* bc 12, CR6_EQ, 544 */
		/* 820A09ACh case    6:*/		if ( regs.CR[6].eq ) { return 0x820A0BCC;  }
		/* 820A09ACh case    6:*/		return 0x820A09B0;
		  /* 820A09B0h */ case    7:  		/* lwz R11, <#[R4 + 16]> */
		/* 820A09B0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 820A09B0h case    7:*/		return 0x820A09B4;
		  /* 820A09B4h */ case    8:  		/* lwz R10, <#[R3 + 16]> */
		/* 820A09B4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 820A09B4h case    8:*/		return 0x820A09B8;
		  /* 820A09B8h */ case    9:  		/* cmpw CR6, R11, R10 */
		/* 820A09B8h case    9:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820A09B8h case    9:*/		return 0x820A09BC;
		  /* 820A09BCh */ case   10:  		/* bc 4, CR6_EQ, 528 */
		/* 820A09BCh case   10:*/		if ( !regs.CR[6].eq ) { return 0x820A0BCC;  }
		/* 820A09BCh case   10:*/		return 0x820A09C0;
		  /* 820A09C0h */ case   11:  		/* cmplwi CR6, R11, 13 */
		/* 820A09C0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000D);
		/* 820A09C0h case   11:*/		return 0x820A09C4;
		  /* 820A09C4h */ case   12:  		/* bc 12, CR6_GT, 480 */
		/* 820A09C4h case   12:*/		if ( regs.CR[6].gt ) { return 0x820A0BA4;  }
		/* 820A09C4h case   12:*/		return 0x820A09C8;
		  /* 820A09C8h */ case   13:  		/* lis R12, -32255 */
		/* 820A09C8h case   13:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820A09C8h case   13:*/		return 0x820A09CC;
		  /* 820A09CCh */ case   14:  		/* addi R12, R12, -11168 */
		/* 820A09CCh case   14:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFD460);
		/* 820A09CCh case   14:*/		return 0x820A09D0;
		  /* 820A09D0h */ case   15:  		/* lbzx R0, <#[R12 + R11]> */
		/* 820A09D0h case   15:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 820A09D0h case   15:*/		return 0x820A09D4;
		  /* 820A09D4h */ case   16:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 820A09D4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 820A09D4h case   16:*/		return 0x820A09D8;
		  /* 820A09D8h */ case   17:  		/* lis R12, -32246 */
		/* 820A09D8h case   17:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820A);
		/* 820A09D8h case   17:*/		return 0x820A09DC;
		  /* 820A09DCh */ case   18:  		/* ori R0, R0, 0 */
		/* 820A09DCh case   18:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820A09DCh case   18:*/		return 0x820A09E0;
		  /* 820A09E0h */ case   19:  		/* addi R12, R12, 2544 */
		/* 820A09E0h case   19:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x9F0);
		/* 820A09E0h case   19:*/		return 0x820A09E4;
		  /* 820A09E4h */ case   20:  		/* add R12, R12, R0 */
		/* 820A09E4h case   20:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820A09E4h case   20:*/		return 0x820A09E8;
		  /* 820A09E8h */ case   21:  		/* mtspr CTR, R12 */
		/* 820A09E8h case   21:*/		regs.CTR = regs.R12;
		/* 820A09E8h case   21:*/		return 0x820A09EC;
		  /* 820A09ECh */ case   22:  		/* bcctr 20, CR0_LT */
		/* 820A09ECh case   22:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820A09ECh case   22:*/		return 0x820A09F0;
	}
	return 0x820A09F0;
} // Block from 820A0994h-820A09F0h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820A09F0h
// Function '?DoElif@CPreProcessor@D3DXShader@@IAAJH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A09F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A09F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A09F0);
		  /* 820A09F0h */ case    0:  		/* lwz R11, <#[R4 + 24]> */
		/* 820A09F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 820A09F0h case    0:*/		return 0x820A09F4;
		  /* 820A09F4h */ case    1:  		/* lwz R10, <#[R3 + 24]> */
		/* 820A09F4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820A09F4h case    1:*/		return 0x820A09F8;
		  /* 820A09F8h */ case    2:  		/* subf R11, R11, R10 */
		/* 820A09F8h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A09F8h case    2:*/		return 0x820A09FC;
		  /* 820A09FCh */ case    3:  		/* cntlzw R11, R11 */
		/* 820A09FCh case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820A09FCh case    3:*/		return 0x820A0A00;
		  /* 820A0A00h */ case    4:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 820A0A00h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820A0A00h case    4:*/		return 0x820A0A04;
		  /* 820A0A04h */ case    5:  		/* b 420 */
		/* 820A0A04h case    5:*/		return 0x820A0BA8;
		/* 820A0A04h case    5:*/		return 0x820A0A08;
		  /* 820A0A08h */ case    6:  		/* lbz R11, <#[R3 + 24]> */
		/* 820A0A08h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820A0A08h case    6:*/		return 0x820A0A0C;
		  /* 820A0A0Ch */ case    7:  		/* lbz R10, <#[R4 + 24]> */
		/* 820A0A0Ch case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 820A0A0Ch case    7:*/		return 0x820A0A10;
		  /* 820A0A10h */ case    8:  		/* cmplw CR6, R10, R11 */
		/* 820A0A10h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820A0A10h case    8:*/		return 0x820A0A14;
		  /* 820A0A14h */ case    9:  		/* bc 4, CR6_EQ, 440 */
		/* 820A0A14h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A0BCC;  }
		/* 820A0A14h case    9:*/		return 0x820A0A18;
		  /* 820A0A18h */ case   10:  		/* lbz R11, <#[R3 + 25]> */
		/* 820A0A18h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000019) );
		/* 820A0A18h case   10:*/		return 0x820A0A1C;
		  /* 820A0A1Ch */ case   11:  		/* lbz R10, <#[R4 + 25]> */
		/* 820A0A1Ch case   11:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000019) );
		/* 820A0A1Ch case   11:*/		return 0x820A0A20;
		  /* 820A0A20h */ case   12:  		/* cmplw CR6, R10, R11 */
		/* 820A0A20h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820A0A20h case   12:*/		return 0x820A0A24;
		  /* 820A0A24h */ case   13:  		/* bc 4, CR6_EQ, 424 */
		/* 820A0A24h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A0BCC;  }
		/* 820A0A24h case   13:*/		return 0x820A0A28;
		  /* 820A0A28h */ case   14:  		/* lbz R11, <#[R3 + 26]> */
		/* 820A0A28h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001A) );
		/* 820A0A28h case   14:*/		return 0x820A0A2C;
		  /* 820A0A2Ch */ case   15:  		/* lbz R10, <#[R4 + 26]> */
		/* 820A0A2Ch case   15:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001A) );
		/* 820A0A2Ch case   15:*/		return 0x820A0A30;
		  /* 820A0A30h */ case   16:  		/* cmplw CR6, R10, R11 */
		/* 820A0A30h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820A0A30h case   16:*/		return 0x820A0A34;
		  /* 820A0A34h */ case   17:  		/* bc 4, CR6_EQ, 408 */
		/* 820A0A34h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820A0BCC;  }
		/* 820A0A34h case   17:*/		return 0x820A0A38;
		  /* 820A0A38h */ case   18:  		/* lbz R11, <#[R3 + 27]> */
		/* 820A0A38h case   18:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001B) );
		/* 820A0A38h case   18:*/		return 0x820A0A3C;
		  /* 820A0A3Ch */ case   19:  		/* lbz R10, <#[R4 + 27]> */
		/* 820A0A3Ch case   19:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001B) );
		/* 820A0A3Ch case   19:*/		return 0x820A0A40;
		  /* 820A0A40h */ case   20:  		/* cmplw CR6, R10, R11 */
		/* 820A0A40h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820A0A40h case   20:*/		return 0x820A0A44;
		  /* 820A0A44h */ case   21:  		/* bc 4, CR6_EQ, 392 */
		/* 820A0A44h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820A0BCC;  }
		/* 820A0A44h case   21:*/		return 0x820A0A48;
		  /* 820A0A48h */ case   22:  		/* b 360 */
		/* 820A0A48h case   22:*/		return 0x820A0BB0;
		/* 820A0A48h case   22:*/		return 0x820A0A4C;
		  /* 820A0A4Ch */ case   23:  		/* ld R11, <#[R4 + 24]> */
		/* 820A0A4Ch case   23:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 820A0A4Ch case   23:*/		return 0x820A0A50;
		  /* 820A0A50h */ case   24:  		/* ld R10, <#[R3 + 24]> */
		/* 820A0A50h case   24:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820A0A50h case   24:*/		return 0x820A0A54;
		  /* 820A0A54h */ case   25:  		/* cmpld CR6, R11, R10 */
		/* 820A0A54h case   25:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R10);
		/* 820A0A54h case   25:*/		return 0x820A0A58;
		  /* 820A0A58h */ case   26:  		/* b -20 */
		/* 820A0A58h case   26:*/		return 0x820A0A44;
		/* 820A0A58h case   26:*/		return 0x820A0A5C;
		  /* 820A0A5Ch */ case   27:  		/* lfd FR0, <#[R4 + 24]> */
		/* 820A0A5Ch case   27:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R4 + 0x00000018) );
		/* 820A0A5Ch case   27:*/		return 0x820A0A60;
		  /* 820A0A60h */ case   28:  		/* lfd FR13, <#[R3 + 24]> */
		/* 820A0A60h case   28:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R3 + 0x00000018) );
		/* 820A0A60h case   28:*/		return 0x820A0A64;
		  /* 820A0A64h */ case   29:  		/* fcmpu CR6, FR0, FR13 */
		/* 820A0A64h case   29:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820A0A64h case   29:*/		return 0x820A0A68;
		  /* 820A0A68h */ case   30:  		/* b -36 */
		/* 820A0A68h case   30:*/		return 0x820A0A44;
		/* 820A0A68h case   30:*/		return 0x820A0A6C;
		  /* 820A0A6Ch */ case   31:  		/* li R5, 0 */
		/* 820A0A6Ch case   31:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A0A6Ch case   31:*/		return 0x820A0A70;
		  /* 820A0A70h */ case   32:  		/* mr R8, R31 */
		/* 820A0A70h case   32:*/		regs.R8 = regs.R31;
		/* 820A0A70h case   32:*/		return 0x820A0A74;
		  /* 820A0A74h */ case   33:  		/* li R7, 1 */
		/* 820A0A74h case   33:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820A0A74h case   33:*/		return 0x820A0A78;
		  /* 820A0A78h */ case   34:  		/* cmplwi CR0, R31, 0 */
		/* 820A0A78h case   34:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820A0A78h case   34:*/		return 0x820A0A7C;
		  /* 820A0A7Ch */ case   35:  		/* bc 12, CR0_EQ, 84 */
		/* 820A0A7Ch case   35:*/		if ( regs.CR[0].eq ) { return 0x820A0AD0;  }
		/* 820A0A7Ch case   35:*/		return 0x820A0A80;
		  /* 820A0A80h */ case   36:  		/* lwz R6, <#[R4 + 24]> */
		/* 820A0A80h case   36:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R4 + 0x00000018) );
		/* 820A0A80h case   36:*/		return 0x820A0A84;
		  /* 820A0A84h */ case   37:  		/* lwz R10, <#[R8 + 24]> */
		/* 820A0A84h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000018) );
		/* 820A0A84h case   37:*/		return 0x820A0A88;
		  /* 820A0A88h */ case   38:  		/* mr R11, R6 */
		/* 820A0A88h case   38:*/		regs.R11 = regs.R6;
		/* 820A0A88h case   38:*/		return 0x820A0A8C;
		  /* 820A0A8Ch */ case   39:  		/* lbz R9, <#[R11]> */
		/* 820A0A8Ch case   39:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0A8Ch case   39:*/		return 0x820A0A90;
		  /* 820A0A90h */ case   40:  		/* lbz R29, <#[R10]> */
		/* 820A0A90h case   40:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0A90h case   40:*/		return 0x820A0A94;
		  /* 820A0A94h */ case   41:  		/* cmpwi CR0, R9, 0 */
		/* 820A0A94h case   41:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0A94h case   41:*/		return 0x820A0A98;
		  /* 820A0A98h */ case   42:  		/* subf R9, R29, R9 */
		/* 820A0A98h case   42:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 820A0A98h case   42:*/		return 0x820A0A9C;
		  /* 820A0A9Ch */ case   43:  		/* bc 12, CR0_EQ, 20 */
		/* 820A0A9Ch case   43:*/		if ( regs.CR[0].eq ) { return 0x820A0AB0;  }
		/* 820A0A9Ch case   43:*/		return 0x820A0AA0;
		  /* 820A0AA0h */ case   44:  		/* addi R11, R11, 1 */
		/* 820A0AA0h case   44:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0AA0h case   44:*/		return 0x820A0AA4;
		  /* 820A0AA4h */ case   45:  		/* addi R10, R10, 1 */
		/* 820A0AA4h case   45:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0AA4h case   45:*/		return 0x820A0AA8;
		  /* 820A0AA8h */ case   46:  		/* cmpwi CR6, R9, 0 */
		/* 820A0AA8h case   46:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0AA8h case   46:*/		return 0x820A0AAC;
		  /* 820A0AACh */ case   47:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0AACh case   47:*/		if ( regs.CR[6].eq ) { return 0x820A0A8C;  }
		/* 820A0AACh case   47:*/		return 0x820A0AB0;
	}
	return 0x820A0AB0;
} // Block from 820A09F0h-820A0AB0h (48 instructions)

//////////////////////////////////////////////////////
// Block at 820A0AB0h
// Function '?DoElse@CPreProcessor@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0AB0);
		  /* 820A0AB0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0AB0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0AB0h case    0:*/		return 0x820A0AB4;
		  /* 820A0AB4h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820A0AB4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A0ACC;  }
		/* 820A0AB4h case    1:*/		return 0x820A0AB8;
		  /* 820A0AB8h */ case    2:  		/* lwz R8, <#[R8 + 12]> */
		/* 820A0AB8h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 820A0AB8h case    2:*/		return 0x820A0ABC;
		  /* 820A0ABCh */ case    3:  		/* addi R7, R7, 1 */
		/* 820A0ABCh case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820A0ABCh case    3:*/		return 0x820A0AC0;
		  /* 820A0AC0h */ case    4:  		/* cmplwi CR6, R8, 0 */
		/* 820A0AC0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820A0AC0h case    4:*/		return 0x820A0AC4;
		  /* 820A0AC4h */ case    5:  		/* bc 4, CR6_EQ, -64 */
		/* 820A0AC4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A0A84;  }
		/* 820A0AC4h case    5:*/		return 0x820A0AC8;
		  /* 820A0AC8h */ case    6:  		/* b 8 */
		/* 820A0AC8h case    6:*/		return 0x820A0AD0;
		/* 820A0AC8h case    6:*/		return 0x820A0ACC;
	}
	return 0x820A0ACC;
} // Block from 820A0AB0h-820A0ACCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A0ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0ACC);
		  /* 820A0ACCh */ case    0:  		/* li R5, 1 */
		/* 820A0ACCh case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A0ACCh case    0:*/		return 0x820A0AD0;
	}
	return 0x820A0AD0;
} // Block from 820A0ACCh-820A0AD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0AD0);
		  /* 820A0AD0h */ case    0:  		/* mr R8, R30 */
		/* 820A0AD0h case    0:*/		regs.R8 = regs.R30;
		/* 820A0AD0h case    0:*/		return 0x820A0AD4;
		  /* 820A0AD4h */ case    1:  		/* addi R6, R7, -1 */
		/* 820A0AD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R7,0xFFFFFFFF);
		/* 820A0AD4h case    1:*/		return 0x820A0AD8;
		  /* 820A0AD8h */ case    2:  		/* cmplwi CR0, R30, 0 */
		/* 820A0AD8h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820A0AD8h case    2:*/		return 0x820A0ADC;
		  /* 820A0ADCh */ case    3:  		/* bc 12, CR0_EQ, 84 */
		/* 820A0ADCh case    3:*/		if ( regs.CR[0].eq ) { return 0x820A0B30;  }
		/* 820A0ADCh case    3:*/		return 0x820A0AE0;
		  /* 820A0AE0h */ case    4:  		/* lwz R7, <#[R3 + 24]> */
		/* 820A0AE0h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000018) );
		/* 820A0AE0h case    4:*/		return 0x820A0AE4;
		  /* 820A0AE4h */ case    5:  		/* lwz R10, <#[R8 + 24]> */
		/* 820A0AE4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000018) );
		/* 820A0AE4h case    5:*/		return 0x820A0AE8;
		  /* 820A0AE8h */ case    6:  		/* mr R11, R7 */
		/* 820A0AE8h case    6:*/		regs.R11 = regs.R7;
		/* 820A0AE8h case    6:*/		return 0x820A0AEC;
		  /* 820A0AECh */ case    7:  		/* lbz R9, <#[R11]> */
		/* 820A0AECh case    7:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0AECh case    7:*/		return 0x820A0AF0;
		  /* 820A0AF0h */ case    8:  		/* lbz R29, <#[R10]> */
		/* 820A0AF0h case    8:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0AF0h case    8:*/		return 0x820A0AF4;
		  /* 820A0AF4h */ case    9:  		/* cmpwi CR0, R9, 0 */
		/* 820A0AF4h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0AF4h case    9:*/		return 0x820A0AF8;
		  /* 820A0AF8h */ case   10:  		/* subf R9, R29, R9 */
		/* 820A0AF8h case   10:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 820A0AF8h case   10:*/		return 0x820A0AFC;
		  /* 820A0AFCh */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 820A0AFCh case   11:*/		if ( regs.CR[0].eq ) { return 0x820A0B10;  }
		/* 820A0AFCh case   11:*/		return 0x820A0B00;
		  /* 820A0B00h */ case   12:  		/* addi R11, R11, 1 */
		/* 820A0B00h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0B00h case   12:*/		return 0x820A0B04;
		  /* 820A0B04h */ case   13:  		/* addi R10, R10, 1 */
		/* 820A0B04h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0B04h case   13:*/		return 0x820A0B08;
		  /* 820A0B08h */ case   14:  		/* cmpwi CR6, R9, 0 */
		/* 820A0B08h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0B08h case   14:*/		return 0x820A0B0C;
		  /* 820A0B0Ch */ case   15:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0B0Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820A0AEC;  }
		/* 820A0B0Ch case   15:*/		return 0x820A0B10;
	}
	return 0x820A0B10;
} // Block from 820A0AD0h-820A0B10h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A0B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0B10);
		  /* 820A0B10h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0B10h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0B10h case    0:*/		return 0x820A0B14;
		  /* 820A0B14h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820A0B14h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A0B2C;  }
		/* 820A0B14h case    1:*/		return 0x820A0B18;
		  /* 820A0B18h */ case    2:  		/* lwz R8, <#[R8 + 12]> */
		/* 820A0B18h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 820A0B18h case    2:*/		return 0x820A0B1C;
		  /* 820A0B1Ch */ case    3:  		/* addi R6, R6, -1 */
		/* 820A0B1Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 820A0B1Ch case    3:*/		return 0x820A0B20;
		  /* 820A0B20h */ case    4:  		/* cmplwi CR6, R8, 0 */
		/* 820A0B20h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820A0B20h case    4:*/		return 0x820A0B24;
		  /* 820A0B24h */ case    5:  		/* bc 4, CR6_EQ, -64 */
		/* 820A0B24h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A0AE4;  }
		/* 820A0B24h case    5:*/		return 0x820A0B28;
		  /* 820A0B28h */ case    6:  		/* b 8 */
		/* 820A0B28h case    6:*/		return 0x820A0B30;
		/* 820A0B28h case    6:*/		return 0x820A0B2C;
	}
	return 0x820A0B2C;
} // Block from 820A0B10h-820A0B2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A0B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0B2C);
		  /* 820A0B2Ch */ case    0:  		/* li R5, 1 */
		/* 820A0B2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A0B2Ch case    0:*/		return 0x820A0B30;
	}
	return 0x820A0B30;
} // Block from 820A0B2Ch-820A0B30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0B30);
		  /* 820A0B30h */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 820A0B30h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 820A0B30h case    0:*/		return 0x820A0B34;
		  /* 820A0B34h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0B34h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A0B40;  }
		/* 820A0B34h case    1:*/		return 0x820A0B38;
		  /* 820A0B38h */ case    2:  		/* addi R11, R6, 0 */
		/* 820A0B38h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0x0);
		/* 820A0B38h case    2:*/		return 0x820A0B3C;
		  /* 820A0B3Ch */ case    3:  		/* b -320 */
		/* 820A0B3Ch case    3:*/		return 0x820A09FC;
		/* 820A0B3Ch case    3:*/		return 0x820A0B40;
	}
	return 0x820A0B40;
} // Block from 820A0B30h-820A0B40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0B40);
		  /* 820A0B40h */ case    0:  		/* lwz R10, <#[R3 + 24]> */
		/* 820A0B40h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820A0B40h case    0:*/		return 0x820A0B44;
		  /* 820A0B44h */ case    1:  		/* lwz R11, <#[R4 + 24]> */
		/* 820A0B44h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 820A0B44h case    1:*/		return 0x820A0B48;
		  /* 820A0B48h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A0B48h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0B48h case    2:*/		return 0x820A0B4C;
		  /* 820A0B4Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A0B4Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0B4Ch case    3:*/		return 0x820A0B50;
		  /* 820A0B50h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A0B50h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0B50h case    4:*/		return 0x820A0B54;
		  /* 820A0B54h */ case    5:  		/* subf R9, R8, R9 */
		/* 820A0B54h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A0B54h case    5:*/		return 0x820A0B58;
		  /* 820A0B58h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820A0B58h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A0B6C;  }
		/* 820A0B58h case    6:*/		return 0x820A0B5C;
		  /* 820A0B5Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820A0B5Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0B5Ch case    7:*/		return 0x820A0B60;
		  /* 820A0B60h */ case    8:  		/* addi R10, R10, 1 */
		/* 820A0B60h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0B60h case    8:*/		return 0x820A0B64;
		  /* 820A0B64h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820A0B64h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0B64h case    9:*/		return 0x820A0B68;
	}
	return 0x820A0B68;
} // Block from 820A0B40h-820A0B68h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A0B68h
// Function '?DoPragmaPackMatrix@CPreProcessor@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0B68);
		  /* 820A0B68h */ case    0:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0B68h case    0:*/		if ( regs.CR[6].eq ) { return 0x820A0B48;  }
		/* 820A0B68h case    0:*/		return 0x820A0B6C;
	}
	return 0x820A0B6C;
} // Block from 820A0B68h-820A0B6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0B6C);
		  /* 820A0B6Ch */ case    0:  		/* cntlzw R11, R9 */
		/* 820A0B6Ch case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R9);
		/* 820A0B6Ch case    0:*/		return 0x820A0B70;
		  /* 820A0B70h */ case    1:  		/* b -368 */
		/* 820A0B70h case    1:*/		return 0x820A0A00;
		/* 820A0B70h case    1:*/		return 0x820A0B74;
		  /* 820A0B74h */ case    2:  		/* lwz R10, <#[R3 + 24]> */
		/* 820A0B74h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820A0B74h case    2:*/		return 0x820A0B78;
		  /* 820A0B78h */ case    3:  		/* lwz R11, <#[R4 + 24]> */
		/* 820A0B78h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 820A0B78h case    3:*/		return 0x820A0B7C;
		  /* 820A0B7Ch */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820A0B7Ch case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0B7Ch case    4:*/		return 0x820A0B80;
		  /* 820A0B80h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820A0B80h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0B80h case    5:*/		return 0x820A0B84;
		  /* 820A0B84h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820A0B84h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0B84h case    6:*/		return 0x820A0B88;
		  /* 820A0B88h */ case    7:  		/* subf R9, R8, R9 */
		/* 820A0B88h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A0B88h case    7:*/		return 0x820A0B8C;
		  /* 820A0B8Ch */ case    8:  		/* bc 12, CR0_EQ, -32 */
		/* 820A0B8Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x820A0B6C;  }
		/* 820A0B8Ch case    8:*/		return 0x820A0B90;
		  /* 820A0B90h */ case    9:  		/* addi R11, R11, 1 */
		/* 820A0B90h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0B90h case    9:*/		return 0x820A0B94;
		  /* 820A0B94h */ case   10:  		/* addi R10, R10, 1 */
		/* 820A0B94h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0B94h case   10:*/		return 0x820A0B98;
		  /* 820A0B98h */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820A0B98h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0B98h case   11:*/		return 0x820A0B9C;
		  /* 820A0B9Ch */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0B9Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820A0B7C;  }
		/* 820A0B9Ch case   12:*/		return 0x820A0BA0;
		  /* 820A0BA0h */ case   13:  		/* b -52 */
		/* 820A0BA0h case   13:*/		return 0x820A0B6C;
		/* 820A0BA0h case   13:*/		return 0x820A0BA4;
	}
	return 0x820A0BA4;
} // Block from 820A0B6Ch-820A0BA4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A0BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0BA4);
		  /* 820A0BA4h */ case    0:  		/* li R11, 1 */
		/* 820A0BA4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A0BA4h case    0:*/		return 0x820A0BA8;
	}
	return 0x820A0BA8;
} // Block from 820A0BA4h-820A0BA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0BA8);
		  /* 820A0BA8h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 820A0BA8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A0BA8h case    0:*/		return 0x820A0BAC;
		  /* 820A0BACh */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820A0BACh case    1:*/		if ( regs.CR[6].eq ) { return 0x820A0BCC;  }
		/* 820A0BACh case    1:*/		return 0x820A0BB0;
	}
	return 0x820A0BB0;
} // Block from 820A0BA8h-820A0BB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0BB0);
		  /* 820A0BB0h */ case    0:  		/* lwz R4, <#[R4 + 12]> */
		/* 820A0BB0h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x0000000C) );
		/* 820A0BB0h case    0:*/		return 0x820A0BB4;
		  /* 820A0BB4h */ case    1:  		/* lwz R3, <#[R3 + 12]> */
		/* 820A0BB4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A0BB4h case    1:*/		return 0x820A0BB8;
	}
	return 0x820A0BB8;
} // Block from 820A0BB0h-820A0BB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0BB8);
		  /* 820A0BB8h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820A0BB8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A0BB8h case    0:*/		return 0x820A0BBC;
		  /* 820A0BBCh */ case    1:  		/* bc 4, CR6_EQ, -532 */
		/* 820A0BBCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A09A8;  }
		/* 820A0BBCh case    1:*/		return 0x820A0BC0;
		  /* 820A0BC0h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 820A0BC0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A0BC0h case    2:*/		return 0x820A0BC4;
		  /* 820A0BC4h */ case    3:  		/* li R3, 1 */
		/* 820A0BC4h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820A0BC4h case    3:*/		return 0x820A0BC8;
		  /* 820A0BC8h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 820A0BC8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A0BD0;  }
		/* 820A0BC8h case    4:*/		return 0x820A0BCC;
	}
	return 0x820A0BCC;
} // Block from 820A0BB8h-820A0BCCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0BCC);
		  /* 820A0BCCh */ case    0:  		/* li R3, 0 */
		/* 820A0BCCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A0BCCh case    0:*/		return 0x820A0BD0;
	}
	return 0x820A0BD0;
} // Block from 820A0BCCh-820A0BD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0BD0);
		  /* 820A0BD0h */ case    0:  		/* b -63780 */
		/* 820A0BD0h case    0:*/		return 0x820912AC;
		/* 820A0BD0h case    0:*/		return 0x820A0BD4;
		  /* 820A0BD4h */ case    1:  		/* nop */
		/* 820A0BD4h case    1:*/		cpu::op::nop();
		/* 820A0BD4h case    1:*/		return 0x820A0BD8;
		  /* 820A0BD8h */ case    2:  		/* lwz R3, <#[R3 + 2204]> */
		/* 820A0BD8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000089C) );
		/* 820A0BD8h case    2:*/		return 0x820A0BDC;
		  /* 820A0BDCh */ case    3:  		/* b 21660 */
		/* 820A0BDCh case    3:*/		return 0x820A6078;
		/* 820A0BDCh case    3:*/		return 0x820A0BE0;
	}
	return 0x820A0BE0;
} // Block from 820A0BD0h-820A0BE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0BE0);
		  /* 820A0BE0h */ case    0:  		/* mfspr R12, LR */
		/* 820A0BE0h case    0:*/		regs.R12 = regs.LR;
		/* 820A0BE0h case    0:*/		return 0x820A0BE4;
		  /* 820A0BE4h */ case    1:  		/* bl -63880 */
		/* 820A0BE4h case    1:*/		regs.LR = 0x820A0BE8; return 0x8209125C;
		/* 820A0BE4h case    1:*/		return 0x820A0BE8;
		  /* 820A0BE8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A0BE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A0BE8h case    2:*/		return 0x820A0BEC;
		  /* 820A0BECh */ case    3:  		/* mr R29, R3 */
		/* 820A0BECh case    3:*/		regs.R29 = regs.R3;
		/* 820A0BECh case    3:*/		return 0x820A0BF0;
		  /* 820A0BF0h */ case    4:  		/* mr R8, R4 */
		/* 820A0BF0h case    4:*/		regs.R8 = regs.R4;
		/* 820A0BF0h case    4:*/		return 0x820A0BF4;
		  /* 820A0BF4h */ case    5:  		/* bl -804 */
		/* 820A0BF4h case    5:*/		regs.LR = 0x820A0BF8; return 0x820A08D0;
		/* 820A0BF4h case    5:*/		return 0x820A0BF8;
		  /* 820A0BF8h */ case    6:  		/* addi R11, R3, 421 */
		/* 820A0BF8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1A5);
		/* 820A0BF8h case    6:*/		return 0x820A0BFC;
		  /* 820A0BFCh */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820A0BFCh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820A0BFCh case    7:*/		return 0x820A0C00;
		  /* 820A0C00h */ case    8:  		/* lwzx R30, <#[R11 + R29]> */
		/* 820A0C00h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820A0C00h case    8:*/		return 0x820A0C04;
		  /* 820A0C04h */ case    9:  		/* b 68 */
		/* 820A0C04h case    9:*/		return 0x820A0C48;
		/* 820A0C04h case    9:*/		return 0x820A0C08;
		  /* 820A0C08h */ case   10:  		/* lwz R10, <#[R30]> */
		/* 820A0C08h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820A0C08h case   10:*/		return 0x820A0C0C;
		  /* 820A0C0Ch */ case   11:  		/* mr R11, R8 */
		/* 820A0C0Ch case   11:*/		regs.R11 = regs.R8;
		/* 820A0C0Ch case   11:*/		return 0x820A0C10;
		  /* 820A0C10h */ case   12:  		/* lbz R9, <#[R11]> */
		/* 820A0C10h case   12:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0C10h case   12:*/		return 0x820A0C14;
		  /* 820A0C14h */ case   13:  		/* lbz R7, <#[R10]> */
		/* 820A0C14h case   13:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0C14h case   13:*/		return 0x820A0C18;
		  /* 820A0C18h */ case   14:  		/* cmpwi CR0, R9, 0 */
		/* 820A0C18h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0C18h case   14:*/		return 0x820A0C1C;
		  /* 820A0C1Ch */ case   15:  		/* subf R9, R7, R9 */
		/* 820A0C1Ch case   15:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A0C1Ch case   15:*/		return 0x820A0C20;
		  /* 820A0C20h */ case   16:  		/* bc 12, CR0_EQ, 20 */
		/* 820A0C20h case   16:*/		if ( regs.CR[0].eq ) { return 0x820A0C34;  }
		/* 820A0C20h case   16:*/		return 0x820A0C24;
		  /* 820A0C24h */ case   17:  		/* addi R11, R11, 1 */
		/* 820A0C24h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0C24h case   17:*/		return 0x820A0C28;
		  /* 820A0C28h */ case   18:  		/* addi R10, R10, 1 */
		/* 820A0C28h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0C28h case   18:*/		return 0x820A0C2C;
		  /* 820A0C2Ch */ case   19:  		/* cmpwi CR6, R9, 0 */
		/* 820A0C2Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0C2Ch case   19:*/		return 0x820A0C30;
		  /* 820A0C30h */ case   20:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0C30h case   20:*/		if ( regs.CR[6].eq ) { return 0x820A0C10;  }
		/* 820A0C30h case   20:*/		return 0x820A0C34;
	}
	return 0x820A0C34;
} // Block from 820A0BE0h-820A0C34h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820A0C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0C34);
		  /* 820A0C34h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0C34h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0C34h case    0:*/		return 0x820A0C38;
		  /* 820A0C38h */ case    1:  		/* bc 12, CR0_LT, 24 */
		/* 820A0C38h case    1:*/		if ( regs.CR[0].lt ) { return 0x820A0C50;  }
		/* 820A0C38h case    1:*/		return 0x820A0C3C;
		  /* 820A0C3Ch */ case    2:  		/* cmpwi CR6, R9, 0 */
		/* 820A0C3Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0C3Ch case    2:*/		return 0x820A0C40;
		  /* 820A0C40h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820A0C40h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A0C58;  }
		/* 820A0C40h case    3:*/		return 0x820A0C44;
		  /* 820A0C44h */ case    4:  		/* lwz R30, <#[R30 + 12]> */
		/* 820A0C44h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x0000000C) );
		/* 820A0C44h case    4:*/		return 0x820A0C48;
	}
	return 0x820A0C48;
} // Block from 820A0C34h-820A0C48h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0C48);
		  /* 820A0C48h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820A0C48h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820A0C48h case    0:*/		return 0x820A0C4C;
		  /* 820A0C4Ch */ case    1:  		/* bc 4, CR6_EQ, -68 */
		/* 820A0C4Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A0C08;  }
		/* 820A0C4Ch case    1:*/		return 0x820A0C50;
	}
	return 0x820A0C50;
} // Block from 820A0C48h-820A0C50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0C50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0C50);
		  /* 820A0C50h */ case    0:  		/* li R3, 0 */
		/* 820A0C50h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A0C50h case    0:*/		return 0x820A0C54;
		  /* 820A0C54h */ case    1:  		/* b 104 */
		/* 820A0C54h case    1:*/		return 0x820A0CBC;
		/* 820A0C54h case    1:*/		return 0x820A0C58;
	}
	return 0x820A0C58;
} // Block from 820A0C50h-820A0C58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0C58);
		  /* 820A0C58h */ case    0:  		/* lbz R11, <#[R30 + 16]> */
		/* 820A0C58h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820A0C58h case    0:*/		return 0x820A0C5C;
		  /* 820A0C5Ch */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820A0C5Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A0C5Ch case    1:*/		return 0x820A0C60;
		  /* 820A0C60h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 820A0C60h case    2:*/		if ( regs.CR[0].eq ) { return 0x820A0C6C;  }
		/* 820A0C60h case    2:*/		return 0x820A0C64;
		  /* 820A0C64h */ case    3:  		/* li R3, 1 */
		/* 820A0C64h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820A0C64h case    3:*/		return 0x820A0C68;
		  /* 820A0C68h */ case    4:  		/* b 84 */
		/* 820A0C68h case    4:*/		return 0x820A0CBC;
		/* 820A0C68h case    4:*/		return 0x820A0C6C;
	}
	return 0x820A0C6C;
} // Block from 820A0C58h-820A0C6Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0C6C);
		  /* 820A0C6Ch */ case    0:  		/* li R11, 1 */
		/* 820A0C6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A0C6Ch case    0:*/		return 0x820A0C70;
		  /* 820A0C70h */ case    1:  		/* lwz R31, <#[R30 + 8]> */
		/* 820A0C70h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000008) );
		/* 820A0C70h case    1:*/		return 0x820A0C74;
		  /* 820A0C74h */ case    2:  		/* stb R11, <#[R30 + 16]> */
		/* 820A0C74h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820A0C74h case    2:*/		return 0x820A0C78;
		  /* 820A0C78h */ case    3:  		/* b 40 */
		/* 820A0C78h case    3:*/		return 0x820A0CA0;
		/* 820A0C78h case    3:*/		return 0x820A0C7C;
		  /* 820A0C7Ch */ case    4:  		/* lwz R11, <#[R31 + 16]> */
		/* 820A0C7Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A0C7Ch case    4:*/		return 0x820A0C80;
		  /* 820A0C80h */ case    5:  		/* cmpwi CR6, R11, 11 */
		/* 820A0C80h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820A0C80h case    5:*/		return 0x820A0C84;
		  /* 820A0C84h */ case    6:  		/* bc 4, CR6_EQ, 24 */
		/* 820A0C84h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A0C9C;  }
		/* 820A0C84h case    6:*/		return 0x820A0C88;
		  /* 820A0C88h */ case    7:  		/* mr R3, R29 */
		/* 820A0C88h case    7:*/		regs.R3 = regs.R29;
		/* 820A0C88h case    7:*/		return 0x820A0C8C;
		  /* 820A0C8Ch */ case    8:  		/* lwz R4, <#[R31 + 24]> */
		/* 820A0C8Ch case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820A0C8Ch case    8:*/		return 0x820A0C90;
		  /* 820A0C90h */ case    9:  		/* bl -176 */
		/* 820A0C90h case    9:*/		regs.LR = 0x820A0C94; return 0x820A0BE0;
		/* 820A0C90h case    9:*/		return 0x820A0C94;
		  /* 820A0C94h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820A0C94h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A0C94h case   10:*/		return 0x820A0C98;
		  /* 820A0C98h */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 820A0C98h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820A0CA8;  }
		/* 820A0C98h case   11:*/		return 0x820A0C9C;
	}
	return 0x820A0C9C;
} // Block from 820A0C6Ch-820A0C9Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A0C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0C9C);
		  /* 820A0C9Ch */ case    0:  		/* lwz R31, <#[R31 + 12]> */
		/* 820A0C9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A0C9Ch case    0:*/		return 0x820A0CA0;
	}
	return 0x820A0CA0;
} // Block from 820A0C9Ch-820A0CA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0CA0);
		  /* 820A0CA0h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820A0CA0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A0CA0h case    0:*/		return 0x820A0CA4;
		  /* 820A0CA4h */ case    1:  		/* bc 4, CR6_EQ, -40 */
		/* 820A0CA4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A0C7C;  }
		/* 820A0CA4h case    1:*/		return 0x820A0CA8;
	}
	return 0x820A0CA8;
} // Block from 820A0CA0h-820A0CA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0CA8);
		  /* 820A0CA8h */ case    0:  		/* addi R11, R31, 0 */
		/* 820A0CA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x0);
		/* 820A0CA8h case    0:*/		return 0x820A0CAC;
		  /* 820A0CACh */ case    1:  		/* li R10, 0 */
		/* 820A0CACh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A0CACh case    1:*/		return 0x820A0CB0;
		  /* 820A0CB0h */ case    2:  		/* addic R9, R11, -1 */
		/* 820A0CB0h case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 820A0CB0h case    2:*/		return 0x820A0CB4;
		  /* 820A0CB4h */ case    3:  		/* stb R10, <#[R30 + 16]> */
		/* 820A0CB4h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 820A0CB4h case    3:*/		return 0x820A0CB8;
		  /* 820A0CB8h */ case    4:  		/* subfe R3, R9, R11 */
		/* 820A0CB8h case    4:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R9,regs.R11);
		/* 820A0CB8h case    4:*/		return 0x820A0CBC;
	}
	return 0x820A0CBC;
} // Block from 820A0CA8h-820A0CBCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0CBC);
		  /* 820A0CBCh */ case    0:  		/* addi R1, R1, 112 */
		/* 820A0CBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A0CBCh case    0:*/		return 0x820A0CC0;
		  /* 820A0CC0h */ case    1:  		/* b -64020 */
		/* 820A0CC0h case    1:*/		return 0x820912AC;
		/* 820A0CC0h case    1:*/		return 0x820A0CC4;
		  /* 820A0CC4h */ case    2:  		/* nop */
		/* 820A0CC4h case    2:*/		cpu::op::nop();
		/* 820A0CC4h case    2:*/		return 0x820A0CC8;
	}
	return 0x820A0CC8;
} // Block from 820A0CBCh-820A0CC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A0CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0CC8);
		  /* 820A0CC8h */ case    0:  		/* mfspr R12, LR */
		/* 820A0CC8h case    0:*/		regs.R12 = regs.LR;
		/* 820A0CC8h case    0:*/		return 0x820A0CCC;
		  /* 820A0CCCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A0CCCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A0CCCh case    1:*/		return 0x820A0CD0;
		  /* 820A0CD0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A0CD0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A0CD0h case    2:*/		return 0x820A0CD4;
		  /* 820A0CD4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A0CD4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A0CD4h case    3:*/		return 0x820A0CD8;
		  /* 820A0CD8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A0CD8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A0CD8h case    4:*/		return 0x820A0CDC;
		  /* 820A0CDCh */ case    5:  		/* mr R31, R3 */
		/* 820A0CDCh case    5:*/		regs.R31 = regs.R3;
		/* 820A0CDCh case    5:*/		return 0x820A0CE0;
		  /* 820A0CE0h */ case    6:  		/* mr R30, R4 */
		/* 820A0CE0h case    6:*/		regs.R30 = regs.R4;
		/* 820A0CE0h case    6:*/		return 0x820A0CE4;
		  /* 820A0CE4h */ case    7:  		/* bl -260 */
		/* 820A0CE4h case    7:*/		regs.LR = 0x820A0CE8; return 0x820A0BE0;
		/* 820A0CE4h case    7:*/		return 0x820A0CE8;
		  /* 820A0CE8h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820A0CE8h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A0CE8h case    8:*/		return 0x820A0CEC;
		  /* 820A0CECh */ case    9:  		/* bc 4, CR0_EQ, 104 */
		/* 820A0CECh case    9:*/		if ( !regs.CR[0].eq ) { return 0x820A0D54;  }
		/* 820A0CECh case    9:*/		return 0x820A0CF0;
		  /* 820A0CF0h */ case   10:  		/* mr R4, R30 */
		/* 820A0CF0h case   10:*/		regs.R4 = regs.R30;
		/* 820A0CF0h case   10:*/		return 0x820A0CF4;
		  /* 820A0CF4h */ case   11:  		/* mr R3, R31 */
		/* 820A0CF4h case   11:*/		regs.R3 = regs.R31;
		/* 820A0CF4h case   11:*/		return 0x820A0CF8;
		  /* 820A0CF8h */ case   12:  		/* bl -1064 */
		/* 820A0CF8h case   12:*/		regs.LR = 0x820A0CFC; return 0x820A08D0;
		/* 820A0CF8h case   12:*/		return 0x820A0CFC;
		  /* 820A0CFCh */ case   13:  		/* addi R11, R3, 421 */
		/* 820A0CFCh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1A5);
		/* 820A0CFCh case   13:*/		return 0x820A0D00;
		  /* 820A0D00h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820A0D00h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820A0D00h case   14:*/		return 0x820A0D04;
		  /* 820A0D04h */ case   15:  		/* lwzx R8, <#[R11 + R31]> */
		/* 820A0D04h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820A0D04h case   15:*/		return 0x820A0D08;
		  /* 820A0D08h */ case   16:  		/* b 68 */
		/* 820A0D08h case   16:*/		return 0x820A0D4C;
		/* 820A0D08h case   16:*/		return 0x820A0D0C;
		  /* 820A0D0Ch */ case   17:  		/* lwz R10, <#[R8]> */
		/* 820A0D0Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820A0D0Ch case   17:*/		return 0x820A0D10;
		  /* 820A0D10h */ case   18:  		/* mr R11, R30 */
		/* 820A0D10h case   18:*/		regs.R11 = regs.R30;
		/* 820A0D10h case   18:*/		return 0x820A0D14;
		  /* 820A0D14h */ case   19:  		/* lbz R9, <#[R11]> */
		/* 820A0D14h case   19:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0D14h case   19:*/		return 0x820A0D18;
		  /* 820A0D18h */ case   20:  		/* lbz R7, <#[R10]> */
		/* 820A0D18h case   20:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A0D18h case   20:*/		return 0x820A0D1C;
		  /* 820A0D1Ch */ case   21:  		/* cmpwi CR0, R9, 0 */
		/* 820A0D1Ch case   21:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0D1Ch case   21:*/		return 0x820A0D20;
		  /* 820A0D20h */ case   22:  		/* subf R9, R7, R9 */
		/* 820A0D20h case   22:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A0D20h case   22:*/		return 0x820A0D24;
		  /* 820A0D24h */ case   23:  		/* bc 12, CR0_EQ, 20 */
		/* 820A0D24h case   23:*/		if ( regs.CR[0].eq ) { return 0x820A0D38;  }
		/* 820A0D24h case   23:*/		return 0x820A0D28;
		  /* 820A0D28h */ case   24:  		/* addi R11, R11, 1 */
		/* 820A0D28h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0D28h case   24:*/		return 0x820A0D2C;
		  /* 820A0D2Ch */ case   25:  		/* addi R10, R10, 1 */
		/* 820A0D2Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A0D2Ch case   25:*/		return 0x820A0D30;
		  /* 820A0D30h */ case   26:  		/* cmpwi CR6, R9, 0 */
		/* 820A0D30h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0D30h case   26:*/		return 0x820A0D34;
		  /* 820A0D34h */ case   27:  		/* bc 12, CR6_EQ, -32 */
		/* 820A0D34h case   27:*/		if ( regs.CR[6].eq ) { return 0x820A0D14;  }
		/* 820A0D34h case   27:*/		return 0x820A0D38;
	}
	return 0x820A0D38;
} // Block from 820A0CC8h-820A0D38h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820A0D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0D38);
		  /* 820A0D38h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A0D38h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A0D38h case    0:*/		return 0x820A0D3C;
		  /* 820A0D3Ch */ case    1:  		/* bc 12, CR0_LT, 24 */
		/* 820A0D3Ch case    1:*/		if ( regs.CR[0].lt ) { return 0x820A0D54;  }
		/* 820A0D3Ch case    1:*/		return 0x820A0D40;
		  /* 820A0D40h */ case    2:  		/* cmpwi CR6, R9, 0 */
		/* 820A0D40h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A0D40h case    2:*/		return 0x820A0D44;
		  /* 820A0D44h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 820A0D44h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A0D70;  }
		/* 820A0D44h case    3:*/		return 0x820A0D48;
		  /* 820A0D48h */ case    4:  		/* lwz R8, <#[R8 + 12]> */
		/* 820A0D48h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 820A0D48h case    4:*/		return 0x820A0D4C;
	}
	return 0x820A0D4C;
} // Block from 820A0D38h-820A0D4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0D4C);
		  /* 820A0D4Ch */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820A0D4Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820A0D4Ch case    0:*/		return 0x820A0D50;
		  /* 820A0D50h */ case    1:  		/* bc 4, CR6_EQ, -68 */
		/* 820A0D50h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A0D0C;  }
		/* 820A0D50h case    1:*/		return 0x820A0D54;
	}
	return 0x820A0D54;
} // Block from 820A0D4Ch-820A0D54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0D54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0D54);
		  /* 820A0D54h */ case    0:  		/* li R3, 0 */
		/* 820A0D54h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A0D54h case    0:*/		return 0x820A0D58;
		  /* 820A0D58h */ case    1:  		/* addi R1, R1, 112 */
		/* 820A0D58h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A0D58h case    1:*/		return 0x820A0D5C;
		  /* 820A0D5Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A0D5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A0D5Ch case    2:*/		return 0x820A0D60;
	}
	return 0x820A0D60;
} // Block from 820A0D54h-820A0D60h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A0D60h
// Function '?DoPragmaWarning@CPreProcessor@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0D60);
		  /* 820A0D60h */ case    0:  		/* mtspr LR, R12 */
		/* 820A0D60h case    0:*/		regs.LR = regs.R12;
		/* 820A0D60h case    0:*/		return 0x820A0D64;
		  /* 820A0D64h */ case    1:  		/* ld R30, <#[R1 - 24]> */
		/* 820A0D64h case    1:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A0D64h case    1:*/		return 0x820A0D68;
		  /* 820A0D68h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 820A0D68h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A0D68h case    2:*/		return 0x820A0D6C;
		  /* 820A0D6Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 820A0D6Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A0D6Ch case    3:*/		return 0x820A0D70;
	}
	return 0x820A0D70;
} // Block from 820A0D60h-820A0D70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0D70);
		  /* 820A0D70h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820A0D70h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820A0D70h case    0:*/		return 0x820A0D74;
		  /* 820A0D74h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0D74h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A0D80;  }
		/* 820A0D74h case    1:*/		return 0x820A0D78;
		  /* 820A0D78h */ case    2:  		/* lwz R11, <#[R8 + 4]> */
		/* 820A0D78h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 820A0D78h case    2:*/		return 0x820A0D7C;
		  /* 820A0D7Ch */ case    3:  		/* stw R11, <#[R5]> */
		/* 820A0D7Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820A0D7Ch case    3:*/		return 0x820A0D80;
	}
	return 0x820A0D80;
} // Block from 820A0D70h-820A0D80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0D80);
		  /* 820A0D80h */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 820A0D80h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820A0D80h case    0:*/		return 0x820A0D84;
		  /* 820A0D84h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0D84h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A0D90;  }
		/* 820A0D84h case    1:*/		return 0x820A0D88;
		  /* 820A0D88h */ case    2:  		/* lwz R11, <#[R8 + 8]> */
		/* 820A0D88h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 820A0D88h case    2:*/		return 0x820A0D8C;
		  /* 820A0D8Ch */ case    3:  		/* stw R11, <#[R6]> */
		/* 820A0D8Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 820A0D8Ch case    3:*/		return 0x820A0D90;
	}
	return 0x820A0D90;
} // Block from 820A0D80h-820A0D90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0D90);
		  /* 820A0D90h */ case    0:  		/* li R3, 1 */
		/* 820A0D90h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820A0D90h case    0:*/		return 0x820A0D94;
		  /* 820A0D94h */ case    1:  		/* b -60 */
		/* 820A0D94h case    1:*/		return 0x820A0D58;
		/* 820A0D94h case    1:*/		return 0x820A0D98;
		  /* 820A0D98h */ case    2:  		/* li R3, 0 */
		/* 820A0D98h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A0D98h case    2:*/		return 0x820A0D9C;
		  /* 820A0D9Ch */ case    3:  		/* li R11, 0 */
		/* 820A0D9Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A0D9Ch case    3:*/		return 0x820A0DA0;
		  /* 820A0DA0h */ case    4:  		/* li R10, 0 */
		/* 820A0DA0h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A0DA0h case    4:*/		return 0x820A0DA4;
		  /* 820A0DA4h */ case    5:  		/* cmplwi CR6, R5, 0 */
		/* 820A0DA4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820A0DA4h case    5:*/		return 0x820A0DA8;
		  /* 820A0DA8h */ case    6:  		/* bclr 12, CR6_EQ */
		/* 820A0DA8h case    6:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820A0DA8h case    6:*/		return 0x820A0DAC;
	}
	return 0x820A0DAC;
} // Block from 820A0D90h-820A0DACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A0DACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0DAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0DAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0DAC);
		  /* 820A0DACh */ case    0:  		/* mtspr CTR, R5 */
		/* 820A0DACh case    0:*/		regs.CTR = regs.R5;
		/* 820A0DACh case    0:*/		return 0x820A0DB0;
		  /* 820A0DB0h */ case    1:  		/* li R9, 92 */
		/* 820A0DB0h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x5C);
		/* 820A0DB0h case    1:*/		return 0x820A0DB4;
		  /* 820A0DB4h */ case    2:  		/* lbz R8, <#[R4]> */
		/* 820A0DB4h case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 820A0DB4h case    2:*/		return 0x820A0DB8;
		  /* 820A0DB8h */ case    3:  		/* cmplwi CR6, R8, 34 */
		/* 820A0DB8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000022);
		/* 820A0DB8h case    3:*/		return 0x820A0DBC;
		  /* 820A0DBCh */ case    4:  		/* bc 4, CR6_EQ, 44 */
		/* 820A0DBCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A0DE8;  }
		/* 820A0DBCh case    4:*/		return 0x820A0DC0;
		  /* 820A0DC0h */ case    5:  		/* cmplwi CR6, R6, 0 */
		/* 820A0DC0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820A0DC0h case    5:*/		return 0x820A0DC4;
		  /* 820A0DC4h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 820A0DC4h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A0DD4;  }
		/* 820A0DC4h case    6:*/		return 0x820A0DC8;
		  /* 820A0DC8h */ case    7:  		/* cmplw CR6, R3, R7 */
		/* 820A0DC8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R7);
		/* 820A0DC8h case    7:*/		return 0x820A0DCC;
		  /* 820A0DCCh */ case    8:  		/* bc 4, CR6_LT, 8 */
		/* 820A0DCCh case    8:*/		if ( !regs.CR[6].lt ) { return 0x820A0DD4;  }
		/* 820A0DCCh case    8:*/		return 0x820A0DD0;
		  /* 820A0DD0h */ case    9:  		/* stbx R9, <#[R3 + R6]> */
		/* 820A0DD0h case    9:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R3 + regs.R6 + 0x00000000) );
		/* 820A0DD0h case    9:*/		return 0x820A0DD4;
	}
	return 0x820A0DD4;
} // Block from 820A0DACh-820A0DD4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A0DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0DD4);
		  /* 820A0DD4h */ case    0:  		/* addi R3, R3, 1 */
		/* 820A0DD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820A0DD4h case    0:*/		return 0x820A0DD8;
		  /* 820A0DD8h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A0DD8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A0DD8h case    1:*/		return 0x820A0DDC;
		  /* 820A0DDCh */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820A0DDCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A0DE8;  }
		/* 820A0DDCh case    2:*/		return 0x820A0DE0;
		  /* 820A0DE0h */ case    3:  		/* cntlzw R11, R10 */
		/* 820A0DE0h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R10);
		/* 820A0DE0h case    3:*/		return 0x820A0DE4;
		  /* 820A0DE4h */ case    4:  		/* rlwinm R10, R11, 27, 31, 31 */
		/* 820A0DE4h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R11);
		/* 820A0DE4h case    4:*/		return 0x820A0DE8;
	}
	return 0x820A0DE8;
} // Block from 820A0DD4h-820A0DE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0DE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0DE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0DE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0DE8);
		  /* 820A0DE8h */ case    0:  		/* li R11, 0 */
		/* 820A0DE8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A0DE8h case    0:*/		return 0x820A0DEC;
		  /* 820A0DECh */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 820A0DECh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820A0DECh case    1:*/		return 0x820A0DF0;
		  /* 820A0DF0h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 820A0DF0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A0E1C;  }
		/* 820A0DF0h case    2:*/		return 0x820A0DF4;
		  /* 820A0DF4h */ case    3:  		/* lbz R8, <#[R4]> */
		/* 820A0DF4h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 820A0DF4h case    3:*/		return 0x820A0DF8;
		  /* 820A0DF8h */ case    4:  		/* cmplwi CR6, R8, 92 */
		/* 820A0DF8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000005C);
		/* 820A0DF8h case    4:*/		return 0x820A0DFC;
		  /* 820A0DFCh */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 820A0DFCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A0E1C;  }
		/* 820A0DFCh case    5:*/		return 0x820A0E00;
		  /* 820A0E00h */ case    6:  		/* cmplwi CR6, R6, 0 */
		/* 820A0E00h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820A0E00h case    6:*/		return 0x820A0E04;
		  /* 820A0E04h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 820A0E04h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A0E14;  }
		/* 820A0E04h case    7:*/		return 0x820A0E08;
		  /* 820A0E08h */ case    8:  		/* cmplw CR6, R3, R7 */
		/* 820A0E08h case    8:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R7);
		/* 820A0E08h case    8:*/		return 0x820A0E0C;
		  /* 820A0E0Ch */ case    9:  		/* bc 4, CR6_LT, 8 */
		/* 820A0E0Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x820A0E14;  }
		/* 820A0E0Ch case    9:*/		return 0x820A0E10;
		  /* 820A0E10h */ case   10:  		/* stbx R9, <#[R3 + R6]> */
		/* 820A0E10h case   10:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R3 + regs.R6 + 0x00000000) );
		/* 820A0E10h case   10:*/		return 0x820A0E14;
	}
	return 0x820A0E14;
} // Block from 820A0DE8h-820A0E14h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A0E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0E14);
		  /* 820A0E14h */ case    0:  		/* addi R3, R3, 1 */
		/* 820A0E14h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820A0E14h case    0:*/		return 0x820A0E18;
		  /* 820A0E18h */ case    1:  		/* li R11, 1 */
		/* 820A0E18h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A0E18h case    1:*/		return 0x820A0E1C;
	}
	return 0x820A0E1C;
} // Block from 820A0E14h-820A0E1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0E1C);
		  /* 820A0E1Ch */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 820A0E1Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820A0E1Ch case    0:*/		return 0x820A0E20;
		  /* 820A0E20h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820A0E20h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A0E34;  }
		/* 820A0E20h case    1:*/		return 0x820A0E24;
		  /* 820A0E24h */ case    2:  		/* cmplw CR6, R3, R7 */
		/* 820A0E24h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R7);
		/* 820A0E24h case    2:*/		return 0x820A0E28;
		  /* 820A0E28h */ case    3:  		/* bc 4, CR6_LT, 12 */
		/* 820A0E28h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820A0E34;  }
		/* 820A0E28h case    3:*/		return 0x820A0E2C;
		  /* 820A0E2Ch */ case    4:  		/* lbz R8, <#[R4]> */
		/* 820A0E2Ch case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 820A0E2Ch case    4:*/		return 0x820A0E30;
		  /* 820A0E30h */ case    5:  		/* stbx R8, <#[R3 + R6]> */
		/* 820A0E30h case    5:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R3 + regs.R6 + 0x00000000) );
		/* 820A0E30h case    5:*/		return 0x820A0E34;
	}
	return 0x820A0E34;
} // Block from 820A0E1Ch-820A0E34h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A0E34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0E34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0E34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0E34);
		  /* 820A0E34h */ case    0:  		/* addi R3, R3, 1 */
		/* 820A0E34h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820A0E34h case    0:*/		return 0x820A0E38;
		  /* 820A0E38h */ case    1:  		/* addi R4, R4, 1 */
		/* 820A0E38h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820A0E38h case    1:*/		return 0x820A0E3C;
		  /* 820A0E3Ch */ case    2:  		/* bc 16, CR0_LT, -136 */
		/* 820A0E3Ch case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A0DB4;  }
		/* 820A0E3Ch case    2:*/		return 0x820A0E40;
		  /* 820A0E40h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820A0E40h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A0E40h case    3:*/		return 0x820A0E44;
	}
	return 0x820A0E44;
} // Block from 820A0E34h-820A0E44h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A0E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0E44);
		  /* 820A0E44h */ case    0:  		/* nop */
		/* 820A0E44h case    0:*/		cpu::op::nop();
		/* 820A0E44h case    0:*/		return 0x820A0E48;
	}
	return 0x820A0E48;
} // Block from 820A0E44h-820A0E48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0E48);
		  /* 820A0E48h */ case    0:  		/* mfspr R12, LR */
		/* 820A0E48h case    0:*/		regs.R12 = regs.LR;
		/* 820A0E48h case    0:*/		return 0x820A0E4C;
		  /* 820A0E4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A0E4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A0E4Ch case    1:*/		return 0x820A0E50;
		  /* 820A0E50h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A0E50h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A0E50h case    2:*/		return 0x820A0E54;
		  /* 820A0E54h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A0E54h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A0E54h case    3:*/		return 0x820A0E58;
		  /* 820A0E58h */ case    4:  		/* mr R31, R3 */
		/* 820A0E58h case    4:*/		regs.R31 = regs.R3;
		/* 820A0E58h case    4:*/		return 0x820A0E5C;
		  /* 820A0E5Ch */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 820A0E5Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A0E5Ch case    5:*/		return 0x820A0E60;
		  /* 820A0E60h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0E60h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A0E6C;  }
		/* 820A0E60h case    6:*/		return 0x820A0E64;
		  /* 820A0E64h */ case    7:  		/* mr R3, R4 */
		/* 820A0E64h case    7:*/		regs.R3 = regs.R4;
		/* 820A0E64h case    7:*/		return 0x820A0E68;
		  /* 820A0E68h */ case    8:  		/* b 52 */
		/* 820A0E68h case    8:*/		return 0x820A0E9C;
		/* 820A0E68h case    8:*/		return 0x820A0E6C;
	}
	return 0x820A0E6C;
} // Block from 820A0E48h-820A0E6Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A0E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0E6C);
		  /* 820A0E6Ch */ case    0:  		/* lwz R11, <#[R31 + 1640]> */
		/* 820A0E6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000668) );
		/* 820A0E6Ch case    0:*/		return 0x820A0E70;
		  /* 820A0E70h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A0E70h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A0E70h case    1:*/		return 0x820A0E74;
		  /* 820A0E74h */ case    2:  		/* bc 4, CR6_EQ, 36 */
		/* 820A0E74h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A0E98;  }
		/* 820A0E74h case    2:*/		return 0x820A0E78;
		  /* 820A0E78h */ case    3:  		/* lis R11, -32255 */
		/* 820A0E78h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A0E78h case    3:*/		return 0x820A0E7C;
		  /* 820A0E7Ch */ case    4:  		/* li R5, 0 */
		/* 820A0E7Ch case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A0E7Ch case    4:*/		return 0x820A0E80;
		  /* 820A0E80h */ case    5:  		/* addi R6, R11, -10784 */
		/* 820A0E80h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD5E0);
		/* 820A0E80h case    5:*/		return 0x820A0E84;
		  /* 820A0E84h */ case    6:  		/* addi R4, R31, 2216 */
		/* 820A0E84h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x8A8);
		/* 820A0E84h case    6:*/		return 0x820A0E88;
		  /* 820A0E88h */ case    7:  		/* addi R3, R31, 24 */
		/* 820A0E88h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A0E88h case    7:*/		return 0x820A0E8C;
		  /* 820A0E8Ch */ case    8:  		/* bl 25348 */
		/* 820A0E8Ch case    8:*/		regs.LR = 0x820A0E90; return 0x820A7190;
		/* 820A0E8Ch case    8:*/		return 0x820A0E90;
		  /* 820A0E90h */ case    9:  		/* li R11, 1 */
		/* 820A0E90h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A0E90h case    9:*/		return 0x820A0E94;
		  /* 820A0E94h */ case   10:  		/* stw R11, <#[R31 + 1640]> */
		/* 820A0E94h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000668) );
		/* 820A0E94h case   10:*/		return 0x820A0E98;
	}
	return 0x820A0E98;
} // Block from 820A0E6Ch-820A0E98h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A0E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0E98);
		  /* 820A0E98h */ case    0:  		/* li R3, 0 */
		/* 820A0E98h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A0E98h case    0:*/		return 0x820A0E9C;
	}
	return 0x820A0E9C;
} // Block from 820A0E98h-820A0E9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0E9C);
		  /* 820A0E9Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 820A0E9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A0E9Ch case    0:*/		return 0x820A0EA0;
		  /* 820A0EA0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A0EA0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A0EA0h case    1:*/		return 0x820A0EA4;
		  /* 820A0EA4h */ case    2:  		/* mtspr LR, R12 */
		/* 820A0EA4h case    2:*/		regs.LR = regs.R12;
		/* 820A0EA4h case    2:*/		return 0x820A0EA8;
		  /* 820A0EA8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A0EA8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A0EA8h case    3:*/		return 0x820A0EAC;
		  /* 820A0EACh */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A0EACh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A0EACh case    4:*/		return 0x820A0EB0;
	}
	return 0x820A0EB0;
} // Block from 820A0E9Ch-820A0EB0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0EB0);
		  /* 820A0EB0h */ case    0:  		/* mr R11, R3 */
		/* 820A0EB0h case    0:*/		regs.R11 = regs.R3;
		/* 820A0EB0h case    0:*/		return 0x820A0EB4;
		  /* 820A0EB4h */ case    1:  		/* li R3, 0 */
		/* 820A0EB4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A0EB4h case    1:*/		return 0x820A0EB8;
		  /* 820A0EB8h */ case    2:  		/* mr R10, R4 */
		/* 820A0EB8h case    2:*/		regs.R10 = regs.R4;
		/* 820A0EB8h case    2:*/		return 0x820A0EBC;
		  /* 820A0EBCh */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 820A0EBCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A0EBCh case    3:*/		return 0x820A0EC0;
		  /* 820A0EC0h */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 820A0EC0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A0EE4;  }
		/* 820A0EC0h case    4:*/		return 0x820A0EC4;
		  /* 820A0EC4h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820A0EC4h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A0EC4h case    5:*/		return 0x820A0EC8;
		  /* 820A0EC8h */ case    6:  		/* cmplwi CR0, R9, 0 */
		/* 820A0EC8h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820A0EC8h case    6:*/		return 0x820A0ECC;
		  /* 820A0ECCh */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 820A0ECCh case    7:*/		if ( regs.CR[0].eq ) { return 0x820A0EDC;  }
		/* 820A0ECCh case    7:*/		return 0x820A0ED0;
		  /* 820A0ED0h */ case    8:  		/* addic. R4, R4, -1 */
		/* 820A0ED0h case    8:*/		cpu::op::addic<1>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 820A0ED0h case    8:*/		return 0x820A0ED4;
		  /* 820A0ED4h */ case    9:  		/* addi R11, R11, 1 */
		/* 820A0ED4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A0ED4h case    9:*/		return 0x820A0ED8;
		  /* 820A0ED8h */ case   10:  		/* bc 4, CR0_EQ, -20 */
		/* 820A0ED8h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820A0EC4;  }
		/* 820A0ED8h case   10:*/		return 0x820A0EDC;
	}
	return 0x820A0EDC;
} // Block from 820A0EB0h-820A0EDCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A0EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0EDC);
		  /* 820A0EDCh */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820A0EDCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A0EDCh case    0:*/		return 0x820A0EE0;
		  /* 820A0EE0h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A0EE0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A0EF0;  }
		/* 820A0EE0h case    1:*/		return 0x820A0EE4;
	}
	return 0x820A0EE4;
} // Block from 820A0EDCh-820A0EE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0EE4);
		  /* 820A0EE4h */ case    0:  		/* lis R3, -32761 */
		/* 820A0EE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A0EE4h case    0:*/		return 0x820A0EE8;
		  /* 820A0EE8h */ case    1:  		/* ori R3, R3, 87 */
		/* 820A0EE8h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x57);
		/* 820A0EE8h case    1:*/		return 0x820A0EEC;
		  /* 820A0EECh */ case    2:  		/* bclr 20, CR0_LT */
		/* 820A0EECh case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A0EECh case    2:*/		return 0x820A0EF0;
	}
	return 0x820A0EF0;
} // Block from 820A0EE4h-820A0EF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A0EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0EF0);
		  /* 820A0EF0h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820A0EF0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820A0EF0h case    0:*/		return 0x820A0EF4;
		  /* 820A0EF4h */ case    1:  		/* bclr 12, CR6_EQ */
		/* 820A0EF4h case    1:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820A0EF4h case    1:*/		return 0x820A0EF8;
	}
	return 0x820A0EF8;
} // Block from 820A0EF0h-820A0EF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A0EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0EF8);
		  /* 820A0EF8h */ case    0:  		/* subf R11, R4, R10 */
		/* 820A0EF8h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R4,regs.R10);
		/* 820A0EF8h case    0:*/		return 0x820A0EFC;
		  /* 820A0EFCh */ case    1:  		/* stw R11, <#[R5]> */
		/* 820A0EFCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820A0EFCh case    1:*/		return 0x820A0F00;
		  /* 820A0F00h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820A0F00h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A0F00h case    2:*/		return 0x820A0F04;
	}
	return 0x820A0F04;
} // Block from 820A0EF8h-820A0F04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A0F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0F04);
		  /* 820A0F04h */ case    0:  		/* nop */
		/* 820A0F04h case    0:*/		cpu::op::nop();
		/* 820A0F04h case    0:*/		return 0x820A0F08;
	}
	return 0x820A0F08;
} // Block from 820A0F04h-820A0F08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0F08);
		  /* 820A0F08h */ case    0:  		/* mfspr R12, LR */
		/* 820A0F08h case    0:*/		regs.R12 = regs.LR;
		/* 820A0F08h case    0:*/		return 0x820A0F0C;
		  /* 820A0F0Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A0F0Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A0F0Ch case    1:*/		return 0x820A0F10;
		  /* 820A0F10h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A0F10h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A0F10h case    2:*/		return 0x820A0F14;
		  /* 820A0F14h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A0F14h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A0F14h case    3:*/		return 0x820A0F18;
		  /* 820A0F18h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A0F18h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A0F18h case    4:*/		return 0x820A0F1C;
		  /* 820A0F1Ch */ case    5:  		/* mr R31, R3 */
		/* 820A0F1Ch case    5:*/		regs.R31 = regs.R3;
		/* 820A0F1Ch case    5:*/		return 0x820A0F20;
		  /* 820A0F20h */ case    6:  		/* lwz R3, <#[R3 + 12]> */
		/* 820A0F20h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A0F20h case    6:*/		return 0x820A0F24;
		  /* 820A0F24h */ case    7:  		/* mr R30, R4 */
		/* 820A0F24h case    7:*/		regs.R30 = regs.R4;
		/* 820A0F24h case    7:*/		return 0x820A0F28;
		  /* 820A0F28h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 820A0F28h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A0F28h case    8:*/		return 0x820A0F2C;
		  /* 820A0F2Ch */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0F2Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820A0F38;  }
		/* 820A0F2Ch case    9:*/		return 0x820A0F30;
		  /* 820A0F30h */ case   10:  		/* li R4, 1 */
		/* 820A0F30h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A0F30h case   10:*/		return 0x820A0F34;
		  /* 820A0F34h */ case   11:  		/* bl -44 */
		/* 820A0F34h case   11:*/		regs.LR = 0x820A0F38; return 0x820A0F08;
		/* 820A0F34h case   11:*/		return 0x820A0F38;
	}
	return 0x820A0F38;
} // Block from 820A0F08h-820A0F38h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A0F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0F38);
		  /* 820A0F38h */ case    0:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 820A0F38h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 820A0F38h case    0:*/		return 0x820A0F3C;
		  /* 820A0F3Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820A0F3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820A0F4C;  }
		/* 820A0F3Ch case    1:*/		return 0x820A0F40;
		  /* 820A0F40h */ case    2:  		/* lis R4, 9345 */
		/* 820A0F40h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A0F40h case    2:*/		return 0x820A0F44;
		  /* 820A0F44h */ case    3:  		/* mr R3, R31 */
		/* 820A0F44h case    3:*/		regs.R3 = regs.R31;
		/* 820A0F44h case    3:*/		return 0x820A0F48;
		  /* 820A0F48h */ case    4:  		/* bl -101392 */
		/* 820A0F48h case    4:*/		regs.LR = 0x820A0F4C; return 0x82088338;
		/* 820A0F48h case    4:*/		return 0x820A0F4C;
	}
	return 0x820A0F4C;
} // Block from 820A0F38h-820A0F4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A0F4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0F4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0F4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0F4C);
		  /* 820A0F4Ch */ case    0:  		/* mr R3, R31 */
		/* 820A0F4Ch case    0:*/		regs.R3 = regs.R31;
		/* 820A0F4Ch case    0:*/		return 0x820A0F50;
		  /* 820A0F50h */ case    1:  		/* addi R1, R1, 112 */
		/* 820A0F50h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A0F50h case    1:*/		return 0x820A0F54;
		  /* 820A0F54h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A0F54h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A0F54h case    2:*/		return 0x820A0F58;
		  /* 820A0F58h */ case    3:  		/* mtspr LR, R12 */
		/* 820A0F58h case    3:*/		regs.LR = regs.R12;
		/* 820A0F58h case    3:*/		return 0x820A0F5C;
		  /* 820A0F5Ch */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820A0F5Ch case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A0F5Ch case    4:*/		return 0x820A0F60;
		  /* 820A0F60h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820A0F60h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A0F60h case    5:*/		return 0x820A0F64;
		  /* 820A0F64h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820A0F64h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A0F64h case    6:*/		return 0x820A0F68;
	}
	return 0x820A0F68;
} // Block from 820A0F4Ch-820A0F68h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A0F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0F68);
		  /* 820A0F68h */ case    0:  		/* mfspr R12, LR */
		/* 820A0F68h case    0:*/		regs.R12 = regs.LR;
		/* 820A0F68h case    0:*/		return 0x820A0F6C;
		  /* 820A0F6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A0F6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A0F6Ch case    1:*/		return 0x820A0F70;
		  /* 820A0F70h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A0F70h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A0F70h case    2:*/		return 0x820A0F74;
		  /* 820A0F74h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A0F74h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A0F74h case    3:*/		return 0x820A0F78;
		  /* 820A0F78h */ case    4:  		/* mr R31, R3 */
		/* 820A0F78h case    4:*/		regs.R31 = regs.R3;
		/* 820A0F78h case    4:*/		return 0x820A0F7C;
		  /* 820A0F7Ch */ case    5:  		/* lwz R3, <#[R3 + 80]> */
		/* 820A0F7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000050) );
		/* 820A0F7Ch case    5:*/		return 0x820A0F80;
		  /* 820A0F80h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 820A0F80h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A0F80h case    6:*/		return 0x820A0F84;
		  /* 820A0F84h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0F84h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A0F90;  }
		/* 820A0F84h case    7:*/		return 0x820A0F88;
		  /* 820A0F88h */ case    8:  		/* li R4, 1 */
		/* 820A0F88h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A0F88h case    8:*/		return 0x820A0F8C;
		  /* 820A0F8Ch */ case    9:  		/* bl -132 */
		/* 820A0F8Ch case    9:*/		regs.LR = 0x820A0F90; return 0x820A0F08;
		/* 820A0F8Ch case    9:*/		return 0x820A0F90;
	}
	return 0x820A0F90;
} // Block from 820A0F68h-820A0F90h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A0F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0F90);
		  /* 820A0F90h */ case    0:  		/* mr R3, R31 */
		/* 820A0F90h case    0:*/		regs.R3 = regs.R31;
		/* 820A0F90h case    0:*/		return 0x820A0F94;
		  /* 820A0F94h */ case    1:  		/* bl -4772 */
		/* 820A0F94h case    1:*/		regs.LR = 0x820A0F98; return 0x8209FCF0;
		/* 820A0F94h case    1:*/		return 0x820A0F98;
		  /* 820A0F98h */ case    2:  		/* addi R3, R31, 84 */
		/* 820A0F98h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x54);
		/* 820A0F98h case    2:*/		return 0x820A0F9C;
		  /* 820A0F9Ch */ case    3:  		/* bl 163988 */
		/* 820A0F9Ch case    3:*/		regs.LR = 0x820A0FA0; return 0x820C9030;
		/* 820A0F9Ch case    3:*/		return 0x820A0FA0;
		  /* 820A0FA0h */ case    4:  		/* mr R3, R31 */
		/* 820A0FA0h case    4:*/		regs.R3 = regs.R31;
		/* 820A0FA0h case    4:*/		return 0x820A0FA4;
		  /* 820A0FA4h */ case    5:  		/* bl 1557532 */
		/* 820A0FA4h case    5:*/		regs.LR = 0x820A0FA8; return 0x8221D3C0;
		/* 820A0FA4h case    5:*/		return 0x820A0FA8;
		  /* 820A0FA8h */ case    6:  		/* addi R1, R1, 96 */
		/* 820A0FA8h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A0FA8h case    6:*/		return 0x820A0FAC;
		  /* 820A0FACh */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A0FACh case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A0FACh case    7:*/		return 0x820A0FB0;
		  /* 820A0FB0h */ case    8:  		/* mtspr LR, R12 */
		/* 820A0FB0h case    8:*/		regs.LR = regs.R12;
		/* 820A0FB0h case    8:*/		return 0x820A0FB4;
		  /* 820A0FB4h */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 820A0FB4h case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A0FB4h case    9:*/		return 0x820A0FB8;
		  /* 820A0FB8h */ case   10:  		/* bclr 20, CR0_LT */
		/* 820A0FB8h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A0FB8h case   10:*/		return 0x820A0FBC;
	}
	return 0x820A0FBC;
} // Block from 820A0F90h-820A0FBCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A0FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0FBC);
		  /* 820A0FBCh */ case    0:  		/* nop */
		/* 820A0FBCh case    0:*/		cpu::op::nop();
		/* 820A0FBCh case    0:*/		return 0x820A0FC0;
	}
	return 0x820A0FC0;
} // Block from 820A0FBCh-820A0FC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A0FC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0FC0);
		  /* 820A0FC0h */ case    0:  		/* mfspr R12, LR */
		/* 820A0FC0h case    0:*/		regs.R12 = regs.LR;
		/* 820A0FC0h case    0:*/		return 0x820A0FC4;
		  /* 820A0FC4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A0FC4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A0FC4h case    1:*/		return 0x820A0FC8;
		  /* 820A0FC8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A0FC8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A0FC8h case    2:*/		return 0x820A0FCC;
		  /* 820A0FCCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A0FCCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A0FCCh case    3:*/		return 0x820A0FD0;
		  /* 820A0FD0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A0FD0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A0FD0h case    4:*/		return 0x820A0FD4;
		  /* 820A0FD4h */ case    5:  		/* mr R31, R3 */
		/* 820A0FD4h case    5:*/		regs.R31 = regs.R3;
		/* 820A0FD4h case    5:*/		return 0x820A0FD8;
		  /* 820A0FD8h */ case    6:  		/* lwz R3, <#[R3 + 4]> */
		/* 820A0FD8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 820A0FD8h case    6:*/		return 0x820A0FDC;
		  /* 820A0FDCh */ case    7:  		/* mr R30, R4 */
		/* 820A0FDCh case    7:*/		regs.R30 = regs.R4;
		/* 820A0FDCh case    7:*/		return 0x820A0FE0;
		  /* 820A0FE0h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 820A0FE0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A0FE0h case    8:*/		return 0x820A0FE4;
		  /* 820A0FE4h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 820A0FE4h case    9:*/		if ( regs.CR[6].eq ) { return 0x820A0FF0;  }
		/* 820A0FE4h case    9:*/		return 0x820A0FE8;
		  /* 820A0FE8h */ case   10:  		/* li R4, 1 */
		/* 820A0FE8h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A0FE8h case   10:*/		return 0x820A0FEC;
		  /* 820A0FECh */ case   11:  		/* bl -44 */
		/* 820A0FECh case   11:*/		regs.LR = 0x820A0FF0; return 0x820A0FC0;
		/* 820A0FECh case   11:*/		return 0x820A0FF0;
	}
	return 0x820A0FF0;
} // Block from 820A0FC0h-820A0FF0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A0FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A0FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A0FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A0FF0);
		  /* 820A0FF0h */ case    0:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 820A0FF0h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 820A0FF0h case    0:*/		return 0x820A0FF4;
		  /* 820A0FF4h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820A0FF4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A1004;  }
		/* 820A0FF4h case    1:*/		return 0x820A0FF8;
		  /* 820A0FF8h */ case    2:  		/* lis R4, 9345 */
		/* 820A0FF8h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A0FF8h case    2:*/		return 0x820A0FFC;
		  /* 820A0FFCh */ case    3:  		/* mr R3, R31 */
		/* 820A0FFCh case    3:*/		regs.R3 = regs.R31;
		/* 820A0FFCh case    3:*/		return 0x820A1000;
		  /* 820A1000h */ case    4:  		/* bl -101576 */
		/* 820A1000h case    4:*/		regs.LR = 0x820A1004; return 0x82088338;
		/* 820A1000h case    4:*/		return 0x820A1004;
	}
	return 0x820A1004;
} // Block from 820A0FF0h-820A1004h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A1004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1004);
		  /* 820A1004h */ case    0:  		/* mr R3, R31 */
		/* 820A1004h case    0:*/		regs.R3 = regs.R31;
		/* 820A1004h case    0:*/		return 0x820A1008;
		  /* 820A1008h */ case    1:  		/* addi R1, R1, 112 */
		/* 820A1008h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A1008h case    1:*/		return 0x820A100C;
		  /* 820A100Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A100Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A100Ch case    2:*/		return 0x820A1010;
		  /* 820A1010h */ case    3:  		/* mtspr LR, R12 */
		/* 820A1010h case    3:*/		regs.LR = regs.R12;
		/* 820A1010h case    3:*/		return 0x820A1014;
		  /* 820A1014h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820A1014h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A1014h case    4:*/		return 0x820A1018;
		  /* 820A1018h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820A1018h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A1018h case    5:*/		return 0x820A101C;
		  /* 820A101Ch */ case    6:  		/* bclr 20, CR0_LT */
		/* 820A101Ch case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A101Ch case    6:*/		return 0x820A1020;
	}
	return 0x820A1020;
} // Block from 820A1004h-820A1020h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A1020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1020);
		  /* 820A1020h */ case    0:  		/* mfspr R12, LR */
		/* 820A1020h case    0:*/		regs.R12 = regs.LR;
		/* 820A1020h case    0:*/		return 0x820A1024;
		  /* 820A1024h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A1024h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A1024h case    1:*/		return 0x820A1028;
		  /* 820A1028h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A1028h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A1028h case    2:*/		return 0x820A102C;
		  /* 820A102Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A102Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A102Ch case    3:*/		return 0x820A1030;
		  /* 820A1030h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A1030h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A1030h case    4:*/		return 0x820A1034;
		  /* 820A1034h */ case    5:  		/* mr R31, R3 */
		/* 820A1034h case    5:*/		regs.R31 = regs.R3;
		/* 820A1034h case    5:*/		return 0x820A1038;
		  /* 820A1038h */ case    6:  		/* lwz R3, <#[R3 + 40]> */
		/* 820A1038h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000028) );
		/* 820A1038h case    6:*/		return 0x820A103C;
		  /* 820A103Ch */ case    7:  		/* mr R30, R4 */
		/* 820A103Ch case    7:*/		regs.R30 = regs.R4;
		/* 820A103Ch case    7:*/		return 0x820A1040;
		  /* 820A1040h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 820A1040h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A1040h case    8:*/		return 0x820A1044;
		  /* 820A1044h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 820A1044h case    9:*/		if ( regs.CR[6].eq ) { return 0x820A1050;  }
		/* 820A1044h case    9:*/		return 0x820A1048;
		  /* 820A1048h */ case   10:  		/* li R4, 1 */
		/* 820A1048h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A1048h case   10:*/		return 0x820A104C;
		  /* 820A104Ch */ case   11:  		/* bl -44 */
		/* 820A104Ch case   11:*/		regs.LR = 0x820A1050; return 0x820A1020;
		/* 820A104Ch case   11:*/		return 0x820A1050;
	}
	return 0x820A1050;
} // Block from 820A1020h-820A1050h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A1050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1050);
		  /* 820A1050h */ case    0:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 820A1050h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 820A1050h case    0:*/		return 0x820A1054;
		  /* 820A1054h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820A1054h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A1064;  }
		/* 820A1054h case    1:*/		return 0x820A1058;
		  /* 820A1058h */ case    2:  		/* lis R4, 9345 */
		/* 820A1058h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A1058h case    2:*/		return 0x820A105C;
		  /* 820A105Ch */ case    3:  		/* mr R3, R31 */
		/* 820A105Ch case    3:*/		regs.R3 = regs.R31;
		/* 820A105Ch case    3:*/		return 0x820A1060;
		  /* 820A1060h */ case    4:  		/* bl -101672 */
		/* 820A1060h case    4:*/		regs.LR = 0x820A1064; return 0x82088338;
		/* 820A1060h case    4:*/		return 0x820A1064;
	}
	return 0x820A1064;
} // Block from 820A1050h-820A1064h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A1064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1064);
		  /* 820A1064h */ case    0:  		/* mr R3, R31 */
		/* 820A1064h case    0:*/		regs.R3 = regs.R31;
		/* 820A1064h case    0:*/		return 0x820A1068;
		  /* 820A1068h */ case    1:  		/* addi R1, R1, 112 */
		/* 820A1068h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A1068h case    1:*/		return 0x820A106C;
		  /* 820A106Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A106Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A106Ch case    2:*/		return 0x820A1070;
		  /* 820A1070h */ case    3:  		/* mtspr LR, R12 */
		/* 820A1070h case    3:*/		regs.LR = regs.R12;
		/* 820A1070h case    3:*/		return 0x820A1074;
		  /* 820A1074h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820A1074h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A1074h case    4:*/		return 0x820A1078;
		  /* 820A1078h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820A1078h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A1078h case    5:*/		return 0x820A107C;
		  /* 820A107Ch */ case    6:  		/* bclr 20, CR0_LT */
		/* 820A107Ch case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A107Ch case    6:*/		return 0x820A1080;
	}
	return 0x820A1080;
} // Block from 820A1064h-820A1080h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A1080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1080);
		  /* 820A1080h */ case    0:  		/* mfspr R12, LR */
		/* 820A1080h case    0:*/		regs.R12 = regs.LR;
		/* 820A1080h case    0:*/		return 0x820A1084;
		  /* 820A1084h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A1084h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A1084h case    1:*/		return 0x820A1088;
		  /* 820A1088h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A1088h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A1088h case    2:*/		return 0x820A108C;
		  /* 820A108Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A108Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A108Ch case    3:*/		return 0x820A1090;
		  /* 820A1090h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A1090h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A1090h case    4:*/		return 0x820A1094;
		  /* 820A1094h */ case    5:  		/* mr R31, R3 */
		/* 820A1094h case    5:*/		regs.R31 = regs.R3;
		/* 820A1094h case    5:*/		return 0x820A1098;
		  /* 820A1098h */ case    6:  		/* lwz R3, <#[R3 + 8]> */
		/* 820A1098h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 820A1098h case    6:*/		return 0x820A109C;
		  /* 820A109Ch */ case    7:  		/* mr R30, R4 */
		/* 820A109Ch case    7:*/		regs.R30 = regs.R4;
		/* 820A109Ch case    7:*/		return 0x820A10A0;
		  /* 820A10A0h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 820A10A0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A10A0h case    8:*/		return 0x820A10A4;
		  /* 820A10A4h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 820A10A4h case    9:*/		if ( regs.CR[6].eq ) { return 0x820A10B0;  }
		/* 820A10A4h case    9:*/		return 0x820A10A8;
		  /* 820A10A8h */ case   10:  		/* li R4, 1 */
		/* 820A10A8h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A10A8h case   10:*/		return 0x820A10AC;
		  /* 820A10ACh */ case   11:  		/* bl -44 */
		/* 820A10ACh case   11:*/		regs.LR = 0x820A10B0; return 0x820A1080;
		/* 820A10ACh case   11:*/		return 0x820A10B0;
	}
	return 0x820A10B0;
} // Block from 820A1080h-820A10B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A10B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A10B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A10B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A10B0);
		  /* 820A10B0h */ case    0:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 820A10B0h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 820A10B0h case    0:*/		return 0x820A10B4;
		  /* 820A10B4h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820A10B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A10C4;  }
		/* 820A10B4h case    1:*/		return 0x820A10B8;
		  /* 820A10B8h */ case    2:  		/* lis R4, 9345 */
		/* 820A10B8h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A10B8h case    2:*/		return 0x820A10BC;
		  /* 820A10BCh */ case    3:  		/* mr R3, R31 */
		/* 820A10BCh case    3:*/		regs.R3 = regs.R31;
		/* 820A10BCh case    3:*/		return 0x820A10C0;
		  /* 820A10C0h */ case    4:  		/* bl -101768 */
		/* 820A10C0h case    4:*/		regs.LR = 0x820A10C4; return 0x82088338;
		/* 820A10C0h case    4:*/		return 0x820A10C4;
	}
	return 0x820A10C4;
} // Block from 820A10B0h-820A10C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A10C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A10C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A10C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A10C4);
		  /* 820A10C4h */ case    0:  		/* mr R3, R31 */
		/* 820A10C4h case    0:*/		regs.R3 = regs.R31;
		/* 820A10C4h case    0:*/		return 0x820A10C8;
		  /* 820A10C8h */ case    1:  		/* addi R1, R1, 112 */
		/* 820A10C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A10C8h case    1:*/		return 0x820A10CC;
		  /* 820A10CCh */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A10CCh case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A10CCh case    2:*/		return 0x820A10D0;
		  /* 820A10D0h */ case    3:  		/* mtspr LR, R12 */
		/* 820A10D0h case    3:*/		regs.LR = regs.R12;
		/* 820A10D0h case    3:*/		return 0x820A10D4;
		  /* 820A10D4h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820A10D4h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A10D4h case    4:*/		return 0x820A10D8;
		  /* 820A10D8h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820A10D8h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A10D8h case    5:*/		return 0x820A10DC;
		  /* 820A10DCh */ case    6:  		/* bclr 20, CR0_LT */
		/* 820A10DCh case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A10DCh case    6:*/		return 0x820A10E0;
	}
	return 0x820A10E0;
} // Block from 820A10C4h-820A10E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A10E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A10E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A10E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A10E0);
		  /* 820A10E0h */ case    0:  		/* mfspr R12, LR */
		/* 820A10E0h case    0:*/		regs.R12 = regs.LR;
		/* 820A10E0h case    0:*/		return 0x820A10E4;
		  /* 820A10E4h */ case    1:  		/* bl -65160 */
		/* 820A10E4h case    1:*/		regs.LR = 0x820A10E8; return 0x8209125C;
		/* 820A10E4h case    1:*/		return 0x820A10E8;
		  /* 820A10E8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A10E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A10E8h case    2:*/		return 0x820A10EC;
		  /* 820A10ECh */ case    3:  		/* lis R5, 1 */
		/* 820A10ECh case    3:*/		cpu::op::lis<0>(regs,&regs.R5,0x1);
		/* 820A10ECh case    3:*/		return 0x820A10F0;
		  /* 820A10F0h */ case    4:  		/* lis R4, 16 */
		/* 820A10F0h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x10);
		/* 820A10F0h case    4:*/		return 0x820A10F4;
		  /* 820A10F4h */ case    5:  		/* mr R31, R3 */
		/* 820A10F4h case    5:*/		regs.R31 = regs.R3;
		/* 820A10F4h case    5:*/		return 0x820A10F8;
		  /* 820A10F8h */ case    6:  		/* bl 163664 */
		/* 820A10F8h case    6:*/		regs.LR = 0x820A10FC; return 0x820C9048;
		/* 820A10F8h case    6:*/		return 0x820A10FC;
		  /* 820A10FCh */ case    7:  		/* addi R3, R31, 24 */
		/* 820A10FCh case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A10FCh case    7:*/		return 0x820A1100;
		  /* 820A1100h */ case    8:  		/* bl 19248 */
		/* 820A1100h case    8:*/		regs.LR = 0x820A1104; return 0x820A5C30;
		/* 820A1100h case    8:*/		return 0x820A1104;
		  /* 820A1104h */ case    9:  		/* addi R3, R31, 80 */
		/* 820A1104h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x50);
		/* 820A1104h case    9:*/		return 0x820A1108;
		  /* 820A1108h */ case   10:  		/* bl 19488 */
		/* 820A1108h case   10:*/		regs.LR = 0x820A110C; return 0x820A5D28;
		/* 820A1108h case   10:*/		return 0x820A110C;
		  /* 820A110Ch */ case   11:  		/* li R30, 0 */
		/* 820A110Ch case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A110Ch case   11:*/		return 0x820A1110;
		  /* 820A1110h */ case   12:  		/* mr R3, R31 */
		/* 820A1110h case   12:*/		regs.R3 = regs.R31;
		/* 820A1110h case   12:*/		return 0x820A1114;
		  /* 820A1114h */ case   13:  		/* stw R30, <#[R31 + 2268]> */
		/* 820A1114h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000008DC) );
		/* 820A1114h case   13:*/		return 0x820A1118;
		  /* 820A1118h */ case   14:  		/* stw R30, <#[R31 + 2264]> */
		/* 820A1118h case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000008D8) );
		/* 820A1118h case   14:*/		return 0x820A111C;
		  /* 820A111Ch */ case   15:  		/* bl -5076 */
		/* 820A111Ch case   15:*/		regs.LR = 0x820A1120; return 0x8209FD48;
		/* 820A111Ch case   15:*/		return 0x820A1120;
		  /* 820A1120h */ case   16:  		/* li R29, 1 */
		/* 820A1120h case   16:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820A1120h case   16:*/		return 0x820A1124;
		  /* 820A1124h */ case   17:  		/* addi R3, R31, 1684 */
		/* 820A1124h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x694);
		/* 820A1124h case   17:*/		return 0x820A1128;
		  /* 820A1128h */ case   18:  		/* stw R30, <#[R31 + 64]> */
		/* 820A1128h case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000040) );
		/* 820A1128h case   18:*/		return 0x820A112C;
		  /* 820A112Ch */ case   19:  		/* li R5, 508 */
		/* 820A112Ch case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x1FC);
		/* 820A112Ch case   19:*/		return 0x820A1130;
		  /* 820A1130h */ case   20:  		/* stw R30, <#[R31 + 68]> */
		/* 820A1130h case   20:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000044) );
		/* 820A1130h case   20:*/		return 0x820A1134;
		  /* 820A1134h */ case   21:  		/* li R4, 0 */
		/* 820A1134h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A1134h case   21:*/		return 0x820A1138;
		  /* 820A1138h */ case   22:  		/* stw R30, <#[R31 + 76]> */
		/* 820A1138h case   22:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000004C) );
		/* 820A1138h case   22:*/		return 0x820A113C;
		  /* 820A113Ch */ case   23:  		/* stw R29, <#[R31 + 1636]> */
		/* 820A113Ch case   23:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000664) );
		/* 820A113Ch case   23:*/		return 0x820A1140;
		  /* 820A1140h */ case   24:  		/* stw R30, <#[R31 + 1640]> */
		/* 820A1140h case   24:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000668) );
		/* 820A1140h case   24:*/		return 0x820A1144;
		  /* 820A1144h */ case   25:  		/* stw R30, <#[R31 + 1644]> */
		/* 820A1144h case   25:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000066C) );
		/* 820A1144h case   25:*/		return 0x820A1148;
		  /* 820A1148h */ case   26:  		/* stw R29, <#[R31 + 1648]> */
		/* 820A1148h case   26:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000670) );
		/* 820A1148h case   26:*/		return 0x820A114C;
		  /* 820A114Ch */ case   27:  		/* stw R29, <#[R31 + 1652]> */
		/* 820A114Ch case   27:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000674) );
		/* 820A114Ch case   27:*/		return 0x820A1150;
		  /* 820A1150h */ case   28:  		/* stw R29, <#[R31 + 1656]> */
		/* 820A1150h case   28:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000678) );
		/* 820A1150h case   28:*/		return 0x820A1154;
		  /* 820A1154h */ case   29:  		/* stw R30, <#[R31 + 1660]> */
		/* 820A1154h case   29:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000067C) );
		/* 820A1154h case   29:*/		return 0x820A1158;
		  /* 820A1158h */ case   30:  		/* stw R30, <#[R31 + 1664]> */
		/* 820A1158h case   30:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000680) );
		/* 820A1158h case   30:*/		return 0x820A115C;
		  /* 820A115Ch */ case   31:  		/* stw R30, <#[R31 + 1676]> */
		/* 820A115Ch case   31:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000068C) );
		/* 820A115Ch case   31:*/		return 0x820A1160;
		  /* 820A1160h */ case   32:  		/* stw R30, <#[R31 + 1668]> */
		/* 820A1160h case   32:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000684) );
		/* 820A1160h case   32:*/		return 0x820A1164;
		  /* 820A1164h */ case   33:  		/* stw R30, <#[R31 + 1672]> */
		/* 820A1164h case   33:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000688) );
		/* 820A1164h case   33:*/		return 0x820A1168;
		  /* 820A1168h */ case   34:  		/* stw R30, <#[R31 + 1680]> */
		/* 820A1168h case   34:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000690) );
		/* 820A1168h case   34:*/		return 0x820A116C;
		  /* 820A116Ch */ case   35:  		/* stw R30, <#[R31 + 2196]> */
		/* 820A116Ch case   35:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000894) );
		/* 820A116Ch case   35:*/		return 0x820A1170;
		  /* 820A1170h */ case   36:  		/* stw R30, <#[R31 + 2200]> */
		/* 820A1170h case   36:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000898) );
		/* 820A1170h case   36:*/		return 0x820A1174;
		  /* 820A1174h */ case   37:  		/* stw R30, <#[R31 + 2204]> */
		/* 820A1174h case   37:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A1174h case   37:*/		return 0x820A1178;
		  /* 820A1178h */ case   38:  		/* stw R30, <#[R31 + 72]> */
		/* 820A1178h case   38:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000048) );
		/* 820A1178h case   38:*/		return 0x820A117C;
		  /* 820A117Ch */ case   39:  		/* bl -65084 */
		/* 820A117Ch case   39:*/		regs.LR = 0x820A1180; return 0x82091340;
		/* 820A117Ch case   39:*/		return 0x820A1180;
		  /* 820A1180h */ case   40:  		/* std R30, <#[R31 + 2216]> */
		/* 820A1180h case   40:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R31 + 0x000008A8) );
		/* 820A1180h case   40:*/		return 0x820A1184;
		  /* 820A1184h */ case   41:  		/* std R30, <#[R31 + 2224]> */
		/* 820A1184h case   41:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R31 + 0x000008B0) );
		/* 820A1184h case   41:*/		return 0x820A1188;
		  /* 820A1188h */ case   42:  		/* std R30, <#[R31 + 2232]> */
		/* 820A1188h case   42:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R31 + 0x000008B8) );
		/* 820A1188h case   42:*/		return 0x820A118C;
		  /* 820A118Ch */ case   43:  		/* std R30, <#[R31 + 2240]> */
		/* 820A118Ch case   43:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R31 + 0x000008C0) );
		/* 820A118Ch case   43:*/		return 0x820A1190;
		  /* 820A1190h */ case   44:  		/* std R30, <#[R31 + 2248]> */
		/* 820A1190h case   44:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R31 + 0x000008C8) );
		/* 820A1190h case   44:*/		return 0x820A1194;
		  /* 820A1194h */ case   45:  		/* stw R30, <#[R31 + 2192]> */
		/* 820A1194h case   45:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000890) );
		/* 820A1194h case   45:*/		return 0x820A1198;
		  /* 820A1198h */ case   46:  		/* stw R29, <#[R31 + 2256]> */
		/* 820A1198h case   46:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x000008D0) );
		/* 820A1198h case   46:*/		return 0x820A119C;
		  /* 820A119Ch */ case   47:  		/* stw R30, <#[R31 + 2272]> */
		/* 820A119Ch case   47:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000008E0) );
		/* 820A119Ch case   47:*/		return 0x820A11A0;
		  /* 820A11A0h */ case   48:  		/* bl 180536 */
		/* 820A11A0h case   48:*/		regs.LR = 0x820A11A4; return 0x820CD2D8;
		/* 820A11A0h case   48:*/		return 0x820A11A4;
		  /* 820A11A4h */ case   49:  		/* mr R3, R31 */
		/* 820A11A4h case   49:*/		regs.R3 = regs.R31;
		/* 820A11A4h case   49:*/		return 0x820A11A8;
		  /* 820A11A8h */ case   50:  		/* addi R1, R1, 112 */
		/* 820A11A8h case   50:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A11A8h case   50:*/		return 0x820A11AC;
		  /* 820A11ACh */ case   51:  		/* b -65280 */
		/* 820A11ACh case   51:*/		return 0x820912AC;
		/* 820A11ACh case   51:*/		return 0x820A11B0;
	}
	return 0x820A11B0;
} // Block from 820A10E0h-820A11B0h (52 instructions)

//////////////////////////////////////////////////////
// Block at 820A11B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A11B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A11B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A11B0);
		  /* 820A11B0h */ case    0:  		/* mfspr R12, LR */
		/* 820A11B0h case    0:*/		regs.R12 = regs.LR;
		/* 820A11B0h case    0:*/		return 0x820A11B4;
		  /* 820A11B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A11B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A11B4h case    1:*/		return 0x820A11B8;
		  /* 820A11B8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A11B8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A11B8h case    2:*/		return 0x820A11BC;
		  /* 820A11BCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A11BCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A11BCh case    3:*/		return 0x820A11C0;
		  /* 820A11C0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A11C0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A11C0h case    4:*/		return 0x820A11C4;
		  /* 820A11C4h */ case    5:  		/* mr R31, R3 */
		/* 820A11C4h case    5:*/		regs.R31 = regs.R3;
		/* 820A11C4h case    5:*/		return 0x820A11C8;
		  /* 820A11C8h */ case    6:  		/* mr R30, R4 */
		/* 820A11C8h case    6:*/		regs.R30 = regs.R4;
		/* 820A11C8h case    6:*/		return 0x820A11CC;
		  /* 820A11CCh */ case    7:  		/* lis R4, 9345 */
		/* 820A11CCh case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A11CCh case    7:*/		return 0x820A11D0;
		  /* 820A11D0h */ case    8:  		/* li R3, 12 */
		/* 820A11D0h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0xC);
		/* 820A11D0h case    8:*/		return 0x820A11D4;
		  /* 820A11D4h */ case    9:  		/* bl -102356 */
		/* 820A11D4h case    9:*/		regs.LR = 0x820A11D8; return 0x82088200;
		/* 820A11D4h case    9:*/		return 0x820A11D8;
		  /* 820A11D8h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 820A11D8h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A11D8h case   10:*/		return 0x820A11DC;
		  /* 820A11DCh */ case   11:  		/* li R11, 0 */
		/* 820A11DCh case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A11DCh case   11:*/		return 0x820A11E0;
		  /* 820A11E0h */ case   12:  		/* bc 12, CR0_EQ, 24 */
		/* 820A11E0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820A11F8;  }
		/* 820A11E0h case   12:*/		return 0x820A11E4;
		  /* 820A11E4h */ case   13:  		/* li R10, 1 */
		/* 820A11E4h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820A11E4h case   13:*/		return 0x820A11E8;
		  /* 820A11E8h */ case   14:  		/* stw R11, <#[R3 + 4]> */
		/* 820A11E8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820A11E8h case   14:*/		return 0x820A11EC;
		  /* 820A11ECh */ case   15:  		/* stw R30, <#[R3]> */
		/* 820A11ECh case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 820A11ECh case   15:*/		return 0x820A11F0;
		  /* 820A11F0h */ case   16:  		/* mr R11, R3 */
		/* 820A11F0h case   16:*/		regs.R11 = regs.R3;
		/* 820A11F0h case   16:*/		return 0x820A11F4;
		  /* 820A11F4h */ case   17:  		/* stw R10, <#[R3 + 8]> */
		/* 820A11F4h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820A11F4h case   17:*/		return 0x820A11F8;
	}
	return 0x820A11F8;
} // Block from 820A11B0h-820A11F8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820A11F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A11F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A11F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A11F8);
		  /* 820A11F8h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820A11F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A11F8h case    0:*/		return 0x820A11FC;
		  /* 820A11FCh */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A11FCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A120C;  }
		/* 820A11FCh case    1:*/		return 0x820A1200;
		  /* 820A1200h */ case    2:  		/* lis R3, -32761 */
		/* 820A1200h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A1200h case    2:*/		return 0x820A1204;
		  /* 820A1204h */ case    3:  		/* ori R3, R3, 14 */
		/* 820A1204h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A1204h case    3:*/		return 0x820A1208;
		  /* 820A1208h */ case    4:  		/* b 24 */
		/* 820A1208h case    4:*/		return 0x820A1220;
		/* 820A1208h case    4:*/		return 0x820A120C;
	}
	return 0x820A120C;
} // Block from 820A11F8h-820A120Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A120Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A120C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A120C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A120C);
		  /* 820A120Ch */ case    0:  		/* lwz R10, <#[R31 + 1680]> */
		/* 820A120Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000690) );
		/* 820A120Ch case    0:*/		return 0x820A1210;
		  /* 820A1210h */ case    1:  		/* li R3, 0 */
		/* 820A1210h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A1210h case    1:*/		return 0x820A1214;
		  /* 820A1214h */ case    2:  		/* stw R10, <#[R11 + 4]> */
		/* 820A1214h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820A1214h case    2:*/		return 0x820A1218;
		  /* 820A1218h */ case    3:  		/* stw R11, <#[R31 + 1680]> */
		/* 820A1218h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000690) );
		/* 820A1218h case    3:*/		return 0x820A121C;
		  /* 820A121Ch */ case    4:  		/* stw R30, <#[R31 + 2256]> */
		/* 820A121Ch case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000008D0) );
		/* 820A121Ch case    4:*/		return 0x820A1220;
	}
	return 0x820A1220;
} // Block from 820A120Ch-820A1220h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A1220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1220);
		  /* 820A1220h */ case    0:  		/* addi R1, R1, 112 */
		/* 820A1220h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A1220h case    0:*/		return 0x820A1224;
		  /* 820A1224h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A1224h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A1224h case    1:*/		return 0x820A1228;
		  /* 820A1228h */ case    2:  		/* mtspr LR, R12 */
		/* 820A1228h case    2:*/		regs.LR = regs.R12;
		/* 820A1228h case    2:*/		return 0x820A122C;
		  /* 820A122Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820A122Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A122Ch case    3:*/		return 0x820A1230;
		  /* 820A1230h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820A1230h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A1230h case    4:*/		return 0x820A1234;
		  /* 820A1234h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820A1234h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A1234h case    5:*/		return 0x820A1238;
	}
	return 0x820A1238;
} // Block from 820A1220h-820A1238h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A1238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1238);
		  /* 820A1238h */ case    0:  		/* mfspr R12, LR */
		/* 820A1238h case    0:*/		regs.R12 = regs.LR;
		/* 820A1238h case    0:*/		return 0x820A123C;
		  /* 820A123Ch */ case    1:  		/* bl -65508 */
		/* 820A123Ch case    1:*/		regs.LR = 0x820A1240; return 0x82091258;
		/* 820A123Ch case    1:*/		return 0x820A1240;
		  /* 820A1240h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820A1240h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820A1240h case    2:*/		return 0x820A1244;
		  /* 820A1244h */ case    3:  		/* li R30, 0 */
		/* 820A1244h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A1244h case    3:*/		return 0x820A1248;
		  /* 820A1248h */ case    4:  		/* mr R28, R3 */
		/* 820A1248h case    4:*/		regs.R28 = regs.R3;
		/* 820A1248h case    4:*/		return 0x820A124C;
		  /* 820A124Ch */ case    5:  		/* stw R30, <#[R4]> */
		/* 820A124Ch case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R4 + 0x00000000) );
		/* 820A124Ch case    5:*/		return 0x820A1250;
		  /* 820A1250h */ case    6:  		/* lwz R11, <#[R3 + 1636]> */
		/* 820A1250h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000664) );
		/* 820A1250h case    6:*/		return 0x820A1254;
		  /* 820A1254h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820A1254h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A1254h case    7:*/		return 0x820A1258;
		  /* 820A1258h */ case    8:  		/* bc 4, CR6_EQ, 1940 */
		/* 820A1258h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A19EC;  }
		/* 820A1258h case    8:*/		return 0x820A125C;
		  /* 820A125Ch */ case    9:  		/* lwz R11, <#[R3 + 1644]> */
		/* 820A125Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000066C) );
		/* 820A125Ch case    9:*/		return 0x820A1260;
		  /* 820A1260h */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 820A1260h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A1260h case   10:*/		return 0x820A1264;
		  /* 820A1264h */ case   11:  		/* bc 4, CR6_EQ, 1928 */
		/* 820A1264h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820A19EC;  }
		/* 820A1264h case   11:*/		return 0x820A1268;
		  /* 820A1268h */ case   12:  		/* lwz R11, <#[R3 + 1668]> */
		/* 820A1268h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000684) );
		/* 820A1268h case   12:*/		return 0x820A126C;
		  /* 820A126Ch */ case   13:  		/* addi R31, R3, 2216 */
		/* 820A126Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x8A8);
		/* 820A126Ch case   13:*/		return 0x820A1270;
		  /* 820A1270h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 820A1270h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A1270h case   14:*/		return 0x820A1274;
		  /* 820A1274h */ case   15:  		/* bc 12, CR6_EQ, 48 */
		/* 820A1274h case   15:*/		if ( regs.CR[6].eq ) { return 0x820A12A4;  }
		/* 820A1274h case   15:*/		return 0x820A1278;
		  /* 820A1278h */ case   16:  		/* li R10, 5 */
		/* 820A1278h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 820A1278h case   16:*/		return 0x820A127C;
		  /* 820A127Ch */ case   17:  		/* addi R9, R11, 8 */
		/* 820A127Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x8);
		/* 820A127Ch case   17:*/		return 0x820A1280;
		  /* 820A1280h */ case   18:  		/* addi R8, R31, -8 */
		/* 820A1280h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0xFFFFFFF8);
		/* 820A1280h case   18:*/		return 0x820A1284;
		  /* 820A1284h */ case   19:  		/* mtspr CTR, R10 */
		/* 820A1284h case   19:*/		regs.CTR = regs.R10;
		/* 820A1284h case   19:*/		return 0x820A1288;
		  /* 820A1288h */ case   20:  		/* ldu R10, <#[R9 + 8]> */
		/* 820A1288h case   20:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820A1288h case   20:*/		return 0x820A128C;
		  /* 820A128Ch */ case   21:  		/* stdu R10, <#[R8 + 8]> */
		/* 820A128Ch case   21:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R8 + 0x00000008) );
		regs.R8 = (uint32)(regs.R8 + 0x00000008);
		/* 820A128Ch case   21:*/		return 0x820A1290;
		  /* 820A1290h */ case   22:  		/* bc 16, CR0_LT, -8 */
		/* 820A1290h case   22:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A1288;  }
		/* 820A1290h case   22:*/		return 0x820A1294;
		  /* 820A1294h */ case   23:  		/* lwz R10, <#[R11 + 12]> */
		/* 820A1294h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A1294h case   23:*/		return 0x820A1298;
		  /* 820A1298h */ case   24:  		/* stw R10, <#[R28 + 1668]> */
		/* 820A1298h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000684) );
		/* 820A1298h case   24:*/		return 0x820A129C;
		  /* 820A129Ch */ case   25:  		/* stw R30, <#[R11 + 12]> */
		/* 820A129Ch case   25:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A129Ch case   25:*/		return 0x820A12A0;
		  /* 820A12A0h */ case   26:  		/* b 32 */
		/* 820A12A0h case   26:*/		return 0x820A12C0;
		/* 820A12A0h case   26:*/		return 0x820A12A4;
	}
	return 0x820A12A4;
} // Block from 820A1238h-820A12A4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820A12A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A12A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A12A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A12A4);
		  /* 820A12A4h */ case    0:  		/* lwz R11, <#[R28 + 2256]> */
		/* 820A12A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000008D0) );
		/* 820A12A4h case    0:*/		return 0x820A12A8;
		  /* 820A12A8h */ case    1:  		/* mr R5, R31 */
		/* 820A12A8h case    1:*/		regs.R5 = regs.R31;
		/* 820A12A8h case    1:*/		return 0x820A12AC;
		  /* 820A12ACh */ case    2:  		/* lwz R3, <#[R28 + 2204]> */
		/* 820A12ACh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x0000089C) );
		/* 820A12ACh case    2:*/		return 0x820A12B0;
		  /* 820A12B0h */ case    3:  		/* ori R4, R11, 4 */
		/* 820A12B0h case    3:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R11,0x4);
		/* 820A12B0h case    3:*/		return 0x820A12B4;
		  /* 820A12B4h */ case    4:  		/* bl 28484 */
		/* 820A12B4h case    4:*/		regs.LR = 0x820A12B8; return 0x820A81F8;
		/* 820A12B4h case    4:*/		return 0x820A12B8;
		  /* 820A12B8h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820A12B8h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A12B8h case    5:*/		return 0x820A12BC;
		  /* 820A12BCh */ case    6:  		/* bc 12, CR0_LT, 1848 */
		/* 820A12BCh case    6:*/		if ( regs.CR[0].lt ) { return 0x820A19F4;  }
		/* 820A12BCh case    6:*/		return 0x820A12C0;
	}
	return 0x820A12C0;
} // Block from 820A12A4h-820A12C0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A12C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A12C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A12C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A12C0);
		  /* 820A12C0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A12C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A12C0h case    0:*/		return 0x820A12C4;
		  /* 820A12C4h */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 820A12C4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820A12C4h case    1:*/		return 0x820A12C8;
		  /* 820A12C8h */ case    2:  		/* bc 12, CR6_EQ, 1656 */
		/* 820A12C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A1940;  }
		/* 820A12C8h case    2:*/		return 0x820A12CC;
		  /* 820A12CCh */ case    3:  		/* bc 4, CR6_GT, 1816 */
		/* 820A12CCh case    3:*/		if ( !regs.CR[6].gt ) { return 0x820A19E4;  }
		/* 820A12CCh case    3:*/		return 0x820A12D0;
		  /* 820A12D0h */ case    4:  		/* cmpwi CR6, R11, 4 */
		/* 820A12D0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 820A12D0h case    4:*/		return 0x820A12D4;
		  /* 820A12D4h */ case    5:  		/* bc 4, CR6_GT, 1636 */
		/* 820A12D4h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820A1938;  }
		/* 820A12D4h case    5:*/		return 0x820A12D8;
		  /* 820A12D8h */ case    6:  		/* cmpwi CR6, R11, 11 */
		/* 820A12D8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820A12D8h case    6:*/		return 0x820A12DC;
		  /* 820A12DCh */ case    7:  		/* bc 12, CR6_EQ, 48 */
		/* 820A12DCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820A130C;  }
		/* 820A12DCh case    7:*/		return 0x820A12E0;
		  /* 820A12E0h */ case    8:  		/* cmpwi CR6, R11, 12 */
		/* 820A12E0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000C);
		/* 820A12E0h case    8:*/		return 0x820A12E4;
		  /* 820A12E4h */ case    9:  		/* bc 12, CR6_EQ, 32 */
		/* 820A12E4h case    9:*/		if ( regs.CR[6].eq ) { return 0x820A1304;  }
		/* 820A12E4h case    9:*/		return 0x820A12E8;
	}
	return 0x820A12E8;
} // Block from 820A12C0h-820A12E8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A12E8h
// Function '?Hash@CPreProcessor@D3DXShader@@IAAIPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A12E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A12E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A12E8);
		  /* 820A12E8h */ case    0:  		/* cmpwi CR6, R11, 16 */
		/* 820A12E8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820A12E8h case    0:*/		return 0x820A12EC;
		  /* 820A12ECh */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820A12ECh case    1:*/		if ( regs.CR[6].eq ) { return 0x820A12F8;  }
		/* 820A12ECh case    1:*/		return 0x820A12F0;
		  /* 820A12F0h */ case    2:  		/* cmpwi CR6, R11, 17 */
		/* 820A12F0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820A12F0h case    2:*/		return 0x820A12F4;
		  /* 820A12F4h */ case    3:  		/* bc 4, CR6_EQ, 1776 */
		/* 820A12F4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A19E4;  }
		/* 820A12F4h case    3:*/		return 0x820A12F8;
	}
	return 0x820A12F8;
} // Block from 820A12E8h-820A12F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A12F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A12F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A12F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A12F8);
		  /* 820A12F8h */ case    0:  		/* li R11, 1 */
		/* 820A12F8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A12F8h case    0:*/		return 0x820A12FC;
		  /* 820A12FCh */ case    1:  		/* stw R11, <#[R28 + 1636]> */
		/* 820A12FCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000664) );
		/* 820A12FCh case    1:*/		return 0x820A1300;
		  /* 820A1300h */ case    2:  		/* b 1780 */
		/* 820A1300h case    2:*/		return 0x820A19F4;
		/* 820A1300h case    2:*/		return 0x820A1304;
	}
	return 0x820A1304;
} // Block from 820A12F8h-820A1304h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A1304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1304);
		  /* 820A1304h */ case    0:  		/* li R3, 280 */
		/* 820A1304h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x118);
		/* 820A1304h case    0:*/		return 0x820A1308;
		  /* 820A1308h */ case    1:  		/* b 1776 */
		/* 820A1308h case    1:*/		return 0x820A19F8;
		/* 820A1308h case    1:*/		return 0x820A130C;
	}
	return 0x820A130C;
} // Block from 820A1304h-820A130Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A130Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A130C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A130C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A130C);
		  /* 820A130Ch */ case    0:  		/* lwz R11, <#[R28 + 1648]> */
		/* 820A130Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000670) );
		/* 820A130Ch case    0:*/		return 0x820A1310;
		  /* 820A1310h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A1310h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A1310h case    1:*/		return 0x820A1314;
		  /* 820A1314h */ case    2:  		/* bc 12, CR6_EQ, 1260 */
		/* 820A1314h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A1800;  }
		/* 820A1314h case    2:*/		return 0x820A1318;
		  /* 820A1318h */ case    3:  		/* lwz R11, <#[R28 + 1652]> */
		/* 820A1318h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000674) );
		/* 820A1318h case    3:*/		return 0x820A131C;
		  /* 820A131Ch */ case    4:  		/* li R29, 1 */
		/* 820A131Ch case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820A131Ch case    4:*/		return 0x820A1320;
		  /* 820A1320h */ case    5:  		/* stw R30, <#[R28 + 1648]> */
		/* 820A1320h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x00000670) );
		/* 820A1320h case    5:*/		return 0x820A1324;
		  /* 820A1324h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 820A1324h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A1324h case    6:*/		return 0x820A1328;
		  /* 820A1328h */ case    7:  		/* lwz R11, <#[R28 + 2224]> */
		/* 820A1328h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000008B0) );
		/* 820A1328h case    7:*/		return 0x820A132C;
		  /* 820A132Ch */ case    8:  		/* stw R30, <#[R28 + 1660]> */
		/* 820A132Ch case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x0000067C) );
		/* 820A132Ch case    8:*/		return 0x820A1330;
		  /* 820A1330h */ case    9:  		/* lbz R10, <#[R11]> */
		/* 820A1330h case    9:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A1330h case    9:*/		return 0x820A1334;
		  /* 820A1334h */ case   10:  		/* bc 12, CR6_EQ, 800 */
		/* 820A1334h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A1654;  }
		/* 820A1334h case   10:*/		return 0x820A1338;
	}
	return 0x820A1338;
} // Block from 820A130Ch-820A1338h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A1338h
// Function '?AreDefinesIdentical@CPreProcessor@D3DXShader@@IAAHPAVCPPDefine@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1338);
		  /* 820A1338h */ case    0:  		/* cmplwi CR6, R10, 100 */
		/* 820A1338h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000064);
		/* 820A1338h case    0:*/		return 0x820A133C;
		  /* 820A133Ch */ case    1:  		/* bc 12, CR6_EQ, 732 */
		/* 820A133Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820A1618;  }
		/* 820A133Ch case    1:*/		return 0x820A1340;
		  /* 820A1340h */ case    2:  		/* cmplwi CR6, R10, 101 */
		/* 820A1340h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000065);
		/* 820A1340h case    2:*/		return 0x820A1344;
		  /* 820A1344h */ case    3:  		/* bc 12, CR6_EQ, 468 */
		/* 820A1344h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A1518;  }
		/* 820A1344h case    3:*/		return 0x820A1348;
		  /* 820A1348h */ case    4:  		/* cmplwi CR6, R10, 105 */
		/* 820A1348h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000069);
		/* 820A1348h case    4:*/		return 0x820A134C;
		  /* 820A134Ch */ case    5:  		/* bc 12, CR6_EQ, 208 */
		/* 820A134Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820A141C;  }
		/* 820A134Ch case    5:*/		return 0x820A1350;
		  /* 820A1350h */ case    6:  		/* cmplwi CR6, R10, 108 */
		/* 820A1350h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000006C);
		/* 820A1350h case    6:*/		return 0x820A1354;
		  /* 820A1354h */ case    7:  		/* bc 12, CR6_EQ, 140 */
		/* 820A1354h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A13E0;  }
		/* 820A1354h case    7:*/		return 0x820A1358;
		  /* 820A1358h */ case    8:  		/* cmplwi CR6, R10, 112 */
		/* 820A1358h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000070);
		/* 820A1358h case    8:*/		return 0x820A135C;
		  /* 820A135Ch */ case    9:  		/* bc 12, CR6_EQ, 72 */
		/* 820A135Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820A13A4;  }
		/* 820A135Ch case    9:*/		return 0x820A1360;
		  /* 820A1360h */ case   10:  		/* cmplwi CR6, R10, 117 */
		/* 820A1360h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000075);
		/* 820A1360h case   10:*/		return 0x820A1364;
		  /* 820A1364h */ case   11:  		/* bc 4, CR6_EQ, 940 */
		/* 820A1364h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820A1710;  }
		/* 820A1364h case   11:*/		return 0x820A1368;
		  /* 820A1368h */ case   12:  		/* lis R10, -32255 */
		/* 820A1368h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A1368h case   12:*/		return 0x820A136C;
		  /* 820A136Ch */ case   13:  		/* addi R10, R10, -10612 */
		/* 820A136Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD68C);
		/* 820A136Ch case   13:*/		return 0x820A1370;
		  /* 820A1370h */ case   14:  		/* lbz R9, <#[R11]> */
		/* 820A1370h case   14:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A1370h case   14:*/		return 0x820A1374;
		  /* 820A1374h */ case   15:  		/* lbz R8, <#[R10]> */
		/* 820A1374h case   15:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1374h case   15:*/		return 0x820A1378;
		  /* 820A1378h */ case   16:  		/* cmpwi CR0, R9, 0 */
		/* 820A1378h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1378h case   16:*/		return 0x820A137C;
		  /* 820A137Ch */ case   17:  		/* subf R9, R8, R9 */
		/* 820A137Ch case   17:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A137Ch case   17:*/		return 0x820A1380;
		  /* 820A1380h */ case   18:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1380h case   18:*/		if ( regs.CR[0].eq ) { return 0x820A1394;  }
		/* 820A1380h case   18:*/		return 0x820A1384;
		  /* 820A1384h */ case   19:  		/* addi R11, R11, 1 */
		/* 820A1384h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A1384h case   19:*/		return 0x820A1388;
		  /* 820A1388h */ case   20:  		/* addi R10, R10, 1 */
		/* 820A1388h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A1388h case   20:*/		return 0x820A138C;
		  /* 820A138Ch */ case   21:  		/* cmpwi CR6, R9, 0 */
		/* 820A138Ch case   21:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A138Ch case   21:*/		return 0x820A1390;
		  /* 820A1390h */ case   22:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1390h case   22:*/		if ( regs.CR[6].eq ) { return 0x820A1370;  }
		/* 820A1390h case   22:*/		return 0x820A1394;
	}
	return 0x820A1394;
} // Block from 820A1338h-820A1394h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820A1394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1394);
		  /* 820A1394h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A1394h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1394h case    0:*/		return 0x820A1398;
		  /* 820A1398h */ case    1:  		/* bc 4, CR0_EQ, 888 */
		/* 820A1398h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A1710;  }
		/* 820A1398h case    1:*/		return 0x820A139C;
		  /* 820A139Ch */ case    2:  		/* li R3, 258 */
		/* 820A139Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x102);
		/* 820A139Ch case    2:*/		return 0x820A13A0;
		  /* 820A13A0h */ case    3:  		/* b 1624 */
		/* 820A13A0h case    3:*/		return 0x820A19F8;
		/* 820A13A0h case    3:*/		return 0x820A13A4;
	}
	return 0x820A13A4;
} // Block from 820A1394h-820A13A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A13A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A13A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A13A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A13A4);
		  /* 820A13A4h */ case    0:  		/* lis R10, -32255 */
		/* 820A13A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A13A4h case    0:*/		return 0x820A13A8;
		  /* 820A13A8h */ case    1:  		/* addi R10, R10, -10620 */
		/* 820A13A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD684);
		/* 820A13A8h case    1:*/		return 0x820A13AC;
		  /* 820A13ACh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A13ACh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A13ACh case    2:*/		return 0x820A13B0;
		  /* 820A13B0h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A13B0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A13B0h case    3:*/		return 0x820A13B4;
		  /* 820A13B4h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A13B4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A13B4h case    4:*/		return 0x820A13B8;
		  /* 820A13B8h */ case    5:  		/* subf R9, R8, R9 */
		/* 820A13B8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A13B8h case    5:*/		return 0x820A13BC;
		  /* 820A13BCh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820A13BCh case    6:*/		if ( regs.CR[0].eq ) { return 0x820A13D0;  }
		/* 820A13BCh case    6:*/		return 0x820A13C0;
		  /* 820A13C0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A13C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A13C0h case    7:*/		return 0x820A13C4;
		  /* 820A13C4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820A13C4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A13C4h case    8:*/		return 0x820A13C8;
		  /* 820A13C8h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820A13C8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A13C8h case    9:*/		return 0x820A13CC;
		  /* 820A13CCh */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820A13CCh case   10:*/		if ( regs.CR[6].eq ) { return 0x820A13AC;  }
		/* 820A13CCh case   10:*/		return 0x820A13D0;
	}
	return 0x820A13D0;
} // Block from 820A13A4h-820A13D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A13D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A13D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A13D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A13D0);
		  /* 820A13D0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A13D0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A13D0h case    0:*/		return 0x820A13D4;
		  /* 820A13D4h */ case    1:  		/* bc 4, CR0_EQ, 828 */
		/* 820A13D4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A1710;  }
		/* 820A13D4h case    1:*/		return 0x820A13D8;
		  /* 820A13D8h */ case    2:  		/* li R3, 270 */
		/* 820A13D8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x10E);
		/* 820A13D8h case    2:*/		return 0x820A13DC;
		  /* 820A13DCh */ case    3:  		/* b 1564 */
		/* 820A13DCh case    3:*/		return 0x820A19F8;
		/* 820A13DCh case    3:*/		return 0x820A13E0;
	}
	return 0x820A13E0;
} // Block from 820A13D0h-820A13E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A13E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A13E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A13E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A13E0);
		  /* 820A13E0h */ case    0:  		/* lis R10, -32255 */
		/* 820A13E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A13E0h case    0:*/		return 0x820A13E4;
		  /* 820A13E4h */ case    1:  		/* addi R10, R10, -10628 */
		/* 820A13E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD67C);
		/* 820A13E4h case    1:*/		return 0x820A13E8;
		  /* 820A13E8h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A13E8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A13E8h case    2:*/		return 0x820A13EC;
		  /* 820A13ECh */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A13ECh case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A13ECh case    3:*/		return 0x820A13F0;
		  /* 820A13F0h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A13F0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A13F0h case    4:*/		return 0x820A13F4;
		  /* 820A13F4h */ case    5:  		/* subf R9, R8, R9 */
		/* 820A13F4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A13F4h case    5:*/		return 0x820A13F8;
		  /* 820A13F8h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820A13F8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A140C;  }
		/* 820A13F8h case    6:*/		return 0x820A13FC;
		  /* 820A13FCh */ case    7:  		/* addi R11, R11, 1 */
		/* 820A13FCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A13FCh case    7:*/		return 0x820A1400;
		  /* 820A1400h */ case    8:  		/* addi R10, R10, 1 */
		/* 820A1400h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A1400h case    8:*/		return 0x820A1404;
		  /* 820A1404h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820A1404h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A1404h case    9:*/		return 0x820A1408;
		  /* 820A1408h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1408h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A13E8;  }
		/* 820A1408h case   10:*/		return 0x820A140C;
	}
	return 0x820A140C;
} // Block from 820A13E0h-820A140Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A140Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A140C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A140C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A140C);
		  /* 820A140Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A140Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A140Ch case    0:*/		return 0x820A1410;
		  /* 820A1410h */ case    1:  		/* bc 4, CR0_EQ, 768 */
		/* 820A1410h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A1710;  }
		/* 820A1410h case    1:*/		return 0x820A1414;
		  /* 820A1414h */ case    2:  		/* li R3, 259 */
		/* 820A1414h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x103);
		/* 820A1414h case    2:*/		return 0x820A1418;
		  /* 820A1418h */ case    3:  		/* b 1504 */
		/* 820A1418h case    3:*/		return 0x820A19F8;
		/* 820A1418h case    3:*/		return 0x820A141C;
	}
	return 0x820A141C;
} // Block from 820A140Ch-820A141Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A141Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A141C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A141C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A141C);
		  /* 820A141Ch */ case    0:  		/* lis R9, -32255 */
		/* 820A141Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A141Ch case    0:*/		return 0x820A1420;
		  /* 820A1420h */ case    1:  		/* mr R10, R11 */
		/* 820A1420h case    1:*/		regs.R10 = regs.R11;
		/* 820A1420h case    1:*/		return 0x820A1424;
		  /* 820A1424h */ case    2:  		/* addi R9, R9, -10632 */
		/* 820A1424h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFD678);
		/* 820A1424h case    2:*/		return 0x820A1428;
		  /* 820A1428h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A1428h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1428h case    3:*/		return 0x820A142C;
		  /* 820A142Ch */ case    4:  		/* lbz R7, <#[R9]> */
		/* 820A142Ch case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A142Ch case    4:*/		return 0x820A1430;
		  /* 820A1430h */ case    5:  		/* cmpwi CR0, R8, 0 */
		/* 820A1430h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A1430h case    5:*/		return 0x820A1434;
		  /* 820A1434h */ case    6:  		/* subf R8, R7, R8 */
		/* 820A1434h case    6:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A1434h case    6:*/		return 0x820A1438;
		  /* 820A1438h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1438h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A144C;  }
		/* 820A1438h case    7:*/		return 0x820A143C;
		  /* 820A143Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820A143Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A143Ch case    8:*/		return 0x820A1440;
		  /* 820A1440h */ case    9:  		/* addi R9, R9, 1 */
		/* 820A1440h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A1440h case    9:*/		return 0x820A1444;
		  /* 820A1444h */ case   10:  		/* cmpwi CR6, R8, 0 */
		/* 820A1444h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A1444h case   10:*/		return 0x820A1448;
		  /* 820A1448h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1448h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A1428;  }
		/* 820A1448h case   11:*/		return 0x820A144C;
	}
	return 0x820A144C;
} // Block from 820A141Ch-820A144Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A144Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A144C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A144C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A144C);
		  /* 820A144Ch */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A144Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A144Ch case    0:*/		return 0x820A1450;
		  /* 820A1450h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A1450h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A145C;  }
		/* 820A1450h case    1:*/		return 0x820A1454;
		  /* 820A1454h */ case    2:  		/* li R3, 262 */
		/* 820A1454h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x106);
		/* 820A1454h case    2:*/		return 0x820A1458;
		  /* 820A1458h */ case    3:  		/* b 252 */
		/* 820A1458h case    3:*/		return 0x820A1554;
		/* 820A1458h case    3:*/		return 0x820A145C;
	}
	return 0x820A145C;
} // Block from 820A144Ch-820A145Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A145Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A145C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A145C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A145C);
		  /* 820A145Ch */ case    0:  		/* lis R9, -32255 */
		/* 820A145Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A145Ch case    0:*/		return 0x820A1460;
		  /* 820A1460h */ case    1:  		/* mr R10, R11 */
		/* 820A1460h case    1:*/		regs.R10 = regs.R11;
		/* 820A1460h case    1:*/		return 0x820A1464;
		  /* 820A1464h */ case    2:  		/* addi R9, R9, -10640 */
		/* 820A1464h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFD670);
		/* 820A1464h case    2:*/		return 0x820A1468;
		  /* 820A1468h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A1468h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1468h case    3:*/		return 0x820A146C;
		  /* 820A146Ch */ case    4:  		/* lbz R7, <#[R9]> */
		/* 820A146Ch case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A146Ch case    4:*/		return 0x820A1470;
		  /* 820A1470h */ case    5:  		/* cmpwi CR0, R8, 0 */
		/* 820A1470h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A1470h case    5:*/		return 0x820A1474;
		  /* 820A1474h */ case    6:  		/* subf R8, R7, R8 */
		/* 820A1474h case    6:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A1474h case    6:*/		return 0x820A1478;
		  /* 820A1478h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1478h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A148C;  }
		/* 820A1478h case    7:*/		return 0x820A147C;
		  /* 820A147Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820A147Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A147Ch case    8:*/		return 0x820A1480;
		  /* 820A1480h */ case    9:  		/* addi R9, R9, 1 */
		/* 820A1480h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A1480h case    9:*/		return 0x820A1484;
		  /* 820A1484h */ case   10:  		/* cmpwi CR6, R8, 0 */
		/* 820A1484h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A1484h case   10:*/		return 0x820A1488;
		  /* 820A1488h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1488h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A1468;  }
		/* 820A1488h case   11:*/		return 0x820A148C;
	}
	return 0x820A148C;
} // Block from 820A145Ch-820A148Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A148Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A148C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A148C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A148C);
		  /* 820A148Ch */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A148Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A148Ch case    0:*/		return 0x820A1490;
		  /* 820A1490h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A1490h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A149C;  }
		/* 820A1490h case    1:*/		return 0x820A1494;
		  /* 820A1494h */ case    2:  		/* li R3, 263 */
		/* 820A1494h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x107);
		/* 820A1494h case    2:*/		return 0x820A1498;
		  /* 820A1498h */ case    3:  		/* b 1376 */
		/* 820A1498h case    3:*/		return 0x820A19F8;
		/* 820A1498h case    3:*/		return 0x820A149C;
	}
	return 0x820A149C;
} // Block from 820A148Ch-820A149Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A149Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A149C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A149C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A149C);
		  /* 820A149Ch */ case    0:  		/* lis R9, -32255 */
		/* 820A149Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A149Ch case    0:*/		return 0x820A14A0;
		  /* 820A14A0h */ case    1:  		/* mr R10, R11 */
		/* 820A14A0h case    1:*/		regs.R10 = regs.R11;
		/* 820A14A0h case    1:*/		return 0x820A14A4;
		  /* 820A14A4h */ case    2:  		/* addi R9, R9, -10648 */
		/* 820A14A4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFD668);
		/* 820A14A4h case    2:*/		return 0x820A14A8;
		  /* 820A14A8h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A14A8h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A14A8h case    3:*/		return 0x820A14AC;
		  /* 820A14ACh */ case    4:  		/* lbz R7, <#[R9]> */
		/* 820A14ACh case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A14ACh case    4:*/		return 0x820A14B0;
		  /* 820A14B0h */ case    5:  		/* cmpwi CR0, R8, 0 */
		/* 820A14B0h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A14B0h case    5:*/		return 0x820A14B4;
		  /* 820A14B4h */ case    6:  		/* subf R8, R7, R8 */
		/* 820A14B4h case    6:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A14B4h case    6:*/		return 0x820A14B8;
		  /* 820A14B8h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A14B8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A14CC;  }
		/* 820A14B8h case    7:*/		return 0x820A14BC;
		  /* 820A14BCh */ case    8:  		/* addi R10, R10, 1 */
		/* 820A14BCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A14BCh case    8:*/		return 0x820A14C0;
		  /* 820A14C0h */ case    9:  		/* addi R9, R9, 1 */
		/* 820A14C0h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A14C0h case    9:*/		return 0x820A14C4;
		  /* 820A14C4h */ case   10:  		/* cmpwi CR6, R8, 0 */
		/* 820A14C4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A14C4h case   10:*/		return 0x820A14C8;
		  /* 820A14C8h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A14C8h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A14A8;  }
		/* 820A14C8h case   11:*/		return 0x820A14CC;
	}
	return 0x820A14CC;
} // Block from 820A149Ch-820A14CCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A14CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A14CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A14CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A14CC);
		  /* 820A14CCh */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A14CCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A14CCh case    0:*/		return 0x820A14D0;
		  /* 820A14D0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A14D0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A14DC;  }
		/* 820A14D0h case    1:*/		return 0x820A14D4;
		  /* 820A14D4h */ case    2:  		/* li R3, 264 */
		/* 820A14D4h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x108);
		/* 820A14D4h case    2:*/		return 0x820A14D8;
		  /* 820A14D8h */ case    3:  		/* b 1312 */
		/* 820A14D8h case    3:*/		return 0x820A19F8;
		/* 820A14D8h case    3:*/		return 0x820A14DC;
	}
	return 0x820A14DC;
} // Block from 820A14CCh-820A14DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A14DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A14DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A14DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A14DC);
		  /* 820A14DCh */ case    0:  		/* lis R10, -32255 */
		/* 820A14DCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A14DCh case    0:*/		return 0x820A14E0;
		  /* 820A14E0h */ case    1:  		/* addi R10, R10, -10656 */
		/* 820A14E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD660);
		/* 820A14E0h case    1:*/		return 0x820A14E4;
		  /* 820A14E4h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A14E4h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A14E4h case    2:*/		return 0x820A14E8;
		  /* 820A14E8h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A14E8h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A14E8h case    3:*/		return 0x820A14EC;
		  /* 820A14ECh */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A14ECh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A14ECh case    4:*/		return 0x820A14F0;
		  /* 820A14F0h */ case    5:  		/* subf R9, R8, R9 */
		/* 820A14F0h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A14F0h case    5:*/		return 0x820A14F4;
		  /* 820A14F4h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820A14F4h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A1508;  }
		/* 820A14F4h case    6:*/		return 0x820A14F8;
		  /* 820A14F8h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A14F8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A14F8h case    7:*/		return 0x820A14FC;
		  /* 820A14FCh */ case    8:  		/* addi R10, R10, 1 */
		/* 820A14FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A14FCh case    8:*/		return 0x820A1500;
		  /* 820A1500h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820A1500h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A1500h case    9:*/		return 0x820A1504;
		  /* 820A1504h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1504h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A14E4;  }
		/* 820A1504h case   10:*/		return 0x820A1508;
	}
	return 0x820A1508;
} // Block from 820A14DCh-820A1508h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A1508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1508);
		  /* 820A1508h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A1508h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1508h case    0:*/		return 0x820A150C;
		  /* 820A150Ch */ case    1:  		/* bc 4, CR0_EQ, 516 */
		/* 820A150Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A1710;  }
		/* 820A150Ch case    1:*/		return 0x820A1510;
		  /* 820A1510h */ case    2:  		/* li R3, 260 */
		/* 820A1510h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x104);
		/* 820A1510h case    2:*/		return 0x820A1514;
		  /* 820A1514h */ case    3:  		/* b 1252 */
		/* 820A1514h case    3:*/		return 0x820A19F8;
		/* 820A1514h case    3:*/		return 0x820A1518;
	}
	return 0x820A1518;
} // Block from 820A1508h-820A1518h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A1518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1518);
		  /* 820A1518h */ case    0:  		/* lis R9, -32255 */
		/* 820A1518h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A1518h case    0:*/		return 0x820A151C;
		  /* 820A151Ch */ case    1:  		/* mr R10, R11 */
		/* 820A151Ch case    1:*/		regs.R10 = regs.R11;
		/* 820A151Ch case    1:*/		return 0x820A1520;
		  /* 820A1520h */ case    2:  		/* addi R9, R9, -10664 */
		/* 820A1520h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFD658);
		/* 820A1520h case    2:*/		return 0x820A1524;
		  /* 820A1524h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A1524h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1524h case    3:*/		return 0x820A1528;
		  /* 820A1528h */ case    4:  		/* lbz R7, <#[R9]> */
		/* 820A1528h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A1528h case    4:*/		return 0x820A152C;
		  /* 820A152Ch */ case    5:  		/* cmpwi CR0, R8, 0 */
		/* 820A152Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A152Ch case    5:*/		return 0x820A1530;
		  /* 820A1530h */ case    6:  		/* subf R8, R7, R8 */
		/* 820A1530h case    6:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A1530h case    6:*/		return 0x820A1534;
		  /* 820A1534h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1534h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A1548;  }
		/* 820A1534h case    7:*/		return 0x820A1538;
		  /* 820A1538h */ case    8:  		/* addi R10, R10, 1 */
		/* 820A1538h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A1538h case    8:*/		return 0x820A153C;
		  /* 820A153Ch */ case    9:  		/* addi R9, R9, 1 */
		/* 820A153Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A153Ch case    9:*/		return 0x820A1540;
		  /* 820A1540h */ case   10:  		/* cmpwi CR6, R8, 0 */
		/* 820A1540h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A1540h case   10:*/		return 0x820A1544;
		  /* 820A1544h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1544h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A1524;  }
		/* 820A1544h case   11:*/		return 0x820A1548;
	}
	return 0x820A1548;
} // Block from 820A1518h-820A1548h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A1548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1548);
		  /* 820A1548h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A1548h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A1548h case    0:*/		return 0x820A154C;
		  /* 820A154Ch */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A154Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A155C;  }
		/* 820A154Ch case    1:*/		return 0x820A1550;
		  /* 820A1550h */ case    2:  		/* li R3, 265 */
		/* 820A1550h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x109);
		/* 820A1550h case    2:*/		return 0x820A1554;
	}
	return 0x820A1554;
} // Block from 820A1548h-820A1554h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A1554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1554);
		  /* 820A1554h */ case    0:  		/* stw R29, <#[R28 + 1660]> */
		/* 820A1554h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + 0x0000067C) );
		/* 820A1554h case    0:*/		return 0x820A1558;
		  /* 820A1558h */ case    1:  		/* b 1184 */
		/* 820A1558h case    1:*/		return 0x820A19F8;
		/* 820A1558h case    1:*/		return 0x820A155C;
	}
	return 0x820A155C;
} // Block from 820A1554h-820A155Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A155Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A155C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A155C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A155C);
		  /* 820A155Ch */ case    0:  		/* lis R9, -32255 */
		/* 820A155Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A155Ch case    0:*/		return 0x820A1560;
		  /* 820A1560h */ case    1:  		/* mr R10, R11 */
		/* 820A1560h case    1:*/		regs.R10 = regs.R11;
		/* 820A1560h case    1:*/		return 0x820A1564;
		  /* 820A1564h */ case    2:  		/* addi R9, R9, -10672 */
		/* 820A1564h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFD650);
		/* 820A1564h case    2:*/		return 0x820A1568;
		  /* 820A1568h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A1568h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1568h case    3:*/		return 0x820A156C;
		  /* 820A156Ch */ case    4:  		/* lbz R7, <#[R9]> */
		/* 820A156Ch case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A156Ch case    4:*/		return 0x820A1570;
		  /* 820A1570h */ case    5:  		/* cmpwi CR0, R8, 0 */
		/* 820A1570h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A1570h case    5:*/		return 0x820A1574;
		  /* 820A1574h */ case    6:  		/* subf R8, R7, R8 */
		/* 820A1574h case    6:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A1574h case    6:*/		return 0x820A1578;
		  /* 820A1578h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1578h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A158C;  }
		/* 820A1578h case    7:*/		return 0x820A157C;
		  /* 820A157Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820A157Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A157Ch case    8:*/		return 0x820A1580;
		  /* 820A1580h */ case    9:  		/* addi R9, R9, 1 */
		/* 820A1580h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A1580h case    9:*/		return 0x820A1584;
		  /* 820A1584h */ case   10:  		/* cmpwi CR6, R8, 0 */
		/* 820A1584h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A1584h case   10:*/		return 0x820A1588;
		  /* 820A1588h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1588h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A1568;  }
		/* 820A1588h case   11:*/		return 0x820A158C;
	}
	return 0x820A158C;
} // Block from 820A155Ch-820A158Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A158Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A158C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A158C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A158C);
		  /* 820A158Ch */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A158Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A158Ch case    0:*/		return 0x820A1590;
		  /* 820A1590h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A1590h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A159C;  }
		/* 820A1590h case    1:*/		return 0x820A1594;
		  /* 820A1594h */ case    2:  		/* li R3, 266 */
		/* 820A1594h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x10A);
		/* 820A1594h case    2:*/		return 0x820A1598;
		  /* 820A1598h */ case    3:  		/* b 1120 */
		/* 820A1598h case    3:*/		return 0x820A19F8;
		/* 820A1598h case    3:*/		return 0x820A159C;
	}
	return 0x820A159C;
} // Block from 820A158Ch-820A159Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A159Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A159C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A159C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A159C);
		  /* 820A159Ch */ case    0:  		/* lis R9, -32255 */
		/* 820A159Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A159Ch case    0:*/		return 0x820A15A0;
		  /* 820A15A0h */ case    1:  		/* mr R10, R11 */
		/* 820A15A0h case    1:*/		regs.R10 = regs.R11;
		/* 820A15A0h case    1:*/		return 0x820A15A4;
		  /* 820A15A4h */ case    2:  		/* addi R9, R9, -10680 */
		/* 820A15A4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFD648);
		/* 820A15A4h case    2:*/		return 0x820A15A8;
		  /* 820A15A8h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A15A8h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A15A8h case    3:*/		return 0x820A15AC;
		  /* 820A15ACh */ case    4:  		/* lbz R7, <#[R9]> */
		/* 820A15ACh case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A15ACh case    4:*/		return 0x820A15B0;
		  /* 820A15B0h */ case    5:  		/* cmpwi CR0, R8, 0 */
		/* 820A15B0h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A15B0h case    5:*/		return 0x820A15B4;
		  /* 820A15B4h */ case    6:  		/* subf R8, R7, R8 */
		/* 820A15B4h case    6:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A15B4h case    6:*/		return 0x820A15B8;
		  /* 820A15B8h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A15B8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A15CC;  }
		/* 820A15B8h case    7:*/		return 0x820A15BC;
		  /* 820A15BCh */ case    8:  		/* addi R10, R10, 1 */
		/* 820A15BCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A15BCh case    8:*/		return 0x820A15C0;
		  /* 820A15C0h */ case    9:  		/* addi R9, R9, 1 */
		/* 820A15C0h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A15C0h case    9:*/		return 0x820A15C4;
		  /* 820A15C4h */ case   10:  		/* cmpwi CR6, R8, 0 */
		/* 820A15C4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A15C4h case   10:*/		return 0x820A15C8;
		  /* 820A15C8h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A15C8h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A15A8;  }
		/* 820A15C8h case   11:*/		return 0x820A15CC;
	}
	return 0x820A15CC;
} // Block from 820A159Ch-820A15CCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A15CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A15CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A15CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A15CC);
		  /* 820A15CCh */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A15CCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A15CCh case    0:*/		return 0x820A15D0;
		  /* 820A15D0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A15D0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A15DC;  }
		/* 820A15D0h case    1:*/		return 0x820A15D4;
		  /* 820A15D4h */ case    2:  		/* li R3, 267 */
		/* 820A15D4h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x10B);
		/* 820A15D4h case    2:*/		return 0x820A15D8;
		  /* 820A15D8h */ case    3:  		/* b 1056 */
		/* 820A15D8h case    3:*/		return 0x820A19F8;
		/* 820A15D8h case    3:*/		return 0x820A15DC;
	}
	return 0x820A15DC;
} // Block from 820A15CCh-820A15DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A15DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A15DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A15DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A15DC);
		  /* 820A15DCh */ case    0:  		/* lis R10, -32255 */
		/* 820A15DCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A15DCh case    0:*/		return 0x820A15E0;
		  /* 820A15E0h */ case    1:  		/* addi R10, R10, -10816 */
		/* 820A15E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD5C0);
		/* 820A15E0h case    1:*/		return 0x820A15E4;
		  /* 820A15E4h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A15E4h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A15E4h case    2:*/		return 0x820A15E8;
		  /* 820A15E8h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A15E8h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A15E8h case    3:*/		return 0x820A15EC;
		  /* 820A15ECh */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A15ECh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A15ECh case    4:*/		return 0x820A15F0;
	}
	return 0x820A15F0;
} // Block from 820A15DCh-820A15F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A15F0h
// Function '?SetTreatDigitsAsLetters@CPreProcessor@D3DXShader@@QAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A15F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A15F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A15F0);
		  /* 820A15F0h */ case    0:  		/* subf R9, R8, R9 */
		/* 820A15F0h case    0:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A15F0h case    0:*/		return 0x820A15F4;
		  /* 820A15F4h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820A15F4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A1608;  }
		/* 820A15F4h case    1:*/		return 0x820A15F8;
	}
	return 0x820A15F8;
} // Block from 820A15F0h-820A15F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A15F8h
// Function '?IsDefineRecursive@CPreProcessor@D3DXShader@@IAAHPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A15F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A15F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A15F8);
		  /* 820A15F8h */ case    0:  		/* addi R11, R11, 1 */
		/* 820A15F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A15F8h case    0:*/		return 0x820A15FC;
		  /* 820A15FCh */ case    1:  		/* addi R10, R10, 1 */
		/* 820A15FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A15FCh case    1:*/		return 0x820A1600;
		  /* 820A1600h */ case    2:  		/* cmpwi CR6, R9, 0 */
		/* 820A1600h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A1600h case    2:*/		return 0x820A1604;
		  /* 820A1604h */ case    3:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1604h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A15E4;  }
		/* 820A1604h case    3:*/		return 0x820A1608;
	}
	return 0x820A1608;
} // Block from 820A15F8h-820A1608h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A1608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1608);
		  /* 820A1608h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A1608h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1608h case    0:*/		return 0x820A160C;
		  /* 820A160Ch */ case    1:  		/* bc 4, CR0_EQ, 260 */
		/* 820A160Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A1710;  }
		/* 820A160Ch case    1:*/		return 0x820A1610;
		  /* 820A1610h */ case    2:  		/* li R3, 261 */
		/* 820A1610h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x105);
		/* 820A1610h case    2:*/		return 0x820A1614;
		  /* 820A1614h */ case    3:  		/* b 996 */
		/* 820A1614h case    3:*/		return 0x820A19F8;
		/* 820A1614h case    3:*/		return 0x820A1618;
	}
	return 0x820A1618;
} // Block from 820A1608h-820A1618h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A1618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1618);
		  /* 820A1618h */ case    0:  		/* lis R10, -32255 */
		/* 820A1618h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A1618h case    0:*/		return 0x820A161C;
		  /* 820A161Ch */ case    1:  		/* addi R10, R10, -10688 */
		/* 820A161Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD640);
		/* 820A161Ch case    1:*/		return 0x820A1620;
		  /* 820A1620h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A1620h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A1620h case    2:*/		return 0x820A1624;
		  /* 820A1624h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A1624h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1624h case    3:*/		return 0x820A1628;
		  /* 820A1628h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A1628h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1628h case    4:*/		return 0x820A162C;
		  /* 820A162Ch */ case    5:  		/* subf R9, R8, R9 */
		/* 820A162Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A162Ch case    5:*/		return 0x820A1630;
		  /* 820A1630h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1630h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A1644;  }
		/* 820A1630h case    6:*/		return 0x820A1634;
		  /* 820A1634h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A1634h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A1634h case    7:*/		return 0x820A1638;
		  /* 820A1638h */ case    8:  		/* addi R10, R10, 1 */
		/* 820A1638h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A1638h case    8:*/		return 0x820A163C;
		  /* 820A163Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820A163Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A163Ch case    9:*/		return 0x820A1640;
		  /* 820A1640h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1640h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A1620;  }
		/* 820A1640h case   10:*/		return 0x820A1644;
	}
	return 0x820A1644;
} // Block from 820A1618h-820A1644h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A1644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1644);
		  /* 820A1644h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A1644h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1644h case    0:*/		return 0x820A1648;
		  /* 820A1648h */ case    1:  		/* bc 4, CR0_EQ, 200 */
		/* 820A1648h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A1710;  }
		/* 820A1648h case    1:*/		return 0x820A164C;
		  /* 820A164Ch */ case    2:  		/* li R3, 257 */
		/* 820A164Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x101);
		/* 820A164Ch case    2:*/		return 0x820A1650;
		  /* 820A1650h */ case    3:  		/* b 936 */
		/* 820A1650h case    3:*/		return 0x820A19F8;
		/* 820A1650h case    3:*/		return 0x820A1654;
	}
	return 0x820A1654;
} // Block from 820A1644h-820A1654h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A1654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1654);
		  /* 820A1654h */ case    0:  		/* cmplwi CR6, R10, 101 */
		/* 820A1654h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000065);
		/* 820A1654h case    0:*/		return 0x820A1658;
		  /* 820A1658h */ case    1:  		/* bc 12, CR6_EQ, 196 */
		/* 820A1658h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A171C;  }
		/* 820A1658h case    1:*/		return 0x820A165C;
		  /* 820A165Ch */ case    2:  		/* cmplwi CR6, R10, 105 */
		/* 820A165Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000069);
		/* 820A165Ch case    2:*/		return 0x820A1660;
		  /* 820A1660h */ case    3:  		/* bc 4, CR6_EQ, 176 */
		/* 820A1660h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A1710;  }
		/* 820A1660h case    3:*/		return 0x820A1664;
		  /* 820A1664h */ case    4:  		/* lis R9, -32255 */
		/* 820A1664h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A1664h case    4:*/		return 0x820A1668;
		  /* 820A1668h */ case    5:  		/* mr R10, R11 */
		/* 820A1668h case    5:*/		regs.R10 = regs.R11;
		/* 820A1668h case    5:*/		return 0x820A166C;
		  /* 820A166Ch */ case    6:  		/* addi R9, R9, -10632 */
		/* 820A166Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFD678);
		/* 820A166Ch case    6:*/		return 0x820A1670;
		  /* 820A1670h */ case    7:  		/* lbz R8, <#[R10]> */
		/* 820A1670h case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1670h case    7:*/		return 0x820A1674;
		  /* 820A1674h */ case    8:  		/* lbz R7, <#[R9]> */
		/* 820A1674h case    8:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A1674h case    8:*/		return 0x820A1678;
		  /* 820A1678h */ case    9:  		/* cmpwi CR0, R8, 0 */
		/* 820A1678h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A1678h case    9:*/		return 0x820A167C;
		  /* 820A167Ch */ case   10:  		/* subf R8, R7, R8 */
		/* 820A167Ch case   10:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A167Ch case   10:*/		return 0x820A1680;
		  /* 820A1680h */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1680h case   11:*/		if ( regs.CR[0].eq ) { return 0x820A1694;  }
		/* 820A1680h case   11:*/		return 0x820A1684;
		  /* 820A1684h */ case   12:  		/* addi R10, R10, 1 */
		/* 820A1684h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A1684h case   12:*/		return 0x820A1688;
		  /* 820A1688h */ case   13:  		/* addi R9, R9, 1 */
		/* 820A1688h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A1688h case   13:*/		return 0x820A168C;
		  /* 820A168Ch */ case   14:  		/* cmpwi CR6, R8, 0 */
		/* 820A168Ch case   14:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A168Ch case   14:*/		return 0x820A1690;
		  /* 820A1690h */ case   15:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1690h case   15:*/		if ( regs.CR[6].eq ) { return 0x820A1670;  }
		/* 820A1690h case   15:*/		return 0x820A1694;
	}
	return 0x820A1694;
} // Block from 820A1654h-820A1694h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A1694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1694);
		  /* 820A1694h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A1694h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A1694h case    0:*/		return 0x820A1698;
		  /* 820A1698h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A1698h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A16A4;  }
		/* 820A1698h case    1:*/		return 0x820A169C;
		  /* 820A169Ch */ case    2:  		/* li R3, 268 */
		/* 820A169Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x10C);
		/* 820A169Ch case    2:*/		return 0x820A16A0;
		  /* 820A16A0h */ case    3:  		/* b 856 */
		/* 820A16A0h case    3:*/		return 0x820A19F8;
		/* 820A16A0h case    3:*/		return 0x820A16A4;
	}
	return 0x820A16A4;
} // Block from 820A1694h-820A16A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A16A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A16A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A16A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A16A4);
		  /* 820A16A4h */ case    0:  		/* lis R9, -32255 */
		/* 820A16A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A16A4h case    0:*/		return 0x820A16A8;
		  /* 820A16A8h */ case    1:  		/* mr R10, R11 */
		/* 820A16A8h case    1:*/		regs.R10 = regs.R11;
		/* 820A16A8h case    1:*/		return 0x820A16AC;
		  /* 820A16ACh */ case    2:  		/* addi R9, R9, -10640 */
		/* 820A16ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFD670);
		/* 820A16ACh case    2:*/		return 0x820A16B0;
		  /* 820A16B0h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A16B0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A16B0h case    3:*/		return 0x820A16B4;
		  /* 820A16B4h */ case    4:  		/* lbz R7, <#[R9]> */
		/* 820A16B4h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A16B4h case    4:*/		return 0x820A16B8;
		  /* 820A16B8h */ case    5:  		/* cmpwi CR0, R8, 0 */
		/* 820A16B8h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A16B8h case    5:*/		return 0x820A16BC;
		  /* 820A16BCh */ case    6:  		/* subf R8, R7, R8 */
		/* 820A16BCh case    6:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A16BCh case    6:*/		return 0x820A16C0;
		  /* 820A16C0h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A16C0h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A16D4;  }
		/* 820A16C0h case    7:*/		return 0x820A16C4;
		  /* 820A16C4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820A16C4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A16C4h case    8:*/		return 0x820A16C8;
		  /* 820A16C8h */ case    9:  		/* addi R9, R9, 1 */
		/* 820A16C8h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A16C8h case    9:*/		return 0x820A16CC;
		  /* 820A16CCh */ case   10:  		/* cmpwi CR6, R8, 0 */
		/* 820A16CCh case   10:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A16CCh case   10:*/		return 0x820A16D0;
		  /* 820A16D0h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A16D0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A16B0;  }
		/* 820A16D0h case   11:*/		return 0x820A16D4;
	}
	return 0x820A16D4;
} // Block from 820A16A4h-820A16D4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A16D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A16D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A16D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A16D4);
		  /* 820A16D4h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A16D4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A16D4h case    0:*/		return 0x820A16D8;
		  /* 820A16D8h */ case    1:  		/* bc 12, CR0_EQ, -60 */
		/* 820A16D8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A169C;  }
		/* 820A16D8h case    1:*/		return 0x820A16DC;
		  /* 820A16DCh */ case    2:  		/* lis R10, -32255 */
		/* 820A16DCh case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A16DCh case    2:*/		return 0x820A16E0;
	}
	return 0x820A16E0;
} // Block from 820A16D4h-820A16E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A16E0h
// Function '?FindDefine@CPreProcessor@D3DXShader@@IAAHPBDPAPAVCNode@2@1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A16E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A16E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A16E0);
		  /* 820A16E0h */ case    0:  		/* addi R10, R10, -10648 */
		/* 820A16E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD668);
		/* 820A16E0h case    0:*/		return 0x820A16E4;
		  /* 820A16E4h */ case    1:  		/* lbz R9, <#[R11]> */
		/* 820A16E4h case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A16E4h case    1:*/		return 0x820A16E8;
		  /* 820A16E8h */ case    2:  		/* lbz R8, <#[R10]> */
		/* 820A16E8h case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A16E8h case    2:*/		return 0x820A16EC;
		  /* 820A16ECh */ case    3:  		/* cmpwi CR0, R9, 0 */
		/* 820A16ECh case    3:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A16ECh case    3:*/		return 0x820A16F0;
		  /* 820A16F0h */ case    4:  		/* subf R9, R8, R9 */
		/* 820A16F0h case    4:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A16F0h case    4:*/		return 0x820A16F4;
		  /* 820A16F4h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 820A16F4h case    5:*/		if ( regs.CR[0].eq ) { return 0x820A1708;  }
		/* 820A16F4h case    5:*/		return 0x820A16F8;
		  /* 820A16F8h */ case    6:  		/* addi R11, R11, 1 */
		/* 820A16F8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A16F8h case    6:*/		return 0x820A16FC;
		  /* 820A16FCh */ case    7:  		/* addi R10, R10, 1 */
		/* 820A16FCh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A16FCh case    7:*/		return 0x820A1700;
		  /* 820A1700h */ case    8:  		/* cmpwi CR6, R9, 0 */
		/* 820A1700h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A1700h case    8:*/		return 0x820A1704;
		  /* 820A1704h */ case    9:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1704h case    9:*/		if ( regs.CR[6].eq ) { return 0x820A16E4;  }
		/* 820A1704h case    9:*/		return 0x820A1708;
	}
	return 0x820A1708;
} // Block from 820A16E0h-820A1708h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A1708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1708);
		  /* 820A1708h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A1708h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1708h case    0:*/		return 0x820A170C;
		  /* 820A170Ch */ case    1:  		/* bc 12, CR0_EQ, -112 */
		/* 820A170Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820A169C;  }
		/* 820A170Ch case    1:*/		return 0x820A1710;
	}
	return 0x820A1710;
} // Block from 820A1708h-820A1710h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A1710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1710);
		  /* 820A1710h */ case    0:  		/* li R11, 1 */
		/* 820A1710h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A1710h case    0:*/		return 0x820A1714;
		  /* 820A1714h */ case    1:  		/* stw R11, <#[R28 + 1648]> */
		/* 820A1714h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000670) );
		/* 820A1714h case    1:*/		return 0x820A1718;
		  /* 820A1718h */ case    2:  		/* b 536 */
		/* 820A1718h case    2:*/		return 0x820A1930;
		/* 820A1718h case    2:*/		return 0x820A171C;
	}
	return 0x820A171C;
} // Block from 820A1710h-820A171Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A171Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A171C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A171C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A171C);
		  /* 820A171Ch */ case    0:  		/* lis R9, -32255 */
		/* 820A171Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A171Ch case    0:*/		return 0x820A1720;
		  /* 820A1720h */ case    1:  		/* mr R10, R11 */
		/* 820A1720h case    1:*/		regs.R10 = regs.R11;
		/* 820A1720h case    1:*/		return 0x820A1724;
		  /* 820A1724h */ case    2:  		/* addi R9, R9, -10672 */
		/* 820A1724h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFD650);
		/* 820A1724h case    2:*/		return 0x820A1728;
		  /* 820A1728h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A1728h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1728h case    3:*/		return 0x820A172C;
		  /* 820A172Ch */ case    4:  		/* lbz R7, <#[R9]> */
		/* 820A172Ch case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A172Ch case    4:*/		return 0x820A1730;
		  /* 820A1730h */ case    5:  		/* cmpwi CR0, R8, 0 */
		/* 820A1730h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A1730h case    5:*/		return 0x820A1734;
		  /* 820A1734h */ case    6:  		/* subf R8, R7, R8 */
		/* 820A1734h case    6:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A1734h case    6:*/		return 0x820A1738;
		  /* 820A1738h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1738h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A174C;  }
		/* 820A1738h case    7:*/		return 0x820A173C;
		  /* 820A173Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820A173Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A173Ch case    8:*/		return 0x820A1740;
		  /* 820A1740h */ case    9:  		/* addi R9, R9, 1 */
		/* 820A1740h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A1740h case    9:*/		return 0x820A1744;
		  /* 820A1744h */ case   10:  		/* cmpwi CR6, R8, 0 */
		/* 820A1744h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A1744h case   10:*/		return 0x820A1748;
		  /* 820A1748h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1748h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A1728;  }
		/* 820A1748h case   11:*/		return 0x820A174C;
	}
	return 0x820A174C;
} // Block from 820A171Ch-820A174Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A174Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A174C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A174C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A174C);
		  /* 820A174Ch */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A174Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A174Ch case    0:*/		return 0x820A1750;
		  /* 820A1750h */ case    1:  		/* bc 12, CR0_EQ, -444 */
		/* 820A1750h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A1594;  }
		/* 820A1750h case    1:*/		return 0x820A1754;
		  /* 820A1754h */ case    2:  		/* lis R9, -32255 */
		/* 820A1754h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A1754h case    2:*/		return 0x820A1758;
		  /* 820A1758h */ case    3:  		/* mr R10, R11 */
		/* 820A1758h case    3:*/		regs.R10 = regs.R11;
		/* 820A1758h case    3:*/		return 0x820A175C;
		  /* 820A175Ch */ case    4:  		/* addi R9, R9, -10680 */
		/* 820A175Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFD648);
		/* 820A175Ch case    4:*/		return 0x820A1760;
		  /* 820A1760h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820A1760h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1760h case    5:*/		return 0x820A1764;
		  /* 820A1764h */ case    6:  		/* lbz R7, <#[R9]> */
		/* 820A1764h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A1764h case    6:*/		return 0x820A1768;
		  /* 820A1768h */ case    7:  		/* cmpwi CR0, R8, 0 */
		/* 820A1768h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A1768h case    7:*/		return 0x820A176C;
		  /* 820A176Ch */ case    8:  		/* subf R8, R7, R8 */
		/* 820A176Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A176Ch case    8:*/		return 0x820A1770;
		  /* 820A1770h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1770h case    9:*/		if ( regs.CR[0].eq ) { return 0x820A1784;  }
		/* 820A1770h case    9:*/		return 0x820A1774;
		  /* 820A1774h */ case   10:  		/* addi R10, R10, 1 */
		/* 820A1774h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A1774h case   10:*/		return 0x820A1778;
		  /* 820A1778h */ case   11:  		/* addi R9, R9, 1 */
		/* 820A1778h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A1778h case   11:*/		return 0x820A177C;
		  /* 820A177Ch */ case   12:  		/* cmpwi CR6, R8, 0 */
		/* 820A177Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A177Ch case   12:*/		return 0x820A1780;
		  /* 820A1780h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1780h case   13:*/		if ( regs.CR[6].eq ) { return 0x820A1760;  }
		/* 820A1780h case   13:*/		return 0x820A1784;
	}
	return 0x820A1784;
} // Block from 820A174Ch-820A1784h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A1784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1784);
		  /* 820A1784h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A1784h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A1784h case    0:*/		return 0x820A1788;
		  /* 820A1788h */ case    1:  		/* bc 12, CR0_EQ, -436 */
		/* 820A1788h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A15D4;  }
		/* 820A1788h case    1:*/		return 0x820A178C;
		  /* 820A178Ch */ case    2:  		/* lis R10, -32255 */
		/* 820A178Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A178Ch case    2:*/		return 0x820A1790;
		  /* 820A1790h */ case    3:  		/* addi R10, R10, -10664 */
		/* 820A1790h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD658);
		/* 820A1790h case    3:*/		return 0x820A1794;
		  /* 820A1794h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820A1794h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A1794h case    4:*/		return 0x820A1798;
		  /* 820A1798h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820A1798h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1798h case    5:*/		return 0x820A179C;
		  /* 820A179Ch */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820A179Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A179Ch case    6:*/		return 0x820A17A0;
		  /* 820A17A0h */ case    7:  		/* subf R9, R8, R9 */
		/* 820A17A0h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A17A0h case    7:*/		return 0x820A17A4;
		  /* 820A17A4h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820A17A4h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A17B8;  }
		/* 820A17A4h case    8:*/		return 0x820A17A8;
		  /* 820A17A8h */ case    9:  		/* addi R11, R11, 1 */
		/* 820A17A8h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A17A8h case    9:*/		return 0x820A17AC;
		  /* 820A17ACh */ case   10:  		/* addi R10, R10, 1 */
		/* 820A17ACh case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A17ACh case   10:*/		return 0x820A17B0;
	}
	return 0x820A17B0;
} // Block from 820A1784h-820A17B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A17B0h
// Function '?Escape@CPreProcessor@D3DXShader@@IAAIPBDIPADI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A17B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A17B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A17B0);
		  /* 820A17B0h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 820A17B0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A17B0h case    0:*/		return 0x820A17B4;
		  /* 820A17B4h */ case    1:  		/* bc 12, CR6_EQ, -32 */
		/* 820A17B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A1794;  }
		/* 820A17B4h case    1:*/		return 0x820A17B8;
	}
	return 0x820A17B8;
} // Block from 820A17B0h-820A17B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A17B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A17B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A17B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A17B8);
		  /* 820A17B8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A17B8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A17B8h case    0:*/		return 0x820A17BC;
		  /* 820A17BCh */ case    1:  		/* bc 4, CR0_EQ, -172 */
		/* 820A17BCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A1710;  }
		/* 820A17BCh case    1:*/		return 0x820A17C0;
		  /* 820A17C0h */ case    2:  		/* lwz R11, <#[R28 + 2196]> */
		/* 820A17C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000894) );
		/* 820A17C0h case    2:*/		return 0x820A17C4;
		  /* 820A17C4h */ case    3:  		/* lwz R11, <#[R11 + 80]> */
		/* 820A17C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 820A17C4h case    3:*/		return 0x820A17C8;
		  /* 820A17C8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820A17C8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A17C8h case    4:*/		return 0x820A17CC;
		  /* 820A17CCh */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 820A17CCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A17D8;  }
		/* 820A17CCh case    5:*/		return 0x820A17D0;
		  /* 820A17D0h */ case    6:  		/* stw R29, <#[R28 + 1652]> */
		/* 820A17D0h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + 0x00000674) );
		/* 820A17D0h case    6:*/		return 0x820A17D4;
		  /* 820A17D4h */ case    7:  		/* b -644 */
		/* 820A17D4h case    7:*/		return 0x820A1550;
		/* 820A17D4h case    7:*/		return 0x820A17D8;
	}
	return 0x820A17D8;
} // Block from 820A17B8h-820A17D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A17D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A17D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A17D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A17D8);
		  /* 820A17D8h */ case    0:  		/* lwz R10, <#[R11 + 4]> */
		/* 820A17D8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820A17D8h case    0:*/		return 0x820A17DC;
		  /* 820A17DCh */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 820A17DCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820A17DCh case    1:*/		return 0x820A17E0;
		  /* 820A17E0h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820A17E0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A17F8;  }
		/* 820A17E0h case    2:*/		return 0x820A17E4;
		  /* 820A17E4h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 820A17E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A17E4h case    3:*/		return 0x820A17E8;
		  /* 820A17E8h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820A17E8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A17E8h case    4:*/		return 0x820A17EC;
		  /* 820A17ECh */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 820A17ECh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A17F8;  }
		/* 820A17ECh case    5:*/		return 0x820A17F0;
		  /* 820A17F0h */ case    6:  		/* stw R10, <#[R28 + 1652]> */
		/* 820A17F0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000674) );
		/* 820A17F0h case    6:*/		return 0x820A17F4;
		  /* 820A17F4h */ case    7:  		/* b -676 */
		/* 820A17F4h case    7:*/		return 0x820A1550;
		/* 820A17F4h case    7:*/		return 0x820A17F8;
	}
	return 0x820A17F8;
} // Block from 820A17D8h-820A17F8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A17F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A17F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A17F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A17F8);
		  /* 820A17F8h */ case    0:  		/* li R3, 269 */
		/* 820A17F8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x10D);
		/* 820A17F8h case    0:*/		return 0x820A17FC;
		  /* 820A17FCh */ case    1:  		/* b 508 */
		/* 820A17FCh case    1:*/		return 0x820A19F8;
		/* 820A17FCh case    1:*/		return 0x820A1800;
	}
	return 0x820A1800;
} // Block from 820A17F8h-820A1800h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A1800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1800);
		  /* 820A1800h */ case    0:  		/* lis R11, -32255 */
		/* 820A1800h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A1800h case    0:*/		return 0x820A1804;
		  /* 820A1804h */ case    1:  		/* lwz R4, <#[R28 + 2224]> */
		/* 820A1804h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x000008B0) );
		/* 820A1804h case    1:*/		return 0x820A1808;
		  /* 820A1808h */ case    2:  		/* addi R10, R11, -10696 */
		/* 820A1808h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFD638);
		/* 820A1808h case    2:*/		return 0x820A180C;
		  /* 820A180Ch */ case    3:  		/* mr R11, R4 */
		/* 820A180Ch case    3:*/		regs.R11 = regs.R4;
		/* 820A180Ch case    3:*/		return 0x820A1810;
		  /* 820A1810h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820A1810h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A1810h case    4:*/		return 0x820A1814;
		  /* 820A1814h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820A1814h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1814h case    5:*/		return 0x820A1818;
		  /* 820A1818h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820A1818h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1818h case    6:*/		return 0x820A181C;
		  /* 820A181Ch */ case    7:  		/* subf R9, R8, R9 */
		/* 820A181Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A181Ch case    7:*/		return 0x820A1820;
		  /* 820A1820h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1820h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A1834;  }
		/* 820A1820h case    8:*/		return 0x820A1824;
		  /* 820A1824h */ case    9:  		/* addi R11, R11, 1 */
		/* 820A1824h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A1824h case    9:*/		return 0x820A1828;
		  /* 820A1828h */ case   10:  		/* addi R10, R10, 1 */
		/* 820A1828h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A1828h case   10:*/		return 0x820A182C;
		  /* 820A182Ch */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820A182Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A182Ch case   11:*/		return 0x820A1830;
		  /* 820A1830h */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1830h case   12:*/		if ( regs.CR[6].eq ) { return 0x820A1810;  }
		/* 820A1830h case   12:*/		return 0x820A1834;
	}
	return 0x820A1834;
} // Block from 820A1800h-820A1834h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A1834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1834);
		  /* 820A1834h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A1834h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1834h case    0:*/		return 0x820A1838;
		  /* 820A1838h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A1838h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A1848;  }
		/* 820A1838h case    1:*/		return 0x820A183C;
		  /* 820A183Ch */ case    2:  		/* li R3, 271 */
		/* 820A183Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x10F);
		/* 820A183Ch case    2:*/		return 0x820A1840;
		  /* 820A1840h */ case    3:  		/* stw R30, <#[R28 + 1660]> */
		/* 820A1840h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x0000067C) );
		/* 820A1840h case    3:*/		return 0x820A1844;
		  /* 820A1844h */ case    4:  		/* b 436 */
		/* 820A1844h case    4:*/		return 0x820A19F8;
		/* 820A1844h case    4:*/		return 0x820A1848;
	}
	return 0x820A1848;
} // Block from 820A1834h-820A1848h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A1848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1848);
		  /* 820A1848h */ case    0:  		/* lwz R11, <#[R28 + 1660]> */
		/* 820A1848h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000067C) );
		/* 820A1848h case    0:*/		return 0x820A184C;
		  /* 820A184Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A184Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A184Ch case    1:*/		return 0x820A1850;
		  /* 820A1850h */ case    2:  		/* bc 12, CR6_EQ, 224 */
		/* 820A1850h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A1930;  }
		/* 820A1850h case    2:*/		return 0x820A1854;
		  /* 820A1854h */ case    3:  		/* addi R6, R1, 80 */
		/* 820A1854h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820A1854h case    3:*/		return 0x820A1858;
		  /* 820A1858h */ case    4:  		/* addi R5, R1, 84 */
		/* 820A1858h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820A1858h case    4:*/		return 0x820A185C;
		  /* 820A185Ch */ case    5:  		/* mr R3, R28 */
		/* 820A185Ch case    5:*/		regs.R3 = regs.R28;
		/* 820A185Ch case    5:*/		return 0x820A1860;
	}
	return 0x820A1860;
} // Block from 820A1848h-820A1860h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A1860h
// Function '?NonNull@CPreProcessor@D3DXShader@@IAAPAVCNode@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1860);
		  /* 820A1860h */ case    0:  		/* bl -2968 */
		/* 820A1860h case    0:*/		regs.LR = 0x820A1864; return 0x820A0CC8;
		/* 820A1860h case    0:*/		return 0x820A1864;
		  /* 820A1864h */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 820A1864h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A1864h case    1:*/		return 0x820A1868;
		  /* 820A1868h */ case    2:  		/* bc 12, CR0_EQ, 200 */
		/* 820A1868h case    2:*/		if ( regs.CR[0].eq ) { return 0x820A1930;  }
		/* 820A1868h case    2:*/		return 0x820A186C;
		  /* 820A186Ch */ case    3:  		/* li R11, 5 */
		/* 820A186Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820A186Ch case    3:*/		return 0x820A1870;
		  /* 820A1870h */ case    4:  		/* addi R10, R1, 88 */
		/* 820A1870h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x58);
		/* 820A1870h case    4:*/		return 0x820A1874;
		  /* 820A1874h */ case    5:  		/* addi R9, R31, -8 */
		/* 820A1874h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0xFFFFFFF8);
		/* 820A1874h case    5:*/		return 0x820A1878;
		  /* 820A1878h */ case    6:  		/* mtspr CTR, R11 */
		/* 820A1878h case    6:*/		regs.CTR = regs.R11;
		/* 820A1878h case    6:*/		return 0x820A187C;
		  /* 820A187Ch */ case    7:  		/* ldu R11, <#[R9 + 8]> */
		/* 820A187Ch case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820A187Ch case    7:*/		return 0x820A1880;
		  /* 820A1880h */ case    8:  		/* stdu R11, <#[R10 + 8]> */
		/* 820A1880h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820A1880h case    8:*/		return 0x820A1884;
		  /* 820A1884h */ case    9:  		/* bc 16, CR0_LT, -8 */
		/* 820A1884h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A187C;  }
		/* 820A1884h case    9:*/		return 0x820A1888;
		  /* 820A1888h */ case   10:  		/* lwz R11, <#[R28 + 1640]> */
		/* 820A1888h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000668) );
		/* 820A1888h case   10:*/		return 0x820A188C;
		  /* 820A188Ch */ case   11:  		/* li R29, 1 */
		/* 820A188Ch case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820A188Ch case   11:*/		return 0x820A1890;
		  /* 820A1890h */ case   12:  		/* cmpwi CR6, R11, 0 */
		/* 820A1890h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A1890h case   12:*/		return 0x820A1894;
		  /* 820A1894h */ case   13:  		/* bc 4, CR6_EQ, 36 */
		/* 820A1894h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A18B8;  }
		/* 820A1894h case   13:*/		return 0x820A1898;
		  /* 820A1898h */ case   14:  		/* addi R4, R1, 96 */
		/* 820A1898h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820A1898h case   14:*/		return 0x820A189C;
		  /* 820A189Ch */ case   15:  		/* lwz R6, <#[R1 + 80]> */
		/* 820A189Ch case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820A189Ch case   15:*/		return 0x820A18A0;
		  /* 820A18A0h */ case   16:  		/* mr R3, R28 */
		/* 820A18A0h case   16:*/		regs.R3 = regs.R28;
		/* 820A18A0h case   16:*/		return 0x820A18A4;
		  /* 820A18A4h */ case   17:  		/* lwz R5, <#[R1 + 84]> */
		/* 820A18A4h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820A18A4h case   17:*/		return 0x820A18A8;
		  /* 820A18A8h */ case   18:  		/* bl 13880 */
		/* 820A18A8h case   18:*/		regs.LR = 0x820A18AC; return 0x820A4EE0;
		/* 820A18A8h case   18:*/		return 0x820A18AC;
		  /* 820A18ACh */ case   19:  		/* cmpwi CR6, R3, 1 */
		/* 820A18ACh case   19:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 820A18ACh case   19:*/		return 0x820A18B0;
		  /* 820A18B0h */ case   20:  		/* mr R11, R30 */
		/* 820A18B0h case   20:*/		regs.R11 = regs.R30;
		/* 820A18B0h case   20:*/		return 0x820A18B4;
		  /* 820A18B4h */ case   21:  		/* bc 12, CR6_EQ, 8 */
		/* 820A18B4h case   21:*/		if ( regs.CR[6].eq ) { return 0x820A18BC;  }
		/* 820A18B4h case   21:*/		return 0x820A18B8;
	}
	return 0x820A18B8;
} // Block from 820A1860h-820A18B8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820A18B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A18B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A18B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A18B8);
		  /* 820A18B8h */ case    0:  		/* mr R11, R29 */
		/* 820A18B8h case    0:*/		regs.R11 = regs.R29;
		/* 820A18B8h case    0:*/		return 0x820A18BC;
	}
	return 0x820A18BC;
} // Block from 820A18B8h-820A18BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A18BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A18BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A18BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A18BC);
		  /* 820A18BCh */ case    0:  		/* stw R11, <#[R28 + 1640]> */
		/* 820A18BCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000668) );
		/* 820A18BCh case    0:*/		return 0x820A18C0;
		  /* 820A18C0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A18C0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A18C0h case    1:*/		return 0x820A18C4;
		  /* 820A18C4h */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 820A18C4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A18E4;  }
		/* 820A18C4h case    2:*/		return 0x820A18C8;
	}
	return 0x820A18C8;
} // Block from 820A18BCh-820A18C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A18C8h
// Function '?StringLengthWorkerA@@YAJPBDIPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A18C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A18C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A18C8);
		  /* 820A18C8h */ case    0:  		/* addi R4, R1, 84 */
		/* 820A18C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 820A18C8h case    0:*/		return 0x820A18CC;
		  /* 820A18CCh */ case    1:  		/* mr R3, R28 */
		/* 820A18CCh case    1:*/		regs.R3 = regs.R28;
		/* 820A18CCh case    1:*/		return 0x820A18D0;
		  /* 820A18D0h */ case    2:  		/* bl -1688 */
		/* 820A18D0h case    2:*/		regs.LR = 0x820A18D4; return 0x820A1238;
		/* 820A18D0h case    2:*/		return 0x820A18D4;
		  /* 820A18D4h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 820A18D4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820A18D4h case    3:*/		return 0x820A18D8;
		  /* 820A18D8h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 820A18D8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A18E8;  }
		/* 820A18D8h case    4:*/		return 0x820A18DC;
		  /* 820A18DCh */ case    5:  		/* mr R11, R30 */
		/* 820A18DCh case    5:*/		regs.R11 = regs.R30;
		/* 820A18DCh case    5:*/		return 0x820A18E0;
		  /* 820A18E0h */ case    6:  		/* b 12 */
		/* 820A18E0h case    6:*/		return 0x820A18EC;
		/* 820A18E0h case    6:*/		return 0x820A18E4;
	}
	return 0x820A18E4;
} // Block from 820A18C8h-820A18E4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A18E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A18E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A18E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A18E4);
		  /* 820A18E4h */ case    0:  		/* lwz R3, <#[R1 + 84]> */
		/* 820A18E4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820A18E4h case    0:*/		return 0x820A18E8;
	}
	return 0x820A18E8;
} // Block from 820A18E4h-820A18E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A18E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A18E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A18E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A18E8);
		  /* 820A18E8h */ case    0:  		/* mr R11, R29 */
		/* 820A18E8h case    0:*/		regs.R11 = regs.R29;
		/* 820A18E8h case    0:*/		return 0x820A18EC;
	}
	return 0x820A18EC;
} // Block from 820A18E8h-820A18ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A18ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A18EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A18EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A18EC);
		  /* 820A18ECh */ case    0:  		/* stw R11, <#[R28 + 1640]> */
		/* 820A18ECh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000668) );
		/* 820A18ECh case    0:*/		return 0x820A18F0;
		  /* 820A18F0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A18F0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A18F0h case    1:*/		return 0x820A18F4;
		  /* 820A18F4h */ case    2:  		/* bc 12, CR6_EQ, 260 */
		/* 820A18F4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A19F8;  }
		/* 820A18F4h case    2:*/		return 0x820A18F8;
		  /* 820A18F8h */ case    3:  		/* li R11, 5 */
		/* 820A18F8h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820A18F8h case    3:*/		return 0x820A18FC;
		  /* 820A18FCh */ case    4:  		/* stw R29, <#[R28 + 1644]> */
		/* 820A18FCh case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + 0x0000066C) );
		/* 820A18FCh case    4:*/		return 0x820A1900;
		  /* 820A1900h */ case    5:  		/* addi R10, R1, 88 */
		/* 820A1900h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x58);
		/* 820A1900h case    5:*/		return 0x820A1904;
		  /* 820A1904h */ case    6:  		/* addi R9, R31, -8 */
		/* 820A1904h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0xFFFFFFF8);
		/* 820A1904h case    6:*/		return 0x820A1908;
		  /* 820A1908h */ case    7:  		/* mtspr CTR, R11 */
		/* 820A1908h case    7:*/		regs.CTR = regs.R11;
		/* 820A1908h case    7:*/		return 0x820A190C;
		  /* 820A190Ch */ case    8:  		/* ldu R11, <#[R10 + 8]> */
		/* 820A190Ch case    8:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820A190Ch case    8:*/		return 0x820A1910;
		  /* 820A1910h */ case    9:  		/* stdu R11, <#[R9 + 8]> */
		/* 820A1910h case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820A1910h case    9:*/		return 0x820A1914;
		  /* 820A1914h */ case   10:  		/* bc 16, CR0_LT, -8 */
		/* 820A1914h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A190C;  }
		/* 820A1914h case   10:*/		return 0x820A1918;
		  /* 820A1918h */ case   11:  		/* lis R11, -32255 */
		/* 820A1918h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A1918h case   11:*/		return 0x820A191C;
		  /* 820A191Ch */ case   12:  		/* li R5, 1518 */
		/* 820A191Ch case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x5EE);
		/* 820A191Ch case   12:*/		return 0x820A1920;
	}
	return 0x820A1920;
} // Block from 820A18ECh-820A1920h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A1920h
// Function '??_GCPPDefine@D3DXShader@@QAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1920);
		  /* 820A1920h */ case    0:  		/* addi R6, R11, -10748 */
		/* 820A1920h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD604);
		/* 820A1920h case    0:*/		return 0x820A1924;
		  /* 820A1924h */ case    1:  		/* mr R4, R31 */
		/* 820A1924h case    1:*/		regs.R4 = regs.R31;
		/* 820A1924h case    1:*/		return 0x820A1928;
		  /* 820A1928h */ case    2:  		/* addi R3, R28, 24 */
		/* 820A1928h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R28,0x18);
		/* 820A1928h case    2:*/		return 0x820A192C;
		  /* 820A192Ch */ case    3:  		/* bl 22628 */
		/* 820A192Ch case    3:*/		regs.LR = 0x820A1930; return 0x820A7190;
		/* 820A192Ch case    3:*/		return 0x820A1930;
	}
	return 0x820A1930;
} // Block from 820A1920h-820A1930h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A1930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1930);
		  /* 820A1930h */ case    0:  		/* li R3, 278 */
		/* 820A1930h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x116);
		/* 820A1930h case    0:*/		return 0x820A1934;
		  /* 820A1934h */ case    1:  		/* b 196 */
		/* 820A1934h case    1:*/		return 0x820A19F8;
		/* 820A1934h case    1:*/		return 0x820A1938;
	}
	return 0x820A1938;
} // Block from 820A1930h-820A1938h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A1938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1938);
		  /* 820A1938h */ case    0:  		/* li R3, 279 */
		/* 820A1938h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x117);
		/* 820A1938h case    0:*/		return 0x820A193C;
		  /* 820A193Ch */ case    1:  		/* b 188 */
		/* 820A193Ch case    1:*/		return 0x820A19F8;
		/* 820A193Ch case    1:*/		return 0x820A1940;
	}
	return 0x820A1940;
} // Block from 820A1938h-820A1940h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A1940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1940);
		  /* 820A1940h */ case    0:  		/* lbz R11, <#[R28 + 2225]> */
		/* 820A1940h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x000008B1) );
		/* 820A1940h case    0:*/		return 0x820A1944;
		  /* 820A1944h */ case    1:  		/* extsb. R10, R11 */
		/* 820A1944h case    1:*/		cpu::op::extsb<1>(regs,&regs.R10,regs.R11);
		/* 820A1944h case    1:*/		return 0x820A1948;
		  /* 820A1948h */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 820A1948h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A1958;  }
		/* 820A1948h case    2:*/		return 0x820A194C;
		  /* 820A194Ch */ case    3:  		/* lbz R11, <#[R28 + 2224]> */
		/* 820A194Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x000008B0) );
		/* 820A194Ch case    3:*/		return 0x820A1950;
		  /* 820A1950h */ case    4:  		/* extsb R3, R11 */
		/* 820A1950h case    4:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820A1950h case    4:*/		return 0x820A1954;
		  /* 820A1954h */ case    5:  		/* b 164 */
		/* 820A1954h case    5:*/		return 0x820A19F8;
		/* 820A1954h case    5:*/		return 0x820A1958;
	}
	return 0x820A1958;
} // Block from 820A1940h-820A1958h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A1958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1958);
		  /* 820A1958h */ case    0:  		/* lbz R11, <#[R28 + 2226]> */
		/* 820A1958h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x000008B2) );
		/* 820A1958h case    0:*/		return 0x820A195C;
		  /* 820A195Ch */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820A195Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A195Ch case    1:*/		return 0x820A1960;
		  /* 820A1960h */ case    2:  		/* bc 4, CR0_EQ, 132 */
		/* 820A1960h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A19E4;  }
		/* 820A1960h case    2:*/		return 0x820A1964;
		  /* 820A1964h */ case    3:  		/* cmpwi CR6, R10, 61 */
		/* 820A1964h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000003D);
		/* 820A1964h case    3:*/		return 0x820A1968;
		  /* 820A1968h */ case    4:  		/* bc 4, CR6_EQ, 72 */
		/* 820A1968h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A19B0;  }
		/* 820A1968h case    4:*/		return 0x820A196C;
		  /* 820A196Ch */ case    5:  		/* lbz R11, <#[R28 + 2224]> */
		/* 820A196Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x000008B0) );
		/* 820A196Ch case    5:*/		return 0x820A1970;
		  /* 820A1970h */ case    6:  		/* cmplwi CR6, R11, 33 */
		/* 820A1970h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000021);
		/* 820A1970h case    6:*/		return 0x820A1974;
		  /* 820A1974h */ case    7:  		/* bc 12, CR6_EQ, 52 */
		/* 820A1974h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A19A8;  }
		/* 820A1974h case    7:*/		return 0x820A1978;
		  /* 820A1978h */ case    8:  		/* cmplwi CR6, R11, 60 */
		/* 820A1978h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003C);
		/* 820A1978h case    8:*/		return 0x820A197C;
		  /* 820A197Ch */ case    9:  		/* bc 12, CR6_EQ, 36 */
		/* 820A197Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820A19A0;  }
		/* 820A197Ch case    9:*/		return 0x820A1980;
	}
	return 0x820A1980;
} // Block from 820A1958h-820A1980h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A1980h
// Function '??1CPPInclude@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1980);
		  /* 820A1980h */ case    0:  		/* cmplwi CR6, R11, 61 */
		/* 820A1980h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003D);
		/* 820A1980h case    0:*/		return 0x820A1984;
		  /* 820A1984h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820A1984h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A1998;  }
		/* 820A1984h case    1:*/		return 0x820A1988;
		  /* 820A1988h */ case    2:  		/* cmplwi CR6, R11, 62 */
		/* 820A1988h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003E);
		/* 820A1988h case    2:*/		return 0x820A198C;
		  /* 820A198Ch */ case    3:  		/* bc 4, CR6_EQ, 88 */
		/* 820A198Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A19E4;  }
		/* 820A198Ch case    3:*/		return 0x820A1990;
		  /* 820A1990h */ case    4:  		/* li R3, 273 */
		/* 820A1990h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x111);
		/* 820A1990h case    4:*/		return 0x820A1994;
		  /* 820A1994h */ case    5:  		/* b 100 */
		/* 820A1994h case    5:*/		return 0x820A19F8;
		/* 820A1994h case    5:*/		return 0x820A1998;
	}
	return 0x820A1998;
} // Block from 820A1980h-820A1998h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A1998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1998);
		  /* 820A1998h */ case    0:  		/* li R3, 274 */
		/* 820A1998h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x112);
		/* 820A1998h case    0:*/		return 0x820A199C;
		  /* 820A199Ch */ case    1:  		/* b 92 */
		/* 820A199Ch case    1:*/		return 0x820A19F8;
		/* 820A199Ch case    1:*/		return 0x820A19A0;
	}
	return 0x820A19A0;
} // Block from 820A1998h-820A19A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A19A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A19A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A19A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A19A0);
		  /* 820A19A0h */ case    0:  		/* li R3, 272 */
		/* 820A19A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x110);
		/* 820A19A0h case    0:*/		return 0x820A19A4;
		  /* 820A19A4h */ case    1:  		/* b 84 */
		/* 820A19A4h case    1:*/		return 0x820A19F8;
		/* 820A19A4h case    1:*/		return 0x820A19A8;
	}
	return 0x820A19A8;
} // Block from 820A19A0h-820A19A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A19A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A19A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A19A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A19A8);
		  /* 820A19A8h */ case    0:  		/* li R3, 275 */
		/* 820A19A8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x113);
		/* 820A19A8h case    0:*/		return 0x820A19AC;
		  /* 820A19ACh */ case    1:  		/* b 76 */
		/* 820A19ACh case    1:*/		return 0x820A19F8;
		/* 820A19ACh case    1:*/		return 0x820A19B0;
	}
	return 0x820A19B0;
} // Block from 820A19A8h-820A19B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A19B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A19B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A19B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A19B0);
		  /* 820A19B0h */ case    0:  		/* lbz R11, <#[R28 + 2224]> */
		/* 820A19B0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x000008B0) );
		/* 820A19B0h case    0:*/		return 0x820A19B4;
		  /* 820A19B4h */ case    1:  		/* extsb R9, R11 */
		/* 820A19B4h case    1:*/		cpu::op::extsb<0>(regs,&regs.R9,regs.R11);
		/* 820A19B4h case    1:*/		return 0x820A19B8;
		  /* 820A19B8h */ case    2:  		/* cmpw CR6, R9, R10 */
		/* 820A19B8h case    2:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R10);
		/* 820A19B8h case    2:*/		return 0x820A19BC;
		  /* 820A19BCh */ case    3:  		/* bc 4, CR6_EQ, 40 */
		/* 820A19BCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A19E4;  }
		/* 820A19BCh case    3:*/		return 0x820A19C0;
		  /* 820A19C0h */ case    4:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 820A19C0h case    4:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 820A19C0h case    4:*/		return 0x820A19C4;
		  /* 820A19C4h */ case    5:  		/* cmplwi CR6, R11, 38 */
		/* 820A19C4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000026);
		/* 820A19C4h case    5:*/		return 0x820A19C8;
		  /* 820A19C8h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 820A19C8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A19DC;  }
		/* 820A19C8h case    6:*/		return 0x820A19CC;
		  /* 820A19CCh */ case    7:  		/* cmplwi CR6, R11, 124 */
		/* 820A19CCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 820A19CCh case    7:*/		return 0x820A19D0;
		  /* 820A19D0h */ case    8:  		/* bc 4, CR6_EQ, 20 */
		/* 820A19D0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A19E4;  }
		/* 820A19D0h case    8:*/		return 0x820A19D4;
		  /* 820A19D4h */ case    9:  		/* li R3, 277 */
		/* 820A19D4h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x115);
		/* 820A19D4h case    9:*/		return 0x820A19D8;
	}
	return 0x820A19D8;
} // Block from 820A19B0h-820A19D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A19D8h
// Function '??_GCPPBlock@D3DXShader@@QAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A19D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A19D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A19D8);
		  /* 820A19D8h */ case    0:  		/* b 32 */
		/* 820A19D8h case    0:*/		return 0x820A19F8;
		/* 820A19D8h case    0:*/		return 0x820A19DC;
	}
	return 0x820A19DC;
} // Block from 820A19D8h-820A19DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A19DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A19DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A19DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A19DC);
		  /* 820A19DCh */ case    0:  		/* li R3, 276 */
		/* 820A19DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x114);
		/* 820A19DCh case    0:*/		return 0x820A19E0;
		  /* 820A19E0h */ case    1:  		/* b 24 */
		/* 820A19E0h case    1:*/		return 0x820A19F8;
		/* 820A19E0h case    1:*/		return 0x820A19E4;
	}
	return 0x820A19E4;
} // Block from 820A19DCh-820A19E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A19E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A19E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A19E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A19E4);
		  /* 820A19E4h */ case    0:  		/* li R3, 281 */
		/* 820A19E4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x119);
		/* 820A19E4h case    0:*/		return 0x820A19E8;
		  /* 820A19E8h */ case    1:  		/* b 16 */
		/* 820A19E8h case    1:*/		return 0x820A19F8;
		/* 820A19E8h case    1:*/		return 0x820A19EC;
	}
	return 0x820A19EC;
} // Block from 820A19E4h-820A19ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A19ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A19EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A19EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A19EC);
		  /* 820A19ECh */ case    0:  		/* li R11, 16 */
		/* 820A19ECh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 820A19ECh case    0:*/		return 0x820A19F0;
		  /* 820A19F0h */ case    1:  		/* stw R11, <#[R28 + 2216]> */
		/* 820A19F0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x000008A8) );
		/* 820A19F0h case    1:*/		return 0x820A19F4;
	}
	return 0x820A19F4;
} // Block from 820A19ECh-820A19F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A19F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A19F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A19F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A19F4);
		  /* 820A19F4h */ case    0:  		/* li R3, -1 */
		/* 820A19F4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820A19F4h case    0:*/		return 0x820A19F8;
	}
	return 0x820A19F8;
} // Block from 820A19F4h-820A19F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A19F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A19F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A19F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A19F8);
		  /* 820A19F8h */ case    0:  		/* addi R1, R1, 176 */
		/* 820A19F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820A19F8h case    0:*/		return 0x820A19FC;
		  /* 820A19FCh */ case    1:  		/* b -67412 */
		/* 820A19FCh case    1:*/		return 0x820912A8;
		/* 820A19FCh case    1:*/		return 0x820A1A00;
	}
	return 0x820A1A00;
} // Block from 820A19F8h-820A1A00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A1A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1A00);
		  /* 820A1A00h */ case    0:  		/* mfspr R12, LR */
		/* 820A1A00h case    0:*/		regs.R12 = regs.LR;
		/* 820A1A00h case    0:*/		return 0x820A1A04;
		  /* 820A1A04h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A1A04h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A1A04h case    1:*/		return 0x820A1A08;
		  /* 820A1A08h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A1A08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A1A08h case    2:*/		return 0x820A1A0C;
		  /* 820A1A0Ch */ case    3:  		/* mr R8, R3 */
		/* 820A1A0Ch case    3:*/		regs.R8 = regs.R3;
		/* 820A1A0Ch case    3:*/		return 0x820A1A10;
		  /* 820A1A10h */ case    4:  		/* mr R7, R4 */
		/* 820A1A10h case    4:*/		regs.R7 = regs.R4;
		/* 820A1A10h case    4:*/		return 0x820A1A14;
		  /* 820A1A14h */ case    5:  		/* bl -4420 */
		/* 820A1A14h case    5:*/		regs.LR = 0x820A1A18; return 0x820A08D0;
		/* 820A1A14h case    5:*/		return 0x820A1A18;
		  /* 820A1A18h */ case    6:  		/* addi R11, R3, 421 */
		/* 820A1A18h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1A5);
		/* 820A1A18h case    6:*/		return 0x820A1A1C;
		  /* 820A1A1Ch */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820A1A1Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820A1A1Ch case    7:*/		return 0x820A1A20;
		  /* 820A1A20h */ case    8:  		/* add R9, R11, R8 */
		/* 820A1A20h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R8);
		/* 820A1A20h case    8:*/		return 0x820A1A24;
		  /* 820A1A24h */ case    9:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820A1A24h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820A1A24h case    9:*/		return 0x820A1A28;
		  /* 820A1A28h */ case   10:  		/* b 76 */
		/* 820A1A28h case   10:*/		return 0x820A1A74;
		/* 820A1A28h case   10:*/		return 0x820A1A2C;
		  /* 820A1A2Ch */ case   11:  		/* lwz R3, <#[R9]> */
		/* 820A1A2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x00000000) );
		/* 820A1A2Ch case   11:*/		return 0x820A1A30;
		  /* 820A1A30h */ case   12:  		/* mr R11, R7 */
		/* 820A1A30h case   12:*/		regs.R11 = regs.R7;
		/* 820A1A30h case   12:*/		return 0x820A1A34;
		  /* 820A1A34h */ case   13:  		/* lwz R10, <#[R3]> */
		/* 820A1A34h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820A1A34h case   13:*/		return 0x820A1A38;
	}
	return 0x820A1A38;
} // Block from 820A1A00h-820A1A38h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A1A38h
// Function '??_GCPPPragmaDef@D3DXShader@@QAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1A38);
		  /* 820A1A38h */ case    0:  		/* lbz R8, <#[R11]> */
		/* 820A1A38h case    0:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A1A38h case    0:*/		return 0x820A1A3C;
		  /* 820A1A3Ch */ case    1:  		/* lbz R6, <#[R10]> */
		/* 820A1A3Ch case    1:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1A3Ch case    1:*/		return 0x820A1A40;
		  /* 820A1A40h */ case    2:  		/* cmpwi CR0, R8, 0 */
		/* 820A1A40h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A1A40h case    2:*/		return 0x820A1A44;
		  /* 820A1A44h */ case    3:  		/* subf R8, R6, R8 */
		/* 820A1A44h case    3:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R6,regs.R8);
		/* 820A1A44h case    3:*/		return 0x820A1A48;
		  /* 820A1A48h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1A48h case    4:*/		if ( regs.CR[0].eq ) { return 0x820A1A5C;  }
		/* 820A1A48h case    4:*/		return 0x820A1A4C;
		  /* 820A1A4Ch */ case    5:  		/* addi R11, R11, 1 */
		/* 820A1A4Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A1A4Ch case    5:*/		return 0x820A1A50;
		  /* 820A1A50h */ case    6:  		/* addi R10, R10, 1 */
		/* 820A1A50h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A1A50h case    6:*/		return 0x820A1A54;
		  /* 820A1A54h */ case    7:  		/* cmpwi CR6, R8, 0 */
		/* 820A1A54h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A1A54h case    7:*/		return 0x820A1A58;
		  /* 820A1A58h */ case    8:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1A58h case    8:*/		if ( regs.CR[6].eq ) { return 0x820A1A38;  }
		/* 820A1A58h case    8:*/		return 0x820A1A5C;
	}
	return 0x820A1A5C;
} // Block from 820A1A38h-820A1A5Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A1A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1A5C);
		  /* 820A1A5Ch */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A1A5Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A1A5Ch case    0:*/		return 0x820A1A60;
		  /* 820A1A60h */ case    1:  		/* bc 12, CR0_LT, 52 */
		/* 820A1A60h case    1:*/		if ( regs.CR[0].lt ) { return 0x820A1A94;  }
		/* 820A1A60h case    1:*/		return 0x820A1A64;
		  /* 820A1A64h */ case    2:  		/* lwz R11, <#[R3 + 12]> */
		/* 820A1A64h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A1A64h case    2:*/		return 0x820A1A68;
		  /* 820A1A68h */ case    3:  		/* cmpwi CR6, R8, 0 */
		/* 820A1A68h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A1A68h case    3:*/		return 0x820A1A6C;
		  /* 820A1A6Ch */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 820A1A6Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820A1A80;  }
		/* 820A1A6Ch case    4:*/		return 0x820A1A70;
		  /* 820A1A70h */ case    5:  		/* addi R9, R3, 12 */
		/* 820A1A70h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0xC);
		/* 820A1A70h case    5:*/		return 0x820A1A74;
	}
	return 0x820A1A74;
} // Block from 820A1A5Ch-820A1A74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A1A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1A74);
		  /* 820A1A74h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820A1A74h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A1A74h case    0:*/		return 0x820A1A78;
		  /* 820A1A78h */ case    1:  		/* bc 4, CR6_EQ, -76 */
		/* 820A1A78h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A1A2C;  }
		/* 820A1A78h case    1:*/		return 0x820A1A7C;
		  /* 820A1A7Ch */ case    2:  		/* b 24 */
		/* 820A1A7Ch case    2:*/		return 0x820A1A94;
		/* 820A1A7Ch case    2:*/		return 0x820A1A80;
	}
	return 0x820A1A80;
} // Block from 820A1A74h-820A1A80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A1A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1A80);
		  /* 820A1A80h */ case    0:  		/* li R10, 0 */
		/* 820A1A80h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A1A80h case    0:*/		return 0x820A1A84;
		  /* 820A1A84h */ case    1:  		/* stw R11, <#[R9]> */
		/* 820A1A84h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820A1A84h case    1:*/		return 0x820A1A88;
		  /* 820A1A88h */ case    2:  		/* li R4, 1 */
		/* 820A1A88h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A1A88h case    2:*/		return 0x820A1A8C;
		  /* 820A1A8Ch */ case    3:  		/* stw R10, <#[R3 + 12]> */
		/* 820A1A8Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A1A8Ch case    3:*/		return 0x820A1A90;
		  /* 820A1A90h */ case    4:  		/* bl -2952 */
		/* 820A1A90h case    4:*/		regs.LR = 0x820A1A94; return 0x820A0F08;
		/* 820A1A90h case    4:*/		return 0x820A1A94;
	}
	return 0x820A1A94;
} // Block from 820A1A80h-820A1A94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A1A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1A94);
		  /* 820A1A94h */ case    0:  		/* li R3, 0 */
		/* 820A1A94h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A1A94h case    0:*/		return 0x820A1A98;
	}
	return 0x820A1A98;
} // Block from 820A1A94h-820A1A98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A1A98h
// Function '??_GCPPPragmaRule@D3DXShader@@QAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1A98);
		  /* 820A1A98h */ case    0:  		/* addi R1, R1, 96 */
		/* 820A1A98h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A1A98h case    0:*/		return 0x820A1A9C;
		  /* 820A1A9Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A1A9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A1A9Ch case    1:*/		return 0x820A1AA0;
		  /* 820A1AA0h */ case    2:  		/* mtspr LR, R12 */
		/* 820A1AA0h case    2:*/		regs.LR = regs.R12;
		/* 820A1AA0h case    2:*/		return 0x820A1AA4;
		  /* 820A1AA4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820A1AA4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A1AA4h case    3:*/		return 0x820A1AA8;
	}
	return 0x820A1AA8;
} // Block from 820A1A98h-820A1AA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A1AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1AA8);
		  /* 820A1AA8h */ case    0:  		/* mfspr R12, LR */
		/* 820A1AA8h case    0:*/		regs.R12 = regs.LR;
		/* 820A1AA8h case    0:*/		return 0x820A1AAC;
		  /* 820A1AACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A1AACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A1AACh case    1:*/		return 0x820A1AB0;
		  /* 820A1AB0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A1AB0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A1AB0h case    2:*/		return 0x820A1AB4;
		  /* 820A1AB4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A1AB4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A1AB4h case    3:*/		return 0x820A1AB8;
		  /* 820A1AB8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A1AB8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A1AB8h case    4:*/		return 0x820A1ABC;
		  /* 820A1ABCh */ case    5:  		/* mr R31, R3 */
		/* 820A1ABCh case    5:*/		regs.R31 = regs.R3;
		/* 820A1ABCh case    5:*/		return 0x820A1AC0;
		  /* 820A1AC0h */ case    6:  		/* mr R30, R4 */
		/* 820A1AC0h case    6:*/		regs.R30 = regs.R4;
		/* 820A1AC0h case    6:*/		return 0x820A1AC4;
		  /* 820A1AC4h */ case    7:  		/* lis R4, 9345 */
		/* 820A1AC4h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A1AC4h case    7:*/		return 0x820A1AC8;
		  /* 820A1AC8h */ case    8:  		/* li R3, 16 */
		/* 820A1AC8h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x10);
		/* 820A1AC8h case    8:*/		return 0x820A1ACC;
		  /* 820A1ACCh */ case    9:  		/* bl -104652 */
		/* 820A1ACCh case    9:*/		regs.LR = 0x820A1AD0; return 0x82088200;
		/* 820A1ACCh case    9:*/		return 0x820A1AD0;
		  /* 820A1AD0h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 820A1AD0h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A1AD0h case   10:*/		return 0x820A1AD4;
		  /* 820A1AD4h */ case   11:  		/* li R11, 0 */
		/* 820A1AD4h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A1AD4h case   11:*/		return 0x820A1AD8;
		  /* 820A1AD8h */ case   12:  		/* bc 12, CR0_EQ, 32 */
		/* 820A1AD8h case   12:*/		if ( regs.CR[0].eq ) { return 0x820A1AF8;  }
		/* 820A1AD8h case   12:*/		return 0x820A1ADC;
		  /* 820A1ADCh */ case   13:  		/* lwz R10, <#[R31 + 1652]> */
		/* 820A1ADCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000674) );
		/* 820A1ADCh case   13:*/		return 0x820A1AE0;
		  /* 820A1AE0h */ case   14:  		/* li R9, 0 */
		/* 820A1AE0h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820A1AE0h case   14:*/		return 0x820A1AE4;
		  /* 820A1AE4h */ case   15:  		/* stw R11, <#[R3 + 8]> */
		/* 820A1AE4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A1AE4h case   15:*/		return 0x820A1AE8;
		  /* 820A1AE8h */ case   16:  		/* mr R11, R3 */
		/* 820A1AE8h case   16:*/		regs.R11 = regs.R3;
		/* 820A1AE8h case   16:*/		return 0x820A1AEC;
		  /* 820A1AECh */ case   17:  		/* stw R30, <#[R3]> */
		/* 820A1AECh case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 820A1AECh case   17:*/		return 0x820A1AF0;
		  /* 820A1AF0h */ case   18:  		/* stw R9, <#[R3 + 12]> */
		/* 820A1AF0h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A1AF0h case   18:*/		return 0x820A1AF4;
		  /* 820A1AF4h */ case   19:  		/* stw R10, <#[R3 + 4]> */
		/* 820A1AF4h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820A1AF4h case   19:*/		return 0x820A1AF8;
	}
	return 0x820A1AF8;
} // Block from 820A1AA8h-820A1AF8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A1AF8h
// Function '??0CPreProcessor@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1AF8);
		  /* 820A1AF8h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820A1AF8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A1AF8h case    0:*/		return 0x820A1AFC;
		  /* 820A1AFCh */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A1AFCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A1B0C;  }
		/* 820A1AFCh case    1:*/		return 0x820A1B00;
		  /* 820A1B00h */ case    2:  		/* lis R3, -32761 */
		/* 820A1B00h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A1B00h case    2:*/		return 0x820A1B04;
		  /* 820A1B04h */ case    3:  		/* ori R3, R3, 14 */
		/* 820A1B04h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A1B04h case    3:*/		return 0x820A1B08;
		  /* 820A1B08h */ case    4:  		/* b 60 */
		/* 820A1B08h case    4:*/		return 0x820A1B44;
		/* 820A1B08h case    4:*/		return 0x820A1B0C;
	}
	return 0x820A1B0C;
} // Block from 820A1AF8h-820A1B0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A1B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1B0C);
		  /* 820A1B0Ch */ case    0:  		/* lwz R10, <#[R31 + 2196]> */
		/* 820A1B0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000894) );
		/* 820A1B0Ch case    0:*/		return 0x820A1B10;
		  /* 820A1B10h */ case    1:  		/* lwz R10, <#[R10 + 80]> */
		/* 820A1B10h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000050) );
		/* 820A1B10h case    1:*/		return 0x820A1B14;
		  /* 820A1B14h */ case    2:  		/* stw R10, <#[R11 + 12]> */
		/* 820A1B14h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A1B14h case    2:*/		return 0x820A1B18;
		  /* 820A1B18h */ case    3:  		/* lwz R10, <#[R31 + 2196]> */
		/* 820A1B18h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000894) );
		/* 820A1B18h case    3:*/		return 0x820A1B1C;
		  /* 820A1B1Ch */ case    4:  		/* stw R11, <#[R10 + 80]> */
		/* 820A1B1Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000050) );
		/* 820A1B1Ch case    4:*/		return 0x820A1B20;
		  /* 820A1B20h */ case    5:  		/* lwz R11, <#[R31 + 1652]> */
		/* 820A1B20h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000674) );
		/* 820A1B20h case    5:*/		return 0x820A1B24;
		  /* 820A1B24h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 820A1B24h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A1B24h case    6:*/		return 0x820A1B28;
		  /* 820A1B28h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 820A1B28h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A1B38;  }
		/* 820A1B28h case    7:*/		return 0x820A1B2C;
		  /* 820A1B2Ch */ case    8:  		/* cmpwi CR6, R30, 0 */
		/* 820A1B2Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820A1B2Ch case    8:*/		return 0x820A1B30;
		  /* 820A1B30h */ case    9:  		/* li R11, 1 */
		/* 820A1B30h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A1B30h case    9:*/		return 0x820A1B34;
		  /* 820A1B34h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 820A1B34h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820A1B3C;  }
		/* 820A1B34h case   10:*/		return 0x820A1B38;
	}
	return 0x820A1B38;
} // Block from 820A1B0Ch-820A1B38h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A1B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1B38);
		  /* 820A1B38h */ case    0:  		/* li R11, 0 */
		/* 820A1B38h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A1B38h case    0:*/		return 0x820A1B3C;
	}
	return 0x820A1B3C;
} // Block from 820A1B38h-820A1B3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A1B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1B3C);
		  /* 820A1B3Ch */ case    0:  		/* stw R11, <#[R31 + 1656]> */
		/* 820A1B3Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000678) );
		/* 820A1B3Ch case    0:*/		return 0x820A1B40;
		  /* 820A1B40h */ case    1:  		/* li R3, 0 */
		/* 820A1B40h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A1B40h case    1:*/		return 0x820A1B44;
	}
	return 0x820A1B44;
} // Block from 820A1B3Ch-820A1B44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A1B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1B44);
		  /* 820A1B44h */ case    0:  		/* addi R1, R1, 112 */
		/* 820A1B44h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A1B44h case    0:*/		return 0x820A1B48;
		  /* 820A1B48h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A1B48h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A1B48h case    1:*/		return 0x820A1B4C;
		  /* 820A1B4Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820A1B4Ch case    2:*/		regs.LR = regs.R12;
		/* 820A1B4Ch case    2:*/		return 0x820A1B50;
		  /* 820A1B50h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820A1B50h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A1B50h case    3:*/		return 0x820A1B54;
		  /* 820A1B54h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820A1B54h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A1B54h case    4:*/		return 0x820A1B58;
		  /* 820A1B58h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820A1B58h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A1B58h case    5:*/		return 0x820A1B5C;
	}
	return 0x820A1B5C;
} // Block from 820A1B44h-820A1B5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A1B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1B5C);
		  /* 820A1B5Ch */ case    0:  		/* nop */
		/* 820A1B5Ch case    0:*/		cpu::op::nop();
		/* 820A1B5Ch case    0:*/		return 0x820A1B60;
	}
	return 0x820A1B60;
} // Block from 820A1B5Ch-820A1B60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A1B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1B60);
		  /* 820A1B60h */ case    0:  		/* mfspr R12, LR */
		/* 820A1B60h case    0:*/		regs.R12 = regs.LR;
		/* 820A1B60h case    0:*/		return 0x820A1B64;
		  /* 820A1B64h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A1B64h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A1B64h case    1:*/		return 0x820A1B68;
		  /* 820A1B68h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A1B68h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A1B68h case    2:*/		return 0x820A1B6C;
		  /* 820A1B6Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A1B6Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A1B6Ch case    3:*/		return 0x820A1B70;
		  /* 820A1B70h */ case    4:  		/* lwz R11, <#[R3 + 2196]> */
		/* 820A1B70h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000894) );
		/* 820A1B70h case    4:*/		return 0x820A1B74;
		  /* 820A1B74h */ case    5:  		/* mr R31, R3 */
		/* 820A1B74h case    5:*/		regs.R31 = regs.R3;
		/* 820A1B74h case    5:*/		return 0x820A1B78;
		  /* 820A1B78h */ case    6:  		/* lwz R3, <#[R11 + 80]> */
		/* 820A1B78h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000050) );
		/* 820A1B78h case    6:*/		return 0x820A1B7C;
		  /* 820A1B7Ch */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 820A1B7Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A1B7Ch case    7:*/		return 0x820A1B80;
		  /* 820A1B80h */ case    8:  		/* bc 4, CR6_EQ, 48 */
		/* 820A1B80h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A1BB0;  }
		/* 820A1B80h case    8:*/		return 0x820A1B84;
		  /* 820A1B84h */ case    9:  		/* lis R11, -32255 */
		/* 820A1B84h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A1B84h case    9:*/		return 0x820A1B88;
		  /* 820A1B88h */ case   10:  		/* li R5, 1510 */
		/* 820A1B88h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x5E6);
		/* 820A1B88h case   10:*/		return 0x820A1B8C;
		  /* 820A1B8Ch */ case   11:  		/* addi R6, R11, -10604 */
		/* 820A1B8Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD694);
		/* 820A1B8Ch case   11:*/		return 0x820A1B90;
		  /* 820A1B90h */ case   12:  		/* addi R4, R31, 2216 */
		/* 820A1B90h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x8A8);
		/* 820A1B90h case   12:*/		return 0x820A1B94;
		  /* 820A1B94h */ case   13:  		/* addi R3, R31, 24 */
		/* 820A1B94h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A1B94h case   13:*/		return 0x820A1B98;
		  /* 820A1B98h */ case   14:  		/* bl 22008 */
		/* 820A1B98h case   14:*/		regs.LR = 0x820A1B9C; return 0x820A7190;
		/* 820A1B98h case   14:*/		return 0x820A1B9C;
		  /* 820A1B9Ch */ case   15:  		/* li R11, 1 */
		/* 820A1B9Ch case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A1B9Ch case   15:*/		return 0x820A1BA0;
		  /* 820A1BA0h */ case   16:  		/* lis R3, -32768 */
		/* 820A1BA0h case   16:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A1BA0h case   16:*/		return 0x820A1BA4;
		  /* 820A1BA4h */ case   17:  		/* stw R11, <#[R31 + 1640]> */
		/* 820A1BA4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000668) );
		/* 820A1BA4h case   17:*/		return 0x820A1BA8;
		  /* 820A1BA8h */ case   18:  		/* ori R3, R3, 16389 */
		/* 820A1BA8h case   18:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820A1BA8h case   18:*/		return 0x820A1BAC;
		  /* 820A1BACh */ case   19:  		/* b 40 */
		/* 820A1BACh case   19:*/		return 0x820A1BD4;
		/* 820A1BACh case   19:*/		return 0x820A1BB0;
	}
	return 0x820A1BB0;
} // Block from 820A1B60h-820A1BB0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A1BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1BB0);
		  /* 820A1BB0h */ case    0:  		/* lwz R10, <#[R3 + 4]> */
		/* 820A1BB0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820A1BB0h case    0:*/		return 0x820A1BB4;
		  /* 820A1BB4h */ case    1:  		/* li R9, 0 */
		/* 820A1BB4h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820A1BB4h case    1:*/		return 0x820A1BB8;
		  /* 820A1BB8h */ case    2:  		/* li R4, 1 */
		/* 820A1BB8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A1BB8h case    2:*/		return 0x820A1BBC;
		  /* 820A1BBCh */ case    3:  		/* stw R10, <#[R31 + 1656]> */
		/* 820A1BBCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000678) );
		/* 820A1BBCh case    3:*/		return 0x820A1BC0;
		  /* 820A1BC0h */ case    4:  		/* lwz R10, <#[R3 + 12]> */
		/* 820A1BC0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A1BC0h case    4:*/		return 0x820A1BC4;
		  /* 820A1BC4h */ case    5:  		/* stw R10, <#[R11 + 80]> */
		/* 820A1BC4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 820A1BC4h case    5:*/		return 0x820A1BC8;
	}
	return 0x820A1BC8;
} // Block from 820A1BB0h-820A1BC8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A1BC8h
// Function '?Begin@CPreProcessor@D3DXShader@@QAAJI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1BC8);
		  /* 820A1BC8h */ case    0:  		/* stw R9, <#[R3 + 12]> */
		/* 820A1BC8h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A1BC8h case    0:*/		return 0x820A1BCC;
		  /* 820A1BCCh */ case    1:  		/* bl -3268 */
		/* 820A1BCCh case    1:*/		regs.LR = 0x820A1BD0; return 0x820A0F08;
		/* 820A1BCCh case    1:*/		return 0x820A1BD0;
		  /* 820A1BD0h */ case    2:  		/* li R3, 0 */
		/* 820A1BD0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A1BD0h case    2:*/		return 0x820A1BD4;
	}
	return 0x820A1BD4;
} // Block from 820A1BC8h-820A1BD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A1BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1BD4);
		  /* 820A1BD4h */ case    0:  		/* addi R1, R1, 96 */
		/* 820A1BD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A1BD4h case    0:*/		return 0x820A1BD8;
		  /* 820A1BD8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A1BD8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A1BD8h case    1:*/		return 0x820A1BDC;
		  /* 820A1BDCh */ case    2:  		/* mtspr LR, R12 */
		/* 820A1BDCh case    2:*/		regs.LR = regs.R12;
		/* 820A1BDCh case    2:*/		return 0x820A1BE0;
		  /* 820A1BE0h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A1BE0h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A1BE0h case    3:*/		return 0x820A1BE4;
		  /* 820A1BE4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A1BE4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A1BE4h case    4:*/		return 0x820A1BE8;
	}
	return 0x820A1BE8;
} // Block from 820A1BD4h-820A1BE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A1BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1BE8);
		  /* 820A1BE8h */ case    0:  		/* mfspr R12, LR */
		/* 820A1BE8h case    0:*/		regs.R12 = regs.LR;
		/* 820A1BE8h case    0:*/		return 0x820A1BEC;
		  /* 820A1BECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A1BECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A1BECh case    1:*/		return 0x820A1BF0;
		  /* 820A1BF0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A1BF0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A1BF0h case    2:*/		return 0x820A1BF4;
		  /* 820A1BF4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A1BF4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A1BF4h case    3:*/		return 0x820A1BF8;
		  /* 820A1BF8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A1BF8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A1BF8h case    4:*/		return 0x820A1BFC;
		  /* 820A1BFCh */ case    5:  		/* addi R30, R3, 2216 */
		/* 820A1BFCh case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x8A8);
		/* 820A1BFCh case    5:*/		return 0x820A1C00;
		  /* 820A1C00h */ case    6:  		/* lwz R4, <#[R3 + 2256]> */
		/* 820A1C00h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x000008D0) );
		/* 820A1C00h case    6:*/		return 0x820A1C04;
		  /* 820A1C04h */ case    7:  		/* mr R31, R3 */
		/* 820A1C04h case    7:*/		regs.R31 = regs.R3;
		/* 820A1C04h case    7:*/		return 0x820A1C08;
		  /* 820A1C08h */ case    8:  		/* lwz R3, <#[R3 + 2204]> */
		/* 820A1C08h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000089C) );
		/* 820A1C08h case    8:*/		return 0x820A1C0C;
		  /* 820A1C0Ch */ case    9:  		/* mr R5, R30 */
		/* 820A1C0Ch case    9:*/		regs.R5 = regs.R30;
		/* 820A1C0Ch case    9:*/		return 0x820A1C10;
		  /* 820A1C10h */ case   10:  		/* bl 26088 */
		/* 820A1C10h case   10:*/		regs.LR = 0x820A1C14; return 0x820A81F8;
		/* 820A1C10h case   10:*/		return 0x820A1C14;
		  /* 820A1C14h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820A1C14h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A1C14h case   11:*/		return 0x820A1C18;
		  /* 820A1C18h */ case   12:  		/* bc 12, CR0_LT, 240 */
		/* 820A1C18h case   12:*/		if ( regs.CR[0].lt ) { return 0x820A1D08;  }
		/* 820A1C18h case   12:*/		return 0x820A1C1C;
		  /* 820A1C1Ch */ case   13:  		/* lwz R11, <#[R30]> */
		/* 820A1C1Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A1C1Ch case   13:*/		return 0x820A1C20;
		  /* 820A1C20h */ case   14:  		/* cmpwi CR6, R11, 2 */
		/* 820A1C20h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820A1C20h case   14:*/		return 0x820A1C24;
		  /* 820A1C24h */ case   15:  		/* bc 12, CR6_EQ, 100 */
		/* 820A1C24h case   15:*/		if ( regs.CR[6].eq ) { return 0x820A1C88;  }
		/* 820A1C24h case   15:*/		return 0x820A1C28;
		  /* 820A1C28h */ case   16:  		/* cmpwi CR6, R11, 4 */
		/* 820A1C28h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 820A1C28h case   16:*/		return 0x820A1C2C;
		  /* 820A1C2Ch */ case   17:  		/* bc 12, CR6_EQ, 92 */
		/* 820A1C2Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x820A1C88;  }
		/* 820A1C2Ch case   17:*/		return 0x820A1C30;
		  /* 820A1C30h */ case   18:  		/* cmpwi CR6, R11, 12 */
		/* 820A1C30h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000C);
		/* 820A1C30h case   18:*/		return 0x820A1C34;
		  /* 820A1C34h */ case   19:  		/* bc 4, CR6_EQ, 180 */
		/* 820A1C34h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820A1CE8;  }
		/* 820A1C34h case   19:*/		return 0x820A1C38;
		  /* 820A1C38h */ case   20:  		/* lis R4, 9345 */
		/* 820A1C38h case   20:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A1C38h case   20:*/		return 0x820A1C3C;
		  /* 820A1C3Ch */ case   21:  		/* li R3, 12 */
		/* 820A1C3Ch case   21:*/		cpu::op::li<0>(regs,&regs.R3,0xC);
		/* 820A1C3Ch case   21:*/		return 0x820A1C40;
		  /* 820A1C40h */ case   22:  		/* bl -105024 */
		/* 820A1C40h case   22:*/		regs.LR = 0x820A1C44; return 0x82088200;
		/* 820A1C40h case   22:*/		return 0x820A1C44;
		  /* 820A1C44h */ case   23:  		/* cmplwi CR0, R3, 0 */
		/* 820A1C44h case   23:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A1C44h case   23:*/		return 0x820A1C48;
		  /* 820A1C48h */ case   24:  		/* bc 12, CR0_EQ, 36 */
		/* 820A1C48h case   24:*/		if ( regs.CR[0].eq ) { return 0x820A1C6C;  }
		/* 820A1C48h case   24:*/		return 0x820A1C4C;
		  /* 820A1C4Ch */ case   25:  		/* lwz R10, <#[R31 + 72]> */
		/* 820A1C4Ch case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000048) );
		/* 820A1C4Ch case   25:*/		return 0x820A1C50;
	}
	return 0x820A1C50;
} // Block from 820A1BE8h-820A1C50h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820A1C50h
// Function '?Token@CPreProcessor@D3DXShader@@IAAHPAH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1C50);
		  /* 820A1C50h */ case    0:  		/* li R9, -1 */
		/* 820A1C50h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 820A1C50h case    0:*/		return 0x820A1C54;
		  /* 820A1C54h */ case    1:  		/* lwz R8, <#[R31 + 2224]> */
		/* 820A1C54h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x000008B0) );
		/* 820A1C54h case    1:*/		return 0x820A1C58;
		  /* 820A1C58h */ case    2:  		/* mr R11, R3 */
		/* 820A1C58h case    2:*/		regs.R11 = regs.R3;
		/* 820A1C58h case    2:*/		return 0x820A1C5C;
		  /* 820A1C5Ch */ case    3:  		/* stw R9, <#[R3]> */
		/* 820A1C5Ch case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 820A1C5Ch case    3:*/		return 0x820A1C60;
		  /* 820A1C60h */ case    4:  		/* stw R10, <#[R3 + 8]> */
		/* 820A1C60h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820A1C60h case    4:*/		return 0x820A1C64;
		  /* 820A1C64h */ case    5:  		/* stw R8, <#[R3 + 4]> */
		/* 820A1C64h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		/* 820A1C64h case    5:*/		return 0x820A1C68;
		  /* 820A1C68h */ case    6:  		/* b 8 */
		/* 820A1C68h case    6:*/		return 0x820A1C70;
		/* 820A1C68h case    6:*/		return 0x820A1C6C;
	}
	return 0x820A1C6C;
} // Block from 820A1C50h-820A1C6Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A1C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1C6C);
		  /* 820A1C6Ch */ case    0:  		/* li R11, 0 */
		/* 820A1C6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A1C6Ch case    0:*/		return 0x820A1C70;
	}
	return 0x820A1C70;
} // Block from 820A1C6Ch-820A1C70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A1C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1C70);
		  /* 820A1C70h */ case    0:  		/* stw R11, <#[R31 + 72]> */
		/* 820A1C70h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 820A1C70h case    0:*/		return 0x820A1C74;
		  /* 820A1C74h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A1C74h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A1C74h case    1:*/		return 0x820A1C78;
		  /* 820A1C78h */ case    2:  		/* bc 4, CR6_EQ, 68 */
		/* 820A1C78h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A1CBC;  }
		/* 820A1C78h case    2:*/		return 0x820A1C7C;
		  /* 820A1C7Ch */ case    3:  		/* lis R3, -32761 */
		/* 820A1C7Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A1C7Ch case    3:*/		return 0x820A1C80;
		  /* 820A1C80h */ case    4:  		/* ori R3, R3, 14 */
		/* 820A1C80h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A1C80h case    4:*/		return 0x820A1C84;
		  /* 820A1C84h */ case    5:  		/* b 132 */
		/* 820A1C84h case    5:*/		return 0x820A1D08;
		/* 820A1C84h case    5:*/		return 0x820A1C88;
	}
	return 0x820A1C88;
} // Block from 820A1C70h-820A1C88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A1C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1C88);
		  /* 820A1C88h */ case    0:  		/* lis R4, 9345 */
		/* 820A1C88h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A1C88h case    0:*/		return 0x820A1C8C;
		  /* 820A1C8Ch */ case    1:  		/* li R3, 12 */
		/* 820A1C8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xC);
		/* 820A1C8Ch case    1:*/		return 0x820A1C90;
		  /* 820A1C90h */ case    2:  		/* bl -105104 */
		/* 820A1C90h case    2:*/		regs.LR = 0x820A1C94; return 0x82088200;
		/* 820A1C90h case    2:*/		return 0x820A1C94;
		  /* 820A1C94h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820A1C94h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A1C94h case    3:*/		return 0x820A1C98;
		  /* 820A1C98h */ case    4:  		/* bc 12, CR0_EQ, -44 */
		/* 820A1C98h case    4:*/		if ( regs.CR[0].eq ) { return 0x820A1C6C;  }
		/* 820A1C98h case    4:*/		return 0x820A1C9C;
		  /* 820A1C9Ch */ case    5:  		/* lwz R10, <#[R31 + 72]> */
		/* 820A1C9Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000048) );
		/* 820A1C9Ch case    5:*/		return 0x820A1CA0;
		  /* 820A1CA0h */ case    6:  		/* li R9, 0 */
		/* 820A1CA0h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820A1CA0h case    6:*/		return 0x820A1CA4;
		  /* 820A1CA4h */ case    7:  		/* lwz R8, <#[R31 + 2224]> */
		/* 820A1CA4h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x000008B0) );
		/* 820A1CA4h case    7:*/		return 0x820A1CA8;
		  /* 820A1CA8h */ case    8:  		/* mr R11, R3 */
		/* 820A1CA8h case    8:*/		regs.R11 = regs.R3;
		/* 820A1CA8h case    8:*/		return 0x820A1CAC;
		  /* 820A1CACh */ case    9:  		/* stw R9, <#[R3 + 4]> */
		/* 820A1CACh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820A1CACh case    9:*/		return 0x820A1CB0;
		  /* 820A1CB0h */ case   10:  		/* stw R10, <#[R3 + 8]> */
		/* 820A1CB0h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820A1CB0h case   10:*/		return 0x820A1CB4;
		  /* 820A1CB4h */ case   11:  		/* stw R8, <#[R3]> */
		/* 820A1CB4h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820A1CB4h case   11:*/		return 0x820A1CB8;
		  /* 820A1CB8h */ case   12:  		/* b -72 */
		/* 820A1CB8h case   12:*/		return 0x820A1C70;
		/* 820A1CB8h case   12:*/		return 0x820A1CBC;
	}
	return 0x820A1CBC;
} // Block from 820A1C88h-820A1CBCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A1CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1CBC);
		  /* 820A1CBCh */ case    0:  		/* mr R5, R30 */
		/* 820A1CBCh case    0:*/		regs.R5 = regs.R30;
		/* 820A1CBCh case    0:*/		return 0x820A1CC0;
		  /* 820A1CC0h */ case    1:  		/* lwz R4, <#[R31 + 2256]> */
		/* 820A1CC0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000008D0) );
		/* 820A1CC0h case    1:*/		return 0x820A1CC4;
		  /* 820A1CC4h */ case    2:  		/* lwz R3, <#[R31 + 2204]> */
		/* 820A1CC4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A1CC4h case    2:*/		return 0x820A1CC8;
		  /* 820A1CC8h */ case    3:  		/* bl 25904 */
		/* 820A1CC8h case    3:*/		regs.LR = 0x820A1CCC; return 0x820A81F8;
		/* 820A1CC8h case    3:*/		return 0x820A1CCC;
		  /* 820A1CCCh */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820A1CCCh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A1CCCh case    4:*/		return 0x820A1CD0;
		  /* 820A1CD0h */ case    5:  		/* bc 12, CR0_LT, 56 */
		/* 820A1CD0h case    5:*/		if ( regs.CR[0].lt ) { return 0x820A1D08;  }
		/* 820A1CD0h case    5:*/		return 0x820A1CD4;
		  /* 820A1CD4h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 820A1CD4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A1CD4h case    6:*/		return 0x820A1CD8;
		  /* 820A1CD8h */ case    7:  		/* cmpwi CR6, R11, 16 */
		/* 820A1CD8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820A1CD8h case    7:*/		return 0x820A1CDC;
		  /* 820A1CDCh */ case    8:  		/* bc 12, CR6_EQ, 40 */
		/* 820A1CDCh case    8:*/		if ( regs.CR[6].eq ) { return 0x820A1D04;  }
		/* 820A1CDCh case    8:*/		return 0x820A1CE0;
		  /* 820A1CE0h */ case    9:  		/* cmpwi CR6, R11, 17 */
		/* 820A1CE0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820A1CE0h case    9:*/		return 0x820A1CE4;
		  /* 820A1CE4h */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 820A1CE4h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A1D04;  }
		/* 820A1CE4h case   10:*/		return 0x820A1CE8;
	}
	return 0x820A1CE8;
} // Block from 820A1CBCh-820A1CE8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A1CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1CE8);
		  /* 820A1CE8h */ case    0:  		/* cmpwi CR6, R11, 16 */
		/* 820A1CE8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820A1CE8h case    0:*/		return 0x820A1CEC;
		  /* 820A1CECh */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820A1CECh case    1:*/		if ( regs.CR[6].eq ) { return 0x820A1D04;  }
		/* 820A1CECh case    1:*/		return 0x820A1CF0;
		  /* 820A1CF0h */ case    2:  		/* cmpwi CR6, R11, 17 */
		/* 820A1CF0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820A1CF0h case    2:*/		return 0x820A1CF4;
		  /* 820A1CF4h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 820A1CF4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A1D04;  }
		/* 820A1CF4h case    3:*/		return 0x820A1CF8;
		  /* 820A1CF8h */ case    4:  		/* li R4, 0 */
		/* 820A1CF8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A1CF8h case    4:*/		return 0x820A1CFC;
		  /* 820A1CFCh */ case    5:  		/* lwz R3, <#[R31 + 2204]> */
		/* 820A1CFCh case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A1CFCh case    5:*/		return 0x820A1D00;
		  /* 820A1D00h */ case    6:  		/* bl 22624 */
		/* 820A1D00h case    6:*/		regs.LR = 0x820A1D04; return 0x820A7560;
		/* 820A1D00h case    6:*/		return 0x820A1D04;
	}
	return 0x820A1D04;
} // Block from 820A1CE8h-820A1D04h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A1D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1D04);
		  /* 820A1D04h */ case    0:  		/* li R3, 0 */
		/* 820A1D04h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A1D04h case    0:*/		return 0x820A1D08;
	}
	return 0x820A1D08;
} // Block from 820A1D04h-820A1D08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A1D08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1D08);
		  /* 820A1D08h */ case    0:  		/* li R11, 1 */
		/* 820A1D08h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A1D08h case    0:*/		return 0x820A1D0C;
		  /* 820A1D0Ch */ case    1:  		/* stw R11, <#[R31 + 1636]> */
		/* 820A1D0Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000664) );
		/* 820A1D0Ch case    1:*/		return 0x820A1D10;
		  /* 820A1D10h */ case    2:  		/* addi R1, R1, 112 */
		/* 820A1D10h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A1D10h case    2:*/		return 0x820A1D14;
		  /* 820A1D14h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A1D14h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A1D14h case    3:*/		return 0x820A1D18;
		  /* 820A1D18h */ case    4:  		/* mtspr LR, R12 */
		/* 820A1D18h case    4:*/		regs.LR = regs.R12;
		/* 820A1D18h case    4:*/		return 0x820A1D1C;
		  /* 820A1D1Ch */ case    5:  		/* ld R30, <#[R1 - 24]> */
		/* 820A1D1Ch case    5:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A1D1Ch case    5:*/		return 0x820A1D20;
		  /* 820A1D20h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 820A1D20h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A1D20h case    6:*/		return 0x820A1D24;
		  /* 820A1D24h */ case    7:  		/* bclr 20, CR0_LT */
		/* 820A1D24h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A1D24h case    7:*/		return 0x820A1D28;
	}
	return 0x820A1D28;
} // Block from 820A1D08h-820A1D28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A1D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1D28);
		  /* 820A1D28h */ case    0:  		/* mfspr R12, LR */
		/* 820A1D28h case    0:*/		regs.R12 = regs.LR;
		/* 820A1D28h case    0:*/		return 0x820A1D2C;
		  /* 820A1D2Ch */ case    1:  		/* bl -68320 */
		/* 820A1D2Ch case    1:*/		regs.LR = 0x820A1D30; return 0x8209124C;
		/* 820A1D2Ch case    1:*/		return 0x820A1D30;
		  /* 820A1D30h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820A1D30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820A1D30h case    2:*/		return 0x820A1D34;
		  /* 820A1D34h */ case    3:  		/* addi R25, R3, 2216 */
		/* 820A1D34h case    3:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R3,0x8A8);
		/* 820A1D34h case    3:*/		return 0x820A1D38;
		  /* 820A1D38h */ case    4:  		/* lwz R4, <#[R3 + 2256]> */
		/* 820A1D38h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x000008D0) );
		/* 820A1D38h case    4:*/		return 0x820A1D3C;
		  /* 820A1D3Ch */ case    5:  		/* mr R27, R3 */
		/* 820A1D3Ch case    5:*/		regs.R27 = regs.R3;
		/* 820A1D3Ch case    5:*/		return 0x820A1D40;
		  /* 820A1D40h */ case    6:  		/* lwz R3, <#[R3 + 2204]> */
		/* 820A1D40h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000089C) );
		/* 820A1D40h case    6:*/		return 0x820A1D44;
		  /* 820A1D44h */ case    7:  		/* mr R5, R25 */
		/* 820A1D44h case    7:*/		regs.R5 = regs.R25;
		/* 820A1D44h case    7:*/		return 0x820A1D48;
		  /* 820A1D48h */ case    8:  		/* bl 25776 */
		/* 820A1D48h case    8:*/		regs.LR = 0x820A1D4C; return 0x820A81F8;
		/* 820A1D48h case    8:*/		return 0x820A1D4C;
		  /* 820A1D4Ch */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820A1D4Ch case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A1D4Ch case    9:*/		return 0x820A1D50;
		  /* 820A1D50h */ case   10:  		/* bc 12, CR0_LT, 420 */
		/* 820A1D50h case   10:*/		if ( regs.CR[0].lt ) { return 0x820A1EF4;  }
		/* 820A1D50h case   10:*/		return 0x820A1D54;
		  /* 820A1D54h */ case   11:  		/* lwz R9, <#[R25]> */
		/* 820A1D54h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000000) );
		/* 820A1D54h case   11:*/		return 0x820A1D58;
		  /* 820A1D58h */ case   12:  		/* cmpwi CR6, R9, 1 */
		/* 820A1D58h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000001);
		/* 820A1D58h case   12:*/		return 0x820A1D5C;
		  /* 820A1D5Ch */ case   13:  		/* bc 4, CR6_EQ, 376 */
		/* 820A1D5Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A1ED4;  }
		/* 820A1D5Ch case   13:*/		return 0x820A1D60;
		  /* 820A1D60h */ case   14:  		/* lbz R11, <#[R27 + 2224]> */
		/* 820A1D60h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x000008B0) );
		/* 820A1D60h case   14:*/		return 0x820A1D64;
		  /* 820A1D64h */ case   15:  		/* cmplwi CR6, R11, 40 */
		/* 820A1D64h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000028);
		/* 820A1D64h case   15:*/		return 0x820A1D68;
		  /* 820A1D68h */ case   16:  		/* bc 4, CR6_EQ, 364 */
		/* 820A1D68h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820A1ED4;  }
		/* 820A1D68h case   16:*/		return 0x820A1D6C;
		  /* 820A1D6Ch */ case   17:  		/* lbz R11, <#[R27 + 2225]> */
		/* 820A1D6Ch case   17:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x000008B1) );
		/* 820A1D6Ch case   17:*/		return 0x820A1D70;
		  /* 820A1D70h */ case   18:  		/* cmplwi CR0, R11, 0 */
		/* 820A1D70h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A1D70h case   18:*/		return 0x820A1D74;
		  /* 820A1D74h */ case   19:  		/* bc 4, CR0_EQ, 352 */
		/* 820A1D74h case   19:*/		if ( !regs.CR[0].eq ) { return 0x820A1ED4;  }
		/* 820A1D74h case   19:*/		return 0x820A1D78;
		  /* 820A1D78h */ case   20:  		/* li R26, 0 */
		/* 820A1D78h case   20:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820A1D78h case   20:*/		return 0x820A1D7C;
		  /* 820A1D7Ch */ case   21:  		/* li R30, 0 */
		/* 820A1D7Ch case   21:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A1D7Ch case   21:*/		return 0x820A1D80;
		  /* 820A1D80h */ case   22:  		/* b 216 */
		/* 820A1D80h case   22:*/		return 0x820A1E58;
		/* 820A1D80h case   22:*/		return 0x820A1D84;
		  /* 820A1D84h */ case   23:  		/* lwz R9, <#[R25]> */
		/* 820A1D84h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000000) );
		/* 820A1D84h case   23:*/		return 0x820A1D88;
		  /* 820A1D88h */ case   24:  		/* cmpwi CR6, R9, 1 */
		/* 820A1D88h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000001);
		/* 820A1D88h case   24:*/		return 0x820A1D8C;
		  /* 820A1D8Ch */ case   25:  		/* bc 4, CR6_EQ, 16 */
		/* 820A1D8Ch case   25:*/		if ( !regs.CR[6].eq ) { return 0x820A1D9C;  }
		/* 820A1D8Ch case   25:*/		return 0x820A1D90;
		  /* 820A1D90h */ case   26:  		/* lbz R11, <#[R27 + 2224]> */
		/* 820A1D90h case   26:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x000008B0) );
		/* 820A1D90h case   26:*/		return 0x820A1D94;
		  /* 820A1D94h */ case   27:  		/* cmplwi CR6, R11, 41 */
		/* 820A1D94h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000029);
		/* 820A1D94h case   27:*/		return 0x820A1D98;
		  /* 820A1D98h */ case   28:  		/* bc 12, CR6_EQ, 216 */
		/* 820A1D98h case   28:*/		if ( regs.CR[6].eq ) { return 0x820A1E70;  }
		/* 820A1D98h case   28:*/		return 0x820A1D9C;
	}
	return 0x820A1D9C;
} // Block from 820A1D28h-820A1D9Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 820A1D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1D9C);
		  /* 820A1D9Ch */ case    0:  		/* lbz R11, <#[R27 + 2225]> */
		/* 820A1D9Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x000008B1) );
		/* 820A1D9Ch case    0:*/		return 0x820A1DA0;
		  /* 820A1DA0h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820A1DA0h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A1DA0h case    1:*/		return 0x820A1DA4;
		  /* 820A1DA4h */ case    2:  		/* bc 12, CR0_EQ, 204 */
		/* 820A1DA4h case    2:*/		if ( regs.CR[0].eq ) { return 0x820A1E70;  }
		/* 820A1DA4h case    2:*/		return 0x820A1DA8;
		  /* 820A1DA8h */ case    3:  		/* cmpwi CR6, R9, 12 */
		/* 820A1DA8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000C);
		/* 820A1DA8h case    3:*/		return 0x820A1DAC;
		  /* 820A1DACh */ case    4:  		/* bc 4, CR6_EQ, 296 */
		/* 820A1DACh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A1ED4;  }
		/* 820A1DACh case    4:*/		return 0x820A1DB0;
		  /* 820A1DB0h */ case    5:  		/* cmplwi CR6, R26, 0 */
		/* 820A1DB0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820A1DB0h case    5:*/		return 0x820A1DB4;
		  /* 820A1DB4h */ case    6:  		/* bc 4, CR6_EQ, 48 */
		/* 820A1DB4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A1DE4;  }
		/* 820A1DB4h case    6:*/		return 0x820A1DB8;
		  /* 820A1DB8h */ case    7:  		/* lwz R26, <#[R27 + 2224]> */
		/* 820A1DB8h case    7:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R27 + 0x000008B0) );
		/* 820A1DB8h case    7:*/		return 0x820A1DBC;
		  /* 820A1DBCh */ case    8:  		/* mr R11, R26 */
		/* 820A1DBCh case    8:*/		regs.R11 = regs.R26;
		/* 820A1DBCh case    8:*/		return 0x820A1DC0;
		  /* 820A1DC0h */ case    9:  		/* lbz R10, <#[R11]> */
		/* 820A1DC0h case    9:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A1DC0h case    9:*/		return 0x820A1DC4;
		  /* 820A1DC4h */ case   10:  		/* addi R11, R11, 1 */
		/* 820A1DC4h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A1DC4h case   10:*/		return 0x820A1DC8;
		  /* 820A1DC8h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 820A1DC8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A1DC8h case   11:*/		return 0x820A1DCC;
		  /* 820A1DCCh */ case   12:  		/* bc 4, CR6_EQ, -12 */
		/* 820A1DCCh case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A1DC0;  }
		/* 820A1DCCh case   12:*/		return 0x820A1DD0;
		  /* 820A1DD0h */ case   13:  		/* subf R11, R26, R11 */
		/* 820A1DD0h case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R26,regs.R11);
		/* 820A1DD0h case   13:*/		return 0x820A1DD4;
		  /* 820A1DD4h */ case   14:  		/* addi R11, R11, -1 */
		/* 820A1DD4h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A1DD4h case   14:*/		return 0x820A1DD8;
		  /* 820A1DD8h */ case   15:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820A1DD8h case   15:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820A1DD8h case   15:*/		return 0x820A1DDC;
		  /* 820A1DDCh */ case   16:  		/* addi R30, R11, 1 */
		/* 820A1DDCh case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1);
		/* 820A1DDCh case   16:*/		return 0x820A1DE0;
		  /* 820A1DE0h */ case   17:  		/* b 120 */
		/* 820A1DE0h case   17:*/		return 0x820A1E58;
		/* 820A1DE0h case   17:*/		return 0x820A1DE4;
	}
	return 0x820A1DE4;
} // Block from 820A1D9Ch-820A1DE4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820A1DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1DE4);
		  /* 820A1DE4h */ case    0:  		/* lwz R11, <#[R27 + 2224]> */
		/* 820A1DE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x000008B0) );
		/* 820A1DE4h case    0:*/		return 0x820A1DE8;
		  /* 820A1DE8h */ case    1:  		/* mr R10, R11 */
		/* 820A1DE8h case    1:*/		regs.R10 = regs.R11;
		/* 820A1DE8h case    1:*/		return 0x820A1DEC;
		  /* 820A1DECh */ case    2:  		/* lbz R8, <#[R11]> */
		/* 820A1DECh case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A1DECh case    2:*/		return 0x820A1DF0;
		  /* 820A1DF0h */ case    3:  		/* addi R11, R11, 1 */
		/* 820A1DF0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A1DF0h case    3:*/		return 0x820A1DF4;
		  /* 820A1DF4h */ case    4:  		/* cmplwi CR6, R8, 0 */
		/* 820A1DF4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820A1DF4h case    4:*/		return 0x820A1DF8;
		  /* 820A1DF8h */ case    5:  		/* bc 4, CR6_EQ, -12 */
		/* 820A1DF8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A1DEC;  }
		/* 820A1DF8h case    5:*/		return 0x820A1DFC;
		  /* 820A1DFCh */ case    6:  		/* subf R11, R10, R11 */
		/* 820A1DFCh case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A1DFCh case    6:*/		return 0x820A1E00;
		  /* 820A1E00h */ case    7:  		/* addi R11, R11, -1 */
		/* 820A1E00h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A1E00h case    7:*/		return 0x820A1E04;
		  /* 820A1E04h */ case    8:  		/* rlwinm R29, R11, 0, 0, 31 */
		/* 820A1E04h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R29,regs.R11);
		/* 820A1E04h case    8:*/		return 0x820A1E08;
		  /* 820A1E08h */ case    9:  		/* add R28, R29, R30 */
		/* 820A1E08h case    9:*/		cpu::op::add<0>(regs,&regs.R28,regs.R29,regs.R30);
		/* 820A1E08h case    9:*/		return 0x820A1E0C;
		  /* 820A1E0Ch */ case   10:  		/* cmplw CR6, R28, R29 */
		/* 820A1E0Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R29);
		/* 820A1E0Ch case   10:*/		return 0x820A1E10;
		  /* 820A1E10h */ case   11:  		/* bc 12, CR6_LT, 196 */
		/* 820A1E10h case   11:*/		if ( regs.CR[6].lt ) { return 0x820A1ED4;  }
		/* 820A1E10h case   11:*/		return 0x820A1E14;
		  /* 820A1E14h */ case   12:  		/* li R5, 1 */
		/* 820A1E14h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A1E14h case   12:*/		return 0x820A1E18;
		  /* 820A1E18h */ case   13:  		/* mr R4, R28 */
		/* 820A1E18h case   13:*/		regs.R4 = regs.R28;
		/* 820A1E18h case   13:*/		return 0x820A1E1C;
		  /* 820A1E1Ch */ case   14:  		/* mr R3, R27 */
		/* 820A1E1Ch case   14:*/		regs.R3 = regs.R27;
		/* 820A1E1Ch case   14:*/		return 0x820A1E20;
		  /* 820A1E20h */ case   15:  		/* bl 160448 */
		/* 820A1E20h case   15:*/		regs.LR = 0x820A1E24; return 0x820C90E0;
		/* 820A1E20h case   15:*/		return 0x820A1E24;
		  /* 820A1E24h */ case   16:  		/* or. R31, R3, R3 */
		/* 820A1E24h case   16:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A1E24h case   16:*/		return 0x820A1E28;
		  /* 820A1E28h */ case   17:  		/* bc 12, CR0_EQ, 220 */
		/* 820A1E28h case   17:*/		if ( regs.CR[0].eq ) { return 0x820A1F04;  }
		/* 820A1E28h case   17:*/		return 0x820A1E2C;
		  /* 820A1E2Ch */ case   18:  		/* addi R5, R30, -1 */
		/* 820A1E2Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R30,0xFFFFFFFF);
		/* 820A1E2Ch case   18:*/		return 0x820A1E30;
		  /* 820A1E30h */ case   19:  		/* mr R4, R26 */
		/* 820A1E30h case   19:*/		regs.R4 = regs.R26;
		/* 820A1E30h case   19:*/		return 0x820A1E34;
		  /* 820A1E34h */ case   20:  		/* mr R3, R31 */
		/* 820A1E34h case   20:*/		regs.R3 = regs.R31;
		/* 820A1E34h case   20:*/		return 0x820A1E38;
		  /* 820A1E38h */ case   21:  		/* bl -66696 */
		/* 820A1E38h case   21:*/		regs.LR = 0x820A1E3C; return 0x820919B0;
		/* 820A1E38h case   21:*/		return 0x820A1E3C;
		  /* 820A1E3Ch */ case   22:  		/* add R11, R31, R30 */
		/* 820A1E3Ch case   22:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R30);
		/* 820A1E3Ch case   22:*/		return 0x820A1E40;
		  /* 820A1E40h */ case   23:  		/* addi R5, R29, 1 */
		/* 820A1E40h case   23:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x1);
		/* 820A1E40h case   23:*/		return 0x820A1E44;
		  /* 820A1E44h */ case   24:  		/* lwz R4, <#[R27 + 2224]> */
		/* 820A1E44h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x000008B0) );
		/* 820A1E44h case   24:*/		return 0x820A1E48;
		  /* 820A1E48h */ case   25:  		/* addi R3, R11, -1 */
		/* 820A1E48h case   25:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 820A1E48h case   25:*/		return 0x820A1E4C;
		  /* 820A1E4Ch */ case   26:  		/* bl -66716 */
		/* 820A1E4Ch case   26:*/		regs.LR = 0x820A1E50; return 0x820919B0;
		/* 820A1E4Ch case   26:*/		return 0x820A1E50;
		  /* 820A1E50h */ case   27:  		/* mr R26, R31 */
		/* 820A1E50h case   27:*/		regs.R26 = regs.R31;
		/* 820A1E50h case   27:*/		return 0x820A1E54;
		  /* 820A1E54h */ case   28:  		/* mr R30, R28 */
		/* 820A1E54h case   28:*/		regs.R30 = regs.R28;
		/* 820A1E54h case   28:*/		return 0x820A1E58;
	}
	return 0x820A1E58;
} // Block from 820A1DE4h-820A1E58h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820A1E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1E58);
		  /* 820A1E58h */ case    0:  		/* mr R4, R25 */
		/* 820A1E58h case    0:*/		regs.R4 = regs.R25;
		/* 820A1E58h case    0:*/		return 0x820A1E5C;
		  /* 820A1E5Ch */ case    1:  		/* mr R3, R27 */
		/* 820A1E5Ch case    1:*/		regs.R3 = regs.R27;
		/* 820A1E5Ch case    1:*/		return 0x820A1E60;
		  /* 820A1E60h */ case    2:  		/* bl 10824 */
		/* 820A1E60h case    2:*/		regs.LR = 0x820A1E64; return 0x820A48A8;
		/* 820A1E60h case    2:*/		return 0x820A1E64;
		  /* 820A1E64h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820A1E64h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A1E64h case    3:*/		return 0x820A1E68;
		  /* 820A1E68h */ case    4:  		/* bc 4, CR0_LT, -228 */
		/* 820A1E68h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820A1D84;  }
		/* 820A1E68h case    4:*/		return 0x820A1E6C;
		  /* 820A1E6Ch */ case    5:  		/* b 136 */
		/* 820A1E6Ch case    5:*/		return 0x820A1EF4;
		/* 820A1E6Ch case    5:*/		return 0x820A1E70;
	}
	return 0x820A1E70;
} // Block from 820A1E58h-820A1E70h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A1E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1E70);
		  /* 820A1E70h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 820A1E70h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820A1E70h case    0:*/		return 0x820A1E74;
		  /* 820A1E74h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 820A1E74h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A1EA8;  }
		/* 820A1E74h case    1:*/		return 0x820A1E78;
		  /* 820A1E78h */ case    2:  		/* addi R31, R27, 24 */
		/* 820A1E78h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R27,0x18);
		/* 820A1E78h case    2:*/		return 0x820A1E7C;
		  /* 820A1E7Ch */ case    3:  		/* mr R4, R26 */
		/* 820A1E7Ch case    3:*/		regs.R4 = regs.R26;
		/* 820A1E7Ch case    3:*/		return 0x820A1E80;
		  /* 820A1E80h */ case    4:  		/* mr R3, R31 */
		/* 820A1E80h case    4:*/		regs.R3 = regs.R31;
		/* 820A1E80h case    4:*/		return 0x820A1E84;
		  /* 820A1E84h */ case    5:  		/* bl 19444 */
		/* 820A1E84h case    5:*/		regs.LR = 0x820A1E88; return 0x820A6A78;
		/* 820A1E84h case    5:*/		return 0x820A1E88;
		  /* 820A1E88h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820A1E88h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A1E88h case    6:*/		return 0x820A1E8C;
		  /* 820A1E8Ch */ case    7:  		/* bc 12, CR0_LT, 104 */
		/* 820A1E8Ch case    7:*/		if ( regs.CR[0].lt ) { return 0x820A1EF4;  }
		/* 820A1E8Ch case    7:*/		return 0x820A1E90;
		  /* 820A1E90h */ case    8:  		/* lis R11, -32256 */
		/* 820A1E90h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820A1E90h case    8:*/		return 0x820A1E94;
		  /* 820A1E94h */ case    9:  		/* mr R3, R31 */
		/* 820A1E94h case    9:*/		regs.R3 = regs.R31;
		/* 820A1E94h case    9:*/		return 0x820A1E98;
		  /* 820A1E98h */ case   10:  		/* addi R4, R11, 17768 */
		/* 820A1E98h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4568);
		/* 820A1E98h case   10:*/		return 0x820A1E9C;
		  /* 820A1E9Ch */ case   11:  		/* bl 19420 */
		/* 820A1E9Ch case   11:*/		regs.LR = 0x820A1EA0; return 0x820A6A78;
		/* 820A1E9Ch case   11:*/		return 0x820A1EA0;
		  /* 820A1EA0h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820A1EA0h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A1EA0h case   12:*/		return 0x820A1EA4;
		  /* 820A1EA4h */ case   13:  		/* bc 12, CR0_LT, 80 */
		/* 820A1EA4h case   13:*/		if ( regs.CR[0].lt ) { return 0x820A1EF4;  }
		/* 820A1EA4h case   13:*/		return 0x820A1EA8;
	}
	return 0x820A1EA8;
} // Block from 820A1E70h-820A1EA8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A1EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1EA8);
		  /* 820A1EA8h */ case    0:  		/* mr R5, R25 */
		/* 820A1EA8h case    0:*/		regs.R5 = regs.R25;
		/* 820A1EA8h case    0:*/		return 0x820A1EAC;
		  /* 820A1EACh */ case    1:  		/* lwz R4, <#[R27 + 2256]> */
		/* 820A1EACh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x000008D0) );
		/* 820A1EACh case    1:*/		return 0x820A1EB0;
		  /* 820A1EB0h */ case    2:  		/* lwz R3, <#[R27 + 2204]> */
		/* 820A1EB0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x0000089C) );
		/* 820A1EB0h case    2:*/		return 0x820A1EB4;
		  /* 820A1EB4h */ case    3:  		/* bl 25412 */
		/* 820A1EB4h case    3:*/		regs.LR = 0x820A1EB8; return 0x820A81F8;
		/* 820A1EB4h case    3:*/		return 0x820A1EB8;
		  /* 820A1EB8h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820A1EB8h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A1EB8h case    4:*/		return 0x820A1EBC;
		  /* 820A1EBCh */ case    5:  		/* bc 12, CR0_LT, 56 */
		/* 820A1EBCh case    5:*/		if ( regs.CR[0].lt ) { return 0x820A1EF4;  }
		/* 820A1EBCh case    5:*/		return 0x820A1EC0;
		  /* 820A1EC0h */ case    6:  		/* lwz R9, <#[R25]> */
		/* 820A1EC0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000000) );
		/* 820A1EC0h case    6:*/		return 0x820A1EC4;
		  /* 820A1EC4h */ case    7:  		/* cmpwi CR6, R9, 16 */
		/* 820A1EC4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000010);
		/* 820A1EC4h case    7:*/		return 0x820A1EC8;
		  /* 820A1EC8h */ case    8:  		/* bc 12, CR6_EQ, 40 */
		/* 820A1EC8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820A1EF0;  }
		/* 820A1EC8h case    8:*/		return 0x820A1ECC;
		  /* 820A1ECCh */ case    9:  		/* cmpwi CR6, R9, 17 */
		/* 820A1ECCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000011);
		/* 820A1ECCh case    9:*/		return 0x820A1ED0;
		  /* 820A1ED0h */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 820A1ED0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A1EF0;  }
		/* 820A1ED0h case   10:*/		return 0x820A1ED4;
	}
	return 0x820A1ED4;
} // Block from 820A1EA8h-820A1ED4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A1ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1ED4);
		  /* 820A1ED4h */ case    0:  		/* cmpwi CR6, R9, 16 */
		/* 820A1ED4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000010);
		/* 820A1ED4h case    0:*/		return 0x820A1ED8;
		  /* 820A1ED8h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820A1ED8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A1EF0;  }
		/* 820A1ED8h case    1:*/		return 0x820A1EDC;
		  /* 820A1EDCh */ case    2:  		/* cmpwi CR6, R9, 17 */
		/* 820A1EDCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000011);
		/* 820A1EDCh case    2:*/		return 0x820A1EE0;
		  /* 820A1EE0h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 820A1EE0h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A1EF0;  }
		/* 820A1EE0h case    3:*/		return 0x820A1EE4;
		  /* 820A1EE4h */ case    4:  		/* li R4, 0 */
		/* 820A1EE4h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A1EE4h case    4:*/		return 0x820A1EE8;
		  /* 820A1EE8h */ case    5:  		/* lwz R3, <#[R27 + 2204]> */
		/* 820A1EE8h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x0000089C) );
		/* 820A1EE8h case    5:*/		return 0x820A1EEC;
		  /* 820A1EECh */ case    6:  		/* bl 22132 */
		/* 820A1EECh case    6:*/		regs.LR = 0x820A1EF0; return 0x820A7560;
		/* 820A1EECh case    6:*/		return 0x820A1EF0;
	}
	return 0x820A1EF0;
} // Block from 820A1ED4h-820A1EF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A1EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1EF0);
		  /* 820A1EF0h */ case    0:  		/* li R3, 0 */
		/* 820A1EF0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A1EF0h case    0:*/		return 0x820A1EF4;
	}
	return 0x820A1EF4;
} // Block from 820A1EF0h-820A1EF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A1EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1EF4);
		  /* 820A1EF4h */ case    0:  		/* li R11, 1 */
		/* 820A1EF4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A1EF4h case    0:*/		return 0x820A1EF8;
		  /* 820A1EF8h */ case    1:  		/* stw R11, <#[R27 + 1636]> */
		/* 820A1EF8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000664) );
		/* 820A1EF8h case    1:*/		return 0x820A1EFC;
		  /* 820A1EFCh */ case    2:  		/* addi R1, R1, 144 */
		/* 820A1EFCh case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820A1EFCh case    2:*/		return 0x820A1F00;
		  /* 820A1F00h */ case    3:  		/* b -68708 */
		/* 820A1F00h case    3:*/		return 0x8209129C;
		/* 820A1F00h case    3:*/		return 0x820A1F04;
	}
	return 0x820A1F04;
} // Block from 820A1EF4h-820A1F04h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A1F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1F04);
		  /* 820A1F04h */ case    0:  		/* lis R3, -32761 */
		/* 820A1F04h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A1F04h case    0:*/		return 0x820A1F08;
		  /* 820A1F08h */ case    1:  		/* ori R3, R3, 14 */
		/* 820A1F08h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A1F08h case    1:*/		return 0x820A1F0C;
		  /* 820A1F0Ch */ case    2:  		/* b -24 */
		/* 820A1F0Ch case    2:*/		return 0x820A1EF4;
		/* 820A1F0Ch case    2:*/		return 0x820A1F10;
	}
	return 0x820A1F10;
} // Block from 820A1F04h-820A1F10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A1F10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1F10);
		  /* 820A1F10h */ case    0:  		/* mfspr R12, LR */
		/* 820A1F10h case    0:*/		regs.R12 = regs.LR;
		/* 820A1F10h case    0:*/		return 0x820A1F14;
		  /* 820A1F14h */ case    1:  		/* bl -68820 */
		/* 820A1F14h case    1:*/		regs.LR = 0x820A1F18; return 0x82091240;
		/* 820A1F14h case    1:*/		return 0x820A1F18;
		  /* 820A1F18h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 820A1F18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 820A1F18h case    2:*/		return 0x820A1F1C;
		  /* 820A1F1Ch */ case    3:  		/* addi R31, R3, 2216 */
		/* 820A1F1Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x8A8);
		/* 820A1F1Ch case    3:*/		return 0x820A1F20;
		  /* 820A1F20h */ case    4:  		/* lwz R4, <#[R3 + 2256]> */
		/* 820A1F20h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x000008D0) );
		/* 820A1F20h case    4:*/		return 0x820A1F24;
		  /* 820A1F24h */ case    5:  		/* mr R29, R3 */
		/* 820A1F24h case    5:*/		regs.R29 = regs.R3;
		/* 820A1F24h case    5:*/		return 0x820A1F28;
		  /* 820A1F28h */ case    6:  		/* lwz R3, <#[R3 + 2204]> */
		/* 820A1F28h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000089C) );
		/* 820A1F28h case    6:*/		return 0x820A1F2C;
		  /* 820A1F2Ch */ case    7:  		/* mr R5, R31 */
		/* 820A1F2Ch case    7:*/		regs.R5 = regs.R31;
		/* 820A1F2Ch case    7:*/		return 0x820A1F30;
		  /* 820A1F30h */ case    8:  		/* bl 25288 */
		/* 820A1F30h case    8:*/		regs.LR = 0x820A1F34; return 0x820A81F8;
		/* 820A1F30h case    8:*/		return 0x820A1F34;
		  /* 820A1F34h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820A1F34h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A1F34h case    9:*/		return 0x820A1F38;
		  /* 820A1F38h */ case   10:  		/* bc 12, CR0_LT, 940 */
		/* 820A1F38h case   10:*/		if ( regs.CR[0].lt ) { return 0x820A22E4;  }
		/* 820A1F38h case   10:*/		return 0x820A1F3C;
		  /* 820A1F3Ch */ case   11:  		/* lwz R8, <#[R31]> */
		/* 820A1F3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 820A1F3Ch case   11:*/		return 0x820A1F40;
		  /* 820A1F40h */ case   12:  		/* cmpwi CR6, R8, 1 */
		/* 820A1F40h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820A1F40h case   12:*/		return 0x820A1F44;
		  /* 820A1F44h */ case   13:  		/* bc 4, CR6_EQ, 896 */
		/* 820A1F44h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A22C4;  }
		/* 820A1F44h case   13:*/		return 0x820A1F48;
		  /* 820A1F48h */ case   14:  		/* addi R27, R29, 2224 */
		/* 820A1F48h case   14:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R29,0x8B0);
		/* 820A1F48h case   14:*/		return 0x820A1F4C;
		  /* 820A1F4Ch */ case   15:  		/* lis R10, -32255 */
		/* 820A1F4Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A1F4Ch case   15:*/		return 0x820A1F50;
		  /* 820A1F50h */ case   16:  		/* mr R11, R27 */
		/* 820A1F50h case   16:*/		regs.R11 = regs.R27;
		/* 820A1F50h case   16:*/		return 0x820A1F54;
		  /* 820A1F54h */ case   17:  		/* addi R10, R10, -10828 */
		/* 820A1F54h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD5B4);
		/* 820A1F54h case   17:*/		return 0x820A1F58;
		  /* 820A1F58h */ case   18:  		/* lbz R9, <#[R11]> */
		/* 820A1F58h case   18:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A1F58h case   18:*/		return 0x820A1F5C;
		  /* 820A1F5Ch */ case   19:  		/* lbz R7, <#[R10]> */
		/* 820A1F5Ch case   19:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1F5Ch case   19:*/		return 0x820A1F60;
		  /* 820A1F60h */ case   20:  		/* cmpwi CR0, R9, 0 */
		/* 820A1F60h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1F60h case   20:*/		return 0x820A1F64;
		  /* 820A1F64h */ case   21:  		/* subf R9, R7, R9 */
		/* 820A1F64h case   21:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A1F64h case   21:*/		return 0x820A1F68;
		  /* 820A1F68h */ case   22:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1F68h case   22:*/		if ( regs.CR[0].eq ) { return 0x820A1F7C;  }
		/* 820A1F68h case   22:*/		return 0x820A1F6C;
		  /* 820A1F6Ch */ case   23:  		/* addi R11, R11, 1 */
		/* 820A1F6Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A1F6Ch case   23:*/		return 0x820A1F70;
		  /* 820A1F70h */ case   24:  		/* addi R10, R10, 1 */
		/* 820A1F70h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A1F70h case   24:*/		return 0x820A1F74;
		  /* 820A1F74h */ case   25:  		/* cmpwi CR6, R9, 0 */
		/* 820A1F74h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A1F74h case   25:*/		return 0x820A1F78;
		  /* 820A1F78h */ case   26:  		/* bc 12, CR6_EQ, -32 */
		/* 820A1F78h case   26:*/		if ( regs.CR[6].eq ) { return 0x820A1F58;  }
		/* 820A1F78h case   26:*/		return 0x820A1F7C;
	}
	return 0x820A1F7C;
} // Block from 820A1F10h-820A1F7Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 820A1F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A1F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A1F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A1F7C);
		  /* 820A1F7Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A1F7Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1F7Ch case    0:*/		return 0x820A1F80;
		  /* 820A1F80h */ case    1:  		/* bc 4, CR0_EQ, 836 */
		/* 820A1F80h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A22C4;  }
		/* 820A1F80h case    1:*/		return 0x820A1F84;
		  /* 820A1F84h */ case    2:  		/* mr R5, R31 */
		/* 820A1F84h case    2:*/		regs.R5 = regs.R31;
		/* 820A1F84h case    2:*/		return 0x820A1F88;
		  /* 820A1F88h */ case    3:  		/* lwz R4, <#[R29 + 2256]> */
		/* 820A1F88h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000008D0) );
		/* 820A1F88h case    3:*/		return 0x820A1F8C;
		  /* 820A1F8Ch */ case    4:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A1F8Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A1F8Ch case    4:*/		return 0x820A1F90;
		  /* 820A1F90h */ case    5:  		/* bl 25192 */
		/* 820A1F90h case    5:*/		regs.LR = 0x820A1F94; return 0x820A81F8;
		/* 820A1F90h case    5:*/		return 0x820A1F94;
		  /* 820A1F94h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820A1F94h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A1F94h case    6:*/		return 0x820A1F98;
		  /* 820A1F98h */ case    7:  		/* bc 12, CR0_LT, 844 */
		/* 820A1F98h case    7:*/		if ( regs.CR[0].lt ) { return 0x820A22E4;  }
		/* 820A1F98h case    7:*/		return 0x820A1F9C;
		  /* 820A1F9Ch */ case    8:  		/* lwz R8, <#[R31]> */
		/* 820A1F9Ch case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 820A1F9Ch case    8:*/		return 0x820A1FA0;
		  /* 820A1FA0h */ case    9:  		/* cmpwi CR6, R8, 11 */
		/* 820A1FA0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000000B);
		/* 820A1FA0h case    9:*/		return 0x820A1FA4;
		  /* 820A1FA4h */ case   10:  		/* bc 4, CR6_EQ, 800 */
		/* 820A1FA4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820A22C4;  }
		/* 820A1FA4h case   10:*/		return 0x820A1FA8;
		  /* 820A1FA8h */ case   11:  		/* mr R5, R31 */
		/* 820A1FA8h case   11:*/		regs.R5 = regs.R31;
		/* 820A1FA8h case   11:*/		return 0x820A1FAC;
		  /* 820A1FACh */ case   12:  		/* lwz R22, <#[R27]> */
		/* 820A1FACh case   12:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R27 + 0x00000000) );
		/* 820A1FACh case   12:*/		return 0x820A1FB0;
		  /* 820A1FB0h */ case   13:  		/* lwz R4, <#[R29 + 2256]> */
		/* 820A1FB0h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000008D0) );
		/* 820A1FB0h case   13:*/		return 0x820A1FB4;
		  /* 820A1FB4h */ case   14:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A1FB4h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A1FB4h case   14:*/		return 0x820A1FB8;
		  /* 820A1FB8h */ case   15:  		/* bl 25152 */
		/* 820A1FB8h case   15:*/		regs.LR = 0x820A1FBC; return 0x820A81F8;
		/* 820A1FB8h case   15:*/		return 0x820A1FBC;
		  /* 820A1FBCh */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820A1FBCh case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A1FBCh case   16:*/		return 0x820A1FC0;
		  /* 820A1FC0h */ case   17:  		/* bc 12, CR0_LT, 804 */
		/* 820A1FC0h case   17:*/		if ( regs.CR[0].lt ) { return 0x820A22E4;  }
		/* 820A1FC0h case   17:*/		return 0x820A1FC4;
		  /* 820A1FC4h */ case   18:  		/* lwz R8, <#[R31]> */
		/* 820A1FC4h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 820A1FC4h case   18:*/		return 0x820A1FC8;
		  /* 820A1FC8h */ case   19:  		/* cmpwi CR6, R8, 1 */
		/* 820A1FC8h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820A1FC8h case   19:*/		return 0x820A1FCC;
		  /* 820A1FCCh */ case   20:  		/* bc 4, CR6_EQ, 760 */
		/* 820A1FCCh case   20:*/		if ( !regs.CR[6].eq ) { return 0x820A22C4;  }
		/* 820A1FCCh case   20:*/		return 0x820A1FD0;
		  /* 820A1FD0h */ case   21:  		/* lis R10, -32255 */
		/* 820A1FD0h case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A1FD0h case   21:*/		return 0x820A1FD4;
		  /* 820A1FD4h */ case   22:  		/* mr R11, R27 */
		/* 820A1FD4h case   22:*/		regs.R11 = regs.R27;
		/* 820A1FD4h case   22:*/		return 0x820A1FD8;
		  /* 820A1FD8h */ case   23:  		/* addi R24, R10, -16572 */
		/* 820A1FD8h case   23:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R10,0xFFFFBF44);
		/* 820A1FD8h case   23:*/		return 0x820A1FDC;
		  /* 820A1FDCh */ case   24:  		/* mr R10, R24 */
		/* 820A1FDCh case   24:*/		regs.R10 = regs.R24;
		/* 820A1FDCh case   24:*/		return 0x820A1FE0;
		  /* 820A1FE0h */ case   25:  		/* lbz R9, <#[R11]> */
		/* 820A1FE0h case   25:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A1FE0h case   25:*/		return 0x820A1FE4;
		  /* 820A1FE4h */ case   26:  		/* lbz R7, <#[R10]> */
		/* 820A1FE4h case   26:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A1FE4h case   26:*/		return 0x820A1FE8;
		  /* 820A1FE8h */ case   27:  		/* cmpwi CR0, R9, 0 */
		/* 820A1FE8h case   27:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A1FE8h case   27:*/		return 0x820A1FEC;
		  /* 820A1FECh */ case   28:  		/* subf R9, R7, R9 */
		/* 820A1FECh case   28:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A1FECh case   28:*/		return 0x820A1FF0;
		  /* 820A1FF0h */ case   29:  		/* bc 12, CR0_EQ, 20 */
		/* 820A1FF0h case   29:*/		if ( regs.CR[0].eq ) { return 0x820A2004;  }
		/* 820A1FF0h case   29:*/		return 0x820A1FF4;
		  /* 820A1FF4h */ case   30:  		/* addi R11, R11, 1 */
		/* 820A1FF4h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A1FF4h case   30:*/		return 0x820A1FF8;
		  /* 820A1FF8h */ case   31:  		/* addi R10, R10, 1 */
		/* 820A1FF8h case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A1FF8h case   31:*/		return 0x820A1FFC;
		  /* 820A1FFCh */ case   32:  		/* cmpwi CR6, R9, 0 */
		/* 820A1FFCh case   32:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A1FFCh case   32:*/		return 0x820A2000;
		  /* 820A2000h */ case   33:  		/* bc 12, CR6_EQ, -32 */
		/* 820A2000h case   33:*/		if ( regs.CR[6].eq ) { return 0x820A1FE0;  }
		/* 820A2000h case   33:*/		return 0x820A2004;
	}
	return 0x820A2004;
} // Block from 820A1F7Ch-820A2004h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820A2004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2004);
		  /* 820A2004h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A2004h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A2004h case    0:*/		return 0x820A2008;
		  /* 820A2008h */ case    1:  		/* bc 4, CR0_EQ, 700 */
		/* 820A2008h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A22C4;  }
		/* 820A2008h case    1:*/		return 0x820A200C;
		  /* 820A200Ch */ case    2:  		/* mr R5, R31 */
		/* 820A200Ch case    2:*/		regs.R5 = regs.R31;
		/* 820A200Ch case    2:*/		return 0x820A2010;
		  /* 820A2010h */ case    3:  		/* lwz R4, <#[R29 + 2256]> */
		/* 820A2010h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000008D0) );
		/* 820A2010h case    3:*/		return 0x820A2014;
		  /* 820A2014h */ case    4:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A2014h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A2014h case    4:*/		return 0x820A2018;
		  /* 820A2018h */ case    5:  		/* bl 25056 */
		/* 820A2018h case    5:*/		regs.LR = 0x820A201C; return 0x820A81F8;
		/* 820A2018h case    5:*/		return 0x820A201C;
		  /* 820A201Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820A201Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A201Ch case    6:*/		return 0x820A2020;
		  /* 820A2020h */ case    7:  		/* bc 12, CR0_LT, 708 */
		/* 820A2020h case    7:*/		if ( regs.CR[0].lt ) { return 0x820A22E4;  }
		/* 820A2020h case    7:*/		return 0x820A2024;
		  /* 820A2024h */ case    8:  		/* lwz R8, <#[R31]> */
		/* 820A2024h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 820A2024h case    8:*/		return 0x820A2028;
		  /* 820A2028h */ case    9:  		/* cmpwi CR6, R8, 11 */
		/* 820A2028h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000000B);
		/* 820A2028h case    9:*/		return 0x820A202C;
		  /* 820A202Ch */ case   10:  		/* bc 4, CR6_EQ, 664 */
		/* 820A202Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x820A22C4;  }
		/* 820A202Ch case   10:*/		return 0x820A2030;
		  /* 820A2030h */ case   11:  		/* lis R11, -32255 */
		/* 820A2030h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A2030h case   11:*/		return 0x820A2034;
		  /* 820A2034h */ case   12:  		/* lwz R23, <#[R27]> */
		/* 820A2034h case   12:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R27 + 0x00000000) );
		/* 820A2034h case   12:*/		return 0x820A2038;
		  /* 820A2038h */ case   13:  		/* li R26, 0 */
		/* 820A2038h case   13:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820A2038h case   13:*/		return 0x820A203C;
		  /* 820A203Ch */ case   14:  		/* addi R28, R1, 96 */
		/* 820A203Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x60);
		/* 820A203Ch case   14:*/		return 0x820A2040;
		  /* 820A2040h */ case   15:  		/* addi R25, R11, -16532 */
		/* 820A2040h case   15:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0xFFFFBF6C);
		/* 820A2040h case   15:*/		return 0x820A2044;
		  /* 820A2044h */ case   16:  		/* mr R5, R31 */
		/* 820A2044h case   16:*/		regs.R5 = regs.R31;
		/* 820A2044h case   16:*/		return 0x820A2048;
		  /* 820A2048h */ case   17:  		/* lwz R4, <#[R29 + 2256]> */
		/* 820A2048h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000008D0) );
		/* 820A2048h case   17:*/		return 0x820A204C;
		  /* 820A204Ch */ case   18:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A204Ch case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A204Ch case   18:*/		return 0x820A2050;
		  /* 820A2050h */ case   19:  		/* li R30, 0 */
		/* 820A2050h case   19:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A2050h case   19:*/		return 0x820A2054;
		  /* 820A2054h */ case   20:  		/* bl 24996 */
		/* 820A2054h case   20:*/		regs.LR = 0x820A2058; return 0x820A81F8;
		/* 820A2054h case   20:*/		return 0x820A2058;
		  /* 820A2058h */ case   21:  		/* cmpwi CR0, R3, 0 */
		/* 820A2058h case   21:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A2058h case   21:*/		return 0x820A205C;
		  /* 820A205Ch */ case   22:  		/* bc 12, CR0_LT, 648 */
		/* 820A205Ch case   22:*/		if ( regs.CR[0].lt ) { return 0x820A22E4;  }
		/* 820A205Ch case   22:*/		return 0x820A2060;
		  /* 820A2060h */ case   23:  		/* lwz R8, <#[R31]> */
		/* 820A2060h case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 820A2060h case   23:*/		return 0x820A2064;
		  /* 820A2064h */ case   24:  		/* cmpwi CR6, R8, 1 */
		/* 820A2064h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820A2064h case   24:*/		return 0x820A2068;
		  /* 820A2068h */ case   25:  		/* bc 4, CR6_EQ, 604 */
		/* 820A2068h case   25:*/		if ( !regs.CR[6].eq ) { return 0x820A22C4;  }
		/* 820A2068h case   25:*/		return 0x820A206C;
		  /* 820A206Ch */ case   26:  		/* mr R10, R24 */
		/* 820A206Ch case   26:*/		regs.R10 = regs.R24;
		/* 820A206Ch case   26:*/		return 0x820A2070;
		  /* 820A2070h */ case   27:  		/* mr R11, R27 */
		/* 820A2070h case   27:*/		regs.R11 = regs.R27;
		/* 820A2070h case   27:*/		return 0x820A2074;
		  /* 820A2074h */ case   28:  		/* lbz R9, <#[R11]> */
		/* 820A2074h case   28:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A2074h case   28:*/		return 0x820A2078;
		  /* 820A2078h */ case   29:  		/* lbz R7, <#[R10]> */
		/* 820A2078h case   29:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A2078h case   29:*/		return 0x820A207C;
		  /* 820A207Ch */ case   30:  		/* cmpwi CR0, R9, 0 */
		/* 820A207Ch case   30:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A207Ch case   30:*/		return 0x820A2080;
		  /* 820A2080h */ case   31:  		/* subf R9, R7, R9 */
		/* 820A2080h case   31:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A2080h case   31:*/		return 0x820A2084;
		  /* 820A2084h */ case   32:  		/* bc 12, CR0_EQ, 20 */
		/* 820A2084h case   32:*/		if ( regs.CR[0].eq ) { return 0x820A2098;  }
		/* 820A2084h case   32:*/		return 0x820A2088;
		  /* 820A2088h */ case   33:  		/* addi R11, R11, 1 */
		/* 820A2088h case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A2088h case   33:*/		return 0x820A208C;
		  /* 820A208Ch */ case   34:  		/* addi R10, R10, 1 */
		/* 820A208Ch case   34:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A208Ch case   34:*/		return 0x820A2090;
		  /* 820A2090h */ case   35:  		/* cmpwi CR6, R9, 0 */
		/* 820A2090h case   35:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A2090h case   35:*/		return 0x820A2094;
		  /* 820A2094h */ case   36:  		/* bc 12, CR6_EQ, -32 */
		/* 820A2094h case   36:*/		if ( regs.CR[6].eq ) { return 0x820A2074;  }
		/* 820A2094h case   36:*/		return 0x820A2098;
	}
	return 0x820A2098;
} // Block from 820A2004h-820A2098h (37 instructions)

//////////////////////////////////////////////////////
// Block at 820A2098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2098);
		  /* 820A2098h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A2098h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A2098h case    0:*/		return 0x820A209C;
		  /* 820A209Ch */ case    1:  		/* bc 4, CR0_EQ, 552 */
		/* 820A209Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A22C4;  }
		/* 820A209Ch case    1:*/		return 0x820A20A0;
		  /* 820A20A0h */ case    2:  		/* mr R5, R31 */
		/* 820A20A0h case    2:*/		regs.R5 = regs.R31;
		/* 820A20A0h case    2:*/		return 0x820A20A4;
		  /* 820A20A4h */ case    3:  		/* lwz R4, <#[R29 + 2256]> */
		/* 820A20A4h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000008D0) );
		/* 820A20A4h case    3:*/		return 0x820A20A8;
		  /* 820A20A8h */ case    4:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A20A8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A20A8h case    4:*/		return 0x820A20AC;
		  /* 820A20ACh */ case    5:  		/* bl 24908 */
		/* 820A20ACh case    5:*/		regs.LR = 0x820A20B0; return 0x820A81F8;
		/* 820A20ACh case    5:*/		return 0x820A20B0;
		  /* 820A20B0h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820A20B0h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A20B0h case    6:*/		return 0x820A20B4;
		  /* 820A20B4h */ case    7:  		/* bc 12, CR0_LT, 560 */
		/* 820A20B4h case    7:*/		if ( regs.CR[0].lt ) { return 0x820A22E4;  }
		/* 820A20B4h case    7:*/		return 0x820A20B8;
		  /* 820A20B8h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 820A20B8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A20B8h case    8:*/		return 0x820A20BC;
		  /* 820A20BCh */ case    9:  		/* cmpwi CR6, R11, 1 */
		/* 820A20BCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820A20BCh case    9:*/		return 0x820A20C0;
		  /* 820A20C0h */ case   10:  		/* bc 4, CR6_EQ, 84 */
		/* 820A20C0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820A2114;  }
		/* 820A20C0h case   10:*/		return 0x820A20C4;
		  /* 820A20C4h */ case   11:  		/* mr R10, R25 */
		/* 820A20C4h case   11:*/		regs.R10 = regs.R25;
		/* 820A20C4h case   11:*/		return 0x820A20C8;
		  /* 820A20C8h */ case   12:  		/* mr R11, R27 */
		/* 820A20C8h case   12:*/		regs.R11 = regs.R27;
		/* 820A20C8h case   12:*/		return 0x820A20CC;
		  /* 820A20CCh */ case   13:  		/* lbz R9, <#[R11]> */
		/* 820A20CCh case   13:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A20CCh case   13:*/		return 0x820A20D0;
		  /* 820A20D0h */ case   14:  		/* lbz R8, <#[R10]> */
		/* 820A20D0h case   14:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A20D0h case   14:*/		return 0x820A20D4;
		  /* 820A20D4h */ case   15:  		/* cmpwi CR0, R9, 0 */
		/* 820A20D4h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A20D4h case   15:*/		return 0x820A20D8;
		  /* 820A20D8h */ case   16:  		/* subf R9, R8, R9 */
		/* 820A20D8h case   16:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A20D8h case   16:*/		return 0x820A20DC;
		  /* 820A20DCh */ case   17:  		/* bc 12, CR0_EQ, 20 */
		/* 820A20DCh case   17:*/		if ( regs.CR[0].eq ) { return 0x820A20F0;  }
		/* 820A20DCh case   17:*/		return 0x820A20E0;
		  /* 820A20E0h */ case   18:  		/* addi R11, R11, 1 */
		/* 820A20E0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A20E0h case   18:*/		return 0x820A20E4;
		  /* 820A20E4h */ case   19:  		/* addi R10, R10, 1 */
		/* 820A20E4h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A20E4h case   19:*/		return 0x820A20E8;
		  /* 820A20E8h */ case   20:  		/* cmpwi CR6, R9, 0 */
		/* 820A20E8h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A20E8h case   20:*/		return 0x820A20EC;
		  /* 820A20ECh */ case   21:  		/* bc 12, CR6_EQ, -32 */
		/* 820A20ECh case   21:*/		if ( regs.CR[6].eq ) { return 0x820A20CC;  }
		/* 820A20ECh case   21:*/		return 0x820A20F0;
	}
	return 0x820A20F0;
} // Block from 820A2098h-820A20F0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820A20F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A20F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A20F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A20F0);
		  /* 820A20F0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A20F0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A20F0h case    0:*/		return 0x820A20F4;
		  /* 820A20F4h */ case    1:  		/* bc 4, CR0_EQ, 32 */
		/* 820A20F4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A2114;  }
		/* 820A20F4h case    1:*/		return 0x820A20F8;
		  /* 820A20F8h */ case    2:  		/* mr R5, R31 */
		/* 820A20F8h case    2:*/		regs.R5 = regs.R31;
		/* 820A20F8h case    2:*/		return 0x820A20FC;
		  /* 820A20FCh */ case    3:  		/* lwz R4, <#[R29 + 2256]> */
		/* 820A20FCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000008D0) );
		/* 820A20FCh case    3:*/		return 0x820A2100;
		  /* 820A2100h */ case    4:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A2100h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A2100h case    4:*/		return 0x820A2104;
		  /* 820A2104h */ case    5:  		/* li R30, 1 */
		/* 820A2104h case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820A2104h case    5:*/		return 0x820A2108;
		  /* 820A2108h */ case    6:  		/* bl 24816 */
		/* 820A2108h case    6:*/		regs.LR = 0x820A210C; return 0x820A81F8;
		/* 820A2108h case    6:*/		return 0x820A210C;
		  /* 820A210Ch */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820A210Ch case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A210Ch case    7:*/		return 0x820A2110;
		  /* 820A2110h */ case    8:  		/* bc 12, CR0_LT, 468 */
		/* 820A2110h case    8:*/		if ( regs.CR[0].lt ) { return 0x820A22E4;  }
		/* 820A2110h case    8:*/		return 0x820A2114;
	}
	return 0x820A2114;
} // Block from 820A20F0h-820A2114h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A2114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2114);
		  /* 820A2114h */ case    0:  		/* lwz R8, <#[R31]> */
		/* 820A2114h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 820A2114h case    0:*/		return 0x820A2118;
		  /* 820A2118h */ case    1:  		/* cmpwi CR6, R8, 2 */
		/* 820A2118h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000002);
		/* 820A2118h case    1:*/		return 0x820A211C;
		  /* 820A211Ch */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 820A211Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820A2158;  }
		/* 820A211Ch case    2:*/		return 0x820A2120;
		  /* 820A2120h */ case    3:  		/* cmpwi CR6, R8, 3 */
		/* 820A2120h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000003);
		/* 820A2120h case    3:*/		return 0x820A2124;
		  /* 820A2124h */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 820A2124h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A2148;  }
		/* 820A2124h case    4:*/		return 0x820A2128;
		  /* 820A2128h */ case    5:  		/* cmpwi CR6, R8, 4 */
		/* 820A2128h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000004);
		/* 820A2128h case    5:*/		return 0x820A212C;
		  /* 820A212Ch */ case    6:  		/* bc 12, CR6_EQ, 44 */
		/* 820A212Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820A2158;  }
		/* 820A212Ch case    6:*/		return 0x820A2130;
		  /* 820A2130h */ case    7:  		/* cmpwi CR6, R8, 6 */
		/* 820A2130h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000006);
		/* 820A2130h case    7:*/		return 0x820A2134;
		  /* 820A2134h */ case    8:  		/* bc 4, CR6_GT, 400 */
		/* 820A2134h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820A22C4;  }
		/* 820A2134h case    8:*/		return 0x820A2138;
		  /* 820A2138h */ case    9:  		/* cmpwi CR6, R8, 10 */
		/* 820A2138h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000000A);
		/* 820A2138h case    9:*/		return 0x820A213C;
		  /* 820A213Ch */ case   10:  		/* bc 12, CR6_GT, 392 */
		/* 820A213Ch case   10:*/		if ( regs.CR[6].gt ) { return 0x820A22C4;  }
		/* 820A213Ch case   10:*/		return 0x820A2140;
		  /* 820A2140h */ case   11:  		/* lfd FR0, <#[R27]> */
		/* 820A2140h case   11:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R27 + 0x00000000) );
		/* 820A2140h case   11:*/		return 0x820A2144;
		  /* 820A2144h */ case   12:  		/* b 36 */
		/* 820A2144h case   12:*/		return 0x820A2168;
		/* 820A2144h case   12:*/		return 0x820A2148;
	}
	return 0x820A2148;
} // Block from 820A2114h-820A2148h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A2148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2148);
		  /* 820A2148h */ case    0:  		/* lwa R11, <#[R27]> */
		/* 820A2148h case    0:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A2148h case    0:*/		return 0x820A214C;
		  /* 820A214Ch */ case    1:  		/* std R11, <#[R1 + 80]> */
		/* 820A214Ch case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A214Ch case    1:*/		return 0x820A2150;
		  /* 820A2150h */ case    2:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820A2150h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820A2150h case    2:*/		return 0x820A2154;
		  /* 820A2154h */ case    3:  		/* b 16 */
		/* 820A2154h case    3:*/		return 0x820A2164;
		/* 820A2154h case    3:*/		return 0x820A2158;
	}
	return 0x820A2158;
} // Block from 820A2148h-820A2158h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A2158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2158);
		  /* 820A2158h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 820A2158h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A2158h case    0:*/		return 0x820A215C;
		  /* 820A215Ch */ case    1:  		/* std R11, <#[R1 + 88]> */
		/* 820A215Ch case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 820A215Ch case    1:*/		return 0x820A2160;
		  /* 820A2160h */ case    2:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820A2160h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820A2160h case    2:*/		return 0x820A2164;
	}
	return 0x820A2164;
} // Block from 820A2158h-820A2164h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A2164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2164);
		  /* 820A2164h */ case    0:  		/* fcfid FR0, FR0 */
		/* 820A2164h case    0:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820A2164h case    0:*/		return 0x820A2168;
	}
	return 0x820A2168;
} // Block from 820A2164h-820A2168h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A2168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2168);
		  /* 820A2168h */ case    0:  		/* stfd FR0, <#[R28]> */
		/* 820A2168h case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R28 + 0x00000000) );
		/* 820A2168h case    0:*/		return 0x820A216C;
		  /* 820A216Ch */ case    1:  		/* cmpwi CR6, R30, 0 */
		/* 820A216Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820A216Ch case    1:*/		return 0x820A2170;
		  /* 820A2170h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820A2170h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A217C;  }
		/* 820A2170h case    2:*/		return 0x820A2174;
		  /* 820A2174h */ case    3:  		/* fneg FR0, FR0 */
		/* 820A2174h case    3:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 820A2174h case    3:*/		return 0x820A2178;
		  /* 820A2178h */ case    4:  		/* stfd FR0, <#[R28]> */
		/* 820A2178h case    4:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R28 + 0x00000000) );
		/* 820A2178h case    4:*/		return 0x820A217C;
	}
	return 0x820A217C;
} // Block from 820A2168h-820A217Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A217Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A217C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A217C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A217C);
		  /* 820A217Ch */ case    0:  		/* addi R26, R26, 1 */
		/* 820A217Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820A217Ch case    0:*/		return 0x820A2180;
		  /* 820A2180h */ case    1:  		/* addi R28, R28, 8 */
		/* 820A2180h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 820A2180h case    1:*/		return 0x820A2184;
		  /* 820A2184h */ case    2:  		/* cmplwi CR6, R26, 4 */
		/* 820A2184h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000004);
		/* 820A2184h case    2:*/		return 0x820A2188;
		  /* 820A2188h */ case    3:  		/* bc 12, CR6_LT, -324 */
		/* 820A2188h case    3:*/		if ( regs.CR[6].lt ) { return 0x820A2044;  }
		/* 820A2188h case    3:*/		return 0x820A218C;
		  /* 820A218Ch */ case    4:  		/* mr R5, R31 */
		/* 820A218Ch case    4:*/		regs.R5 = regs.R31;
		/* 820A218Ch case    4:*/		return 0x820A2190;
		  /* 820A2190h */ case    5:  		/* lwz R4, <#[R29 + 2256]> */
		/* 820A2190h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000008D0) );
		/* 820A2190h case    5:*/		return 0x820A2194;
		  /* 820A2194h */ case    6:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A2194h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A2194h case    6:*/		return 0x820A2198;
		  /* 820A2198h */ case    7:  		/* bl 24672 */
		/* 820A2198h case    7:*/		regs.LR = 0x820A219C; return 0x820A81F8;
		/* 820A2198h case    7:*/		return 0x820A219C;
		  /* 820A219Ch */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820A219Ch case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A219Ch case    8:*/		return 0x820A21A0;
		  /* 820A21A0h */ case    9:  		/* bc 12, CR0_LT, 324 */
		/* 820A21A0h case    9:*/		if ( regs.CR[0].lt ) { return 0x820A22E4;  }
		/* 820A21A0h case    9:*/		return 0x820A21A4;
		  /* 820A21A4h */ case   10:  		/* lwz R8, <#[R31]> */
		/* 820A21A4h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 820A21A4h case   10:*/		return 0x820A21A8;
		  /* 820A21A8h */ case   11:  		/* cmpwi CR6, R8, 1 */
		/* 820A21A8h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820A21A8h case   11:*/		return 0x820A21AC;
		  /* 820A21ACh */ case   12:  		/* bc 4, CR6_EQ, 280 */
		/* 820A21ACh case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A22C4;  }
		/* 820A21ACh case   12:*/		return 0x820A21B0;
		  /* 820A21B0h */ case   13:  		/* lis R10, -32255 */
		/* 820A21B0h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A21B0h case   13:*/		return 0x820A21B4;
		  /* 820A21B4h */ case   14:  		/* mr R11, R27 */
		/* 820A21B4h case   14:*/		regs.R11 = regs.R27;
		/* 820A21B4h case   14:*/		return 0x820A21B8;
		  /* 820A21B8h */ case   15:  		/* addi R10, R10, -10832 */
		/* 820A21B8h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD5B0);
		/* 820A21B8h case   15:*/		return 0x820A21BC;
		  /* 820A21BCh */ case   16:  		/* lbz R9, <#[R11]> */
		/* 820A21BCh case   16:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A21BCh case   16:*/		return 0x820A21C0;
		  /* 820A21C0h */ case   17:  		/* lbz R7, <#[R10]> */
		/* 820A21C0h case   17:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A21C0h case   17:*/		return 0x820A21C4;
		  /* 820A21C4h */ case   18:  		/* cmpwi CR0, R9, 0 */
		/* 820A21C4h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A21C4h case   18:*/		return 0x820A21C8;
		  /* 820A21C8h */ case   19:  		/* subf R9, R7, R9 */
		/* 820A21C8h case   19:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A21C8h case   19:*/		return 0x820A21CC;
		  /* 820A21CCh */ case   20:  		/* bc 12, CR0_EQ, 20 */
		/* 820A21CCh case   20:*/		if ( regs.CR[0].eq ) { return 0x820A21E0;  }
		/* 820A21CCh case   20:*/		return 0x820A21D0;
		  /* 820A21D0h */ case   21:  		/* addi R11, R11, 1 */
		/* 820A21D0h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A21D0h case   21:*/		return 0x820A21D4;
		  /* 820A21D4h */ case   22:  		/* addi R10, R10, 1 */
		/* 820A21D4h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A21D4h case   22:*/		return 0x820A21D8;
		  /* 820A21D8h */ case   23:  		/* cmpwi CR6, R9, 0 */
		/* 820A21D8h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A21D8h case   23:*/		return 0x820A21DC;
		  /* 820A21DCh */ case   24:  		/* bc 12, CR6_EQ, -32 */
		/* 820A21DCh case   24:*/		if ( regs.CR[6].eq ) { return 0x820A21BC;  }
		/* 820A21DCh case   24:*/		return 0x820A21E0;
	}
	return 0x820A21E0;
} // Block from 820A217Ch-820A21E0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820A21E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A21E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A21E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A21E0);
		  /* 820A21E0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A21E0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A21E0h case    0:*/		return 0x820A21E4;
		  /* 820A21E4h */ case    1:  		/* bc 4, CR0_EQ, 224 */
		/* 820A21E4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A22C4;  }
		/* 820A21E4h case    1:*/		return 0x820A21E8;
		  /* 820A21E8h */ case    2:  		/* mr R5, R31 */
		/* 820A21E8h case    2:*/		regs.R5 = regs.R31;
		/* 820A21E8h case    2:*/		return 0x820A21EC;
		  /* 820A21ECh */ case    3:  		/* lwz R4, <#[R29 + 2256]> */
		/* 820A21ECh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000008D0) );
		/* 820A21ECh case    3:*/		return 0x820A21F0;
		  /* 820A21F0h */ case    4:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A21F0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A21F0h case    4:*/		return 0x820A21F4;
		  /* 820A21F4h */ case    5:  		/* bl 24580 */
		/* 820A21F4h case    5:*/		regs.LR = 0x820A21F8; return 0x820A81F8;
		/* 820A21F4h case    5:*/		return 0x820A21F8;
		  /* 820A21F8h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820A21F8h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A21F8h case    6:*/		return 0x820A21FC;
		  /* 820A21FCh */ case    7:  		/* bc 12, CR0_LT, 232 */
		/* 820A21FCh case    7:*/		if ( regs.CR[0].lt ) { return 0x820A22E4;  }
		/* 820A21FCh case    7:*/		return 0x820A2200;
		  /* 820A2200h */ case    8:  		/* lwz R8, <#[R31]> */
		/* 820A2200h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 820A2200h case    8:*/		return 0x820A2204;
		  /* 820A2204h */ case    9:  		/* cmpwi CR6, R8, 16 */
		/* 820A2204h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000010);
		/* 820A2204h case    9:*/		return 0x820A2208;
		  /* 820A2208h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820A2208h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A2214;  }
		/* 820A2208h case   10:*/		return 0x820A220C;
		  /* 820A220Ch */ case   11:  		/* cmpwi CR6, R8, 17 */
		/* 820A220Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000011);
		/* 820A220Ch case   11:*/		return 0x820A2210;
		  /* 820A2210h */ case   12:  		/* bc 4, CR6_EQ, 180 */
		/* 820A2210h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A22C4;  }
		/* 820A2210h case   12:*/		return 0x820A2214;
	}
	return 0x820A2214;
} // Block from 820A21E0h-820A2214h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A2214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2214);
		  /* 820A2214h */ case    0:  		/* lis R4, 9345 */
		/* 820A2214h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A2214h case    0:*/		return 0x820A2218;
		  /* 820A2218h */ case    1:  		/* li R3, 48 */
		/* 820A2218h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x30);
		/* 820A2218h case    1:*/		return 0x820A221C;
		  /* 820A221Ch */ case    2:  		/* bl -106524 */
		/* 820A221Ch case    2:*/		regs.LR = 0x820A2220; return 0x82088200;
		/* 820A221Ch case    2:*/		return 0x820A2220;
		  /* 820A2220h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820A2220h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A2220h case    3:*/		return 0x820A2224;
		  /* 820A2224h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 820A2224h case    4:*/		if ( regs.CR[0].eq ) { return 0x820A2238;  }
		/* 820A2224h case    4:*/		return 0x820A2228;
		  /* 820A2228h */ case    5:  		/* li R11, 0 */
		/* 820A2228h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A2228h case    5:*/		return 0x820A222C;
		  /* 820A222Ch */ case    6:  		/* mr R31, R3 */
		/* 820A222Ch case    6:*/		regs.R31 = regs.R3;
		/* 820A222Ch case    6:*/		return 0x820A2230;
		  /* 820A2230h */ case    7:  		/* stw R11, <#[R3 + 40]> */
		/* 820A2230h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820A2230h case    7:*/		return 0x820A2234;
		  /* 820A2234h */ case    8:  		/* b 8 */
		/* 820A2234h case    8:*/		return 0x820A223C;
		/* 820A2234h case    8:*/		return 0x820A2238;
	}
	return 0x820A2238;
} // Block from 820A2214h-820A2238h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A2238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2238);
		  /* 820A2238h */ case    0:  		/* li R31, 0 */
		/* 820A2238h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820A2238h case    0:*/		return 0x820A223C;
	}
	return 0x820A223C;
} // Block from 820A2238h-820A223Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A223Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A223C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A223C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A223C);
		  /* 820A223Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820A223Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A223Ch case    0:*/		return 0x820A2240;
		  /* 820A2240h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A2240h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A2250;  }
		/* 820A2240h case    1:*/		return 0x820A2244;
		  /* 820A2244h */ case    2:  		/* lis R3, -32761 */
		/* 820A2244h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A2244h case    2:*/		return 0x820A2248;
		  /* 820A2248h */ case    3:  		/* ori R3, R3, 14 */
		/* 820A2248h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A2248h case    3:*/		return 0x820A224C;
		  /* 820A224Ch */ case    4:  		/* b 152 */
		/* 820A224Ch case    4:*/		return 0x820A22E4;
		/* 820A224Ch case    4:*/		return 0x820A2250;
	}
	return 0x820A2250;
} // Block from 820A223Ch-820A2250h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A2250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2250);
		  /* 820A2250h */ case    0:  		/* addi R10, R1, 96 */
		/* 820A2250h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 820A2250h case    0:*/		return 0x820A2254;
		  /* 820A2254h */ case    1:  		/* stw R22, <#[R31]> */
		/* 820A2254h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000000) );
		/* 820A2254h case    1:*/		return 0x820A2258;
		  /* 820A2258h */ case    2:  		/* addi R11, R31, 8 */
		/* 820A2258h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x8);
		/* 820A2258h case    2:*/		return 0x820A225C;
		  /* 820A225Ch */ case    3:  		/* stw R23, <#[R31 + 4]> */
		/* 820A225Ch case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000004) );
		/* 820A225Ch case    3:*/		return 0x820A2260;
		  /* 820A2260h */ case    4:  		/* addi R30, R29, 68 */
		/* 820A2260h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0x44);
		/* 820A2260h case    4:*/		return 0x820A2264;
		  /* 820A2264h */ case    5:  		/* ld R11, <#[R10]> */
		/* 820A2264h case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820A2264h case    5:*/		return 0x820A2268;
		  /* 820A2268h */ case    6:  		/* ld R9, <#[R10 + 8]> */
		/* 820A2268h case    6:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 820A2268h case    6:*/		return 0x820A226C;
		  /* 820A226Ch */ case    7:  		/* ld R8, <#[R10 + 16]> */
		/* 820A226Ch case    7:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 820A226Ch case    7:*/		return 0x820A2270;
		  /* 820A2270h */ case    8:  		/* ld R10, <#[R10 + 24]> */
		/* 820A2270h case    8:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 820A2270h case    8:*/		return 0x820A2274;
		  /* 820A2274h */ case    9:  		/* std R11, <#[R31 + 8]> */
		/* 820A2274h case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820A2274h case    9:*/		return 0x820A2278;
		  /* 820A2278h */ case   10:  		/* std R9, <#[R31 + 16]> */
		/* 820A2278h case   10:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820A2278h case   10:*/		return 0x820A227C;
		  /* 820A227Ch */ case   11:  		/* std R8, <#[R31 + 24]> */
		/* 820A227Ch case   11:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 820A227Ch case   11:*/		return 0x820A2280;
		  /* 820A2280h */ case   12:  		/* std R10, <#[R31 + 32]> */
		/* 820A2280h case   12:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 820A2280h case   12:*/		return 0x820A2284;
		  /* 820A2284h */ case   13:  		/* lwz R11, <#[R29 + 68]> */
		/* 820A2284h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000044) );
		/* 820A2284h case   13:*/		return 0x820A2288;
		  /* 820A2288h */ case   14:  		/* b 36 */
		/* 820A2288h case   14:*/		return 0x820A22AC;
		/* 820A2288h case   14:*/		return 0x820A228C;
		  /* 820A228Ch */ case   15:  		/* lwz R4, <#[R31 + 4]> */
		/* 820A228Ch case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 820A228Ch case   15:*/		return 0x820A2290;
		  /* 820A2290h */ case   16:  		/* lwz R3, <#[R11 + 4]> */
		/* 820A2290h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 820A2290h case   16:*/		return 0x820A2294;
		  /* 820A2294h */ case   17:  		/* bl -61028 */
		/* 820A2294h case   17:*/		regs.LR = 0x820A2298; return 0x82093430;
		/* 820A2294h case   17:*/		return 0x820A2298;
		  /* 820A2298h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820A2298h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A2298h case   18:*/		return 0x820A229C;
		  /* 820A229Ch */ case   19:  		/* bc 4, CR0_LT, 24 */
		/* 820A229Ch case   19:*/		if ( !regs.CR[0].lt ) { return 0x820A22B4;  }
		/* 820A229Ch case   19:*/		return 0x820A22A0;
		  /* 820A22A0h */ case   20:  		/* lwz R11, <#[R30]> */
		/* 820A22A0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A22A0h case   20:*/		return 0x820A22A4;
		  /* 820A22A4h */ case   21:  		/* addi R30, R11, 40 */
		/* 820A22A4h case   21:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x28);
		/* 820A22A4h case   21:*/		return 0x820A22A8;
		  /* 820A22A8h */ case   22:  		/* lwz R11, <#[R11 + 40]> */
		/* 820A22A8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 820A22A8h case   22:*/		return 0x820A22AC;
	}
	return 0x820A22AC;
} // Block from 820A2250h-820A22ACh (23 instructions)

//////////////////////////////////////////////////////
// Block at 820A22ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A22AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A22AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A22AC);
		  /* 820A22ACh */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820A22ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A22ACh case    0:*/		return 0x820A22B0;
		  /* 820A22B0h */ case    1:  		/* bc 4, CR6_EQ, -36 */
		/* 820A22B0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A228C;  }
		/* 820A22B0h case    1:*/		return 0x820A22B4;
	}
	return 0x820A22B4;
} // Block from 820A22ACh-820A22B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A22B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A22B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A22B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A22B4);
		  /* 820A22B4h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820A22B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A22B4h case    0:*/		return 0x820A22B8;
		  /* 820A22B8h */ case    1:  		/* stw R11, <#[R31 + 40]> */
		/* 820A22B8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820A22B8h case    1:*/		return 0x820A22BC;
		  /* 820A22BCh */ case    2:  		/* stw R31, <#[R30]> */
		/* 820A22BCh case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 820A22BCh case    2:*/		return 0x820A22C0;
		  /* 820A22C0h */ case    3:  		/* b 32 */
		/* 820A22C0h case    3:*/		return 0x820A22E0;
		/* 820A22C0h case    3:*/		return 0x820A22C4;
	}
	return 0x820A22C4;
} // Block from 820A22B4h-820A22C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A22C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A22C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A22C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A22C4);
		  /* 820A22C4h */ case    0:  		/* cmpwi CR6, R8, 16 */
		/* 820A22C4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000010);
		/* 820A22C4h case    0:*/		return 0x820A22C8;
		  /* 820A22C8h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820A22C8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A22E0;  }
		/* 820A22C8h case    1:*/		return 0x820A22CC;
		  /* 820A22CCh */ case    2:  		/* cmpwi CR6, R8, 17 */
		/* 820A22CCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000011);
		/* 820A22CCh case    2:*/		return 0x820A22D0;
		  /* 820A22D0h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 820A22D0h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A22E0;  }
		/* 820A22D0h case    3:*/		return 0x820A22D4;
		  /* 820A22D4h */ case    4:  		/* li R4, 0 */
		/* 820A22D4h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A22D4h case    4:*/		return 0x820A22D8;
		  /* 820A22D8h */ case    5:  		/* lwz R3, <#[R29 + 2204]> */
		/* 820A22D8h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000089C) );
		/* 820A22D8h case    5:*/		return 0x820A22DC;
		  /* 820A22DCh */ case    6:  		/* bl 21124 */
		/* 820A22DCh case    6:*/		regs.LR = 0x820A22E0; return 0x820A7560;
		/* 820A22DCh case    6:*/		return 0x820A22E0;
	}
	return 0x820A22E0;
} // Block from 820A22C4h-820A22E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A22E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A22E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A22E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A22E0);
		  /* 820A22E0h */ case    0:  		/* li R3, 0 */
		/* 820A22E0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A22E0h case    0:*/		return 0x820A22E4;
	}
	return 0x820A22E4;
} // Block from 820A22E0h-820A22E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A22E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A22E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A22E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A22E4);
		  /* 820A22E4h */ case    0:  		/* li R11, 1 */
		/* 820A22E4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A22E4h case    0:*/		return 0x820A22E8;
		  /* 820A22E8h */ case    1:  		/* stw R11, <#[R29 + 1636]> */
		/* 820A22E8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000664) );
		/* 820A22E8h case    1:*/		return 0x820A22EC;
		  /* 820A22ECh */ case    2:  		/* addi R1, R1, 224 */
		/* 820A22ECh case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 820A22ECh case    2:*/		return 0x820A22F0;
		  /* 820A22F0h */ case    3:  		/* b -69728 */
		/* 820A22F0h case    3:*/		return 0x82091290;
		/* 820A22F0h case    3:*/		return 0x820A22F4;
		  /* 820A22F4h */ case    4:  		/* nop */
		/* 820A22F4h case    4:*/		cpu::op::nop();
		/* 820A22F4h case    4:*/		return 0x820A22F8;
	}
	return 0x820A22F8;
} // Block from 820A22E4h-820A22F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A22F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A22F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A22F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A22F8);
		  /* 820A22F8h */ case    0:  		/* mfspr R12, LR */
		/* 820A22F8h case    0:*/		regs.R12 = regs.LR;
		/* 820A22F8h case    0:*/		return 0x820A22FC;
		  /* 820A22FCh */ case    1:  		/* bl -69796 */
		/* 820A22FCh case    1:*/		regs.LR = 0x820A2300; return 0x82091258;
		/* 820A22FCh case    1:*/		return 0x820A2300;
		  /* 820A2300h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820A2300h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820A2300h case    2:*/		return 0x820A2304;
		  /* 820A2304h */ case    3:  		/* lwz R29, <#[R4]> */
		/* 820A2304h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x00000000) );
		/* 820A2304h case    3:*/		return 0x820A2308;
		  /* 820A2308h */ case    4:  		/* mr R28, R4 */
		/* 820A2308h case    4:*/		regs.R28 = regs.R4;
		/* 820A2308h case    4:*/		return 0x820A230C;
		  /* 820A230Ch */ case    5:  		/* mr R30, R3 */
		/* 820A230Ch case    5:*/		regs.R30 = regs.R3;
		/* 820A230Ch case    5:*/		return 0x820A2310;
		  /* 820A2310h */ case    6:  		/* mr R4, R29 */
		/* 820A2310h case    6:*/		regs.R4 = regs.R29;
		/* 820A2310h case    6:*/		return 0x820A2314;
		  /* 820A2314h */ case    7:  		/* bl -6724 */
		/* 820A2314h case    7:*/		regs.LR = 0x820A2318; return 0x820A08D0;
		/* 820A2314h case    7:*/		return 0x820A2318;
		  /* 820A2318h */ case    8:  		/* addi R11, R3, 421 */
		/* 820A2318h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1A5);
		/* 820A2318h case    8:*/		return 0x820A231C;
		  /* 820A231Ch */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820A231Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820A231Ch case    9:*/		return 0x820A2320;
		  /* 820A2320h */ case   10:  		/* add R31, R11, R30 */
		/* 820A2320h case   10:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R30);
		/* 820A2320h case   10:*/		return 0x820A2324;
		  /* 820A2324h */ case   11:  		/* lwzx R11, <#[R11 + R30]> */
		/* 820A2324h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820A2324h case   11:*/		return 0x820A2328;
		  /* 820A2328h */ case   12:  		/* b 76 */
		/* 820A2328h case   12:*/		return 0x820A2374;
		/* 820A2328h case   12:*/		return 0x820A232C;
		  /* 820A232Ch */ case   13:  		/* lwz R4, <#[R31]> */
		/* 820A232Ch case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820A232Ch case   13:*/		return 0x820A2330;
		  /* 820A2330h */ case   14:  		/* mr R11, R29 */
		/* 820A2330h case   14:*/		regs.R11 = regs.R29;
		/* 820A2330h case   14:*/		return 0x820A2334;
		  /* 820A2334h */ case   15:  		/* lwz R10, <#[R4]> */
		/* 820A2334h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 820A2334h case   15:*/		return 0x820A2338;
		  /* 820A2338h */ case   16:  		/* lbz R9, <#[R11]> */
		/* 820A2338h case   16:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A2338h case   16:*/		return 0x820A233C;
		  /* 820A233Ch */ case   17:  		/* lbz R8, <#[R10]> */
		/* 820A233Ch case   17:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A233Ch case   17:*/		return 0x820A2340;
		  /* 820A2340h */ case   18:  		/* cmpwi CR0, R9, 0 */
		/* 820A2340h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A2340h case   18:*/		return 0x820A2344;
		  /* 820A2344h */ case   19:  		/* subf R9, R8, R9 */
		/* 820A2344h case   19:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A2344h case   19:*/		return 0x820A2348;
		  /* 820A2348h */ case   20:  		/* bc 12, CR0_EQ, 20 */
		/* 820A2348h case   20:*/		if ( regs.CR[0].eq ) { return 0x820A235C;  }
		/* 820A2348h case   20:*/		return 0x820A234C;
		  /* 820A234Ch */ case   21:  		/* addi R11, R11, 1 */
		/* 820A234Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A234Ch case   21:*/		return 0x820A2350;
		  /* 820A2350h */ case   22:  		/* addi R10, R10, 1 */
		/* 820A2350h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A2350h case   22:*/		return 0x820A2354;
		  /* 820A2354h */ case   23:  		/* cmpwi CR6, R9, 0 */
		/* 820A2354h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A2354h case   23:*/		return 0x820A2358;
		  /* 820A2358h */ case   24:  		/* bc 12, CR6_EQ, -32 */
		/* 820A2358h case   24:*/		if ( regs.CR[6].eq ) { return 0x820A2338;  }
		/* 820A2358h case   24:*/		return 0x820A235C;
	}
	return 0x820A235C;
} // Block from 820A22F8h-820A235Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 820A235Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A235C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A235C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A235C);
		  /* 820A235Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A235Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A235Ch case    0:*/		return 0x820A2360;
		  /* 820A2360h */ case    1:  		/* bc 12, CR0_LT, 108 */
		/* 820A2360h case    1:*/		if ( regs.CR[0].lt ) { return 0x820A23CC;  }
		/* 820A2360h case    1:*/		return 0x820A2364;
		  /* 820A2364h */ case    2:  		/* cmpwi CR6, R9, 0 */
		/* 820A2364h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A2364h case    2:*/		return 0x820A2368;
		  /* 820A2368h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820A2368h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A2380;  }
		/* 820A2368h case    3:*/		return 0x820A236C;
		  /* 820A236Ch */ case    4:  		/* lwz R11, <#[R4 + 12]> */
		/* 820A236Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 820A236Ch case    4:*/		return 0x820A2370;
		  /* 820A2370h */ case    5:  		/* addi R31, R4, 12 */
		/* 820A2370h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R4,0xC);
		/* 820A2370h case    5:*/		return 0x820A2374;
	}
	return 0x820A2374;
} // Block from 820A235Ch-820A2374h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A2374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2374);
		  /* 820A2374h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820A2374h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A2374h case    0:*/		return 0x820A2378;
		  /* 820A2378h */ case    1:  		/* bc 4, CR6_EQ, -76 */
		/* 820A2378h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A232C;  }
		/* 820A2378h case    1:*/		return 0x820A237C;
		  /* 820A237Ch */ case    2:  		/* b 80 */
		/* 820A237Ch case    2:*/		return 0x820A23CC;
		/* 820A237Ch case    2:*/		return 0x820A2380;
	}
	return 0x820A2380;
} // Block from 820A2374h-820A2380h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A2380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2380);
		  /* 820A2380h */ case    0:  		/* mr R5, R28 */
		/* 820A2380h case    0:*/		regs.R5 = regs.R28;
		/* 820A2380h case    0:*/		return 0x820A2384;
		  /* 820A2384h */ case    1:  		/* mr R3, R30 */
		/* 820A2384h case    1:*/		regs.R3 = regs.R30;
		/* 820A2384h case    1:*/		return 0x820A2388;
		  /* 820A2388h */ case    2:  		/* bl -6760 */
		/* 820A2388h case    2:*/		regs.LR = 0x820A238C; return 0x820A0920;
		/* 820A2388h case    2:*/		return 0x820A238C;
		  /* 820A238Ch */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820A238Ch case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A238Ch case    3:*/		return 0x820A2390;
		  /* 820A2390h */ case    4:  		/* bc 4, CR0_EQ, 32 */
		/* 820A2390h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820A23B0;  }
		/* 820A2390h case    4:*/		return 0x820A2394;
		  /* 820A2394h */ case    5:  		/* lis R11, -32255 */
		/* 820A2394h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A2394h case    5:*/		return 0x820A2398;
		  /* 820A2398h */ case    6:  		/* mr R7, R29 */
		/* 820A2398h case    6:*/		regs.R7 = regs.R29;
		/* 820A2398h case    6:*/		return 0x820A239C;
		  /* 820A239Ch */ case    7:  		/* addi R6, R11, -10584 */
		/* 820A239Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD6A8);
		/* 820A239Ch case    7:*/		return 0x820A23A0;
		  /* 820A23A0h */ case    8:  		/* li R5, 1519 */
		/* 820A23A0h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x5EF);
		/* 820A23A0h case    8:*/		return 0x820A23A4;
		  /* 820A23A4h */ case    9:  		/* addi R4, R30, 2216 */
		/* 820A23A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x8A8);
		/* 820A23A4h case    9:*/		return 0x820A23A8;
		  /* 820A23A8h */ case   10:  		/* addi R3, R30, 24 */
		/* 820A23A8h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x18);
		/* 820A23A8h case   10:*/		return 0x820A23AC;
		  /* 820A23ACh */ case   11:  		/* bl 20396 */
		/* 820A23ACh case   11:*/		regs.LR = 0x820A23B0; return 0x820A7358;
		/* 820A23ACh case   11:*/		return 0x820A23B0;
	}
	return 0x820A23B0;
} // Block from 820A2380h-820A23B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A23B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A23B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A23B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A23B0);
		  /* 820A23B0h */ case    0:  		/* lwz R3, <#[R31]> */
		/* 820A23B0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A23B0h case    0:*/		return 0x820A23B4;
		  /* 820A23B4h */ case    1:  		/* li R11, 0 */
		/* 820A23B4h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A23B4h case    1:*/		return 0x820A23B8;
		  /* 820A23B8h */ case    2:  		/* li R4, 1 */
		/* 820A23B8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A23B8h case    2:*/		return 0x820A23BC;
		  /* 820A23BCh */ case    3:  		/* lwz R10, <#[R3 + 12]> */
		/* 820A23BCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A23BCh case    3:*/		return 0x820A23C0;
		  /* 820A23C0h */ case    4:  		/* stw R10, <#[R31]> */
		/* 820A23C0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820A23C0h case    4:*/		return 0x820A23C4;
		  /* 820A23C4h */ case    5:  		/* stw R11, <#[R3 + 12]> */
		/* 820A23C4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A23C4h case    5:*/		return 0x820A23C8;
		  /* 820A23C8h */ case    6:  		/* bl -5312 */
		/* 820A23C8h case    6:*/		regs.LR = 0x820A23CC; return 0x820A0F08;
		/* 820A23C8h case    6:*/		return 0x820A23CC;
	}
	return 0x820A23CC;
} // Block from 820A23B0h-820A23CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A23CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A23CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A23CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A23CC);
		  /* 820A23CCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A23CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A23CCh case    0:*/		return 0x820A23D0;
		  /* 820A23D0h */ case    1:  		/* li R3, 0 */
		/* 820A23D0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A23D0h case    1:*/		return 0x820A23D4;
		  /* 820A23D4h */ case    2:  		/* stw R11, <#[R28 + 12]> */
		/* 820A23D4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 820A23D4h case    2:*/		return 0x820A23D8;
		  /* 820A23D8h */ case    3:  		/* stw R28, <#[R31]> */
		/* 820A23D8h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 820A23D8h case    3:*/		return 0x820A23DC;
		  /* 820A23DCh */ case    4:  		/* addi R1, R1, 128 */
		/* 820A23DCh case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820A23DCh case    4:*/		return 0x820A23E0;
		  /* 820A23E0h */ case    5:  		/* b -69944 */
		/* 820A23E0h case    5:*/		return 0x820912A8;
		/* 820A23E0h case    5:*/		return 0x820A23E4;
		  /* 820A23E4h */ case    6:  		/* nop */
		/* 820A23E4h case    6:*/		cpu::op::nop();
		/* 820A23E4h case    6:*/		return 0x820A23E8;
	}
	return 0x820A23E8;
} // Block from 820A23CCh-820A23E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A23E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A23E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A23E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A23E8);
		  /* 820A23E8h */ case    0:  		/* mfspr R12, LR */
		/* 820A23E8h case    0:*/		regs.R12 = regs.LR;
		/* 820A23E8h case    0:*/		return 0x820A23EC;
		  /* 820A23ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A23ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A23ECh case    1:*/		return 0x820A23F0;
		  /* 820A23F0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A23F0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A23F0h case    2:*/		return 0x820A23F4;
		  /* 820A23F4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A23F4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A23F4h case    3:*/		return 0x820A23F8;
		  /* 820A23F8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A23F8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A23F8h case    4:*/		return 0x820A23FC;
		  /* 820A23FCh */ case    5:  		/* mr R30, R3 */
		/* 820A23FCh case    5:*/		regs.R30 = regs.R3;
		/* 820A23FCh case    5:*/		return 0x820A2400;
		  /* 820A2400h */ case    6:  		/* mr R31, R4 */
		/* 820A2400h case    6:*/		regs.R31 = regs.R4;
		/* 820A2400h case    6:*/		return 0x820A2404;
		  /* 820A2404h */ case    7:  		/* lis R4, 9345 */
		/* 820A2404h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A2404h case    7:*/		return 0x820A2408;
		  /* 820A2408h */ case    8:  		/* li R3, 20 */
		/* 820A2408h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A2408h case    8:*/		return 0x820A240C;
		  /* 820A240Ch */ case    9:  		/* bl -107020 */
		/* 820A240Ch case    9:*/		regs.LR = 0x820A2410; return 0x82088200;
		/* 820A240Ch case    9:*/		return 0x820A2410;
		  /* 820A2410h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 820A2410h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A2410h case   10:*/		return 0x820A2414;
		  /* 820A2414h */ case   11:  		/* bc 12, CR0_EQ, 40 */
		/* 820A2414h case   11:*/		if ( regs.CR[0].eq ) { return 0x820A243C;  }
		/* 820A2414h case   11:*/		return 0x820A2418;
	}
	return 0x820A2418;
} // Block from 820A23E8h-820A2418h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A2418h
// Function '?DoUndef@CPreProcessor@D3DXShader@@IAAJPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2418);
		  /* 820A2418h */ case    0:  		/* li R11, 0 */
		/* 820A2418h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A2418h case    0:*/		return 0x820A241C;
		  /* 820A241Ch */ case    1:  		/* stw R31, <#[R3]> */
		/* 820A241Ch case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 820A241Ch case    1:*/		return 0x820A2420;
		  /* 820A2420h */ case    2:  		/* mr R4, R3 */
		/* 820A2420h case    2:*/		regs.R4 = regs.R3;
		/* 820A2420h case    2:*/		return 0x820A2424;
		  /* 820A2424h */ case    3:  		/* stw R11, <#[R3 + 4]> */
		/* 820A2424h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820A2424h case    3:*/		return 0x820A2428;
		  /* 820A2428h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 820A2428h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A2428h case    4:*/		return 0x820A242C;
		  /* 820A242Ch */ case    5:  		/* stw R11, <#[R3 + 12]> */
		/* 820A242Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A242Ch case    5:*/		return 0x820A2430;
		  /* 820A2430h */ case    6:  		/* stb R11, <#[R3 + 16]> */
		/* 820A2430h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820A2430h case    6:*/		return 0x820A2434;
		  /* 820A2434h */ case    7:  		/* stb R11, <#[R3 + 17]> */
		/* 820A2434h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000011) );
		/* 820A2434h case    7:*/		return 0x820A2438;
		  /* 820A2438h */ case    8:  		/* b 8 */
		/* 820A2438h case    8:*/		return 0x820A2440;
		/* 820A2438h case    8:*/		return 0x820A243C;
	}
	return 0x820A243C;
} // Block from 820A2418h-820A243Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A243Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A243C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A243C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A243C);
		  /* 820A243Ch */ case    0:  		/* li R4, 0 */
		/* 820A243Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A243Ch case    0:*/		return 0x820A2440;
	}
	return 0x820A2440;
} // Block from 820A243Ch-820A2440h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A2440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2440);
		  /* 820A2440h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820A2440h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A2440h case    0:*/		return 0x820A2444;
		  /* 820A2444h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A2444h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A2454;  }
		/* 820A2444h case    1:*/		return 0x820A2448;
		  /* 820A2448h */ case    2:  		/* lis R3, -32761 */
		/* 820A2448h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A2448h case    2:*/		return 0x820A244C;
		  /* 820A244Ch */ case    3:  		/* ori R3, R3, 14 */
		/* 820A244Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A244Ch case    3:*/		return 0x820A2450;
		  /* 820A2450h */ case    4:  		/* b 12 */
		/* 820A2450h case    4:*/		return 0x820A245C;
		/* 820A2450h case    4:*/		return 0x820A2454;
	}
	return 0x820A2454;
} // Block from 820A2440h-820A2454h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A2454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2454);
		  /* 820A2454h */ case    0:  		/* mr R3, R30 */
		/* 820A2454h case    0:*/		regs.R3 = regs.R30;
		/* 820A2454h case    0:*/		return 0x820A2458;
		  /* 820A2458h */ case    1:  		/* bl -352 */
		/* 820A2458h case    1:*/		regs.LR = 0x820A245C; return 0x820A22F8;
		/* 820A2458h case    1:*/		return 0x820A245C;
	}
	return 0x820A245C;
} // Block from 820A2454h-820A245Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A245Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A245C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A245C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A245C);
		  /* 820A245Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820A245Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A245Ch case    0:*/		return 0x820A2460;
		  /* 820A2460h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A2460h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A2460h case    1:*/		return 0x820A2464;
		  /* 820A2464h */ case    2:  		/* mtspr LR, R12 */
		/* 820A2464h case    2:*/		regs.LR = regs.R12;
		/* 820A2464h case    2:*/		return 0x820A2468;
		  /* 820A2468h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820A2468h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A2468h case    3:*/		return 0x820A246C;
		  /* 820A246Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820A246Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A246Ch case    4:*/		return 0x820A2470;
		  /* 820A2470h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820A2470h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A2470h case    5:*/		return 0x820A2474;
	}
	return 0x820A2474;
} // Block from 820A245Ch-820A2474h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A2474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2474);
		  /* 820A2474h */ case    0:  		/* nop */
		/* 820A2474h case    0:*/		cpu::op::nop();
		/* 820A2474h case    0:*/		return 0x820A2478;
	}
	return 0x820A2478;
} // Block from 820A2474h-820A2478h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A2478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2478);
		  /* 820A2478h */ case    0:  		/* mfspr R12, LR */
		/* 820A2478h case    0:*/		regs.R12 = regs.LR;
		/* 820A2478h case    0:*/		return 0x820A247C;
		  /* 820A247Ch */ case    1:  		/* bl -70180 */
		/* 820A247Ch case    1:*/		regs.LR = 0x820A2480; return 0x82091258;
		/* 820A247Ch case    1:*/		return 0x820A2480;
		  /* 820A2480h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820A2480h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820A2480h case    2:*/		return 0x820A2484;
		  /* 820A2484h */ case    3:  		/* mr R28, R3 */
		/* 820A2484h case    3:*/		regs.R28 = regs.R3;
		/* 820A2484h case    3:*/		return 0x820A2488;
		  /* 820A2488h */ case    4:  		/* mr R30, R4 */
		/* 820A2488h case    4:*/		regs.R30 = regs.R4;
		/* 820A2488h case    4:*/		return 0x820A248C;
		  /* 820A248Ch */ case    5:  		/* lis R4, 9345 */
		/* 820A248Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A248Ch case    5:*/		return 0x820A2490;
		  /* 820A2490h */ case    6:  		/* li R3, 20 */
		/* 820A2490h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A2490h case    6:*/		return 0x820A2494;
		  /* 820A2494h */ case    7:  		/* mr R29, R5 */
		/* 820A2494h case    7:*/		regs.R29 = regs.R5;
		/* 820A2494h case    7:*/		return 0x820A2498;
		  /* 820A2498h */ case    8:  		/* bl -107160 */
		/* 820A2498h case    8:*/		regs.LR = 0x820A249C; return 0x82088200;
		/* 820A2498h case    8:*/		return 0x820A249C;
		  /* 820A249Ch */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820A249Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A249Ch case    9:*/		return 0x820A24A0;
		  /* 820A24A0h */ case   10:  		/* li R31, 0 */
		/* 820A24A0h case   10:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820A24A0h case   10:*/		return 0x820A24A4;
		  /* 820A24A4h */ case   11:  		/* bc 12, CR0_EQ, 36 */
		/* 820A24A4h case   11:*/		if ( regs.CR[0].eq ) { return 0x820A24C8;  }
		/* 820A24A4h case   11:*/		return 0x820A24A8;
		  /* 820A24A8h */ case   12:  		/* stw R30, <#[R3]> */
		/* 820A24A8h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 820A24A8h case   12:*/		return 0x820A24AC;
		  /* 820A24ACh */ case   13:  		/* mr R30, R3 */
		/* 820A24ACh case   13:*/		regs.R30 = regs.R3;
		/* 820A24ACh case   13:*/		return 0x820A24B0;
		  /* 820A24B0h */ case   14:  		/* stw R31, <#[R3 + 4]> */
		/* 820A24B0h case   14:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000004) );
		/* 820A24B0h case   14:*/		return 0x820A24B4;
		  /* 820A24B4h */ case   15:  		/* stw R31, <#[R3 + 8]> */
		/* 820A24B4h case   15:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000008) );
		/* 820A24B4h case   15:*/		return 0x820A24B8;
		  /* 820A24B8h */ case   16:  		/* stw R31, <#[R3 + 12]> */
		/* 820A24B8h case   16:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A24B8h case   16:*/		return 0x820A24BC;
		  /* 820A24BCh */ case   17:  		/* stb R31, <#[R3 + 16]> */
		/* 820A24BCh case   17:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R3 + 0x00000010) );
		/* 820A24BCh case   17:*/		return 0x820A24C0;
	}
	return 0x820A24C0;
} // Block from 820A2478h-820A24C0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820A24C0h
// Function '?DoIf@CPreProcessor@D3DXShader@@IAAJH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A24C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A24C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A24C0);
		  /* 820A24C0h */ case    0:  		/* stb R31, <#[R3 + 17]> */
		/* 820A24C0h case    0:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R3 + 0x00000011) );
		/* 820A24C0h case    0:*/		return 0x820A24C4;
		  /* 820A24C4h */ case    1:  		/* b 8 */
		/* 820A24C4h case    1:*/		return 0x820A24CC;
		/* 820A24C4h case    1:*/		return 0x820A24C8;
	}
	return 0x820A24C8;
} // Block from 820A24C0h-820A24C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A24C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A24C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A24C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A24C8);
		  /* 820A24C8h */ case    0:  		/* mr R30, R31 */
		/* 820A24C8h case    0:*/		regs.R30 = regs.R31;
		/* 820A24C8h case    0:*/		return 0x820A24CC;
	}
	return 0x820A24CC;
} // Block from 820A24C8h-820A24CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A24CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A24CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A24CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A24CC);
		  /* 820A24CCh */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820A24CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820A24CCh case    0:*/		return 0x820A24D0;
		  /* 820A24D0h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A24D0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A24E0;  }
		/* 820A24D0h case    1:*/		return 0x820A24D4;
		  /* 820A24D4h */ case    2:  		/* lis R3, -32761 */
		/* 820A24D4h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A24D4h case    2:*/		return 0x820A24D8;
		  /* 820A24D8h */ case    3:  		/* ori R3, R3, 14 */
		/* 820A24D8h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A24D8h case    3:*/		return 0x820A24DC;
		  /* 820A24DCh */ case    4:  		/* b 88 */
		/* 820A24DCh case    4:*/		return 0x820A2534;
		/* 820A24DCh case    4:*/		return 0x820A24E0;
	}
	return 0x820A24E0;
} // Block from 820A24CCh-820A24E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A24E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A24E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A24E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A24E0);
		  /* 820A24E0h */ case    0:  		/* li R11, 2 */
		/* 820A24E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820A24E0h case    0:*/		return 0x820A24E4;
		  /* 820A24E4h */ case    1:  		/* stw R29, <#[R1 + 88]> */
		/* 820A24E4h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000058) );
		/* 820A24E4h case    1:*/		return 0x820A24E8;
		  /* 820A24E8h */ case    2:  		/* li R3, 56 */
		/* 820A24E8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A24E8h case    2:*/		return 0x820A24EC;
		  /* 820A24ECh */ case    3:  		/* stw R11, <#[R1 + 80]> */
		/* 820A24ECh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A24ECh case    3:*/		return 0x820A24F0;
		  /* 820A24F0h */ case    4:  		/* bl 159032 */
		/* 820A24F0h case    4:*/		regs.LR = 0x820A24F4; return 0x820C9228;
		/* 820A24F0h case    4:*/		return 0x820A24F4;
		  /* 820A24F4h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820A24F4h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A24F4h case    5:*/		return 0x820A24F8;
		  /* 820A24F8h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820A24F8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A2508;  }
		/* 820A24F8h case    6:*/		return 0x820A24FC;
		  /* 820A24FCh */ case    7:  		/* addi R4, R1, 80 */
		/* 820A24FCh case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820A24FCh case    7:*/		return 0x820A2500;
		  /* 820A2500h */ case    8:  		/* bl 160592 */
		/* 820A2500h case    8:*/		regs.LR = 0x820A2504; return 0x820C9850;
		/* 820A2500h case    8:*/		return 0x820A2504;
		  /* 820A2504h */ case    9:  		/* b 8 */
		/* 820A2504h case    9:*/		return 0x820A250C;
		/* 820A2504h case    9:*/		return 0x820A2508;
	}
	return 0x820A2508;
} // Block from 820A24E0h-820A2508h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A2508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2508);
		  /* 820A2508h */ case    0:  		/* mr R3, R31 */
		/* 820A2508h case    0:*/		regs.R3 = regs.R31;
		/* 820A2508h case    0:*/		return 0x820A250C;
	}
	return 0x820A250C;
} // Block from 820A2508h-820A250Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A250Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A250C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A250C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A250C);
		  /* 820A250Ch */ case    0:  		/* stw R3, <#[R30 + 8]> */
		/* 820A250Ch case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820A250Ch case    0:*/		return 0x820A2510;
		  /* 820A2510h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A2510h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A2510h case    1:*/		return 0x820A2514;
		  /* 820A2514h */ case    2:  		/* bc 4, CR6_EQ, 20 */
		/* 820A2514h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A2528;  }
		/* 820A2514h case    2:*/		return 0x820A2518;
		  /* 820A2518h */ case    3:  		/* li R4, 1 */
		/* 820A2518h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A2518h case    3:*/		return 0x820A251C;
		  /* 820A251Ch */ case    4:  		/* mr R3, R30 */
		/* 820A251Ch case    4:*/		regs.R3 = regs.R30;
		/* 820A251Ch case    4:*/		return 0x820A2520;
		  /* 820A2520h */ case    5:  		/* bl -5656 */
		/* 820A2520h case    5:*/		regs.LR = 0x820A2524; return 0x820A0F08;
		/* 820A2520h case    5:*/		return 0x820A2524;
		  /* 820A2524h */ case    6:  		/* b -80 */
		/* 820A2524h case    6:*/		return 0x820A24D4;
		/* 820A2524h case    6:*/		return 0x820A2528;
	}
	return 0x820A2528;
} // Block from 820A250Ch-820A2528h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A2528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2528);
		  /* 820A2528h */ case    0:  		/* mr R4, R30 */
		/* 820A2528h case    0:*/		regs.R4 = regs.R30;
		/* 820A2528h case    0:*/		return 0x820A252C;
		  /* 820A252Ch */ case    1:  		/* mr R3, R28 */
		/* 820A252Ch case    1:*/		regs.R3 = regs.R28;
		/* 820A252Ch case    1:*/		return 0x820A2530;
		  /* 820A2530h */ case    2:  		/* bl -568 */
		/* 820A2530h case    2:*/		regs.LR = 0x820A2534; return 0x820A22F8;
		/* 820A2530h case    2:*/		return 0x820A2534;
	}
	return 0x820A2534;
} // Block from 820A2528h-820A2534h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A2534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2534);
		  /* 820A2534h */ case    0:  		/* addi R1, R1, 160 */
		/* 820A2534h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820A2534h case    0:*/		return 0x820A2538;
		  /* 820A2538h */ case    1:  		/* b -70288 */
		/* 820A2538h case    1:*/		return 0x820912A8;
		/* 820A2538h case    1:*/		return 0x820A253C;
		  /* 820A253Ch */ case    2:  		/* nop */
		/* 820A253Ch case    2:*/		cpu::op::nop();
		/* 820A253Ch case    2:*/		return 0x820A2540;
	}
	return 0x820A2540;
} // Block from 820A2534h-820A2540h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A2540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2540);
		  /* 820A2540h */ case    0:  		/* mfspr R12, LR */
		/* 820A2540h case    0:*/		regs.R12 = regs.LR;
		/* 820A2540h case    0:*/		return 0x820A2544;
		  /* 820A2544h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A2544h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A2544h case    1:*/		return 0x820A2548;
		  /* 820A2548h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A2548h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A2548h case    2:*/		return 0x820A254C;
		  /* 820A254Ch */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A254Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A254Ch case    3:*/		return 0x820A2550;
		  /* 820A2550h */ case    4:  		/* lis R11, -32255 */
		/* 820A2550h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A2550h case    4:*/		return 0x820A2554;
		  /* 820A2554h */ case    5:  		/* mr R31, R3 */
		/* 820A2554h case    5:*/		regs.R31 = regs.R3;
		/* 820A2554h case    5:*/		return 0x820A2558;
		  /* 820A2558h */ case    6:  		/* mr R10, R4 */
		/* 820A2558h case    6:*/		regs.R10 = regs.R4;
		/* 820A2558h case    6:*/		return 0x820A255C;
		  /* 820A255Ch */ case    7:  		/* addi R11, R11, -10484 */
		/* 820A255Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFD70C);
		/* 820A255Ch case    7:*/		return 0x820A2560;
		  /* 820A2560h */ case    8:  		/* lbz R9, <#[R11]> */
		/* 820A2560h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A2560h case    8:*/		return 0x820A2564;
		  /* 820A2564h */ case    9:  		/* lbz R8, <#[R10]> */
		/* 820A2564h case    9:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A2564h case    9:*/		return 0x820A2568;
		  /* 820A2568h */ case   10:  		/* cmpwi CR0, R9, 0 */
		/* 820A2568h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A2568h case   10:*/		return 0x820A256C;
		  /* 820A256Ch */ case   11:  		/* subf R9, R8, R9 */
		/* 820A256Ch case   11:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A256Ch case   11:*/		return 0x820A2570;
		  /* 820A2570h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 820A2570h case   12:*/		if ( regs.CR[0].eq ) { return 0x820A2584;  }
		/* 820A2570h case   12:*/		return 0x820A2574;
		  /* 820A2574h */ case   13:  		/* addi R11, R11, 1 */
		/* 820A2574h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A2574h case   13:*/		return 0x820A2578;
	}
	return 0x820A2578;
} // Block from 820A2540h-820A2578h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A2578h
// Function '?DoEndif@CPreProcessor@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2578);
		  /* 820A2578h */ case    0:  		/* addi R10, R10, 1 */
		/* 820A2578h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A2578h case    0:*/		return 0x820A257C;
		  /* 820A257Ch */ case    1:  		/* cmpwi CR6, R9, 0 */
		/* 820A257Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A257Ch case    1:*/		return 0x820A2580;
		  /* 820A2580h */ case    2:  		/* bc 12, CR6_EQ, -32 */
		/* 820A2580h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A2560;  }
		/* 820A2580h case    2:*/		return 0x820A2584;
	}
	return 0x820A2584;
} // Block from 820A2578h-820A2584h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A2584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2584);
		  /* 820A2584h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A2584h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A2584h case    0:*/		return 0x820A2588;
		  /* 820A2588h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A2588h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A2594;  }
		/* 820A2588h case    1:*/		return 0x820A258C;
		  /* 820A258Ch */ case    2:  		/* lwz R3, <#[R31 + 2240]> */
		/* 820A258Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000008C0) );
		/* 820A258Ch case    2:*/		return 0x820A2590;
		  /* 820A2590h */ case    3:  		/* b 152 */
		/* 820A2590h case    3:*/		return 0x820A2628;
		/* 820A2590h case    3:*/		return 0x820A2594;
	}
	return 0x820A2594;
} // Block from 820A2584h-820A2594h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A2594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2594);
		  /* 820A2594h */ case    0:  		/* addi R6, R1, 84 */
		/* 820A2594h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820A2594h case    0:*/		return 0x820A2598;
		  /* 820A2598h */ case    1:  		/* addi R5, R1, 80 */
		/* 820A2598h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820A2598h case    1:*/		return 0x820A259C;
		  /* 820A259Ch */ case    2:  		/* mr R3, R31 */
		/* 820A259Ch case    2:*/		regs.R3 = regs.R31;
		/* 820A259Ch case    2:*/		return 0x820A25A0;
		  /* 820A25A0h */ case    3:  		/* bl -6360 */
		/* 820A25A0h case    3:*/		regs.LR = 0x820A25A4; return 0x820A0CC8;
		/* 820A25A0h case    3:*/		return 0x820A25A4;
		  /* 820A25A4h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820A25A4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A25A4h case    4:*/		return 0x820A25A8;
		  /* 820A25A8h */ case    5:  		/* bc 12, CR0_EQ, 124 */
		/* 820A25A8h case    5:*/		if ( regs.CR[0].eq ) { return 0x820A2624;  }
		/* 820A25A8h case    5:*/		return 0x820A25AC;
		  /* 820A25ACh */ case    6:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A25ACh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A25ACh case    6:*/		return 0x820A25B0;
		  /* 820A25B0h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820A25B0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A25B0h case    7:*/		return 0x820A25B4;
		  /* 820A25B4h */ case    8:  		/* bc 12, CR6_EQ, 36 */
		/* 820A25B4h case    8:*/		if ( regs.CR[6].eq ) { return 0x820A25D8;  }
		/* 820A25B4h case    8:*/		return 0x820A25B8;
		  /* 820A25B8h */ case    9:  		/* lis R11, -32255 */
		/* 820A25B8h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A25B8h case    9:*/		return 0x820A25BC;
		  /* 820A25BCh */ case   10:  		/* li R5, 1517 */
		/* 820A25BCh case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x5ED);
		/* 820A25BCh case   10:*/		return 0x820A25C0;
		  /* 820A25C0h */ case   11:  		/* addi R6, R11, -10552 */
		/* 820A25C0h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD6C8);
		/* 820A25C0h case   11:*/		return 0x820A25C4;
		  /* 820A25C4h */ case   12:  		/* addi R4, R31, 2216 */
		/* 820A25C4h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x8A8);
		/* 820A25C4h case   12:*/		return 0x820A25C8;
		  /* 820A25C8h */ case   13:  		/* addi R3, R31, 24 */
		/* 820A25C8h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A25C8h case   13:*/		return 0x820A25CC;
		  /* 820A25CCh */ case   14:  		/* bl 19396 */
		/* 820A25CCh case   14:*/		regs.LR = 0x820A25D0; return 0x820A7190;
		/* 820A25CCh case   14:*/		return 0x820A25D0;
		  /* 820A25D0h */ case   15:  		/* li R3, 1 */
		/* 820A25D0h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820A25D0h case   15:*/		return 0x820A25D4;
		  /* 820A25D4h */ case   16:  		/* b 84 */
		/* 820A25D4h case   16:*/		return 0x820A2628;
		/* 820A25D4h case   16:*/		return 0x820A25D8;
	}
	return 0x820A25D8;
} // Block from 820A2594h-820A25D8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A25D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A25D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A25D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A25D8);
		  /* 820A25D8h */ case    0:  		/* lwz R10, <#[R1 + 84]> */
		/* 820A25D8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 820A25D8h case    0:*/		return 0x820A25DC;
		  /* 820A25DCh */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820A25DCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A25DCh case    1:*/		return 0x820A25E0;
		  /* 820A25E0h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 820A25E0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A260C;  }
		/* 820A25E0h case    2:*/		return 0x820A25E4;
		  /* 820A25E4h */ case    3:  		/* lwz R11, <#[R10 + 12]> */
		/* 820A25E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820A25E4h case    3:*/		return 0x820A25E8;
		  /* 820A25E8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820A25E8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A25E8h case    4:*/		return 0x820A25EC;
		  /* 820A25ECh */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 820A25ECh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A260C;  }
		/* 820A25ECh case    5:*/		return 0x820A25F0;
		  /* 820A25F0h */ case    6:  		/* lwz R11, <#[R10 + 16]> */
		/* 820A25F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820A25F0h case    6:*/		return 0x820A25F4;
		  /* 820A25F4h */ case    7:  		/* cmpwi CR6, R11, 2 */
		/* 820A25F4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820A25F4h case    7:*/		return 0x820A25F8;
		  /* 820A25F8h */ case    8:  		/* bc 12, CR6_LT, 20 */
		/* 820A25F8h case    8:*/		if ( regs.CR[6].lt ) { return 0x820A260C;  }
		/* 820A25F8h case    8:*/		return 0x820A25FC;
		  /* 820A25FCh */ case    9:  		/* cmpwi CR6, R11, 4 */
		/* 820A25FCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 820A25FCh case    9:*/		return 0x820A2600;
	}
	return 0x820A2600;
} // Block from 820A25D8h-820A2600h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A2600h
// Function '?DoPragmaRuleDisable@CPreProcessor@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2600);
		  /* 820A2600h */ case    0:  		/* bc 12, CR6_GT, 12 */
		/* 820A2600h case    0:*/		if ( regs.CR[6].gt ) { return 0x820A260C;  }
		/* 820A2600h case    0:*/		return 0x820A2604;
		  /* 820A2604h */ case    1:  		/* lwz R3, <#[R10 + 24]> */
		/* 820A2604h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000018) );
		/* 820A2604h case    1:*/		return 0x820A2608;
		  /* 820A2608h */ case    2:  		/* b 32 */
		/* 820A2608h case    2:*/		return 0x820A2628;
		/* 820A2608h case    2:*/		return 0x820A260C;
	}
	return 0x820A260C;
} // Block from 820A2600h-820A260Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A260Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A260C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A260C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A260C);
		  /* 820A260Ch */ case    0:  		/* lis R11, -32255 */
		/* 820A260Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A260Ch case    0:*/		return 0x820A2610;
		  /* 820A2610h */ case    1:  		/* li R5, 1518 */
		/* 820A2610h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x5EE);
		/* 820A2610h case    1:*/		return 0x820A2614;
		  /* 820A2614h */ case    2:  		/* addi R6, R11, -10748 */
		/* 820A2614h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD604);
		/* 820A2614h case    2:*/		return 0x820A2618;
		  /* 820A2618h */ case    3:  		/* addi R4, R31, 2216 */
		/* 820A2618h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x8A8);
		/* 820A2618h case    3:*/		return 0x820A261C;
		  /* 820A261Ch */ case    4:  		/* addi R3, R31, 24 */
		/* 820A261Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A261Ch case    4:*/		return 0x820A2620;
		  /* 820A2620h */ case    5:  		/* bl 19312 */
		/* 820A2620h case    5:*/		regs.LR = 0x820A2624; return 0x820A7190;
		/* 820A2620h case    5:*/		return 0x820A2624;
	}
	return 0x820A2624;
} // Block from 820A260Ch-820A2624h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A2624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2624);
		  /* 820A2624h */ case    0:  		/* li R3, 0 */
		/* 820A2624h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A2624h case    0:*/		return 0x820A2628;
	}
	return 0x820A2628;
} // Block from 820A2624h-820A2628h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A2628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2628);
		  /* 820A2628h */ case    0:  		/* addi R1, R1, 112 */
		/* 820A2628h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A2628h case    0:*/		return 0x820A262C;
		  /* 820A262Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A262Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A262Ch case    1:*/		return 0x820A2630;
		  /* 820A2630h */ case    2:  		/* mtspr LR, R12 */
		/* 820A2630h case    2:*/		regs.LR = regs.R12;
		/* 820A2630h case    2:*/		return 0x820A2634;
		  /* 820A2634h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A2634h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A2634h case    3:*/		return 0x820A2638;
		  /* 820A2638h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A2638h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A2638h case    4:*/		return 0x820A263C;
	}
	return 0x820A263C;
} // Block from 820A2628h-820A263Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A263Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A263C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A263C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A263C);
		  /* 820A263Ch */ case    0:  		/* nop */
		/* 820A263Ch case    0:*/		cpu::op::nop();
		/* 820A263Ch case    0:*/		return 0x820A2640;
	}
	return 0x820A2640;
} // Block from 820A263Ch-820A2640h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A2640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2640);
		  /* 820A2640h */ case    0:  		/* mfspr R12, LR */
		/* 820A2640h case    0:*/		regs.R12 = regs.LR;
		/* 820A2640h case    0:*/		return 0x820A2644;
		  /* 820A2644h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A2644h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A2644h case    1:*/		return 0x820A2648;
		  /* 820A2648h */ case    2:  		/* std R6, <#[R1 + 40]> */
		/* 820A2648h case    2:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820A2648h case    2:*/		return 0x820A264C;
		  /* 820A264Ch */ case    3:  		/* std R7, <#[R1 + 48]> */
		/* 820A264Ch case    3:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820A264Ch case    3:*/		return 0x820A2650;
		  /* 820A2650h */ case    4:  		/* std R8, <#[R1 + 56]> */
		/* 820A2650h case    4:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820A2650h case    4:*/		return 0x820A2654;
		  /* 820A2654h */ case    5:  		/* std R9, <#[R1 + 64]> */
		/* 820A2654h case    5:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820A2654h case    5:*/		return 0x820A2658;
		  /* 820A2658h */ case    6:  		/* std R10, <#[R1 + 72]> */
		/* 820A2658h case    6:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820A2658h case    6:*/		return 0x820A265C;
		  /* 820A265Ch */ case    7:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A265Ch case    7:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A265Ch case    7:*/		return 0x820A2660;
		  /* 820A2660h */ case    8:  		/* lis R11, 32767 */
		/* 820A2660h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 820A2660h case    8:*/		return 0x820A2664;
		  /* 820A2664h */ case    9:  		/* stw R5, <#[R1 + 132]> */
		/* 820A2664h case    9:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000084) );
		/* 820A2664h case    9:*/		return 0x820A2668;
		  /* 820A2668h */ case   10:  		/* ori R11, R11, 65535 */
		/* 820A2668h case   10:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 820A2668h case   10:*/		return 0x820A266C;
		  /* 820A266Ch */ case   11:  		/* cmplw CR6, R4, R11 */
		/* 820A266Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820A266Ch case   11:*/		return 0x820A2670;
		  /* 820A2670h */ case   12:  		/* bc 4, CR6_GT, 16 */
		/* 820A2670h case   12:*/		if ( !regs.CR[6].gt ) { return 0x820A2680;  }
		/* 820A2670h case   12:*/		return 0x820A2674;
		  /* 820A2674h */ case   13:  		/* lis R3, -32761 */
		/* 820A2674h case   13:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A2674h case   13:*/		return 0x820A2678;
		  /* 820A2678h */ case   14:  		/* ori R3, R3, 87 */
		/* 820A2678h case   14:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x57);
		/* 820A2678h case   14:*/		return 0x820A267C;
		  /* 820A267Ch */ case   15:  		/* b 24 */
		/* 820A267Ch case   15:*/		return 0x820A2694;
		/* 820A267Ch case   15:*/		return 0x820A2680;
	}
	return 0x820A2680;
} // Block from 820A2640h-820A2680h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A2680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2680);
		  /* 820A2680h */ case    0:  		/* addi R11, R1, 80 */
		/* 820A2680h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A2680h case    0:*/		return 0x820A2684;
		  /* 820A2684h */ case    1:  		/* addi R10, R1, 136 */
		/* 820A2684h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x88);
		/* 820A2684h case    1:*/		return 0x820A2688;
		  /* 820A2688h */ case    2:  		/* stw R10, <#[R11]> */
		/* 820A2688h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A2688h case    2:*/		return 0x820A268C;
		  /* 820A268Ch */ case    3:  		/* lwz R6, <#[R1 + 80]> */
		/* 820A268Ch case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820A268Ch case    3:*/		return 0x820A2690;
		  /* 820A2690h */ case    4:  		/* bl -14248 */
		/* 820A2690h case    4:*/		regs.LR = 0x820A2694; return 0x8209EEE8;
		/* 820A2690h case    4:*/		return 0x820A2694;
	}
	return 0x820A2694;
} // Block from 820A2680h-820A2694h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A2694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2694);
		  /* 820A2694h */ case    0:  		/* addi R1, R1, 96 */
		/* 820A2694h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A2694h case    0:*/		return 0x820A2698;
		  /* 820A2698h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A2698h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A2698h case    1:*/		return 0x820A269C;
		  /* 820A269Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820A269Ch case    2:*/		regs.LR = regs.R12;
		/* 820A269Ch case    2:*/		return 0x820A26A0;
		  /* 820A26A0h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820A26A0h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A26A0h case    3:*/		return 0x820A26A4;
	}
	return 0x820A26A4;
} // Block from 820A2694h-820A26A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A26A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A26A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A26A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A26A4);
		  /* 820A26A4h */ case    0:  		/* nop */
		/* 820A26A4h case    0:*/		cpu::op::nop();
		/* 820A26A4h case    0:*/		return 0x820A26A8;
	}
	return 0x820A26A8;
} // Block from 820A26A4h-820A26A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A26A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A26A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A26A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A26A8);
		  /* 820A26A8h */ case    0:  		/* mfspr R12, LR */
		/* 820A26A8h case    0:*/		regs.R12 = regs.LR;
		/* 820A26A8h case    0:*/		return 0x820A26AC;
		  /* 820A26ACh */ case    1:  		/* bl -70744 */
		/* 820A26ACh case    1:*/		regs.LR = 0x820A26B0; return 0x82091254;
		/* 820A26ACh case    1:*/		return 0x820A26B0;
		  /* 820A26B0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820A26B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820A26B0h case    2:*/		return 0x820A26B4;
		  /* 820A26B4h */ case    3:  		/* lwz R11, <#[R3 + 100]> */
		/* 820A26B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000064) );
		/* 820A26B4h case    3:*/		return 0x820A26B8;
		  /* 820A26B8h */ case    4:  		/* mr R31, R3 */
		/* 820A26B8h case    4:*/		regs.R31 = regs.R3;
		/* 820A26B8h case    4:*/		return 0x820A26BC;
		  /* 820A26BCh */ case    5:  		/* mr R30, R4 */
		/* 820A26BCh case    5:*/		regs.R30 = regs.R4;
		/* 820A26BCh case    5:*/		return 0x820A26C0;
		  /* 820A26C0h */ case    6:  		/* mr R28, R5 */
		/* 820A26C0h case    6:*/		regs.R28 = regs.R5;
		/* 820A26C0h case    6:*/		return 0x820A26C4;
		  /* 820A26C4h */ case    7:  		/* mr R27, R6 */
		/* 820A26C4h case    7:*/		regs.R27 = regs.R6;
		/* 820A26C4h case    7:*/		return 0x820A26C8;
		  /* 820A26C8h */ case    8:  		/* mr R29, R7 */
		/* 820A26C8h case    8:*/		regs.R29 = regs.R7;
		/* 820A26C8h case    8:*/		return 0x820A26CC;
		  /* 820A26CCh */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820A26CCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A26CCh case    9:*/		return 0x820A26D0;
		  /* 820A26D0h */ case   10:  		/* bc 12, CR6_EQ, 64 */
		/* 820A26D0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A2710;  }
		/* 820A26D0h case   10:*/		return 0x820A26D4;
		  /* 820A26D4h */ case   11:  		/* lis R10, 32767 */
		/* 820A26D4h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FFF);
		/* 820A26D4h case   11:*/		return 0x820A26D8;
		  /* 820A26D8h */ case   12:  		/* li R3, 0 */
		/* 820A26D8h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A26D8h case   12:*/		return 0x820A26DC;
		  /* 820A26DCh */ case   13:  		/* ori R9, R10, 65535 */
		/* 820A26DCh case   13:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R10,0xFFFF);
		/* 820A26DCh case   13:*/		return 0x820A26E0;
		  /* 820A26E0h */ case   14:  		/* mr R10, R9 */
		/* 820A26E0h case   14:*/		regs.R10 = regs.R9;
		/* 820A26E0h case   14:*/		return 0x820A26E4;
		  /* 820A26E4h */ case   15:  		/* lbz R8, <#[R11]> */
		/* 820A26E4h case   15:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A26E4h case   15:*/		return 0x820A26E8;
		  /* 820A26E8h */ case   16:  		/* cmplwi CR0, R8, 0 */
		/* 820A26E8h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R8,0x00000000);
		/* 820A26E8h case   16:*/		return 0x820A26EC;
		  /* 820A26ECh */ case   17:  		/* bc 12, CR0_EQ, 16 */
		/* 820A26ECh case   17:*/		if ( regs.CR[0].eq ) { return 0x820A26FC;  }
		/* 820A26ECh case   17:*/		return 0x820A26F0;
		  /* 820A26F0h */ case   18:  		/* addic. R10, R10, -1 */
		/* 820A26F0h case   18:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820A26F0h case   18:*/		return 0x820A26F4;
		  /* 820A26F4h */ case   19:  		/* addi R11, R11, 1 */
		/* 820A26F4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A26F4h case   19:*/		return 0x820A26F8;
		  /* 820A26F8h */ case   20:  		/* bc 4, CR0_EQ, -20 */
		/* 820A26F8h case   20:*/		if ( !regs.CR[0].eq ) { return 0x820A26E4;  }
		/* 820A26F8h case   20:*/		return 0x820A26FC;
	}
	return 0x820A26FC;
} // Block from 820A26A8h-820A26FCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 820A26FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A26FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A26FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A26FC);
		  /* 820A26FCh */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820A26FCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A26FCh case    0:*/		return 0x820A2700;
		  /* 820A2700h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820A2700h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A2710;  }
		/* 820A2700h case    1:*/		return 0x820A2704;
		  /* 820A2704h */ case    2:  		/* subf R11, R10, R9 */
		/* 820A2704h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 820A2704h case    2:*/		return 0x820A2708;
		  /* 820A2708h */ case    3:  		/* stw R11, <#[R1 + 96]> */
		/* 820A2708h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820A2708h case    3:*/		return 0x820A270C;
		  /* 820A270Ch */ case    4:  		/* b 12 */
		/* 820A270Ch case    4:*/		return 0x820A2718;
		/* 820A270Ch case    4:*/		return 0x820A2710;
	}
	return 0x820A2710;
} // Block from 820A26FCh-820A2710h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A2710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2710);
		  /* 820A2710h */ case    0:  		/* lis R3, -32761 */
		/* 820A2710h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A2710h case    0:*/		return 0x820A2714;
		  /* 820A2714h */ case    1:  		/* ori R3, R3, 87 */
		/* 820A2714h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x57);
		/* 820A2714h case    1:*/		return 0x820A2718;
	}
	return 0x820A2718;
} // Block from 820A2710h-820A2718h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A2718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2718);
		  /* 820A2718h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820A2718h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820A2718h case    0:*/		return 0x820A271C;
		  /* 820A271Ch */ case    1:  		/* bc 12, CR6_LT, 116 */
		/* 820A271Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x820A2790;  }
		/* 820A271Ch case    1:*/		return 0x820A2720;
		  /* 820A2720h */ case    2:  		/* lwz R11, <#[R1 + 96]> */
		/* 820A2720h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820A2720h case    2:*/		return 0x820A2724;
		  /* 820A2724h */ case    3:  		/* li R5, 1 */
		/* 820A2724h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A2724h case    3:*/		return 0x820A2728;
		  /* 820A2728h */ case    4:  		/* mr R3, R30 */
		/* 820A2728h case    4:*/		regs.R3 = regs.R30;
		/* 820A2728h case    4:*/		return 0x820A272C;
		  /* 820A272Ch */ case    5:  		/* lwz R4, <#[R31 + 124]> */
		/* 820A272Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000007C) );
		/* 820A272Ch case    5:*/		return 0x820A2730;
		  /* 820A2730h */ case    6:  		/* stw R11, <#[R31 + 112]> */
		/* 820A2730h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820A2730h case    6:*/		return 0x820A2734;
		  /* 820A2734h */ case    7:  		/* bl 158124 */
		/* 820A2734h case    7:*/		regs.LR = 0x820A2738; return 0x820C90E0;
		/* 820A2734h case    7:*/		return 0x820A2738;
		  /* 820A2738h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 820A2738h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A2738h case    8:*/		return 0x820A273C;
		  /* 820A273Ch */ case    9:  		/* stw R3, <#[R31 + 120]> */
		/* 820A273Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000078) );
		/* 820A273Ch case    9:*/		return 0x820A2740;
	}
	return 0x820A2740;
} // Block from 820A2718h-820A2740h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A2740h
// Function '?DoPragmaMessage@CPreProcessor@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2740);
		  /* 820A2740h */ case    0:  		/* bc 4, CR0_EQ, 16 */
		/* 820A2740h case    0:*/		if ( !regs.CR[0].eq ) { return 0x820A2750;  }
		/* 820A2740h case    0:*/		return 0x820A2744;
		  /* 820A2744h */ case    1:  		/* lis R3, -32761 */
		/* 820A2744h case    1:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A2744h case    1:*/		return 0x820A2748;
		  /* 820A2748h */ case    2:  		/* ori R3, R3, 14 */
		/* 820A2748h case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A2748h case    2:*/		return 0x820A274C;
		  /* 820A274Ch */ case    3:  		/* b 68 */
		/* 820A274Ch case    3:*/		return 0x820A2790;
		/* 820A274Ch case    3:*/		return 0x820A2750;
	}
	return 0x820A2750;
} // Block from 820A2740h-820A2750h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A2750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2750);
		  /* 820A2750h */ case    0:  		/* lwz R5, <#[R31 + 124]> */
		/* 820A2750h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000007C) );
		/* 820A2750h case    0:*/		return 0x820A2754;
		  /* 820A2754h */ case    1:  		/* lwz R4, <#[R31 + 116]> */
		/* 820A2754h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000074) );
		/* 820A2754h case    1:*/		return 0x820A2758;
		  /* 820A2758h */ case    2:  		/* bl -69032 */
		/* 820A2758h case    2:*/		regs.LR = 0x820A275C; return 0x820919B0;
		/* 820A2758h case    2:*/		return 0x820A275C;
		  /* 820A275Ch */ case    3:  		/* mr R10, R28 */
		/* 820A275Ch case    3:*/		regs.R10 = regs.R28;
		/* 820A275Ch case    3:*/		return 0x820A2760;
		  /* 820A2760h */ case    4:  		/* lwz R7, <#[R31 + 100]> */
		/* 820A2760h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000064) );
		/* 820A2760h case    4:*/		return 0x820A2764;
		  /* 820A2764h */ case    5:  		/* mr R9, R30 */
		/* 820A2764h case    5:*/		regs.R9 = regs.R30;
		/* 820A2764h case    5:*/		return 0x820A2768;
		  /* 820A2768h */ case    6:  		/* lwz R5, <#[R31 + 124]> */
		/* 820A2768h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000007C) );
		/* 820A2768h case    6:*/		return 0x820A276C;
		  /* 820A276Ch */ case    7:  		/* li R8, 1 */
		/* 820A276Ch case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820A276Ch case    7:*/		return 0x820A2770;
		  /* 820A2770h */ case    8:  		/* lwz R4, <#[R31 + 120]> */
		/* 820A2770h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000078) );
		/* 820A2770h case    8:*/		return 0x820A2774;
		  /* 820A2774h */ case    9:  		/* mr R6, R29 */
		/* 820A2774h case    9:*/		regs.R6 = regs.R29;
		/* 820A2774h case    9:*/		return 0x820A2778;
		  /* 820A2778h */ case   10:  		/* stw R27, <#[R1 + 84]> */
		/* 820A2778h case   10:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 820A2778h case   10:*/		return 0x820A277C;
		  /* 820A277Ch */ case   11:  		/* mr R3, R31 */
		/* 820A277Ch case   11:*/		regs.R3 = regs.R31;
		/* 820A277Ch case   11:*/		return 0x820A2780;
		  /* 820A2780h */ case   12:  		/* bl 14400 */
		/* 820A2780h case   12:*/		regs.LR = 0x820A2784; return 0x820A5FC0;
		/* 820A2780h case   12:*/		return 0x820A2784;
		  /* 820A2784h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820A2784h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A2784h case   13:*/		return 0x820A2788;
		  /* 820A2788h */ case   14:  		/* bc 12, CR0_LT, 8 */
		/* 820A2788h case   14:*/		if ( regs.CR[0].lt ) { return 0x820A2790;  }
		/* 820A2788h case   14:*/		return 0x820A278C;
		  /* 820A278Ch */ case   15:  		/* stw R29, <#[R31 + 108]> */
		/* 820A278Ch case   15:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000006C) );
		/* 820A278Ch case   15:*/		return 0x820A2790;
	}
	return 0x820A2790;
} // Block from 820A2750h-820A2790h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A2790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2790);
		  /* 820A2790h */ case    0:  		/* addi R1, R1, 160 */
		/* 820A2790h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820A2790h case    0:*/		return 0x820A2794;
		  /* 820A2794h */ case    1:  		/* b -70896 */
		/* 820A2794h case    1:*/		return 0x820912A4;
		/* 820A2794h case    1:*/		return 0x820A2798;
	}
	return 0x820A2798;
} // Block from 820A2790h-820A2798h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A2798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2798);
		  /* 820A2798h */ case    0:  		/* mfspr R12, LR */
		/* 820A2798h case    0:*/		regs.R12 = regs.LR;
		/* 820A2798h case    0:*/		return 0x820A279C;
		  /* 820A279Ch */ case    1:  		/* bl -71000 */
		/* 820A279Ch case    1:*/		regs.LR = 0x820A27A0; return 0x82091244;
		/* 820A279Ch case    1:*/		return 0x820A27A0;
		  /* 820A27A0h */ case    2:  		/* stwu R1, <#[R1 - 976]> */
		/* 820A27A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFC30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFC30);
		/* 820A27A0h case    2:*/		return 0x820A27A4;
		  /* 820A27A4h */ case    3:  		/* mr R31, R3 */
		/* 820A27A4h case    3:*/		regs.R31 = regs.R3;
		/* 820A27A4h case    3:*/		return 0x820A27A8;
		  /* 820A27A8h */ case    4:  		/* stw R10, <#[R3 + 96]> */
		/* 820A27A8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000060) );
		/* 820A27A8h case    4:*/		return 0x820A27AC;
		  /* 820A27ACh */ case    5:  		/* mr R27, R4 */
		/* 820A27ACh case    5:*/		regs.R27 = regs.R4;
		/* 820A27ACh case    5:*/		return 0x820A27B0;
		  /* 820A27B0h */ case    6:  		/* mr R26, R5 */
		/* 820A27B0h case    6:*/		regs.R26 = regs.R5;
		/* 820A27B0h case    6:*/		return 0x820A27B4;
		  /* 820A27B4h */ case    7:  		/* mr R28, R6 */
		/* 820A27B4h case    7:*/		regs.R28 = regs.R6;
		/* 820A27B4h case    7:*/		return 0x820A27B8;
		  /* 820A27B8h */ case    8:  		/* mr R25, R7 */
		/* 820A27B8h case    8:*/		regs.R25 = regs.R7;
		/* 820A27B8h case    8:*/		return 0x820A27BC;
		  /* 820A27BCh */ case    9:  		/* mr R23, R8 */
		/* 820A27BCh case    9:*/		regs.R23 = regs.R8;
		/* 820A27BCh case    9:*/		return 0x820A27C0;
		  /* 820A27C0h */ case   10:  		/* mr R24, R9 */
		/* 820A27C0h case   10:*/		regs.R24 = regs.R9;
		/* 820A27C0h case   10:*/		return 0x820A27C4;
		  /* 820A27C4h */ case   11:  		/* cmpwi CR6, R5, 0 */
		/* 820A27C4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 820A27C4h case   11:*/		return 0x820A27C8;
		  /* 820A27C8h */ case   12:  		/* bc 12, CR6_EQ, 52 */
		/* 820A27C8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820A27FC;  }
		/* 820A27C8h case   12:*/		return 0x820A27CC;
		  /* 820A27CCh */ case   13:  		/* lis R3, 0 */
		/* 820A27CCh case   13:*/		cpu::op::lis<0>(regs,&regs.R3,0x0);
		/* 820A27CCh case   13:*/		return 0x820A27D0;
		  /* 820A27D0h */ case   14:  		/* mr R5, R4 */
		/* 820A27D0h case   14:*/		regs.R5 = regs.R4;
		/* 820A27D0h case   14:*/		return 0x820A27D4;
		  /* 820A27D4h */ case   15:  		/* li R10, 0 */
		/* 820A27D4h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A27D4h case   15:*/		return 0x820A27D8;
		  /* 820A27D8h */ case   16:  		/* li R9, 0 */
		/* 820A27D8h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820A27D8h case   16:*/		return 0x820A27DC;
		  /* 820A27DCh */ case   17:  		/* li R8, 260 */
		/* 820A27DCh case   17:*/		cpu::op::li<0>(regs,&regs.R8,0x104);
		/* 820A27DCh case   17:*/		return 0x820A27E0;
		  /* 820A27E0h */ case   18:  		/* addi R7, R1, 624 */
		/* 820A27E0h case   18:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x270);
		/* 820A27E0h case   18:*/		return 0x820A27E4;
		  /* 820A27E4h */ case   19:  		/* li R6, -1 */
		/* 820A27E4h case   19:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820A27E4h case   19:*/		return 0x820A27E8;
		  /* 820A27E8h */ case   20:  		/* li R4, 0 */
		/* 820A27E8h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A27E8h case   20:*/		return 0x820A27EC;
		  /* 820A27ECh */ case   21:  		/* ori R3, R3, 65001 */
		/* 820A27ECh case   21:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xFDE9);
		/* 820A27ECh case   21:*/		return 0x820A27F0;
		  /* 820A27F0h */ case   22:  		/* bl 1854712 */
		/* 820A27F0h case   22:*/		regs.LR = 0x820A27F4; return 0x822674E8;
		/* 820A27F0h case   22:*/		return 0x820A27F4;
		  /* 820A27F4h */ case   23:  		/* addi R30, R1, 624 */
		/* 820A27F4h case   23:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x270);
		/* 820A27F4h case   23:*/		return 0x820A27F8;
		  /* 820A27F8h */ case   24:  		/* b 8 */
		/* 820A27F8h case   24:*/		return 0x820A2800;
		/* 820A27F8h case   24:*/		return 0x820A27FC;
	}
	return 0x820A27FC;
} // Block from 820A2798h-820A27FCh (25 instructions)

//////////////////////////////////////////////////////
// Block at 820A27FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A27FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A27FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A27FC);
		  /* 820A27FCh */ case    0:  		/* mr R30, R27 */
		/* 820A27FCh case    0:*/		regs.R30 = regs.R27;
		/* 820A27FCh case    0:*/		return 0x820A2800;
	}
	return 0x820A2800;
} // Block from 820A27FCh-820A2800h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A2800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2800);
		  /* 820A2800h */ case    0:  		/* lwz R11, <#[R31 + 96]> */
		/* 820A2800h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 820A2800h case    0:*/		return 0x820A2804;
		  /* 820A2804h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A2804h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A2804h case    1:*/		return 0x820A2808;
		  /* 820A2808h */ case    2:  		/* bc 12, CR6_EQ, 324 */
		/* 820A2808h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A294C;  }
		/* 820A2808h case    2:*/		return 0x820A280C;
		  /* 820A280Ch */ case    3:  		/* mr R3, R30 */
		/* 820A280Ch case    3:*/		regs.R3 = regs.R30;
		/* 820A280Ch case    3:*/		return 0x820A2810;
		  /* 820A2810h */ case    4:  		/* bl 1856896 */
		/* 820A2810h case    4:*/		regs.LR = 0x820A2814; return 0x82267D90;
		/* 820A2810h case    4:*/		return 0x820A2814;
		  /* 820A2814h */ case    5:  		/* addi R29, R3, 1 */
		/* 820A2814h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R3,0x1);
		/* 820A2814h case    5:*/		return 0x820A2818;
		  /* 820A2818h */ case    6:  		/* li R5, 1 */
		/* 820A2818h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A2818h case    6:*/		return 0x820A281C;
		  /* 820A281Ch */ case    7:  		/* mr R3, R28 */
		/* 820A281Ch case    7:*/		regs.R3 = regs.R28;
		/* 820A281Ch case    7:*/		return 0x820A2820;
		  /* 820A2820h */ case    8:  		/* mr R4, R29 */
		/* 820A2820h case    8:*/		regs.R4 = regs.R29;
		/* 820A2820h case    8:*/		return 0x820A2824;
		  /* 820A2824h */ case    9:  		/* bl 157884 */
		/* 820A2824h case    9:*/		regs.LR = 0x820A2828; return 0x820C90E0;
		/* 820A2824h case    9:*/		return 0x820A2828;
		  /* 820A2828h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 820A2828h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A2828h case   10:*/		return 0x820A282C;
		  /* 820A282Ch */ case   11:  		/* stw R3, <#[R31 + 100]> */
		/* 820A282Ch case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000064) );
		/* 820A282Ch case   11:*/		return 0x820A2830;
		  /* 820A2830h */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 820A2830h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820A2840;  }
		/* 820A2830h case   12:*/		return 0x820A2834;
		  /* 820A2834h */ case   13:  		/* lis R3, -32761 */
		/* 820A2834h case   13:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A2834h case   13:*/		return 0x820A2838;
		  /* 820A2838h */ case   14:  		/* ori R3, R3, 14 */
		/* 820A2838h case   14:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A2838h case   14:*/		return 0x820A283C;
		  /* 820A283Ch */ case   15:  		/* b 428 */
		/* 820A283Ch case   15:*/		return 0x820A29E8;
		/* 820A283Ch case   15:*/		return 0x820A2840;
	}
	return 0x820A2840;
} // Block from 820A2800h-820A2840h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A2840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2840);
		  /* 820A2840h */ case    0:  		/* mr R5, R29 */
		/* 820A2840h case    0:*/		regs.R5 = regs.R29;
		/* 820A2840h case    0:*/		return 0x820A2844;
		  /* 820A2844h */ case    1:  		/* mr R4, R30 */
		/* 820A2844h case    1:*/		regs.R4 = regs.R30;
		/* 820A2844h case    1:*/		return 0x820A2848;
		  /* 820A2848h */ case    2:  		/* bl -69272 */
		/* 820A2848h case    2:*/		regs.LR = 0x820A284C; return 0x820919B0;
		/* 820A2848h case    2:*/		return 0x820A284C;
		  /* 820A284Ch */ case    3:  		/* li R29, 0 */
		/* 820A284Ch case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820A284Ch case    3:*/		return 0x820A2850;
		  /* 820A2850h */ case    4:  		/* lwz R3, <#[R31 + 96]> */
		/* 820A2850h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000060) );
		/* 820A2850h case    4:*/		return 0x820A2854;
		  /* 820A2854h */ case    5:  		/* li R10, 260 */
		/* 820A2854h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x104);
		/* 820A2854h case    5:*/		return 0x820A2858;
		  /* 820A2858h */ case    6:  		/* stb R29, <#[R1 + 352]> */
		/* 820A2858h case    6:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R1 + 0x00000160) );
		/* 820A2858h case    6:*/		return 0x820A285C;
		  /* 820A285Ch */ case    7:  		/* addi R9, R1, 352 */
		/* 820A285Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x160);
		/* 820A285Ch case    7:*/		return 0x820A2860;
		  /* 820A2860h */ case    8:  		/* addi R8, R31, 124 */
		/* 820A2860h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x7C);
		/* 820A2860h case    8:*/		return 0x820A2864;
		  /* 820A2864h */ case    9:  		/* lwz R5, <#[R31 + 100]> */
		/* 820A2864h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000064) );
		/* 820A2864h case    9:*/		return 0x820A2868;
		  /* 820A2868h */ case   10:  		/* addi R7, R31, 116 */
		/* 820A2868h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R31,0x74);
		/* 820A2868h case   10:*/		return 0x820A286C;
		  /* 820A286Ch */ case   11:  		/* lwz R6, <#[R1 + 1068]> */
		/* 820A286Ch case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000042C) );
		/* 820A286Ch case   11:*/		return 0x820A2870;
		  /* 820A2870h */ case   12:  		/* lwz R4, <#[R1 + 1060]> */
		/* 820A2870h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000424) );
		/* 820A2870h case   12:*/		return 0x820A2874;
		  /* 820A2874h */ case   13:  		/* lwz R11, <#[R3]> */
		/* 820A2874h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A2874h case   13:*/		return 0x820A2878;
		  /* 820A2878h */ case   14:  		/* lwz R11, <#[R11]> */
		/* 820A2878h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A2878h case   14:*/		return 0x820A287C;
		  /* 820A287Ch */ case   15:  		/* mtspr CTR, R11 */
		/* 820A287Ch case   15:*/		regs.CTR = regs.R11;
		/* 820A287Ch case   15:*/		return 0x820A2880;
		  /* 820A2880h */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 820A2880h case   16:*/		if ( 1 ) { regs.LR = 0x820A2884; return (uint32)regs.CTR; }
		/* 820A2880h case   16:*/		return 0x820A2884;
		  /* 820A2884h */ case   17:  		/* or. R30, R3, R3 */
		/* 820A2884h case   17:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A2884h case   17:*/		return 0x820A2888;
		  /* 820A2888h */ case   18:  		/* bc 4, CR0_LT, 92 */
		/* 820A2888h case   18:*/		if ( !regs.CR[0].lt ) { return 0x820A28E4;  }
		/* 820A2888h case   18:*/		return 0x820A288C;
		  /* 820A288Ch */ case   19:  		/* cmpwi CR6, R26, 0 */
		/* 820A288Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 820A288Ch case   19:*/		return 0x820A2890;
		  /* 820A2890h */ case   20:  		/* bc 12, CR6_EQ, 52 */
		/* 820A2890h case   20:*/		if ( regs.CR[6].eq ) { return 0x820A28C4;  }
		/* 820A2890h case   20:*/		return 0x820A2894;
		  /* 820A2894h */ case   21:  		/* li R10, 0 */
		/* 820A2894h case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A2894h case   21:*/		return 0x820A2898;
		  /* 820A2898h */ case   22:  		/* li R9, 0 */
		/* 820A2898h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820A2898h case   22:*/		return 0x820A289C;
		  /* 820A289Ch */ case   23:  		/* li R8, 260 */
		/* 820A289Ch case   23:*/		cpu::op::li<0>(regs,&regs.R8,0x104);
		/* 820A289Ch case   23:*/		return 0x820A28A0;
		  /* 820A28A0h */ case   24:  		/* addi R7, R1, 80 */
		/* 820A28A0h case   24:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820A28A0h case   24:*/		return 0x820A28A4;
		  /* 820A28A4h */ case   25:  		/* li R6, -1 */
		/* 820A28A4h case   25:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820A28A4h case   25:*/		return 0x820A28A8;
		  /* 820A28A8h */ case   26:  		/* mr R5, R27 */
		/* 820A28A8h case   26:*/		regs.R5 = regs.R27;
		/* 820A28A8h case   26:*/		return 0x820A28AC;
		  /* 820A28ACh */ case   27:  		/* li R4, 0 */
		/* 820A28ACh case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A28ACh case   27:*/		return 0x820A28B0;
		  /* 820A28B0h */ case   28:  		/* li R3, 0 */
		/* 820A28B0h case   28:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A28B0h case   28:*/		return 0x820A28B4;
		  /* 820A28B4h */ case   29:  		/* bl 1854516 */
		/* 820A28B4h case   29:*/		regs.LR = 0x820A28B8; return 0x822674E8;
		/* 820A28B4h case   29:*/		return 0x820A28B8;
		  /* 820A28B8h */ case   30:  		/* addi R7, R1, 80 */
		/* 820A28B8h case   30:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820A28B8h case   30:*/		return 0x820A28BC;
		  /* 820A28BCh */ case   31:  		/* stb R29, <#[R1 + 339]> */
		/* 820A28BCh case   31:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R1 + 0x00000153) );
		/* 820A28BCh case   31:*/		return 0x820A28C0;
		  /* 820A28C0h */ case   32:  		/* b 8 */
		/* 820A28C0h case   32:*/		return 0x820A28C8;
		/* 820A28C0h case   32:*/		return 0x820A28C4;
	}
	return 0x820A28C4;
} // Block from 820A2840h-820A28C4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820A28C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A28C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A28C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A28C4);
		  /* 820A28C4h */ case    0:  		/* mr R7, R27 */
		/* 820A28C4h case    0:*/		regs.R7 = regs.R27;
		/* 820A28C4h case    0:*/		return 0x820A28C8;
	}
	return 0x820A28C8;
} // Block from 820A28C4h-820A28C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A28C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A28C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A28C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A28C8);
		  /* 820A28C8h */ case    0:  		/* lis R11, -32255 */
		/* 820A28C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A28C8h case    0:*/		return 0x820A28CC;
		  /* 820A28CCh */ case    1:  		/* li R5, 1507 */
		/* 820A28CCh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x5E3);
		/* 820A28CCh case    1:*/		return 0x820A28D0;
		  /* 820A28D0h */ case    2:  		/* addi R6, R11, -10472 */
		/* 820A28D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD718);
		/* 820A28D0h case    2:*/		return 0x820A28D4;
		  /* 820A28D4h */ case    3:  		/* mr R4, R25 */
		/* 820A28D4h case    3:*/		regs.R4 = regs.R25;
		/* 820A28D4h case    3:*/		return 0x820A28D8;
		  /* 820A28D8h */ case    4:  		/* mr R3, R23 */
		/* 820A28D8h case    4:*/		regs.R3 = regs.R23;
		/* 820A28D8h case    4:*/		return 0x820A28DC;
		  /* 820A28DCh */ case    5:  		/* bl 18612 */
		/* 820A28DCh case    5:*/		regs.LR = 0x820A28E0; return 0x820A7190;
		/* 820A28DCh case    5:*/		return 0x820A28E0;
		  /* 820A28E0h */ case    6:  		/* b 260 */
		/* 820A28E0h case    6:*/		return 0x820A29E4;
		/* 820A28E0h case    6:*/		return 0x820A28E4;
	}
	return 0x820A28E4;
} // Block from 820A28C8h-820A28E4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A28E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A28E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A28E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A28E4);
		  /* 820A28E4h */ case    0:  		/* lbz R11, <#[R1 + 352]> */
		/* 820A28E4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000160) );
		/* 820A28E4h case    0:*/		return 0x820A28E8;
		  /* 820A28E8h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820A28E8h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A28E8h case    1:*/		return 0x820A28EC;
		  /* 820A28ECh */ case    2:  		/* bc 12, CR0_EQ, 220 */
		/* 820A28ECh case    2:*/		if ( regs.CR[0].eq ) { return 0x820A29C8;  }
		/* 820A28ECh case    2:*/		return 0x820A28F0;
		  /* 820A28F0h */ case    3:  		/* addi R11, R1, 352 */
		/* 820A28F0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x160);
		/* 820A28F0h case    3:*/		return 0x820A28F4;
		  /* 820A28F4h */ case    4:  		/* stb R29, <#[R1 + 611]> */
		/* 820A28F4h case    4:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R1 + 0x00000263) );
		/* 820A28F4h case    4:*/		return 0x820A28F8;
		  /* 820A28F8h */ case    5:  		/* mr R10, R11 */
		/* 820A28F8h case    5:*/		regs.R10 = regs.R11;
		/* 820A28F8h case    5:*/		return 0x820A28FC;
		  /* 820A28FCh */ case    6:  		/* lbz R9, <#[R11]> */
		/* 820A28FCh case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A28FCh case    6:*/		return 0x820A2900;
		  /* 820A2900h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A2900h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A2900h case    7:*/		return 0x820A2904;
		  /* 820A2904h */ case    8:  		/* cmplwi CR6, R9, 0 */
		/* 820A2904h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A2904h case    8:*/		return 0x820A2908;
		  /* 820A2908h */ case    9:  		/* bc 4, CR6_EQ, -12 */
		/* 820A2908h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A28FC;  }
		/* 820A2908h case    9:*/		return 0x820A290C;
		  /* 820A290Ch */ case   10:  		/* subf R11, R10, R11 */
		/* 820A290Ch case   10:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A290Ch case   10:*/		return 0x820A2910;
		  /* 820A2910h */ case   11:  		/* li R5, 1 */
		/* 820A2910h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A2910h case   11:*/		return 0x820A2914;
		  /* 820A2914h */ case   12:  		/* addi R11, R11, -1 */
		/* 820A2914h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A2914h case   12:*/		return 0x820A2918;
		  /* 820A2918h */ case   13:  		/* mr R3, R28 */
		/* 820A2918h case   13:*/		regs.R3 = regs.R28;
		/* 820A2918h case   13:*/		return 0x820A291C;
		  /* 820A291Ch */ case   14:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820A291Ch case   14:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820A291Ch case   14:*/		return 0x820A2920;
		  /* 820A2920h */ case   15:  		/* addi R29, R11, 1 */
		/* 820A2920h case   15:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1);
		/* 820A2920h case   15:*/		return 0x820A2924;
		  /* 820A2924h */ case   16:  		/* mr R4, R29 */
		/* 820A2924h case   16:*/		regs.R4 = regs.R29;
		/* 820A2924h case   16:*/		return 0x820A2928;
	}
	return 0x820A2928;
} // Block from 820A28E4h-820A2928h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A2928h
// Function '?DoPragmaDef@CPreProcessor@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2928);
		  /* 820A2928h */ case    0:  		/* bl 157624 */
		/* 820A2928h case    0:*/		regs.LR = 0x820A292C; return 0x820C90E0;
		/* 820A2928h case    0:*/		return 0x820A292C;
		  /* 820A292Ch */ case    1:  		/* or. R30, R3, R3 */
		/* 820A292Ch case    1:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A292Ch case    1:*/		return 0x820A2930;
		  /* 820A2930h */ case    2:  		/* bc 12, CR0_EQ, -252 */
		/* 820A2930h case    2:*/		if ( regs.CR[0].eq ) { return 0x820A2834;  }
		/* 820A2930h case    2:*/		return 0x820A2934;
		  /* 820A2934h */ case    3:  		/* mr R5, R29 */
		/* 820A2934h case    3:*/		regs.R5 = regs.R29;
		/* 820A2934h case    3:*/		return 0x820A2938;
		  /* 820A2938h */ case    4:  		/* addi R4, R1, 352 */
		/* 820A2938h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x160);
		/* 820A2938h case    4:*/		return 0x820A293C;
		  /* 820A293Ch */ case    5:  		/* mr R3, R30 */
		/* 820A293Ch case    5:*/		regs.R3 = regs.R30;
		/* 820A293Ch case    5:*/		return 0x820A2940;
		  /* 820A2940h */ case    6:  		/* bl -69520 */
		/* 820A2940h case    6:*/		regs.LR = 0x820A2944; return 0x820919B0;
		/* 820A2940h case    6:*/		return 0x820A2944;
		  /* 820A2944h */ case    7:  		/* stw R30, <#[R31 + 100]> */
		/* 820A2944h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000064) );
		/* 820A2944h case    7:*/		return 0x820A2948;
		  /* 820A2948h */ case    8:  		/* b 128 */
		/* 820A2948h case    8:*/		return 0x820A29C8;
		/* 820A2948h case    8:*/		return 0x820A294C;
	}
	return 0x820A294C;
} // Block from 820A2928h-820A294Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A294Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A294C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A294C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A294C);
		  /* 820A294Ch */ case    0:  		/* mr R5, R30 */
		/* 820A294Ch case    0:*/		regs.R5 = regs.R30;
		/* 820A294Ch case    0:*/		return 0x820A2950;
		  /* 820A2950h */ case    1:  		/* mr R4, R28 */
		/* 820A2950h case    1:*/		regs.R4 = regs.R28;
		/* 820A2950h case    1:*/		return 0x820A2954;
		  /* 820A2954h */ case    2:  		/* mr R3, R31 */
		/* 820A2954h case    2:*/		regs.R3 = regs.R31;
		/* 820A2954h case    2:*/		return 0x820A2958;
		  /* 820A2958h */ case    3:  		/* bl -11592 */
		/* 820A2958h case    3:*/		regs.LR = 0x820A295C; return 0x8209FC10;
		/* 820A2958h case    3:*/		return 0x820A295C;
		  /* 820A295Ch */ case    4:  		/* or. R30, R3, R3 */
		/* 820A295Ch case    4:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A295Ch case    4:*/		return 0x820A2960;
		  /* 820A2960h */ case    5:  		/* bc 12, CR0_LT, 132 */
		/* 820A2960h case    5:*/		if ( regs.CR[0].lt ) { return 0x820A29E4;  }
		/* 820A2960h case    5:*/		return 0x820A2964;
		  /* 820A2964h */ case    6:  		/* li R5, 0 */
		/* 820A2964h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A2964h case    6:*/		return 0x820A2968;
		  /* 820A2968h */ case    7:  		/* lwz R4, <#[R31 + 100]> */
		/* 820A2968h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000064) );
		/* 820A2968h case    7:*/		return 0x820A296C;
		  /* 820A296Ch */ case    8:  		/* addi R3, R31, 84 */
		/* 820A296Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x54);
		/* 820A296Ch case    8:*/		return 0x820A2970;
		  /* 820A2970h */ case    9:  		/* bl 157024 */
		/* 820A2970h case    9:*/		regs.LR = 0x820A2974; return 0x820C8ED0;
		/* 820A2970h case    9:*/		return 0x820A2974;
		  /* 820A2974h */ case   10:  		/* or. R30, R3, R3 */
		/* 820A2974h case   10:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A2974h case   10:*/		return 0x820A2978;
		  /* 820A2978h */ case   11:  		/* bc 4, CR0_LT, 64 */
		/* 820A2978h case   11:*/		if ( !regs.CR[0].lt ) { return 0x820A29B8;  }
		/* 820A2978h case   11:*/		return 0x820A297C;
		  /* 820A297Ch */ case   12:  		/* cmpwi CR6, R26, 0 */
		/* 820A297Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 820A297Ch case   12:*/		return 0x820A2980;
		  /* 820A2980h */ case   13:  		/* bc 12, CR6_EQ, -188 */
		/* 820A2980h case   13:*/		if ( regs.CR[6].eq ) { return 0x820A28C4;  }
		/* 820A2980h case   13:*/		return 0x820A2984;
		  /* 820A2984h */ case   14:  		/* li R10, 0 */
		/* 820A2984h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A2984h case   14:*/		return 0x820A2988;
		  /* 820A2988h */ case   15:  		/* li R9, 0 */
		/* 820A2988h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820A2988h case   15:*/		return 0x820A298C;
		  /* 820A298Ch */ case   16:  		/* li R8, 260 */
		/* 820A298Ch case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x104);
		/* 820A298Ch case   16:*/		return 0x820A2990;
		  /* 820A2990h */ case   17:  		/* addi R7, R1, 80 */
		/* 820A2990h case   17:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820A2990h case   17:*/		return 0x820A2994;
		  /* 820A2994h */ case   18:  		/* li R6, -1 */
		/* 820A2994h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820A2994h case   18:*/		return 0x820A2998;
		  /* 820A2998h */ case   19:  		/* mr R5, R27 */
		/* 820A2998h case   19:*/		regs.R5 = regs.R27;
		/* 820A2998h case   19:*/		return 0x820A299C;
		  /* 820A299Ch */ case   20:  		/* li R4, 0 */
		/* 820A299Ch case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A299Ch case   20:*/		return 0x820A29A0;
		  /* 820A29A0h */ case   21:  		/* li R3, 0 */
		/* 820A29A0h case   21:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A29A0h case   21:*/		return 0x820A29A4;
		  /* 820A29A4h */ case   22:  		/* bl 1854276 */
		/* 820A29A4h case   22:*/		regs.LR = 0x820A29A8; return 0x822674E8;
		/* 820A29A4h case   22:*/		return 0x820A29A8;
		  /* 820A29A8h */ case   23:  		/* li R11, 0 */
		/* 820A29A8h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A29A8h case   23:*/		return 0x820A29AC;
		  /* 820A29ACh */ case   24:  		/* addi R7, R1, 80 */
		/* 820A29ACh case   24:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820A29ACh case   24:*/		return 0x820A29B0;
		  /* 820A29B0h */ case   25:  		/* stb R11, <#[R1 + 339]> */
		/* 820A29B0h case   25:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000153) );
		/* 820A29B0h case   25:*/		return 0x820A29B4;
		  /* 820A29B4h */ case   26:  		/* b -236 */
		/* 820A29B4h case   26:*/		return 0x820A28C8;
		/* 820A29B4h case   26:*/		return 0x820A29B8;
	}
	return 0x820A29B8;
} // Block from 820A294Ch-820A29B8h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820A29B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A29B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A29B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A29B8);
		  /* 820A29B8h */ case    0:  		/* lwz R11, <#[R31 + 88]> */
		/* 820A29B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 820A29B8h case    0:*/		return 0x820A29BC;
		  /* 820A29BCh */ case    1:  		/* lwz R10, <#[R31 + 92]> */
		/* 820A29BCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000005C) );
		/* 820A29BCh case    1:*/		return 0x820A29C0;
		  /* 820A29C0h */ case    2:  		/* stw R11, <#[R31 + 116]> */
		/* 820A29C0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000074) );
		/* 820A29C0h case    2:*/		return 0x820A29C4;
		  /* 820A29C4h */ case    3:  		/* stw R10, <#[R31 + 124]> */
		/* 820A29C4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000007C) );
		/* 820A29C4h case    3:*/		return 0x820A29C8;
	}
	return 0x820A29C8;
} // Block from 820A29B8h-820A29C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A29C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A29C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A29C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A29C8);
		  /* 820A29C8h */ case    0:  		/* mr R6, R24 */
		/* 820A29C8h case    0:*/		regs.R6 = regs.R24;
		/* 820A29C8h case    0:*/		return 0x820A29CC;
		  /* 820A29CCh */ case    1:  		/* lwz R7, <#[R1 + 1076]> */
		/* 820A29CCh case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000434) );
		/* 820A29CCh case    1:*/		return 0x820A29D0;
		  /* 820A29D0h */ case    2:  		/* mr R5, R23 */
		/* 820A29D0h case    2:*/		regs.R5 = regs.R23;
		/* 820A29D0h case    2:*/		return 0x820A29D4;
		  /* 820A29D4h */ case    3:  		/* mr R4, R28 */
		/* 820A29D4h case    3:*/		regs.R4 = regs.R28;
		/* 820A29D4h case    3:*/		return 0x820A29D8;
		  /* 820A29D8h */ case    4:  		/* mr R3, R31 */
		/* 820A29D8h case    4:*/		regs.R3 = regs.R31;
		/* 820A29D8h case    4:*/		return 0x820A29DC;
		  /* 820A29DCh */ case    5:  		/* bl -820 */
		/* 820A29DCh case    5:*/		regs.LR = 0x820A29E0; return 0x820A26A8;
		/* 820A29DCh case    5:*/		return 0x820A29E0;
		  /* 820A29E0h */ case    6:  		/* mr R30, R3 */
		/* 820A29E0h case    6:*/		regs.R30 = regs.R3;
		/* 820A29E0h case    6:*/		return 0x820A29E4;
	}
	return 0x820A29E4;
} // Block from 820A29C8h-820A29E4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A29E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A29E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A29E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A29E4);
		  /* 820A29E4h */ case    0:  		/* mr R3, R30 */
		/* 820A29E4h case    0:*/		regs.R3 = regs.R30;
		/* 820A29E4h case    0:*/		return 0x820A29E8;
	}
	return 0x820A29E8;
} // Block from 820A29E4h-820A29E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A29E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A29E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A29E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A29E8);
		  /* 820A29E8h */ case    0:  		/* addi R1, R1, 976 */
		/* 820A29E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x3D0);
		/* 820A29E8h case    0:*/		return 0x820A29EC;
		  /* 820A29ECh */ case    1:  		/* b -71512 */
		/* 820A29ECh case    1:*/		return 0x82091294;
		/* 820A29ECh case    1:*/		return 0x820A29F0;
	}
	return 0x820A29F0;
} // Block from 820A29E8h-820A29F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A29F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A29F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A29F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A29F0);
		  /* 820A29F0h */ case    0:  		/* mfspr R12, LR */
		/* 820A29F0h case    0:*/		regs.R12 = regs.LR;
		/* 820A29F0h case    0:*/		return 0x820A29F4;
		  /* 820A29F4h */ case    1:  		/* bl -71584 */
		/* 820A29F4h case    1:*/		regs.LR = 0x820A29F8; return 0x82091254;
		/* 820A29F4h case    1:*/		return 0x820A29F8;
		  /* 820A29F8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820A29F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820A29F8h case    2:*/		return 0x820A29FC;
		  /* 820A29FCh */ case    3:  		/* mr R31, R3 */
		/* 820A29FCh case    3:*/		regs.R31 = regs.R3;
		/* 820A29FCh case    3:*/		return 0x820A2A00;
		  /* 820A2A00h */ case    4:  		/* mr R30, R7 */
		/* 820A2A00h case    4:*/		regs.R30 = regs.R7;
		/* 820A2A00h case    4:*/		return 0x820A2A04;
		  /* 820A2A04h */ case    5:  		/* mr R29, R8 */
		/* 820A2A04h case    5:*/		regs.R29 = regs.R8;
		/* 820A2A04h case    5:*/		return 0x820A2A08;
		  /* 820A2A08h */ case    6:  		/* mr R28, R9 */
		/* 820A2A08h case    6:*/		regs.R28 = regs.R9;
		/* 820A2A08h case    6:*/		return 0x820A2A0C;
		  /* 820A2A0Ch */ case    7:  		/* mr R27, R10 */
		/* 820A2A0Ch case    7:*/		regs.R27 = regs.R10;
		/* 820A2A0Ch case    7:*/		return 0x820A2A10;
		  /* 820A2A10h */ case    8:  		/* cmplwi CR6, R6, 0 */
		/* 820A2A10h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820A2A10h case    8:*/		return 0x820A2A14;
		  /* 820A2A14h */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 820A2A14h case    9:*/		if ( regs.CR[6].eq ) { return 0x820A2A2C;  }
		/* 820A2A14h case    9:*/		return 0x820A2A18;
		  /* 820A2A18h */ case   10:  		/* cmplwi CR6, R5, 0 */
		/* 820A2A18h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820A2A18h case   10:*/		return 0x820A2A1C;
		  /* 820A2A1Ch */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 820A2A1Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x820A2A2C;  }
		/* 820A2A1Ch case   11:*/		return 0x820A2A20;
		  /* 820A2A20h */ case   12:  		/* lis R3, -30602 */
		/* 820A2A20h case   12:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820A2A20h case   12:*/		return 0x820A2A24;
		  /* 820A2A24h */ case   13:  		/* ori R3, R3, 2156 */
		/* 820A2A24h case   13:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 820A2A24h case   13:*/		return 0x820A2A28;
		  /* 820A2A28h */ case   14:  		/* b 60 */
		/* 820A2A28h case   14:*/		return 0x820A2A64;
		/* 820A2A28h case   14:*/		return 0x820A2A2C;
	}
	return 0x820A2A2C;
} // Block from 820A29F0h-820A2A2Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A2A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2A2C);
		  /* 820A2A2Ch */ case    0:  		/* stw R5, <#[R31 + 116]> */
		/* 820A2A2Ch case    0:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x00000074) );
		/* 820A2A2Ch case    0:*/		return 0x820A2A30;
		  /* 820A2A30h */ case    1:  		/* mr R5, R4 */
		/* 820A2A30h case    1:*/		regs.R5 = regs.R4;
		/* 820A2A30h case    1:*/		return 0x820A2A34;
		  /* 820A2A34h */ case    2:  		/* stw R6, <#[R31 + 124]> */
		/* 820A2A34h case    2:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x0000007C) );
		/* 820A2A34h case    2:*/		return 0x820A2A38;
		  /* 820A2A38h */ case    3:  		/* mr R4, R30 */
		/* 820A2A38h case    3:*/		regs.R4 = regs.R30;
		/* 820A2A38h case    3:*/		return 0x820A2A3C;
		  /* 820A2A3Ch */ case    4:  		/* mr R3, R31 */
		/* 820A2A3Ch case    4:*/		regs.R3 = regs.R31;
		/* 820A2A3Ch case    4:*/		return 0x820A2A40;
		  /* 820A2A40h */ case    5:  		/* bl -11824 */
		/* 820A2A40h case    5:*/		regs.LR = 0x820A2A44; return 0x8209FC10;
		/* 820A2A40h case    5:*/		return 0x820A2A44;
		  /* 820A2A44h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820A2A44h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A2A44h case    6:*/		return 0x820A2A48;
		  /* 820A2A48h */ case    7:  		/* bc 12, CR0_LT, 28 */
		/* 820A2A48h case    7:*/		if ( regs.CR[0].lt ) { return 0x820A2A64;  }
		/* 820A2A48h case    7:*/		return 0x820A2A4C;
		  /* 820A2A4Ch */ case    8:  		/* mr R7, R27 */
		/* 820A2A4Ch case    8:*/		regs.R7 = regs.R27;
		/* 820A2A4Ch case    8:*/		return 0x820A2A50;
		  /* 820A2A50h */ case    9:  		/* mr R6, R28 */
		/* 820A2A50h case    9:*/		regs.R6 = regs.R28;
		/* 820A2A50h case    9:*/		return 0x820A2A54;
		  /* 820A2A54h */ case   10:  		/* mr R5, R29 */
		/* 820A2A54h case   10:*/		regs.R5 = regs.R29;
		/* 820A2A54h case   10:*/		return 0x820A2A58;
		  /* 820A2A58h */ case   11:  		/* mr R4, R30 */
		/* 820A2A58h case   11:*/		regs.R4 = regs.R30;
		/* 820A2A58h case   11:*/		return 0x820A2A5C;
		  /* 820A2A5Ch */ case   12:  		/* mr R3, R31 */
		/* 820A2A5Ch case   12:*/		regs.R3 = regs.R31;
		/* 820A2A5Ch case   12:*/		return 0x820A2A60;
		  /* 820A2A60h */ case   13:  		/* bl -952 */
		/* 820A2A60h case   13:*/		regs.LR = 0x820A2A64; return 0x820A26A8;
		/* 820A2A60h case   13:*/		return 0x820A2A64;
	}
	return 0x820A2A64;
} // Block from 820A2A2Ch-820A2A64h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A2A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2A64);
		  /* 820A2A64h */ case    0:  		/* addi R1, R1, 128 */
		/* 820A2A64h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820A2A64h case    0:*/		return 0x820A2A68;
		  /* 820A2A68h */ case    1:  		/* b -71620 */
		/* 820A2A68h case    1:*/		return 0x820912A4;
		/* 820A2A68h case    1:*/		return 0x820A2A6C;
		  /* 820A2A6Ch */ case    2:  		/* nop */
		/* 820A2A6Ch case    2:*/		cpu::op::nop();
		/* 820A2A6Ch case    2:*/		return 0x820A2A70;
	}
	return 0x820A2A70;
} // Block from 820A2A64h-820A2A70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A2A70h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2A70);
		  /* 820A2A70h */ case    0:  		/* mfspr R12, LR */
		/* 820A2A70h case    0:*/		regs.R12 = regs.LR;
		/* 820A2A70h case    0:*/		return 0x820A2A74;
		  /* 820A2A74h */ case    1:  		/* bl -71704 */
		/* 820A2A74h case    1:*/		regs.LR = 0x820A2A78; return 0x8209125C;
		/* 820A2A74h case    1:*/		return 0x820A2A78;
		  /* 820A2A78h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A2A78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A2A78h case    2:*/		return 0x820A2A7C;
		  /* 820A2A7Ch */ case    3:  		/* mr R31, R3 */
		/* 820A2A7Ch case    3:*/		regs.R31 = regs.R3;
		/* 820A2A7Ch case    3:*/		return 0x820A2A80;
		  /* 820A2A80h */ case    4:  		/* lwz R3, <#[R3 + 68]> */
		/* 820A2A80h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000044) );
		/* 820A2A80h case    4:*/		return 0x820A2A84;
		  /* 820A2A84h */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 820A2A84h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A2A84h case    5:*/		return 0x820A2A88;
		  /* 820A2A88h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 820A2A88h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A2A94;  }
		/* 820A2A88h case    6:*/		return 0x820A2A8C;
		  /* 820A2A8Ch */ case    7:  		/* li R4, 1 */
		/* 820A2A8Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A2A8Ch case    7:*/		return 0x820A2A90;
		  /* 820A2A90h */ case    8:  		/* bl -6768 */
		/* 820A2A90h case    8:*/		regs.LR = 0x820A2A94; return 0x820A1020;
		/* 820A2A90h case    8:*/		return 0x820A2A94;
	}
	return 0x820A2A94;
} // Block from 820A2A70h-820A2A94h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A2A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2A94);
		  /* 820A2A94h */ case    0:  		/* lwz R3, <#[R31 + 1680]> */
		/* 820A2A94h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000690) );
		/* 820A2A94h case    0:*/		return 0x820A2A98;
		  /* 820A2A98h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A2A98h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A2A98h case    1:*/		return 0x820A2A9C;
		  /* 820A2A9Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820A2A9Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820A2AA8;  }
		/* 820A2A9Ch case    2:*/		return 0x820A2AA0;
		  /* 820A2AA0h */ case    3:  		/* li R4, 1 */
		/* 820A2AA0h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A2AA0h case    3:*/		return 0x820A2AA4;
		  /* 820A2AA4h */ case    4:  		/* bl -6884 */
		/* 820A2AA4h case    4:*/		regs.LR = 0x820A2AA8; return 0x820A0FC0;
		/* 820A2AA4h case    4:*/		return 0x820A2AA8;
	}
	return 0x820A2AA8;
} // Block from 820A2A94h-820A2AA8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A2AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2AA8);
		  /* 820A2AA8h */ case    0:  		/* lwz R3, <#[R31 + 72]> */
		/* 820A2AA8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000048) );
		/* 820A2AA8h case    0:*/		return 0x820A2AAC;
		  /* 820A2AACh */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A2AACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A2AACh case    1:*/		return 0x820A2AB0;
		  /* 820A2AB0h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820A2AB0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A2ABC;  }
		/* 820A2AB0h case    2:*/		return 0x820A2AB4;
		  /* 820A2AB4h */ case    3:  		/* li R4, 1 */
		/* 820A2AB4h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A2AB4h case    3:*/		return 0x820A2AB8;
		  /* 820A2AB8h */ case    4:  		/* bl -6712 */
		/* 820A2AB8h case    4:*/		regs.LR = 0x820A2ABC; return 0x820A1080;
		/* 820A2AB8h case    4:*/		return 0x820A2ABC;
	}
	return 0x820A2ABC;
} // Block from 820A2AA8h-820A2ABCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A2ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2ABC);
		  /* 820A2ABCh */ case    0:  		/* addi R30, R31, 1684 */
		/* 820A2ABCh case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x694);
		/* 820A2ABCh case    0:*/		return 0x820A2AC0;
		  /* 820A2AC0h */ case    1:  		/* li R29, 127 */
		/* 820A2AC0h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x7F);
		/* 820A2AC0h case    1:*/		return 0x820A2AC4;
		  /* 820A2AC4h */ case    2:  		/* lwz R3, <#[R30]> */
		/* 820A2AC4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A2AC4h case    2:*/		return 0x820A2AC8;
		  /* 820A2AC8h */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 820A2AC8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A2AC8h case    3:*/		return 0x820A2ACC;
		  /* 820A2ACCh */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 820A2ACCh case    4:*/		if ( regs.CR[6].eq ) { return 0x820A2AD8;  }
		/* 820A2ACCh case    4:*/		return 0x820A2AD0;
		  /* 820A2AD0h */ case    5:  		/* li R4, 1 */
		/* 820A2AD0h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A2AD0h case    5:*/		return 0x820A2AD4;
		  /* 820A2AD4h */ case    6:  		/* bl -7116 */
		/* 820A2AD4h case    6:*/		regs.LR = 0x820A2AD8; return 0x820A0F08;
		/* 820A2AD4h case    6:*/		return 0x820A2AD8;
	}
	return 0x820A2AD8;
} // Block from 820A2ABCh-820A2AD8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A2AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2AD8);
		  /* 820A2AD8h */ case    0:  		/* addic. R29, R29, -1 */
		/* 820A2AD8h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820A2AD8h case    0:*/		return 0x820A2ADC;
		  /* 820A2ADCh */ case    1:  		/* addi R30, R30, 4 */
		/* 820A2ADCh case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820A2ADCh case    1:*/		return 0x820A2AE0;
		  /* 820A2AE0h */ case    2:  		/* bc 4, CR0_EQ, -28 */
		/* 820A2AE0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A2AC4;  }
		/* 820A2AE0h case    2:*/		return 0x820A2AE4;
		  /* 820A2AE4h */ case    3:  		/* b 36 */
		/* 820A2AE4h case    3:*/		return 0x820A2B08;
		/* 820A2AE4h case    3:*/		return 0x820A2AE8;
		  /* 820A2AE8h */ case    4:  		/* lwz R30, <#[R31 + 2200]> */
		/* 820A2AE8h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000898) );
		/* 820A2AE8h case    4:*/		return 0x820A2AEC;
		  /* 820A2AECh */ case    5:  		/* mr R3, R30 */
		/* 820A2AECh case    5:*/		regs.R3 = regs.R30;
		/* 820A2AECh case    5:*/		return 0x820A2AF0;
		  /* 820A2AF0h */ case    6:  		/* lwz R11, <#[R30 + 132]> */
		/* 820A2AF0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 820A2AF0h case    6:*/		return 0x820A2AF4;
		  /* 820A2AF4h */ case    7:  		/* stw R11, <#[R31 + 2200]> */
		/* 820A2AF4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000898) );
		/* 820A2AF4h case    7:*/		return 0x820A2AF8;
		  /* 820A2AF8h */ case    8:  		/* bl -7056 */
		/* 820A2AF8h case    8:*/		regs.LR = 0x820A2AFC; return 0x820A0F68;
		/* 820A2AF8h case    8:*/		return 0x820A2AFC;
		  /* 820A2AFCh */ case    9:  		/* lis R4, 9345 */
		/* 820A2AFCh case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A2AFCh case    9:*/		return 0x820A2B00;
		  /* 820A2B00h */ case   10:  		/* mr R3, R30 */
		/* 820A2B00h case   10:*/		regs.R3 = regs.R30;
		/* 820A2B00h case   10:*/		return 0x820A2B04;
		  /* 820A2B04h */ case   11:  		/* bl -108492 */
		/* 820A2B04h case   11:*/		regs.LR = 0x820A2B08; return 0x82088338;
		/* 820A2B04h case   11:*/		return 0x820A2B08;
	}
	return 0x820A2B08;
} // Block from 820A2AD8h-820A2B08h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A2B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2B08);
		  /* 820A2B08h */ case    0:  		/* lwz R11, <#[R31 + 2200]> */
		/* 820A2B08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000898) );
		/* 820A2B08h case    0:*/		return 0x820A2B0C;
		  /* 820A2B0Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A2B0Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A2B0Ch case    1:*/		return 0x820A2B10;
		  /* 820A2B10h */ case    2:  		/* bc 4, CR6_EQ, -40 */
		/* 820A2B10h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A2AE8;  }
		/* 820A2B10h case    2:*/		return 0x820A2B14;
		  /* 820A2B14h */ case    3:  		/* lwz R11, <#[R31 + 2264]> */
		/* 820A2B14h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000008D8) );
		/* 820A2B14h case    3:*/		return 0x820A2B18;
		  /* 820A2B18h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820A2B18h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A2B18h case    4:*/		return 0x820A2B1C;
		  /* 820A2B1Ch */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 820A2B1Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820A2B28;  }
		/* 820A2B1Ch case    5:*/		return 0x820A2B20;
		  /* 820A2B20h */ case    6:  		/* mr R3, R31 */
		/* 820A2B20h case    6:*/		regs.R3 = regs.R31;
		/* 820A2B20h case    6:*/		return 0x820A2B24;
		  /* 820A2B24h */ case    7:  		/* bl -11652 */
		/* 820A2B24h case    7:*/		regs.LR = 0x820A2B28; return 0x8209FDA0;
		/* 820A2B24h case    7:*/		return 0x820A2B28;
	}
	return 0x820A2B28;
} // Block from 820A2B08h-820A2B28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A2B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2B28);
		  /* 820A2B28h */ case    0:  		/* addi R3, R31, 80 */
		/* 820A2B28h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x50);
		/* 820A2B28h case    0:*/		return 0x820A2B2C;
		  /* 820A2B2Ch */ case    1:  		/* bl 1550484 */
		/* 820A2B2Ch case    1:*/		regs.LR = 0x820A2B30; return 0x8221D3C0;
		/* 820A2B2Ch case    1:*/		return 0x820A2B30;
		  /* 820A2B30h */ case    2:  		/* addi R3, R31, 24 */
		/* 820A2B30h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A2B30h case    2:*/		return 0x820A2B34;
		  /* 820A2B34h */ case    3:  		/* bl 15500 */
		/* 820A2B34h case    3:*/		regs.LR = 0x820A2B38; return 0x820A67C0;
		/* 820A2B34h case    3:*/		return 0x820A2B38;
		  /* 820A2B38h */ case    4:  		/* mr R3, R31 */
		/* 820A2B38h case    4:*/		regs.R3 = regs.R31;
		/* 820A2B38h case    4:*/		return 0x820A2B3C;
		  /* 820A2B3Ch */ case    5:  		/* bl 157012 */
		/* 820A2B3Ch case    5:*/		regs.LR = 0x820A2B40; return 0x820C9090;
		/* 820A2B3Ch case    5:*/		return 0x820A2B40;
		  /* 820A2B40h */ case    6:  		/* addi R1, R1, 112 */
		/* 820A2B40h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A2B40h case    6:*/		return 0x820A2B44;
		  /* 820A2B44h */ case    7:  		/* b -71832 */
		/* 820A2B44h case    7:*/		return 0x820912AC;
		/* 820A2B44h case    7:*/		return 0x820A2B48;
	}
	return 0x820A2B48;
} // Block from 820A2B28h-820A2B48h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A2B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2B48);
		  /* 820A2B48h */ case    0:  		/* mfspr R12, LR */
		/* 820A2B48h case    0:*/		regs.R12 = regs.LR;
		/* 820A2B48h case    0:*/		return 0x820A2B4C;
		  /* 820A2B4Ch */ case    1:  		/* bl -71928 */
		/* 820A2B4Ch case    1:*/		regs.LR = 0x820A2B50; return 0x82091254;
		/* 820A2B4Ch case    1:*/		return 0x820A2B50;
		  /* 820A2B50h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820A2B50h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820A2B50h case    2:*/		return 0x820A2B54;
		  /* 820A2B54h */ case    3:  		/* lis R11, 32767 */
		/* 820A2B54h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 820A2B54h case    3:*/		return 0x820A2B58;
		  /* 820A2B58h */ case    4:  		/* mr R7, R3 */
		/* 820A2B58h case    4:*/		regs.R7 = regs.R3;
		/* 820A2B58h case    4:*/		return 0x820A2B5C;
		  /* 820A2B5Ch */ case    5:  		/* mr R27, R4 */
		/* 820A2B5Ch case    5:*/		regs.R27 = regs.R4;
		/* 820A2B5Ch case    5:*/		return 0x820A2B60;
		  /* 820A2B60h */ case    6:  		/* mr R30, R5 */
		/* 820A2B60h case    6:*/		regs.R30 = regs.R5;
		/* 820A2B60h case    6:*/		return 0x820A2B64;
		  /* 820A2B64h */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 820A2B64h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820A2B64h case    7:*/		return 0x820A2B68;
		  /* 820A2B68h */ case    8:  		/* ori R8, R11, 65535 */
		/* 820A2B68h case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R11,0xFFFF);
		/* 820A2B68h case    8:*/		return 0x820A2B6C;
		  /* 820A2B6Ch */ case    9:  		/* bc 12, CR6_EQ, 80 */
		/* 820A2B6Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820A2BBC;  }
		/* 820A2B6Ch case    9:*/		return 0x820A2B70;
		  /* 820A2B70h */ case   10:  		/* mr R11, R8 */
		/* 820A2B70h case   10:*/		regs.R11 = regs.R8;
		/* 820A2B70h case   10:*/		return 0x820A2B74;
		  /* 820A2B74h */ case   11:  		/* mr R10, R5 */
		/* 820A2B74h case   11:*/		regs.R10 = regs.R5;
		/* 820A2B74h case   11:*/		return 0x820A2B78;
		  /* 820A2B78h */ case   12:  		/* li R9, 0 */
		/* 820A2B78h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820A2B78h case   12:*/		return 0x820A2B7C;
		  /* 820A2B7Ch */ case   13:  		/* lbz R5, <#[R10]> */
		/* 820A2B7Ch case   13:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 820A2B7Ch case   13:*/		return 0x820A2B80;
		  /* 820A2B80h */ case   14:  		/* cmplwi CR0, R5, 0 */
		/* 820A2B80h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R5,0x00000000);
		/* 820A2B80h case   14:*/		return 0x820A2B84;
		  /* 820A2B84h */ case   15:  		/* bc 12, CR0_EQ, 16 */
		/* 820A2B84h case   15:*/		if ( regs.CR[0].eq ) { return 0x820A2B94;  }
		/* 820A2B84h case   15:*/		return 0x820A2B88;
		  /* 820A2B88h */ case   16:  		/* addic. R11, R11, -1 */
		/* 820A2B88h case   16:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A2B88h case   16:*/		return 0x820A2B8C;
		  /* 820A2B8Ch */ case   17:  		/* addi R10, R10, 1 */
		/* 820A2B8Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A2B8Ch case   17:*/		return 0x820A2B90;
		  /* 820A2B90h */ case   18:  		/* bc 4, CR0_EQ, -20 */
		/* 820A2B90h case   18:*/		if ( !regs.CR[0].eq ) { return 0x820A2B7C;  }
		/* 820A2B90h case   18:*/		return 0x820A2B94;
	}
	return 0x820A2B94;
} // Block from 820A2B48h-820A2B94h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A2B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2B94);
		  /* 820A2B94h */ case    0:  		/* lis R10, -32761 */
		/* 820A2B94h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8007);
		/* 820A2B94h case    0:*/		return 0x820A2B98;
		  /* 820A2B98h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A2B98h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A2B98h case    1:*/		return 0x820A2B9C;
		  /* 820A2B9Ch */ case    2:  		/* ori R3, R10, 87 */
		/* 820A2B9Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R10,0x57);
		/* 820A2B9Ch case    2:*/		return 0x820A2BA0;
		  /* 820A2BA0h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820A2BA0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A2BB0;  }
		/* 820A2BA0h case    3:*/		return 0x820A2BA4;
		  /* 820A2BA4h */ case    4:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A2BA4h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A2BA4h case    4:*/		return 0x820A2BA8;
		  /* 820A2BA8h */ case    5:  		/* mr R9, R3 */
		/* 820A2BA8h case    5:*/		regs.R9 = regs.R3;
		/* 820A2BA8h case    5:*/		return 0x820A2BAC;
		  /* 820A2BACh */ case    6:  		/* b 8 */
		/* 820A2BACh case    6:*/		return 0x820A2BB4;
		/* 820A2BACh case    6:*/		return 0x820A2BB0;
	}
	return 0x820A2BB0;
} // Block from 820A2B94h-820A2BB0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A2BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2BB0);
		  /* 820A2BB0h */ case    0:  		/* subf R29, R11, R8 */
		/* 820A2BB0h case    0:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R11,regs.R8);
		/* 820A2BB0h case    0:*/		return 0x820A2BB4;
	}
	return 0x820A2BB4;
} // Block from 820A2BB0h-820A2BB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A2BB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2BB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2BB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2BB4);
		  /* 820A2BB4h */ case    0:  		/* mr R11, R9 */
		/* 820A2BB4h case    0:*/		regs.R11 = regs.R9;
		/* 820A2BB4h case    0:*/		return 0x820A2BB8;
		  /* 820A2BB8h */ case    1:  		/* b 20 */
		/* 820A2BB8h case    1:*/		return 0x820A2BCC;
		/* 820A2BB8h case    1:*/		return 0x820A2BBC;
	}
	return 0x820A2BBC;
} // Block from 820A2BB4h-820A2BBCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A2BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2BBC);
		  /* 820A2BBCh */ case    0:  		/* lis R11, -32761 */
		/* 820A2BBCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8007);
		/* 820A2BBCh case    0:*/		return 0x820A2BC0;
		  /* 820A2BC0h */ case    1:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A2BC0h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A2BC0h case    1:*/		return 0x820A2BC4;
		  /* 820A2BC4h */ case    2:  		/* ori R3, R11, 87 */
		/* 820A2BC4h case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R11,0x57);
		/* 820A2BC4h case    2:*/		return 0x820A2BC8;
		  /* 820A2BC8h */ case    3:  		/* mr R11, R3 */
		/* 820A2BC8h case    3:*/		regs.R11 = regs.R3;
		/* 820A2BC8h case    3:*/		return 0x820A2BCC;
	}
	return 0x820A2BCC;
} // Block from 820A2BBCh-820A2BCCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A2BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2BCC);
		  /* 820A2BCCh */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 820A2BCCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A2BCCh case    0:*/		return 0x820A2BD0;
		  /* 820A2BD0h */ case    1:  		/* bc 12, CR6_LT, 268 */
		/* 820A2BD0h case    1:*/		if ( regs.CR[6].lt ) { return 0x820A2CDC;  }
		/* 820A2BD0h case    1:*/		return 0x820A2BD4;
		  /* 820A2BD4h */ case    2:  		/* rlwinm. R28, R6, 0, 24, 31 */
		/* 820A2BD4h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R28,regs.R6);
		/* 820A2BD4h case    2:*/		return 0x820A2BD8;
		  /* 820A2BD8h */ case    3:  		/* bc 12, CR0_EQ, 100 */
		/* 820A2BD8h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A2C3C;  }
		/* 820A2BD8h case    3:*/		return 0x820A2BDC;
		  /* 820A2BDCh */ case    4:  		/* lis R11, 32767 */
		/* 820A2BDCh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 820A2BDCh case    4:*/		return 0x820A2BE0;
		  /* 820A2BE0h */ case    5:  		/* ori R11, R11, 65533 */
		/* 820A2BE0h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFD);
		/* 820A2BE0h case    5:*/		return 0x820A2BE4;
		  /* 820A2BE4h */ case    6:  		/* cmplw CR6, R29, R11 */
		/* 820A2BE4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820A2BE4h case    6:*/		return 0x820A2BE8;
		  /* 820A2BE8h */ case    7:  		/* bc 4, CR6_LT, 248 */
		/* 820A2BE8h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820A2CE0;  }
		/* 820A2BE8h case    7:*/		return 0x820A2BEC;
		  /* 820A2BECh */ case    8:  		/* lbz R11, <#[R30]> */
		/* 820A2BECh case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A2BECh case    8:*/		return 0x820A2BF0;
		  /* 820A2BF0h */ case    9:  		/* addi R29, R29, 2 */
		/* 820A2BF0h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x2);
		/* 820A2BF0h case    9:*/		return 0x820A2BF4;
		  /* 820A2BF4h */ case   10:  		/* mr R10, R30 */
		/* 820A2BF4h case   10:*/		regs.R10 = regs.R30;
		/* 820A2BF4h case   10:*/		return 0x820A2BF8;
		  /* 820A2BF8h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 820A2BF8h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A2BF8h case   11:*/		return 0x820A2BFC;
		  /* 820A2BFCh */ case   12:  		/* bc 12, CR0_EQ, 64 */
		/* 820A2BFCh case   12:*/		if ( regs.CR[0].eq ) { return 0x820A2C3C;  }
		/* 820A2BFCh case   12:*/		return 0x820A2C00;
		  /* 820A2C00h */ case   13:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 820A2C00h case   13:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 820A2C00h case   13:*/		return 0x820A2C04;
		  /* 820A2C04h */ case   14:  		/* cmplwi CR6, R11, 9 */
		/* 820A2C04h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000009);
		/* 820A2C04h case   14:*/		return 0x820A2C08;
		  /* 820A2C08h */ case   15:  		/* bc 12, CR6_LT, 40 */
		/* 820A2C08h case   15:*/		if ( regs.CR[6].lt ) { return 0x820A2C30;  }
		/* 820A2C08h case   15:*/		return 0x820A2C0C;
		  /* 820A2C0Ch */ case   16:  		/* cmplwi CR6, R11, 10 */
		/* 820A2C0Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 820A2C0Ch case   16:*/		return 0x820A2C10;
		  /* 820A2C10h */ case   17:  		/* bc 4, CR6_GT, 20 */
		/* 820A2C10h case   17:*/		if ( !regs.CR[6].gt ) { return 0x820A2C24;  }
		/* 820A2C10h case   17:*/		return 0x820A2C14;
		  /* 820A2C14h */ case   18:  		/* cmplwi CR6, R11, 13 */
		/* 820A2C14h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000D);
		/* 820A2C14h case   18:*/		return 0x820A2C18;
		  /* 820A2C18h */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 820A2C18h case   19:*/		if ( regs.CR[6].eq ) { return 0x820A2C24;  }
		/* 820A2C18h case   19:*/		return 0x820A2C1C;
		  /* 820A2C1Ch */ case   20:  		/* cmplwi CR6, R11, 92 */
		/* 820A2C1Ch case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005C);
		/* 820A2C1Ch case   20:*/		return 0x820A2C20;
		  /* 820A2C20h */ case   21:  		/* bc 4, CR6_EQ, 16 */
		/* 820A2C20h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820A2C30;  }
		/* 820A2C20h case   21:*/		return 0x820A2C24;
	}
	return 0x820A2C24;
} // Block from 820A2BCCh-820A2C24h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820A2C24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2C24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2C24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2C24);
		  /* 820A2C24h */ case    0:  		/* addi R29, R29, 1 */
		/* 820A2C24h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820A2C24h case    0:*/		return 0x820A2C28;
		  /* 820A2C28h */ case    1:  		/* cmplw CR6, R29, R8 */
		/* 820A2C28h case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R8);
		/* 820A2C28h case    1:*/		return 0x820A2C2C;
		  /* 820A2C2Ch */ case    2:  		/* bc 4, CR6_LT, 180 */
		/* 820A2C2Ch case    2:*/		if ( !regs.CR[6].lt ) { return 0x820A2CE0;  }
		/* 820A2C2Ch case    2:*/		return 0x820A2C30;
	}
	return 0x820A2C30;
} // Block from 820A2C24h-820A2C30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A2C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2C30);
		  /* 820A2C30h */ case    0:  		/* lbzu R11, <#[R10 + 1]> */
		/* 820A2C30h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000001) );
		regs.R10 = (uint32)(regs.R10 + 0x00000001);
		/* 820A2C30h case    0:*/		return 0x820A2C34;
		  /* 820A2C34h */ case    1:  		/* extsb. R9, R11 */
		/* 820A2C34h case    1:*/		cpu::op::extsb<1>(regs,&regs.R9,regs.R11);
		/* 820A2C34h case    1:*/		return 0x820A2C38;
		  /* 820A2C38h */ case    2:  		/* bc 4, CR0_EQ, -56 */
		/* 820A2C38h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A2C00;  }
		/* 820A2C38h case    2:*/		return 0x820A2C3C;
	}
	return 0x820A2C3C;
} // Block from 820A2C30h-820A2C3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A2C3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2C3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2C3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2C3C);
		  /* 820A2C3Ch */ case    0:  		/* li R5, 1 */
		/* 820A2C3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A2C3Ch case    0:*/		return 0x820A2C40;
		  /* 820A2C40h */ case    1:  		/* mr R4, R29 */
		/* 820A2C40h case    1:*/		regs.R4 = regs.R29;
		/* 820A2C40h case    1:*/		return 0x820A2C44;
		  /* 820A2C44h */ case    2:  		/* mr R3, R7 */
		/* 820A2C44h case    2:*/		regs.R3 = regs.R7;
		/* 820A2C44h case    2:*/		return 0x820A2C48;
		  /* 820A2C48h */ case    3:  		/* bl 156824 */
		/* 820A2C48h case    3:*/		regs.LR = 0x820A2C4C; return 0x820C90E0;
		/* 820A2C48h case    3:*/		return 0x820A2C4C;
		  /* 820A2C4Ch */ case    4:  		/* mr R31, R3 */
		/* 820A2C4Ch case    4:*/		regs.R31 = regs.R3;
		/* 820A2C4Ch case    4:*/		return 0x820A2C50;
		  /* 820A2C50h */ case    5:  		/* cmplwi CR6, R28, 0 */
		/* 820A2C50h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820A2C50h case    5:*/		return 0x820A2C54;
		  /* 820A2C54h */ case    6:  		/* bc 12, CR6_EQ, 108 */
		/* 820A2C54h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A2CC0;  }
		/* 820A2C54h case    6:*/		return 0x820A2C58;
		  /* 820A2C58h */ case    7:  		/* li R8, 34 */
		/* 820A2C58h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x22);
		/* 820A2C58h case    7:*/		return 0x820A2C5C;
		  /* 820A2C5Ch */ case    8:  		/* addi R11, R3, 1 */
		/* 820A2C5Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 820A2C5Ch case    8:*/		return 0x820A2C60;
		  /* 820A2C60h */ case    9:  		/* stb R8, <#[R3]> */
		/* 820A2C60h case    9:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820A2C60h case    9:*/		return 0x820A2C64;
		  /* 820A2C64h */ case   10:  		/* mr R10, R30 */
		/* 820A2C64h case   10:*/		regs.R10 = regs.R30;
		/* 820A2C64h case   10:*/		return 0x820A2C68;
		  /* 820A2C68h */ case   11:  		/* lbz R9, <#[R30]> */
		/* 820A2C68h case   11:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 820A2C68h case   11:*/		return 0x820A2C6C;
		  /* 820A2C6Ch */ case   12:  		/* b 68 */
		/* 820A2C6Ch case   12:*/		return 0x820A2CB0;
		/* 820A2C6Ch case   12:*/		return 0x820A2C70;
		  /* 820A2C70h */ case   13:  		/* lbz R9, <#[R10]> */
		/* 820A2C70h case   13:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820A2C70h case   13:*/		return 0x820A2C74;
		  /* 820A2C74h */ case   14:  		/* cmplwi CR6, R9, 9 */
		/* 820A2C74h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000009);
		/* 820A2C74h case   14:*/		return 0x820A2C78;
		  /* 820A2C78h */ case   15:  		/* bc 12, CR6_LT, 40 */
		/* 820A2C78h case   15:*/		if ( regs.CR[6].lt ) { return 0x820A2CA0;  }
		/* 820A2C78h case   15:*/		return 0x820A2C7C;
		  /* 820A2C7Ch */ case   16:  		/* cmplwi CR6, R9, 10 */
		/* 820A2C7Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000A);
		/* 820A2C7Ch case   16:*/		return 0x820A2C80;
		  /* 820A2C80h */ case   17:  		/* bc 4, CR6_GT, 20 */
		/* 820A2C80h case   17:*/		if ( !regs.CR[6].gt ) { return 0x820A2C94;  }
		/* 820A2C80h case   17:*/		return 0x820A2C84;
		  /* 820A2C84h */ case   18:  		/* cmplwi CR6, R9, 13 */
		/* 820A2C84h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000D);
		/* 820A2C84h case   18:*/		return 0x820A2C88;
		  /* 820A2C88h */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 820A2C88h case   19:*/		if ( regs.CR[6].eq ) { return 0x820A2C94;  }
		/* 820A2C88h case   19:*/		return 0x820A2C8C;
		  /* 820A2C8Ch */ case   20:  		/* cmplwi CR6, R9, 92 */
		/* 820A2C8Ch case   20:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000005C);
		/* 820A2C8Ch case   20:*/		return 0x820A2C90;
		  /* 820A2C90h */ case   21:  		/* bc 4, CR6_EQ, 16 */
		/* 820A2C90h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820A2CA0;  }
		/* 820A2C90h case   21:*/		return 0x820A2C94;
	}
	return 0x820A2C94;
} // Block from 820A2C3Ch-820A2C94h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820A2C94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2C94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2C94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2C94);
		  /* 820A2C94h */ case    0:  		/* li R9, 92 */
		/* 820A2C94h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x5C);
		/* 820A2C94h case    0:*/		return 0x820A2C98;
		  /* 820A2C98h */ case    1:  		/* stb R9, <#[R11]> */
		/* 820A2C98h case    1:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A2C98h case    1:*/		return 0x820A2C9C;
		  /* 820A2C9Ch */ case    2:  		/* addi R11, R11, 1 */
		/* 820A2C9Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A2C9Ch case    2:*/		return 0x820A2CA0;
	}
	return 0x820A2CA0;
} // Block from 820A2C94h-820A2CA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A2CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2CA0);
		  /* 820A2CA0h */ case    0:  		/* lbz R9, <#[R10]> */
		/* 820A2CA0h case    0:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820A2CA0h case    0:*/		return 0x820A2CA4;
		  /* 820A2CA4h */ case    1:  		/* stb R9, <#[R11]> */
		/* 820A2CA4h case    1:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A2CA4h case    1:*/		return 0x820A2CA8;
		  /* 820A2CA8h */ case    2:  		/* addi R11, R11, 1 */
		/* 820A2CA8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A2CA8h case    2:*/		return 0x820A2CAC;
		  /* 820A2CACh */ case    3:  		/* lbzu R9, <#[R10 + 1]> */
		/* 820A2CACh case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000001) );
		regs.R10 = (uint32)(regs.R10 + 0x00000001);
		/* 820A2CACh case    3:*/		return 0x820A2CB0;
	}
	return 0x820A2CB0;
} // Block from 820A2CA0h-820A2CB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A2CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2CB0);
		  /* 820A2CB0h */ case    0:  		/* cmplwi CR0, R9, 0 */
		/* 820A2CB0h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820A2CB0h case    0:*/		return 0x820A2CB4;
		  /* 820A2CB4h */ case    1:  		/* bc 4, CR0_EQ, -68 */
		/* 820A2CB4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A2C70;  }
		/* 820A2CB4h case    1:*/		return 0x820A2CB8;
		  /* 820A2CB8h */ case    2:  		/* stb R8, <#[R11]> */
		/* 820A2CB8h case    2:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A2CB8h case    2:*/		return 0x820A2CBC;
		  /* 820A2CBCh */ case    3:  		/* b 20 */
		/* 820A2CBCh case    3:*/		return 0x820A2CD0;
		/* 820A2CBCh case    3:*/		return 0x820A2CC0;
	}
	return 0x820A2CC0;
} // Block from 820A2CB0h-820A2CC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A2CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2CC0);
		  /* 820A2CC0h */ case    0:  		/* mr R5, R29 */
		/* 820A2CC0h case    0:*/		regs.R5 = regs.R29;
		/* 820A2CC0h case    0:*/		return 0x820A2CC4;
		  /* 820A2CC4h */ case    1:  		/* mr R4, R30 */
		/* 820A2CC4h case    1:*/		regs.R4 = regs.R30;
		/* 820A2CC4h case    1:*/		return 0x820A2CC8;
		  /* 820A2CC8h */ case    2:  		/* mr R3, R31 */
		/* 820A2CC8h case    2:*/		regs.R3 = regs.R31;
		/* 820A2CC8h case    2:*/		return 0x820A2CCC;
		  /* 820A2CCCh */ case    3:  		/* bl -70428 */
		/* 820A2CCCh case    3:*/		regs.LR = 0x820A2CD0; return 0x820919B0;
		/* 820A2CCCh case    3:*/		return 0x820A2CD0;
	}
	return 0x820A2CD0;
} // Block from 820A2CC0h-820A2CD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A2CD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2CD0);
		  /* 820A2CD0h */ case    0:  		/* stw R31, <#[R27 + 32]> */
		/* 820A2CD0h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R27 + 0x00000020) );
		/* 820A2CD0h case    0:*/		return 0x820A2CD4;
		  /* 820A2CD4h */ case    1:  		/* li R11, 0 */
		/* 820A2CD4h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A2CD4h case    1:*/		return 0x820A2CD8;
		  /* 820A2CD8h */ case    2:  		/* stw R29, <#[R27 + 36]> */
		/* 820A2CD8h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + 0x00000024) );
		/* 820A2CD8h case    2:*/		return 0x820A2CDC;
	}
	return 0x820A2CDC;
} // Block from 820A2CD0h-820A2CDCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A2CDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2CDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2CDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2CDC);
		  /* 820A2CDCh */ case    0:  		/* mr R3, R11 */
		/* 820A2CDCh case    0:*/		regs.R3 = regs.R11;
		/* 820A2CDCh case    0:*/		return 0x820A2CE0;
	}
	return 0x820A2CE0;
} // Block from 820A2CDCh-820A2CE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A2CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2CE0);
		  /* 820A2CE0h */ case    0:  		/* addi R1, R1, 144 */
		/* 820A2CE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820A2CE0h case    0:*/		return 0x820A2CE4;
		  /* 820A2CE4h */ case    1:  		/* b -72256 */
		/* 820A2CE4h case    1:*/		return 0x820912A4;
		/* 820A2CE4h case    1:*/		return 0x820A2CE8;
	}
	return 0x820A2CE8;
} // Block from 820A2CE0h-820A2CE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A2CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2CE8);
		  /* 820A2CE8h */ case    0:  		/* mfspr R12, LR */
		/* 820A2CE8h case    0:*/		regs.R12 = regs.LR;
		/* 820A2CE8h case    0:*/		return 0x820A2CEC;
		  /* 820A2CECh */ case    1:  		/* bl -72336 */
		/* 820A2CECh case    1:*/		regs.LR = 0x820A2CF0; return 0x8209125C;
		/* 820A2CECh case    1:*/		return 0x820A2CF0;
		  /* 820A2CF0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820A2CF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820A2CF0h case    2:*/		return 0x820A2CF4;
		  /* 820A2CF4h */ case    3:  		/* lis R11, -32255 */
		/* 820A2CF4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A2CF4h case    3:*/		return 0x820A2CF8;
		  /* 820A2CF8h */ case    4:  		/* mr R29, R3 */
		/* 820A2CF8h case    4:*/		regs.R29 = regs.R3;
		/* 820A2CF8h case    4:*/		return 0x820A2CFC;
		  /* 820A2CFCh */ case    5:  		/* mr R30, R4 */
		/* 820A2CFCh case    5:*/		regs.R30 = regs.R4;
		/* 820A2CFCh case    5:*/		return 0x820A2D00;
		  /* 820A2D00h */ case    6:  		/* mr R6, R5 */
		/* 820A2D00h case    6:*/		regs.R6 = regs.R5;
		/* 820A2D00h case    6:*/		return 0x820A2D04;
		  /* 820A2D04h */ case    7:  		/* li R4, 32 */
		/* 820A2D04h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 820A2D04h case    7:*/		return 0x820A2D08;
		  /* 820A2D08h */ case    8:  		/* addi R5, R11, -10436 */
		/* 820A2D08h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFD73C);
		/* 820A2D08h case    8:*/		return 0x820A2D0C;
		  /* 820A2D0Ch */ case    9:  		/* addi R3, R1, 96 */
		/* 820A2D0Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820A2D0Ch case    9:*/		return 0x820A2D10;
	}
	return 0x820A2D10;
} // Block from 820A2CE8h-820A2D10h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A2D10h
// Function '?AddDefine@CPreProcessor@D3DXShader@@IAAJPAVCPPDefine@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2D10);
		  /* 820A2D10h */ case    0:  		/* bl -1744 */
		/* 820A2D10h case    0:*/		regs.LR = 0x820A2D14; return 0x820A2640;
		/* 820A2D10h case    0:*/		return 0x820A2D14;
		  /* 820A2D14h */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 820A2D14h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A2D14h case    1:*/		return 0x820A2D18;
		  /* 820A2D18h */ case    2:  		/* bc 12, CR0_LT, 120 */
		/* 820A2D18h case    2:*/		if ( regs.CR[0].lt ) { return 0x820A2D90;  }
		/* 820A2D18h case    2:*/		return 0x820A2D1C;
		  /* 820A2D1Ch */ case    3:  		/* li R11, 31 */
		/* 820A2D1Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1F);
		/* 820A2D1Ch case    3:*/		return 0x820A2D20;
		  /* 820A2D20h */ case    4:  		/* addi R10, R1, 96 */
		/* 820A2D20h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 820A2D20h case    4:*/		return 0x820A2D24;
		  /* 820A2D24h */ case    5:  		/* li R3, 0 */
		/* 820A2D24h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A2D24h case    5:*/		return 0x820A2D28;
		  /* 820A2D28h */ case    6:  		/* lbz R9, <#[R10]> */
		/* 820A2D28h case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820A2D28h case    6:*/		return 0x820A2D2C;
		  /* 820A2D2Ch */ case    7:  		/* cmplwi CR0, R9, 0 */
		/* 820A2D2Ch case    7:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820A2D2Ch case    7:*/		return 0x820A2D30;
		  /* 820A2D30h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 820A2D30h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A2D40;  }
		/* 820A2D30h case    8:*/		return 0x820A2D34;
		  /* 820A2D34h */ case    9:  		/* addic. R11, R11, -1 */
		/* 820A2D34h case    9:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A2D34h case    9:*/		return 0x820A2D38;
		  /* 820A2D38h */ case   10:  		/* addi R10, R10, 1 */
		/* 820A2D38h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A2D38h case   10:*/		return 0x820A2D3C;
		  /* 820A2D3Ch */ case   11:  		/* bc 4, CR0_EQ, -20 */
		/* 820A2D3Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x820A2D28;  }
		/* 820A2D3Ch case   11:*/		return 0x820A2D40;
	}
	return 0x820A2D40;
} // Block from 820A2D10h-820A2D40h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A2D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2D40);
		  /* 820A2D40h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820A2D40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A2D40h case    0:*/		return 0x820A2D44;
		  /* 820A2D44h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 820A2D44h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A2D58;  }
		/* 820A2D44h case    1:*/		return 0x820A2D48;
		  /* 820A2D48h */ case    2:  		/* lis R3, -32761 */
		/* 820A2D48h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A2D48h case    2:*/		return 0x820A2D4C;
		  /* 820A2D4Ch */ case    3:  		/* lwz R31, <#[R1 + 80]> */
		/* 820A2D4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 820A2D4Ch case    3:*/		return 0x820A2D50;
		  /* 820A2D50h */ case    4:  		/* ori R3, R3, 87 */
		/* 820A2D50h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x57);
		/* 820A2D50h case    4:*/		return 0x820A2D54;
		  /* 820A2D54h */ case    5:  		/* b 8 */
		/* 820A2D54h case    5:*/		return 0x820A2D5C;
		/* 820A2D54h case    5:*/		return 0x820A2D58;
	}
	return 0x820A2D58;
} // Block from 820A2D40h-820A2D58h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A2D58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2D58);
		  /* 820A2D58h */ case    0:  		/* subfic R31, R11, 31 */
		/* 820A2D58h case    0:*/		cpu::op::subfic<0>(regs,&regs.R31,regs.R11,0x1F);
		/* 820A2D58h case    0:*/		return 0x820A2D5C;
	}
	return 0x820A2D5C;
} // Block from 820A2D58h-820A2D5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A2D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2D5C);
		  /* 820A2D5Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820A2D5Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820A2D5Ch case    0:*/		return 0x820A2D60;
		  /* 820A2D60h */ case    1:  		/* bc 12, CR6_LT, 48 */
		/* 820A2D60h case    1:*/		if ( regs.CR[6].lt ) { return 0x820A2D90;  }
		/* 820A2D60h case    1:*/		return 0x820A2D64;
		  /* 820A2D64h */ case    2:  		/* li R5, 1 */
		/* 820A2D64h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A2D64h case    2:*/		return 0x820A2D68;
		  /* 820A2D68h */ case    3:  		/* mr R4, R31 */
		/* 820A2D68h case    3:*/		regs.R4 = regs.R31;
		/* 820A2D68h case    3:*/		return 0x820A2D6C;
		  /* 820A2D6Ch */ case    4:  		/* mr R3, R29 */
		/* 820A2D6Ch case    4:*/		regs.R3 = regs.R29;
		/* 820A2D6Ch case    4:*/		return 0x820A2D70;
		  /* 820A2D70h */ case    5:  		/* bl 156528 */
		/* 820A2D70h case    5:*/		regs.LR = 0x820A2D74; return 0x820C90E0;
		/* 820A2D70h case    5:*/		return 0x820A2D74;
		  /* 820A2D74h */ case    6:  		/* mr R5, R31 */
		/* 820A2D74h case    6:*/		regs.R5 = regs.R31;
		/* 820A2D74h case    6:*/		return 0x820A2D78;
		  /* 820A2D78h */ case    7:  		/* addi R4, R1, 96 */
		/* 820A2D78h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820A2D78h case    7:*/		return 0x820A2D7C;
		  /* 820A2D7Ch */ case    8:  		/* mr R29, R3 */
		/* 820A2D7Ch case    8:*/		regs.R29 = regs.R3;
		/* 820A2D7Ch case    8:*/		return 0x820A2D80;
		  /* 820A2D80h */ case    9:  		/* bl -70608 */
		/* 820A2D80h case    9:*/		regs.LR = 0x820A2D84; return 0x820919B0;
		/* 820A2D80h case    9:*/		return 0x820A2D84;
		  /* 820A2D84h */ case   10:  		/* stw R29, <#[R30 + 32]> */
		/* 820A2D84h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000020) );
		/* 820A2D84h case   10:*/		return 0x820A2D88;
		  /* 820A2D88h */ case   11:  		/* stw R31, <#[R30 + 36]> */
		/* 820A2D88h case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000024) );
		/* 820A2D88h case   11:*/		return 0x820A2D8C;
		  /* 820A2D8Ch */ case   12:  		/* li R3, 0 */
		/* 820A2D8Ch case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A2D8Ch case   12:*/		return 0x820A2D90;
	}
	return 0x820A2D90;
} // Block from 820A2D5Ch-820A2D90h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A2D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2D90);
		  /* 820A2D90h */ case    0:  		/* addi R1, R1, 160 */
		/* 820A2D90h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820A2D90h case    0:*/		return 0x820A2D94;
		  /* 820A2D94h */ case    1:  		/* b -72424 */
		/* 820A2D94h case    1:*/		return 0x820912AC;
		/* 820A2D94h case    1:*/		return 0x820A2D98;
	}
	return 0x820A2D98;
} // Block from 820A2D90h-820A2D98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A2D98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2D98);
		  /* 820A2D98h */ case    0:  		/* mfspr R12, LR */
		/* 820A2D98h case    0:*/		regs.R12 = regs.LR;
		/* 820A2D98h case    0:*/		return 0x820A2D9C;
		  /* 820A2D9Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A2D9Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A2D9Ch case    1:*/		return 0x820A2DA0;
		  /* 820A2DA0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A2DA0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A2DA0h case    2:*/		return 0x820A2DA4;
		  /* 820A2DA4h */ case    3:  		/* stwu R1, <#[R1 - 352]> */
		/* 820A2DA4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEA0);
		/* 820A2DA4h case    3:*/		return 0x820A2DA8;
		  /* 820A2DA8h */ case    4:  		/* lwz R11, <#[R3 + 1652]> */
		/* 820A2DA8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000674) );
		/* 820A2DA8h case    4:*/		return 0x820A2DAC;
		  /* 820A2DACh */ case    5:  		/* li R10, 1 */
		/* 820A2DACh case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820A2DACh case    5:*/		return 0x820A2DB0;
		  /* 820A2DB0h */ case    6:  		/* mr R31, R3 */
		/* 820A2DB0h case    6:*/		regs.R31 = regs.R3;
		/* 820A2DB0h case    6:*/		return 0x820A2DB4;
		  /* 820A2DB4h */ case    7:  		/* mr R6, R5 */
		/* 820A2DB4h case    7:*/		regs.R6 = regs.R5;
		/* 820A2DB4h case    7:*/		return 0x820A2DB8;
		  /* 820A2DB8h */ case    8:  		/* stw R10, <#[R3 + 1640]> */
		/* 820A2DB8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000668) );
		/* 820A2DB8h case    8:*/		return 0x820A2DBC;
		  /* 820A2DBCh */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 820A2DBCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A2DBCh case    9:*/		return 0x820A2DC0;
		  /* 820A2DC0h */ case   10:  		/* bc 12, CR6_EQ, 172 */
		/* 820A2DC0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A2E6C;  }
		/* 820A2DC0h case   10:*/		return 0x820A2DC4;
		  /* 820A2DC4h */ case   11:  		/* lis R10, -32255 */
		/* 820A2DC4h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A2DC4h case   11:*/		return 0x820A2DC8;
		  /* 820A2DC8h */ case   12:  		/* mr R11, R4 */
		/* 820A2DC8h case   12:*/		regs.R11 = regs.R4;
		/* 820A2DC8h case   12:*/		return 0x820A2DCC;
		  /* 820A2DCCh */ case   13:  		/* addi R10, R10, -10392 */
		/* 820A2DCCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD768);
		/* 820A2DCCh case   13:*/		return 0x820A2DD0;
		  /* 820A2DD0h */ case   14:  		/* lbz R9, <#[R11]> */
		/* 820A2DD0h case   14:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A2DD0h case   14:*/		return 0x820A2DD4;
		  /* 820A2DD4h */ case   15:  		/* lbz R8, <#[R10]> */
		/* 820A2DD4h case   15:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A2DD4h case   15:*/		return 0x820A2DD8;
		  /* 820A2DD8h */ case   16:  		/* cmpwi CR0, R9, 0 */
		/* 820A2DD8h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A2DD8h case   16:*/		return 0x820A2DDC;
		  /* 820A2DDCh */ case   17:  		/* subf R9, R8, R9 */
		/* 820A2DDCh case   17:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A2DDCh case   17:*/		return 0x820A2DE0;
		  /* 820A2DE0h */ case   18:  		/* bc 12, CR0_EQ, 20 */
		/* 820A2DE0h case   18:*/		if ( regs.CR[0].eq ) { return 0x820A2DF4;  }
		/* 820A2DE0h case   18:*/		return 0x820A2DE4;
		  /* 820A2DE4h */ case   19:  		/* addi R11, R11, 1 */
		/* 820A2DE4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A2DE4h case   19:*/		return 0x820A2DE8;
		  /* 820A2DE8h */ case   20:  		/* addi R10, R10, 1 */
		/* 820A2DE8h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A2DE8h case   20:*/		return 0x820A2DEC;
		  /* 820A2DECh */ case   21:  		/* cmpwi CR6, R9, 0 */
		/* 820A2DECh case   21:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A2DECh case   21:*/		return 0x820A2DF0;
		  /* 820A2DF0h */ case   22:  		/* bc 12, CR6_EQ, -32 */
		/* 820A2DF0h case   22:*/		if ( regs.CR[6].eq ) { return 0x820A2DD0;  }
		/* 820A2DF0h case   22:*/		return 0x820A2DF4;
	}
	return 0x820A2DF4;
} // Block from 820A2D98h-820A2DF4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820A2DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2DF4);
		  /* 820A2DF4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A2DF4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A2DF4h case    0:*/		return 0x820A2DF8;
		  /* 820A2DF8h */ case    1:  		/* bc 4, CR0_EQ, 72 */
		/* 820A2DF8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A2E40;  }
		/* 820A2DF8h case    1:*/		return 0x820A2DFC;
		  /* 820A2DFCh */ case    2:  		/* lwz R11, <#[R31 + 1648]> */
		/* 820A2DFCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000670) );
		/* 820A2DFCh case    2:*/		return 0x820A2E00;
	}
	return 0x820A2E00;
} // Block from 820A2DF4h-820A2E00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A2E00h
// Function '?AddDefine@CPreProcessor@D3DXShader@@QAAJPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2E00);
		  /* 820A2E00h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 820A2E00h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A2E00h case    0:*/		return 0x820A2E04;
		  /* 820A2E04h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820A2E04h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A2E2C;  }
		/* 820A2E04h case    1:*/		return 0x820A2E08;
		  /* 820A2E08h */ case    2:  		/* lwz R11, <#[R31 + 2216]> */
		/* 820A2E08h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000008A8) );
		/* 820A2E08h case    2:*/		return 0x820A2E0C;
		  /* 820A2E0Ch */ case    3:  		/* addi R4, R31, 2216 */
		/* 820A2E0Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x8A8);
		/* 820A2E0Ch case    3:*/		return 0x820A2E10;
		  /* 820A2E10h */ case    4:  		/* cmpwi CR6, R11, 11 */
		/* 820A2E10h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820A2E10h case    4:*/		return 0x820A2E14;
		  /* 820A2E14h */ case    5:  		/* bc 4, CR6_EQ, 24 */
		/* 820A2E14h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A2E2C;  }
		/* 820A2E14h case    5:*/		return 0x820A2E18;
		  /* 820A2E18h */ case    6:  		/* lis R11, -32255 */
		/* 820A2E18h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A2E18h case    6:*/		return 0x820A2E1C;
		  /* 820A2E1Ch */ case    7:  		/* lwz R7, <#[R31 + 2224]> */
		/* 820A2E1Ch case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x000008B0) );
		/* 820A2E1Ch case    7:*/		return 0x820A2E20;
		  /* 820A2E20h */ case    8:  		/* li R5, 1504 */
		/* 820A2E20h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x5E0);
		/* 820A2E20h case    8:*/		return 0x820A2E24;
		  /* 820A2E24h */ case    9:  		/* addi R6, R11, -10428 */
		/* 820A2E24h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD744);
		/* 820A2E24h case    9:*/		return 0x820A2E28;
		  /* 820A2E28h */ case   10:  		/* b 60 */
		/* 820A2E28h case   10:*/		return 0x820A2E64;
		/* 820A2E28h case   10:*/		return 0x820A2E2C;
	}
	return 0x820A2E2C;
} // Block from 820A2E00h-820A2E2Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A2E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2E2C);
		  /* 820A2E2Ch */ case    0:  		/* addi R5, R31, 2216 */
		/* 820A2E2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x8A8);
		/* 820A2E2Ch case    0:*/		return 0x820A2E30;
		  /* 820A2E30h */ case    1:  		/* li R4, 1500 */
		/* 820A2E30h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x5DC);
		/* 820A2E30h case    1:*/		return 0x820A2E34;
		  /* 820A2E34h */ case    2:  		/* addi R3, R31, 24 */
		/* 820A2E34h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A2E34h case    2:*/		return 0x820A2E38;
		  /* 820A2E38h */ case    3:  		/* bl 17768 */
		/* 820A2E38h case    3:*/		regs.LR = 0x820A2E3C; return 0x820A73A0;
		/* 820A2E38h case    3:*/		return 0x820A2E3C;
		  /* 820A2E3Ch */ case    4:  		/* b 48 */
		/* 820A2E3Ch case    4:*/		return 0x820A2E6C;
		/* 820A2E3Ch case    4:*/		return 0x820A2E40;
	}
	return 0x820A2E40;
} // Block from 820A2E2Ch-820A2E40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A2E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2E40);
		  /* 820A2E40h */ case    0:  		/* mr R5, R4 */
		/* 820A2E40h case    0:*/		regs.R5 = regs.R4;
		/* 820A2E40h case    0:*/		return 0x820A2E44;
		  /* 820A2E44h */ case    1:  		/* li R4, 256 */
		/* 820A2E44h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 820A2E44h case    1:*/		return 0x820A2E48;
		  /* 820A2E48h */ case    2:  		/* addi R3, R1, 80 */
		/* 820A2E48h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820A2E48h case    2:*/		return 0x820A2E4C;
		  /* 820A2E4Ch */ case    3:  		/* bl -16228 */
		/* 820A2E4Ch case    3:*/		regs.LR = 0x820A2E50; return 0x8209EEE8;
		/* 820A2E4Ch case    3:*/		return 0x820A2E50;
		  /* 820A2E50h */ case    4:  		/* lis R11, -32255 */
		/* 820A2E50h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A2E50h case    4:*/		return 0x820A2E54;
		  /* 820A2E54h */ case    5:  		/* addi R7, R1, 80 */
		/* 820A2E54h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820A2E54h case    5:*/		return 0x820A2E58;
		  /* 820A2E58h */ case    6:  		/* addi R6, R11, -10432 */
		/* 820A2E58h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD740);
		/* 820A2E58h case    6:*/		return 0x820A2E5C;
		  /* 820A2E5Ch */ case    7:  		/* li R5, 0 */
		/* 820A2E5Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A2E5Ch case    7:*/		return 0x820A2E60;
		  /* 820A2E60h */ case    8:  		/* addi R4, R31, 2216 */
		/* 820A2E60h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x8A8);
		/* 820A2E60h case    8:*/		return 0x820A2E64;
	}
	return 0x820A2E64;
} // Block from 820A2E40h-820A2E64h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A2E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2E64);
		  /* 820A2E64h */ case    0:  		/* addi R3, R31, 24 */
		/* 820A2E64h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A2E64h case    0:*/		return 0x820A2E68;
		  /* 820A2E68h */ case    1:  		/* bl 17192 */
		/* 820A2E68h case    1:*/		regs.LR = 0x820A2E6C; return 0x820A7190;
		/* 820A2E68h case    1:*/		return 0x820A2E6C;
	}
	return 0x820A2E6C;
} // Block from 820A2E64h-820A2E6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A2E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2E6C);
		  /* 820A2E6Ch */ case    0:  		/* addi R1, R1, 352 */
		/* 820A2E6Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x160);
		/* 820A2E6Ch case    0:*/		return 0x820A2E70;
		  /* 820A2E70h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A2E70h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A2E70h case    1:*/		return 0x820A2E74;
		  /* 820A2E74h */ case    2:  		/* mtspr LR, R12 */
		/* 820A2E74h case    2:*/		regs.LR = regs.R12;
		/* 820A2E74h case    2:*/		return 0x820A2E78;
		  /* 820A2E78h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A2E78h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A2E78h case    3:*/		return 0x820A2E7C;
		  /* 820A2E7Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A2E7Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A2E7Ch case    4:*/		return 0x820A2E80;
	}
	return 0x820A2E80;
} // Block from 820A2E6Ch-820A2E80h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A2E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2E80);
		  /* 820A2E80h */ case    0:  		/* mfspr R12, LR */
		/* 820A2E80h case    0:*/		regs.R12 = regs.LR;
		/* 820A2E80h case    0:*/		return 0x820A2E84;
		  /* 820A2E84h */ case    1:  		/* bl -72772 */
		/* 820A2E84h case    1:*/		regs.LR = 0x820A2E88; return 0x82091240;
		/* 820A2E84h case    1:*/		return 0x820A2E88;
		  /* 820A2E88h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820A2E88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820A2E88h case    2:*/		return 0x820A2E8C;
		  /* 820A2E8Ch */ case    3:  		/* mr R30, R3 */
		/* 820A2E8Ch case    3:*/		regs.R30 = regs.R3;
		/* 820A2E8Ch case    3:*/		return 0x820A2E90;
	}
	return 0x820A2E90;
} // Block from 820A2E80h-820A2E90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A2E90h
// Function '?AddDefine@CPreProcessor@D3DXShader@@QAAJPBDI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2E90);
		  /* 820A2E90h */ case    0:  		/* mr R31, R4 */
		/* 820A2E90h case    0:*/		regs.R31 = regs.R4;
		/* 820A2E90h case    0:*/		return 0x820A2E94;
		  /* 820A2E94h */ case    1:  		/* lis R4, 9345 */
		/* 820A2E94h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A2E94h case    1:*/		return 0x820A2E98;
		  /* 820A2E98h */ case    2:  		/* li R3, 20 */
		/* 820A2E98h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A2E98h case    2:*/		return 0x820A2E9C;
		  /* 820A2E9Ch */ case    3:  		/* mr R29, R5 */
		/* 820A2E9Ch case    3:*/		regs.R29 = regs.R5;
		/* 820A2E9Ch case    3:*/		return 0x820A2EA0;
		  /* 820A2EA0h */ case    4:  		/* mr R22, R6 */
		/* 820A2EA0h case    4:*/		regs.R22 = regs.R6;
		/* 820A2EA0h case    4:*/		return 0x820A2EA4;
		  /* 820A2EA4h */ case    5:  		/* bl -109732 */
		/* 820A2EA4h case    5:*/		regs.LR = 0x820A2EA8; return 0x82088200;
		/* 820A2EA4h case    5:*/		return 0x820A2EA8;
		  /* 820A2EA8h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820A2EA8h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A2EA8h case    6:*/		return 0x820A2EAC;
		  /* 820A2EACh */ case    7:  		/* li R23, 0 */
		/* 820A2EACh case    7:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820A2EACh case    7:*/		return 0x820A2EB0;
		  /* 820A2EB0h */ case    8:  		/* bc 12, CR0_EQ, 36 */
		/* 820A2EB0h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A2ED4;  }
		/* 820A2EB0h case    8:*/		return 0x820A2EB4;
		  /* 820A2EB4h */ case    9:  		/* stw R31, <#[R3]> */
		/* 820A2EB4h case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 820A2EB4h case    9:*/		return 0x820A2EB8;
		  /* 820A2EB8h */ case   10:  		/* mr R24, R3 */
		/* 820A2EB8h case   10:*/		regs.R24 = regs.R3;
		/* 820A2EB8h case   10:*/		return 0x820A2EBC;
		  /* 820A2EBCh */ case   11:  		/* stw R23, <#[R3 + 4]> */
		/* 820A2EBCh case   11:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000004) );
		/* 820A2EBCh case   11:*/		return 0x820A2EC0;
		  /* 820A2EC0h */ case   12:  		/* stw R23, <#[R3 + 8]> */
		/* 820A2EC0h case   12:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000008) );
		/* 820A2EC0h case   12:*/		return 0x820A2EC4;
		  /* 820A2EC4h */ case   13:  		/* stw R23, <#[R3 + 12]> */
		/* 820A2EC4h case   13:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A2EC4h case   13:*/		return 0x820A2EC8;
		  /* 820A2EC8h */ case   14:  		/* stb R23, <#[R3 + 16]> */
		/* 820A2EC8h case   14:*/		cpu::mem::store8( regs, regs.R23, (uint32)(regs.R3 + 0x00000010) );
		/* 820A2EC8h case   14:*/		return 0x820A2ECC;
		  /* 820A2ECCh */ case   15:  		/* stb R23, <#[R3 + 17]> */
		/* 820A2ECCh case   15:*/		cpu::mem::store8( regs, regs.R23, (uint32)(regs.R3 + 0x00000011) );
		/* 820A2ECCh case   15:*/		return 0x820A2ED0;
		  /* 820A2ED0h */ case   16:  		/* b 8 */
		/* 820A2ED0h case   16:*/		return 0x820A2ED8;
		/* 820A2ED0h case   16:*/		return 0x820A2ED4;
	}
	return 0x820A2ED4;
} // Block from 820A2E90h-820A2ED4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A2ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2ED4);
		  /* 820A2ED4h */ case    0:  		/* mr R24, R23 */
		/* 820A2ED4h case    0:*/		regs.R24 = regs.R23;
		/* 820A2ED4h case    0:*/		return 0x820A2ED8;
	}
	return 0x820A2ED8;
} // Block from 820A2ED4h-820A2ED8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A2ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2ED8);
		  /* 820A2ED8h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 820A2ED8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820A2ED8h case    0:*/		return 0x820A2EDC;
		  /* 820A2EDCh */ case    1:  		/* bc 12, CR6_EQ, 740 */
		/* 820A2EDCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820A31C0;  }
		/* 820A2EDCh case    1:*/		return 0x820A2EE0;
		  /* 820A2EE0h */ case    2:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 820A2EE0h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 820A2EE0h case    2:*/		return 0x820A2EE4;
		  /* 820A2EE4h */ case    3:  		/* bc 12, CR0_EQ, 484 */
		/* 820A2EE4h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A30C8;  }
		/* 820A2EE4h case    3:*/		return 0x820A2EE8;
		  /* 820A2EE8h */ case    4:  		/* lwz R3, <#[R30 + 2204]> */
		/* 820A2EE8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000089C) );
		/* 820A2EE8h case    4:*/		return 0x820A2EEC;
		  /* 820A2EECh */ case    5:  		/* lwz R11, <#[R3]> */
		/* 820A2EECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A2EECh case    5:*/		return 0x820A2EF0;
		  /* 820A2EF0h */ case    6:  		/* lwz R10, <#[R3 + 8]> */
		/* 820A2EF0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820A2EF0h case    6:*/		return 0x820A2EF4;
		  /* 820A2EF4h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820A2EF4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A2EF4h case    7:*/		return 0x820A2EF8;
		  /* 820A2EF8h */ case    8:  		/* bc 4, CR6_LT, 464 */
		/* 820A2EF8h case    8:*/		if ( !regs.CR[6].lt ) { return 0x820A30C8;  }
		/* 820A2EF8h case    8:*/		return 0x820A2EFC;
		  /* 820A2EFCh */ case    9:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820A2EFCh case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820A2EFCh case    9:*/		return 0x820A2F00;
		  /* 820A2F00h */ case   10:  		/* lbz R11, <#[R11]> */
		/* 820A2F00h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A2F00h case   10:*/		return 0x820A2F04;
		  /* 820A2F04h */ case   11:  		/* cmplwi CR6, R11, 40 */
		/* 820A2F04h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000028);
		/* 820A2F04h case   11:*/		return 0x820A2F08;
		  /* 820A2F08h */ case   12:  		/* bc 4, CR6_EQ, 448 */
		/* 820A2F08h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A30C8;  }
		/* 820A2F08h case   12:*/		return 0x820A2F0C;
		  /* 820A2F0Ch */ case   13:  		/* addi R28, R30, 2216 */
		/* 820A2F0Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R30,0x8A8);
		/* 820A2F0Ch case   13:*/		return 0x820A2F10;
		  /* 820A2F10h */ case   14:  		/* lwz R4, <#[R30 + 2256]> */
		/* 820A2F10h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000008D0) );
		/* 820A2F10h case   14:*/		return 0x820A2F14;
		  /* 820A2F14h */ case   15:  		/* addi R26, R24, 4 */
		/* 820A2F14h case   15:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R24,0x4);
		/* 820A2F14h case   15:*/		return 0x820A2F18;
		  /* 820A2F18h */ case   16:  		/* mr R5, R28 */
		/* 820A2F18h case   16:*/		regs.R5 = regs.R28;
		/* 820A2F18h case   16:*/		return 0x820A2F1C;
		  /* 820A2F1Ch */ case   17:  		/* mr R29, R26 */
		/* 820A2F1Ch case   17:*/		regs.R29 = regs.R26;
		/* 820A2F1Ch case   17:*/		return 0x820A2F20;
		  /* 820A2F20h */ case   18:  		/* bl 21208 */
		/* 820A2F20h case   18:*/		regs.LR = 0x820A2F24; return 0x820A81F8;
		/* 820A2F20h case   18:*/		return 0x820A2F24;
		  /* 820A2F24h */ case   19:  		/* or. R31, R3, R3 */
		/* 820A2F24h case   19:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A2F24h case   19:*/		return 0x820A2F28;
		  /* 820A2F28h */ case   20:  		/* bc 12, CR0_LT, 716 */
		/* 820A2F28h case   20:*/		if ( regs.CR[0].lt ) { return 0x820A31F4;  }
		/* 820A2F28h case   20:*/		return 0x820A2F2C;
		  /* 820A2F2Ch */ case   21:  		/* lis R11, -32255 */
		/* 820A2F2Ch case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A2F2Ch case   21:*/		return 0x820A2F30;
		  /* 820A2F30h */ case   22:  		/* lis R10, -32255 */
		/* 820A2F30h case   22:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A2F30h case   22:*/		return 0x820A2F34;
		  /* 820A2F34h */ case   23:  		/* addi R27, R11, -16572 */
		/* 820A2F34h case   23:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFBF44);
		/* 820A2F34h case   23:*/		return 0x820A2F38;
		  /* 820A2F38h */ case   24:  		/* addi R25, R10, -10376 */
		/* 820A2F38h case   24:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R10,0xFFFFD778);
		/* 820A2F38h case   24:*/		return 0x820A2F3C;
		  /* 820A2F3Ch */ case   25:  		/* mr R5, R28 */
		/* 820A2F3Ch case   25:*/		regs.R5 = regs.R28;
		/* 820A2F3Ch case   25:*/		return 0x820A2F40;
		  /* 820A2F40h */ case   26:  		/* lwz R4, <#[R30 + 2256]> */
		/* 820A2F40h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000008D0) );
		/* 820A2F40h case   26:*/		return 0x820A2F44;
		  /* 820A2F44h */ case   27:  		/* lwz R3, <#[R30 + 2204]> */
		/* 820A2F44h case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000089C) );
		/* 820A2F44h case   27:*/		return 0x820A2F48;
		  /* 820A2F48h */ case   28:  		/* bl 21168 */
		/* 820A2F48h case   28:*/		regs.LR = 0x820A2F4C; return 0x820A81F8;
		/* 820A2F48h case   28:*/		return 0x820A2F4C;
		  /* 820A2F4Ch */ case   29:  		/* or. R31, R3, R3 */
		/* 820A2F4Ch case   29:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A2F4Ch case   29:*/		return 0x820A2F50;
		  /* 820A2F50h */ case   30:  		/* bc 12, CR0_LT, 676 */
		/* 820A2F50h case   30:*/		if ( regs.CR[0].lt ) { return 0x820A31F4;  }
		/* 820A2F50h case   30:*/		return 0x820A2F54;
		  /* 820A2F54h */ case   31:  		/* lwz R7, <#[R28]> */
		/* 820A2F54h case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + 0x00000000) );
		/* 820A2F54h case   31:*/		return 0x820A2F58;
	}
	return 0x820A2F58;
} // Block from 820A2ED8h-820A2F58h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820A2F58h
// Function '?UintDefine@CPreProcessor@D3DXShader@@IAAIPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2F58);
		  /* 820A2F58h */ case    0:  		/* cmpwi CR6, R7, 11 */
		/* 820A2F58h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x0000000B);
		/* 820A2F58h case    0:*/		return 0x820A2F5C;
		  /* 820A2F5Ch */ case    1:  		/* bc 4, CR6_EQ, 308 */
		/* 820A2F5Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A3090;  }
		/* 820A2F5Ch case    1:*/		return 0x820A2F60;
		  /* 820A2F60h */ case    2:  		/* lwz R8, <#[R26]> */
		/* 820A2F60h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000000) );
		/* 820A2F60h case    2:*/		return 0x820A2F64;
		  /* 820A2F64h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 820A2F64h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820A2F64h case    3:*/		return 0x820A2F68;
		  /* 820A2F68h */ case    4:  		/* bc 12, CR6_EQ, 96 */
		/* 820A2F68h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A2FC8;  }
		/* 820A2F68h case    4:*/		return 0x820A2F6C;
		  /* 820A2F6Ch */ case    5:  		/* lwz R7, <#[R30 + 2224]> */
		/* 820A2F6Ch case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x000008B0) );
		/* 820A2F6Ch case    5:*/		return 0x820A2F70;
		  /* 820A2F70h */ case    6:  		/* lwz R10, <#[R8 + 24]> */
		/* 820A2F70h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000018) );
		/* 820A2F70h case    6:*/		return 0x820A2F74;
		  /* 820A2F74h */ case    7:  		/* mr R11, R7 */
		/* 820A2F74h case    7:*/		regs.R11 = regs.R7;
		/* 820A2F74h case    7:*/		return 0x820A2F78;
		  /* 820A2F78h */ case    8:  		/* lbz R9, <#[R11]> */
		/* 820A2F78h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A2F78h case    8:*/		return 0x820A2F7C;
		  /* 820A2F7Ch */ case    9:  		/* lbz R6, <#[R10]> */
		/* 820A2F7Ch case    9:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820A2F7Ch case    9:*/		return 0x820A2F80;
		  /* 820A2F80h */ case   10:  		/* cmpwi CR0, R9, 0 */
		/* 820A2F80h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A2F80h case   10:*/		return 0x820A2F84;
		  /* 820A2F84h */ case   11:  		/* subf R9, R6, R9 */
		/* 820A2F84h case   11:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820A2F84h case   11:*/		return 0x820A2F88;
		  /* 820A2F88h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 820A2F88h case   12:*/		if ( regs.CR[0].eq ) { return 0x820A2F9C;  }
		/* 820A2F88h case   12:*/		return 0x820A2F8C;
		  /* 820A2F8Ch */ case   13:  		/* addi R11, R11, 1 */
		/* 820A2F8Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A2F8Ch case   13:*/		return 0x820A2F90;
		  /* 820A2F90h */ case   14:  		/* addi R10, R10, 1 */
		/* 820A2F90h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A2F90h case   14:*/		return 0x820A2F94;
		  /* 820A2F94h */ case   15:  		/* cmpwi CR6, R9, 0 */
		/* 820A2F94h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A2F94h case   15:*/		return 0x820A2F98;
		  /* 820A2F98h */ case   16:  		/* bc 12, CR6_EQ, -32 */
		/* 820A2F98h case   16:*/		if ( regs.CR[6].eq ) { return 0x820A2F78;  }
		/* 820A2F98h case   16:*/		return 0x820A2F9C;
	}
	return 0x820A2F9C;
} // Block from 820A2F58h-820A2F9Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A2F9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2F9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2F9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2F9C);
		  /* 820A2F9Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A2F9Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A2F9Ch case    0:*/		return 0x820A2FA0;
		  /* 820A2FA0h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820A2FA0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A2FB4;  }
		/* 820A2FA0h case    1:*/		return 0x820A2FA4;
		  /* 820A2FA4h */ case    2:  		/* lwz R8, <#[R8 + 12]> */
		/* 820A2FA4h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 820A2FA4h case    2:*/		return 0x820A2FA8;
		  /* 820A2FA8h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 820A2FA8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820A2FA8h case    3:*/		return 0x820A2FAC;
		  /* 820A2FACh */ case    4:  		/* bc 4, CR6_EQ, -60 */
		/* 820A2FACh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A2F70;  }
		/* 820A2FACh case    4:*/		return 0x820A2FB0;
		  /* 820A2FB0h */ case    5:  		/* b 24 */
		/* 820A2FB0h case    5:*/		return 0x820A2FC8;
		/* 820A2FB0h case    5:*/		return 0x820A2FB4;
	}
	return 0x820A2FB4;
} // Block from 820A2F9Ch-820A2FB4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A2FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2FB4);
		  /* 820A2FB4h */ case    0:  		/* mr R6, R25 */
		/* 820A2FB4h case    0:*/		regs.R6 = regs.R25;
		/* 820A2FB4h case    0:*/		return 0x820A2FB8;
		  /* 820A2FB8h */ case    1:  		/* li R5, 1511 */
		/* 820A2FB8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x5E7);
		/* 820A2FB8h case    1:*/		return 0x820A2FBC;
		  /* 820A2FBCh */ case    2:  		/* mr R4, R28 */
		/* 820A2FBCh case    2:*/		regs.R4 = regs.R28;
		/* 820A2FBCh case    2:*/		return 0x820A2FC0;
		  /* 820A2FC0h */ case    3:  		/* addi R3, R30, 24 */
		/* 820A2FC0h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x18);
		/* 820A2FC0h case    3:*/		return 0x820A2FC4;
		  /* 820A2FC4h */ case    4:  		/* bl 16844 */
		/* 820A2FC4h case    4:*/		regs.LR = 0x820A2FC8; return 0x820A7190;
		/* 820A2FC4h case    4:*/		return 0x820A2FC8;
	}
	return 0x820A2FC8;
} // Block from 820A2FB4h-820A2FC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A2FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2FC8);
		  /* 820A2FC8h */ case    0:  		/* li R3, 56 */
		/* 820A2FC8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A2FC8h case    0:*/		return 0x820A2FCC;
		  /* 820A2FCCh */ case    1:  		/* bl 156252 */
		/* 820A2FCCh case    1:*/		regs.LR = 0x820A2FD0; return 0x820C9228;
		/* 820A2FCCh case    1:*/		return 0x820A2FD0;
		  /* 820A2FD0h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820A2FD0h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A2FD0h case    2:*/		return 0x820A2FD4;
		  /* 820A2FD4h */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 820A2FD4h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A2FE8;  }
		/* 820A2FD4h case    3:*/		return 0x820A2FD8;
		  /* 820A2FD8h */ case    4:  		/* mr R4, R28 */
		/* 820A2FD8h case    4:*/		regs.R4 = regs.R28;
		/* 820A2FD8h case    4:*/		return 0x820A2FDC;
		  /* 820A2FDCh */ case    5:  		/* bl 157812 */
		/* 820A2FDCh case    5:*/		regs.LR = 0x820A2FE0; return 0x820C9850;
		/* 820A2FDCh case    5:*/		return 0x820A2FE0;
		  /* 820A2FE0h */ case    6:  		/* mr R11, R3 */
		/* 820A2FE0h case    6:*/		regs.R11 = regs.R3;
		/* 820A2FE0h case    6:*/		return 0x820A2FE4;
		  /* 820A2FE4h */ case    7:  		/* b 8 */
		/* 820A2FE4h case    7:*/		return 0x820A2FEC;
		/* 820A2FE4h case    7:*/		return 0x820A2FE8;
	}
	return 0x820A2FE8;
} // Block from 820A2FC8h-820A2FE8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A2FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2FE8);
		  /* 820A2FE8h */ case    0:  		/* mr R11, R23 */
		/* 820A2FE8h case    0:*/		regs.R11 = regs.R23;
		/* 820A2FE8h case    0:*/		return 0x820A2FEC;
	}
	return 0x820A2FEC;
} // Block from 820A2FE8h-820A2FECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A2FECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A2FEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A2FEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A2FEC);
		  /* 820A2FECh */ case    0:  		/* stw R11, <#[R29]> */
		/* 820A2FECh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820A2FECh case    0:*/		return 0x820A2FF0;
		  /* 820A2FF0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A2FF0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A2FF0h case    1:*/		return 0x820A2FF4;
		  /* 820A2FF4h */ case    2:  		/* bc 12, CR6_EQ, 460 */
		/* 820A2FF4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A31C0;  }
		/* 820A2FF4h case    2:*/		return 0x820A2FF8;
		  /* 820A2FF8h */ case    3:  		/* mr R5, R28 */
		/* 820A2FF8h case    3:*/		regs.R5 = regs.R28;
		/* 820A2FF8h case    3:*/		return 0x820A2FFC;
		  /* 820A2FFCh */ case    4:  		/* lwz R4, <#[R30 + 2256]> */
		/* 820A2FFCh case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000008D0) );
		/* 820A2FFCh case    4:*/		return 0x820A3000;
		  /* 820A3000h */ case    5:  		/* lwz R3, <#[R30 + 2204]> */
		/* 820A3000h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000089C) );
		/* 820A3000h case    5:*/		return 0x820A3004;
		  /* 820A3004h */ case    6:  		/* addi R29, R11, 12 */
		/* 820A3004h case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xC);
		/* 820A3004h case    6:*/		return 0x820A3008;
		  /* 820A3008h */ case    7:  		/* bl 20976 */
		/* 820A3008h case    7:*/		regs.LR = 0x820A300C; return 0x820A81F8;
		/* 820A3008h case    7:*/		return 0x820A300C;
		  /* 820A300Ch */ case    8:  		/* or. R31, R3, R3 */
		/* 820A300Ch case    8:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A300Ch case    8:*/		return 0x820A3010;
		  /* 820A3010h */ case    9:  		/* bc 12, CR0_LT, 484 */
		/* 820A3010h case    9:*/		if ( regs.CR[0].lt ) { return 0x820A31F4;  }
		/* 820A3010h case    9:*/		return 0x820A3014;
		  /* 820A3014h */ case   10:  		/* lwz R7, <#[R28]> */
		/* 820A3014h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + 0x00000000) );
		/* 820A3014h case   10:*/		return 0x820A3018;
		  /* 820A3018h */ case   11:  		/* cmpwi CR6, R7, 1 */
		/* 820A3018h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000001);
		/* 820A3018h case   11:*/		return 0x820A301C;
		  /* 820A301Ch */ case   12:  		/* bc 4, CR6_EQ, 116 */
		/* 820A301Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A3090;  }
		/* 820A301Ch case   12:*/		return 0x820A3020;
		  /* 820A3020h */ case   13:  		/* addi R8, R30, 2224 */
		/* 820A3020h case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x8B0);
		/* 820A3020h case   13:*/		return 0x820A3024;
		  /* 820A3024h */ case   14:  		/* mr R11, R27 */
		/* 820A3024h case   14:*/		regs.R11 = regs.R27;
		/* 820A3024h case   14:*/		return 0x820A3028;
		  /* 820A3028h */ case   15:  		/* mr R10, R8 */
		/* 820A3028h case   15:*/		regs.R10 = regs.R8;
		/* 820A3028h case   15:*/		return 0x820A302C;
		  /* 820A302Ch */ case   16:  		/* lbz R9, <#[R11]> */
		/* 820A302Ch case   16:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A302Ch case   16:*/		return 0x820A3030;
		  /* 820A3030h */ case   17:  		/* lbz R6, <#[R10]> */
		/* 820A3030h case   17:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820A3030h case   17:*/		return 0x820A3034;
		  /* 820A3034h */ case   18:  		/* cmpwi CR0, R9, 0 */
		/* 820A3034h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A3034h case   18:*/		return 0x820A3038;
		  /* 820A3038h */ case   19:  		/* subf R9, R6, R9 */
		/* 820A3038h case   19:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820A3038h case   19:*/		return 0x820A303C;
		  /* 820A303Ch */ case   20:  		/* bc 12, CR0_EQ, 20 */
		/* 820A303Ch case   20:*/		if ( regs.CR[0].eq ) { return 0x820A3050;  }
		/* 820A303Ch case   20:*/		return 0x820A3040;
		  /* 820A3040h */ case   21:  		/* addi R11, R11, 1 */
		/* 820A3040h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A3040h case   21:*/		return 0x820A3044;
		  /* 820A3044h */ case   22:  		/* addi R10, R10, 1 */
		/* 820A3044h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A3044h case   22:*/		return 0x820A3048;
		  /* 820A3048h */ case   23:  		/* cmpwi CR6, R9, 0 */
		/* 820A3048h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A3048h case   23:*/		return 0x820A304C;
		  /* 820A304Ch */ case   24:  		/* bc 12, CR6_EQ, -32 */
		/* 820A304Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x820A302C;  }
		/* 820A304Ch case   24:*/		return 0x820A3050;
	}
	return 0x820A3050;
} // Block from 820A2FECh-820A3050h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820A3050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3050);
		  /* 820A3050h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A3050h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A3050h case    0:*/		return 0x820A3054;
		  /* 820A3054h */ case    1:  		/* bc 12, CR0_EQ, -280 */
		/* 820A3054h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A2F3C;  }
		/* 820A3054h case    1:*/		return 0x820A3058;
	}
	return 0x820A3058;
} // Block from 820A3050h-820A3058h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A3058h
// Function '?StringCchPrintfA@@YAJPADIPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3058);
		  /* 820A3058h */ case    0:  		/* lis R11, -32255 */
		/* 820A3058h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A3058h case    0:*/		return 0x820A305C;
		  /* 820A305Ch */ case    1:  		/* mr R10, R8 */
		/* 820A305Ch case    1:*/		regs.R10 = regs.R8;
		/* 820A305Ch case    1:*/		return 0x820A3060;
		  /* 820A3060h */ case    2:  		/* addi R11, R11, -10832 */
		/* 820A3060h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFD5B0);
		/* 820A3060h case    2:*/		return 0x820A3064;
		  /* 820A3064h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A3064h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3064h case    3:*/		return 0x820A3068;
		  /* 820A3068h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A3068h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A3068h case    4:*/		return 0x820A306C;
		  /* 820A306Ch */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A306Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A306Ch case    5:*/		return 0x820A3070;
		  /* 820A3070h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A3070h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A3070h case    6:*/		return 0x820A3074;
		  /* 820A3074h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A3074h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A3088;  }
		/* 820A3074h case    7:*/		return 0x820A3078;
		  /* 820A3078h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A3078h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A3078h case    8:*/		return 0x820A307C;
		  /* 820A307Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820A307Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A307Ch case    9:*/		return 0x820A3080;
		  /* 820A3080h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A3080h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A3080h case   10:*/		return 0x820A3084;
		  /* 820A3084h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A3084h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A3064;  }
		/* 820A3084h case   11:*/		return 0x820A3088;
	}
	return 0x820A3088;
} // Block from 820A3058h-820A3088h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A3088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3088);
		  /* 820A3088h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A3088h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A3088h case    0:*/		return 0x820A308C;
		  /* 820A308Ch */ case    1:  		/* bc 12, CR0_EQ, 60 */
		/* 820A308Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820A30C8;  }
		/* 820A308Ch case    1:*/		return 0x820A3090;
	}
	return 0x820A3090;
} // Block from 820A3088h-820A3090h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A3090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3090);
		  /* 820A3090h */ case    0:  		/* li R29, 1 */
		/* 820A3090h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820A3090h case    0:*/		return 0x820A3094;
		  /* 820A3094h */ case    1:  		/* cmpwi CR6, R7, 16 */
		/* 820A3094h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000010);
		/* 820A3094h case    1:*/		return 0x820A3098;
		  /* 820A3098h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820A3098h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A30A4;  }
		/* 820A3098h case    2:*/		return 0x820A309C;
		  /* 820A309Ch */ case    3:  		/* cmpwi CR6, R7, 17 */
		/* 820A309Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000011);
		/* 820A309Ch case    3:*/		return 0x820A30A0;
		  /* 820A30A0h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 820A30A0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A30A8;  }
		/* 820A30A0h case    4:*/		return 0x820A30A4;
	}
	return 0x820A30A4;
} // Block from 820A3090h-820A30A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A30A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A30A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A30A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A30A4);
		  /* 820A30A4h */ case    0:  		/* stw R29, <#[R30 + 1636]> */
		/* 820A30A4h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000664) );
		/* 820A30A4h case    0:*/		return 0x820A30A8;
	}
	return 0x820A30A8;
} // Block from 820A30A4h-820A30A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A30A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A30A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A30A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A30A8);
		  /* 820A30A8h */ case    0:  		/* mr R5, R28 */
		/* 820A30A8h case    0:*/		regs.R5 = regs.R28;
		/* 820A30A8h case    0:*/		return 0x820A30AC;
		  /* 820A30ACh */ case    1:  		/* li R4, 1500 */
		/* 820A30ACh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x5DC);
		/* 820A30ACh case    1:*/		return 0x820A30B0;
		  /* 820A30B0h */ case    2:  		/* addi R3, R30, 24 */
		/* 820A30B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x18);
		/* 820A30B0h case    2:*/		return 0x820A30B4;
		  /* 820A30B4h */ case    3:  		/* bl 17132 */
		/* 820A30B4h case    3:*/		regs.LR = 0x820A30B8; return 0x820A73A0;
		/* 820A30B4h case    3:*/		return 0x820A30B8;
		  /* 820A30B8h */ case    4:  		/* lis R31, -32768 */
		/* 820A30B8h case    4:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8000);
		/* 820A30B8h case    4:*/		return 0x820A30BC;
		  /* 820A30BCh */ case    5:  		/* stw R29, <#[R30 + 1640]> */
		/* 820A30BCh case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000668) );
		/* 820A30BCh case    5:*/		return 0x820A30C0;
	}
	return 0x820A30C0;
} // Block from 820A30A8h-820A30C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A30C0h
// Function '?FinishInit@CPPInclude@D3DXShader@@QAAJPAVCAlloc@D3DXCore@@PAVCTErrors@2@PAVCTokStringTable@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A30C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A30C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A30C0);
		  /* 820A30C0h */ case    0:  		/* ori R31, R31, 16389 */
		/* 820A30C0h case    0:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x4005);
		/* 820A30C0h case    0:*/		return 0x820A30C4;
		  /* 820A30C4h */ case    1:  		/* b 304 */
		/* 820A30C4h case    1:*/		return 0x820A31F4;
		/* 820A30C4h case    1:*/		return 0x820A30C8;
	}
	return 0x820A30C8;
} // Block from 820A30C0h-820A30C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A30C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A30C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A30C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A30C8);
		  /* 820A30C8h */ case    0:  		/* addi R28, R24, 8 */
		/* 820A30C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R24,0x8);
		/* 820A30C8h case    0:*/		return 0x820A30CC;
		  /* 820A30CCh */ case    1:  		/* lwz R11, <#[R30 + 1668]> */
		/* 820A30CCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000684) );
		/* 820A30CCh case    1:*/		return 0x820A30D0;
		  /* 820A30D0h */ case    2:  		/* addi R29, R30, 2216 */
		/* 820A30D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x8A8);
		/* 820A30D0h case    2:*/		return 0x820A30D4;
		  /* 820A30D4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820A30D4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A30D4h case    3:*/		return 0x820A30D8;
		  /* 820A30D8h */ case    4:  		/* bc 12, CR6_EQ, 84 */
		/* 820A30D8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A312C;  }
		/* 820A30D8h case    4:*/		return 0x820A30DC;
		  /* 820A30DCh */ case    5:  		/* li R10, 5 */
		/* 820A30DCh case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 820A30DCh case    5:*/		return 0x820A30E0;
		  /* 820A30E0h */ case    6:  		/* addi R9, R11, 8 */
		/* 820A30E0h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x8);
		/* 820A30E0h case    6:*/		return 0x820A30E4;
		  /* 820A30E4h */ case    7:  		/* addi R8, R29, -8 */
		/* 820A30E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R29,0xFFFFFFF8);
		/* 820A30E4h case    7:*/		return 0x820A30E8;
		  /* 820A30E8h */ case    8:  		/* mtspr CTR, R10 */
		/* 820A30E8h case    8:*/		regs.CTR = regs.R10;
		/* 820A30E8h case    8:*/		return 0x820A30EC;
		  /* 820A30ECh */ case    9:  		/* ldu R10, <#[R9 + 8]> */
		/* 820A30ECh case    9:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820A30ECh case    9:*/		return 0x820A30F0;
		  /* 820A30F0h */ case   10:  		/* stdu R10, <#[R8 + 8]> */
		/* 820A30F0h case   10:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R8 + 0x00000008) );
		regs.R8 = (uint32)(regs.R8 + 0x00000008);
		/* 820A30F0h case   10:*/		return 0x820A30F4;
		  /* 820A30F4h */ case   11:  		/* bc 16, CR0_LT, -8 */
		/* 820A30F4h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A30EC;  }
		/* 820A30F4h case   11:*/		return 0x820A30F8;
		  /* 820A30F8h */ case   12:  		/* lwz R10, <#[R11 + 12]> */
		/* 820A30F8h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A30F8h case   12:*/		return 0x820A30FC;
		  /* 820A30FCh */ case   13:  		/* stw R10, <#[R30 + 1668]> */
		/* 820A30FCh case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000684) );
		/* 820A30FCh case   13:*/		return 0x820A3100;
		  /* 820A3100h */ case   14:  		/* stw R23, <#[R11 + 12]> */
		/* 820A3100h case   14:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A3100h case   14:*/		return 0x820A3104;
		  /* 820A3104h */ case   15:  		/* lwz R11, <#[R30 + 2204]> */
		/* 820A3104h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000089C) );
		/* 820A3104h case   15:*/		return 0x820A3108;
		  /* 820A3108h */ case   16:  		/* lwz R10, <#[R11 + 32]> */
		/* 820A3108h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 820A3108h case   16:*/		return 0x820A310C;
		  /* 820A310Ch */ case   17:  		/* stw R10, <#[R30 + 2232]> */
		/* 820A310Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x000008B8) );
		/* 820A310Ch case   17:*/		return 0x820A3110;
		  /* 820A3110h */ case   18:  		/* lwz R10, <#[R11 + 40]> */
		/* 820A3110h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 820A3110h case   18:*/		return 0x820A3114;
		  /* 820A3114h */ case   19:  		/* stw R10, <#[R30 + 2240]> */
		/* 820A3114h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x000008C0) );
		/* 820A3114h case   19:*/		return 0x820A3118;
		  /* 820A3118h */ case   20:  		/* lwz R10, <#[R11 + 44]> */
		/* 820A3118h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000002C) );
		/* 820A3118h case   20:*/		return 0x820A311C;
		  /* 820A311Ch */ case   21:  		/* stw R10, <#[R30 + 2244]> */
		/* 820A311Ch case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x000008C4) );
		/* 820A311Ch case   21:*/		return 0x820A3120;
		  /* 820A3120h */ case   22:  		/* lwz R11, <#[R11 + 36]> */
		/* 820A3120h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 820A3120h case   22:*/		return 0x820A3124;
		  /* 820A3124h */ case   23:  		/* stw R11, <#[R30 + 2236]> */
		/* 820A3124h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000008BC) );
		/* 820A3124h case   23:*/		return 0x820A3128;
		  /* 820A3128h */ case   24:  		/* b 32 */
		/* 820A3128h case   24:*/		return 0x820A3148;
		/* 820A3128h case   24:*/		return 0x820A312C;
	}
	return 0x820A312C;
} // Block from 820A30C8h-820A312Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 820A312Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A312C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A312C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A312C);
		  /* 820A312Ch */ case    0:  		/* lwz R11, <#[R30 + 2256]> */
		/* 820A312Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000008D0) );
		/* 820A312Ch case    0:*/		return 0x820A3130;
		  /* 820A3130h */ case    1:  		/* mr R5, R29 */
		/* 820A3130h case    1:*/		regs.R5 = regs.R29;
		/* 820A3130h case    1:*/		return 0x820A3134;
		  /* 820A3134h */ case    2:  		/* lwz R3, <#[R30 + 2204]> */
		/* 820A3134h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000089C) );
		/* 820A3134h case    2:*/		return 0x820A3138;
		  /* 820A3138h */ case    3:  		/* ori R4, R11, 16 */
		/* 820A3138h case    3:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R11,0x10);
		/* 820A3138h case    3:*/		return 0x820A313C;
		  /* 820A313Ch */ case    4:  		/* bl 20668 */
		/* 820A313Ch case    4:*/		regs.LR = 0x820A3140; return 0x820A81F8;
		/* 820A313Ch case    4:*/		return 0x820A3140;
		  /* 820A3140h */ case    5:  		/* or. R31, R3, R3 */
		/* 820A3140h case    5:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A3140h case    5:*/		return 0x820A3144;
		  /* 820A3144h */ case    6:  		/* bc 12, CR0_LT, 176 */
		/* 820A3144h case    6:*/		if ( regs.CR[0].lt ) { return 0x820A31F4;  }
		/* 820A3144h case    6:*/		return 0x820A3148;
	}
	return 0x820A3148;
} // Block from 820A312Ch-820A3148h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A3148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3148);
		  /* 820A3148h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 820A3148h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820A3148h case    0:*/		return 0x820A314C;
		  /* 820A314Ch */ case    1:  		/* cmpwi CR6, R11, 16 */
		/* 820A314Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820A314Ch case    1:*/		return 0x820A3150;
		  /* 820A3150h */ case    2:  		/* bc 12, CR6_EQ, 124 */
		/* 820A3150h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A31CC;  }
		/* 820A3150h case    2:*/		return 0x820A3154;
		  /* 820A3154h */ case    3:  		/* cmpwi CR6, R11, 17 */
		/* 820A3154h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820A3154h case    3:*/		return 0x820A3158;
		  /* 820A3158h */ case    4:  		/* bc 12, CR6_EQ, 116 */
		/* 820A3158h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A31CC;  }
		/* 820A3158h case    4:*/		return 0x820A315C;
		  /* 820A315Ch */ case    5:  		/* li R3, 56 */
		/* 820A315Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A315Ch case    5:*/		return 0x820A3160;
		  /* 820A3160h */ case    6:  		/* bl 155848 */
		/* 820A3160h case    6:*/		regs.LR = 0x820A3164; return 0x820C9228;
		/* 820A3160h case    6:*/		return 0x820A3164;
		  /* 820A3164h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 820A3164h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A3164h case    7:*/		return 0x820A3168;
		  /* 820A3168h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820A3168h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A317C;  }
		/* 820A3168h case    8:*/		return 0x820A316C;
		  /* 820A316Ch */ case    9:  		/* mr R4, R29 */
		/* 820A316Ch case    9:*/		regs.R4 = regs.R29;
		/* 820A316Ch case    9:*/		return 0x820A3170;
		  /* 820A3170h */ case   10:  		/* bl 157408 */
		/* 820A3170h case   10:*/		regs.LR = 0x820A3174; return 0x820C9850;
		/* 820A3170h case   10:*/		return 0x820A3174;
		  /* 820A3174h */ case   11:  		/* mr R31, R3 */
		/* 820A3174h case   11:*/		regs.R31 = regs.R3;
		/* 820A3174h case   11:*/		return 0x820A3178;
		  /* 820A3178h */ case   12:  		/* b 8 */
		/* 820A3178h case   12:*/		return 0x820A3180;
		/* 820A3178h case   12:*/		return 0x820A317C;
	}
	return 0x820A317C;
} // Block from 820A3148h-820A317Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A317Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A317C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A317C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A317C);
		  /* 820A317Ch */ case    0:  		/* mr R31, R23 */
		/* 820A317Ch case    0:*/		regs.R31 = regs.R23;
		/* 820A317Ch case    0:*/		return 0x820A3180;
	}
	return 0x820A3180;
} // Block from 820A317Ch-820A3180h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3180);
		  /* 820A3180h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820A3180h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A3180h case    0:*/		return 0x820A3184;
		  /* 820A3184h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 820A3184h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A31C0;  }
		/* 820A3184h case    1:*/		return 0x820A3188;
		  /* 820A3188h */ case    2:  		/* li R5, 1 */
		/* 820A3188h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A3188h case    2:*/		return 0x820A318C;
		  /* 820A318Ch */ case    3:  		/* lwz R4, <#[R30 + 2252]> */
		/* 820A318Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000008CC) );
		/* 820A318Ch case    3:*/		return 0x820A3190;
		  /* 820A3190h */ case    4:  		/* mr R3, R30 */
		/* 820A3190h case    4:*/		regs.R3 = regs.R30;
		/* 820A3190h case    4:*/		return 0x820A3194;
		  /* 820A3194h */ case    5:  		/* bl 155468 */
		/* 820A3194h case    5:*/		regs.LR = 0x820A3198; return 0x820C90E0;
		/* 820A3194h case    5:*/		return 0x820A3198;
		  /* 820A3198h */ case    6:  		/* or. R29, R3, R3 */
		/* 820A3198h case    6:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820A3198h case    6:*/		return 0x820A319C;
		  /* 820A319Ch */ case    7:  		/* bc 12, CR0_EQ, 36 */
		/* 820A319Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820A31C0;  }
		/* 820A319Ch case    7:*/		return 0x820A31A0;
		  /* 820A31A0h */ case    8:  		/* mr R3, R29 */
		/* 820A31A0h case    8:*/		regs.R3 = regs.R29;
		/* 820A31A0h case    8:*/		return 0x820A31A4;
		  /* 820A31A4h */ case    9:  		/* lwz R5, <#[R30 + 2252]> */
		/* 820A31A4h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x000008CC) );
		/* 820A31A4h case    9:*/		return 0x820A31A8;
		  /* 820A31A8h */ case   10:  		/* lwz R4, <#[R30 + 2248]> */
		/* 820A31A8h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000008C8) );
		/* 820A31A8h case   10:*/		return 0x820A31AC;
		  /* 820A31ACh */ case   11:  		/* bl -71676 */
		/* 820A31ACh case   11:*/		regs.LR = 0x820A31B0; return 0x820919B0;
		/* 820A31ACh case   11:*/		return 0x820A31B0;
	}
	return 0x820A31B0;
} // Block from 820A3180h-820A31B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A31B0h
// Function '?InitializeFromFile@CPPInclude@D3DXShader@@QAAJPBXHPAVCAlloc@D3DXCore@@PAUD3DXTOKEN@2@PAVCTErrors@2@PAVCTokStringTable@2@PAUID3DXInclude@@W4_D3DXINCLUDE_TYPE@@0I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A31B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A31B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A31B0);
		  /* 820A31B0h */ case    0:  		/* stw R29, <#[R31 + 48]> */
		/* 820A31B0h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000030) );
		/* 820A31B0h case    0:*/		return 0x820A31B4;
		  /* 820A31B4h */ case    1:  		/* stw R31, <#[R28]> */
		/* 820A31B4h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 820A31B4h case    1:*/		return 0x820A31B8;
		  /* 820A31B8h */ case    2:  		/* addi R28, R31, 12 */
		/* 820A31B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0xC);
		/* 820A31B8h case    2:*/		return 0x820A31BC;
		  /* 820A31BCh */ case    3:  		/* b -240 */
		/* 820A31BCh case    3:*/		return 0x820A30CC;
		/* 820A31BCh case    3:*/		return 0x820A31C0;
	}
	return 0x820A31C0;
} // Block from 820A31B0h-820A31C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A31C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A31C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A31C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A31C0);
		  /* 820A31C0h */ case    0:  		/* lis R31, -32761 */
		/* 820A31C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820A31C0h case    0:*/		return 0x820A31C4;
		  /* 820A31C4h */ case    1:  		/* ori R31, R31, 14 */
		/* 820A31C4h case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820A31C4h case    1:*/		return 0x820A31C8;
		  /* 820A31C8h */ case    2:  		/* b 44 */
		/* 820A31C8h case    2:*/		return 0x820A31F4;
		/* 820A31C8h case    2:*/		return 0x820A31CC;
	}
	return 0x820A31CC;
} // Block from 820A31C0h-820A31CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A31CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A31CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A31CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A31CC);
		  /* 820A31CCh */ case    0:  		/* li R11, 1 */
		/* 820A31CCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A31CCh case    0:*/		return 0x820A31D0;
		  /* 820A31D0h */ case    1:  		/* mr R4, R24 */
		/* 820A31D0h case    1:*/		regs.R4 = regs.R24;
		/* 820A31D0h case    1:*/		return 0x820A31D4;
		  /* 820A31D4h */ case    2:  		/* stw R11, <#[R30 + 1636]> */
		/* 820A31D4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000664) );
		/* 820A31D4h case    2:*/		return 0x820A31D8;
		  /* 820A31D8h */ case    3:  		/* mr R3, R30 */
		/* 820A31D8h case    3:*/		regs.R3 = regs.R30;
		/* 820A31D8h case    3:*/		return 0x820A31DC;
		  /* 820A31DCh */ case    4:  		/* stb R22, <#[R24 + 17]> */
		/* 820A31DCh case    4:*/		cpu::mem::store8( regs, regs.R22, (uint32)(regs.R24 + 0x00000011) );
		/* 820A31DCh case    4:*/		return 0x820A31E0;
		  /* 820A31E0h */ case    5:  		/* bl -3816 */
		/* 820A31E0h case    5:*/		regs.LR = 0x820A31E4; return 0x820A22F8;
		/* 820A31E0h case    5:*/		return 0x820A31E4;
		  /* 820A31E4h */ case    6:  		/* or. R31, R3, R3 */
		/* 820A31E4h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A31E4h case    6:*/		return 0x820A31E8;
		  /* 820A31E8h */ case    7:  		/* bc 12, CR0_LT, 12 */
		/* 820A31E8h case    7:*/		if ( regs.CR[0].lt ) { return 0x820A31F4;  }
		/* 820A31E8h case    7:*/		return 0x820A31EC;
		  /* 820A31ECh */ case    8:  		/* mr R24, R23 */
		/* 820A31ECh case    8:*/		regs.R24 = regs.R23;
		/* 820A31ECh case    8:*/		return 0x820A31F0;
		  /* 820A31F0h */ case    9:  		/* mr R31, R23 */
		/* 820A31F0h case    9:*/		regs.R31 = regs.R23;
		/* 820A31F0h case    9:*/		return 0x820A31F4;
	}
	return 0x820A31F4;
} // Block from 820A31CCh-820A31F4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A31F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A31F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A31F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A31F4);
		  /* 820A31F4h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 820A31F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820A31F4h case    0:*/		return 0x820A31F8;
		  /* 820A31F8h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820A31F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A3208;  }
		/* 820A31F8h case    1:*/		return 0x820A31FC;
		  /* 820A31FCh */ case    2:  		/* li R4, 1 */
		/* 820A31FCh case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A31FCh case    2:*/		return 0x820A3200;
		  /* 820A3200h */ case    3:  		/* mr R3, R24 */
		/* 820A3200h case    3:*/		regs.R3 = regs.R24;
		/* 820A3200h case    3:*/		return 0x820A3204;
		  /* 820A3204h */ case    4:  		/* bl -8956 */
		/* 820A3204h case    4:*/		regs.LR = 0x820A3208; return 0x820A0F08;
		/* 820A3204h case    4:*/		return 0x820A3208;
	}
	return 0x820A3208;
} // Block from 820A31F4h-820A3208h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A3208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3208);
		  /* 820A3208h */ case    0:  		/* mr R3, R31 */
		/* 820A3208h case    0:*/		regs.R3 = regs.R31;
		/* 820A3208h case    0:*/		return 0x820A320C;
		  /* 820A320Ch */ case    1:  		/* addi R1, R1, 176 */
		/* 820A320Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820A320Ch case    1:*/		return 0x820A3210;
		  /* 820A3210h */ case    2:  		/* b -73600 */
		/* 820A3210h case    2:*/		return 0x82091290;
		/* 820A3210h case    2:*/		return 0x820A3214;
		  /* 820A3214h */ case    3:  		/* nop */
		/* 820A3214h case    3:*/		cpu::op::nop();
		/* 820A3214h case    3:*/		return 0x820A3218;
	}
	return 0x820A3218;
} // Block from 820A3208h-820A3218h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A3218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3218);
		  /* 820A3218h */ case    0:  		/* mfspr R12, LR */
		/* 820A3218h case    0:*/		regs.R12 = regs.LR;
		/* 820A3218h case    0:*/		return 0x820A321C;
		  /* 820A321Ch */ case    1:  		/* bl -73664 */
		/* 820A321Ch case    1:*/		regs.LR = 0x820A3220; return 0x8209125C;
		/* 820A321Ch case    1:*/		return 0x820A3220;
		  /* 820A3220h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A3220h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A3220h case    2:*/		return 0x820A3224;
		  /* 820A3224h */ case    3:  		/* addi R30, R3, 2216 */
		/* 820A3224h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x8A8);
		/* 820A3224h case    3:*/		return 0x820A3228;
		  /* 820A3228h */ case    4:  		/* lwz R4, <#[R3 + 2256]> */
		/* 820A3228h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x000008D0) );
		/* 820A3228h case    4:*/		return 0x820A322C;
		  /* 820A322Ch */ case    5:  		/* mr R31, R3 */
		/* 820A322Ch case    5:*/		regs.R31 = regs.R3;
		/* 820A322Ch case    5:*/		return 0x820A3230;
		  /* 820A3230h */ case    6:  		/* lwz R3, <#[R3 + 2204]> */
		/* 820A3230h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000089C) );
		/* 820A3230h case    6:*/		return 0x820A3234;
		  /* 820A3234h */ case    7:  		/* mr R5, R30 */
		/* 820A3234h case    7:*/		regs.R5 = regs.R30;
		/* 820A3234h case    7:*/		return 0x820A3238;
		  /* 820A3238h */ case    8:  		/* bl 20416 */
		/* 820A3238h case    8:*/		regs.LR = 0x820A323C; return 0x820A81F8;
		/* 820A3238h case    8:*/		return 0x820A323C;
		  /* 820A323Ch */ case    9:  		/* li R29, 1 */
		/* 820A323Ch case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820A323Ch case    9:*/		return 0x820A3240;
		  /* 820A3240h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820A3240h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A3240h case   10:*/		return 0x820A3244;
		  /* 820A3244h */ case   11:  		/* bc 12, CR0_LT, 428 */
		/* 820A3244h case   11:*/		if ( regs.CR[0].lt ) { return 0x820A33F0;  }
		/* 820A3244h case   11:*/		return 0x820A3248;
		  /* 820A3248h */ case   12:  		/* lwz R11, <#[R30]> */
		/* 820A3248h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A3248h case   12:*/		return 0x820A324C;
		  /* 820A324Ch */ case   13:  		/* cmpwi CR6, R11, 11 */
		/* 820A324Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820A324Ch case   13:*/		return 0x820A3250;
		  /* 820A3250h */ case   14:  		/* bc 4, CR6_EQ, 376 */
		/* 820A3250h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820A33C8;  }
		/* 820A3250h case   14:*/		return 0x820A3254;
		  /* 820A3254h */ case   15:  		/* lwz R7, <#[R31 + 2224]> */
		/* 820A3254h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x000008B0) );
		/* 820A3254h case   15:*/		return 0x820A3258;
		  /* 820A3258h */ case   16:  		/* lis R10, -32255 */
		/* 820A3258h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A3258h case   16:*/		return 0x820A325C;
		  /* 820A325Ch */ case   17:  		/* stw R29, <#[R31 + 76]> */
		/* 820A325Ch case   17:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000004C) );
		/* 820A325Ch case   17:*/		return 0x820A3260;
		  /* 820A3260h */ case   18:  		/* mr R11, R7 */
		/* 820A3260h case   18:*/		regs.R11 = regs.R7;
		/* 820A3260h case   18:*/		return 0x820A3264;
		  /* 820A3264h */ case   19:  		/* addi R10, R10, -10280 */
		/* 820A3264h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD7D8);
		/* 820A3264h case   19:*/		return 0x820A3268;
		  /* 820A3268h */ case   20:  		/* lbz R9, <#[R11]> */
		/* 820A3268h case   20:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3268h case   20:*/		return 0x820A326C;
		  /* 820A326Ch */ case   21:  		/* lbz R8, <#[R10]> */
		/* 820A326Ch case   21:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A326Ch case   21:*/		return 0x820A3270;
		  /* 820A3270h */ case   22:  		/* cmpwi CR0, R9, 0 */
		/* 820A3270h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A3270h case   22:*/		return 0x820A3274;
		  /* 820A3274h */ case   23:  		/* subf R9, R8, R9 */
		/* 820A3274h case   23:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A3274h case   23:*/		return 0x820A3278;
		  /* 820A3278h */ case   24:  		/* bc 12, CR0_EQ, 20 */
		/* 820A3278h case   24:*/		if ( regs.CR[0].eq ) { return 0x820A328C;  }
		/* 820A3278h case   24:*/		return 0x820A327C;
		  /* 820A327Ch */ case   25:  		/* addi R11, R11, 1 */
		/* 820A327Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A327Ch case   25:*/		return 0x820A3280;
		  /* 820A3280h */ case   26:  		/* addi R10, R10, 1 */
		/* 820A3280h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A3280h case   26:*/		return 0x820A3284;
		  /* 820A3284h */ case   27:  		/* cmpwi CR6, R9, 0 */
		/* 820A3284h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A3284h case   27:*/		return 0x820A3288;
		  /* 820A3288h */ case   28:  		/* bc 12, CR6_EQ, -32 */
		/* 820A3288h case   28:*/		if ( regs.CR[6].eq ) { return 0x820A3268;  }
		/* 820A3288h case   28:*/		return 0x820A328C;
	}
	return 0x820A328C;
} // Block from 820A3218h-820A328Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 820A328Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A328C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A328C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A328C);
		  /* 820A328Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A328Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A328Ch case    0:*/		return 0x820A3290;
		  /* 820A3290h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A3290h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A32A0;  }
		/* 820A3290h case    1:*/		return 0x820A3294;
		  /* 820A3294h */ case    2:  		/* mr R3, R31 */
		/* 820A3294h case    2:*/		regs.R3 = regs.R31;
		/* 820A3294h case    2:*/		return 0x820A3298;
		  /* 820A3298h */ case    3:  		/* bl -12616 */
		/* 820A3298h case    3:*/		regs.LR = 0x820A329C; return 0x820A0150;
		/* 820A3298h case    3:*/		return 0x820A329C;
		  /* 820A329Ch */ case    4:  		/* b 344 */
		/* 820A329Ch case    4:*/		return 0x820A33F4;
		/* 820A329Ch case    4:*/		return 0x820A32A0;
	}
	return 0x820A32A0;
} // Block from 820A328Ch-820A32A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A32A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A32A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A32A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A32A0);
		  /* 820A32A0h */ case    0:  		/* lis R10, -32255 */
		/* 820A32A0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A32A0h case    0:*/		return 0x820A32A4;
		  /* 820A32A4h */ case    1:  		/* mr R11, R7 */
		/* 820A32A4h case    1:*/		regs.R11 = regs.R7;
		/* 820A32A4h case    1:*/		return 0x820A32A8;
		  /* 820A32A8h */ case    2:  		/* addi R10, R10, -10288 */
		/* 820A32A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD7D0);
		/* 820A32A8h case    2:*/		return 0x820A32AC;
		  /* 820A32ACh */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A32ACh case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A32ACh case    3:*/		return 0x820A32B0;
		  /* 820A32B0h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A32B0h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A32B0h case    4:*/		return 0x820A32B4;
		  /* 820A32B4h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A32B4h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A32B4h case    5:*/		return 0x820A32B8;
		  /* 820A32B8h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A32B8h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A32B8h case    6:*/		return 0x820A32BC;
		  /* 820A32BCh */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A32BCh case    7:*/		if ( regs.CR[0].eq ) { return 0x820A32D0;  }
		/* 820A32BCh case    7:*/		return 0x820A32C0;
		  /* 820A32C0h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A32C0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A32C0h case    8:*/		return 0x820A32C4;
		  /* 820A32C4h */ case    9:  		/* addi R10, R10, 1 */
		/* 820A32C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A32C4h case    9:*/		return 0x820A32C8;
		  /* 820A32C8h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A32C8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A32C8h case   10:*/		return 0x820A32CC;
		  /* 820A32CCh */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A32CCh case   11:*/		if ( regs.CR[6].eq ) { return 0x820A32AC;  }
		/* 820A32CCh case   11:*/		return 0x820A32D0;
	}
	return 0x820A32D0;
} // Block from 820A32A0h-820A32D0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A32D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A32D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A32D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A32D0);
		  /* 820A32D0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A32D0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A32D0h case    0:*/		return 0x820A32D4;
		  /* 820A32D4h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A32D4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A32E4;  }
		/* 820A32D4h case    1:*/		return 0x820A32D8;
		  /* 820A32D8h */ case    2:  		/* mr R3, R31 */
		/* 820A32D8h case    2:*/		regs.R3 = regs.R31;
		/* 820A32D8h case    2:*/		return 0x820A32DC;
		  /* 820A32DCh */ case    3:  		/* bl -12180 */
		/* 820A32DCh case    3:*/		regs.LR = 0x820A32E0; return 0x820A0348;
		/* 820A32DCh case    3:*/		return 0x820A32E0;
		  /* 820A32E0h */ case    4:  		/* b 276 */
		/* 820A32E0h case    4:*/		return 0x820A33F4;
		/* 820A32E0h case    4:*/		return 0x820A32E4;
	}
	return 0x820A32E4;
} // Block from 820A32D0h-820A32E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A32E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A32E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A32E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A32E4);
		  /* 820A32E4h */ case    0:  		/* lis R10, -32255 */
		/* 820A32E4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A32E4h case    0:*/		return 0x820A32E8;
		  /* 820A32E8h */ case    1:  		/* mr R11, R7 */
		/* 820A32E8h case    1:*/		regs.R11 = regs.R7;
		/* 820A32E8h case    1:*/		return 0x820A32EC;
		  /* 820A32ECh */ case    2:  		/* addi R10, R10, -10292 */
		/* 820A32ECh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD7CC);
		/* 820A32ECh case    2:*/		return 0x820A32F0;
		  /* 820A32F0h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A32F0h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A32F0h case    3:*/		return 0x820A32F4;
		  /* 820A32F4h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A32F4h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A32F4h case    4:*/		return 0x820A32F8;
		  /* 820A32F8h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A32F8h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A32F8h case    5:*/		return 0x820A32FC;
		  /* 820A32FCh */ case    6:  		/* subf R9, R8, R9 */
		/* 820A32FCh case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A32FCh case    6:*/		return 0x820A3300;
		  /* 820A3300h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A3300h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A3314;  }
		/* 820A3300h case    7:*/		return 0x820A3304;
		  /* 820A3304h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A3304h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A3304h case    8:*/		return 0x820A3308;
		  /* 820A3308h */ case    9:  		/* addi R10, R10, 1 */
		/* 820A3308h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A3308h case    9:*/		return 0x820A330C;
		  /* 820A330Ch */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A330Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A330Ch case   10:*/		return 0x820A3310;
		  /* 820A3310h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A3310h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A32F0;  }
		/* 820A3310h case   11:*/		return 0x820A3314;
	}
	return 0x820A3314;
} // Block from 820A32E4h-820A3314h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A3314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3314);
		  /* 820A3314h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A3314h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A3314h case    0:*/		return 0x820A3318;
		  /* 820A3318h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A3318h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A3328;  }
		/* 820A3318h case    1:*/		return 0x820A331C;
		  /* 820A331Ch */ case    2:  		/* mr R3, R31 */
		/* 820A331Ch case    2:*/		regs.R3 = regs.R31;
		/* 820A331Ch case    2:*/		return 0x820A3320;
		  /* 820A3320h */ case    3:  		/* bl -5136 */
		/* 820A3320h case    3:*/		regs.LR = 0x820A3324; return 0x820A1F10;
		/* 820A3320h case    3:*/		return 0x820A3324;
		  /* 820A3324h */ case    4:  		/* b 208 */
		/* 820A3324h case    4:*/		return 0x820A33F4;
		/* 820A3324h case    4:*/		return 0x820A3328;
	}
	return 0x820A3328;
} // Block from 820A3314h-820A3328h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A3328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3328);
		  /* 820A3328h */ case    0:  		/* lis R10, -32255 */
		/* 820A3328h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A3328h case    0:*/		return 0x820A332C;
		  /* 820A332Ch */ case    1:  		/* mr R11, R7 */
		/* 820A332Ch case    1:*/		regs.R11 = regs.R7;
		/* 820A332Ch case    1:*/		return 0x820A3330;
		  /* 820A3330h */ case    2:  		/* addi R10, R10, -10304 */
		/* 820A3330h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD7C0);
		/* 820A3330h case    2:*/		return 0x820A3334;
		  /* 820A3334h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A3334h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3334h case    3:*/		return 0x820A3338;
		  /* 820A3338h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A3338h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A3338h case    4:*/		return 0x820A333C;
		  /* 820A333Ch */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A333Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A333Ch case    5:*/		return 0x820A3340;
		  /* 820A3340h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A3340h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A3340h case    6:*/		return 0x820A3344;
		  /* 820A3344h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A3344h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A3358;  }
		/* 820A3344h case    7:*/		return 0x820A3348;
		  /* 820A3348h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A3348h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A3348h case    8:*/		return 0x820A334C;
		  /* 820A334Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820A334Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A334Ch case    9:*/		return 0x820A3350;
		  /* 820A3350h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A3350h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A3350h case   10:*/		return 0x820A3354;
		  /* 820A3354h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A3354h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A3334;  }
		/* 820A3354h case   11:*/		return 0x820A3358;
	}
	return 0x820A3358;
} // Block from 820A3328h-820A3358h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A3358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3358);
		  /* 820A3358h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A3358h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A3358h case    0:*/		return 0x820A335C;
		  /* 820A335Ch */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A335Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A336C;  }
		/* 820A335Ch case    1:*/		return 0x820A3360;
		  /* 820A3360h */ case    2:  		/* mr R3, R31 */
		/* 820A3360h case    2:*/		regs.R3 = regs.R31;
		/* 820A3360h case    2:*/		return 0x820A3364;
		  /* 820A3364h */ case    3:  		/* bl -6012 */
		/* 820A3364h case    3:*/		regs.LR = 0x820A3368; return 0x820A1BE8;
		/* 820A3364h case    3:*/		return 0x820A3368;
		  /* 820A3368h */ case    4:  		/* b 140 */
		/* 820A3368h case    4:*/		return 0x820A33F4;
		/* 820A3368h case    4:*/		return 0x820A336C;
	}
	return 0x820A336C;
} // Block from 820A3358h-820A336Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A336Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A336C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A336C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A336C);
		  /* 820A336Ch */ case    0:  		/* lis R10, -32255 */
		/* 820A336Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A336Ch case    0:*/		return 0x820A3370;
		  /* 820A3370h */ case    1:  		/* mr R11, R7 */
		/* 820A3370h case    1:*/		regs.R11 = regs.R7;
		/* 820A3370h case    1:*/		return 0x820A3374;
		  /* 820A3374h */ case    2:  		/* addi R10, R10, -10312 */
		/* 820A3374h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD7B8);
		/* 820A3374h case    2:*/		return 0x820A3378;
		  /* 820A3378h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A3378h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3378h case    3:*/		return 0x820A337C;
		  /* 820A337Ch */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A337Ch case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A337Ch case    4:*/		return 0x820A3380;
		  /* 820A3380h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A3380h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A3380h case    5:*/		return 0x820A3384;
		  /* 820A3384h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A3384h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A3384h case    6:*/		return 0x820A3388;
		  /* 820A3388h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A3388h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A339C;  }
		/* 820A3388h case    7:*/		return 0x820A338C;
		  /* 820A338Ch */ case    8:  		/* addi R11, R11, 1 */
		/* 820A338Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A338Ch case    8:*/		return 0x820A3390;
		  /* 820A3390h */ case    9:  		/* addi R10, R10, 1 */
		/* 820A3390h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A3390h case    9:*/		return 0x820A3394;
		  /* 820A3394h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A3394h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A3394h case   10:*/		return 0x820A3398;
		  /* 820A3398h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A3398h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A3378;  }
		/* 820A3398h case   11:*/		return 0x820A339C;
	}
	return 0x820A339C;
} // Block from 820A336Ch-820A339Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A339Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A339C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A339C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A339C);
		  /* 820A339Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A339Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A339Ch case    0:*/		return 0x820A33A0;
		  /* 820A33A0h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A33A0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A33B0;  }
		/* 820A33A0h case    1:*/		return 0x820A33A4;
		  /* 820A33A4h */ case    2:  		/* mr R3, R31 */
		/* 820A33A4h case    2:*/		regs.R3 = regs.R31;
		/* 820A33A4h case    2:*/		return 0x820A33A8;
		  /* 820A33A8h */ case    3:  		/* bl -5760 */
		/* 820A33A8h case    3:*/		regs.LR = 0x820A33AC; return 0x820A1D28;
		/* 820A33A8h case    3:*/		return 0x820A33AC;
		  /* 820A33ACh */ case    4:  		/* b 72 */
		/* 820A33ACh case    4:*/		return 0x820A33F4;
		/* 820A33ACh case    4:*/		return 0x820A33B0;
	}
	return 0x820A33B0;
} // Block from 820A339Ch-820A33B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A33B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A33B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A33B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A33B0);
		  /* 820A33B0h */ case    0:  		/* lis R11, -32255 */
		/* 820A33B0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A33B0h case    0:*/		return 0x820A33B4;
		  /* 820A33B4h */ case    1:  		/* li R5, 3568 */
		/* 820A33B4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0xDF0);
		/* 820A33B4h case    1:*/		return 0x820A33B8;
		  /* 820A33B8h */ case    2:  		/* addi R6, R11, -10344 */
		/* 820A33B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD798);
		/* 820A33B8h case    2:*/		return 0x820A33BC;
		  /* 820A33BCh */ case    3:  		/* mr R4, R30 */
		/* 820A33BCh case    3:*/		regs.R4 = regs.R30;
		/* 820A33BCh case    3:*/		return 0x820A33C0;
		  /* 820A33C0h */ case    4:  		/* addi R3, R31, 24 */
		/* 820A33C0h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A33C0h case    4:*/		return 0x820A33C4;
		  /* 820A33C4h */ case    5:  		/* bl 16276 */
		/* 820A33C4h case    5:*/		regs.LR = 0x820A33C8; return 0x820A7358;
		/* 820A33C4h case    5:*/		return 0x820A33C8;
	}
	return 0x820A33C8;
} // Block from 820A33B0h-820A33C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A33C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A33C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A33C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A33C8);
		  /* 820A33C8h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820A33C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A33C8h case    0:*/		return 0x820A33CC;
		  /* 820A33CCh */ case    1:  		/* cmpwi CR6, R11, 16 */
		/* 820A33CCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820A33CCh case    1:*/		return 0x820A33D0;
		  /* 820A33D0h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820A33D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A33E8;  }
		/* 820A33D0h case    2:*/		return 0x820A33D4;
		  /* 820A33D4h */ case    3:  		/* cmpwi CR6, R11, 17 */
		/* 820A33D4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820A33D4h case    3:*/		return 0x820A33D8;
		  /* 820A33D8h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 820A33D8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A33E8;  }
		/* 820A33D8h case    4:*/		return 0x820A33DC;
		  /* 820A33DCh */ case    5:  		/* li R4, 0 */
		/* 820A33DCh case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A33DCh case    5:*/		return 0x820A33E0;
		  /* 820A33E0h */ case    6:  		/* lwz R3, <#[R31 + 2204]> */
		/* 820A33E0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A33E0h case    6:*/		return 0x820A33E4;
		  /* 820A33E4h */ case    7:  		/* bl 16764 */
		/* 820A33E4h case    7:*/		regs.LR = 0x820A33E8; return 0x820A7560;
		/* 820A33E4h case    7:*/		return 0x820A33E8;
	}
	return 0x820A33E8;
} // Block from 820A33C8h-820A33E8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A33E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A33E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A33E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A33E8);
		  /* 820A33E8h */ case    0:  		/* li R3, 0 */
		/* 820A33E8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A33E8h case    0:*/		return 0x820A33EC;
		  /* 820A33ECh */ case    1:  		/* stw R3, <#[R31 + 2252]> */
		/* 820A33ECh case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000008CC) );
		/* 820A33ECh case    1:*/		return 0x820A33F0;
	}
	return 0x820A33F0;
} // Block from 820A33E8h-820A33F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A33F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A33F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A33F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A33F0);
		  /* 820A33F0h */ case    0:  		/* stw R29, <#[R31 + 1636]> */
		/* 820A33F0h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000664) );
		/* 820A33F0h case    0:*/		return 0x820A33F4;
	}
	return 0x820A33F4;
} // Block from 820A33F0h-820A33F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A33F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A33F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A33F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A33F4);
		  /* 820A33F4h */ case    0:  		/* addi R1, R1, 112 */
		/* 820A33F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A33F4h case    0:*/		return 0x820A33F8;
		  /* 820A33F8h */ case    1:  		/* b -74060 */
		/* 820A33F8h case    1:*/		return 0x820912AC;
		/* 820A33F8h case    1:*/		return 0x820A33FC;
		  /* 820A33FCh */ case    2:  		/* nop */
		/* 820A33FCh case    2:*/		cpu::op::nop();
		/* 820A33FCh case    2:*/		return 0x820A3400;
	}
	return 0x820A3400;
} // Block from 820A33F4h-820A3400h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A3400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3400);
		  /* 820A3400h */ case    0:  		/* mfspr R12, LR */
		/* 820A3400h case    0:*/		regs.R12 = regs.LR;
		/* 820A3400h case    0:*/		return 0x820A3404;
		  /* 820A3404h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A3404h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A3404h case    1:*/		return 0x820A3408;
	}
	return 0x820A3408;
} // Block from 820A3400h-820A3408h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A3408h
// Function '?InitializeFromMemory@CPPInclude@D3DXShader@@QAAJPBDPBXIPAVCAlloc@D3DXCore@@PAVCTErrors@2@PAVCTokStringTable@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3408);
		  /* 820A3408h */ case    0:  		/* std R5, <#[R1 + 32]> */
		/* 820A3408h case    0:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 820A3408h case    0:*/		return 0x820A340C;
		  /* 820A340Ch */ case    1:  		/* std R6, <#[R1 + 40]> */
		/* 820A340Ch case    1:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820A340Ch case    1:*/		return 0x820A3410;
		  /* 820A3410h */ case    2:  		/* std R7, <#[R1 + 48]> */
		/* 820A3410h case    2:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820A3410h case    2:*/		return 0x820A3414;
		  /* 820A3414h */ case    3:  		/* std R8, <#[R1 + 56]> */
		/* 820A3414h case    3:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820A3414h case    3:*/		return 0x820A3418;
		  /* 820A3418h */ case    4:  		/* std R9, <#[R1 + 64]> */
		/* 820A3418h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820A3418h case    4:*/		return 0x820A341C;
		  /* 820A341Ch */ case    5:  		/* std R10, <#[R1 + 72]> */
		/* 820A341Ch case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820A341Ch case    5:*/		return 0x820A3420;
		  /* 820A3420h */ case    6:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A3420h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A3420h case    6:*/		return 0x820A3424;
		  /* 820A3424h */ case    7:  		/* stw R4, <#[R1 + 124]> */
		/* 820A3424h case    7:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 820A3424h case    7:*/		return 0x820A3428;
		  /* 820A3428h */ case    8:  		/* addi R11, R1, 80 */
		/* 820A3428h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A3428h case    8:*/		return 0x820A342C;
		  /* 820A342Ch */ case    9:  		/* addi R10, R1, 128 */
		/* 820A342Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 820A342Ch case    9:*/		return 0x820A3430;
		  /* 820A3430h */ case   10:  		/* lwz R3, <#[R3 + 3032]> */
		/* 820A3430h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000BD8) );
		/* 820A3430h case   10:*/		return 0x820A3434;
		  /* 820A3434h */ case   11:  		/* stw R10, <#[R11]> */
		/* 820A3434h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3434h case   11:*/		return 0x820A3438;
		  /* 820A3438h */ case   12:  		/* lwz R5, <#[R1 + 80]> */
		/* 820A3438h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3438h case   12:*/		return 0x820A343C;
		  /* 820A343Ch */ case   13:  		/* bl -1700 */
		/* 820A343Ch case   13:*/		regs.LR = 0x820A3440; return 0x820A2D98;
		/* 820A343Ch case   13:*/		return 0x820A3440;
		  /* 820A3440h */ case   14:  		/* addi R1, R1, 96 */
		/* 820A3440h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A3440h case   14:*/		return 0x820A3444;
		  /* 820A3444h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A3444h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A3444h case   15:*/		return 0x820A3448;
		  /* 820A3448h */ case   16:  		/* mtspr LR, R12 */
		/* 820A3448h case   16:*/		regs.LR = regs.R12;
		/* 820A3448h case   16:*/		return 0x820A344C;
		  /* 820A344Ch */ case   17:  		/* bclr 20, CR0_LT */
		/* 820A344Ch case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A344Ch case   17:*/		return 0x820A3450;
	}
	return 0x820A3450;
} // Block from 820A3408h-820A3450h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820A3450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3450);
		  /* 820A3450h */ case    0:  		/* mfspr R12, LR */
		/* 820A3450h case    0:*/		regs.R12 = regs.LR;
		/* 820A3450h case    0:*/		return 0x820A3454;
		  /* 820A3454h */ case    1:  		/* bl -74256 */
		/* 820A3454h case    1:*/		regs.LR = 0x820A3458; return 0x82091244;
		/* 820A3454h case    1:*/		return 0x820A3458;
		  /* 820A3458h */ case    2:  		/* stwu R1, <#[R1 - 304]> */
		/* 820A3458h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFED0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFED0);
		/* 820A3458h case    2:*/		return 0x820A345C;
		  /* 820A345Ch */ case    3:  		/* addi R11, R1, 96 */
		/* 820A345Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820A345Ch case    3:*/		return 0x820A3460;
		  /* 820A3460h */ case    4:  		/* lwz R23, <#[R3 + 2204]> */
		/* 820A3460h case    4:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R3 + 0x0000089C) );
		/* 820A3460h case    4:*/		return 0x820A3464;
		  /* 820A3464h */ case    5:  		/* li R30, 0 */
		/* 820A3464h case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A3464h case    5:*/		return 0x820A3468;
		  /* 820A3468h */ case    6:  		/* mr R25, R3 */
		/* 820A3468h case    6:*/		regs.R25 = regs.R3;
		/* 820A3468h case    6:*/		return 0x820A346C;
		  /* 820A346Ch */ case    7:  		/* mr R24, R4 */
		/* 820A346Ch case    7:*/		regs.R24 = regs.R4;
		/* 820A346Ch case    7:*/		return 0x820A3470;
		  /* 820A3470h */ case    8:  		/* lis R4, 9345 */
		/* 820A3470h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A3470h case    8:*/		return 0x820A3474;
		  /* 820A3474h */ case    9:  		/* std R30, <#[R11]> */
		/* 820A3474h case    9:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3474h case    9:*/		return 0x820A3478;
		  /* 820A3478h */ case   10:  		/* li R3, 20 */
		/* 820A3478h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A3478h case   10:*/		return 0x820A347C;
		  /* 820A347Ch */ case   11:  		/* std R30, <#[R11 + 8]> */
		/* 820A347Ch case   11:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R11 + 0x00000008) );
		/* 820A347Ch case   11:*/		return 0x820A3480;
		  /* 820A3480h */ case   12:  		/* std R30, <#[R11 + 16]> */
		/* 820A3480h case   12:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R11 + 0x00000010) );
		/* 820A3480h case   12:*/		return 0x820A3484;
		  /* 820A3484h */ case   13:  		/* std R30, <#[R11 + 24]> */
		/* 820A3484h case   13:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R11 + 0x00000018) );
		/* 820A3484h case   13:*/		return 0x820A3488;
	}
	return 0x820A3488;
} // Block from 820A3450h-820A3488h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A3488h
// Function '??1CPreProcessor@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3488);
		  /* 820A3488h */ case    0:  		/* std R30, <#[R11 + 32]> */
		/* 820A3488h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R11 + 0x00000020) );
		/* 820A3488h case    0:*/		return 0x820A348C;
		  /* 820A348Ch */ case    1:  		/* bl -111244 */
		/* 820A348Ch case    1:*/		regs.LR = 0x820A3490; return 0x82088200;
		/* 820A348Ch case    1:*/		return 0x820A3490;
		  /* 820A3490h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820A3490h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A3490h case    2:*/		return 0x820A3494;
		  /* 820A3494h */ case    3:  		/* bc 12, CR0_EQ, 44 */
		/* 820A3494h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A34C0;  }
		/* 820A3494h case    3:*/		return 0x820A3498;
		  /* 820A3498h */ case    4:  		/* lis R11, -32255 */
		/* 820A3498h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A3498h case    4:*/		return 0x820A349C;
		  /* 820A349Ch */ case    5:  		/* stw R30, <#[R3 + 4]> */
		/* 820A349Ch case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 820A349Ch case    5:*/		return 0x820A34A0;
		  /* 820A34A0h */ case    6:  		/* stw R30, <#[R3 + 8]> */
		/* 820A34A0h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 820A34A0h case    6:*/		return 0x820A34A4;
		  /* 820A34A4h */ case    7:  		/* mr R29, R3 */
		/* 820A34A4h case    7:*/		regs.R29 = regs.R3;
		/* 820A34A4h case    7:*/		return 0x820A34A8;
		  /* 820A34A8h */ case    8:  		/* addi R11, R11, -10164 */
		/* 820A34A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFD84C);
		/* 820A34A8h case    8:*/		return 0x820A34AC;
		  /* 820A34ACh */ case    9:  		/* stw R30, <#[R3 + 12]> */
		/* 820A34ACh case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A34ACh case    9:*/		return 0x820A34B0;
		  /* 820A34B0h */ case   10:  		/* stb R30, <#[R3 + 16]> */
		/* 820A34B0h case   10:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000010) );
		/* 820A34B0h case   10:*/		return 0x820A34B4;
		  /* 820A34B4h */ case   11:  		/* stw R11, <#[R3]> */
		/* 820A34B4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A34B4h case   11:*/		return 0x820A34B8;
		  /* 820A34B8h */ case   12:  		/* stb R30, <#[R3 + 17]> */
		/* 820A34B8h case   12:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000011) );
		/* 820A34B8h case   12:*/		return 0x820A34BC;
		  /* 820A34BCh */ case   13:  		/* b 8 */
		/* 820A34BCh case   13:*/		return 0x820A34C4;
		/* 820A34BCh case   13:*/		return 0x820A34C0;
	}
	return 0x820A34C0;
} // Block from 820A3488h-820A34C0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A34C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A34C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A34C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A34C0);
		  /* 820A34C0h */ case    0:  		/* mr R29, R30 */
		/* 820A34C0h case    0:*/		regs.R29 = regs.R30;
		/* 820A34C0h case    0:*/		return 0x820A34C4;
	}
	return 0x820A34C4;
} // Block from 820A34C0h-820A34C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A34C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A34C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A34C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A34C4);
		  /* 820A34C4h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820A34C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820A34C4h case    0:*/		return 0x820A34C8;
		  /* 820A34C8h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A34C8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A34D8;  }
		/* 820A34C8h case    1:*/		return 0x820A34CC;
		  /* 820A34CCh */ case    2:  		/* lis R31, -32761 */
		/* 820A34CCh case    2:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820A34CCh case    2:*/		return 0x820A34D0;
		  /* 820A34D0h */ case    3:  		/* ori R31, R31, 14 */
		/* 820A34D0h case    3:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820A34D0h case    3:*/		return 0x820A34D4;
		  /* 820A34D4h */ case    4:  		/* b 996 */
		/* 820A34D4h case    4:*/		return 0x820A38B8;
		/* 820A34D4h case    4:*/		return 0x820A34D8;
	}
	return 0x820A34D8;
} // Block from 820A34C4h-820A34D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A34D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A34D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A34D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A34D8);
		  /* 820A34D8h */ case    0:  		/* mr R4, R29 */
		/* 820A34D8h case    0:*/		regs.R4 = regs.R29;
		/* 820A34D8h case    0:*/		return 0x820A34DC;
		  /* 820A34DCh */ case    1:  		/* mr R3, R25 */
		/* 820A34DCh case    1:*/		regs.R3 = regs.R25;
		/* 820A34DCh case    1:*/		return 0x820A34E0;
		  /* 820A34E0h */ case    2:  		/* bl -4584 */
		/* 820A34E0h case    2:*/		regs.LR = 0x820A34E4; return 0x820A22F8;
		/* 820A34E0h case    2:*/		return 0x820A34E4;
		  /* 820A34E4h */ case    3:  		/* or. R31, R3, R3 */
		/* 820A34E4h case    3:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A34E4h case    3:*/		return 0x820A34E8;
		  /* 820A34E8h */ case    4:  		/* bc 12, CR0_LT, 976 */
		/* 820A34E8h case    4:*/		if ( regs.CR[0].lt ) { return 0x820A38B8;  }
		/* 820A34E8h case    4:*/		return 0x820A34EC;
		  /* 820A34ECh */ case    5:  		/* lis R4, 9345 */
		/* 820A34ECh case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A34ECh case    5:*/		return 0x820A34F0;
		  /* 820A34F0h */ case    6:  		/* li R3, 20 */
		/* 820A34F0h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A34F0h case    6:*/		return 0x820A34F4;
		  /* 820A34F4h */ case    7:  		/* bl -111348 */
		/* 820A34F4h case    7:*/		regs.LR = 0x820A34F8; return 0x82088200;
		/* 820A34F4h case    7:*/		return 0x820A34F8;
		  /* 820A34F8h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 820A34F8h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A34F8h case    8:*/		return 0x820A34FC;
		  /* 820A34FCh */ case    9:  		/* bc 12, CR0_EQ, 44 */
		/* 820A34FCh case    9:*/		if ( regs.CR[0].eq ) { return 0x820A3528;  }
		/* 820A34FCh case    9:*/		return 0x820A3500;
		  /* 820A3500h */ case   10:  		/* lis R11, -32255 */
		/* 820A3500h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A3500h case   10:*/		return 0x820A3504;
		  /* 820A3504h */ case   11:  		/* stw R30, <#[R3 + 4]> */
		/* 820A3504h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 820A3504h case   11:*/		return 0x820A3508;
		  /* 820A3508h */ case   12:  		/* stw R30, <#[R3 + 8]> */
		/* 820A3508h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 820A3508h case   12:*/		return 0x820A350C;
		  /* 820A350Ch */ case   13:  		/* mr R29, R3 */
		/* 820A350Ch case   13:*/		regs.R29 = regs.R3;
		/* 820A350Ch case   13:*/		return 0x820A3510;
		  /* 820A3510h */ case   14:  		/* addi R11, R11, -10172 */
		/* 820A3510h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFD844);
		/* 820A3510h case   14:*/		return 0x820A3514;
		  /* 820A3514h */ case   15:  		/* stw R30, <#[R3 + 12]> */
		/* 820A3514h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A3514h case   15:*/		return 0x820A3518;
		  /* 820A3518h */ case   16:  		/* stb R30, <#[R3 + 16]> */
		/* 820A3518h case   16:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000010) );
		/* 820A3518h case   16:*/		return 0x820A351C;
		  /* 820A351Ch */ case   17:  		/* stw R11, <#[R3]> */
		/* 820A351Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A351Ch case   17:*/		return 0x820A3520;
		  /* 820A3520h */ case   18:  		/* stb R30, <#[R3 + 17]> */
		/* 820A3520h case   18:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000011) );
		/* 820A3520h case   18:*/		return 0x820A3524;
		  /* 820A3524h */ case   19:  		/* b 8 */
		/* 820A3524h case   19:*/		return 0x820A352C;
		/* 820A3524h case   19:*/		return 0x820A3528;
	}
	return 0x820A3528;
} // Block from 820A34D8h-820A3528h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A3528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3528);
		  /* 820A3528h */ case    0:  		/* mr R29, R30 */
		/* 820A3528h case    0:*/		regs.R29 = regs.R30;
		/* 820A3528h case    0:*/		return 0x820A352C;
	}
	return 0x820A352C;
} // Block from 820A3528h-820A352Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A352Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A352C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A352C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A352C);
		  /* 820A352Ch */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820A352Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820A352Ch case    0:*/		return 0x820A3530;
		  /* 820A3530h */ case    1:  		/* bc 12, CR6_EQ, -100 */
		/* 820A3530h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A34CC;  }
		/* 820A3530h case    1:*/		return 0x820A3534;
		  /* 820A3534h */ case    2:  		/* mr R4, R29 */
		/* 820A3534h case    2:*/		regs.R4 = regs.R29;
		/* 820A3534h case    2:*/		return 0x820A3538;
		  /* 820A3538h */ case    3:  		/* mr R3, R25 */
		/* 820A3538h case    3:*/		regs.R3 = regs.R25;
		/* 820A3538h case    3:*/		return 0x820A353C;
		  /* 820A353Ch */ case    4:  		/* bl -4676 */
		/* 820A353Ch case    4:*/		regs.LR = 0x820A3540; return 0x820A22F8;
		/* 820A353Ch case    4:*/		return 0x820A3540;
		  /* 820A3540h */ case    5:  		/* or. R31, R3, R3 */
		/* 820A3540h case    5:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A3540h case    5:*/		return 0x820A3544;
		  /* 820A3544h */ case    6:  		/* bc 12, CR0_LT, 884 */
		/* 820A3544h case    6:*/		if ( regs.CR[0].lt ) { return 0x820A38B8;  }
		/* 820A3544h case    6:*/		return 0x820A3548;
		  /* 820A3548h */ case    7:  		/* lis R4, 9345 */
		/* 820A3548h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A3548h case    7:*/		return 0x820A354C;
		  /* 820A354Ch */ case    8:  		/* li R3, 20 */
		/* 820A354Ch case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A354Ch case    8:*/		return 0x820A3550;
		  /* 820A3550h */ case    9:  		/* bl -111440 */
		/* 820A3550h case    9:*/		regs.LR = 0x820A3554; return 0x82088200;
		/* 820A3550h case    9:*/		return 0x820A3554;
		  /* 820A3554h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 820A3554h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A3554h case   10:*/		return 0x820A3558;
		  /* 820A3558h */ case   11:  		/* bc 12, CR0_EQ, 44 */
		/* 820A3558h case   11:*/		if ( regs.CR[0].eq ) { return 0x820A3584;  }
		/* 820A3558h case   11:*/		return 0x820A355C;
		  /* 820A355Ch */ case   12:  		/* lis R11, -32255 */
		/* 820A355Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A355Ch case   12:*/		return 0x820A3560;
	}
	return 0x820A3560;
} // Block from 820A352Ch-820A3560h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A3560h
// Function '?AllocTokenString@CPreProcessor@D3DXShader@@QAAJPAUD3DXTOKEN@2@PBD_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3560);
		  /* 820A3560h */ case    0:  		/* stw R30, <#[R3 + 4]> */
		/* 820A3560h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 820A3560h case    0:*/		return 0x820A3564;
		  /* 820A3564h */ case    1:  		/* stw R30, <#[R3 + 8]> */
		/* 820A3564h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 820A3564h case    1:*/		return 0x820A3568;
		  /* 820A3568h */ case    2:  		/* mr R29, R3 */
		/* 820A3568h case    2:*/		regs.R29 = regs.R3;
		/* 820A3568h case    2:*/		return 0x820A356C;
		  /* 820A356Ch */ case    3:  		/* addi R11, R11, -10188 */
		/* 820A356Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFD834);
		/* 820A356Ch case    3:*/		return 0x820A3570;
		  /* 820A3570h */ case    4:  		/* stw R30, <#[R3 + 12]> */
		/* 820A3570h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A3570h case    4:*/		return 0x820A3574;
		  /* 820A3574h */ case    5:  		/* stb R30, <#[R3 + 16]> */
		/* 820A3574h case    5:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000010) );
		/* 820A3574h case    5:*/		return 0x820A3578;
		  /* 820A3578h */ case    6:  		/* stw R11, <#[R3]> */
		/* 820A3578h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A3578h case    6:*/		return 0x820A357C;
		  /* 820A357Ch */ case    7:  		/* stb R30, <#[R3 + 17]> */
		/* 820A357Ch case    7:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000011) );
		/* 820A357Ch case    7:*/		return 0x820A3580;
		  /* 820A3580h */ case    8:  		/* b 8 */
		/* 820A3580h case    8:*/		return 0x820A3588;
		/* 820A3580h case    8:*/		return 0x820A3584;
	}
	return 0x820A3584;
} // Block from 820A3560h-820A3584h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A3584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3584);
		  /* 820A3584h */ case    0:  		/* mr R29, R30 */
		/* 820A3584h case    0:*/		regs.R29 = regs.R30;
		/* 820A3584h case    0:*/		return 0x820A3588;
	}
	return 0x820A3588;
} // Block from 820A3584h-820A3588h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3588);
		  /* 820A3588h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820A3588h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820A3588h case    0:*/		return 0x820A358C;
		  /* 820A358Ch */ case    1:  		/* bc 12, CR6_EQ, -192 */
		/* 820A358Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820A34CC;  }
		/* 820A358Ch case    1:*/		return 0x820A3590;
		  /* 820A3590h */ case    2:  		/* mr R4, R29 */
		/* 820A3590h case    2:*/		regs.R4 = regs.R29;
		/* 820A3590h case    2:*/		return 0x820A3594;
		  /* 820A3594h */ case    3:  		/* mr R3, R25 */
		/* 820A3594h case    3:*/		regs.R3 = regs.R25;
		/* 820A3594h case    3:*/		return 0x820A3598;
		  /* 820A3598h */ case    4:  		/* bl -4768 */
		/* 820A3598h case    4:*/		regs.LR = 0x820A359C; return 0x820A22F8;
		/* 820A3598h case    4:*/		return 0x820A359C;
		  /* 820A359Ch */ case    5:  		/* or. R31, R3, R3 */
		/* 820A359Ch case    5:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A359Ch case    5:*/		return 0x820A35A0;
		  /* 820A35A0h */ case    6:  		/* bc 12, CR0_LT, 792 */
		/* 820A35A0h case    6:*/		if ( regs.CR[0].lt ) { return 0x820A38B8;  }
		/* 820A35A0h case    6:*/		return 0x820A35A4;
		  /* 820A35A4h */ case    7:  		/* li R28, 2 */
		/* 820A35A4h case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x2);
		/* 820A35A4h case    7:*/		return 0x820A35A8;
		  /* 820A35A8h */ case    8:  		/* lis R4, 9345 */
		/* 820A35A8h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A35A8h case    8:*/		return 0x820A35AC;
		  /* 820A35ACh */ case    9:  		/* stw R28, <#[R1 + 96]> */
		/* 820A35ACh case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000060) );
		/* 820A35ACh case    9:*/		return 0x820A35B0;
		  /* 820A35B0h */ case   10:  		/* li R3, 20 */
		/* 820A35B0h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A35B0h case   10:*/		return 0x820A35B4;
		  /* 820A35B4h */ case   11:  		/* stw R28, <#[R1 + 104]> */
		/* 820A35B4h case   11:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000068) );
		/* 820A35B4h case   11:*/		return 0x820A35B8;
		  /* 820A35B8h */ case   12:  		/* bl -111544 */
		/* 820A35B8h case   12:*/		regs.LR = 0x820A35BC; return 0x82088200;
		/* 820A35B8h case   12:*/		return 0x820A35BC;
		  /* 820A35BCh */ case   13:  		/* cmplwi CR0, R3, 0 */
		/* 820A35BCh case   13:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A35BCh case   13:*/		return 0x820A35C0;
		  /* 820A35C0h */ case   14:  		/* bc 12, CR0_EQ, 44 */
		/* 820A35C0h case   14:*/		if ( regs.CR[0].eq ) { return 0x820A35EC;  }
		/* 820A35C0h case   14:*/		return 0x820A35C4;
		  /* 820A35C4h */ case   15:  		/* lis R11, -32255 */
		/* 820A35C4h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A35C4h case   15:*/		return 0x820A35C8;
		  /* 820A35C8h */ case   16:  		/* stw R30, <#[R3 + 4]> */
		/* 820A35C8h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 820A35C8h case   16:*/		return 0x820A35CC;
		  /* 820A35CCh */ case   17:  		/* stw R30, <#[R3 + 8]> */
		/* 820A35CCh case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 820A35CCh case   17:*/		return 0x820A35D0;
		  /* 820A35D0h */ case   18:  		/* mr R29, R3 */
		/* 820A35D0h case   18:*/		regs.R29 = regs.R3;
		/* 820A35D0h case   18:*/		return 0x820A35D4;
		  /* 820A35D4h */ case   19:  		/* addi R11, R11, -10204 */
		/* 820A35D4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFD824);
		/* 820A35D4h case   19:*/		return 0x820A35D8;
		  /* 820A35D8h */ case   20:  		/* stw R30, <#[R3 + 12]> */
		/* 820A35D8h case   20:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A35D8h case   20:*/		return 0x820A35DC;
		  /* 820A35DCh */ case   21:  		/* stb R30, <#[R3 + 16]> */
		/* 820A35DCh case   21:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000010) );
		/* 820A35DCh case   21:*/		return 0x820A35E0;
		  /* 820A35E0h */ case   22:  		/* stw R11, <#[R3]> */
		/* 820A35E0h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A35E0h case   22:*/		return 0x820A35E4;
		  /* 820A35E4h */ case   23:  		/* stb R30, <#[R3 + 17]> */
		/* 820A35E4h case   23:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000011) );
		/* 820A35E4h case   23:*/		return 0x820A35E8;
		  /* 820A35E8h */ case   24:  		/* b 8 */
		/* 820A35E8h case   24:*/		return 0x820A35F0;
		/* 820A35E8h case   24:*/		return 0x820A35EC;
	}
	return 0x820A35EC;
} // Block from 820A3588h-820A35ECh (25 instructions)

//////////////////////////////////////////////////////
// Block at 820A35ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A35EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A35EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A35EC);
		  /* 820A35ECh */ case    0:  		/* mr R29, R30 */
		/* 820A35ECh case    0:*/		regs.R29 = regs.R30;
		/* 820A35ECh case    0:*/		return 0x820A35F0;
	}
	return 0x820A35F0;
} // Block from 820A35ECh-820A35F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A35F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A35F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A35F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A35F0);
		  /* 820A35F0h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820A35F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820A35F0h case    0:*/		return 0x820A35F4;
		  /* 820A35F4h */ case    1:  		/* bc 12, CR6_EQ, -296 */
		/* 820A35F4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A34CC;  }
		/* 820A35F4h case    1:*/		return 0x820A35F8;
		  /* 820A35F8h */ case    2:  		/* li R3, 56 */
		/* 820A35F8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A35F8h case    2:*/		return 0x820A35FC;
		  /* 820A35FCh */ case    3:  		/* bl 154668 */
		/* 820A35FCh case    3:*/		regs.LR = 0x820A3600; return 0x820C9228;
		/* 820A35FCh case    3:*/		return 0x820A3600;
		  /* 820A3600h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820A3600h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A3600h case    4:*/		return 0x820A3604;
		  /* 820A3604h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820A3604h case    5:*/		if ( regs.CR[0].eq ) { return 0x820A3614;  }
		/* 820A3604h case    5:*/		return 0x820A3608;
		  /* 820A3608h */ case    6:  		/* addi R4, R1, 96 */
		/* 820A3608h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820A3608h case    6:*/		return 0x820A360C;
		  /* 820A360Ch */ case    7:  		/* bl 156228 */
		/* 820A360Ch case    7:*/		regs.LR = 0x820A3610; return 0x820C9850;
		/* 820A360Ch case    7:*/		return 0x820A3610;
		  /* 820A3610h */ case    8:  		/* b 8 */
		/* 820A3610h case    8:*/		return 0x820A3618;
		/* 820A3610h case    8:*/		return 0x820A3614;
	}
	return 0x820A3614;
} // Block from 820A35F0h-820A3614h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A3614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3614);
		  /* 820A3614h */ case    0:  		/* mr R3, R30 */
		/* 820A3614h case    0:*/		regs.R3 = regs.R30;
		/* 820A3614h case    0:*/		return 0x820A3618;
	}
	return 0x820A3618;
} // Block from 820A3614h-820A3618h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3618);
		  /* 820A3618h */ case    0:  		/* stw R3, <#[R29 + 8]> */
		/* 820A3618h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 820A3618h case    0:*/		return 0x820A361C;
		  /* 820A361Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A361Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A361Ch case    1:*/		return 0x820A3620;
		  /* 820A3620h */ case    2:  		/* bc 12, CR6_EQ, -340 */
		/* 820A3620h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A34CC;  }
		/* 820A3620h case    2:*/		return 0x820A3624;
		  /* 820A3624h */ case    3:  		/* mr R4, R29 */
		/* 820A3624h case    3:*/		regs.R4 = regs.R29;
		/* 820A3624h case    3:*/		return 0x820A3628;
		  /* 820A3628h */ case    4:  		/* mr R3, R25 */
		/* 820A3628h case    4:*/		regs.R3 = regs.R25;
		/* 820A3628h case    4:*/		return 0x820A362C;
		  /* 820A362Ch */ case    5:  		/* bl -4916 */
		/* 820A362Ch case    5:*/		regs.LR = 0x820A3630; return 0x820A22F8;
		/* 820A362Ch case    5:*/		return 0x820A3630;
		  /* 820A3630h */ case    6:  		/* or. R31, R3, R3 */
		/* 820A3630h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A3630h case    6:*/		return 0x820A3634;
		  /* 820A3634h */ case    7:  		/* bc 12, CR0_LT, 644 */
		/* 820A3634h case    7:*/		if ( regs.CR[0].lt ) { return 0x820A38B8;  }
		/* 820A3634h case    7:*/		return 0x820A3638;
		  /* 820A3638h */ case    8:  		/* li R11, 2560 */
		/* 820A3638h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0xA00);
		/* 820A3638h case    8:*/		return 0x820A363C;
		  /* 820A363Ch */ case    9:  		/* stw R28, <#[R1 + 96]> */
		/* 820A363Ch case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000060) );
		/* 820A363Ch case    9:*/		return 0x820A3640;
		  /* 820A3640h */ case   10:  		/* lis R4, 9345 */
		/* 820A3640h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A3640h case   10:*/		return 0x820A3644;
		  /* 820A3644h */ case   11:  		/* stw R11, <#[R1 + 104]> */
		/* 820A3644h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820A3644h case   11:*/		return 0x820A3648;
		  /* 820A3648h */ case   12:  		/* li R3, 20 */
		/* 820A3648h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A3648h case   12:*/		return 0x820A364C;
		  /* 820A364Ch */ case   13:  		/* bl -111692 */
		/* 820A364Ch case   13:*/		regs.LR = 0x820A3650; return 0x82088200;
		/* 820A364Ch case   13:*/		return 0x820A3650;
		  /* 820A3650h */ case   14:  		/* cmplwi CR0, R3, 0 */
		/* 820A3650h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A3650h case   14:*/		return 0x820A3654;
		  /* 820A3654h */ case   15:  		/* bc 12, CR0_EQ, 44 */
		/* 820A3654h case   15:*/		if ( regs.CR[0].eq ) { return 0x820A3680;  }
		/* 820A3654h case   15:*/		return 0x820A3658;
		  /* 820A3658h */ case   16:  		/* lis R11, -32255 */
		/* 820A3658h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A3658h case   16:*/		return 0x820A365C;
		  /* 820A365Ch */ case   17:  		/* stw R30, <#[R3 + 4]> */
		/* 820A365Ch case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 820A365Ch case   17:*/		return 0x820A3660;
		  /* 820A3660h */ case   18:  		/* stw R30, <#[R3 + 8]> */
		/* 820A3660h case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 820A3660h case   18:*/		return 0x820A3664;
		  /* 820A3664h */ case   19:  		/* mr R29, R3 */
		/* 820A3664h case   19:*/		regs.R29 = regs.R3;
		/* 820A3664h case   19:*/		return 0x820A3668;
		  /* 820A3668h */ case   20:  		/* addi R11, R11, -10224 */
		/* 820A3668h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFD810);
		/* 820A3668h case   20:*/		return 0x820A366C;
		  /* 820A366Ch */ case   21:  		/* stw R30, <#[R3 + 12]> */
		/* 820A366Ch case   21:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A366Ch case   21:*/		return 0x820A3670;
		  /* 820A3670h */ case   22:  		/* stb R30, <#[R3 + 16]> */
		/* 820A3670h case   22:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000010) );
		/* 820A3670h case   22:*/		return 0x820A3674;
		  /* 820A3674h */ case   23:  		/* stw R11, <#[R3]> */
		/* 820A3674h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A3674h case   23:*/		return 0x820A3678;
		  /* 820A3678h */ case   24:  		/* stb R30, <#[R3 + 17]> */
		/* 820A3678h case   24:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000011) );
		/* 820A3678h case   24:*/		return 0x820A367C;
		  /* 820A367Ch */ case   25:  		/* b 8 */
		/* 820A367Ch case   25:*/		return 0x820A3684;
		/* 820A367Ch case   25:*/		return 0x820A3680;
	}
	return 0x820A3680;
} // Block from 820A3618h-820A3680h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820A3680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3680);
		  /* 820A3680h */ case    0:  		/* mr R29, R30 */
		/* 820A3680h case    0:*/		regs.R29 = regs.R30;
		/* 820A3680h case    0:*/		return 0x820A3684;
	}
	return 0x820A3684;
} // Block from 820A3680h-820A3684h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3684);
		  /* 820A3684h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820A3684h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820A3684h case    0:*/		return 0x820A3688;
		  /* 820A3688h */ case    1:  		/* bc 12, CR6_EQ, -444 */
		/* 820A3688h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A34CC;  }
		/* 820A3688h case    1:*/		return 0x820A368C;
		  /* 820A368Ch */ case    2:  		/* li R3, 56 */
		/* 820A368Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A368Ch case    2:*/		return 0x820A3690;
		  /* 820A3690h */ case    3:  		/* bl 154520 */
		/* 820A3690h case    3:*/		regs.LR = 0x820A3694; return 0x820C9228;
		/* 820A3690h case    3:*/		return 0x820A3694;
		  /* 820A3694h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820A3694h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A3694h case    4:*/		return 0x820A3698;
		  /* 820A3698h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820A3698h case    5:*/		if ( regs.CR[0].eq ) { return 0x820A36A8;  }
		/* 820A3698h case    5:*/		return 0x820A369C;
		  /* 820A369Ch */ case    6:  		/* addi R4, R1, 96 */
		/* 820A369Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820A369Ch case    6:*/		return 0x820A36A0;
		  /* 820A36A0h */ case    7:  		/* bl 156080 */
		/* 820A36A0h case    7:*/		regs.LR = 0x820A36A4; return 0x820C9850;
		/* 820A36A0h case    7:*/		return 0x820A36A4;
		  /* 820A36A4h */ case    8:  		/* b 8 */
		/* 820A36A4h case    8:*/		return 0x820A36AC;
		/* 820A36A4h case    8:*/		return 0x820A36A8;
	}
	return 0x820A36A8;
} // Block from 820A3684h-820A36A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A36A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A36A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A36A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A36A8);
		  /* 820A36A8h */ case    0:  		/* mr R3, R30 */
		/* 820A36A8h case    0:*/		regs.R3 = regs.R30;
		/* 820A36A8h case    0:*/		return 0x820A36AC;
	}
	return 0x820A36AC;
} // Block from 820A36A8h-820A36ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A36ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A36AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A36AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A36AC);
		  /* 820A36ACh */ case    0:  		/* stw R3, <#[R29 + 8]> */
		/* 820A36ACh case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 820A36ACh case    0:*/		return 0x820A36B0;
		  /* 820A36B0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A36B0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A36B0h case    1:*/		return 0x820A36B4;
		  /* 820A36B4h */ case    2:  		/* bc 12, CR6_EQ, -488 */
		/* 820A36B4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A34CC;  }
		/* 820A36B4h case    2:*/		return 0x820A36B8;
		  /* 820A36B8h */ case    3:  		/* mr R4, R29 */
		/* 820A36B8h case    3:*/		regs.R4 = regs.R29;
		/* 820A36B8h case    3:*/		return 0x820A36BC;
		  /* 820A36BCh */ case    4:  		/* mr R3, R25 */
		/* 820A36BCh case    4:*/		regs.R3 = regs.R25;
		/* 820A36BCh case    4:*/		return 0x820A36C0;
		  /* 820A36C0h */ case    5:  		/* bl -5064 */
		/* 820A36C0h case    5:*/		regs.LR = 0x820A36C4; return 0x820A22F8;
		/* 820A36C0h case    5:*/		return 0x820A36C4;
		  /* 820A36C4h */ case    6:  		/* or. R31, R3, R3 */
		/* 820A36C4h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A36C4h case    6:*/		return 0x820A36C8;
		  /* 820A36C8h */ case    7:  		/* bc 12, CR0_LT, 496 */
		/* 820A36C8h case    7:*/		if ( regs.CR[0].lt ) { return 0x820A38B8;  }
		/* 820A36C8h case    7:*/		return 0x820A36CC;
		  /* 820A36CCh */ case    8:  		/* li R11, 2589 */
		/* 820A36CCh case    8:*/		cpu::op::li<0>(regs,&regs.R11,0xA1D);
		/* 820A36CCh case    8:*/		return 0x820A36D0;
		  /* 820A36D0h */ case    9:  		/* stw R28, <#[R1 + 96]> */
		/* 820A36D0h case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000060) );
		/* 820A36D0h case    9:*/		return 0x820A36D4;
		  /* 820A36D4h */ case   10:  		/* lis R4, 9345 */
		/* 820A36D4h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A36D4h case   10:*/		return 0x820A36D8;
		  /* 820A36D8h */ case   11:  		/* stw R11, <#[R1 + 104]> */
		/* 820A36D8h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820A36D8h case   11:*/		return 0x820A36DC;
		  /* 820A36DCh */ case   12:  		/* li R3, 20 */
		/* 820A36DCh case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A36DCh case   12:*/		return 0x820A36E0;
		  /* 820A36E0h */ case   13:  		/* bl -111840 */
		/* 820A36E0h case   13:*/		regs.LR = 0x820A36E4; return 0x82088200;
		/* 820A36E0h case   13:*/		return 0x820A36E4;
		  /* 820A36E4h */ case   14:  		/* cmplwi CR0, R3, 0 */
		/* 820A36E4h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A36E4h case   14:*/		return 0x820A36E8;
		  /* 820A36E8h */ case   15:  		/* bc 12, CR0_EQ, 44 */
		/* 820A36E8h case   15:*/		if ( regs.CR[0].eq ) { return 0x820A3714;  }
		/* 820A36E8h case   15:*/		return 0x820A36EC;
		  /* 820A36ECh */ case   16:  		/* lis R11, -32255 */
		/* 820A36ECh case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A36ECh case   16:*/		return 0x820A36F0;
		  /* 820A36F0h */ case   17:  		/* stw R30, <#[R3 + 4]> */
		/* 820A36F0h case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 820A36F0h case   17:*/		return 0x820A36F4;
		  /* 820A36F4h */ case   18:  		/* stw R30, <#[R3 + 8]> */
		/* 820A36F4h case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 820A36F4h case   18:*/		return 0x820A36F8;
		  /* 820A36F8h */ case   19:  		/* mr R29, R3 */
		/* 820A36F8h case   19:*/		regs.R29 = regs.R3;
		/* 820A36F8h case   19:*/		return 0x820A36FC;
		  /* 820A36FCh */ case   20:  		/* addi R11, R11, -10240 */
		/* 820A36FCh case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFD800);
		/* 820A36FCh case   20:*/		return 0x820A3700;
	}
	return 0x820A3700;
} // Block from 820A36ACh-820A3700h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820A3700h
// Function '?AllocTokenUint@CPreProcessor@D3DXShader@@QAAJPAUD3DXTOKEN@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3700);
		  /* 820A3700h */ case    0:  		/* stw R30, <#[R3 + 12]> */
		/* 820A3700h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A3700h case    0:*/		return 0x820A3704;
		  /* 820A3704h */ case    1:  		/* stb R30, <#[R3 + 16]> */
		/* 820A3704h case    1:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000010) );
		/* 820A3704h case    1:*/		return 0x820A3708;
		  /* 820A3708h */ case    2:  		/* stw R11, <#[R3]> */
		/* 820A3708h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A3708h case    2:*/		return 0x820A370C;
		  /* 820A370Ch */ case    3:  		/* stb R30, <#[R3 + 17]> */
		/* 820A370Ch case    3:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000011) );
		/* 820A370Ch case    3:*/		return 0x820A3710;
		  /* 820A3710h */ case    4:  		/* b 8 */
		/* 820A3710h case    4:*/		return 0x820A3718;
		/* 820A3710h case    4:*/		return 0x820A3714;
	}
	return 0x820A3714;
} // Block from 820A3700h-820A3714h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A3714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3714);
		  /* 820A3714h */ case    0:  		/* mr R29, R30 */
		/* 820A3714h case    0:*/		regs.R29 = regs.R30;
		/* 820A3714h case    0:*/		return 0x820A3718;
	}
	return 0x820A3718;
} // Block from 820A3714h-820A3718h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3718);
		  /* 820A3718h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820A3718h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820A3718h case    0:*/		return 0x820A371C;
		  /* 820A371Ch */ case    1:  		/* bc 12, CR6_EQ, -592 */
		/* 820A371Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820A34CC;  }
		/* 820A371Ch case    1:*/		return 0x820A3720;
		  /* 820A3720h */ case    2:  		/* li R3, 56 */
		/* 820A3720h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A3720h case    2:*/		return 0x820A3724;
		  /* 820A3724h */ case    3:  		/* bl 154372 */
		/* 820A3724h case    3:*/		regs.LR = 0x820A3728; return 0x820C9228;
		/* 820A3724h case    3:*/		return 0x820A3728;
		  /* 820A3728h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820A3728h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A3728h case    4:*/		return 0x820A372C;
		  /* 820A372Ch */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820A372Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820A373C;  }
		/* 820A372Ch case    5:*/		return 0x820A3730;
		  /* 820A3730h */ case    6:  		/* addi R4, R1, 96 */
		/* 820A3730h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820A3730h case    6:*/		return 0x820A3734;
		  /* 820A3734h */ case    7:  		/* bl 155932 */
		/* 820A3734h case    7:*/		regs.LR = 0x820A3738; return 0x820C9850;
		/* 820A3734h case    7:*/		return 0x820A3738;
		  /* 820A3738h */ case    8:  		/* b 8 */
		/* 820A3738h case    8:*/		return 0x820A3740;
		/* 820A3738h case    8:*/		return 0x820A373C;
	}
	return 0x820A373C;
} // Block from 820A3718h-820A373Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A373Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A373C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A373C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A373C);
		  /* 820A373Ch */ case    0:  		/* mr R3, R30 */
		/* 820A373Ch case    0:*/		regs.R3 = regs.R30;
		/* 820A373Ch case    0:*/		return 0x820A3740;
	}
	return 0x820A3740;
} // Block from 820A373Ch-820A3740h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3740);
		  /* 820A3740h */ case    0:  		/* stw R3, <#[R29 + 8]> */
		/* 820A3740h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 820A3740h case    0:*/		return 0x820A3744;
		  /* 820A3744h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A3744h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A3744h case    1:*/		return 0x820A3748;
		  /* 820A3748h */ case    2:  		/* bc 12, CR6_EQ, -636 */
		/* 820A3748h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A34CC;  }
		/* 820A3748h case    2:*/		return 0x820A374C;
		  /* 820A374Ch */ case    3:  		/* mr R4, R29 */
		/* 820A374Ch case    3:*/		regs.R4 = regs.R29;
		/* 820A374Ch case    3:*/		return 0x820A3750;
		  /* 820A3750h */ case    4:  		/* mr R3, R25 */
		/* 820A3750h case    4:*/		regs.R3 = regs.R25;
		/* 820A3750h case    4:*/		return 0x820A3754;
		  /* 820A3754h */ case    5:  		/* bl -5212 */
		/* 820A3754h case    5:*/		regs.LR = 0x820A3758; return 0x820A22F8;
		/* 820A3754h case    5:*/		return 0x820A3758;
		  /* 820A3758h */ case    6:  		/* or. R31, R3, R3 */
		/* 820A3758h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A3758h case    6:*/		return 0x820A375C;
		  /* 820A375Ch */ case    7:  		/* bc 12, CR0_LT, 348 */
		/* 820A375Ch case    7:*/		if ( regs.CR[0].lt ) { return 0x820A38B8;  }
		/* 820A375Ch case    7:*/		return 0x820A3760;
		  /* 820A3760h */ case    8:  		/* lis R4, 9345 */
		/* 820A3760h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A3760h case    8:*/		return 0x820A3764;
		  /* 820A3764h */ case    9:  		/* li R3, 20 */
		/* 820A3764h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A3764h case    9:*/		return 0x820A3768;
		  /* 820A3768h */ case   10:  		/* bl -111976 */
		/* 820A3768h case   10:*/		regs.LR = 0x820A376C; return 0x82088200;
		/* 820A3768h case   10:*/		return 0x820A376C;
		  /* 820A376Ch */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820A376Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A376Ch case   11:*/		return 0x820A3770;
		  /* 820A3770h */ case   12:  		/* bc 12, CR0_EQ, 44 */
		/* 820A3770h case   12:*/		if ( regs.CR[0].eq ) { return 0x820A379C;  }
		/* 820A3770h case   12:*/		return 0x820A3774;
		  /* 820A3774h */ case   13:  		/* lis R11, -32255 */
		/* 820A3774h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A3774h case   13:*/		return 0x820A3778;
		  /* 820A3778h */ case   14:  		/* stw R30, <#[R3 + 4]> */
		/* 820A3778h case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 820A3778h case   14:*/		return 0x820A377C;
		  /* 820A377Ch */ case   15:  		/* stw R30, <#[R3 + 8]> */
		/* 820A377Ch case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 820A377Ch case   15:*/		return 0x820A3780;
		  /* 820A3780h */ case   16:  		/* mr R29, R3 */
		/* 820A3780h case   16:*/		regs.R29 = regs.R3;
		/* 820A3780h case   16:*/		return 0x820A3784;
		  /* 820A3784h */ case   17:  		/* addi R11, R11, -10248 */
		/* 820A3784h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFD7F8);
		/* 820A3784h case   17:*/		return 0x820A3788;
		  /* 820A3788h */ case   18:  		/* stw R30, <#[R3 + 12]> */
		/* 820A3788h case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A3788h case   18:*/		return 0x820A378C;
		  /* 820A378Ch */ case   19:  		/* stb R30, <#[R3 + 16]> */
		/* 820A378Ch case   19:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000010) );
		/* 820A378Ch case   19:*/		return 0x820A3790;
		  /* 820A3790h */ case   20:  		/* stw R11, <#[R3]> */
		/* 820A3790h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A3790h case   20:*/		return 0x820A3794;
		  /* 820A3794h */ case   21:  		/* stb R30, <#[R3 + 17]> */
		/* 820A3794h case   21:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R3 + 0x00000011) );
		/* 820A3794h case   21:*/		return 0x820A3798;
		  /* 820A3798h */ case   22:  		/* b 8 */
		/* 820A3798h case   22:*/		return 0x820A37A0;
		/* 820A3798h case   22:*/		return 0x820A379C;
	}
	return 0x820A379C;
} // Block from 820A3740h-820A379Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 820A379Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A379C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A379C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A379C);
		  /* 820A379Ch */ case    0:  		/* mr R29, R30 */
		/* 820A379Ch case    0:*/		regs.R29 = regs.R30;
		/* 820A379Ch case    0:*/		return 0x820A37A0;
	}
	return 0x820A37A0;
} // Block from 820A379Ch-820A37A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A37A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A37A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A37A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A37A0);
		  /* 820A37A0h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820A37A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820A37A0h case    0:*/		return 0x820A37A4;
		  /* 820A37A4h */ case    1:  		/* bc 12, CR6_EQ, -728 */
		/* 820A37A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A34CC;  }
		/* 820A37A4h case    1:*/		return 0x820A37A8;
		  /* 820A37A8h */ case    2:  		/* mr R4, R29 */
		/* 820A37A8h case    2:*/		regs.R4 = regs.R29;
		/* 820A37A8h case    2:*/		return 0x820A37AC;
		  /* 820A37ACh */ case    3:  		/* mr R3, R25 */
		/* 820A37ACh case    3:*/		regs.R3 = regs.R25;
		/* 820A37ACh case    3:*/		return 0x820A37B0;
	}
	return 0x820A37B0;
} // Block from 820A37A0h-820A37B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A37B0h
// Function '?VError@CPreProcessor@D3DXShader@@IAAXPBDPAD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A37B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A37B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A37B0);
		  /* 820A37B0h */ case    0:  		/* bl -5304 */
		/* 820A37B0h case    0:*/		regs.LR = 0x820A37B4; return 0x820A22F8;
		/* 820A37B0h case    0:*/		return 0x820A37B4;
		  /* 820A37B4h */ case    1:  		/* or. R31, R3, R3 */
		/* 820A37B4h case    1:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A37B4h case    1:*/		return 0x820A37B8;
		  /* 820A37B8h */ case    2:  		/* bc 12, CR0_LT, 256 */
		/* 820A37B8h case    2:*/		if ( regs.CR[0].lt ) { return 0x820A38B8;  }
		/* 820A37B8h case    2:*/		return 0x820A37BC;
		  /* 820A37BCh */ case    3:  		/* lis R11, -32255 */
		/* 820A37BCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A37BCh case    3:*/		return 0x820A37C0;
		  /* 820A37C0h */ case    4:  		/* mr R3, R25 */
		/* 820A37C0h case    4:*/		regs.R3 = regs.R25;
		/* 820A37C0h case    4:*/		return 0x820A37C4;
		  /* 820A37C4h */ case    5:  		/* addi R4, R11, -10256 */
		/* 820A37C4h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFD7F0);
		/* 820A37C4h case    5:*/		return 0x820A37C8;
		  /* 820A37C8h */ case    6:  		/* mr R29, R30 */
		/* 820A37C8h case    6:*/		regs.R29 = regs.R30;
		/* 820A37C8h case    6:*/		return 0x820A37CC;
		  /* 820A37CCh */ case    7:  		/* bl -5092 */
		/* 820A37CCh case    7:*/		regs.LR = 0x820A37D0; return 0x820A23E8;
		/* 820A37CCh case    7:*/		return 0x820A37D0;
		  /* 820A37D0h */ case    8:  		/* or. R31, R3, R3 */
		/* 820A37D0h case    8:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A37D0h case    8:*/		return 0x820A37D4;
		  /* 820A37D4h */ case    9:  		/* bc 12, CR0_LT, 228 */
		/* 820A37D4h case    9:*/		if ( regs.CR[0].lt ) { return 0x820A38B8;  }
		/* 820A37D4h case    9:*/		return 0x820A37D8;
		  /* 820A37D8h */ case   10:  		/* lis R11, -32255 */
		/* 820A37D8h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A37D8h case   10:*/		return 0x820A37DC;
		  /* 820A37DCh */ case   11:  		/* li R5, 200 */
		/* 820A37DCh case   11:*/		cpu::op::li<0>(regs,&regs.R5,0xC8);
		/* 820A37DCh case   11:*/		return 0x820A37E0;
		  /* 820A37E0h */ case   12:  		/* addi R4, R11, -10268 */
		/* 820A37E0h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFD7E4);
		/* 820A37E0h case   12:*/		return 0x820A37E4;
		  /* 820A37E4h */ case   13:  		/* mr R3, R25 */
		/* 820A37E4h case   13:*/		regs.R3 = regs.R25;
		/* 820A37E4h case   13:*/		return 0x820A37E8;
		  /* 820A37E8h */ case   14:  		/* bl -4976 */
		/* 820A37E8h case   14:*/		regs.LR = 0x820A37EC; return 0x820A2478;
		/* 820A37E8h case   14:*/		return 0x820A37EC;
		  /* 820A37ECh */ case   15:  		/* or. R31, R3, R3 */
		/* 820A37ECh case   15:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A37ECh case   15:*/		return 0x820A37F0;
		  /* 820A37F0h */ case   16:  		/* bc 12, CR0_LT, 200 */
		/* 820A37F0h case   16:*/		if ( regs.CR[0].lt ) { return 0x820A38B8;  }
		/* 820A37F0h case   16:*/		return 0x820A37F4;
		  /* 820A37F4h */ case   17:  		/* cmplwi CR6, R24, 0 */
		/* 820A37F4h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820A37F4h case   17:*/		return 0x820A37F8;
		  /* 820A37F8h */ case   18:  		/* bc 12, CR6_EQ, 188 */
		/* 820A37F8h case   18:*/		if ( regs.CR[6].eq ) { return 0x820A38B4;  }
		/* 820A37F8h case   18:*/		return 0x820A37FC;
		  /* 820A37FCh */ case   19:  		/* addi R3, R1, 144 */
		/* 820A37FCh case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x90);
		/* 820A37FCh case   19:*/		return 0x820A3800;
		  /* 820A3800h */ case   20:  		/* bl 10120 */
		/* 820A3800h case   20:*/		regs.LR = 0x820A3804; return 0x820A5F88;
		/* 820A3800h case   20:*/		return 0x820A3804;
		  /* 820A3804h */ case   21:  		/* addi R11, R1, 144 */
		/* 820A3804h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 820A3804h case   21:*/		return 0x820A3808;
		  /* 820A3808h */ case   22:  		/* stw R11, <#[R25 + 2204]> */
		/* 820A3808h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x0000089C) );
		/* 820A3808h case   22:*/		return 0x820A380C;
		  /* 820A380Ch */ case   23:  		/* lwz R11, <#[R24]> */
		/* 820A380Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 820A380Ch case   23:*/		return 0x820A3810;
		  /* 820A3810h */ case   24:  		/* cmplwi CR6, R11, 0 */
		/* 820A3810h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A3810h case   24:*/		return 0x820A3814;
		  /* 820A3814h */ case   25:  		/* bc 12, CR6_EQ, 152 */
		/* 820A3814h case   25:*/		if ( regs.CR[6].eq ) { return 0x820A38AC;  }
		/* 820A3814h case   25:*/		return 0x820A3818;
		  /* 820A3818h */ case   26:  		/* addi R27, R25, 80 */
		/* 820A3818h case   26:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R25,0x50);
		/* 820A3818h case   26:*/		return 0x820A381C;
		  /* 820A381Ch */ case   27:  		/* addi R26, R25, 24 */
		/* 820A381Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R25,0x18);
		/* 820A381Ch case   27:*/		return 0x820A3820;
		  /* 820A3820h */ case   28:  		/* addi R28, R24, 4 */
		/* 820A3820h case   28:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R24,0x4);
		/* 820A3820h case   28:*/		return 0x820A3824;
		  /* 820A3824h */ case   29:  		/* lwz R4, <#[R28]> */
		/* 820A3824h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 820A3824h case   29:*/		return 0x820A3828;
		  /* 820A3828h */ case   30:  		/* cmplwi CR6, R4, 0 */
		/* 820A3828h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A3828h case   30:*/		return 0x820A382C;
		  /* 820A382Ch */ case   31:  		/* bc 12, CR6_EQ, 40 */
		/* 820A382Ch case   31:*/		if ( regs.CR[6].eq ) { return 0x820A3854;  }
		/* 820A382Ch case   31:*/		return 0x820A3830;
		  /* 820A3830h */ case   32:  		/* mr R11, R4 */
		/* 820A3830h case   32:*/		regs.R11 = regs.R4;
		/* 820A3830h case   32:*/		return 0x820A3834;
		  /* 820A3834h */ case   33:  		/* lbz R10, <#[R11]> */
		/* 820A3834h case   33:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3834h case   33:*/		return 0x820A3838;
		  /* 820A3838h */ case   34:  		/* addi R11, R11, 1 */
		/* 820A3838h case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A3838h case   34:*/		return 0x820A383C;
		  /* 820A383Ch */ case   35:  		/* cmplwi CR6, R10, 0 */
		/* 820A383Ch case   35:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A383Ch case   35:*/		return 0x820A3840;
		  /* 820A3840h */ case   36:  		/* bc 4, CR6_EQ, -12 */
		/* 820A3840h case   36:*/		if ( !regs.CR[6].eq ) { return 0x820A3834;  }
		/* 820A3840h case   36:*/		return 0x820A3844;
		  /* 820A3844h */ case   37:  		/* subf R11, R4, R11 */
		/* 820A3844h case   37:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 820A3844h case   37:*/		return 0x820A3848;
		  /* 820A3848h */ case   38:  		/* addi R11, R11, -1 */
		/* 820A3848h case   38:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A3848h case   38:*/		return 0x820A384C;
		  /* 820A384Ch */ case   39:  		/* rlwinm R5, R11, 0, 0, 31 */
		/* 820A384Ch case   39:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R5,regs.R11);
		/* 820A384Ch case   39:*/		return 0x820A3850;
		  /* 820A3850h */ case   40:  		/* b 8 */
		/* 820A3850h case   40:*/		return 0x820A3858;
		/* 820A3850h case   40:*/		return 0x820A3854;
	}
	return 0x820A3854;
} // Block from 820A37B0h-820A3854h (41 instructions)

//////////////////////////////////////////////////////
// Block at 820A3854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3854);
		  /* 820A3854h */ case    0:  		/* mr R5, R30 */
		/* 820A3854h case    0:*/		regs.R5 = regs.R30;
		/* 820A3854h case    0:*/		return 0x820A3858;
	}
	return 0x820A3858;
} // Block from 820A3854h-820A3858h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3858);
		  /* 820A3858h */ case    0:  		/* mr R10, R26 */
		/* 820A3858h case    0:*/		regs.R10 = regs.R26;
		/* 820A3858h case    0:*/		return 0x820A385C;
		  /* 820A385Ch */ case    1:  		/* stw R27, <#[R1 + 84]> */
		/* 820A385Ch case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 820A385Ch case    1:*/		return 0x820A3860;
		  /* 820A3860h */ case    2:  		/* mr R9, R25 */
		/* 820A3860h case    2:*/		regs.R9 = regs.R25;
		/* 820A3860h case    2:*/		return 0x820A3864;
		  /* 820A3864h */ case    3:  		/* li R8, 0 */
		/* 820A3864h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820A3864h case    3:*/		return 0x820A3868;
		  /* 820A3868h */ case    4:  		/* li R7, 0 */
		/* 820A3868h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820A3868h case    4:*/		return 0x820A386C;
		  /* 820A386Ch */ case    5:  		/* li R6, -1 */
		/* 820A386Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820A386Ch case    5:*/		return 0x820A3870;
		  /* 820A3870h */ case    6:  		/* addi R3, R1, 144 */
		/* 820A3870h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x90);
		/* 820A3870h case    6:*/		return 0x820A3874;
		  /* 820A3874h */ case    7:  		/* bl 10060 */
		/* 820A3874h case    7:*/		regs.LR = 0x820A3878; return 0x820A5FC0;
		/* 820A3874h case    7:*/		return 0x820A3878;
		  /* 820A3878h */ case    8:  		/* or. R31, R3, R3 */
		/* 820A3878h case    8:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A3878h case    8:*/		return 0x820A387C;
		  /* 820A387Ch */ case    9:  		/* bc 12, CR0_LT, 96 */
		/* 820A387Ch case    9:*/		if ( regs.CR[0].lt ) { return 0x820A38DC;  }
		/* 820A387Ch case    9:*/		return 0x820A3880;
		  /* 820A3880h */ case   10:  		/* li R6, 1 */
		/* 820A3880h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820A3880h case   10:*/		return 0x820A3884;
		  /* 820A3884h */ case   11:  		/* lwz R4, <#[R28 - 4]> */
		/* 820A3884h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0xFFFFFFFC) );
		/* 820A3884h case   11:*/		return 0x820A3888;
		  /* 820A3888h */ case   12:  		/* li R5, 0 */
		/* 820A3888h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A3888h case   12:*/		return 0x820A388C;
		  /* 820A388Ch */ case   13:  		/* mr R3, R25 */
		/* 820A388Ch case   13:*/		regs.R3 = regs.R25;
		/* 820A388Ch case   13:*/		return 0x820A3890;
		  /* 820A3890h */ case   14:  		/* bl -2576 */
		/* 820A3890h case   14:*/		regs.LR = 0x820A3894; return 0x820A2E80;
		/* 820A3890h case   14:*/		return 0x820A3894;
		  /* 820A3894h */ case   15:  		/* or. R31, R3, R3 */
		/* 820A3894h case   15:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A3894h case   15:*/		return 0x820A3898;
	}
	return 0x820A3898;
} // Block from 820A3858h-820A3898h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A3898h
// Function '?DoDefine@CPreProcessor@D3DXShader@@IAAJPBD_N1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3898);
		  /* 820A3898h */ case    0:  		/* bc 12, CR0_LT, 68 */
		/* 820A3898h case    0:*/		if ( regs.CR[0].lt ) { return 0x820A38DC;  }
		/* 820A3898h case    0:*/		return 0x820A389C;
		  /* 820A389Ch */ case    1:  		/* addi R28, R28, 8 */
		/* 820A389Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 820A389Ch case    1:*/		return 0x820A38A0;
		  /* 820A38A0h */ case    2:  		/* lwz R11, <#[R28 - 4]> */
		/* 820A38A0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFFFFFC) );
		/* 820A38A0h case    2:*/		return 0x820A38A4;
		  /* 820A38A4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820A38A4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A38A4h case    3:*/		return 0x820A38A8;
		  /* 820A38A8h */ case    4:  		/* bc 4, CR6_EQ, -132 */
		/* 820A38A8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A3824;  }
		/* 820A38A8h case    4:*/		return 0x820A38AC;
	}
	return 0x820A38AC;
} // Block from 820A3898h-820A38ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A38ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A38AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A38AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A38AC);
		  /* 820A38ACh */ case    0:  		/* addi R3, R1, 144 */
		/* 820A38ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x90);
		/* 820A38ACh case    0:*/		return 0x820A38B0;
		  /* 820A38B0h */ case    1:  		/* bl 1547024 */
		/* 820A38B0h case    1:*/		regs.LR = 0x820A38B4; return 0x8221D3C0;
		/* 820A38B0h case    1:*/		return 0x820A38B4;
	}
	return 0x820A38B4;
} // Block from 820A38ACh-820A38B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A38B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A38B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A38B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A38B4);
		  /* 820A38B4h */ case    0:  		/* mr R31, R30 */
		/* 820A38B4h case    0:*/		regs.R31 = regs.R30;
		/* 820A38B4h case    0:*/		return 0x820A38B8;
	}
	return 0x820A38B8;
} // Block from 820A38B4h-820A38B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A38B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A38B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A38B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A38B8);
		  /* 820A38B8h */ case    0:  		/* stw R23, <#[R25 + 2204]> */
		/* 820A38B8h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R25 + 0x0000089C) );
		/* 820A38B8h case    0:*/		return 0x820A38BC;
		  /* 820A38BCh */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 820A38BCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820A38BCh case    1:*/		return 0x820A38C0;
		  /* 820A38C0h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820A38C0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A38D0;  }
		/* 820A38C0h case    2:*/		return 0x820A38C4;
		  /* 820A38C4h */ case    3:  		/* li R4, 1 */
		/* 820A38C4h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A38C4h case    3:*/		return 0x820A38C8;
		  /* 820A38C8h */ case    4:  		/* mr R3, R29 */
		/* 820A38C8h case    4:*/		regs.R3 = regs.R29;
		/* 820A38C8h case    4:*/		return 0x820A38CC;
		  /* 820A38CCh */ case    5:  		/* bl -10692 */
		/* 820A38CCh case    5:*/		regs.LR = 0x820A38D0; return 0x820A0F08;
		/* 820A38CCh case    5:*/		return 0x820A38D0;
	}
	return 0x820A38D0;
} // Block from 820A38B8h-820A38D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A38D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A38D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A38D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A38D0);
		  /* 820A38D0h */ case    0:  		/* mr R3, R31 */
		/* 820A38D0h case    0:*/		regs.R3 = regs.R31;
		/* 820A38D0h case    0:*/		return 0x820A38D4;
		  /* 820A38D4h */ case    1:  		/* addi R1, R1, 304 */
		/* 820A38D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x130);
		/* 820A38D4h case    1:*/		return 0x820A38D8;
		  /* 820A38D8h */ case    2:  		/* b -75332 */
		/* 820A38D8h case    2:*/		return 0x82091294;
		/* 820A38D8h case    2:*/		return 0x820A38DC;
	}
	return 0x820A38DC;
} // Block from 820A38D0h-820A38DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A38DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A38DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A38DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A38DC);
		  /* 820A38DCh */ case    0:  		/* addi R3, R1, 144 */
		/* 820A38DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x90);
		/* 820A38DCh case    0:*/		return 0x820A38E0;
		  /* 820A38E0h */ case    1:  		/* bl 1546976 */
		/* 820A38E0h case    1:*/		regs.LR = 0x820A38E4; return 0x8221D3C0;
		/* 820A38E0h case    1:*/		return 0x820A38E4;
		  /* 820A38E4h */ case    2:  		/* b -44 */
		/* 820A38E4h case    2:*/		return 0x820A38B8;
		/* 820A38E4h case    2:*/		return 0x820A38E8;
	}
	return 0x820A38E8;
} // Block from 820A38DCh-820A38E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A38E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A38E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A38E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A38E8);
		  /* 820A38E8h */ case    0:  		/* mfspr R12, LR */
		/* 820A38E8h case    0:*/		regs.R12 = regs.LR;
		/* 820A38E8h case    0:*/		return 0x820A38EC;
		  /* 820A38ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A38ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A38ECh case    1:*/		return 0x820A38F0;
		  /* 820A38F0h */ case    2:  		/* std R5, <#[R1 + 32]> */
		/* 820A38F0h case    2:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 820A38F0h case    2:*/		return 0x820A38F4;
		  /* 820A38F4h */ case    3:  		/* std R6, <#[R1 + 40]> */
		/* 820A38F4h case    3:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820A38F4h case    3:*/		return 0x820A38F8;
		  /* 820A38F8h */ case    4:  		/* std R7, <#[R1 + 48]> */
		/* 820A38F8h case    4:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820A38F8h case    4:*/		return 0x820A38FC;
		  /* 820A38FCh */ case    5:  		/* std R8, <#[R1 + 56]> */
		/* 820A38FCh case    5:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820A38FCh case    5:*/		return 0x820A3900;
		  /* 820A3900h */ case    6:  		/* std R9, <#[R1 + 64]> */
		/* 820A3900h case    6:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820A3900h case    6:*/		return 0x820A3904;
		  /* 820A3904h */ case    7:  		/* std R10, <#[R1 + 72]> */
		/* 820A3904h case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820A3904h case    7:*/		return 0x820A3908;
		  /* 820A3908h */ case    8:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A3908h case    8:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A3908h case    8:*/		return 0x820A390C;
		  /* 820A390Ch */ case    9:  		/* stw R4, <#[R1 + 124]> */
		/* 820A390Ch case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 820A390Ch case    9:*/		return 0x820A3910;
		  /* 820A3910h */ case   10:  		/* addi R11, R1, 80 */
		/* 820A3910h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A3910h case   10:*/		return 0x820A3914;
		  /* 820A3914h */ case   11:  		/* addi R10, R1, 128 */
		/* 820A3914h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 820A3914h case   11:*/		return 0x820A3918;
		  /* 820A3918h */ case   12:  		/* stw R10, <#[R11]> */
		/* 820A3918h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3918h case   12:*/		return 0x820A391C;
		  /* 820A391Ch */ case   13:  		/* lwz R5, <#[R1 + 80]> */
		/* 820A391Ch case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820A391Ch case   13:*/		return 0x820A3920;
		  /* 820A3920h */ case   14:  		/* bl -2952 */
		/* 820A3920h case   14:*/		regs.LR = 0x820A3924; return 0x820A2D98;
		/* 820A3920h case   14:*/		return 0x820A3924;
		  /* 820A3924h */ case   15:  		/* addi R1, R1, 96 */
		/* 820A3924h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A3924h case   15:*/		return 0x820A3928;
		  /* 820A3928h */ case   16:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A3928h case   16:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A3928h case   16:*/		return 0x820A392C;
		  /* 820A392Ch */ case   17:  		/* mtspr LR, R12 */
		/* 820A392Ch case   17:*/		regs.LR = regs.R12;
		/* 820A392Ch case   17:*/		return 0x820A3930;
		  /* 820A3930h */ case   18:  		/* bclr 20, CR0_LT */
		/* 820A3930h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A3930h case   18:*/		return 0x820A3934;
	}
	return 0x820A3934;
} // Block from 820A38E8h-820A3934h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A3934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3934);
		  /* 820A3934h */ case    0:  		/* nop */
		/* 820A3934h case    0:*/		cpu::op::nop();
		/* 820A3934h case    0:*/		return 0x820A3938;
	}
	return 0x820A3938;
} // Block from 820A3934h-820A3938h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3938);
		  /* 820A3938h */ case    0:  		/* mfspr R12, LR */
		/* 820A3938h case    0:*/		regs.R12 = regs.LR;
		/* 820A3938h case    0:*/		return 0x820A393C;
		  /* 820A393Ch */ case    1:  		/* bl -75504 */
		/* 820A393Ch case    1:*/		regs.LR = 0x820A3940; return 0x8209124C;
		/* 820A393Ch case    1:*/		return 0x820A3940;
		  /* 820A3940h */ case    2:  		/* stwu R1, <#[R1 - 448]> */
		/* 820A3940h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE40);
		/* 820A3940h case    2:*/		return 0x820A3944;
		  /* 820A3944h */ case    3:  		/* lwz R11, <#[R3 + 2256]> */
		/* 820A3944h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000008D0) );
		/* 820A3944h case    3:*/		return 0x820A3948;
		  /* 820A3948h */ case    4:  		/* addi R26, R3, 2216 */
		/* 820A3948h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R3,0x8A8);
		/* 820A3948h case    4:*/		return 0x820A394C;
		  /* 820A394Ch */ case    5:  		/* mr R31, R3 */
		/* 820A394Ch case    5:*/		regs.R31 = regs.R3;
		/* 820A394Ch case    5:*/		return 0x820A3950;
		  /* 820A3950h */ case    6:  		/* lwz R3, <#[R3 + 2204]> */
		/* 820A3950h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000089C) );
		/* 820A3950h case    6:*/		return 0x820A3954;
		  /* 820A3954h */ case    7:  		/* ori R4, R11, 12 */
		/* 820A3954h case    7:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R11,0xC);
		/* 820A3954h case    7:*/		return 0x820A3958;
		  /* 820A3958h */ case    8:  		/* mr R5, R26 */
		/* 820A3958h case    8:*/		regs.R5 = regs.R26;
		/* 820A3958h case    8:*/		return 0x820A395C;
		  /* 820A395Ch */ case    9:  		/* bl 18588 */
		/* 820A395Ch case    9:*/		regs.LR = 0x820A3960; return 0x820A81F8;
		/* 820A395Ch case    9:*/		return 0x820A3960;
		  /* 820A3960h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820A3960h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A3960h case   10:*/		return 0x820A3964;
		  /* 820A3964h */ case   11:  		/* bc 12, CR0_LT, 552 */
		/* 820A3964h case   11:*/		if ( regs.CR[0].lt ) { return 0x820A3B8C;  }
		/* 820A3964h case   11:*/		return 0x820A3968;
		  /* 820A3968h */ case   12:  		/* lwz R11, <#[R26]> */
		/* 820A3968h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820A3968h case   12:*/		return 0x820A396C;
		  /* 820A396Ch */ case   13:  		/* li R25, 1 */
		/* 820A396Ch case   13:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820A396Ch case   13:*/		return 0x820A3970;
		  /* 820A3970h */ case   14:  		/* cmpwi CR6, R11, 12 */
		/* 820A3970h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000C);
		/* 820A3970h case   14:*/		return 0x820A3974;
		  /* 820A3974h */ case   15:  		/* bc 12, CR6_EQ, 48 */
		/* 820A3974h case   15:*/		if ( regs.CR[6].eq ) { return 0x820A39A4;  }
		/* 820A3974h case   15:*/		return 0x820A3978;
		  /* 820A3978h */ case   16:  		/* cmpwi CR6, R11, 13 */
		/* 820A3978h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000D);
		/* 820A3978h case   16:*/		return 0x820A397C;
		  /* 820A397Ch */ case   17:  		/* bc 12, CR6_EQ, 32 */
		/* 820A397Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x820A399C;  }
		/* 820A397Ch case   17:*/		return 0x820A3980;
		  /* 820A3980h */ case   18:  		/* lis R11, -32255 */
		/* 820A3980h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A3980h case   18:*/		return 0x820A3984;
		  /* 820A3984h */ case   19:  		/* mr R3, R31 */
		/* 820A3984h case   19:*/		regs.R3 = regs.R31;
		/* 820A3984h case   19:*/		return 0x820A3988;
		  /* 820A3988h */ case   20:  		/* addi R4, R11, -10392 */
		/* 820A3988h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFD768);
		/* 820A3988h case   20:*/		return 0x820A398C;
		  /* 820A398Ch */ case   21:  		/* bl -164 */
		/* 820A398Ch case   21:*/		regs.LR = 0x820A3990; return 0x820A38E8;
		/* 820A398Ch case   21:*/		return 0x820A3990;
		  /* 820A3990h */ case   22:  		/* lis R3, -32768 */
		/* 820A3990h case   22:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A3990h case   22:*/		return 0x820A3994;
		  /* 820A3994h */ case   23:  		/* ori R3, R3, 16389 */
		/* 820A3994h case   23:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820A3994h case   23:*/		return 0x820A3998;
		  /* 820A3998h */ case   24:  		/* b 500 */
		/* 820A3998h case   24:*/		return 0x820A3B8C;
		/* 820A3998h case   24:*/		return 0x820A399C;
	}
	return 0x820A399C;
} // Block from 820A3938h-820A399Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 820A399Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A399C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A399C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A399C);
		  /* 820A399Ch */ case    0:  		/* mr R27, R25 */
		/* 820A399Ch case    0:*/		regs.R27 = regs.R25;
		/* 820A399Ch case    0:*/		return 0x820A39A0;
		  /* 820A39A0h */ case    1:  		/* b 8 */
		/* 820A39A0h case    1:*/		return 0x820A39A8;
		/* 820A39A0h case    1:*/		return 0x820A39A4;
	}
	return 0x820A39A4;
} // Block from 820A399Ch-820A39A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A39A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A39A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A39A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A39A4);
		  /* 820A39A4h */ case    0:  		/* li R27, 0 */
		/* 820A39A4h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820A39A4h case    0:*/		return 0x820A39A8;
	}
	return 0x820A39A8;
} // Block from 820A39A4h-820A39A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A39A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A39A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A39A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A39A8);
		  /* 820A39A8h */ case    0:  		/* lwz R9, <#[R31 + 2208]> */
		/* 820A39A8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000008A0) );
		/* 820A39A8h case    0:*/		return 0x820A39AC;
		  /* 820A39ACh */ case    1:  		/* lwz R28, <#[R31 + 2224]> */
		/* 820A39ACh case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x000008B0) );
		/* 820A39ACh case    1:*/		return 0x820A39B0;
		  /* 820A39B0h */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 820A39B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A39B0h case    2:*/		return 0x820A39B4;
		  /* 820A39B4h */ case    3:  		/* bc 4, CR6_EQ, 64 */
		/* 820A39B4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A39F4;  }
		/* 820A39B4h case    3:*/		return 0x820A39B8;
		  /* 820A39B8h */ case    4:  		/* lwz R11, <#[R31 + 2204]> */
		/* 820A39B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A39B8h case    4:*/		return 0x820A39BC;
		  /* 820A39BCh */ case    5:  		/* lwz R11, <#[R11 + 32]> */
		/* 820A39BCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 820A39BCh case    5:*/		return 0x820A39C0;
		  /* 820A39C0h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820A39C0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A39C0h case    6:*/		return 0x820A39C4;
		  /* 820A39C4h */ case    7:  		/* bc 4, CR6_EQ, 48 */
		/* 820A39C4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820A39F4;  }
		/* 820A39C4h case    7:*/		return 0x820A39C8;
		  /* 820A39C8h */ case    8:  		/* lis R11, -32255 */
		/* 820A39C8h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A39C8h case    8:*/		return 0x820A39CC;
		  /* 820A39CCh */ case    9:  		/* li R5, 1505 */
		/* 820A39CCh case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x5E1);
		/* 820A39CCh case    9:*/		return 0x820A39D0;
		  /* 820A39D0h */ case   10:  		/* addi R6, R11, -10112 */
		/* 820A39D0h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD880);
		/* 820A39D0h case   10:*/		return 0x820A39D4;
		  /* 820A39D4h */ case   11:  		/* mr R4, R26 */
		/* 820A39D4h case   11:*/		regs.R4 = regs.R26;
		/* 820A39D4h case   11:*/		return 0x820A39D8;
		  /* 820A39D8h */ case   12:  		/* addi R3, R31, 24 */
		/* 820A39D8h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A39D8h case   12:*/		return 0x820A39DC;
		  /* 820A39DCh */ case   13:  		/* bl 14260 */
		/* 820A39DCh case   13:*/		regs.LR = 0x820A39E0; return 0x820A7190;
		/* 820A39DCh case   13:*/		return 0x820A39E0;
		  /* 820A39E0h */ case   14:  		/* lis R3, -32768 */
		/* 820A39E0h case   14:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A39E0h case   14:*/		return 0x820A39E4;
		  /* 820A39E4h */ case   15:  		/* stw R25, <#[R31 + 1644]> */
		/* 820A39E4h case   15:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x0000066C) );
		/* 820A39E4h case   15:*/		return 0x820A39E8;
		  /* 820A39E8h */ case   16:  		/* ori R3, R3, 16389 */
		/* 820A39E8h case   16:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820A39E8h case   16:*/		return 0x820A39EC;
		  /* 820A39ECh */ case   17:  		/* stw R25, <#[R31 + 1640]> */
		/* 820A39ECh case   17:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000668) );
		/* 820A39ECh case   17:*/		return 0x820A39F0;
		  /* 820A39F0h */ case   18:  		/* b 412 */
		/* 820A39F0h case   18:*/		return 0x820A3B8C;
		/* 820A39F0h case   18:*/		return 0x820A39F4;
	}
	return 0x820A39F4;
} // Block from 820A39A8h-820A39F4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A39F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A39F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A39F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A39F4);
		  /* 820A39F4h */ case    0:  		/* lwz R11, <#[R31 + 2196]> */
		/* 820A39F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000894) );
		/* 820A39F4h case    0:*/		return 0x820A39F8;
		  /* 820A39F8h */ case    1:  		/* li R10, 0 */
		/* 820A39F8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A39F8h case    1:*/		return 0x820A39FC;
		  /* 820A39FCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820A39FCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A39FCh case    2:*/		return 0x820A3A00;
		  /* 820A3A00h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 820A3A00h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A3A2C;  }
		/* 820A3A00h case    3:*/		return 0x820A3A04;
		  /* 820A3A04h */ case    4:  		/* lwz R11, <#[R11 + 128]> */
		/* 820A3A04h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000080) );
		/* 820A3A04h case    4:*/		return 0x820A3A08;
		  /* 820A3A08h */ case    5:  		/* addi R10, R10, 1 */
		/* 820A3A08h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A3A08h case    5:*/		return 0x820A3A0C;
		  /* 820A3A0Ch */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820A3A0Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A3A0Ch case    6:*/		return 0x820A3A10;
		  /* 820A3A10h */ case    7:  		/* bc 4, CR6_EQ, -12 */
		/* 820A3A10h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820A3A04;  }
		/* 820A3A10h case    7:*/		return 0x820A3A14;
		  /* 820A3A14h */ case    8:  		/* cmplwi CR6, R10, 32 */
		/* 820A3A14h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000020);
		/* 820A3A14h case    8:*/		return 0x820A3A18;
		  /* 820A3A18h */ case    9:  		/* bc 12, CR6_LT, 20 */
		/* 820A3A18h case    9:*/		if ( regs.CR[6].lt ) { return 0x820A3A2C;  }
		/* 820A3A18h case    9:*/		return 0x820A3A1C;
		  /* 820A3A1Ch */ case   10:  		/* lis R11, -32255 */
		/* 820A3A1Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A3A1Ch case   10:*/		return 0x820A3A20;
		  /* 820A3A20h */ case   11:  		/* li R5, 1506 */
		/* 820A3A20h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x5E2);
		/* 820A3A20h case   11:*/		return 0x820A3A24;
		  /* 820A3A24h */ case   12:  		/* addi R6, R11, -10144 */
		/* 820A3A24h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD860);
		/* 820A3A24h case   12:*/		return 0x820A3A28;
		  /* 820A3A28h */ case   13:  		/* b -84 */
		/* 820A3A28h case   13:*/		return 0x820A39D4;
		/* 820A3A28h case   13:*/		return 0x820A3A2C;
	}
	return 0x820A3A2C;
} // Block from 820A39F4h-820A3A2Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A3A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3A2C);
		  /* 820A3A2Ch */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 820A3A2Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A3A2Ch case    0:*/		return 0x820A3A30;
		  /* 820A3A30h */ case    1:  		/* bc 4, CR6_EQ, 64 */
		/* 820A3A30h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A3A70;  }
		/* 820A3A30h case    1:*/		return 0x820A3A34;
		  /* 820A3A34h */ case    2:  		/* mr R3, R28 */
		/* 820A3A34h case    2:*/		regs.R3 = regs.R28;
		/* 820A3A34h case    2:*/		return 0x820A3A38;
		  /* 820A3A38h */ case    3:  		/* bl 1850224 */
		/* 820A3A38h case    3:*/		regs.LR = 0x820A3A3C; return 0x822675A8;
		/* 820A3A38h case    3:*/		return 0x820A3A3C;
		  /* 820A3A3Ch */ case    4:  		/* cmpwi CR6, R3, -1 */
		/* 820A3A3Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820A3A3Ch case    4:*/		return 0x820A3A40;
		  /* 820A3A40h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 820A3A40h case    5:*/		if ( regs.CR[6].eq ) { return 0x820A3A4C;  }
		/* 820A3A40h case    5:*/		return 0x820A3A44;
		  /* 820A3A44h */ case    6:  		/* rlwinm. R11, R3, 0, 27, 27 */
		/* 820A3A44h case    6:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R3);
		/* 820A3A44h case    6:*/		return 0x820A3A48;
		  /* 820A3A48h */ case    7:  		/* bc 12, CR0_EQ, 40 */
		/* 820A3A48h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A3A70;  }
		/* 820A3A48h case    7:*/		return 0x820A3A4C;
	}
	return 0x820A3A4C;
} // Block from 820A3A2Ch-820A3A4Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A3A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3A4C);
		  /* 820A3A4Ch */ case    0:  		/* lwz R11, <#[R31 + 2196]> */
		/* 820A3A4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000894) );
		/* 820A3A4Ch case    0:*/		return 0x820A3A50;
		  /* 820A3A50h */ case    1:  		/* lis R10, -32255 */
		/* 820A3A50h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A3A50h case    1:*/		return 0x820A3A54;
		  /* 820A3A54h */ case    2:  		/* mr R7, R28 */
		/* 820A3A54h case    2:*/		regs.R7 = regs.R28;
		/* 820A3A54h case    2:*/		return 0x820A3A58;
		  /* 820A3A58h */ case    3:  		/* addi R5, R10, -10152 */
		/* 820A3A58h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFD858);
		/* 820A3A58h case    3:*/		return 0x820A3A5C;
		  /* 820A3A5Ch */ case    4:  		/* li R4, 260 */
		/* 820A3A5Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x104);
		/* 820A3A5Ch case    4:*/		return 0x820A3A60;
		  /* 820A3A60h */ case    5:  		/* addi R3, R1, 112 */
		/* 820A3A60h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 820A3A60h case    5:*/		return 0x820A3A64;
		  /* 820A3A64h */ case    6:  		/* lwz R6, <#[R11 + 104]> */
		/* 820A3A64h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000068) );
		/* 820A3A64h case    6:*/		return 0x820A3A68;
		  /* 820A3A68h */ case    7:  		/* bl -5160 */
		/* 820A3A68h case    7:*/		regs.LR = 0x820A3A6C; return 0x820A2640;
		/* 820A3A68h case    7:*/		return 0x820A3A6C;
		  /* 820A3A6Ch */ case    8:  		/* addi R28, R1, 112 */
		/* 820A3A6Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x70);
		/* 820A3A6Ch case    8:*/		return 0x820A3A70;
	}
	return 0x820A3A70;
} // Block from 820A3A4Ch-820A3A70h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A3A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3A70);
		  /* 820A3A70h */ case    0:  		/* lwz R11, <#[R31 + 2196]> */
		/* 820A3A70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000894) );
		/* 820A3A70h case    0:*/		return 0x820A3A74;
		  /* 820A3A74h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A3A74h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A3A74h case    1:*/		return 0x820A3A78;
		  /* 820A3A78h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820A3A78h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A3A90;  }
		/* 820A3A78h case    2:*/		return 0x820A3A7C;
		  /* 820A3A7Ch */ case    3:  		/* lwz R10, <#[R11 + 96]> */
		/* 820A3A7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 820A3A7Ch case    3:*/		return 0x820A3A80;
		  /* 820A3A80h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 820A3A80h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A3A80h case    4:*/		return 0x820A3A84;
		  /* 820A3A84h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 820A3A84h case    5:*/		if ( regs.CR[6].eq ) { return 0x820A3A90;  }
		/* 820A3A84h case    5:*/		return 0x820A3A88;
		  /* 820A3A88h */ case    6:  		/* lwz R29, <#[R11 + 116]> */
		/* 820A3A88h case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000074) );
		/* 820A3A88h case    6:*/		return 0x820A3A8C;
		  /* 820A3A8Ch */ case    7:  		/* b 8 */
		/* 820A3A8Ch case    7:*/		return 0x820A3A94;
		/* 820A3A8Ch case    7:*/		return 0x820A3A90;
	}
	return 0x820A3A90;
} // Block from 820A3A70h-820A3A90h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A3A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3A90);
		  /* 820A3A90h */ case    0:  		/* li R29, 0 */
		/* 820A3A90h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820A3A90h case    0:*/		return 0x820A3A94;
	}
	return 0x820A3A94;
} // Block from 820A3A90h-820A3A94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3A94);
		  /* 820A3A94h */ case    0:  		/* lis R4, 9345 */
		/* 820A3A94h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A3A94h case    0:*/		return 0x820A3A98;
		  /* 820A3A98h */ case    1:  		/* li R3, 136 */
		/* 820A3A98h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x88);
		/* 820A3A98h case    1:*/		return 0x820A3A9C;
		  /* 820A3A9Ch */ case    2:  		/* bl -112796 */
		/* 820A3A9Ch case    2:*/		regs.LR = 0x820A3AA0; return 0x82088200;
		/* 820A3A9Ch case    2:*/		return 0x820A3AA0;
		  /* 820A3AA0h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820A3AA0h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A3AA0h case    3:*/		return 0x820A3AA4;
		  /* 820A3AA4h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820A3AA4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820A3AB4;  }
		/* 820A3AA4h case    4:*/		return 0x820A3AA8;
		  /* 820A3AA8h */ case    5:  		/* bl -16120 */
		/* 820A3AA8h case    5:*/		regs.LR = 0x820A3AAC; return 0x8209FBB0;
		/* 820A3AA8h case    5:*/		return 0x820A3AAC;
		  /* 820A3AACh */ case    6:  		/* mr R30, R3 */
		/* 820A3AACh case    6:*/		regs.R30 = regs.R3;
		/* 820A3AACh case    6:*/		return 0x820A3AB0;
		  /* 820A3AB0h */ case    7:  		/* b 8 */
		/* 820A3AB0h case    7:*/		return 0x820A3AB8;
		/* 820A3AB0h case    7:*/		return 0x820A3AB4;
	}
	return 0x820A3AB4;
} // Block from 820A3A94h-820A3AB4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A3AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3AB4);
		  /* 820A3AB4h */ case    0:  		/* li R30, 0 */
		/* 820A3AB4h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A3AB4h case    0:*/		return 0x820A3AB8;
	}
	return 0x820A3AB8;
} // Block from 820A3AB4h-820A3AB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3AB8);
		  /* 820A3AB8h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820A3AB8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820A3AB8h case    0:*/		return 0x820A3ABC;
		  /* 820A3ABCh */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A3ABCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A3ACC;  }
		/* 820A3ABCh case    1:*/		return 0x820A3AC0;
		  /* 820A3AC0h */ case    2:  		/* lis R3, -32761 */
		/* 820A3AC0h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A3AC0h case    2:*/		return 0x820A3AC4;
		  /* 820A3AC4h */ case    3:  		/* ori R3, R3, 14 */
		/* 820A3AC4h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A3AC4h case    3:*/		return 0x820A3AC8;
		  /* 820A3AC8h */ case    4:  		/* b 196 */
		/* 820A3AC8h case    4:*/		return 0x820A3B8C;
		/* 820A3AC8h case    4:*/		return 0x820A3ACC;
	}
	return 0x820A3ACC;
} // Block from 820A3AB8h-820A3ACCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A3ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3ACC);
		  /* 820A3ACCh */ case    0:  		/* lwz R11, <#[R31 + 2192]> */
		/* 820A3ACCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000890) );
		/* 820A3ACCh case    0:*/		return 0x820A3AD0;
		  /* 820A3AD0h */ case    1:  		/* addi R9, R31, 80 */
		/* 820A3AD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x50);
		/* 820A3AD0h case    1:*/		return 0x820A3AD4;
		  /* 820A3AD4h */ case    2:  		/* addi R8, R31, 24 */
		/* 820A3AD4h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x18);
		/* 820A3AD4h case    2:*/		return 0x820A3AD8;
		  /* 820A3AD8h */ case    3:  		/* lwz R10, <#[R31 + 2208]> */
		/* 820A3AD8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000008A0) );
		/* 820A3AD8h case    3:*/		return 0x820A3ADC;
		  /* 820A3ADCh */ case    4:  		/* mr R7, R26 */
		/* 820A3ADCh case    4:*/		regs.R7 = regs.R26;
		/* 820A3ADCh case    4:*/		return 0x820A3AE0;
		  /* 820A3AE0h */ case    5:  		/* stw R29, <#[R1 + 92]> */
		/* 820A3AE0h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000005C) );
		/* 820A3AE0h case    5:*/		return 0x820A3AE4;
		  /* 820A3AE4h */ case    6:  		/* mr R6, R31 */
		/* 820A3AE4h case    6:*/		regs.R6 = regs.R31;
		/* 820A3AE4h case    6:*/		return 0x820A3AE8;
		  /* 820A3AE8h */ case    7:  		/* stw R27, <#[R1 + 84]> */
		/* 820A3AE8h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 820A3AE8h case    7:*/		return 0x820A3AEC;
		  /* 820A3AECh */ case    8:  		/* li R5, 0 */
		/* 820A3AECh case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A3AECh case    8:*/		return 0x820A3AF0;
		  /* 820A3AF0h */ case    9:  		/* mr R4, R28 */
		/* 820A3AF0h case    9:*/		regs.R4 = regs.R28;
		/* 820A3AF0h case    9:*/		return 0x820A3AF4;
		  /* 820A3AF4h */ case   10:  		/* stw R11, <#[R1 + 100]> */
		/* 820A3AF4h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820A3AF4h case   10:*/		return 0x820A3AF8;
		  /* 820A3AF8h */ case   11:  		/* mr R3, R30 */
		/* 820A3AF8h case   11:*/		regs.R3 = regs.R30;
		/* 820A3AF8h case   11:*/		return 0x820A3AFC;
		  /* 820A3AFCh */ case   12:  		/* bl -4964 */
		/* 820A3AFCh case   12:*/		regs.LR = 0x820A3B00; return 0x820A2798;
		/* 820A3AFCh case   12:*/		return 0x820A3B00;
		  /* 820A3B00h */ case   13:  		/* or. R29, R3, R3 */
		/* 820A3B00h case   13:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820A3B00h case   13:*/		return 0x820A3B04;
		  /* 820A3B04h */ case   14:  		/* bc 4, CR0_LT, 40 */
		/* 820A3B04h case   14:*/		if ( !regs.CR[0].lt ) { return 0x820A3B2C;  }
		/* 820A3B04h case   14:*/		return 0x820A3B08;
		  /* 820A3B08h */ case   15:  		/* stw R25, <#[R31 + 1644]> */
		/* 820A3B08h case   15:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x0000066C) );
		/* 820A3B08h case   15:*/		return 0x820A3B0C;
		  /* 820A3B0Ch */ case   16:  		/* mr R3, R30 */
		/* 820A3B0Ch case   16:*/		regs.R3 = regs.R30;
		/* 820A3B0Ch case   16:*/		return 0x820A3B10;
		  /* 820A3B10h */ case   17:  		/* stw R25, <#[R31 + 1640]> */
		/* 820A3B10h case   17:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000668) );
		/* 820A3B10h case   17:*/		return 0x820A3B14;
		  /* 820A3B14h */ case   18:  		/* bl -11180 */
		/* 820A3B14h case   18:*/		regs.LR = 0x820A3B18; return 0x820A0F68;
		/* 820A3B14h case   18:*/		return 0x820A3B18;
		  /* 820A3B18h */ case   19:  		/* lis R4, 9345 */
		/* 820A3B18h case   19:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A3B18h case   19:*/		return 0x820A3B1C;
		  /* 820A3B1Ch */ case   20:  		/* mr R3, R30 */
		/* 820A3B1Ch case   20:*/		regs.R3 = regs.R30;
		/* 820A3B1Ch case   20:*/		return 0x820A3B20;
		  /* 820A3B20h */ case   21:  		/* bl -112616 */
		/* 820A3B20h case   21:*/		regs.LR = 0x820A3B24; return 0x82088338;
		/* 820A3B20h case   21:*/		return 0x820A3B24;
		  /* 820A3B24h */ case   22:  		/* mr R3, R29 */
		/* 820A3B24h case   22:*/		regs.R3 = regs.R29;
		/* 820A3B24h case   22:*/		return 0x820A3B28;
		  /* 820A3B28h */ case   23:  		/* b 100 */
		/* 820A3B28h case   23:*/		return 0x820A3B8C;
		/* 820A3B28h case   23:*/		return 0x820A3B2C;
	}
	return 0x820A3B2C;
} // Block from 820A3ACCh-820A3B2Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 820A3B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3B2C);
		  /* 820A3B2Ch */ case    0:  		/* lwz R11, <#[R31 + 2200]> */
		/* 820A3B2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000898) );
		/* 820A3B2Ch case    0:*/		return 0x820A3B30;
		  /* 820A3B30h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A3B30h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A3B30h case    1:*/		return 0x820A3B34;
		  /* 820A3B34h */ case    2:  		/* bc 4, CR6_EQ, 100 */
		/* 820A3B34h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A3B98;  }
		/* 820A3B34h case    2:*/		return 0x820A3B38;
		  /* 820A3B38h */ case    3:  		/* stw R30, <#[R31 + 2200]> */
		/* 820A3B38h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000898) );
		/* 820A3B38h case    3:*/		return 0x820A3B3C;
		  /* 820A3B3Ch */ case    4:  		/* li R11, 0 */
		/* 820A3B3Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A3B3Ch case    4:*/		return 0x820A3B40;
		  /* 820A3B40h */ case    5:  		/* stw R11, <#[R30 + 132]> */
		/* 820A3B40h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 820A3B40h case    5:*/		return 0x820A3B44;
		  /* 820A3B44h */ case    6:  		/* lwz R10, <#[R31 + 2196]> */
		/* 820A3B44h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000894) );
		/* 820A3B44h case    6:*/		return 0x820A3B48;
		  /* 820A3B48h */ case    7:  		/* lwz R11, <#[R31 + 2192]> */
		/* 820A3B48h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000890) );
		/* 820A3B48h case    7:*/		return 0x820A3B4C;
		  /* 820A3B4Ch */ case    8:  		/* addi R11, R11, 1 */
		/* 820A3B4Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A3B4Ch case    8:*/		return 0x820A3B50;
		  /* 820A3B50h */ case    9:  		/* stw R11, <#[R31 + 2192]> */
		/* 820A3B50h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000890) );
		/* 820A3B50h case    9:*/		return 0x820A3B54;
		  /* 820A3B54h */ case   10:  		/* stw R10, <#[R30 + 128]> */
		/* 820A3B54h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000080) );
		/* 820A3B54h case   10:*/		return 0x820A3B58;
		  /* 820A3B58h */ case   11:  		/* stw R30, <#[R31 + 2196]> */
		/* 820A3B58h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000894) );
		/* 820A3B58h case   11:*/		return 0x820A3B5C;
		  /* 820A3B5Ch */ case   12:  		/* lwz R11, <#[R31 + 2272]> */
		/* 820A3B5Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000008E0) );
		/* 820A3B5Ch case   12:*/		return 0x820A3B60;
		  /* 820A3B60h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 820A3B60h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A3B60h case   13:*/		return 0x820A3B64;
		  /* 820A3B64h */ case   14:  		/* bc 12, CR6_EQ, 36 */
		/* 820A3B64h case   14:*/		if ( regs.CR[6].eq ) { return 0x820A3B88;  }
		/* 820A3B64h case   14:*/		return 0x820A3B68;
		  /* 820A3B68h */ case   15:  		/* lwz R3, <#[R11 + 20]> */
		/* 820A3B68h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000014) );
		/* 820A3B68h case   15:*/		return 0x820A3B6C;
		  /* 820A3B6Ch */ case   16:  		/* cmplwi CR6, R3, 0 */
		/* 820A3B6Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A3B6Ch case   16:*/		return 0x820A3B70;
		  /* 820A3B70h */ case   17:  		/* bc 12, CR6_EQ, 24 */
		/* 820A3B70h case   17:*/		if ( regs.CR[6].eq ) { return 0x820A3B88;  }
		/* 820A3B70h case   17:*/		return 0x820A3B74;
		  /* 820A3B74h */ case   18:  		/* lwz R5, <#[R30]> */
		/* 820A3B74h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000000) );
		/* 820A3B74h case   18:*/		return 0x820A3B78;
		  /* 820A3B78h */ case   19:  		/* lwz R11, <#[R30 + 8]> */
		/* 820A3B78h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820A3B78h case   19:*/		return 0x820A3B7C;
		  /* 820A3B7Ch */ case   20:  		/* lwz R4, <#[R30 + 100]> */
		/* 820A3B7Ch case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000064) );
		/* 820A3B7Ch case   20:*/		return 0x820A3B80;
		  /* 820A3B80h */ case   21:  		/* subf R6, R5, R11 */
		/* 820A3B80h case   21:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R5,regs.R11);
		/* 820A3B80h case   21:*/		return 0x820A3B84;
		  /* 820A3B84h */ case   22:  		/* bl 688092 */
		/* 820A3B84h case   22:*/		regs.LR = 0x820A3B88; return 0x8214BB60;
		/* 820A3B84h case   22:*/		return 0x820A3B88;
	}
	return 0x820A3B88;
} // Block from 820A3B2Ch-820A3B88h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820A3B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3B88);
		  /* 820A3B88h */ case    0:  		/* li R3, 0 */
		/* 820A3B88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A3B88h case    0:*/		return 0x820A3B8C;
	}
	return 0x820A3B8C;
} // Block from 820A3B88h-820A3B8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3B8C);
		  /* 820A3B8Ch */ case    0:  		/* addi R1, R1, 448 */
		/* 820A3B8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1C0);
		/* 820A3B8Ch case    0:*/		return 0x820A3B90;
		  /* 820A3B90h */ case    1:  		/* b -76020 */
		/* 820A3B90h case    1:*/		return 0x8209129C;
		/* 820A3B90h case    1:*/		return 0x820A3B94;
		  /* 820A3B94h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 820A3B94h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3B94h case    2:*/		return 0x820A3B98;
	}
	return 0x820A3B98;
} // Block from 820A3B8Ch-820A3B98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A3B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3B98);
		  /* 820A3B98h */ case    0:  		/* addi R11, R11, 132 */
		/* 820A3B98h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x84);
		/* 820A3B98h case    0:*/		return 0x820A3B9C;
		  /* 820A3B9Ch */ case    1:  		/* lwz R10, <#[R11]> */
		/* 820A3B9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3B9Ch case    1:*/		return 0x820A3BA0;
		  /* 820A3BA0h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 820A3BA0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A3BA0h case    2:*/		return 0x820A3BA4;
		  /* 820A3BA4h */ case    3:  		/* bc 4, CR6_EQ, -16 */
		/* 820A3BA4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A3B94;  }
		/* 820A3BA4h case    3:*/		return 0x820A3BA8;
		  /* 820A3BA8h */ case    4:  		/* stw R30, <#[R11]> */
		/* 820A3BA8h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3BA8h case    4:*/		return 0x820A3BAC;
		  /* 820A3BACh */ case    5:  		/* b -112 */
		/* 820A3BACh case    5:*/		return 0x820A3B3C;
		/* 820A3BACh case    5:*/		return 0x820A3BB0;
	}
	return 0x820A3BB0;
} // Block from 820A3B98h-820A3BB0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A3BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3BB0);
		  /* 820A3BB0h */ case    0:  		/* mfspr R12, LR */
		/* 820A3BB0h case    0:*/		regs.R12 = regs.LR;
		/* 820A3BB0h case    0:*/		return 0x820A3BB4;
		  /* 820A3BB4h */ case    1:  		/* bl -76136 */
		/* 820A3BB4h case    1:*/		regs.LR = 0x820A3BB8; return 0x8209124C;
		/* 820A3BB4h case    1:*/		return 0x820A3BB8;
		  /* 820A3BB8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820A3BB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820A3BB8h case    2:*/		return 0x820A3BBC;
		  /* 820A3BBCh */ case    3:  		/* mr R31, R3 */
		/* 820A3BBCh case    3:*/		regs.R31 = regs.R3;
		/* 820A3BBCh case    3:*/		return 0x820A3BC0;
		  /* 820A3BC0h */ case    4:  		/* lwz R3, <#[R3 + 2260]> */
		/* 820A3BC0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000008D4) );
		/* 820A3BC0h case    4:*/		return 0x820A3BC4;
		  /* 820A3BC4h */ case    5:  		/* mr R29, R4 */
		/* 820A3BC4h case    5:*/		regs.R29 = regs.R4;
		/* 820A3BC4h case    5:*/		return 0x820A3BC8;
		  /* 820A3BC8h */ case    6:  		/* mr R28, R5 */
		/* 820A3BC8h case    6:*/		regs.R28 = regs.R5;
		/* 820A3BC8h case    6:*/		return 0x820A3BCC;
		  /* 820A3BCCh */ case    7:  		/* mr R27, R6 */
		/* 820A3BCCh case    7:*/		regs.R27 = regs.R6;
		/* 820A3BCCh case    7:*/		return 0x820A3BD0;
		  /* 820A3BD0h */ case    8:  		/* mr R26, R7 */
		/* 820A3BD0h case    8:*/		regs.R26 = regs.R7;
		/* 820A3BD0h case    8:*/		return 0x820A3BD4;
		  /* 820A3BD4h */ case    9:  		/* mr R25, R8 */
		/* 820A3BD4h case    9:*/		regs.R25 = regs.R8;
		/* 820A3BD4h case    9:*/		return 0x820A3BD8;
		  /* 820A3BD8h */ case   10:  		/* cmpwi CR6, R3, 0 */
		/* 820A3BD8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820A3BD8h case   10:*/		return 0x820A3BDC;
		  /* 820A3BDCh */ case   11:  		/* bc 12, CR6_LT, 240 */
		/* 820A3BDCh case   11:*/		if ( regs.CR[6].lt ) { return 0x820A3CCC;  }
		/* 820A3BDCh case   11:*/		return 0x820A3BE0;
		  /* 820A3BE0h */ case   12:  		/* cmplwi CR6, R4, 0 */
		/* 820A3BE0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A3BE0h case   12:*/		return 0x820A3BE4;
		  /* 820A3BE4h */ case   13:  		/* bc 4, CR6_EQ, 12 */
		/* 820A3BE4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A3BF0;  }
		/* 820A3BE4h case   13:*/		return 0x820A3BE8;
		  /* 820A3BE8h */ case   14:  		/* lis R11, -32256 */
		/* 820A3BE8h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820A3BE8h case   14:*/		return 0x820A3BEC;
		  /* 820A3BECh */ case   15:  		/* addi R29, R11, 4485 */
		/* 820A3BECh case   15:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1185);
		/* 820A3BECh case   15:*/		return 0x820A3BF0;
	}
	return 0x820A3BF0;
} // Block from 820A3BB0h-820A3BF0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A3BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3BF0);
		  /* 820A3BF0h */ case    0:  		/* lis R4, 9345 */
		/* 820A3BF0h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A3BF0h case    0:*/		return 0x820A3BF4;
		  /* 820A3BF4h */ case    1:  		/* li R3, 136 */
		/* 820A3BF4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x88);
		/* 820A3BF4h case    1:*/		return 0x820A3BF8;
		  /* 820A3BF8h */ case    2:  		/* bl -113144 */
		/* 820A3BF8h case    2:*/		regs.LR = 0x820A3BFC; return 0x82088200;
		/* 820A3BF8h case    2:*/		return 0x820A3BFC;
		  /* 820A3BFCh */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820A3BFCh case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A3BFCh case    3:*/		return 0x820A3C00;
		  /* 820A3C00h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820A3C00h case    4:*/		if ( regs.CR[0].eq ) { return 0x820A3C10;  }
		/* 820A3C00h case    4:*/		return 0x820A3C04;
		  /* 820A3C04h */ case    5:  		/* bl -16468 */
		/* 820A3C04h case    5:*/		regs.LR = 0x820A3C08; return 0x8209FBB0;
		/* 820A3C04h case    5:*/		return 0x820A3C08;
		  /* 820A3C08h */ case    6:  		/* mr R30, R3 */
		/* 820A3C08h case    6:*/		regs.R30 = regs.R3;
		/* 820A3C08h case    6:*/		return 0x820A3C0C;
		  /* 820A3C0Ch */ case    7:  		/* b 8 */
		/* 820A3C0Ch case    7:*/		return 0x820A3C14;
		/* 820A3C0Ch case    7:*/		return 0x820A3C10;
	}
	return 0x820A3C10;
} // Block from 820A3BF0h-820A3C10h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A3C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3C10);
		  /* 820A3C10h */ case    0:  		/* li R30, 0 */
		/* 820A3C10h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A3C10h case    0:*/		return 0x820A3C14;
	}
	return 0x820A3C14;
} // Block from 820A3C10h-820A3C14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A3C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3C14);
		  /* 820A3C14h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820A3C14h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820A3C14h case    0:*/		return 0x820A3C18;
		  /* 820A3C18h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A3C18h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A3C28;  }
		/* 820A3C18h case    1:*/		return 0x820A3C1C;
		  /* 820A3C1Ch */ case    2:  		/* lis R3, -32761 */
		/* 820A3C1Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A3C1Ch case    2:*/		return 0x820A3C20;
		  /* 820A3C20h */ case    3:  		/* ori R3, R3, 14 */
		/* 820A3C20h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A3C20h case    3:*/		return 0x820A3C24;
		  /* 820A3C24h */ case    4:  		/* b 168 */
		/* 820A3C24h case    4:*/		return 0x820A3CCC;
		/* 820A3C24h case    4:*/		return 0x820A3C28;
	}
	return 0x820A3C28;
} // Block from 820A3C14h-820A3C28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A3C28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3C28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3C28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3C28);
		  /* 820A3C28h */ case    0:  		/* addi R9, R31, 80 */
		/* 820A3C28h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x50);
		/* 820A3C28h case    0:*/		return 0x820A3C2C;
		  /* 820A3C2Ch */ case    1:  		/* lwz R10, <#[R31 + 2192]> */
		/* 820A3C2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000890) );
		/* 820A3C2Ch case    1:*/		return 0x820A3C30;
	}
	return 0x820A3C30;
} // Block from 820A3C28h-820A3C30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A3C30h
// Function '?DoPragma@CPreProcessor@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3C30);
		  /* 820A3C30h */ case    0:  		/* addi R8, R31, 24 */
		/* 820A3C30h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x18);
		/* 820A3C30h case    0:*/		return 0x820A3C34;
		  /* 820A3C34h */ case    1:  		/* mr R7, R31 */
		/* 820A3C34h case    1:*/		regs.R7 = regs.R31;
		/* 820A3C34h case    1:*/		return 0x820A3C38;
		  /* 820A3C38h */ case    2:  		/* mr R6, R27 */
		/* 820A3C38h case    2:*/		regs.R6 = regs.R27;
		/* 820A3C38h case    2:*/		return 0x820A3C3C;
		  /* 820A3C3Ch */ case    3:  		/* mr R5, R28 */
		/* 820A3C3Ch case    3:*/		regs.R5 = regs.R28;
		/* 820A3C3Ch case    3:*/		return 0x820A3C40;
		  /* 820A3C40h */ case    4:  		/* mr R4, R29 */
		/* 820A3C40h case    4:*/		regs.R4 = regs.R29;
		/* 820A3C40h case    4:*/		return 0x820A3C44;
		  /* 820A3C44h */ case    5:  		/* mr R3, R30 */
		/* 820A3C44h case    5:*/		regs.R3 = regs.R30;
		/* 820A3C44h case    5:*/		return 0x820A3C48;
		  /* 820A3C48h */ case    6:  		/* bl -4696 */
		/* 820A3C48h case    6:*/		regs.LR = 0x820A3C4C; return 0x820A29F0;
		/* 820A3C48h case    6:*/		return 0x820A3C4C;
		  /* 820A3C4Ch */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820A3C4Ch case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A3C4Ch case    7:*/		return 0x820A3C50;
		  /* 820A3C50h */ case    8:  		/* bc 12, CR0_LT, 124 */
		/* 820A3C50h case    8:*/		if ( regs.CR[0].lt ) { return 0x820A3CCC;  }
		/* 820A3C50h case    8:*/		return 0x820A3C54;
		  /* 820A3C54h */ case    9:  		/* lwz R11, <#[R31 + 2272]> */
		/* 820A3C54h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000008E0) );
		/* 820A3C54h case    9:*/		return 0x820A3C58;
		  /* 820A3C58h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 820A3C58h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A3C58h case   10:*/		return 0x820A3C5C;
		  /* 820A3C5Ch */ case   11:  		/* bc 12, CR6_EQ, 44 */
		/* 820A3C5Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820A3C88;  }
		/* 820A3C5Ch case   11:*/		return 0x820A3C60;
		  /* 820A3C60h */ case   12:  		/* lwz R3, <#[R11 + 20]> */
		/* 820A3C60h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000014) );
		/* 820A3C60h case   12:*/		return 0x820A3C64;
		  /* 820A3C64h */ case   13:  		/* cmplwi CR6, R3, 0 */
		/* 820A3C64h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A3C64h case   13:*/		return 0x820A3C68;
		  /* 820A3C68h */ case   14:  		/* bc 12, CR6_EQ, 32 */
		/* 820A3C68h case   14:*/		if ( regs.CR[6].eq ) { return 0x820A3C88;  }
		/* 820A3C68h case   14:*/		return 0x820A3C6C;
		  /* 820A3C6Ch */ case   15:  		/* lwz R5, <#[R30]> */
		/* 820A3C6Ch case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000000) );
		/* 820A3C6Ch case   15:*/		return 0x820A3C70;
		  /* 820A3C70h */ case   16:  		/* lwz R11, <#[R30 + 8]> */
		/* 820A3C70h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820A3C70h case   16:*/		return 0x820A3C74;
		  /* 820A3C74h */ case   17:  		/* lwz R4, <#[R30 + 100]> */
		/* 820A3C74h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000064) );
		/* 820A3C74h case   17:*/		return 0x820A3C78;
		  /* 820A3C78h */ case   18:  		/* subf R6, R5, R11 */
		/* 820A3C78h case   18:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R5,regs.R11);
		/* 820A3C78h case   18:*/		return 0x820A3C7C;
		  /* 820A3C7Ch */ case   19:  		/* bl 687844 */
		/* 820A3C7Ch case   19:*/		regs.LR = 0x820A3C80; return 0x8214BB60;
		/* 820A3C7Ch case   19:*/		return 0x820A3C80;
		  /* 820A3C80h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820A3C80h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A3C80h case   20:*/		return 0x820A3C84;
		  /* 820A3C84h */ case   21:  		/* bc 12, CR0_LT, 72 */
		/* 820A3C84h case   21:*/		if ( regs.CR[0].lt ) { return 0x820A3CCC;  }
		/* 820A3C84h case   21:*/		return 0x820A3C88;
	}
	return 0x820A3C88;
} // Block from 820A3C30h-820A3C88h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820A3C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3C88);
		  /* 820A3C88h */ case    0:  		/* mr R4, R26 */
		/* 820A3C88h case    0:*/		regs.R4 = regs.R26;
		/* 820A3C88h case    0:*/		return 0x820A3C8C;
		  /* 820A3C8Ch */ case    1:  		/* mr R3, R31 */
		/* 820A3C8Ch case    1:*/		regs.R3 = regs.R31;
		/* 820A3C8Ch case    1:*/		return 0x820A3C90;
		  /* 820A3C90h */ case    2:  		/* bl -2112 */
		/* 820A3C90h case    2:*/		regs.LR = 0x820A3C94; return 0x820A3450;
		/* 820A3C90h case    2:*/		return 0x820A3C94;
		  /* 820A3C94h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820A3C94h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A3C94h case    3:*/		return 0x820A3C98;
		  /* 820A3C98h */ case    4:  		/* bc 12, CR0_LT, 52 */
		/* 820A3C98h case    4:*/		if ( regs.CR[0].lt ) { return 0x820A3CCC;  }
		/* 820A3C98h case    4:*/		return 0x820A3C9C;
		  /* 820A3C9Ch */ case    5:  		/* lwz R11, <#[R31 + 2200]> */
		/* 820A3C9Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000898) );
		/* 820A3C9Ch case    5:*/		return 0x820A3CA0;
		  /* 820A3CA0h */ case    6:  		/* stw R30, <#[R31 + 2196]> */
		/* 820A3CA0h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000894) );
		/* 820A3CA0h case    6:*/		return 0x820A3CA4;
		  /* 820A3CA4h */ case    7:  		/* stw R30, <#[R31 + 2204]> */
		/* 820A3CA4h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A3CA4h case    7:*/		return 0x820A3CA8;
		  /* 820A3CA8h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820A3CA8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A3CA8h case    8:*/		return 0x820A3CAC;
		  /* 820A3CACh */ case    9:  		/* stw R25, <#[R31 + 2208]> */
		/* 820A3CACh case    9:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x000008A0) );
		/* 820A3CACh case    9:*/		return 0x820A3CB0;
		  /* 820A3CB0h */ case   10:  		/* bc 4, CR6_EQ, 40 */
		/* 820A3CB0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820A3CD8;  }
		/* 820A3CB0h case   10:*/		return 0x820A3CB4;
		  /* 820A3CB4h */ case   11:  		/* stw R30, <#[R31 + 2200]> */
		/* 820A3CB4h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000898) );
		/* 820A3CB4h case   11:*/		return 0x820A3CB8;
		  /* 820A3CB8h */ case   12:  		/* li R11, 0 */
		/* 820A3CB8h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A3CB8h case   12:*/		return 0x820A3CBC;
		  /* 820A3CBCh */ case   13:  		/* stw R11, <#[R30 + 132]> */
		/* 820A3CBCh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 820A3CBCh case   13:*/		return 0x820A3CC0;
		  /* 820A3CC0h */ case   14:  		/* lwz R11, <#[R31 + 2192]> */
		/* 820A3CC0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000890) );
		/* 820A3CC0h case   14:*/		return 0x820A3CC4;
		  /* 820A3CC4h */ case   15:  		/* addi R11, R11, 1 */
		/* 820A3CC4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A3CC4h case   15:*/		return 0x820A3CC8;
		  /* 820A3CC8h */ case   16:  		/* stw R11, <#[R31 + 2192]> */
		/* 820A3CC8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000890) );
		/* 820A3CC8h case   16:*/		return 0x820A3CCC;
	}
	return 0x820A3CCC;
} // Block from 820A3C88h-820A3CCCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A3CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3CCC);
		  /* 820A3CCCh */ case    0:  		/* addi R1, R1, 144 */
		/* 820A3CCCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820A3CCCh case    0:*/		return 0x820A3CD0;
		  /* 820A3CD0h */ case    1:  		/* b -76340 */
		/* 820A3CD0h case    1:*/		return 0x8209129C;
		/* 820A3CD0h case    1:*/		return 0x820A3CD4;
		  /* 820A3CD4h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 820A3CD4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3CD4h case    2:*/		return 0x820A3CD8;
	}
	return 0x820A3CD8;
} // Block from 820A3CCCh-820A3CD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A3CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3CD8);
		  /* 820A3CD8h */ case    0:  		/* addi R11, R11, 132 */
		/* 820A3CD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x84);
		/* 820A3CD8h case    0:*/		return 0x820A3CDC;
		  /* 820A3CDCh */ case    1:  		/* lwz R10, <#[R11]> */
		/* 820A3CDCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3CDCh case    1:*/		return 0x820A3CE0;
		  /* 820A3CE0h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 820A3CE0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A3CE0h case    2:*/		return 0x820A3CE4;
		  /* 820A3CE4h */ case    3:  		/* bc 4, CR6_EQ, -16 */
		/* 820A3CE4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A3CD4;  }
		/* 820A3CE4h case    3:*/		return 0x820A3CE8;
		  /* 820A3CE8h */ case    4:  		/* stw R30, <#[R11]> */
		/* 820A3CE8h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820A3CE8h case    4:*/		return 0x820A3CEC;
		  /* 820A3CECh */ case    5:  		/* b -52 */
		/* 820A3CECh case    5:*/		return 0x820A3CB8;
		/* 820A3CECh case    5:*/		return 0x820A3CF0;
	}
	return 0x820A3CF0;
} // Block from 820A3CD8h-820A3CF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A3CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3CF0);
		  /* 820A3CF0h */ case    0:  		/* mfspr R12, LR */
		/* 820A3CF0h case    0:*/		regs.R12 = regs.LR;
		/* 820A3CF0h case    0:*/		return 0x820A3CF4;
		  /* 820A3CF4h */ case    1:  		/* bl -76456 */
		/* 820A3CF4h case    1:*/		regs.LR = 0x820A3CF8; return 0x8209124C;
		/* 820A3CF4h case    1:*/		return 0x820A3CF8;
		  /* 820A3CF8h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 820A3CF8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820A3CF8h case    2:*/		return 0x820A3CFC;
		  /* 820A3CFCh */ case    3:  		/* li R26, 0 */
		/* 820A3CFCh case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820A3CFCh case    3:*/		return 0x820A3D00;
		  /* 820A3D00h */ case    4:  		/* mr R30, R3 */
		/* 820A3D00h case    4:*/		regs.R30 = regs.R3;
		/* 820A3D00h case    4:*/		return 0x820A3D04;
		  /* 820A3D04h */ case    5:  		/* mr R27, R4 */
		/* 820A3D04h case    5:*/		regs.R27 = regs.R4;
		/* 820A3D04h case    5:*/		return 0x820A3D08;
		  /* 820A3D08h */ case    6:  		/* mr R31, R5 */
		/* 820A3D08h case    6:*/		regs.R31 = regs.R5;
		/* 820A3D08h case    6:*/		return 0x820A3D0C;
		  /* 820A3D0Ch */ case    7:  		/* li R25, 1 */
		/* 820A3D0Ch case    7:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820A3D0Ch case    7:*/		return 0x820A3D10;
		  /* 820A3D10h */ case    8:  		/* mr R29, R26 */
		/* 820A3D10h case    8:*/		regs.R29 = regs.R26;
		/* 820A3D10h case    8:*/		return 0x820A3D14;
		  /* 820A3D14h */ case    9:  		/* cmplwi CR6, R5, 16 */
		/* 820A3D14h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000010);
		/* 820A3D14h case    9:*/		return 0x820A3D18;
		  /* 820A3D18h */ case   10:  		/* bc 4, CR6_GT, 8 */
		/* 820A3D18h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820A3D20;  }
		/* 820A3D18h case   10:*/		return 0x820A3D1C;
		  /* 820A3D1Ch */ case   11:  		/* stw R25, <#[R3 + 1640]> */
		/* 820A3D1Ch case   11:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000668) );
		/* 820A3D1Ch case   11:*/		return 0x820A3D20;
	}
	return 0x820A3D20;
} // Block from 820A3CF0h-820A3D20h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A3D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3D20);
		  /* 820A3D20h */ case    0:  		/* lwz R11, <#[R30 + 1640]> */
		/* 820A3D20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000668) );
		/* 820A3D20h case    0:*/		return 0x820A3D24;
		  /* 820A3D24h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A3D24h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A3D24h case    1:*/		return 0x820A3D28;
		  /* 820A3D28h */ case    2:  		/* bc 4, CR6_EQ, 1304 */
		/* 820A3D28h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A4240;  }
		/* 820A3D28h case    2:*/		return 0x820A3D2C;
		  /* 820A3D2Ch */ case    3:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 820A3D2Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 820A3D2Ch case    3:*/		return 0x820A3D30;
		  /* 820A3D30h */ case    4:  		/* addi R11, R1, 80 */
		/* 820A3D30h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A3D30h case    4:*/		return 0x820A3D34;
		  /* 820A3D34h */ case    5:  		/* subfic R9, R31, 16 */
		/* 820A3D34h case    5:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R31,0x10);
		/* 820A3D34h case    5:*/		return 0x820A3D38;
		  /* 820A3D38h */ case    6:  		/* add R28, R10, R11 */
		/* 820A3D38h case    6:*/		cpu::op::add<0>(regs,&regs.R28,regs.R10,regs.R11);
		/* 820A3D38h case    6:*/		return 0x820A3D3C;
		  /* 820A3D3Ch */ case    7:  		/* rlwinm R5, R9, 2, 0, 29 */
		/* 820A3D3Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R9);
		/* 820A3D3Ch case    7:*/		return 0x820A3D40;
		  /* 820A3D40h */ case    8:  		/* li R4, 0 */
		/* 820A3D40h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A3D40h case    8:*/		return 0x820A3D44;
		  /* 820A3D44h */ case    9:  		/* mr R3, R28 */
		/* 820A3D44h case    9:*/		regs.R3 = regs.R28;
		/* 820A3D44h case    9:*/		return 0x820A3D48;
		  /* 820A3D48h */ case   10:  		/* bl -76296 */
		/* 820A3D48h case   10:*/		regs.LR = 0x820A3D4C; return 0x82091340;
		/* 820A3D48h case   10:*/		return 0x820A3D4C;
		  /* 820A3D4Ch */ case   11:  		/* mr R10, R31 */
		/* 820A3D4Ch case   11:*/		regs.R10 = regs.R31;
		/* 820A3D4Ch case   11:*/		return 0x820A3D50;
		  /* 820A3D50h */ case   12:  		/* cmplwi CR6, R31, 0 */
		/* 820A3D50h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A3D50h case   12:*/		return 0x820A3D54;
		  /* 820A3D54h */ case   13:  		/* bc 12, CR6_EQ, 72 */
		/* 820A3D54h case   13:*/		if ( regs.CR[6].eq ) { return 0x820A3D9C;  }
		/* 820A3D54h case   13:*/		return 0x820A3D58;
		  /* 820A3D58h */ case   14:  		/* mr R9, R28 */
		/* 820A3D58h case   14:*/		regs.R9 = regs.R28;
		/* 820A3D58h case   14:*/		return 0x820A3D5C;
		  /* 820A3D5Ch */ case   15:  		/* lwz R11, <#[R30 + 1664]> */
		/* 820A3D5Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000680) );
		/* 820A3D5Ch case   15:*/		return 0x820A3D60;
		  /* 820A3D60h */ case   16:  		/* addi R10, R10, -1 */
		/* 820A3D60h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820A3D60h case   16:*/		return 0x820A3D64;
		  /* 820A3D64h */ case   17:  		/* addi R9, R9, -4 */
		/* 820A3D64h case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFC);
		/* 820A3D64h case   17:*/		return 0x820A3D68;
		  /* 820A3D68h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 820A3D68h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A3D68h case   18:*/		return 0x820A3D6C;
		  /* 820A3D6Ch */ case   19:  		/* bc 12, CR6_EQ, 96 */
		/* 820A3D6Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x820A3DCC;  }
		/* 820A3D6Ch case   19:*/		return 0x820A3D70;
		  /* 820A3D70h */ case   20:  		/* lwz R8, <#[R11 + 12]> */
		/* 820A3D70h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A3D70h case   20:*/		return 0x820A3D74;
		  /* 820A3D74h */ case   21:  		/* cmplwi CR6, R10, 0 */
		/* 820A3D74h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A3D74h case   21:*/		return 0x820A3D78;
		  /* 820A3D78h */ case   22:  		/* lwz R7, <#[R11 + 8]> */
		/* 820A3D78h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 820A3D78h case   22:*/		return 0x820A3D7C;
		  /* 820A3D7Ch */ case   23:  		/* stw R26, <#[R11 + 8]> */
		/* 820A3D7Ch case   23:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000008) );
		/* 820A3D7Ch case   23:*/		return 0x820A3D80;
		  /* 820A3D80h */ case   24:  		/* stw R8, <#[R30 + 1664]> */
		/* 820A3D80h case   24:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000680) );
		/* 820A3D80h case   24:*/		return 0x820A3D84;
		  /* 820A3D84h */ case   25:  		/* stw R26, <#[R11 + 12]> */
		/* 820A3D84h case   25:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A3D84h case   25:*/		return 0x820A3D88;
		  /* 820A3D88h */ case   26:  		/* lwz R8, <#[R30 + 1676]> */
		/* 820A3D88h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000068C) );
		/* 820A3D88h case   26:*/		return 0x820A3D8C;
		  /* 820A3D8Ch */ case   27:  		/* stw R8, <#[R11 + 12]> */
		/* 820A3D8Ch case   27:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A3D8Ch case   27:*/		return 0x820A3D90;
		  /* 820A3D90h */ case   28:  		/* stw R7, <#[R9]> */
		/* 820A3D90h case   28:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A3D90h case   28:*/		return 0x820A3D94;
		  /* 820A3D94h */ case   29:  		/* stw R11, <#[R30 + 1676]> */
		/* 820A3D94h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000068C) );
		/* 820A3D94h case   29:*/		return 0x820A3D98;
		  /* 820A3D98h */ case   30:  		/* bc 4, CR6_EQ, -60 */
		/* 820A3D98h case   30:*/		if ( !regs.CR[6].eq ) { return 0x820A3D5C;  }
		/* 820A3D98h case   30:*/		return 0x820A3D9C;
	}
	return 0x820A3D9C;
} // Block from 820A3D20h-820A3D9Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 820A3D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3D9C);
		  /* 820A3D9Ch */ case    0:  		/* cmplwi CR6, R27, 53 */
		/* 820A3D9Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000035);
		/* 820A3D9Ch case    0:*/		return 0x820A3DA0;
		  /* 820A3DA0h */ case    1:  		/* bc 12, CR6_GT, 1132 */
		/* 820A3DA0h case    1:*/		if ( regs.CR[6].gt ) { return 0x820A420C;  }
		/* 820A3DA0h case    1:*/		return 0x820A3DA4;
		  /* 820A3DA4h */ case    2:  		/* lis R12, -32255 */
		/* 820A3DA4h case    2:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820A3DA4h case    2:*/		return 0x820A3DA8;
		  /* 820A3DA8h */ case    3:  		/* rlwinm R0, R27, 1, 0, 30 */
		/* 820A3DA8h case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R27);
		/* 820A3DA8h case    3:*/		return 0x820A3DAC;
		  /* 820A3DACh */ case    4:  		/* addi R12, R12, -11152 */
		/* 820A3DACh case    4:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFD470);
		/* 820A3DACh case    4:*/		return 0x820A3DB0;
		  /* 820A3DB0h */ case    5:  		/* lhzx R0, <#[R12 + R0]> */
		/* 820A3DB0h case    5:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 820A3DB0h case    5:*/		return 0x820A3DB4;
		  /* 820A3DB4h */ case    6:  		/* lis R12, -32246 */
		/* 820A3DB4h case    6:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820A);
		/* 820A3DB4h case    6:*/		return 0x820A3DB8;
		  /* 820A3DB8h */ case    7:  		/* addi R12, R12, 15820 */
		/* 820A3DB8h case    7:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x3DCC);
		/* 820A3DB8h case    7:*/		return 0x820A3DBC;
		  /* 820A3DBCh */ case    8:  		/* ori R0, R0, 0 */
		/* 820A3DBCh case    8:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820A3DBCh case    8:*/		return 0x820A3DC0;
		  /* 820A3DC0h */ case    9:  		/* add R12, R12, R0 */
		/* 820A3DC0h case    9:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820A3DC0h case    9:*/		return 0x820A3DC4;
		  /* 820A3DC4h */ case   10:  		/* mtspr CTR, R12 */
		/* 820A3DC4h case   10:*/		regs.CTR = regs.R12;
		/* 820A3DC4h case   10:*/		return 0x820A3DC8;
		  /* 820A3DC8h */ case   11:  		/* bcctr 20, CR0_LT */
		/* 820A3DC8h case   11:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820A3DC8h case   11:*/		return 0x820A3DCC;
	}
	return 0x820A3DCC;
} // Block from 820A3D9Ch-820A3DCCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A3DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3DCC);
		  /* 820A3DCCh */ case    0:  		/* lis R11, -32255 */
		/* 820A3DCCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A3DCCh case    0:*/		return 0x820A3DD0;
		  /* 820A3DD0h */ case    1:  		/* addi R6, R11, -9956 */
		/* 820A3DD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD91C);
		/* 820A3DD0h case    1:*/		return 0x820A3DD4;
		  /* 820A3DD4h */ case    2:  		/* li R5, 0 */
		/* 820A3DD4h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A3DD4h case    2:*/		return 0x820A3DD8;
		  /* 820A3DD8h */ case    3:  		/* addi R4, R30, 2216 */
		/* 820A3DD8h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x8A8);
		/* 820A3DD8h case    3:*/		return 0x820A3DDC;
		  /* 820A3DDCh */ case    4:  		/* addi R3, R30, 24 */
		/* 820A3DDCh case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x18);
		/* 820A3DDCh case    4:*/		return 0x820A3DE0;
		  /* 820A3DE0h */ case    5:  		/* bl 13232 */
		/* 820A3DE0h case    5:*/		regs.LR = 0x820A3DE4; return 0x820A7190;
		/* 820A3DE0h case    5:*/		return 0x820A3DE4;
		  /* 820A3DE4h */ case    6:  		/* stw R25, <#[R30 + 1640]> */
		/* 820A3DE4h case    6:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + 0x00000668) );
		/* 820A3DE4h case    6:*/		return 0x820A3DE8;
		  /* 820A3DE8h */ case    7:  		/* b 1112 */
		/* 820A3DE8h case    7:*/		return 0x820A4240;
		/* 820A3DE8h case    7:*/		return 0x820A3DEC;
		  /* 820A3DECh */ case    8:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A3DECh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3DECh case    8:*/		return 0x820A3DF0;
		  /* 820A3DF0h */ case    9:  		/* li R6, 0 */
		/* 820A3DF0h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820A3DF0h case    9:*/		return 0x820A3DF4;
		  /* 820A3DF4h */ case   10:  		/* li R5, 1 */
		/* 820A3DF4h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A3DF4h case   10:*/		return 0x820A3DF8;
		  /* 820A3DF8h */ case   11:  		/* mr R3, R30 */
		/* 820A3DF8h case   11:*/		regs.R3 = regs.R30;
		/* 820A3DF8h case   11:*/		return 0x820A3DFC;
		  /* 820A3DFCh */ case   12:  		/* lwz R4, <#[R11 + 24]> */
		/* 820A3DFCh case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000018) );
		/* 820A3DFCh case   12:*/		return 0x820A3E00;
		  /* 820A3E00h */ case   13:  		/* bl -3968 */
		/* 820A3E00h case   13:*/		regs.LR = 0x820A3E04; return 0x820A2E80;
		/* 820A3E00h case   13:*/		return 0x820A3E04;
		  /* 820A3E04h */ case   14:  		/* b 1032 */
		/* 820A3E04h case   14:*/		return 0x820A420C;
		/* 820A3E04h case   14:*/		return 0x820A3E08;
		  /* 820A3E08h */ case   15:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A3E08h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3E08h case   15:*/		return 0x820A3E0C;
		  /* 820A3E0Ch */ case   16:  		/* mr R3, R30 */
		/* 820A3E0Ch case   16:*/		regs.R3 = regs.R30;
		/* 820A3E0Ch case   16:*/		return 0x820A3E10;
		  /* 820A3E10h */ case   17:  		/* lwz R4, <#[R11 + 24]> */
		/* 820A3E10h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000018) );
		/* 820A3E10h case   17:*/		return 0x820A3E14;
		  /* 820A3E14h */ case   18:  		/* bl -9236 */
		/* 820A3E14h case   18:*/		regs.LR = 0x820A3E18; return 0x820A1A00;
		/* 820A3E14h case   18:*/		return 0x820A3E18;
	}
	return 0x820A3E18;
} // Block from 820A3DCCh-820A3E18h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A3E18h
// Function '?Static_Error@CPreProcessor@D3DXShader@@SAXPAXPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3E18);
		  /* 820A3E18h */ case    0:  		/* b 1012 */
		/* 820A3E18h case    0:*/		return 0x820A420C;
		/* 820A3E18h case    0:*/		return 0x820A3E1C;
		  /* 820A3E1Ch */ case    1:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A3E1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3E1Ch case    1:*/		return 0x820A3E20;
		  /* 820A3E20h */ case    2:  		/* lwz R10, <#[R30 + 2204]> */
		/* 820A3E20h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000089C) );
		/* 820A3E20h case    2:*/		return 0x820A3E24;
		  /* 820A3E24h */ case    3:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A3E24h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A3E24h case    3:*/		return 0x820A3E28;
		  /* 820A3E28h */ case    4:  		/* stw R11, <#[R10 + 40]> */
		/* 820A3E28h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000028) );
		/* 820A3E28h case    4:*/		return 0x820A3E2C;
		  /* 820A3E2Ch */ case    5:  		/* lwz R11, <#[R30 + 2216]> */
		/* 820A3E2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000008A8) );
		/* 820A3E2Ch case    5:*/		return 0x820A3E30;
		  /* 820A3E30h */ case    6:  		/* cmpwi CR6, R11, 16 */
		/* 820A3E30h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820A3E30h case    6:*/		return 0x820A3E34;
		  /* 820A3E34h */ case    7:  		/* bc 12, CR6_EQ, 984 */
		/* 820A3E34h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A420C;  }
		/* 820A3E34h case    7:*/		return 0x820A3E38;
		  /* 820A3E38h */ case    8:  		/* lwz R11, <#[R30 + 2204]> */
		/* 820A3E38h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000089C) );
		/* 820A3E38h case    8:*/		return 0x820A3E3C;
		  /* 820A3E3Ch */ case    9:  		/* lwz R10, <#[R11 + 40]> */
		/* 820A3E3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 820A3E3Ch case    9:*/		return 0x820A3E40;
		  /* 820A3E40h */ case   10:  		/* addi R10, R10, -1 */
		/* 820A3E40h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820A3E40h case   10:*/		return 0x820A3E44;
		  /* 820A3E44h */ case   11:  		/* stw R10, <#[R11 + 40]> */
		/* 820A3E44h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 820A3E44h case   11:*/		return 0x820A3E48;
		  /* 820A3E48h */ case   12:  		/* b 964 */
		/* 820A3E48h case   12:*/		return 0x820A420C;
		/* 820A3E48h case   12:*/		return 0x820A3E4C;
		  /* 820A3E4Ch */ case   13:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A3E4Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3E4Ch case   13:*/		return 0x820A3E50;
		  /* 820A3E50h */ case   14:  		/* lwz R10, <#[R1 + 84]> */
		/* 820A3E50h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 820A3E50h case   14:*/		return 0x820A3E54;
		  /* 820A3E54h */ case   15:  		/* lwz R8, <#[R30 + 2204]> */
		/* 820A3E54h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000089C) );
		/* 820A3E54h case   15:*/		return 0x820A3E58;
		  /* 820A3E58h */ case   16:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A3E58h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A3E58h case   16:*/		return 0x820A3E5C;
		  /* 820A3E5Ch */ case   17:  		/* lwz R9, <#[R10 + 24]> */
		/* 820A3E5Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000018) );
		/* 820A3E5Ch case   17:*/		return 0x820A3E60;
		  /* 820A3E60h */ case   18:  		/* stw R11, <#[R8 + 40]> */
		/* 820A3E60h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000028) );
		/* 820A3E60h case   18:*/		return 0x820A3E64;
		  /* 820A3E64h */ case   19:  		/* lwz R11, <#[R30 + 2216]> */
		/* 820A3E64h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000008A8) );
		/* 820A3E64h case   19:*/		return 0x820A3E68;
	}
	return 0x820A3E68;
} // Block from 820A3E18h-820A3E68h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A3E68h
// Function '?InitializeDefines@CPreProcessor@D3DXShader@@IAAJPBU_D3DXMACRO@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3E68);
		  /* 820A3E68h */ case    0:  		/* cmpwi CR6, R11, 16 */
		/* 820A3E68h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820A3E68h case    0:*/		return 0x820A3E6C;
		  /* 820A3E6Ch */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820A3E6Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820A3E80;  }
		/* 820A3E6Ch case    1:*/		return 0x820A3E70;
		  /* 820A3E70h */ case    2:  		/* lwz R11, <#[R30 + 2204]> */
		/* 820A3E70h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000089C) );
		/* 820A3E70h case    2:*/		return 0x820A3E74;
		  /* 820A3E74h */ case    3:  		/* lwz R10, <#[R11 + 40]> */
		/* 820A3E74h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 820A3E74h case    3:*/		return 0x820A3E78;
		  /* 820A3E78h */ case    4:  		/* addi R10, R10, -1 */
		/* 820A3E78h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820A3E78h case    4:*/		return 0x820A3E7C;
		  /* 820A3E7Ch */ case    5:  		/* stw R10, <#[R11 + 40]> */
		/* 820A3E7Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 820A3E7Ch case    5:*/		return 0x820A3E80;
	}
	return 0x820A3E80;
} // Block from 820A3E68h-820A3E80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A3E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A3E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A3E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A3E80);
		  /* 820A3E80h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 820A3E80h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A3E80h case    0:*/		return 0x820A3E84;
		  /* 820A3E84h */ case    1:  		/* bc 12, CR6_EQ, 904 */
		/* 820A3E84h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A420C;  }
		/* 820A3E84h case    1:*/		return 0x820A3E88;
		  /* 820A3E88h */ case    2:  		/* lwz R11, <#[R30 + 2204]> */
		/* 820A3E88h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000089C) );
		/* 820A3E88h case    2:*/		return 0x820A3E8C;
		  /* 820A3E8Ch */ case    3:  		/* stw R9, <#[R11 + 32]> */
		/* 820A3E8Ch case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000020) );
		/* 820A3E8Ch case    3:*/		return 0x820A3E90;
		  /* 820A3E90h */ case    4:  		/* b 892 */
		/* 820A3E90h case    4:*/		return 0x820A420C;
		/* 820A3E90h case    4:*/		return 0x820A3E94;
		  /* 820A3E94h */ case    5:  		/* mr R3, R30 */
		/* 820A3E94h case    5:*/		regs.R3 = regs.R30;
		/* 820A3E94h case    5:*/		return 0x820A3E98;
		  /* 820A3E98h */ case    6:  		/* bl -1376 */
		/* 820A3E98h case    6:*/		regs.LR = 0x820A3E9C; return 0x820A3938;
		/* 820A3E98h case    6:*/		return 0x820A3E9C;
		  /* 820A3E9Ch */ case    7:  		/* b 880 */
		/* 820A3E9Ch case    7:*/		return 0x820A420C;
		/* 820A3E9Ch case    7:*/		return 0x820A3EA0;
		  /* 820A3EA0h */ case    8:  		/* mr R3, R30 */
		/* 820A3EA0h case    8:*/		regs.R3 = regs.R30;
		/* 820A3EA0h case    8:*/		return 0x820A3EA4;
		  /* 820A3EA4h */ case    9:  		/* bl -16436 */
		/* 820A3EA4h case    9:*/		regs.LR = 0x820A3EA8; return 0x8209FE70;
		/* 820A3EA4h case    9:*/		return 0x820A3EA8;
		  /* 820A3EA8h */ case   10:  		/* b 868 */
		/* 820A3EA8h case   10:*/		return 0x820A420C;
		/* 820A3EA8h case   10:*/		return 0x820A3EAC;
		  /* 820A3EACh */ case   11:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A3EACh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3EACh case   11:*/		return 0x820A3EB0;
		  /* 820A3EB0h */ case   12:  		/* lwz R4, <#[R11 + 24]> */
		/* 820A3EB0h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000018) );
		/* 820A3EB0h case   12:*/		return 0x820A3EB4;
		  /* 820A3EB4h */ case   13:  		/* mr R3, R30 */
		/* 820A3EB4h case   13:*/		regs.R3 = regs.R30;
		/* 820A3EB4h case   13:*/		return 0x820A3EB8;
		  /* 820A3EB8h */ case   14:  		/* bl -9232 */
		/* 820A3EB8h case   14:*/		regs.LR = 0x820A3EBC; return 0x820A1AA8;
		/* 820A3EB8h case   14:*/		return 0x820A3EBC;
		  /* 820A3EBCh */ case   15:  		/* b 848 */
		/* 820A3EBCh case   15:*/		return 0x820A420C;
		/* 820A3EBCh case   15:*/		return 0x820A3EC0;
		  /* 820A3EC0h */ case   16:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A3EC0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3EC0h case   16:*/		return 0x820A3EC4;
		  /* 820A3EC4h */ case   17:  		/* li R6, 0 */
		/* 820A3EC4h case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820A3EC4h case   17:*/		return 0x820A3EC8;
		  /* 820A3EC8h */ case   18:  		/* li R5, 0 */
		/* 820A3EC8h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A3EC8h case   18:*/		return 0x820A3ECC;
		  /* 820A3ECCh */ case   19:  		/* mr R3, R30 */
		/* 820A3ECCh case   19:*/		regs.R3 = regs.R30;
		/* 820A3ECCh case   19:*/		return 0x820A3ED0;
		  /* 820A3ED0h */ case   20:  		/* lwz R4, <#[R11 + 24]> */
		/* 820A3ED0h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000018) );
		/* 820A3ED0h case   20:*/		return 0x820A3ED4;
		  /* 820A3ED4h */ case   21:  		/* bl -12812 */
		/* 820A3ED4h case   21:*/		regs.LR = 0x820A3ED8; return 0x820A0CC8;
		/* 820A3ED4h case   21:*/		return 0x820A3ED8;
		  /* 820A3ED8h */ case   22:  		/* mr R4, R3 */
		/* 820A3ED8h case   22:*/		regs.R4 = regs.R3;
		/* 820A3ED8h case   22:*/		return 0x820A3EDC;
		  /* 820A3EDCh */ case   23:  		/* b -40 */
		/* 820A3EDCh case   23:*/		return 0x820A3EB4;
		/* 820A3EDCh case   23:*/		return 0x820A3EE0;
		  /* 820A3EE0h */ case   24:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A3EE0h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3EE0h case   24:*/		return 0x820A3EE4;
		  /* 820A3EE4h */ case   25:  		/* li R6, 0 */
		/* 820A3EE4h case   25:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820A3EE4h case   25:*/		return 0x820A3EE8;
		  /* 820A3EE8h */ case   26:  		/* li R5, 0 */
		/* 820A3EE8h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A3EE8h case   26:*/		return 0x820A3EEC;
		  /* 820A3EECh */ case   27:  		/* mr R3, R30 */
		/* 820A3EECh case   27:*/		regs.R3 = regs.R30;
		/* 820A3EECh case   27:*/		return 0x820A3EF0;
		  /* 820A3EF0h */ case   28:  		/* lwz R4, <#[R11 + 24]> */
		/* 820A3EF0h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000018) );
		/* 820A3EF0h case   28:*/		return 0x820A3EF4;
		  /* 820A3EF4h */ case   29:  		/* bl -12844 */
		/* 820A3EF4h case   29:*/		regs.LR = 0x820A3EF8; return 0x820A0CC8;
		/* 820A3EF4h case   29:*/		return 0x820A3EF8;
		  /* 820A3EF8h */ case   30:  		/* cntlzw R11, R3 */
		/* 820A3EF8h case   30:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R3);
		/* 820A3EF8h case   30:*/		return 0x820A3EFC;
		  /* 820A3EFCh */ case   31:  		/* rlwinm R4, R11, 27, 31, 31 */
		/* 820A3EFCh case   31:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R4,regs.R11);
		/* 820A3EFCh case   31:*/		return 0x820A3F00;
		  /* 820A3F00h */ case   32:  		/* b -76 */
		/* 820A3F00h case   32:*/		return 0x820A3EB4;
		/* 820A3F00h case   32:*/		return 0x820A3F04;
		  /* 820A3F04h */ case   33:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A3F04h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3F04h case   33:*/		return 0x820A3F08;
		  /* 820A3F08h */ case   34:  		/* mr R3, R30 */
		/* 820A3F08h case   34:*/		regs.R3 = regs.R30;
		/* 820A3F08h case   34:*/		return 0x820A3F0C;
		  /* 820A3F0Ch */ case   35:  		/* lwz R4, <#[R11 + 24]> */
		/* 820A3F0Ch case   35:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000018) );
		/* 820A3F0Ch case   35:*/		return 0x820A3F10;
		  /* 820A3F10h */ case   36:  		/* bl -16184 */
		/* 820A3F10h case   36:*/		regs.LR = 0x820A3F14; return 0x8209FFD8;
		/* 820A3F10h case   36:*/		return 0x820A3F14;
		  /* 820A3F14h */ case   37:  		/* b 760 */
		/* 820A3F14h case   37:*/		return 0x820A420C;
		/* 820A3F14h case   37:*/		return 0x820A3F18;
		  /* 820A3F18h */ case   38:  		/* mr R3, R30 */
		/* 820A3F18h case   38:*/		regs.R3 = regs.R30;
		/* 820A3F18h case   38:*/		return 0x820A3F1C;
		  /* 820A3F1Ch */ case   39:  		/* bl -16004 */
		/* 820A3F1Ch case   39:*/		regs.LR = 0x820A3F20; return 0x820A0098;
		/* 820A3F1Ch case   39:*/		return 0x820A3F20;
		  /* 820A3F20h */ case   40:  		/* b 748 */
		/* 820A3F20h case   40:*/		return 0x820A420C;
		/* 820A3F20h case   40:*/		return 0x820A3F24;
		  /* 820A3F24h */ case   41:  		/* mr R3, R30 */
		/* 820A3F24h case   41:*/		regs.R3 = regs.R30;
		/* 820A3F24h case   41:*/		return 0x820A3F28;
		  /* 820A3F28h */ case   42:  		/* bl -9160 */
		/* 820A3F28h case   42:*/		regs.LR = 0x820A3F2C; return 0x820A1B60;
		/* 820A3F28h case   42:*/		return 0x820A3F2C;
		  /* 820A3F2Ch */ case   43:  		/* b 736 */
		/* 820A3F2Ch case   43:*/		return 0x820A420C;
		/* 820A3F2Ch case   43:*/		return 0x820A3F30;
		  /* 820A3F30h */ case   44:  		/* li R4, 1 */
		/* 820A3F30h case   44:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A3F30h case   44:*/		return 0x820A3F34;
		  /* 820A3F34h */ case   45:  		/* mr R3, R30 */
		/* 820A3F34h case   45:*/		regs.R3 = regs.R30;
		/* 820A3F34h case   45:*/		return 0x820A3F38;
		  /* 820A3F38h */ case   46:  		/* bl -9360 */
		/* 820A3F38h case   46:*/		regs.LR = 0x820A3F3C; return 0x820A1AA8;
		/* 820A3F38h case   46:*/		return 0x820A3F3C;
		  /* 820A3F3Ch */ case   47:  		/* li R4, 0 */
		/* 820A3F3Ch case   47:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A3F3Ch case   47:*/		return 0x820A3F40;
		  /* 820A3F40h */ case   48:  		/* lwz R3, <#[R30 + 2204]> */
		/* 820A3F40h case   48:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000089C) );
		/* 820A3F40h case   48:*/		return 0x820A3F44;
		  /* 820A3F44h */ case   49:  		/* bl 13852 */
		/* 820A3F44h case   49:*/		regs.LR = 0x820A3F48; return 0x820A7560;
		/* 820A3F44h case   49:*/		return 0x820A3F48;
		  /* 820A3F48h */ case   50:  		/* b 708 */
		/* 820A3F48h case   50:*/		return 0x820A420C;
		/* 820A3F48h case   50:*/		return 0x820A3F4C;
		  /* 820A3F4Ch */ case   51:  		/* li R4, 1 */
		/* 820A3F4Ch case   51:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A3F4Ch case   51:*/		return 0x820A3F50;
		  /* 820A3F50h */ case   52:  		/* mr R3, R30 */
		/* 820A3F50h case   52:*/		regs.R3 = regs.R30;
		/* 820A3F50h case   52:*/		return 0x820A3F54;
		  /* 820A3F54h */ case   53:  		/* bl -16252 */
		/* 820A3F54h case   53:*/		regs.LR = 0x820A3F58; return 0x8209FFD8;
		/* 820A3F54h case   53:*/		return 0x820A3F58;
		  /* 820A3F58h */ case   54:  		/* b -28 */
		/* 820A3F58h case   54:*/		return 0x820A3F3C;
		/* 820A3F58h case   54:*/		return 0x820A3F5C;
		  /* 820A3F5Ch */ case   55:  		/* mr R3, R30 */
		/* 820A3F5Ch case   55:*/		regs.R3 = regs.R30;
		/* 820A3F5Ch case   55:*/		return 0x820A3F60;
		  /* 820A3F60h */ case   56:  		/* bl -3400 */
		/* 820A3F60h case   56:*/		regs.LR = 0x820A3F64; return 0x820A3218;
		/* 820A3F60h case   56:*/		return 0x820A3F64;
		  /* 820A3F64h */ case   57:  		/* b 680 */
		/* 820A3F64h case   57:*/		return 0x820A420C;
		/* 820A3F64h case   57:*/		return 0x820A3F68;
		  /* 820A3F68h */ case   58:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A3F68h case   58:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3F68h case   58:*/		return 0x820A3F6C;
		  /* 820A3F6Ch */ case   59:  		/* b 672 */
		/* 820A3F6Ch case   59:*/		return 0x820A420C;
		/* 820A3F6Ch case   59:*/		return 0x820A3F70;
		  /* 820A3F70h */ case   60:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A3F70h case   60:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3F70h case   60:*/		return 0x820A3F74;
		  /* 820A3F74h */ case   61:  		/* li R11, 2 */
		/* 820A3F74h case   61:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820A3F74h case   61:*/		return 0x820A3F78;
		  /* 820A3F78h */ case   62:  		/* mr R3, R30 */
		/* 820A3F78h case   62:*/		regs.R3 = regs.R30;
		/* 820A3F78h case   62:*/		return 0x820A3F7C;
		  /* 820A3F7Ch */ case   63:  		/* stw R11, <#[R29 + 16]> */
		/* 820A3F7Ch case   63:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 820A3F7Ch case   63:*/		return 0x820A3F80;
		  /* 820A3F80h */ case   64:  		/* lwz R4, <#[R29 + 24]> */
		/* 820A3F80h case   64:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000018) );
		/* 820A3F80h case   64:*/		return 0x820A3F84;
		  /* 820A3F84h */ case   65:  		/* bl -6724 */
		/* 820A3F84h case   65:*/		regs.LR = 0x820A3F88; return 0x820A2540;
		/* 820A3F84h case   65:*/		return 0x820A3F88;
		  /* 820A3F88h */ case   66:  		/* stw R3, <#[R29 + 24]> */
		/* 820A3F88h case   66:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000018) );
		/* 820A3F88h case   66:*/		return 0x820A3F8C;
		  /* 820A3F8Ch */ case   67:  		/* b 640 */
		/* 820A3F8Ch case   67:*/		return 0x820A420C;
		/* 820A3F8Ch case   67:*/		return 0x820A3F90;
		  /* 820A3F90h */ case   68:  		/* lwz R31, <#[R1 + 80]> */
		/* 820A3F90h case   68:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3F90h case   68:*/		return 0x820A3F94;
		  /* 820A3F94h */ case   69:  		/* li R11, 2 */
		/* 820A3F94h case   69:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820A3F94h case   69:*/		return 0x820A3F98;
		  /* 820A3F98h */ case   70:  		/* li R6, 0 */
		/* 820A3F98h case   70:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820A3F98h case   70:*/		return 0x820A3F9C;
		  /* 820A3F9Ch */ case   71:  		/* li R5, 0 */
		/* 820A3F9Ch case   71:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A3F9Ch case   71:*/		return 0x820A3FA0;
		  /* 820A3FA0h */ case   72:  		/* mr R3, R30 */
		/* 820A3FA0h case   72:*/		regs.R3 = regs.R30;
		/* 820A3FA0h case   72:*/		return 0x820A3FA4;
		  /* 820A3FA4h */ case   73:  		/* mr R29, R31 */
		/* 820A3FA4h case   73:*/		regs.R29 = regs.R31;
		/* 820A3FA4h case   73:*/		return 0x820A3FA8;
		  /* 820A3FA8h */ case   74:  		/* stw R11, <#[R31 + 16]> */
		/* 820A3FA8h case   74:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A3FA8h case   74:*/		return 0x820A3FAC;
		  /* 820A3FACh */ case   75:  		/* lwz R4, <#[R31 + 24]> */
		/* 820A3FACh case   75:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820A3FACh case   75:*/		return 0x820A3FB0;
		  /* 820A3FB0h */ case   76:  		/* bl -13032 */
		/* 820A3FB0h case   76:*/		regs.LR = 0x820A3FB4; return 0x820A0CC8;
		/* 820A3FB0h case   76:*/		return 0x820A3FB4;
		  /* 820A3FB4h */ case   77:  		/* stw R3, <#[R31 + 24]> */
		/* 820A3FB4h case   77:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820A3FB4h case   77:*/		return 0x820A3FB8;
		  /* 820A3FB8h */ case   78:  		/* stw R25, <#[R30 + 1660]> */
		/* 820A3FB8h case   78:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + 0x0000067C) );
		/* 820A3FB8h case   78:*/		return 0x820A3FBC;
		  /* 820A3FBCh */ case   79:  		/* b 592 */
		/* 820A3FBCh case   79:*/		return 0x820A420C;
		/* 820A3FBCh case   79:*/		return 0x820A3FC0;
		  /* 820A3FC0h */ case   80:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A3FC0h case   80:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3FC0h case   80:*/		return 0x820A3FC4;
		  /* 820A3FC4h */ case   81:  		/* lwz R11, <#[R29 + 24]> */
		/* 820A3FC4h case   81:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820A3FC4h case   81:*/		return 0x820A3FC8;
		  /* 820A3FC8h */ case   82:  		/* cntlzw R11, R11 */
		/* 820A3FC8h case   82:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820A3FC8h case   82:*/		return 0x820A3FCC;
		  /* 820A3FCCh */ case   83:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 820A3FCCh case   83:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820A3FCCh case   83:*/		return 0x820A3FD0;
		  /* 820A3FD0h */ case   84:  		/* stw R11, <#[R29 + 24]> */
		/* 820A3FD0h case   84:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820A3FD0h case   84:*/		return 0x820A3FD4;
		  /* 820A3FD4h */ case   85:  		/* b 568 */
		/* 820A3FD4h case   85:*/		return 0x820A420C;
		/* 820A3FD4h case   85:*/		return 0x820A3FD8;
		  /* 820A3FD8h */ case   86:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A3FD8h case   86:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3FD8h case   86:*/		return 0x820A3FDC;
		  /* 820A3FDCh */ case   87:  		/* lwz R11, <#[R29 + 24]> */
		/* 820A3FDCh case   87:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820A3FDCh case   87:*/		return 0x820A3FE0;
		  /* 820A3FE0h */ case   88:  		/* neg R11, R11 */
		/* 820A3FE0h case   88:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 820A3FE0h case   88:*/		return 0x820A3FE4;
		  /* 820A3FE4h */ case   89:  		/* b -20 */
		/* 820A3FE4h case   89:*/		return 0x820A3FD0;
		/* 820A3FE4h case   89:*/		return 0x820A3FE8;
		  /* 820A3FE8h */ case   90:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A3FE8h case   90:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A3FE8h case   90:*/		return 0x820A3FEC;
		  /* 820A3FECh */ case   91:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A3FECh case   91:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A3FECh case   91:*/		return 0x820A3FF0;
		  /* 820A3FF0h */ case   92:  		/* lwz R10, <#[R29 + 24]> */
		/* 820A3FF0h case   92:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 820A3FF0h case   92:*/		return 0x820A3FF4;
		  /* 820A3FF4h */ case   93:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A3FF4h case   93:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A3FF4h case   93:*/		return 0x820A3FF8;
		  /* 820A3FF8h */ case   94:  		/* mullw R11, R11, R10 */
		/* 820A3FF8h case   94:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A3FF8h case   94:*/		return 0x820A3FFC;
		  /* 820A3FFCh */ case   95:  		/* b -44 */
		/* 820A3FFCh case   95:*/		return 0x820A3FD0;
		/* 820A3FFCh case   95:*/		return 0x820A4000;
		  /* 820A4000h */ case   96:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A4000h case   96:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A4000h case   96:*/		return 0x820A4004;
		  /* 820A4004h */ case   97:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A4004h case   97:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A4004h case   97:*/		return 0x820A4008;
		  /* 820A4008h */ case   98:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A4008h case   98:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A4008h case   98:*/		return 0x820A400C;
		  /* 820A400Ch */ case   99:  		/* cmplwi CR6, R11, 0 */
		/* 820A400Ch case   99:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A400Ch case   99:*/		return 0x820A4010;
		  /* 820A4010h */ case  100:  		/* bc 12, CR6_EQ, 20 */
		/* 820A4010h case  100:*/		if ( regs.CR[6].eq ) { return 0x820A4024;  }
		/* 820A4010h case  100:*/		return 0x820A4014;
		  /* 820A4014h */ case  101:  		/* lwz R10, <#[R29 + 24]> */
		/* 820A4014h case  101:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 820A4014h case  101:*/		return 0x820A4018;
		  /* 820A4018h */ case  102:  		/* twi 6, R11, 0 */
		/* 820A4018h case  102:*/		cpu::op::tw<6>(regs, 0x820A4018, regs.R11, 0x00000000);
		/* 820A4018h case  102:*/		return 0x820A401C;
		  /* 820A401Ch */ case  103:  		/* divwu R11, R10, R11 */
		/* 820A401Ch case  103:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A401Ch case  103:*/		return 0x820A4020;
		  /* 820A4020h */ case  104:  		/* b -80 */
		/* 820A4020h case  104:*/		return 0x820A3FD0;
		/* 820A4020h case  104:*/		return 0x820A4024;
	}
	return 0x820A4024;
} // Block from 820A3E80h-820A4024h (105 instructions)

//////////////////////////////////////////////////////
// Block at 820A4024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4024);
		  /* 820A4024h */ case    0:  		/* lis R11, -32255 */
		/* 820A4024h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A4024h case    0:*/		return 0x820A4028;
		  /* 820A4028h */ case    1:  		/* li R5, 1503 */
		/* 820A4028h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x5DF);
		/* 820A4028h case    1:*/		return 0x820A402C;
		  /* 820A402Ch */ case    2:  		/* addi R6, R11, -10000 */
		/* 820A402Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD8F0);
		/* 820A402Ch case    2:*/		return 0x820A4030;
		  /* 820A4030h */ case    3:  		/* addi R4, R30, 2216 */
		/* 820A4030h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x8A8);
		/* 820A4030h case    3:*/		return 0x820A4034;
		  /* 820A4034h */ case    4:  		/* addi R3, R30, 24 */
		/* 820A4034h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x18);
		/* 820A4034h case    4:*/		return 0x820A4038;
		  /* 820A4038h */ case    5:  		/* bl 12632 */
		/* 820A4038h case    5:*/		regs.LR = 0x820A403C; return 0x820A7190;
		/* 820A4038h case    5:*/		return 0x820A403C;
		  /* 820A403Ch */ case    6:  		/* stw R25, <#[R30 + 1640]> */
		/* 820A403Ch case    6:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + 0x00000668) );
		/* 820A403Ch case    6:*/		return 0x820A4040;
		  /* 820A4040h */ case    7:  		/* b 460 */
		/* 820A4040h case    7:*/		return 0x820A420C;
		/* 820A4040h case    7:*/		return 0x820A4044;
		  /* 820A4044h */ case    8:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A4044h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A4044h case    8:*/		return 0x820A4048;
		  /* 820A4048h */ case    9:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A4048h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A4048h case    9:*/		return 0x820A404C;
		  /* 820A404Ch */ case   10:  		/* lwz R10, <#[R11 + 24]> */
		/* 820A404Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 820A404Ch case   10:*/		return 0x820A4050;
		  /* 820A4050h */ case   11:  		/* lwz R11, <#[R29 + 24]> */
		/* 820A4050h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820A4050h case   11:*/		return 0x820A4054;
		  /* 820A4054h */ case   12:  		/* add R11, R10, R11 */
		/* 820A4054h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A4054h case   12:*/		return 0x820A4058;
		  /* 820A4058h */ case   13:  		/* b -136 */
		/* 820A4058h case   13:*/		return 0x820A3FD0;
		/* 820A4058h case   13:*/		return 0x820A405C;
		  /* 820A405Ch */ case   14:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A405Ch case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A405Ch case   14:*/		return 0x820A4060;
		  /* 820A4060h */ case   15:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A4060h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A4060h case   15:*/		return 0x820A4064;
		  /* 820A4064h */ case   16:  		/* lwz R10, <#[R29 + 24]> */
		/* 820A4064h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 820A4064h case   16:*/		return 0x820A4068;
		  /* 820A4068h */ case   17:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A4068h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A4068h case   17:*/		return 0x820A406C;
		  /* 820A406Ch */ case   18:  		/* subf R11, R11, R10 */
		/* 820A406Ch case   18:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A406Ch case   18:*/		return 0x820A4070;
		  /* 820A4070h */ case   19:  		/* b -160 */
		/* 820A4070h case   19:*/		return 0x820A3FD0;
		/* 820A4070h case   19:*/		return 0x820A4074;
		  /* 820A4074h */ case   20:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A4074h case   20:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A4074h case   20:*/		return 0x820A4078;
		  /* 820A4078h */ case   21:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A4078h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A4078h case   21:*/		return 0x820A407C;
		  /* 820A407Ch */ case   22:  		/* lwz R10, <#[R29 + 24]> */
		/* 820A407Ch case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 820A407Ch case   22:*/		return 0x820A4080;
		  /* 820A4080h */ case   23:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A4080h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A4080h case   23:*/		return 0x820A4084;
		  /* 820A4084h */ case   24:  		/* subfc R11, R11, R10 */
		/* 820A4084h case   24:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A4084h case   24:*/		return 0x820A4088;
		  /* 820A4088h */ case   25:  		/* subfe R11, R11, R11 */
		/* 820A4088h case   25:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820A4088h case   25:*/		return 0x820A408C;
		  /* 820A408Ch */ case   26:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 820A408Ch case   26:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820A408Ch case   26:*/		return 0x820A4090;
		  /* 820A4090h */ case   27:  		/* b -192 */
		/* 820A4090h case   27:*/		return 0x820A3FD0;
		/* 820A4090h case   27:*/		return 0x820A4094;
		  /* 820A4094h */ case   28:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A4094h case   28:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A4094h case   28:*/		return 0x820A4098;
		  /* 820A4098h */ case   29:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A4098h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A4098h case   29:*/		return 0x820A409C;
		  /* 820A409Ch */ case   30:  		/* lwz R10, <#[R29 + 24]> */
		/* 820A409Ch case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 820A409Ch case   30:*/		return 0x820A40A0;
		  /* 820A40A0h */ case   31:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A40A0h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A40A0h case   31:*/		return 0x820A40A4;
		  /* 820A40A4h */ case   32:  		/* subfc R11, R10, R11 */
		/* 820A40A4h case   32:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A40A4h case   32:*/		return 0x820A40A8;
		  /* 820A40A8h */ case   33:  		/* b -32 */
		/* 820A40A8h case   33:*/		return 0x820A4088;
		/* 820A40A8h case   33:*/		return 0x820A40AC;
		  /* 820A40ACh */ case   34:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A40ACh case   34:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A40ACh case   34:*/		return 0x820A40B0;
		  /* 820A40B0h */ case   35:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A40B0h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A40B0h case   35:*/		return 0x820A40B4;
		  /* 820A40B4h */ case   36:  		/* lwz R9, <#[R29 + 24]> */
		/* 820A40B4h case   36:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000018) );
		/* 820A40B4h case   36:*/		return 0x820A40B8;
		  /* 820A40B8h */ case   37:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A40B8h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A40B8h case   37:*/		return 0x820A40BC;
		  /* 820A40BCh */ case   38:  		/* subfc R11, R9, R11 */
		/* 820A40BCh case   38:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820A40BCh case   38:*/		return 0x820A40C0;
		  /* 820A40C0h */ case   39:  		/* li R10, -1 */
		/* 820A40C0h case   39:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820A40C0h case   39:*/		return 0x820A40C4;
		  /* 820A40C4h */ case   40:  		/* subfze R11, R10 */
		/* 820A40C4h case   40:*/		cpu::op::subfze<0>(regs,&regs.R11,regs.R10);
		/* 820A40C4h case   40:*/		return 0x820A40C8;
		  /* 820A40C8h */ case   41:  		/* b -248 */
		/* 820A40C8h case   41:*/		return 0x820A3FD0;
		/* 820A40C8h case   41:*/		return 0x820A40CC;
		  /* 820A40CCh */ case   42:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A40CCh case   42:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A40CCh case   42:*/		return 0x820A40D0;
		  /* 820A40D0h */ case   43:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A40D0h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A40D0h case   43:*/		return 0x820A40D4;
		  /* 820A40D4h */ case   44:  		/* lwz R9, <#[R29 + 24]> */
		/* 820A40D4h case   44:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000018) );
		/* 820A40D4h case   44:*/		return 0x820A40D8;
		  /* 820A40D8h */ case   45:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A40D8h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A40D8h case   45:*/		return 0x820A40DC;
		  /* 820A40DCh */ case   46:  		/* subfc R11, R11, R9 */
		/* 820A40DCh case   46:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820A40DCh case   46:*/		return 0x820A40E0;
		  /* 820A40E0h */ case   47:  		/* b -32 */
		/* 820A40E0h case   47:*/		return 0x820A40C0;
		/* 820A40E0h case   47:*/		return 0x820A40E4;
		  /* 820A40E4h */ case   48:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A40E4h case   48:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A40E4h case   48:*/		return 0x820A40E8;
		  /* 820A40E8h */ case   49:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A40E8h case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A40E8h case   49:*/		return 0x820A40EC;
		  /* 820A40ECh */ case   50:  		/* lwz R10, <#[R29 + 24]> */
		/* 820A40ECh case   50:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 820A40ECh case   50:*/		return 0x820A40F0;
		  /* 820A40F0h */ case   51:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A40F0h case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A40F0h case   51:*/		return 0x820A40F4;
		  /* 820A40F4h */ case   52:  		/* subf R11, R10, R11 */
		/* 820A40F4h case   52:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A40F4h case   52:*/		return 0x820A40F8;
		  /* 820A40F8h */ case   53:  		/* b -304 */
		/* 820A40F8h case   53:*/		return 0x820A3FC8;
		/* 820A40F8h case   53:*/		return 0x820A40FC;
		  /* 820A40FCh */ case   54:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A40FCh case   54:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A40FCh case   54:*/		return 0x820A4100;
		  /* 820A4100h */ case   55:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A4100h case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A4100h case   55:*/		return 0x820A4104;
		  /* 820A4104h */ case   56:  		/* lwz R10, <#[R29 + 24]> */
		/* 820A4104h case   56:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 820A4104h case   56:*/		return 0x820A4108;
		  /* 820A4108h */ case   57:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A4108h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A4108h case   57:*/		return 0x820A410C;
		  /* 820A410Ch */ case   58:  		/* subf R11, R10, R11 */
		/* 820A410Ch case   58:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A410Ch case   58:*/		return 0x820A4110;
		  /* 820A4110h */ case   59:  		/* addic R10, R11, -1 */
		/* 820A4110h case   59:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 820A4110h case   59:*/		return 0x820A4114;
		  /* 820A4114h */ case   60:  		/* subfe R11, R10, R11 */
		/* 820A4114h case   60:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A4114h case   60:*/		return 0x820A4118;
		  /* 820A4118h */ case   61:  		/* b -328 */
		/* 820A4118h case   61:*/		return 0x820A3FD0;
		/* 820A4118h case   61:*/		return 0x820A411C;
		  /* 820A411Ch */ case   62:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A411Ch case   62:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A411Ch case   62:*/		return 0x820A4120;
		  /* 820A4120h */ case   63:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A4120h case   63:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A4120h case   63:*/		return 0x820A4124;
		  /* 820A4124h */ case   64:  		/* lwz R10, <#[R29 + 24]> */
		/* 820A4124h case   64:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 820A4124h case   64:*/		return 0x820A4128;
		  /* 820A4128h */ case   65:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A4128h case   65:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A4128h case   65:*/		return 0x820A412C;
		  /* 820A412Ch */ case   66:  		/* and R11, R11, R10 */
		/* 820A412Ch case   66:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A412Ch case   66:*/		return 0x820A4130;
		  /* 820A4130h */ case   67:  		/* b -352 */
		/* 820A4130h case   67:*/		return 0x820A3FD0;
		/* 820A4130h case   67:*/		return 0x820A4134;
		  /* 820A4134h */ case   68:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A4134h case   68:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A4134h case   68:*/		return 0x820A4138;
		  /* 820A4138h */ case   69:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A4138h case   69:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A4138h case   69:*/		return 0x820A413C;
		  /* 820A413Ch */ case   70:  		/* lwz R10, <#[R29 + 24]> */
		/* 820A413Ch case   70:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 820A413Ch case   70:*/		return 0x820A4140;
		  /* 820A4140h */ case   71:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A4140h case   71:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A4140h case   71:*/		return 0x820A4144;
		  /* 820A4144h */ case   72:  		/* xor R11, R11, R10 */
		/* 820A4144h case   72:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A4144h case   72:*/		return 0x820A4148;
		  /* 820A4148h */ case   73:  		/* b -376 */
		/* 820A4148h case   73:*/		return 0x820A3FD0;
		/* 820A4148h case   73:*/		return 0x820A414C;
		  /* 820A414Ch */ case   74:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A414Ch case   74:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A414Ch case   74:*/		return 0x820A4150;
		  /* 820A4150h */ case   75:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A4150h case   75:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A4150h case   75:*/		return 0x820A4154;
		  /* 820A4154h */ case   76:  		/* lwz R10, <#[R29 + 24]> */
		/* 820A4154h case   76:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 820A4154h case   76:*/		return 0x820A4158;
		  /* 820A4158h */ case   77:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A4158h case   77:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A4158h case   77:*/		return 0x820A415C;
		  /* 820A415Ch */ case   78:  		/* or R11, R11, R10 */
		/* 820A415Ch case   78:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A415Ch case   78:*/		return 0x820A4160;
		  /* 820A4160h */ case   79:  		/* b -400 */
		/* 820A4160h case   79:*/		return 0x820A3FD0;
		/* 820A4160h case   79:*/		return 0x820A4164;
		  /* 820A4164h */ case   80:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A4164h case   80:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A4164h case   80:*/		return 0x820A4168;
		  /* 820A4168h */ case   81:  		/* lwz R11, <#[R29 + 24]> */
		/* 820A4168h case   81:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820A4168h case   81:*/		return 0x820A416C;
		  /* 820A416Ch */ case   82:  		/* cmplwi CR6, R11, 0 */
		/* 820A416Ch case   82:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A416Ch case   82:*/		return 0x820A4170;
		  /* 820A4170h */ case   83:  		/* bc 12, CR6_EQ, 24 */
		/* 820A4170h case   83:*/		if ( regs.CR[6].eq ) { return 0x820A4188;  }
		/* 820A4170h case   83:*/		return 0x820A4174;
		  /* 820A4174h */ case   84:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A4174h case   84:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A4174h case   84:*/		return 0x820A4178;
		  /* 820A4178h */ case   85:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A4178h case   85:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A4178h case   85:*/		return 0x820A417C;
		  /* 820A417Ch */ case   86:  		/* cmplwi CR6, R11, 0 */
		/* 820A417Ch case   86:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A417Ch case   86:*/		return 0x820A4180;
		  /* 820A4180h */ case   87:  		/* mr R11, R25 */
		/* 820A4180h case   87:*/		regs.R11 = regs.R25;
		/* 820A4180h case   87:*/		return 0x820A4184;
		  /* 820A4184h */ case   88:  		/* bc 4, CR6_EQ, -436 */
		/* 820A4184h case   88:*/		if ( !regs.CR[6].eq ) { return 0x820A3FD0;  }
		/* 820A4184h case   88:*/		return 0x820A4188;
	}
	return 0x820A4188;
} // Block from 820A4024h-820A4188h (89 instructions)

//////////////////////////////////////////////////////
// Block at 820A4188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4188);
		  /* 820A4188h */ case    0:  		/* mr R11, R26 */
		/* 820A4188h case    0:*/		regs.R11 = regs.R26;
		/* 820A4188h case    0:*/		return 0x820A418C;
		  /* 820A418Ch */ case    1:  		/* b -444 */
		/* 820A418Ch case    1:*/		return 0x820A3FD0;
		/* 820A418Ch case    1:*/		return 0x820A4190;
		  /* 820A4190h */ case    2:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A4190h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A4190h case    2:*/		return 0x820A4194;
		  /* 820A4194h */ case    3:  		/* lwz R11, <#[R29 + 24]> */
		/* 820A4194h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820A4194h case    3:*/		return 0x820A4198;
		  /* 820A4198h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820A4198h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A4198h case    4:*/		return 0x820A419C;
		  /* 820A419Ch */ case    5:  		/* bc 4, CR6_EQ, 24 */
		/* 820A419Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A41B4;  }
		/* 820A419Ch case    5:*/		return 0x820A41A0;
		  /* 820A41A0h */ case    6:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A41A0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A41A0h case    6:*/		return 0x820A41A4;
		  /* 820A41A4h */ case    7:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A41A4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A41A4h case    7:*/		return 0x820A41A8;
		  /* 820A41A8h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820A41A8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A41A8h case    8:*/		return 0x820A41AC;
		  /* 820A41ACh */ case    9:  		/* mr R11, R26 */
		/* 820A41ACh case    9:*/		regs.R11 = regs.R26;
		/* 820A41ACh case    9:*/		return 0x820A41B0;
		  /* 820A41B0h */ case   10:  		/* bc 12, CR6_EQ, -480 */
		/* 820A41B0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A3FD0;  }
		/* 820A41B0h case   10:*/		return 0x820A41B4;
	}
	return 0x820A41B4;
} // Block from 820A4188h-820A41B4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A41B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A41B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A41B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A41B4);
		  /* 820A41B4h */ case    0:  		/* mr R11, R25 */
		/* 820A41B4h case    0:*/		regs.R11 = regs.R25;
		/* 820A41B4h case    0:*/		return 0x820A41B8;
		  /* 820A41B8h */ case    1:  		/* b -488 */
		/* 820A41B8h case    1:*/		return 0x820A3FD0;
		/* 820A41B8h case    1:*/		return 0x820A41BC;
		  /* 820A41BCh */ case    2:  		/* lwz R29, <#[R1 + 80]> */
		/* 820A41BCh case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820A41BCh case    2:*/		return 0x820A41C0;
		  /* 820A41C0h */ case    3:  		/* lwz R11, <#[R29 + 24]> */
		/* 820A41C0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820A41C0h case    3:*/		return 0x820A41C4;
		  /* 820A41C4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820A41C4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A41C4h case    4:*/		return 0x820A41C8;
		  /* 820A41C8h */ case    5:  		/* lwz R11, <#[R1 + 84]> */
		/* 820A41C8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A41C8h case    5:*/		return 0x820A41CC;
		  /* 820A41CCh */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 820A41CCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A41D4;  }
		/* 820A41CCh case    6:*/		return 0x820A41D0;
		  /* 820A41D0h */ case    7:  		/* lwz R11, <#[R1 + 88]> */
		/* 820A41D0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 820A41D0h case    7:*/		return 0x820A41D4;
	}
	return 0x820A41D4;
} // Block from 820A41B4h-820A41D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A41D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A41D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A41D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A41D4);
		  /* 820A41D4h */ case    0:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A41D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A41D4h case    0:*/		return 0x820A41D8;
		  /* 820A41D8h */ case    1:  		/* b -520 */
		/* 820A41D8h case    1:*/		return 0x820A3FD0;
		/* 820A41D8h case    1:*/		return 0x820A41DC;
		  /* 820A41DCh */ case    2:  		/* li R3, 56 */
		/* 820A41DCh case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A41DCh case    2:*/		return 0x820A41E0;
		  /* 820A41E0h */ case    3:  		/* bl 151624 */
		/* 820A41E0h case    3:*/		regs.LR = 0x820A41E4; return 0x820C9228;
		/* 820A41E0h case    3:*/		return 0x820A41E4;
		  /* 820A41E4h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820A41E4h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A41E4h case    4:*/		return 0x820A41E8;
		  /* 820A41E8h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 820A41E8h case    5:*/		if ( regs.CR[0].eq ) { return 0x820A41FC;  }
		/* 820A41E8h case    5:*/		return 0x820A41EC;
		  /* 820A41ECh */ case    6:  		/* addi R4, R30, 2216 */
		/* 820A41ECh case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x8A8);
		/* 820A41ECh case    6:*/		return 0x820A41F0;
		  /* 820A41F0h */ case    7:  		/* bl 153184 */
		/* 820A41F0h case    7:*/		regs.LR = 0x820A41F4; return 0x820C9850;
		/* 820A41F0h case    7:*/		return 0x820A41F4;
		  /* 820A41F4h */ case    8:  		/* mr R29, R3 */
		/* 820A41F4h case    8:*/		regs.R29 = regs.R3;
		/* 820A41F4h case    8:*/		return 0x820A41F8;
		  /* 820A41F8h */ case    9:  		/* b 8 */
		/* 820A41F8h case    9:*/		return 0x820A4200;
		/* 820A41F8h case    9:*/		return 0x820A41FC;
	}
	return 0x820A41FC;
} // Block from 820A41D4h-820A41FCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A41FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A41FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A41FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A41FC);
		  /* 820A41FCh */ case    0:  		/* mr R29, R26 */
		/* 820A41FCh case    0:*/		regs.R29 = regs.R26;
		/* 820A41FCh case    0:*/		return 0x820A4200;
	}
	return 0x820A4200;
} // Block from 820A41FCh-820A4200h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A4200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4200);
		  /* 820A4200h */ case    0:  		/* mr R4, R29 */
		/* 820A4200h case    0:*/		regs.R4 = regs.R29;
		/* 820A4200h case    0:*/		return 0x820A4204;
		  /* 820A4204h */ case    1:  		/* mr R3, R30 */
		/* 820A4204h case    1:*/		regs.R3 = regs.R30;
		/* 820A4204h case    1:*/		return 0x820A4208;
		  /* 820A4208h */ case    2:  		/* bl -13248 */
		/* 820A4208h case    2:*/		regs.LR = 0x820A420C; return 0x820A0E48;
		/* 820A4208h case    2:*/		return 0x820A420C;
	}
	return 0x820A420C;
} // Block from 820A4200h-820A420Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A420Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A420C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A420C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A420C);
		  /* 820A420Ch */ case    0:  		/* lwz R11, <#[R30 + 1640]> */
		/* 820A420Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000668) );
		/* 820A420Ch case    0:*/		return 0x820A4210;
		  /* 820A4210h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A4210h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4210h case    1:*/		return 0x820A4214;
		  /* 820A4214h */ case    2:  		/* bc 4, CR6_EQ, 44 */
		/* 820A4214h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A4240;  }
		/* 820A4214h case    2:*/		return 0x820A4218;
		  /* 820A4218h */ case    3:  		/* lwz R11, <#[R30 + 1676]> */
		/* 820A4218h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000068C) );
		/* 820A4218h case    3:*/		return 0x820A421C;
		  /* 820A421Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820A421Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A421Ch case    4:*/		return 0x820A4220;
		  /* 820A4220h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 820A4220h case    5:*/		if ( regs.CR[6].eq ) { return 0x820A4248;  }
		/* 820A4220h case    5:*/		return 0x820A4224;
		  /* 820A4224h */ case    6:  		/* lwz R10, <#[R11 + 12]> */
		/* 820A4224h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A4224h case    6:*/		return 0x820A4228;
		  /* 820A4228h */ case    7:  		/* mr R3, R11 */
		/* 820A4228h case    7:*/		regs.R3 = regs.R11;
		/* 820A4228h case    7:*/		return 0x820A422C;
		  /* 820A422Ch */ case    8:  		/* stw R10, <#[R30 + 1676]> */
		/* 820A422Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x0000068C) );
		/* 820A422Ch case    8:*/		return 0x820A4230;
		  /* 820A4230h */ case    9:  		/* stw R29, <#[R11 + 8]> */
		/* 820A4230h case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000008) );
		/* 820A4230h case    9:*/		return 0x820A4234;
		  /* 820A4234h */ case   10:  		/* lwz R10, <#[R30 + 1664]> */
		/* 820A4234h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000680) );
		/* 820A4234h case   10:*/		return 0x820A4238;
		  /* 820A4238h */ case   11:  		/* stw R10, <#[R11 + 12]> */
		/* 820A4238h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A4238h case   11:*/		return 0x820A423C;
		  /* 820A423Ch */ case   12:  		/* stw R3, <#[R30 + 1664]> */
		/* 820A423Ch case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000680) );
		/* 820A423Ch case   12:*/		return 0x820A4240;
	}
	return 0x820A4240;
} // Block from 820A420Ch-820A4240h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A4240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4240);
		  /* 820A4240h */ case    0:  		/* addi R1, R1, 208 */
		/* 820A4240h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820A4240h case    0:*/		return 0x820A4244;
		  /* 820A4244h */ case    1:  		/* b -77736 */
		/* 820A4244h case    1:*/		return 0x8209129C;
		/* 820A4244h case    1:*/		return 0x820A4248;
	}
	return 0x820A4248;
} // Block from 820A4240h-820A4248h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A4248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4248);
		  /* 820A4248h */ case    0:  		/* li R3, 20 */
		/* 820A4248h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A4248h case    0:*/		return 0x820A424C;
		  /* 820A424Ch */ case    1:  		/* bl 151516 */
		/* 820A424Ch case    1:*/		regs.LR = 0x820A4250; return 0x820C9228;
		/* 820A424Ch case    1:*/		return 0x820A4250;
		  /* 820A4250h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820A4250h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A4250h case    2:*/		return 0x820A4254;
		  /* 820A4254h */ case    3:  		/* bc 12, CR0_EQ, 28 */
		/* 820A4254h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A4270;  }
		/* 820A4254h case    3:*/		return 0x820A4258;
		  /* 820A4258h */ case    4:  		/* lis R11, -32255 */
		/* 820A4258h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A4258h case    4:*/		return 0x820A425C;
		  /* 820A425Ch */ case    5:  		/* lwz R5, <#[R30 + 1664]> */
		/* 820A425Ch case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000680) );
		/* 820A425Ch case    5:*/		return 0x820A4260;
		  /* 820A4260h */ case    6:  		/* mr R4, R29 */
		/* 820A4260h case    6:*/		regs.R4 = regs.R29;
		/* 820A4260h case    6:*/		return 0x820A4264;
		  /* 820A4264h */ case    7:  		/* addi R6, R11, -10008 */
		/* 820A4264h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD8E8);
		/* 820A4264h case    7:*/		return 0x820A4268;
		  /* 820A4268h */ case    8:  		/* bl 151944 */
		/* 820A4268h case    8:*/		regs.LR = 0x820A426C; return 0x820C93F0;
		/* 820A4268h case    8:*/		return 0x820A426C;
		  /* 820A426Ch */ case    9:  		/* b 8 */
		/* 820A426Ch case    9:*/		return 0x820A4274;
		/* 820A426Ch case    9:*/		return 0x820A4270;
	}
	return 0x820A4270;
} // Block from 820A4248h-820A4270h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A4270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4270);
		  /* 820A4270h */ case    0:  		/* mr R3, R26 */
		/* 820A4270h case    0:*/		regs.R3 = regs.R26;
		/* 820A4270h case    0:*/		return 0x820A4274;
	}
	return 0x820A4274;
} // Block from 820A4270h-820A4274h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A4274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4274);
		  /* 820A4274h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820A4274h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A4274h case    0:*/		return 0x820A4278;
		  /* 820A4278h */ case    1:  		/* bc 4, CR6_EQ, -60 */
		/* 820A4278h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A423C;  }
		/* 820A4278h case    1:*/		return 0x820A427C;
		  /* 820A427Ch */ case    2:  		/* lis R11, -32255 */
		/* 820A427Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A427Ch case    2:*/		return 0x820A4280;
		  /* 820A4280h */ case    3:  		/* addi R6, R11, -10040 */
		/* 820A4280h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD8C8);
		/* 820A4280h case    3:*/		return 0x820A4284;
		  /* 820A4284h */ case    4:  		/* b -1200 */
		/* 820A4284h case    4:*/		return 0x820A3DD4;
		/* 820A4284h case    4:*/		return 0x820A4288;
	}
	return 0x820A4288;
} // Block from 820A4274h-820A4288h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A4288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4288);
		  /* 820A4288h */ case    0:  		/* mfspr R12, LR */
		/* 820A4288h case    0:*/		regs.R12 = regs.LR;
		/* 820A4288h case    0:*/		return 0x820A428C;
		  /* 820A428Ch */ case    1:  		/* bl -77896 */
		/* 820A428Ch case    1:*/		regs.LR = 0x820A4290; return 0x82091244;
		/* 820A428Ch case    1:*/		return 0x820A4290;
		  /* 820A4290h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820A4290h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820A4290h case    2:*/		return 0x820A4294;
		  /* 820A4294h */ case    3:  		/* addi R11, R3, 1032 */
		/* 820A4294h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x408);
		/* 820A4294h case    3:*/		return 0x820A4298;
		  /* 820A4298h */ case    4:  		/* li R25, 0 */
		/* 820A4298h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820A4298h case    4:*/		return 0x820A429C;
		  /* 820A429Ch */ case    5:  		/* stw R11, <#[R3 + 20]> */
		/* 820A429Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820A429Ch case    5:*/		return 0x820A42A0;
		  /* 820A42A0h */ case    6:  		/* li R26, -1 */
		/* 820A42A0h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0xFFFFFFFF);
		/* 820A42A0h case    6:*/		return 0x820A42A4;
		  /* 820A42A4h */ case    7:  		/* addi R24, R3, 32 */
		/* 820A42A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R3,0x20);
		/* 820A42A4h case    7:*/		return 0x820A42A8;
		  /* 820A42A8h */ case    8:  		/* stw R25, <#[R3 + 4]> */
		/* 820A42A8h case    8:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000004) );
		/* 820A42A8h case    8:*/		return 0x820A42AC;
		  /* 820A42ACh */ case    9:  		/* lis R11, -32255 */
		/* 820A42ACh case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A42ACh case    9:*/		return 0x820A42B0;
		  /* 820A42B0h */ case   10:  		/* stw R25, <#[R3 + 8]> */
		/* 820A42B0h case   10:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000008) );
		/* 820A42B0h case   10:*/		return 0x820A42B4;
		  /* 820A42B4h */ case   11:  		/* lis R10, -32255 */
		/* 820A42B4h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A42B4h case   11:*/		return 0x820A42B8;
		  /* 820A42B8h */ case   12:  		/* stw R26, <#[R3 + 12]> */
		/* 820A42B8h case   12:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A42B8h case   12:*/		return 0x820A42BC;
		  /* 820A42BCh */ case   13:  		/* stw R24, <#[R3 + 16]> */
		/* 820A42BCh case   13:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000010) );
		/* 820A42BCh case   13:*/		return 0x820A42C0;
		  /* 820A42C0h */ case   14:  		/* mr R31, R3 */
		/* 820A42C0h case   14:*/		regs.R31 = regs.R3;
		/* 820A42C0h case   14:*/		return 0x820A42C4;
		  /* 820A42C4h */ case   15:  		/* mr R30, R25 */
		/* 820A42C4h case   15:*/		regs.R30 = regs.R25;
		/* 820A42C4h case   15:*/		return 0x820A42C8;
		  /* 820A42C8h */ case   16:  		/* sth R25, <#[R3 + 32]> */
		/* 820A42C8h case   16:*/		cpu::mem::store16( regs, regs.R25, (uint32)(regs.R3 + 0x00000020) );
		/* 820A42C8h case   16:*/		return 0x820A42CC;
		  /* 820A42CCh */ case   17:  		/* addi R27, R11, -14444 */
		/* 820A42CCh case   17:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFC794);
		/* 820A42CCh case   17:*/		return 0x820A42D0;
		  /* 820A42D0h */ case   18:  		/* addi R23, R10, -10392 */
		/* 820A42D0h case   18:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0xFFFFD768);
		/* 820A42D0h case   18:*/		return 0x820A42D4;
		  /* 820A42D4h */ case   19:  		/* addi R11, R27, 260 */
		/* 820A42D4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x104);
		/* 820A42D4h case   19:*/		return 0x820A42D8;
		  /* 820A42D8h */ case   20:  		/* rlwinm R29, R30, 1, 0, 30 */
		/* 820A42D8h case   20:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R29,regs.R30);
		/* 820A42D8h case   20:*/		return 0x820A42DC;
		  /* 820A42DCh */ case   21:  		/* lhax R11, <#[R29 + R11]> */
		/* 820A42DCh case   21:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820A42DCh case   21:*/		return 0x820A42E0;
		  /* 820A42E0h */ case   22:  		/* cmpwi CR0, R11, 0 */
		/* 820A42E0h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820A42E0h case   22:*/		return 0x820A42E4;
		  /* 820A42E4h */ case   23:  		/* bc 4, CR0_EQ, 248 */
		/* 820A42E4h case   23:*/		if ( !regs.CR[0].eq ) { return 0x820A43DC;  }
		/* 820A42E4h case   23:*/		return 0x820A42E8;
		  /* 820A42E8h */ case   24:  		/* lwz R11, <#[R31 + 12]> */
		/* 820A42E8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A42E8h case   24:*/		return 0x820A42EC;
		  /* 820A42ECh */ case   25:  		/* cmpwi CR6, R11, 0 */
		/* 820A42ECh case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A42ECh case   25:*/		return 0x820A42F0;
		  /* 820A42F0h */ case   26:  		/* bc 4, CR6_LT, 32 */
		/* 820A42F0h case   26:*/		if ( !regs.CR[6].lt ) { return 0x820A4310;  }
		/* 820A42F0h case   26:*/		return 0x820A42F4;
		  /* 820A42F4h */ case   27:  		/* addi R4, R1, 96 */
		/* 820A42F4h case   27:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820A42F4h case   27:*/		return 0x820A42F8;
		  /* 820A42F8h */ case   28:  		/* lwz R3, <#[R31 + 3032]> */
		/* 820A42F8h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000BD8) );
		/* 820A42F8h case   28:*/		return 0x820A42FC;
		  /* 820A42FCh */ case   29:  		/* bl -12484 */
		/* 820A42FCh case   29:*/		regs.LR = 0x820A4300; return 0x820A1238;
		/* 820A42FCh case   29:*/		return 0x820A4300;
	}
	return 0x820A4300;
} // Block from 820A4288h-820A4300h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820A4300h
// Function '?Error@CPreProcessor@D3DXShader@@IAAXPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4300);
		  /* 820A4300h */ case    0:  		/* stw R3, <#[R31 + 12]> */
		/* 820A4300h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A4300h case    0:*/		return 0x820A4304;
		  /* 820A4304h */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 820A4304h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A4304h case    1:*/		return 0x820A4308;
		  /* 820A4308h */ case    2:  		/* bc 4, CR0_LT, 8 */
		/* 820A4308h case    2:*/		if ( !regs.CR[0].lt ) { return 0x820A4310;  }
		/* 820A4308h case    2:*/		return 0x820A430C;
		  /* 820A430Ch */ case    3:  		/* stw R25, <#[R31 + 12]> */
		/* 820A430Ch case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A430Ch case    3:*/		return 0x820A4310;
	}
	return 0x820A4310;
} // Block from 820A4300h-820A4310h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A4310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4310);
		  /* 820A4310h */ case    0:  		/* addi R11, R27, 444 */
		/* 820A4310h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x1BC);
		/* 820A4310h case    0:*/		return 0x820A4314;
		  /* 820A4314h */ case    1:  		/* lhax R11, <#[R29 + R11]> */
		/* 820A4314h case    1:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820A4314h case    1:*/		return 0x820A4318;
		  /* 820A4318h */ case    2:  		/* cmpwi CR0, R11, 0 */
		/* 820A4318h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820A4318h case    2:*/		return 0x820A431C;
		  /* 820A431Ch */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 820A431Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820A439C;  }
		/* 820A431Ch case    3:*/		return 0x820A4320;
		  /* 820A4320h */ case    4:  		/* lwz R9, <#[R31 + 12]> */
		/* 820A4320h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A4320h case    4:*/		return 0x820A4324;
		  /* 820A4324h */ case    5:  		/* add. R11, R9, R11 */
		/* 820A4324h case    5:*/		cpu::op::add<1>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820A4324h case    5:*/		return 0x820A4328;
		  /* 820A4328h */ case    6:  		/* bc 12, CR0_LT, 116 */
		/* 820A4328h case    6:*/		if ( regs.CR[0].lt ) { return 0x820A439C;  }
		/* 820A4328h case    6:*/		return 0x820A432C;
		  /* 820A432Ch */ case    7:  		/* cmpwi CR6, R11, 607 */
		/* 820A432Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000025F);
		/* 820A432Ch case    7:*/		return 0x820A4330;
		  /* 820A4330h */ case    8:  		/* bc 12, CR6_GT, 108 */
		/* 820A4330h case    8:*/		if ( regs.CR[6].gt ) { return 0x820A439C;  }
		/* 820A4330h case    8:*/		return 0x820A4334;
		  /* 820A4334h */ case    9:  		/* addi R8, R27, 2060 */
		/* 820A4334h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R27,0x80C);
		/* 820A4334h case    9:*/		return 0x820A4338;
		  /* 820A4338h */ case   10:  		/* rlwinm R10, R11, 1, 0, 30 */
		/* 820A4338h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R11);
		/* 820A4338h case   10:*/		return 0x820A433C;
		  /* 820A433Ch */ case   11:  		/* lhax R11, <#[R10 + R8]> */
		/* 820A433Ch case   11:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820A433Ch case   11:*/		return 0x820A4340;
		  /* 820A4340h */ case   12:  		/* cmpw CR6, R11, R9 */
		/* 820A4340h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 820A4340h case   12:*/		return 0x820A4344;
		  /* 820A4344h */ case   13:  		/* bc 4, CR6_EQ, 88 */
		/* 820A4344h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A439C;  }
		/* 820A4344h case   13:*/		return 0x820A4348;
		  /* 820A4348h */ case   14:  		/* lwz R11, <#[R31 + 16]> */
		/* 820A4348h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A4348h case   14:*/		return 0x820A434C;
		  /* 820A434Ch */ case   15:  		/* addi R9, R31, 1030 */
		/* 820A434Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x406);
		/* 820A434Ch case   15:*/		return 0x820A4350;
	}
	return 0x820A4350;
} // Block from 820A4310h-820A4350h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A4350h
// Function '?DoInclude@CPreProcessor@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4350);
		  /* 820A4350h */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 820A4350h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820A4350h case    0:*/		return 0x820A4354;
		  /* 820A4354h */ case    1:  		/* bc 4, CR6_LT, 1332 */
		/* 820A4354h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820A4888;  }
		/* 820A4354h case    1:*/		return 0x820A4358;
		  /* 820A4358h */ case    2:  		/* addi R9, R27, 844 */
		/* 820A4358h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x34C);
		/* 820A4358h case    2:*/		return 0x820A435C;
		  /* 820A435Ch */ case    3:  		/* addi R11, R11, 2 */
		/* 820A435Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A435Ch case    3:*/		return 0x820A4360;
		  /* 820A4360h */ case    4:  		/* lhax R30, <#[R10 + R9]> */
		/* 820A4360h case    4:*/		cpu::mem::load16a( regs, &regs.R30, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820A4360h case    4:*/		return 0x820A4364;
		  /* 820A4364h */ case    5:  		/* stw R11, <#[R31 + 16]> */
		/* 820A4364h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A4364h case    5:*/		return 0x820A4368;
		  /* 820A4368h */ case    6:  		/* sth R30, <#[R11]> */
		/* 820A4368h case    6:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820A4368h case    6:*/		return 0x820A436C;
		  /* 820A436Ch */ case    7:  		/* lwz R10, <#[R31 + 28]> */
		/* 820A436Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 820A436Ch case    7:*/		return 0x820A4370;
		  /* 820A4370h */ case    8:  		/* lwz R11, <#[R31 + 20]> */
		/* 820A4370h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820A4370h case    8:*/		return 0x820A4374;
		  /* 820A4374h */ case    9:  		/* addi R11, R11, 4 */
		/* 820A4374h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820A4374h case    9:*/		return 0x820A4378;
		  /* 820A4378h */ case   10:  		/* stw R11, <#[R31 + 20]> */
		/* 820A4378h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820A4378h case   10:*/		return 0x820A437C;
		  /* 820A437Ch */ case   11:  		/* stw R10, <#[R11]> */
		/* 820A437Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A437Ch case   11:*/		return 0x820A4380;
		  /* 820A4380h */ case   12:  		/* lwz R11, <#[R31 + 8]> */
		/* 820A4380h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820A4380h case   12:*/		return 0x820A4384;
		  /* 820A4384h */ case   13:  		/* cmpwi CR6, R11, 0 */
		/* 820A4384h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4384h case   13:*/		return 0x820A4388;
		  /* 820A4388h */ case   14:  		/* stw R26, <#[R31 + 12]> */
		/* 820A4388h case   14:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A4388h case   14:*/		return 0x820A438C;
		  /* 820A438Ch */ case   15:  		/* bc 4, CR6_GT, -184 */
		/* 820A438Ch case   15:*/		if ( !regs.CR[6].gt ) { return 0x820A42D4;  }
		/* 820A438Ch case   15:*/		return 0x820A4390;
		  /* 820A4390h */ case   16:  		/* addi R11, R11, -1 */
		/* 820A4390h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A4390h case   16:*/		return 0x820A4394;
		  /* 820A4394h */ case   17:  		/* stw R11, <#[R31 + 8]> */
		/* 820A4394h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820A4394h case   17:*/		return 0x820A4398;
		  /* 820A4398h */ case   18:  		/* b -196 */
		/* 820A4398h case   18:*/		return 0x820A42D4;
		/* 820A4398h case   18:*/		return 0x820A439C;
	}
	return 0x820A439C;
} // Block from 820A4350h-820A439Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A439Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A439C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A439C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A439C);
		  /* 820A439Ch */ case    0:  		/* addi R11, R27, 628 */
		/* 820A439Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x274);
		/* 820A439Ch case    0:*/		return 0x820A43A0;
		  /* 820A43A0h */ case    1:  		/* lhax R11, <#[R29 + R11]> */
		/* 820A43A0h case    1:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820A43A0h case    1:*/		return 0x820A43A4;
		  /* 820A43A4h */ case    2:  		/* cmpwi CR0, R11, 0 */
		/* 820A43A4h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820A43A4h case    2:*/		return 0x820A43A8;
		  /* 820A43A8h */ case    3:  		/* bc 12, CR0_EQ, 1036 */
		/* 820A43A8h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A47B4;  }
		/* 820A43A8h case    3:*/		return 0x820A43AC;
		  /* 820A43ACh */ case    4:  		/* lwz R10, <#[R31 + 12]> */
		/* 820A43ACh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A43ACh case    4:*/		return 0x820A43B0;
		  /* 820A43B0h */ case    5:  		/* add. R11, R10, R11 */
		/* 820A43B0h case    5:*/		cpu::op::add<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A43B0h case    5:*/		return 0x820A43B4;
		  /* 820A43B4h */ case    6:  		/* bc 12, CR0_LT, 1024 */
		/* 820A43B4h case    6:*/		if ( regs.CR[0].lt ) { return 0x820A47B4;  }
		/* 820A43B4h case    6:*/		return 0x820A43B8;
		  /* 820A43B8h */ case    7:  		/* cmpwi CR6, R11, 607 */
		/* 820A43B8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000025F);
		/* 820A43B8h case    7:*/		return 0x820A43BC;
		  /* 820A43BCh */ case    8:  		/* bc 12, CR6_GT, 1016 */
		/* 820A43BCh case    8:*/		if ( regs.CR[6].gt ) { return 0x820A47B4;  }
		/* 820A43BCh case    8:*/		return 0x820A43C0;
		  /* 820A43C0h */ case    9:  		/* addi R9, R27, 2060 */
		/* 820A43C0h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x80C);
		/* 820A43C0h case    9:*/		return 0x820A43C4;
		  /* 820A43C4h */ case   10:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 820A43C4h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 820A43C4h case   10:*/		return 0x820A43C8;
		  /* 820A43C8h */ case   11:  		/* lhax R9, <#[R11 + R9]> */
		/* 820A43C8h case   11:*/		cpu::mem::load16a( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820A43C8h case   11:*/		return 0x820A43CC;
		  /* 820A43CCh */ case   12:  		/* cmpw CR6, R9, R10 */
		/* 820A43CCh case   12:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R10);
		/* 820A43CCh case   12:*/		return 0x820A43D0;
		  /* 820A43D0h */ case   13:  		/* bc 4, CR6_EQ, 996 */
		/* 820A43D0h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A47B4;  }
		/* 820A43D0h case   13:*/		return 0x820A43D4;
		  /* 820A43D4h */ case   14:  		/* addi R10, R27, 844 */
		/* 820A43D4h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x34C);
		/* 820A43D4h case   14:*/		return 0x820A43D8;
		  /* 820A43D8h */ case   15:  		/* lhax R11, <#[R11 + R10]> */
		/* 820A43D8h case   15:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820A43D8h case   15:*/		return 0x820A43DC;
	}
	return 0x820A43DC;
} // Block from 820A439Ch-820A43DCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A43DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A43DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A43DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A43DC);
		  /* 820A43DCh */ case    0:  		/* rlwinm R30, R11, 1, 0, 30 */
		/* 820A43DCh case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R30,regs.R11);
		/* 820A43DCh case    0:*/		return 0x820A43E0;
		  /* 820A43E0h */ case    1:  		/* lwz R10, <#[R31 + 20]> */
		/* 820A43E0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820A43E0h case    1:*/		return 0x820A43E4;
		  /* 820A43E4h */ case    2:  		/* addi R9, R27, 148 */
		/* 820A43E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x94);
		/* 820A43E4h case    2:*/		return 0x820A43E8;
		  /* 820A43E8h */ case    3:  		/* addi R11, R11, -1 */
		/* 820A43E8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A43E8h case    3:*/		return 0x820A43EC;
		  /* 820A43ECh */ case    4:  		/* cmplwi CR6, R11, 53 */
		/* 820A43ECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000035);
		/* 820A43ECh case    4:*/		return 0x820A43F0;
		  /* 820A43F0h */ case    5:  		/* lhax R29, <#[R30 + R9]> */
		/* 820A43F0h case    5:*/		cpu::mem::load16a( regs, &regs.R29, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 820A43F0h case    5:*/		return 0x820A43F4;
		  /* 820A43F4h */ case    6:  		/* rlwinm R28, R29, 2, 0, 29 */
		/* 820A43F4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R29);
		/* 820A43F4h case    6:*/		return 0x820A43F8;
		  /* 820A43F8h */ case    7:  		/* subf R10, R28, R10 */
		/* 820A43F8h case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R28,regs.R10);
		/* 820A43F8h case    7:*/		return 0x820A43FC;
		  /* 820A43FCh */ case    8:  		/* lwz R10, <#[R10 + 4]> */
		/* 820A43FCh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820A43FCh case    8:*/		return 0x820A4400;
		  /* 820A4400h */ case    9:  		/* stw R10, <#[R31 + 24]> */
		/* 820A4400h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820A4400h case    9:*/		return 0x820A4404;
		  /* 820A4404h */ case   10:  		/* bc 12, CR6_GT, 660 */
		/* 820A4404h case   10:*/		if ( regs.CR[6].gt ) { return 0x820A4698;  }
		/* 820A4404h case   10:*/		return 0x820A4408;
		  /* 820A4408h */ case   11:  		/* lis R12, -32255 */
		/* 820A4408h case   11:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820A4408h case   11:*/		return 0x820A440C;
		  /* 820A440Ch */ case   12:  		/* addi R12, R12, -11040 */
		/* 820A440Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFD4E0);
		/* 820A440Ch case   12:*/		return 0x820A4410;
		  /* 820A4410h */ case   13:  		/* lbzx R0, <#[R12 + R11]> */
		/* 820A4410h case   13:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 820A4410h case   13:*/		return 0x820A4414;
		  /* 820A4414h */ case   14:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 820A4414h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 820A4414h case   14:*/		return 0x820A4418;
		  /* 820A4418h */ case   15:  		/* lis R12, -32246 */
		/* 820A4418h case   15:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820A);
		/* 820A4418h case   15:*/		return 0x820A441C;
		  /* 820A441Ch */ case   16:  		/* ori R0, R0, 0 */
		/* 820A441Ch case   16:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820A441Ch case   16:*/		return 0x820A4420;
		  /* 820A4420h */ case   17:  		/* addi R12, R12, 17456 */
		/* 820A4420h case   17:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x4430);
		/* 820A4420h case   17:*/		return 0x820A4424;
		  /* 820A4424h */ case   18:  		/* add R12, R12, R0 */
		/* 820A4424h case   18:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820A4424h case   18:*/		return 0x820A4428;
		  /* 820A4428h */ case   19:  		/* mtspr CTR, R12 */
		/* 820A4428h case   19:*/		regs.CTR = regs.R12;
		/* 820A4428h case   19:*/		return 0x820A442C;
		  /* 820A442Ch */ case   20:  		/* bcctr 20, CR0_LT */
		/* 820A442Ch case   20:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820A442Ch case   20:*/		return 0x820A4430;
		  /* 820A4430h */ case   21:  		/* li R5, 1 */
		/* 820A4430h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4430h case   21:*/		return 0x820A4434;
		  /* 820A4434h */ case   22:  		/* li R4, 0 */
		/* 820A4434h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A4434h case   22:*/		return 0x820A4438;
		  /* 820A4438h */ case   23:  		/* b 600 */
		/* 820A4438h case   23:*/		return 0x820A4690;
		/* 820A4438h case   23:*/		return 0x820A443C;
		  /* 820A443Ch */ case   24:  		/* li R5, 1 */
		/* 820A443Ch case   24:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A443Ch case   24:*/		return 0x820A4440;
		  /* 820A4440h */ case   25:  		/* li R4, 1 */
		/* 820A4440h case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A4440h case   25:*/		return 0x820A4444;
		  /* 820A4444h */ case   26:  		/* b 588 */
		/* 820A4444h case   26:*/		return 0x820A4690;
		/* 820A4444h case   26:*/		return 0x820A4448;
		  /* 820A4448h */ case   27:  		/* li R5, 1 */
		/* 820A4448h case   27:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4448h case   27:*/		return 0x820A444C;
		  /* 820A444Ch */ case   28:  		/* li R4, 2 */
		/* 820A444Ch case   28:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 820A444Ch case   28:*/		return 0x820A4450;
		  /* 820A4450h */ case   29:  		/* b 576 */
		/* 820A4450h case   29:*/		return 0x820A4690;
		/* 820A4450h case   29:*/		return 0x820A4454;
		  /* 820A4454h */ case   30:  		/* li R5, 2 */
		/* 820A4454h case   30:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A4454h case   30:*/		return 0x820A4458;
		  /* 820A4458h */ case   31:  		/* li R4, 3 */
		/* 820A4458h case   31:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 820A4458h case   31:*/		return 0x820A445C;
		  /* 820A445Ch */ case   32:  		/* b 564 */
		/* 820A445Ch case   32:*/		return 0x820A4690;
		/* 820A445Ch case   32:*/		return 0x820A4460;
		  /* 820A4460h */ case   33:  		/* li R4, 4 */
		/* 820A4460h case   33:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 820A4460h case   33:*/		return 0x820A4464;
		  /* 820A4464h */ case   34:  		/* b 552 */
		/* 820A4464h case   34:*/		return 0x820A468C;
		/* 820A4464h case   34:*/		return 0x820A4468;
		  /* 820A4468h */ case   35:  		/* li R4, 5 */
		/* 820A4468h case   35:*/		cpu::op::li<0>(regs,&regs.R4,0x5);
		/* 820A4468h case   35:*/		return 0x820A446C;
		  /* 820A446Ch */ case   36:  		/* b 544 */
		/* 820A446Ch case   36:*/		return 0x820A468C;
		/* 820A446Ch case   36:*/		return 0x820A4470;
		  /* 820A4470h */ case   37:  		/* li R5, 1 */
		/* 820A4470h case   37:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4470h case   37:*/		return 0x820A4474;
		  /* 820A4474h */ case   38:  		/* li R4, 6 */
		/* 820A4474h case   38:*/		cpu::op::li<0>(regs,&regs.R4,0x6);
		/* 820A4474h case   38:*/		return 0x820A4478;
		  /* 820A4478h */ case   39:  		/* b 536 */
		/* 820A4478h case   39:*/		return 0x820A4690;
		/* 820A4478h case   39:*/		return 0x820A447C;
		  /* 820A447Ch */ case   40:  		/* li R5, 1 */
		/* 820A447Ch case   40:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A447Ch case   40:*/		return 0x820A4480;
		  /* 820A4480h */ case   41:  		/* li R4, 7 */
		/* 820A4480h case   41:*/		cpu::op::li<0>(regs,&regs.R4,0x7);
		/* 820A4480h case   41:*/		return 0x820A4484;
		  /* 820A4484h */ case   42:  		/* b 524 */
		/* 820A4484h case   42:*/		return 0x820A4690;
		/* 820A4484h case   42:*/		return 0x820A4488;
		  /* 820A4488h */ case   43:  		/* li R5, 1 */
		/* 820A4488h case   43:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4488h case   43:*/		return 0x820A448C;
		  /* 820A448Ch */ case   44:  		/* li R4, 8 */
		/* 820A448Ch case   44:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 820A448Ch case   44:*/		return 0x820A4490;
		  /* 820A4490h */ case   45:  		/* b 512 */
		/* 820A4490h case   45:*/		return 0x820A4690;
		/* 820A4490h case   45:*/		return 0x820A4494;
		  /* 820A4494h */ case   46:  		/* li R5, 1 */
		/* 820A4494h case   46:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4494h case   46:*/		return 0x820A4498;
		  /* 820A4498h */ case   47:  		/* li R4, 9 */
		/* 820A4498h case   47:*/		cpu::op::li<0>(regs,&regs.R4,0x9);
		/* 820A4498h case   47:*/		return 0x820A449C;
		  /* 820A449Ch */ case   48:  		/* b 500 */
		/* 820A449Ch case   48:*/		return 0x820A4690;
		/* 820A449Ch case   48:*/		return 0x820A44A0;
		  /* 820A44A0h */ case   49:  		/* li R4, 10 */
		/* 820A44A0h case   49:*/		cpu::op::li<0>(regs,&regs.R4,0xA);
		/* 820A44A0h case   49:*/		return 0x820A44A4;
		  /* 820A44A4h */ case   50:  		/* b 488 */
		/* 820A44A4h case   50:*/		return 0x820A468C;
		/* 820A44A4h case   50:*/		return 0x820A44A8;
		  /* 820A44A8h */ case   51:  		/* li R4, 11 */
		/* 820A44A8h case   51:*/		cpu::op::li<0>(regs,&regs.R4,0xB);
		/* 820A44A8h case   51:*/		return 0x820A44AC;
		  /* 820A44ACh */ case   52:  		/* b 480 */
		/* 820A44ACh case   52:*/		return 0x820A468C;
		/* 820A44ACh case   52:*/		return 0x820A44B0;
		  /* 820A44B0h */ case   53:  		/* li R4, 12 */
		/* 820A44B0h case   53:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 820A44B0h case   53:*/		return 0x820A44B4;
		  /* 820A44B4h */ case   54:  		/* b 472 */
		/* 820A44B4h case   54:*/		return 0x820A468C;
		/* 820A44B4h case   54:*/		return 0x820A44B8;
		  /* 820A44B8h */ case   55:  		/* li R4, 13 */
		/* 820A44B8h case   55:*/		cpu::op::li<0>(regs,&regs.R4,0xD);
		/* 820A44B8h case   55:*/		return 0x820A44BC;
		  /* 820A44BCh */ case   56:  		/* b 464 */
		/* 820A44BCh case   56:*/		return 0x820A468C;
		/* 820A44BCh case   56:*/		return 0x820A44C0;
		  /* 820A44C0h */ case   57:  		/* li R4, 14 */
		/* 820A44C0h case   57:*/		cpu::op::li<0>(regs,&regs.R4,0xE);
		/* 820A44C0h case   57:*/		return 0x820A44C4;
		  /* 820A44C4h */ case   58:  		/* b 456 */
		/* 820A44C4h case   58:*/		return 0x820A468C;
		/* 820A44C4h case   58:*/		return 0x820A44C8;
		  /* 820A44C8h */ case   59:  		/* li R5, 1 */
		/* 820A44C8h case   59:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A44C8h case   59:*/		return 0x820A44CC;
		  /* 820A44CCh */ case   60:  		/* li R4, 15 */
		/* 820A44CCh case   60:*/		cpu::op::li<0>(regs,&regs.R4,0xF);
		/* 820A44CCh case   60:*/		return 0x820A44D0;
		  /* 820A44D0h */ case   61:  		/* b 448 */
		/* 820A44D0h case   61:*/		return 0x820A4690;
		/* 820A44D0h case   61:*/		return 0x820A44D4;
		  /* 820A44D4h */ case   62:  		/* li R5, 1 */
		/* 820A44D4h case   62:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A44D4h case   62:*/		return 0x820A44D8;
		  /* 820A44D8h */ case   63:  		/* li R4, 16 */
		/* 820A44D8h case   63:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 820A44D8h case   63:*/		return 0x820A44DC;
		  /* 820A44DCh */ case   64:  		/* b 436 */
		/* 820A44DCh case   64:*/		return 0x820A4690;
		/* 820A44DCh case   64:*/		return 0x820A44E0;
		  /* 820A44E0h */ case   65:  		/* li R5, 1 */
		/* 820A44E0h case   65:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A44E0h case   65:*/		return 0x820A44E4;
		  /* 820A44E4h */ case   66:  		/* li R4, 17 */
		/* 820A44E4h case   66:*/		cpu::op::li<0>(regs,&regs.R4,0x11);
		/* 820A44E4h case   66:*/		return 0x820A44E8;
		  /* 820A44E8h */ case   67:  		/* b 424 */
		/* 820A44E8h case   67:*/		return 0x820A4690;
		/* 820A44E8h case   67:*/		return 0x820A44EC;
		  /* 820A44ECh */ case   68:  		/* li R5, 1 */
		/* 820A44ECh case   68:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A44ECh case   68:*/		return 0x820A44F0;
		  /* 820A44F0h */ case   69:  		/* li R4, 18 */
		/* 820A44F0h case   69:*/		cpu::op::li<0>(regs,&regs.R4,0x12);
		/* 820A44F0h case   69:*/		return 0x820A44F4;
		  /* 820A44F4h */ case   70:  		/* b 412 */
		/* 820A44F4h case   70:*/		return 0x820A4690;
		/* 820A44F4h case   70:*/		return 0x820A44F8;
		  /* 820A44F8h */ case   71:  		/* li R5, 1 */
		/* 820A44F8h case   71:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A44F8h case   71:*/		return 0x820A44FC;
		  /* 820A44FCh */ case   72:  		/* li R4, 19 */
		/* 820A44FCh case   72:*/		cpu::op::li<0>(regs,&regs.R4,0x13);
		/* 820A44FCh case   72:*/		return 0x820A4500;
		  /* 820A4500h */ case   73:  		/* b 400 */
		/* 820A4500h case   73:*/		return 0x820A4690;
		/* 820A4500h case   73:*/		return 0x820A4504;
		  /* 820A4504h */ case   74:  		/* li R5, 1 */
		/* 820A4504h case   74:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4504h case   74:*/		return 0x820A4508;
		  /* 820A4508h */ case   75:  		/* li R4, 20 */
		/* 820A4508h case   75:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 820A4508h case   75:*/		return 0x820A450C;
		  /* 820A450Ch */ case   76:  		/* b 388 */
		/* 820A450Ch case   76:*/		return 0x820A4690;
		/* 820A450Ch case   76:*/		return 0x820A4510;
		  /* 820A4510h */ case   77:  		/* li R5, 1 */
		/* 820A4510h case   77:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4510h case   77:*/		return 0x820A4514;
		  /* 820A4514h */ case   78:  		/* li R4, 21 */
		/* 820A4514h case   78:*/		cpu::op::li<0>(regs,&regs.R4,0x15);
		/* 820A4514h case   78:*/		return 0x820A4518;
		  /* 820A4518h */ case   79:  		/* b 376 */
		/* 820A4518h case   79:*/		return 0x820A4690;
		/* 820A4518h case   79:*/		return 0x820A451C;
		  /* 820A451Ch */ case   80:  		/* li R5, 1 */
		/* 820A451Ch case   80:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A451Ch case   80:*/		return 0x820A4520;
		  /* 820A4520h */ case   81:  		/* li R4, 22 */
		/* 820A4520h case   81:*/		cpu::op::li<0>(regs,&regs.R4,0x16);
		/* 820A4520h case   81:*/		return 0x820A4524;
		  /* 820A4524h */ case   82:  		/* b 364 */
		/* 820A4524h case   82:*/		return 0x820A4690;
		/* 820A4524h case   82:*/		return 0x820A4528;
		  /* 820A4528h */ case   83:  		/* li R5, 1 */
		/* 820A4528h case   83:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4528h case   83:*/		return 0x820A452C;
		  /* 820A452Ch */ case   84:  		/* li R4, 23 */
		/* 820A452Ch case   84:*/		cpu::op::li<0>(regs,&regs.R4,0x17);
		/* 820A452Ch case   84:*/		return 0x820A4530;
		  /* 820A4530h */ case   85:  		/* b 352 */
		/* 820A4530h case   85:*/		return 0x820A4690;
		/* 820A4530h case   85:*/		return 0x820A4534;
		  /* 820A4534h */ case   86:  		/* li R5, 1 */
		/* 820A4534h case   86:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4534h case   86:*/		return 0x820A4538;
		  /* 820A4538h */ case   87:  		/* li R4, 24 */
		/* 820A4538h case   87:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 820A4538h case   87:*/		return 0x820A453C;
		  /* 820A453Ch */ case   88:  		/* b 340 */
		/* 820A453Ch case   88:*/		return 0x820A4690;
		/* 820A453Ch case   88:*/		return 0x820A4540;
		  /* 820A4540h */ case   89:  		/* li R5, 2 */
		/* 820A4540h case   89:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A4540h case   89:*/		return 0x820A4544;
		  /* 820A4544h */ case   90:  		/* li R4, 25 */
		/* 820A4544h case   90:*/		cpu::op::li<0>(regs,&regs.R4,0x19);
		/* 820A4544h case   90:*/		return 0x820A4548;
		  /* 820A4548h */ case   91:  		/* b 328 */
		/* 820A4548h case   91:*/		return 0x820A4690;
		/* 820A4548h case   91:*/		return 0x820A454C;
		  /* 820A454Ch */ case   92:  		/* li R5, 2 */
		/* 820A454Ch case   92:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A454Ch case   92:*/		return 0x820A4550;
		  /* 820A4550h */ case   93:  		/* li R4, 26 */
		/* 820A4550h case   93:*/		cpu::op::li<0>(regs,&regs.R4,0x1A);
		/* 820A4550h case   93:*/		return 0x820A4554;
		  /* 820A4554h */ case   94:  		/* b 316 */
		/* 820A4554h case   94:*/		return 0x820A4690;
		/* 820A4554h case   94:*/		return 0x820A4558;
		  /* 820A4558h */ case   95:  		/* li R5, 1 */
		/* 820A4558h case   95:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4558h case   95:*/		return 0x820A455C;
		  /* 820A455Ch */ case   96:  		/* li R4, 27 */
		/* 820A455Ch case   96:*/		cpu::op::li<0>(regs,&regs.R4,0x1B);
		/* 820A455Ch case   96:*/		return 0x820A4560;
		  /* 820A4560h */ case   97:  		/* b 304 */
		/* 820A4560h case   97:*/		return 0x820A4690;
		/* 820A4560h case   97:*/		return 0x820A4564;
		  /* 820A4564h */ case   98:  		/* li R5, 2 */
		/* 820A4564h case   98:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A4564h case   98:*/		return 0x820A4568;
		  /* 820A4568h */ case   99:  		/* li R4, 28 */
		/* 820A4568h case   99:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 820A4568h case   99:*/		return 0x820A456C;
		  /* 820A456Ch */ case  100:  		/* b 292 */
		/* 820A456Ch case  100:*/		return 0x820A4690;
		/* 820A456Ch case  100:*/		return 0x820A4570;
		  /* 820A4570h */ case  101:  		/* li R5, 2 */
		/* 820A4570h case  101:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A4570h case  101:*/		return 0x820A4574;
		  /* 820A4574h */ case  102:  		/* li R4, 29 */
		/* 820A4574h case  102:*/		cpu::op::li<0>(regs,&regs.R4,0x1D);
		/* 820A4574h case  102:*/		return 0x820A4578;
		  /* 820A4578h */ case  103:  		/* b 280 */
		/* 820A4578h case  103:*/		return 0x820A4690;
		/* 820A4578h case  103:*/		return 0x820A457C;
		  /* 820A457Ch */ case  104:  		/* li R5, 1 */
		/* 820A457Ch case  104:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A457Ch case  104:*/		return 0x820A4580;
		  /* 820A4580h */ case  105:  		/* li R4, 30 */
		/* 820A4580h case  105:*/		cpu::op::li<0>(regs,&regs.R4,0x1E);
		/* 820A4580h case  105:*/		return 0x820A4584;
		  /* 820A4584h */ case  106:  		/* b 268 */
		/* 820A4584h case  106:*/		return 0x820A4690;
		/* 820A4584h case  106:*/		return 0x820A4588;
		  /* 820A4588h */ case  107:  		/* li R5, 2 */
		/* 820A4588h case  107:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A4588h case  107:*/		return 0x820A458C;
		  /* 820A458Ch */ case  108:  		/* li R4, 31 */
		/* 820A458Ch case  108:*/		cpu::op::li<0>(regs,&regs.R4,0x1F);
		/* 820A458Ch case  108:*/		return 0x820A4590;
		  /* 820A4590h */ case  109:  		/* b 256 */
		/* 820A4590h case  109:*/		return 0x820A4690;
		/* 820A4590h case  109:*/		return 0x820A4594;
		  /* 820A4594h */ case  110:  		/* li R5, 2 */
		/* 820A4594h case  110:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A4594h case  110:*/		return 0x820A4598;
		  /* 820A4598h */ case  111:  		/* li R4, 32 */
		/* 820A4598h case  111:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 820A4598h case  111:*/		return 0x820A459C;
		  /* 820A459Ch */ case  112:  		/* b 244 */
		/* 820A459Ch case  112:*/		return 0x820A4690;
		/* 820A459Ch case  112:*/		return 0x820A45A0;
		  /* 820A45A0h */ case  113:  		/* li R5, 2 */
		/* 820A45A0h case  113:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A45A0h case  113:*/		return 0x820A45A4;
		  /* 820A45A4h */ case  114:  		/* li R4, 33 */
		/* 820A45A4h case  114:*/		cpu::op::li<0>(regs,&regs.R4,0x21);
		/* 820A45A4h case  114:*/		return 0x820A45A8;
		  /* 820A45A8h */ case  115:  		/* b 232 */
		/* 820A45A8h case  115:*/		return 0x820A4690;
		/* 820A45A8h case  115:*/		return 0x820A45AC;
		  /* 820A45ACh */ case  116:  		/* li R5, 2 */
		/* 820A45ACh case  116:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A45ACh case  116:*/		return 0x820A45B0;
		  /* 820A45B0h */ case  117:  		/* li R4, 34 */
		/* 820A45B0h case  117:*/		cpu::op::li<0>(regs,&regs.R4,0x22);
		/* 820A45B0h case  117:*/		return 0x820A45B4;
		  /* 820A45B4h */ case  118:  		/* b 220 */
		/* 820A45B4h case  118:*/		return 0x820A4690;
		/* 820A45B4h case  118:*/		return 0x820A45B8;
		  /* 820A45B8h */ case  119:  		/* li R5, 1 */
		/* 820A45B8h case  119:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A45B8h case  119:*/		return 0x820A45BC;
		  /* 820A45BCh */ case  120:  		/* li R4, 35 */
		/* 820A45BCh case  120:*/		cpu::op::li<0>(regs,&regs.R4,0x23);
		/* 820A45BCh case  120:*/		return 0x820A45C0;
		  /* 820A45C0h */ case  121:  		/* b 208 */
		/* 820A45C0h case  121:*/		return 0x820A4690;
		/* 820A45C0h case  121:*/		return 0x820A45C4;
		  /* 820A45C4h */ case  122:  		/* li R5, 2 */
		/* 820A45C4h case  122:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A45C4h case  122:*/		return 0x820A45C8;
	}
	return 0x820A45C8;
} // Block from 820A43DCh-820A45C8h (123 instructions)

//////////////////////////////////////////////////////
// Block at 820A45C8h
// Function '?InitializeFromMemory@CPreProcessor@D3DXShader@@QAAJPBDPBXIPBU_D3DXMACRO@@PAUID3DXInclude@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A45C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A45C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A45C8);
		  /* 820A45C8h */ case    0:  		/* li R4, 36 */
		/* 820A45C8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x24);
		/* 820A45C8h case    0:*/		return 0x820A45CC;
		  /* 820A45CCh */ case    1:  		/* b 196 */
		/* 820A45CCh case    1:*/		return 0x820A4690;
		/* 820A45CCh case    1:*/		return 0x820A45D0;
		  /* 820A45D0h */ case    2:  		/* li R5, 2 */
		/* 820A45D0h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A45D0h case    2:*/		return 0x820A45D4;
		  /* 820A45D4h */ case    3:  		/* li R4, 37 */
		/* 820A45D4h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x25);
		/* 820A45D4h case    3:*/		return 0x820A45D8;
		  /* 820A45D8h */ case    4:  		/* b 184 */
		/* 820A45D8h case    4:*/		return 0x820A4690;
		/* 820A45D8h case    4:*/		return 0x820A45DC;
		  /* 820A45DCh */ case    5:  		/* li R5, 1 */
		/* 820A45DCh case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A45DCh case    5:*/		return 0x820A45E0;
		  /* 820A45E0h */ case    6:  		/* li R4, 38 */
		/* 820A45E0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x26);
		/* 820A45E0h case    6:*/		return 0x820A45E4;
		  /* 820A45E4h */ case    7:  		/* b 172 */
		/* 820A45E4h case    7:*/		return 0x820A4690;
		/* 820A45E4h case    7:*/		return 0x820A45E8;
		  /* 820A45E8h */ case    8:  		/* li R5, 2 */
		/* 820A45E8h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A45E8h case    8:*/		return 0x820A45EC;
		  /* 820A45ECh */ case    9:  		/* li R4, 39 */
		/* 820A45ECh case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x27);
		/* 820A45ECh case    9:*/		return 0x820A45F0;
		  /* 820A45F0h */ case   10:  		/* b 160 */
		/* 820A45F0h case   10:*/		return 0x820A4690;
		/* 820A45F0h case   10:*/		return 0x820A45F4;
		  /* 820A45F4h */ case   11:  		/* li R5, 1 */
		/* 820A45F4h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A45F4h case   11:*/		return 0x820A45F8;
		  /* 820A45F8h */ case   12:  		/* li R4, 40 */
		/* 820A45F8h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 820A45F8h case   12:*/		return 0x820A45FC;
		  /* 820A45FCh */ case   13:  		/* b 148 */
		/* 820A45FCh case   13:*/		return 0x820A4690;
		/* 820A45FCh case   13:*/		return 0x820A4600;
		  /* 820A4600h */ case   14:  		/* li R5, 2 */
		/* 820A4600h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A4600h case   14:*/		return 0x820A4604;
		  /* 820A4604h */ case   15:  		/* li R4, 41 */
		/* 820A4604h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x29);
		/* 820A4604h case   15:*/		return 0x820A4608;
		  /* 820A4608h */ case   16:  		/* b 136 */
		/* 820A4608h case   16:*/		return 0x820A4690;
		/* 820A4608h case   16:*/		return 0x820A460C;
		  /* 820A460Ch */ case   17:  		/* li R5, 1 */
		/* 820A460Ch case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A460Ch case   17:*/		return 0x820A4610;
		  /* 820A4610h */ case   18:  		/* li R4, 42 */
		/* 820A4610h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x2A);
		/* 820A4610h case   18:*/		return 0x820A4614;
		  /* 820A4614h */ case   19:  		/* b 124 */
		/* 820A4614h case   19:*/		return 0x820A4690;
		/* 820A4614h case   19:*/		return 0x820A4618;
		  /* 820A4618h */ case   20:  		/* li R5, 2 */
		/* 820A4618h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A4618h case   20:*/		return 0x820A461C;
		  /* 820A461Ch */ case   21:  		/* li R4, 43 */
		/* 820A461Ch case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x2B);
		/* 820A461Ch case   21:*/		return 0x820A4620;
		  /* 820A4620h */ case   22:  		/* b 112 */
		/* 820A4620h case   22:*/		return 0x820A4690;
		/* 820A4620h case   22:*/		return 0x820A4624;
		  /* 820A4624h */ case   23:  		/* li R5, 1 */
		/* 820A4624h case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4624h case   23:*/		return 0x820A4628;
		  /* 820A4628h */ case   24:  		/* li R4, 44 */
		/* 820A4628h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x2C);
		/* 820A4628h case   24:*/		return 0x820A462C;
		  /* 820A462Ch */ case   25:  		/* b 100 */
		/* 820A462Ch case   25:*/		return 0x820A4690;
		/* 820A462Ch case   25:*/		return 0x820A4630;
		  /* 820A4630h */ case   26:  		/* li R5, 2 */
		/* 820A4630h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A4630h case   26:*/		return 0x820A4634;
		  /* 820A4634h */ case   27:  		/* li R4, 45 */
		/* 820A4634h case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x2D);
		/* 820A4634h case   27:*/		return 0x820A4638;
		  /* 820A4638h */ case   28:  		/* b 88 */
		/* 820A4638h case   28:*/		return 0x820A4690;
		/* 820A4638h case   28:*/		return 0x820A463C;
		  /* 820A463Ch */ case   29:  		/* li R5, 1 */
		/* 820A463Ch case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A463Ch case   29:*/		return 0x820A4640;
		  /* 820A4640h */ case   30:  		/* li R4, 46 */
		/* 820A4640h case   30:*/		cpu::op::li<0>(regs,&regs.R4,0x2E);
		/* 820A4640h case   30:*/		return 0x820A4644;
		  /* 820A4644h */ case   31:  		/* b 76 */
		/* 820A4644h case   31:*/		return 0x820A4690;
		/* 820A4644h case   31:*/		return 0x820A4648;
		  /* 820A4648h */ case   32:  		/* li R5, 2 */
		/* 820A4648h case   32:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820A4648h case   32:*/		return 0x820A464C;
		  /* 820A464Ch */ case   33:  		/* li R4, 47 */
		/* 820A464Ch case   33:*/		cpu::op::li<0>(regs,&regs.R4,0x2F);
		/* 820A464Ch case   33:*/		return 0x820A4650;
		  /* 820A4650h */ case   34:  		/* b 64 */
		/* 820A4650h case   34:*/		return 0x820A4690;
		/* 820A4650h case   34:*/		return 0x820A4654;
		  /* 820A4654h */ case   35:  		/* li R5, 1 */
		/* 820A4654h case   35:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A4654h case   35:*/		return 0x820A4658;
		  /* 820A4658h */ case   36:  		/* li R4, 48 */
		/* 820A4658h case   36:*/		cpu::op::li<0>(regs,&regs.R4,0x30);
		/* 820A4658h case   36:*/		return 0x820A465C;
		  /* 820A465Ch */ case   37:  		/* b 52 */
		/* 820A465Ch case   37:*/		return 0x820A4690;
		/* 820A465Ch case   37:*/		return 0x820A4660;
		  /* 820A4660h */ case   38:  		/* li R5, 3 */
		/* 820A4660h case   38:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 820A4660h case   38:*/		return 0x820A4664;
		  /* 820A4664h */ case   39:  		/* li R4, 49 */
		/* 820A4664h case   39:*/		cpu::op::li<0>(regs,&regs.R4,0x31);
		/* 820A4664h case   39:*/		return 0x820A4668;
		  /* 820A4668h */ case   40:  		/* b 40 */
		/* 820A4668h case   40:*/		return 0x820A4690;
		/* 820A4668h case   40:*/		return 0x820A466C;
		  /* 820A466Ch */ case   41:  		/* li R5, 1 */
		/* 820A466Ch case   41:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A466Ch case   41:*/		return 0x820A4670;
		  /* 820A4670h */ case   42:  		/* li R4, 50 */
		/* 820A4670h case   42:*/		cpu::op::li<0>(regs,&regs.R4,0x32);
		/* 820A4670h case   42:*/		return 0x820A4674;
		  /* 820A4674h */ case   43:  		/* b 28 */
		/* 820A4674h case   43:*/		return 0x820A4690;
		/* 820A4674h case   43:*/		return 0x820A4678;
		  /* 820A4678h */ case   44:  		/* li R4, 51 */
		/* 820A4678h case   44:*/		cpu::op::li<0>(regs,&regs.R4,0x33);
		/* 820A4678h case   44:*/		return 0x820A467C;
		  /* 820A467Ch */ case   45:  		/* b 16 */
		/* 820A467Ch case   45:*/		return 0x820A468C;
		/* 820A467Ch case   45:*/		return 0x820A4680;
		  /* 820A4680h */ case   46:  		/* li R4, 52 */
		/* 820A4680h case   46:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 820A4680h case   46:*/		return 0x820A4684;
		  /* 820A4684h */ case   47:  		/* b 8 */
		/* 820A4684h case   47:*/		return 0x820A468C;
		/* 820A4684h case   47:*/		return 0x820A4688;
		  /* 820A4688h */ case   48:  		/* li R4, 53 */
		/* 820A4688h case   48:*/		cpu::op::li<0>(regs,&regs.R4,0x35);
		/* 820A4688h case   48:*/		return 0x820A468C;
	}
	return 0x820A468C;
} // Block from 820A45C8h-820A468Ch (49 instructions)

//////////////////////////////////////////////////////
// Block at 820A468Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A468C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A468C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A468C);
		  /* 820A468Ch */ case    0:  		/* li R5, 0 */
		/* 820A468Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A468Ch case    0:*/		return 0x820A4690;
	}
	return 0x820A4690;
} // Block from 820A468Ch-820A4690h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A4690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4690);
		  /* 820A4690h */ case    0:  		/* lwz R3, <#[R31 + 3032]> */
		/* 820A4690h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000BD8) );
		/* 820A4690h case    0:*/		return 0x820A4694;
		  /* 820A4694h */ case    1:  		/* bl -2468 */
		/* 820A4694h case    1:*/		regs.LR = 0x820A4698; return 0x820A3CF0;
		/* 820A4694h case    1:*/		return 0x820A4698;
	}
	return 0x820A4698;
} // Block from 820A4690h-820A4698h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A4698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4698);
		  /* 820A4698h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 820A4698h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A4698h case    0:*/		return 0x820A469C;
		  /* 820A469Ch */ case    1:  		/* rlwinm R10, R29, 1, 0, 30 */
		/* 820A469Ch case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R29);
		/* 820A469Ch case    1:*/		return 0x820A46A0;
		  /* 820A46A0h */ case    2:  		/* lwz R9, <#[R31 + 20]> */
		/* 820A46A0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820A46A0h case    2:*/		return 0x820A46A4;
		  /* 820A46A4h */ case    3:  		/* addi R8, R27, 36 */
		/* 820A46A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R27,0x24);
		/* 820A46A4h case    3:*/		return 0x820A46A8;
		  /* 820A46A8h */ case    4:  		/* subf R11, R10, R11 */
		/* 820A46A8h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A46A8h case    4:*/		return 0x820A46AC;
		  /* 820A46ACh */ case    5:  		/* subf R10, R28, R9 */
		/* 820A46ACh case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R28,regs.R9);
		/* 820A46ACh case    5:*/		return 0x820A46B0;
		  /* 820A46B0h */ case    6:  		/* stw R11, <#[R31 + 16]> */
		/* 820A46B0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A46B0h case    6:*/		return 0x820A46B4;
		  /* 820A46B4h */ case    7:  		/* lha R11, <#[R11]> */
		/* 820A46B4h case    7:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A46B4h case    7:*/		return 0x820A46B8;
		  /* 820A46B8h */ case    8:  		/* stw R10, <#[R31 + 20]> */
		/* 820A46B8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820A46B8h case    8:*/		return 0x820A46BC;
		  /* 820A46BCh */ case    9:  		/* cmpwi CR0, R11, 0 */
		/* 820A46BCh case    9:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820A46BCh case    9:*/		return 0x820A46C0;
		  /* 820A46C0h */ case   10:  		/* lhax R10, <#[R30 + R8]> */
		/* 820A46C0h case   10:*/		cpu::mem::load16a( regs, &regs.R10, (uint32)(regs.R30 + regs.R8 + 0x00000000) );
		/* 820A46C0h case   10:*/		return 0x820A46C4;
		  /* 820A46C4h */ case   11:  		/* bc 4, CR0_EQ, 116 */
		/* 820A46C4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820A4738;  }
		/* 820A46C4h case   11:*/		return 0x820A46C8;
		  /* 820A46C8h */ case   12:  		/* cmpwi CR6, R10, 0 */
		/* 820A46C8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820A46C8h case   12:*/		return 0x820A46CC;
		  /* 820A46CCh */ case   13:  		/* bc 4, CR6_EQ, 108 */
		/* 820A46CCh case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A4738;  }
		/* 820A46CCh case   13:*/		return 0x820A46D0;
		  /* 820A46D0h */ case   14:  		/* lwz R11, <#[R31 + 16]> */
		/* 820A46D0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A46D0h case   14:*/		return 0x820A46D4;
		  /* 820A46D4h */ case   15:  		/* li R10, 15 */
		/* 820A46D4h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0xF);
		/* 820A46D4h case   15:*/		return 0x820A46D8;
		  /* 820A46D8h */ case   16:  		/* li R30, 15 */
		/* 820A46D8h case   16:*/		cpu::op::li<0>(regs,&regs.R30,0xF);
		/* 820A46D8h case   16:*/		return 0x820A46DC;
		  /* 820A46DCh */ case   17:  		/* addi R11, R11, 2 */
		/* 820A46DCh case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A46DCh case   17:*/		return 0x820A46E0;
		  /* 820A46E0h */ case   18:  		/* stw R11, <#[R31 + 16]> */
		/* 820A46E0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A46E0h case   18:*/		return 0x820A46E4;
		  /* 820A46E4h */ case   19:  		/* sth R10, <#[R11]> */
		/* 820A46E4h case   19:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A46E4h case   19:*/		return 0x820A46E8;
		  /* 820A46E8h */ case   20:  		/* lwz R10, <#[R31 + 24]> */
		/* 820A46E8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820A46E8h case   20:*/		return 0x820A46EC;
		  /* 820A46ECh */ case   21:  		/* lwz R11, <#[R31 + 20]> */
		/* 820A46ECh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820A46ECh case   21:*/		return 0x820A46F0;
		  /* 820A46F0h */ case   22:  		/* addi R11, R11, 4 */
		/* 820A46F0h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820A46F0h case   22:*/		return 0x820A46F4;
		  /* 820A46F4h */ case   23:  		/* stw R11, <#[R31 + 20]> */
		/* 820A46F4h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820A46F4h case   23:*/		return 0x820A46F8;
		  /* 820A46F8h */ case   24:  		/* stw R10, <#[R11]> */
		/* 820A46F8h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A46F8h case   24:*/		return 0x820A46FC;
		  /* 820A46FCh */ case   25:  		/* lwz R11, <#[R31 + 12]> */
		/* 820A46FCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A46FCh case   25:*/		return 0x820A4700;
		  /* 820A4700h */ case   26:  		/* cmpwi CR6, R11, 0 */
		/* 820A4700h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4700h case   26:*/		return 0x820A4704;
		  /* 820A4704h */ case   27:  		/* bc 4, CR6_LT, 32 */
		/* 820A4704h case   27:*/		if ( !regs.CR[6].lt ) { return 0x820A4724;  }
		/* 820A4704h case   27:*/		return 0x820A4708;
	}
	return 0x820A4708;
} // Block from 820A4698h-820A4708h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820A4708h
// Function '?Production@CPreProcessor@D3DXShader@@IAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4708);
		  /* 820A4708h */ case    0:  		/* addi R4, R1, 96 */
		/* 820A4708h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820A4708h case    0:*/		return 0x820A470C;
		  /* 820A470Ch */ case    1:  		/* lwz R3, <#[R31 + 3032]> */
		/* 820A470Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000BD8) );
		/* 820A470Ch case    1:*/		return 0x820A4710;
		  /* 820A4710h */ case    2:  		/* bl -13528 */
		/* 820A4710h case    2:*/		regs.LR = 0x820A4714; return 0x820A1238;
		/* 820A4710h case    2:*/		return 0x820A4714;
		  /* 820A4714h */ case    3:  		/* stw R3, <#[R31 + 12]> */
		/* 820A4714h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A4714h case    3:*/		return 0x820A4718;
		  /* 820A4718h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820A4718h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A4718h case    4:*/		return 0x820A471C;
		  /* 820A471Ch */ case    5:  		/* bc 4, CR0_LT, 8 */
		/* 820A471Ch case    5:*/		if ( !regs.CR[0].lt ) { return 0x820A4724;  }
		/* 820A471Ch case    5:*/		return 0x820A4720;
		  /* 820A4720h */ case    6:  		/* stw R25, <#[R31 + 12]> */
		/* 820A4720h case    6:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A4720h case    6:*/		return 0x820A4724;
	}
	return 0x820A4724;
} // Block from 820A4708h-820A4724h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A4724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4724);
		  /* 820A4724h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820A4724h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A4724h case    0:*/		return 0x820A4728;
		  /* 820A4728h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A4728h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4728h case    1:*/		return 0x820A472C;
		  /* 820A472Ch */ case    2:  		/* bc 4, CR6_EQ, -1112 */
		/* 820A472Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A42D4;  }
		/* 820A472Ch case    2:*/		return 0x820A4730;
		  /* 820A4730h */ case    3:  		/* li R3, 0 */
		/* 820A4730h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A4730h case    3:*/		return 0x820A4734;
		  /* 820A4734h */ case    4:  		/* b 360 */
		/* 820A4734h case    4:*/		return 0x820A489C;
		/* 820A4734h case    4:*/		return 0x820A4738;
	}
	return 0x820A4738;
} // Block from 820A4724h-820A4738h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A4738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4738);
		  /* 820A4738h */ case    0:  		/* rlwinm R9, R10, 1, 0, 30 */
		/* 820A4738h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R10);
		/* 820A4738h case    0:*/		return 0x820A473C;
		  /* 820A473Ch */ case    1:  		/* addi R10, R27, 808 */
		/* 820A473Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x328);
		/* 820A473Ch case    1:*/		return 0x820A4740;
		  /* 820A4740h */ case    2:  		/* lhax R10, <#[R9 + R10]> */
		/* 820A4740h case    2:*/		cpu::mem::load16a( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820A4740h case    2:*/		return 0x820A4744;
		  /* 820A4744h */ case    3:  		/* cmpwi CR0, R10, 0 */
		/* 820A4744h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 820A4744h case    3:*/		return 0x820A4748;
		  /* 820A4748h */ case    4:  		/* bc 12, CR0_EQ, 52 */
		/* 820A4748h case    4:*/		if ( regs.CR[0].eq ) { return 0x820A477C;  }
		/* 820A4748h case    4:*/		return 0x820A474C;
		  /* 820A474Ch */ case    5:  		/* add. R10, R10, R11 */
		/* 820A474Ch case    5:*/		cpu::op::add<1>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820A474Ch case    5:*/		return 0x820A4750;
		  /* 820A4750h */ case    6:  		/* bc 12, CR0_LT, 44 */
		/* 820A4750h case    6:*/		if ( regs.CR[0].lt ) { return 0x820A477C;  }
		/* 820A4750h case    6:*/		return 0x820A4754;
		  /* 820A4754h */ case    7:  		/* cmpwi CR6, R10, 607 */
		/* 820A4754h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000025F);
		/* 820A4754h case    7:*/		return 0x820A4758;
		  /* 820A4758h */ case    8:  		/* bc 12, CR6_GT, 36 */
		/* 820A4758h case    8:*/		if ( regs.CR[6].gt ) { return 0x820A477C;  }
		/* 820A4758h case    8:*/		return 0x820A475C;
		  /* 820A475Ch */ case    9:  		/* addi R8, R27, 2060 */
		/* 820A475Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R27,0x80C);
		/* 820A475Ch case    9:*/		return 0x820A4760;
		  /* 820A4760h */ case   10:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 820A4760h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 820A4760h case   10:*/		return 0x820A4764;
		  /* 820A4764h */ case   11:  		/* lhax R8, <#[R10 + R8]> */
		/* 820A4764h case   11:*/		cpu::mem::load16a( regs, &regs.R8, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820A4764h case   11:*/		return 0x820A4768;
		  /* 820A4768h */ case   12:  		/* cmpw CR6, R8, R11 */
		/* 820A4768h case   12:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R11);
		/* 820A4768h case   12:*/		return 0x820A476C;
		  /* 820A476Ch */ case   13:  		/* bc 4, CR6_EQ, 16 */
		/* 820A476Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A477C;  }
		/* 820A476Ch case   13:*/		return 0x820A4770;
		  /* 820A4770h */ case   14:  		/* addi R11, R27, 844 */
		/* 820A4770h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x34C);
		/* 820A4770h case   14:*/		return 0x820A4774;
		  /* 820A4774h */ case   15:  		/* lhax R30, <#[R10 + R11]> */
		/* 820A4774h case   15:*/		cpu::mem::load16a( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820A4774h case   15:*/		return 0x820A4778;
		  /* 820A4778h */ case   16:  		/* b 8 */
		/* 820A4778h case   16:*/		return 0x820A4780;
		/* 820A4778h case   16:*/		return 0x820A477C;
	}
	return 0x820A477C;
} // Block from 820A4738h-820A477Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A477Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A477C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A477C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A477C);
		  /* 820A477Ch */ case    0:  		/* lhax R30, <#[R9 + R27]> */
		/* 820A477Ch case    0:*/		cpu::mem::load16a( regs, &regs.R30, (uint32)(regs.R9 + regs.R27 + 0x00000000) );
		/* 820A477Ch case    0:*/		return 0x820A4780;
	}
	return 0x820A4780;
} // Block from 820A477Ch-820A4780h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A4780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4780);
		  /* 820A4780h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 820A4780h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A4780h case    0:*/		return 0x820A4784;
		  /* 820A4784h */ case    1:  		/* addi R10, R31, 1030 */
		/* 820A4784h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x406);
		/* 820A4784h case    1:*/		return 0x820A4788;
		  /* 820A4788h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820A4788h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A4788h case    2:*/		return 0x820A478C;
		  /* 820A478Ch */ case    3:  		/* bc 4, CR6_LT, 252 */
		/* 820A478Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x820A4888;  }
		/* 820A478Ch case    3:*/		return 0x820A4790;
		  /* 820A4790h */ case    4:  		/* addi R11, R11, 2 */
		/* 820A4790h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A4790h case    4:*/		return 0x820A4794;
		  /* 820A4794h */ case    5:  		/* stw R11, <#[R31 + 16]> */
		/* 820A4794h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A4794h case    5:*/		return 0x820A4798;
		  /* 820A4798h */ case    6:  		/* sth R30, <#[R11]> */
		/* 820A4798h case    6:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820A4798h case    6:*/		return 0x820A479C;
		  /* 820A479Ch */ case    7:  		/* lwz R10, <#[R31 + 24]> */
		/* 820A479Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820A479Ch case    7:*/		return 0x820A47A0;
		  /* 820A47A0h */ case    8:  		/* lwz R11, <#[R31 + 20]> */
		/* 820A47A0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820A47A0h case    8:*/		return 0x820A47A4;
		  /* 820A47A4h */ case    9:  		/* addi R11, R11, 4 */
		/* 820A47A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820A47A4h case    9:*/		return 0x820A47A8;
		  /* 820A47A8h */ case   10:  		/* stw R11, <#[R31 + 20]> */
		/* 820A47A8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820A47A8h case   10:*/		return 0x820A47AC;
		  /* 820A47ACh */ case   11:  		/* stw R10, <#[R11]> */
		/* 820A47ACh case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A47ACh case   11:*/		return 0x820A47B0;
		  /* 820A47B0h */ case   12:  		/* b -1244 */
		/* 820A47B0h case   12:*/		return 0x820A42D4;
		/* 820A47B0h case   12:*/		return 0x820A47B4;
	}
	return 0x820A47B4;
} // Block from 820A4780h-820A47B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A47B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A47B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A47B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A47B4);
		  /* 820A47B4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820A47B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820A47B4h case    0:*/		return 0x820A47B8;
		  /* 820A47B8h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A47B8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A47B8h case    1:*/		return 0x820A47BC;
		  /* 820A47BCh */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 820A47BCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A47D8;  }
		/* 820A47BCh case    2:*/		return 0x820A47C0;
		  /* 820A47C0h */ case    3:  		/* mr R4, R23 */
		/* 820A47C0h case    3:*/		regs.R4 = regs.R23;
		/* 820A47C0h case    3:*/		return 0x820A47C4;
		  /* 820A47C4h */ case    4:  		/* mr R3, R31 */
		/* 820A47C4h case    4:*/		regs.R3 = regs.R31;
		/* 820A47C4h case    4:*/		return 0x820A47C8;
		  /* 820A47C8h */ case    5:  		/* bl -5064 */
		/* 820A47C8h case    5:*/		regs.LR = 0x820A47CC; return 0x820A3400;
		/* 820A47C8h case    5:*/		return 0x820A47CC;
		  /* 820A47CCh */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 820A47CCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820A47CCh case    6:*/		return 0x820A47D0;
		  /* 820A47D0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A47D0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A47D0h case    7:*/		return 0x820A47D4;
		  /* 820A47D4h */ case    8:  		/* stw R11, <#[R31 + 4]> */
		/* 820A47D4h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820A47D4h case    8:*/		return 0x820A47D8;
	}
	return 0x820A47D8;
} // Block from 820A47B4h-820A47D8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A47D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A47D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A47D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A47D8);
		  /* 820A47D8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820A47D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820A47D8h case    0:*/		return 0x820A47DC;
		  /* 820A47DCh */ case    1:  		/* cmpwi CR6, R11, 3 */
		/* 820A47DCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820A47DCh case    1:*/		return 0x820A47E0;
		  /* 820A47E0h */ case    2:  		/* bc 4, CR6_LT, 148 */
		/* 820A47E0h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820A4874;  }
		/* 820A47E0h case    2:*/		return 0x820A47E4;
		  /* 820A47E4h */ case    3:  		/* li R11, 3 */
		/* 820A47E4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820A47E4h case    3:*/		return 0x820A47E8;
		  /* 820A47E8h */ case    4:  		/* stw R11, <#[R31 + 8]> */
		/* 820A47E8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820A47E8h case    4:*/		return 0x820A47EC;
		  /* 820A47ECh */ case    5:  		/* lwz R11, <#[R31 + 16]> */
		/* 820A47ECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A47ECh case    5:*/		return 0x820A47F0;
		  /* 820A47F0h */ case    6:  		/* addi R10, R27, 444 */
		/* 820A47F0h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x1BC);
		/* 820A47F0h case    6:*/		return 0x820A47F4;
		  /* 820A47F4h */ case    7:  		/* lha R9, <#[R11]> */
		/* 820A47F4h case    7:*/		cpu::mem::load16a( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A47F4h case    7:*/		return 0x820A47F8;
		  /* 820A47F8h */ case    8:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 820A47F8h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 820A47F8h case    8:*/		return 0x820A47FC;
		  /* 820A47FCh */ case    9:  		/* lhax R10, <#[R9 + R10]> */
		/* 820A47FCh case    9:*/		cpu::mem::load16a( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820A47FCh case    9:*/		return 0x820A4800;
		  /* 820A4800h */ case   10:  		/* cmpwi CR0, R10, 0 */
		/* 820A4800h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 820A4800h case   10:*/		return 0x820A4804;
		  /* 820A4804h */ case   11:  		/* bc 12, CR0_EQ, 40 */
		/* 820A4804h case   11:*/		if ( regs.CR[0].eq ) { return 0x820A482C;  }
		/* 820A4804h case   11:*/		return 0x820A4808;
		  /* 820A4808h */ case   12:  		/* addic. R10, R10, 256 */
		/* 820A4808h case   12:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0x100);
		/* 820A4808h case   12:*/		return 0x820A480C;
		  /* 820A480Ch */ case   13:  		/* bc 12, CR0_LT, 32 */
		/* 820A480Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x820A482C;  }
		/* 820A480Ch case   13:*/		return 0x820A4810;
		  /* 820A4810h */ case   14:  		/* cmpwi CR6, R10, 607 */
		/* 820A4810h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000025F);
		/* 820A4810h case   14:*/		return 0x820A4814;
		  /* 820A4814h */ case   15:  		/* bc 12, CR6_GT, 24 */
		/* 820A4814h case   15:*/		if ( regs.CR[6].gt ) { return 0x820A482C;  }
		/* 820A4814h case   15:*/		return 0x820A4818;
		  /* 820A4818h */ case   16:  		/* addi R9, R27, 2060 */
		/* 820A4818h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x80C);
		/* 820A4818h case   16:*/		return 0x820A481C;
		  /* 820A481Ch */ case   17:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 820A481Ch case   17:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 820A481Ch case   17:*/		return 0x820A4820;
		  /* 820A4820h */ case   18:  		/* lhzx R9, <#[R10 + R9]> */
		/* 820A4820h case   18:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820A4820h case   18:*/		return 0x820A4824;
		  /* 820A4824h */ case   19:  		/* cmplwi CR6, R9, 256 */
		/* 820A4824h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000100);
		/* 820A4824h case   19:*/		return 0x820A4828;
		  /* 820A4828h */ case   20:  		/* bc 12, CR6_EQ, 36 */
		/* 820A4828h case   20:*/		if ( regs.CR[6].eq ) { return 0x820A484C;  }
		/* 820A4828h case   20:*/		return 0x820A482C;
	}
	return 0x820A482C;
} // Block from 820A47D8h-820A482Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820A482Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A482C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A482C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A482C);
		  /* 820A482Ch */ case    0:  		/* cmplw CR6, R11, R24 */
		/* 820A482Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 820A482Ch case    0:*/		return 0x820A4830;
		  /* 820A4830h */ case    1:  		/* bc 4, CR6_GT, 104 */
		/* 820A4830h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820A4898;  }
		/* 820A4830h case    1:*/		return 0x820A4834;
		  /* 820A4834h */ case    2:  		/* lwz R10, <#[R31 + 20]> */
		/* 820A4834h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820A4834h case    2:*/		return 0x820A4838;
		  /* 820A4838h */ case    3:  		/* addi R11, R11, -2 */
		/* 820A4838h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 820A4838h case    3:*/		return 0x820A483C;
		  /* 820A483Ch */ case    4:  		/* addi R10, R10, -4 */
		/* 820A483Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 820A483Ch case    4:*/		return 0x820A4840;
		  /* 820A4840h */ case    5:  		/* stw R11, <#[R31 + 16]> */
		/* 820A4840h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A4840h case    5:*/		return 0x820A4844;
		  /* 820A4844h */ case    6:  		/* stw R10, <#[R31 + 20]> */
		/* 820A4844h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820A4844h case    6:*/		return 0x820A4848;
		  /* 820A4848h */ case    7:  		/* b -92 */
		/* 820A4848h case    7:*/		return 0x820A47EC;
		/* 820A4848h case    7:*/		return 0x820A484C;
	}
	return 0x820A484C;
} // Block from 820A482Ch-820A484Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A484Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A484C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A484C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A484C);
		  /* 820A484Ch */ case    0:  		/* addi R9, R31, 1030 */
		/* 820A484Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x406);
		/* 820A484Ch case    0:*/		return 0x820A4850;
		  /* 820A4850h */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 820A4850h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820A4850h case    1:*/		return 0x820A4854;
		  /* 820A4854h */ case    2:  		/* bc 4, CR6_LT, 52 */
		/* 820A4854h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820A4888;  }
		/* 820A4854h case    2:*/		return 0x820A4858;
		  /* 820A4858h */ case    3:  		/* addi R9, R27, 844 */
		/* 820A4858h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x34C);
		/* 820A4858h case    3:*/		return 0x820A485C;
		  /* 820A485Ch */ case    4:  		/* addi R11, R11, 2 */
		/* 820A485Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A485Ch case    4:*/		return 0x820A4860;
		  /* 820A4860h */ case    5:  		/* lhax R30, <#[R10 + R9]> */
		/* 820A4860h case    5:*/		cpu::mem::load16a( regs, &regs.R30, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820A4860h case    5:*/		return 0x820A4864;
		  /* 820A4864h */ case    6:  		/* stw R11, <#[R31 + 16]> */
		/* 820A4864h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A4864h case    6:*/		return 0x820A4868;
		  /* 820A4868h */ case    7:  		/* sth R30, <#[R11]> */
		/* 820A4868h case    7:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820A4868h case    7:*/		return 0x820A486C;
		  /* 820A486Ch */ case    8:  		/* lwz R10, <#[R31 + 28]> */
		/* 820A486Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 820A486Ch case    8:*/		return 0x820A4870;
		  /* 820A4870h */ case    9:  		/* b -208 */
		/* 820A4870h case    9:*/		return 0x820A47A0;
		/* 820A4870h case    9:*/		return 0x820A4874;
	}
	return 0x820A4874;
} // Block from 820A484Ch-820A4874h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A4874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4874);
		  /* 820A4874h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820A4874h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A4874h case    0:*/		return 0x820A4878;
		  /* 820A4878h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A4878h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4878h case    1:*/		return 0x820A487C;
		  /* 820A487Ch */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 820A487Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820A4898;  }
		/* 820A487Ch case    2:*/		return 0x820A4880;
		  /* 820A4880h */ case    3:  		/* stw R26, <#[R31 + 12]> */
		/* 820A4880h case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A4880h case    3:*/		return 0x820A4884;
		  /* 820A4884h */ case    4:  		/* b -1456 */
		/* 820A4884h case    4:*/		return 0x820A42D4;
		/* 820A4884h case    4:*/		return 0x820A4888;
	}
	return 0x820A4888;
} // Block from 820A4874h-820A4888h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A4888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4888);
		  /* 820A4888h */ case    0:  		/* lis R11, -32255 */
		/* 820A4888h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A4888h case    0:*/		return 0x820A488C;
		  /* 820A488Ch */ case    1:  		/* mr R3, R31 */
		/* 820A488Ch case    1:*/		regs.R3 = regs.R31;
		/* 820A488Ch case    1:*/		return 0x820A4890;
		  /* 820A4890h */ case    2:  		/* addi R4, R11, -9924 */
		/* 820A4890h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFD93C);
		/* 820A4890h case    2:*/		return 0x820A4894;
		  /* 820A4894h */ case    3:  		/* bl -5268 */
		/* 820A4894h case    3:*/		regs.LR = 0x820A4898; return 0x820A3400;
		/* 820A4894h case    3:*/		return 0x820A4898;
	}
	return 0x820A4898;
} // Block from 820A4888h-820A4898h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A4898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4898);
		  /* 820A4898h */ case    0:  		/* li R3, 1 */
		/* 820A4898h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820A4898h case    0:*/		return 0x820A489C;
	}
	return 0x820A489C;
} // Block from 820A4898h-820A489Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A489Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A489C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A489C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A489C);
		  /* 820A489Ch */ case    0:  		/* addi R1, R1, 192 */
		/* 820A489Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820A489Ch case    0:*/		return 0x820A48A0;
		  /* 820A48A0h */ case    1:  		/* b -79372 */
		/* 820A48A0h case    1:*/		return 0x82091294;
		/* 820A48A0h case    1:*/		return 0x820A48A4;
		  /* 820A48A4h */ case    2:  		/* nop */
		/* 820A48A4h case    2:*/		cpu::op::nop();
		/* 820A48A4h case    2:*/		return 0x820A48A8;
	}
	return 0x820A48A8;
} // Block from 820A489Ch-820A48A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A48A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A48A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A48A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A48A8);
		  /* 820A48A8h */ case    0:  		/* mfspr R12, LR */
		/* 820A48A8h case    0:*/		regs.R12 = regs.LR;
		/* 820A48A8h case    0:*/		return 0x820A48AC;
		  /* 820A48ACh */ case    1:  		/* bl -79468 */
		/* 820A48ACh case    1:*/		regs.LR = 0x820A48B0; return 0x82091240;
		/* 820A48ACh case    1:*/		return 0x820A48B0;
		  /* 820A48B0h */ case    2:  		/* stwu R1, <#[R1 - 3232]> */
		/* 820A48B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF360) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF360);
		/* 820A48B0h case    2:*/		return 0x820A48B4;
		  /* 820A48B4h */ case    3:  		/* lwz R11, <#[R3 + 1644]> */
		/* 820A48B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000066C) );
		/* 820A48B4h case    3:*/		return 0x820A48B8;
		  /* 820A48B8h */ case    4:  		/* mr R31, R3 */
		/* 820A48B8h case    4:*/		regs.R31 = regs.R3;
		/* 820A48B8h case    4:*/		return 0x820A48BC;
		  /* 820A48BCh */ case    5:  		/* mr R30, R4 */
		/* 820A48BCh case    5:*/		regs.R30 = regs.R4;
		/* 820A48BCh case    5:*/		return 0x820A48C0;
		  /* 820A48C0h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 820A48C0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A48C0h case    6:*/		return 0x820A48C4;
		  /* 820A48C4h */ case    7:  		/* bc 4, CR6_EQ, 1060 */
		/* 820A48C4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820A4CE8;  }
		/* 820A48C4h case    7:*/		return 0x820A48C8;
		  /* 820A48C8h */ case    8:  		/* lis R11, -32256 */
		/* 820A48C8h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820A48C8h case    8:*/		return 0x820A48CC;
		  /* 820A48CCh */ case    9:  		/* lis R10, -32255 */
		/* 820A48CCh case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A48CCh case    9:*/		return 0x820A48D0;
		  /* 820A48D0h */ case   10:  		/* lis R9, -32255 */
		/* 820A48D0h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A48D0h case   10:*/		return 0x820A48D4;
		  /* 820A48D4h */ case   11:  		/* lis R8, -32255 */
		/* 820A48D4h case   11:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 820A48D4h case   11:*/		return 0x820A48D8;
		  /* 820A48D8h */ case   12:  		/* lis R7, -32255 */
		/* 820A48D8h case   12:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8201);
		/* 820A48D8h case   12:*/		return 0x820A48DC;
		  /* 820A48DCh */ case   13:  		/* li R28, 0 */
		/* 820A48DCh case   13:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820A48DCh case   13:*/		return 0x820A48E0;
		  /* 820A48E0h */ case   14:  		/* li R27, 1 */
		/* 820A48E0h case   14:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820A48E0h case   14:*/		return 0x820A48E4;
		  /* 820A48E4h */ case   15:  		/* addi R22, R11, 4485 */
		/* 820A48E4h case   15:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R11,0x1185);
		/* 820A48E4h case   15:*/		return 0x820A48E8;
		  /* 820A48E8h */ case   16:  		/* addi R25, R10, -10484 */
		/* 820A48E8h case   16:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R10,0xFFFFD70C);
		/* 820A48E8h case   16:*/		return 0x820A48EC;
		  /* 820A48ECh */ case   17:  		/* addi R26, R9, -9824 */
		/* 820A48ECh case   17:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R9,0xFFFFD9A0);
		/* 820A48ECh case   17:*/		return 0x820A48F0;
		  /* 820A48F0h */ case   18:  		/* addi R23, R8, -9876 */
		/* 820A48F0h case   18:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R8,0xFFFFD96C);
		/* 820A48F0h case   18:*/		return 0x820A48F4;
		  /* 820A48F4h */ case   19:  		/* addi R24, R7, -9880 */
		/* 820A48F4h case   19:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R7,0xFFFFD968);
		/* 820A48F4h case   19:*/		return 0x820A48F8;
		  /* 820A48F8h */ case   20:  		/* lwz R11, <#[R31 + 1680]> */
		/* 820A48F8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000690) );
		/* 820A48F8h case   20:*/		return 0x820A48FC;
		  /* 820A48FCh */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 820A48FCh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A48FCh case   21:*/		return 0x820A4900;
		  /* 820A4900h */ case   22:  		/* bc 12, CR6_EQ, 16 */
		/* 820A4900h case   22:*/		if ( regs.CR[6].eq ) { return 0x820A4910;  }
		/* 820A4900h case   22:*/		return 0x820A4904;
		  /* 820A4904h */ case   23:  		/* lwz R11, <#[R11 + 8]> */
		/* 820A4904h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820A4904h case   23:*/		return 0x820A4908;
		  /* 820A4908h */ case   24:  		/* cmplwi CR6, R11, 0 */
		/* 820A4908h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A4908h case   24:*/		return 0x820A490C;
		  /* 820A490Ch */ case   25:  		/* bc 12, CR6_EQ, 1056 */
		/* 820A490Ch case   25:*/		if ( regs.CR[6].eq ) { return 0x820A4D2C;  }
		/* 820A490Ch case   25:*/		return 0x820A4910;
	}
	return 0x820A4910;
} // Block from 820A48A8h-820A4910h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820A4910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4910);
		  /* 820A4910h */ case    0:  		/* lwz R10, <#[R31 + 1672]> */
		/* 820A4910h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000688) );
		/* 820A4910h case    0:*/		return 0x820A4914;
		  /* 820A4914h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820A4914h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A4914h case    1:*/		return 0x820A4918;
		  /* 820A4918h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 820A4918h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A494C;  }
		/* 820A4918h case    2:*/		return 0x820A491C;
		  /* 820A491Ch */ case    3:  		/* li R11, 5 */
		/* 820A491Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820A491Ch case    3:*/		return 0x820A4920;
		  /* 820A4920h */ case    4:  		/* addi R9, R10, 8 */
		/* 820A4920h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x8);
		/* 820A4920h case    4:*/		return 0x820A4924;
		  /* 820A4924h */ case    5:  		/* addi R8, R30, -8 */
		/* 820A4924h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0xFFFFFFF8);
		/* 820A4924h case    5:*/		return 0x820A4928;
		  /* 820A4928h */ case    6:  		/* mtspr CTR, R11 */
		/* 820A4928h case    6:*/		regs.CTR = regs.R11;
		/* 820A4928h case    6:*/		return 0x820A492C;
		  /* 820A492Ch */ case    7:  		/* ldu R11, <#[R9 + 8]> */
		/* 820A492Ch case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820A492Ch case    7:*/		return 0x820A4930;
		  /* 820A4930h */ case    8:  		/* stdu R11, <#[R8 + 8]> */
		/* 820A4930h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R8 + 0x00000008) );
		regs.R8 = (uint32)(regs.R8 + 0x00000008);
		/* 820A4930h case    8:*/		return 0x820A4934;
		  /* 820A4934h */ case    9:  		/* bc 16, CR0_LT, -8 */
		/* 820A4934h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A492C;  }
		/* 820A4934h case    9:*/		return 0x820A4938;
		  /* 820A4938h */ case   10:  		/* lwz R11, <#[R31 + 1672]> */
		/* 820A4938h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000688) );
		/* 820A4938h case   10:*/		return 0x820A493C;
		  /* 820A493Ch */ case   11:  		/* lwz R11, <#[R11 + 12]> */
		/* 820A493Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A493Ch case   11:*/		return 0x820A4940;
		  /* 820A4940h */ case   12:  		/* stw R11, <#[R31 + 1672]> */
		/* 820A4940h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000688) );
		/* 820A4940h case   12:*/		return 0x820A4944;
		  /* 820A4944h */ case   13:  		/* stw R28, <#[R10 + 12]> */
		/* 820A4944h case   13:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R10 + 0x0000000C) );
		/* 820A4944h case   13:*/		return 0x820A4948;
		  /* 820A4948h */ case   14:  		/* b 108 */
		/* 820A4948h case   14:*/		return 0x820A49B4;
		/* 820A4948h case   14:*/		return 0x820A494C;
	}
	return 0x820A494C;
} // Block from 820A4910h-820A494Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A494Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A494C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A494C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A494C);
		  /* 820A494Ch */ case    0:  		/* lwz R10, <#[R31 + 1668]> */
		/* 820A494Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000684) );
		/* 820A494Ch case    0:*/		return 0x820A4950;
		  /* 820A4950h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820A4950h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A4950h case    1:*/		return 0x820A4954;
		  /* 820A4954h */ case    2:  		/* bc 12, CR6_EQ, 104 */
		/* 820A4954h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A49BC;  }
		/* 820A4954h case    2:*/		return 0x820A4958;
		  /* 820A4958h */ case    3:  		/* li R11, 5 */
		/* 820A4958h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820A4958h case    3:*/		return 0x820A495C;
		  /* 820A495Ch */ case    4:  		/* addi R9, R10, 8 */
		/* 820A495Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x8);
		/* 820A495Ch case    4:*/		return 0x820A4960;
		  /* 820A4960h */ case    5:  		/* addi R8, R30, -8 */
		/* 820A4960h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0xFFFFFFF8);
		/* 820A4960h case    5:*/		return 0x820A4964;
		  /* 820A4964h */ case    6:  		/* mtspr CTR, R11 */
		/* 820A4964h case    6:*/		regs.CTR = regs.R11;
		/* 820A4964h case    6:*/		return 0x820A4968;
		  /* 820A4968h */ case    7:  		/* ldu R11, <#[R9 + 8]> */
		/* 820A4968h case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820A4968h case    7:*/		return 0x820A496C;
		  /* 820A496Ch */ case    8:  		/* stdu R11, <#[R8 + 8]> */
		/* 820A496Ch case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R8 + 0x00000008) );
		regs.R8 = (uint32)(regs.R8 + 0x00000008);
		/* 820A496Ch case    8:*/		return 0x820A4970;
		  /* 820A4970h */ case    9:  		/* bc 16, CR0_LT, -8 */
		/* 820A4970h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A4968;  }
		/* 820A4970h case    9:*/		return 0x820A4974;
		  /* 820A4974h */ case   10:  		/* lwz R11, <#[R31 + 1668]> */
		/* 820A4974h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000684) );
		/* 820A4974h case   10:*/		return 0x820A4978;
		  /* 820A4978h */ case   11:  		/* lwz R11, <#[R11 + 12]> */
		/* 820A4978h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A4978h case   11:*/		return 0x820A497C;
		  /* 820A497Ch */ case   12:  		/* stw R11, <#[R31 + 1668]> */
		/* 820A497Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000684) );
		/* 820A497Ch case   12:*/		return 0x820A4980;
		  /* 820A4980h */ case   13:  		/* stw R28, <#[R10 + 12]> */
		/* 820A4980h case   13:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R10 + 0x0000000C) );
		/* 820A4980h case   13:*/		return 0x820A4984;
		  /* 820A4984h */ case   14:  		/* lwz R11, <#[R31 + 2204]> */
		/* 820A4984h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4984h case   14:*/		return 0x820A4988;
		  /* 820A4988h */ case   15:  		/* lwz R11, <#[R11 + 36]> */
		/* 820A4988h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 820A4988h case   15:*/		return 0x820A498C;
		  /* 820A498Ch */ case   16:  		/* stw R11, <#[R30 + 20]> */
		/* 820A498Ch case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820A498Ch case   16:*/		return 0x820A4990;
		  /* 820A4990h */ case   17:  		/* lwz R11, <#[R31 + 2204]> */
		/* 820A4990h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4990h case   17:*/		return 0x820A4994;
		  /* 820A4994h */ case   18:  		/* lwz R11, <#[R11 + 32]> */
		/* 820A4994h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 820A4994h case   18:*/		return 0x820A4998;
		  /* 820A4998h */ case   19:  		/* stw R11, <#[R30 + 16]> */
		/* 820A4998h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820A4998h case   19:*/		return 0x820A499C;
		  /* 820A499Ch */ case   20:  		/* lwz R11, <#[R31 + 2204]> */
		/* 820A499Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A499Ch case   20:*/		return 0x820A49A0;
		  /* 820A49A0h */ case   21:  		/* lwz R11, <#[R11 + 40]> */
		/* 820A49A0h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 820A49A0h case   21:*/		return 0x820A49A4;
		  /* 820A49A4h */ case   22:  		/* stw R11, <#[R30 + 24]> */
		/* 820A49A4h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820A49A4h case   22:*/		return 0x820A49A8;
		  /* 820A49A8h */ case   23:  		/* lwz R11, <#[R31 + 2204]> */
		/* 820A49A8h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A49A8h case   23:*/		return 0x820A49AC;
		  /* 820A49ACh */ case   24:  		/* lwz R11, <#[R11 + 44]> */
		/* 820A49ACh case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 820A49ACh case   24:*/		return 0x820A49B0;
		  /* 820A49B0h */ case   25:  		/* stw R11, <#[R30 + 28]> */
		/* 820A49B0h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820A49B0h case   25:*/		return 0x820A49B4;
	}
	return 0x820A49B4;
} // Block from 820A494Ch-820A49B4h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820A49B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A49B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A49B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A49B4);
		  /* 820A49B4h */ case    0:  		/* stw R28, <#[R31 + 1636]> */
		/* 820A49B4h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000664) );
		/* 820A49B4h case    0:*/		return 0x820A49B8;
		  /* 820A49B8h */ case    1:  		/* b 28 */
		/* 820A49B8h case    1:*/		return 0x820A49D4;
		/* 820A49B8h case    1:*/		return 0x820A49BC;
	}
	return 0x820A49BC;
} // Block from 820A49B4h-820A49BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A49BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A49BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A49BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A49BC);
		  /* 820A49BCh */ case    0:  		/* mr R5, R30 */
		/* 820A49BCh case    0:*/		regs.R5 = regs.R30;
		/* 820A49BCh case    0:*/		return 0x820A49C0;
		  /* 820A49C0h */ case    1:  		/* lwz R4, <#[R31 + 2256]> */
		/* 820A49C0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000008D0) );
		/* 820A49C0h case    1:*/		return 0x820A49C4;
		  /* 820A49C4h */ case    2:  		/* lwz R3, <#[R31 + 2204]> */
		/* 820A49C4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A49C4h case    2:*/		return 0x820A49C8;
		  /* 820A49C8h */ case    3:  		/* bl 14384 */
		/* 820A49C8h case    3:*/		regs.LR = 0x820A49CC; return 0x820A81F8;
		/* 820A49C8h case    3:*/		return 0x820A49CC;
		  /* 820A49CCh */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820A49CCh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A49CCh case    4:*/		return 0x820A49D0;
		  /* 820A49D0h */ case    5:  		/* bc 12, CR0_LT, 1100 */
		/* 820A49D0h case    5:*/		if ( regs.CR[0].lt ) { return 0x820A4E1C;  }
		/* 820A49D0h case    5:*/		return 0x820A49D4;
	}
	return 0x820A49D4;
} // Block from 820A49BCh-820A49D4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A49D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A49D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A49D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A49D4);
		  /* 820A49D4h */ case    0:  		/* lwz R8, <#[R30]> */
		/* 820A49D4h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 820A49D4h case    0:*/		return 0x820A49D8;
		  /* 820A49D8h */ case    1:  		/* cmpwi CR6, R8, 1 */
		/* 820A49D8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820A49D8h case    1:*/		return 0x820A49DC;
		  /* 820A49DCh */ case    2:  		/* bc 4, CR6_EQ, 408 */
		/* 820A49DCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A4B74;  }
		/* 820A49DCh case    2:*/		return 0x820A49E0;
		  /* 820A49E0h */ case    3:  		/* mr R11, R24 */
		/* 820A49E0h case    3:*/		regs.R11 = regs.R24;
		/* 820A49E0h case    3:*/		return 0x820A49E4;
		  /* 820A49E4h */ case    4:  		/* addi R10, R30, 8 */
		/* 820A49E4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x8);
		/* 820A49E4h case    4:*/		return 0x820A49E8;
		  /* 820A49E8h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820A49E8h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A49E8h case    5:*/		return 0x820A49EC;
		  /* 820A49ECh */ case    6:  		/* lbz R7, <#[R10]> */
		/* 820A49ECh case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A49ECh case    6:*/		return 0x820A49F0;
		  /* 820A49F0h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820A49F0h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A49F0h case    7:*/		return 0x820A49F4;
		  /* 820A49F4h */ case    8:  		/* subf R9, R7, R9 */
		/* 820A49F4h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A49F4h case    8:*/		return 0x820A49F8;
		  /* 820A49F8h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820A49F8h case    9:*/		if ( regs.CR[0].eq ) { return 0x820A4A0C;  }
		/* 820A49F8h case    9:*/		return 0x820A49FC;
		  /* 820A49FCh */ case   10:  		/* addi R11, R11, 1 */
		/* 820A49FCh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A49FCh case   10:*/		return 0x820A4A00;
		  /* 820A4A00h */ case   11:  		/* addi R10, R10, 1 */
		/* 820A4A00h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A4A00h case   11:*/		return 0x820A4A04;
		  /* 820A4A04h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820A4A04h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A4A04h case   12:*/		return 0x820A4A08;
		  /* 820A4A08h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820A4A08h case   13:*/		if ( regs.CR[6].eq ) { return 0x820A49E8;  }
		/* 820A4A08h case   13:*/		return 0x820A4A0C;
	}
	return 0x820A4A0C;
} // Block from 820A49D4h-820A4A0Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A4A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4A0C);
		  /* 820A4A0Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A4A0Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A4A0Ch case    0:*/		return 0x820A4A10;
		  /* 820A4A10h */ case    1:  		/* bc 4, CR0_EQ, 356 */
		/* 820A4A10h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A4B74;  }
		/* 820A4A10h case    1:*/		return 0x820A4A14;
		  /* 820A4A14h */ case    2:  		/* lwz R11, <#[R31 + 1636]> */
		/* 820A4A14h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000664) );
		/* 820A4A14h case    2:*/		return 0x820A4A18;
		  /* 820A4A18h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820A4A18h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4A18h case    3:*/		return 0x820A4A1C;
		  /* 820A4A1Ch */ case    4:  		/* bc 12, CR6_EQ, 344 */
		/* 820A4A1Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820A4B74;  }
		/* 820A4A1Ch case    4:*/		return 0x820A4A20;
		  /* 820A4A20h */ case    5:  		/* lwz R11, <#[R31 + 1652]> */
		/* 820A4A20h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000674) );
		/* 820A4A20h case    5:*/		return 0x820A4A24;
		  /* 820A4A24h */ case    6:  		/* li R5, 3036 */
		/* 820A4A24h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0xBDC);
		/* 820A4A24h case    6:*/		return 0x820A4A28;
		  /* 820A4A28h */ case    7:  		/* li R4, 0 */
		/* 820A4A28h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A4A28h case    7:*/		return 0x820A4A2C;
		  /* 820A4A2Ch */ case    8:  		/* stw R28, <#[R31 + 1636]> */
		/* 820A4A2Ch case    8:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000664) );
		/* 820A4A2Ch case    8:*/		return 0x820A4A30;
		  /* 820A4A30h */ case    9:  		/* addi R3, R1, 96 */
		/* 820A4A30h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820A4A30h case    9:*/		return 0x820A4A34;
		  /* 820A4A34h */ case   10:  		/* stw R28, <#[R31 + 1640]> */
		/* 820A4A34h case   10:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000668) );
		/* 820A4A34h case   10:*/		return 0x820A4A38;
		  /* 820A4A38h */ case   11:  		/* stw R27, <#[R31 + 1648]> */
		/* 820A4A38h case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000670) );
		/* 820A4A38h case   11:*/		return 0x820A4A3C;
		  /* 820A4A3Ch */ case   12:  		/* stw R11, <#[R31 + 1656]> */
		/* 820A4A3Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000678) );
		/* 820A4A3Ch case   12:*/		return 0x820A4A40;
		  /* 820A4A40h */ case   13:  		/* bl -79616 */
		/* 820A4A40h case   13:*/		regs.LR = 0x820A4A44; return 0x82091340;
		/* 820A4A40h case   13:*/		return 0x820A4A44;
		  /* 820A4A44h */ case   14:  		/* stw R31, <#[R1 + 3128]> */
		/* 820A4A44h case   14:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000C38) );
		/* 820A4A44h case   14:*/		return 0x820A4A48;
		  /* 820A4A48h */ case   15:  		/* addi R3, R1, 96 */
		/* 820A4A48h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820A4A48h case   15:*/		return 0x820A4A4C;
		  /* 820A4A4Ch */ case   16:  		/* bl -1988 */
		/* 820A4A4Ch case   16:*/		regs.LR = 0x820A4A50; return 0x820A4288;
		/* 820A4A4Ch case   16:*/		return 0x820A4A50;
		  /* 820A4A50h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820A4A50h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A4A50h case   17:*/		return 0x820A4A54;
		  /* 820A4A54h */ case   18:  		/* bc 12, CR0_EQ, 8 */
		/* 820A4A54h case   18:*/		if ( regs.CR[0].eq ) { return 0x820A4A5C;  }
		/* 820A4A54h case   18:*/		return 0x820A4A58;
		  /* 820A4A58h */ case   19:  		/* stw R27, <#[R31 + 1640]> */
		/* 820A4A58h case   19:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000668) );
		/* 820A4A58h case   19:*/		return 0x820A4A5C;
	}
	return 0x820A4A5C;
} // Block from 820A4A0Ch-820A4A5Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A4A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4A5C);
		  /* 820A4A5Ch */ case    0:  		/* lwz R11, <#[R31 + 1636]> */
		/* 820A4A5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000664) );
		/* 820A4A5Ch case    0:*/		return 0x820A4A60;
		  /* 820A4A60h */ case    1:  		/* stw R28, <#[R31 + 1664]> */
		/* 820A4A60h case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000680) );
		/* 820A4A60h case    1:*/		return 0x820A4A64;
		  /* 820A4A64h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 820A4A64h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4A64h case    2:*/		return 0x820A4A68;
		  /* 820A4A68h */ case    3:  		/* bc 4, CR6_EQ, 108 */
		/* 820A4A68h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A4AD4;  }
		/* 820A4A68h case    3:*/		return 0x820A4A6C;
		  /* 820A4A6Ch */ case    4:  		/* lwz R11, <#[R31 + 1640]> */
		/* 820A4A6Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000668) );
		/* 820A4A6Ch case    4:*/		return 0x820A4A70;
		  /* 820A4A70h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 820A4A70h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4A70h case    5:*/		return 0x820A4A74;
		  /* 820A4A74h */ case    6:  		/* bc 4, CR6_EQ, 96 */
		/* 820A4A74h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A4AD4;  }
		/* 820A4A74h case    6:*/		return 0x820A4A78;
		  /* 820A4A78h */ case    7:  		/* addi R29, R31, 2216 */
		/* 820A4A78h case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x8A8);
		/* 820A4A78h case    7:*/		return 0x820A4A7C;
		  /* 820A4A7Ch */ case    8:  		/* lwz R4, <#[R31 + 2256]> */
		/* 820A4A7Ch case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000008D0) );
		/* 820A4A7Ch case    8:*/		return 0x820A4A80;
		  /* 820A4A80h */ case    9:  		/* lwz R3, <#[R31 + 2204]> */
		/* 820A4A80h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4A80h case    9:*/		return 0x820A4A84;
		  /* 820A4A84h */ case   10:  		/* mr R5, R29 */
		/* 820A4A84h case   10:*/		regs.R5 = regs.R29;
		/* 820A4A84h case   10:*/		return 0x820A4A88;
		  /* 820A4A88h */ case   11:  		/* bl 14192 */
		/* 820A4A88h case   11:*/		regs.LR = 0x820A4A8C; return 0x820A81F8;
		/* 820A4A88h case   11:*/		return 0x820A4A8C;
		  /* 820A4A8Ch */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820A4A8Ch case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A4A8Ch case   12:*/		return 0x820A4A90;
		  /* 820A4A90h */ case   13:  		/* bc 12, CR0_LT, 908 */
		/* 820A4A90h case   13:*/		if ( regs.CR[0].lt ) { return 0x820A4E1C;  }
		/* 820A4A90h case   13:*/		return 0x820A4A94;
		  /* 820A4A94h */ case   14:  		/* lwz R11, <#[R29]> */
		/* 820A4A94h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820A4A94h case   14:*/		return 0x820A4A98;
		  /* 820A4A98h */ case   15:  		/* cmpwi CR6, R11, 16 */
		/* 820A4A98h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820A4A98h case   15:*/		return 0x820A4A9C;
		  /* 820A4A9Ch */ case   16:  		/* bc 12, CR6_EQ, 52 */
		/* 820A4A9Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x820A4AD0;  }
		/* 820A4A9Ch case   16:*/		return 0x820A4AA0;
		  /* 820A4AA0h */ case   17:  		/* cmpwi CR6, R11, 17 */
		/* 820A4AA0h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820A4AA0h case   17:*/		return 0x820A4AA4;
		  /* 820A4AA4h */ case   18:  		/* bc 12, CR6_EQ, 44 */
		/* 820A4AA4h case   18:*/		if ( regs.CR[6].eq ) { return 0x820A4AD0;  }
		/* 820A4AA4h case   18:*/		return 0x820A4AA8;
		  /* 820A4AA8h */ case   19:  		/* lwz R11, <#[R31 + 1652]> */
		/* 820A4AA8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000674) );
		/* 820A4AA8h case   19:*/		return 0x820A4AAC;
		  /* 820A4AACh */ case   20:  		/* cmpwi CR6, R11, 0 */
		/* 820A4AACh case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4AACh case   20:*/		return 0x820A4AB0;
		  /* 820A4AB0h */ case   21:  		/* bc 12, CR6_EQ, 24 */
		/* 820A4AB0h case   21:*/		if ( regs.CR[6].eq ) { return 0x820A4AC8;  }
		/* 820A4AB0h case   21:*/		return 0x820A4AB4;
		  /* 820A4AB4h */ case   22:  		/* mr R6, R23 */
		/* 820A4AB4h case   22:*/		regs.R6 = regs.R23;
		/* 820A4AB4h case   22:*/		return 0x820A4AB8;
		  /* 820A4AB8h */ case   23:  		/* li R5, 1501 */
		/* 820A4AB8h case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x5DD);
		/* 820A4AB8h case   23:*/		return 0x820A4ABC;
		  /* 820A4ABCh */ case   24:  		/* mr R4, R30 */
		/* 820A4ABCh case   24:*/		regs.R4 = regs.R30;
		/* 820A4ABCh case   24:*/		return 0x820A4AC0;
		  /* 820A4AC0h */ case   25:  		/* addi R3, R31, 24 */
		/* 820A4AC0h case   25:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A4AC0h case   25:*/		return 0x820A4AC4;
		  /* 820A4AC4h */ case   26:  		/* bl 9932 */
		/* 820A4AC4h case   26:*/		regs.LR = 0x820A4AC8; return 0x820A7190;
		/* 820A4AC4h case   26:*/		return 0x820A4AC8;
	}
	return 0x820A4AC8;
} // Block from 820A4A5Ch-820A4AC8h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820A4AC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4AC8);
		  /* 820A4AC8h */ case    0:  		/* stw R27, <#[R31 + 1640]> */
		/* 820A4AC8h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000668) );
		/* 820A4AC8h case    0:*/		return 0x820A4ACC;
		  /* 820A4ACCh */ case    1:  		/* b 8 */
		/* 820A4ACCh case    1:*/		return 0x820A4AD4;
		/* 820A4ACCh case    1:*/		return 0x820A4AD0;
	}
	return 0x820A4AD0;
} // Block from 820A4AC8h-820A4AD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A4AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4AD0);
		  /* 820A4AD0h */ case    0:  		/* stw R27, <#[R31 + 1636]> */
		/* 820A4AD0h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000664) );
		/* 820A4AD0h case    0:*/		return 0x820A4AD4;
	}
	return 0x820A4AD4;
} // Block from 820A4AD0h-820A4AD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A4AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4AD4);
		  /* 820A4AD4h */ case    0:  		/* lwz R11, <#[R31 + 1636]> */
		/* 820A4AD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000664) );
		/* 820A4AD4h case    0:*/		return 0x820A4AD8;
		  /* 820A4AD8h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A4AD8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4AD8h case    1:*/		return 0x820A4ADC;
		  /* 820A4ADCh */ case    2:  		/* bc 4, CR6_EQ, 48 */
		/* 820A4ADCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A4B0C;  }
		/* 820A4ADCh case    2:*/		return 0x820A4AE0;
		  /* 820A4AE0h */ case    3:  		/* li R4, 0 */
		/* 820A4AE0h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A4AE0h case    3:*/		return 0x820A4AE4;
		  /* 820A4AE4h */ case    4:  		/* lwz R3, <#[R31 + 2204]> */
		/* 820A4AE4h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4AE4h case    4:*/		return 0x820A4AE8;
		  /* 820A4AE8h */ case    5:  		/* bl 10872 */
		/* 820A4AE8h case    5:*/		regs.LR = 0x820A4AEC; return 0x820A7560;
		/* 820A4AE8h case    5:*/		return 0x820A4AEC;
		  /* 820A4AECh */ case    6:  		/* stw R28, <#[R31 + 1668]> */
		/* 820A4AECh case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000684) );
		/* 820A4AECh case    6:*/		return 0x820A4AF0;
		  /* 820A4AF0h */ case    7:  		/* addi R5, R31, 2216 */
		/* 820A4AF0h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x8A8);
		/* 820A4AF0h case    7:*/		return 0x820A4AF4;
		  /* 820A4AF4h */ case    8:  		/* lwz R4, <#[R31 + 2256]> */
		/* 820A4AF4h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000008D0) );
		/* 820A4AF4h case    8:*/		return 0x820A4AF8;
		  /* 820A4AF8h */ case    9:  		/* lwz R3, <#[R31 + 2204]> */
		/* 820A4AF8h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4AF8h case    9:*/		return 0x820A4AFC;
		  /* 820A4AFCh */ case   10:  		/* bl 14076 */
		/* 820A4AFCh case   10:*/		regs.LR = 0x820A4B00; return 0x820A81F8;
		/* 820A4AFCh case   10:*/		return 0x820A4B00;
		  /* 820A4B00h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820A4B00h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A4B00h case   11:*/		return 0x820A4B04;
		  /* 820A4B04h */ case   12:  		/* bc 12, CR0_LT, 792 */
		/* 820A4B04h case   12:*/		if ( regs.CR[0].lt ) { return 0x820A4E1C;  }
		/* 820A4B04h case   12:*/		return 0x820A4B08;
		  /* 820A4B08h */ case   13:  		/* stw R27, <#[R31 + 1636]> */
		/* 820A4B08h case   13:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000664) );
		/* 820A4B08h case   13:*/		return 0x820A4B0C;
	}
	return 0x820A4B0C;
} // Block from 820A4AD4h-820A4B0Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A4B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4B0C);
		  /* 820A4B0Ch */ case    0:  		/* lwz R11, <#[R31 + 1656]> */
		/* 820A4B0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000678) );
		/* 820A4B0Ch case    0:*/		return 0x820A4B10;
		  /* 820A4B10h */ case    1:  		/* lwz R10, <#[R31 + 2196]> */
		/* 820A4B10h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000894) );
		/* 820A4B10h case    1:*/		return 0x820A4B14;
		  /* 820A4B14h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 820A4B14h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4B14h case    2:*/		return 0x820A4B18;
		  /* 820A4B18h */ case    3:  		/* stw R11, <#[R31 + 1652]> */
		/* 820A4B18h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000674) );
		/* 820A4B18h case    3:*/		return 0x820A4B1C;
		  /* 820A4B1Ch */ case    4:  		/* stw R10, <#[R31 + 2204]> */
		/* 820A4B1Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4B1Ch case    4:*/		return 0x820A4B20;
		  /* 820A4B20h */ case    5:  		/* bc 12, CR6_EQ, 444 */
		/* 820A4B20h case    5:*/		if ( regs.CR[6].eq ) { return 0x820A4CDC;  }
		/* 820A4B20h case    5:*/		return 0x820A4B24;
		  /* 820A4B24h */ case    6:  		/* li R11, 5 */
		/* 820A4B24h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820A4B24h case    6:*/		return 0x820A4B28;
		  /* 820A4B28h */ case    7:  		/* addi R10, R31, 2208 */
		/* 820A4B28h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x8A0);
		/* 820A4B28h case    7:*/		return 0x820A4B2C;
		  /* 820A4B2Ch */ case    8:  		/* addi R9, R30, -8 */
		/* 820A4B2Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0xFFFFFFF8);
		/* 820A4B2Ch case    8:*/		return 0x820A4B30;
		  /* 820A4B30h */ case    9:  		/* mtspr CTR, R11 */
		/* 820A4B30h case    9:*/		regs.CTR = regs.R11;
		/* 820A4B30h case    9:*/		return 0x820A4B34;
		  /* 820A4B34h */ case   10:  		/* ldu R11, <#[R10 + 8]> */
		/* 820A4B34h case   10:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820A4B34h case   10:*/		return 0x820A4B38;
		  /* 820A4B38h */ case   11:  		/* stdu R11, <#[R9 + 8]> */
		/* 820A4B38h case   11:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820A4B38h case   11:*/		return 0x820A4B3C;
		  /* 820A4B3Ch */ case   12:  		/* bc 16, CR0_LT, -8 */
		/* 820A4B3Ch case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A4B34;  }
		/* 820A4B3Ch case   12:*/		return 0x820A4B40;
		  /* 820A4B40h */ case   13:  		/* lwz R11, <#[R31 + 2196]> */
		/* 820A4B40h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000894) );
		/* 820A4B40h case   13:*/		return 0x820A4B44;
		  /* 820A4B44h */ case   14:  		/* lwz R11, <#[R11 + 128]> */
		/* 820A4B44h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000080) );
		/* 820A4B44h case   14:*/		return 0x820A4B48;
		  /* 820A4B48h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 820A4B48h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A4B48h case   15:*/		return 0x820A4B4C;
		  /* 820A4B4Ch */ case   16:  		/* bc 12, CR6_EQ, 12 */
		/* 820A4B4Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x820A4B58;  }
		/* 820A4B4Ch case   16:*/		return 0x820A4B50;
		  /* 820A4B50h */ case   17:  		/* li R11, 16 */
		/* 820A4B50h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 820A4B50h case   17:*/		return 0x820A4B54;
		  /* 820A4B54h */ case   18:  		/* stw R11, <#[R30]> */
		/* 820A4B54h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A4B54h case   18:*/		return 0x820A4B58;
	}
	return 0x820A4B58;
} // Block from 820A4B0Ch-820A4B58h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A4B58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4B58);
		  /* 820A4B58h */ case    0:  		/* lwz R11, <#[R31 + 1644]> */
		/* 820A4B58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000066C) );
		/* 820A4B58h case    0:*/		return 0x820A4B5C;
		  /* 820A4B5Ch */ case    1:  		/* lis R10, -32768 */
		/* 820A4B5Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 820A4B5Ch case    1:*/		return 0x820A4B60;
		  /* 820A4B60h */ case    2:  		/* subfic R11, R11, 0 */
		/* 820A4B60h case    2:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820A4B60h case    2:*/		return 0x820A4B64;
		  /* 820A4B64h */ case    3:  		/* ori R10, R10, 16389 */
		/* 820A4B64h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4005);
		/* 820A4B64h case    3:*/		return 0x820A4B68;
		  /* 820A4B68h */ case    4:  		/* subfe R11, R11, R11 */
		/* 820A4B68h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820A4B68h case    4:*/		return 0x820A4B6C;
		  /* 820A4B6Ch */ case    5:  		/* and R3, R11, R10 */
		/* 820A4B6Ch case    5:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820A4B6Ch case    5:*/		return 0x820A4B70;
		  /* 820A4B70h */ case    6:  		/* b 684 */
		/* 820A4B70h case    6:*/		return 0x820A4E1C;
		/* 820A4B70h case    6:*/		return 0x820A4B74;
	}
	return 0x820A4B74;
} // Block from 820A4B58h-820A4B74h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A4B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4B74);
		  /* 820A4B74h */ case    0:  		/* cmpwi CR6, R8, 17 */
		/* 820A4B74h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000011);
		/* 820A4B74h case    0:*/		return 0x820A4B78;
		  /* 820A4B78h */ case    1:  		/* bc 12, CR6_EQ, 444 */
		/* 820A4B78h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A4D34;  }
		/* 820A4B78h case    1:*/		return 0x820A4B7C;
		  /* 820A4B7Ch */ case    2:  		/* lwz R11, <#[R31 + 1652]> */
		/* 820A4B7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000674) );
		/* 820A4B7Ch case    2:*/		return 0x820A4B80;
		  /* 820A4B80h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820A4B80h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4B80h case    3:*/		return 0x820A4B84;
		  /* 820A4B84h */ case    4:  		/* bc 12, CR6_EQ, 96 */
		/* 820A4B84h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A4BE4;  }
		/* 820A4B84h case    4:*/		return 0x820A4B88;
		  /* 820A4B88h */ case    5:  		/* cmpwi CR6, R8, 11 */
		/* 820A4B88h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000000B);
		/* 820A4B88h case    5:*/		return 0x820A4B8C;
		  /* 820A4B8Ch */ case    6:  		/* bc 4, CR6_EQ, 88 */
		/* 820A4B8Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A4BE4;  }
		/* 820A4B8Ch case    6:*/		return 0x820A4B90;
		  /* 820A4B90h */ case    7:  		/* addi R6, R1, 84 */
		/* 820A4B90h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820A4B90h case    7:*/		return 0x820A4B94;
		  /* 820A4B94h */ case    8:  		/* lwz R4, <#[R30 + 8]> */
		/* 820A4B94h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000008) );
		/* 820A4B94h case    8:*/		return 0x820A4B98;
		  /* 820A4B98h */ case    9:  		/* addi R5, R1, 80 */
		/* 820A4B98h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820A4B98h case    9:*/		return 0x820A4B9C;
		  /* 820A4B9Ch */ case   10:  		/* mr R3, R31 */
		/* 820A4B9Ch case   10:*/		regs.R3 = regs.R31;
		/* 820A4B9Ch case   10:*/		return 0x820A4BA0;
		  /* 820A4BA0h */ case   11:  		/* bl -16088 */
		/* 820A4BA0h case   11:*/		regs.LR = 0x820A4BA4; return 0x820A0CC8;
		/* 820A4BA0h case   11:*/		return 0x820A4BA4;
		  /* 820A4BA4h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820A4BA4h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A4BA4h case   12:*/		return 0x820A4BA8;
		  /* 820A4BA8h */ case   13:  		/* bc 12, CR0_EQ, 60 */
		/* 820A4BA8h case   13:*/		if ( regs.CR[0].eq ) { return 0x820A4BE4;  }
		/* 820A4BA8h case   13:*/		return 0x820A4BAC;
		  /* 820A4BACh */ case   14:  		/* mr R4, R30 */
		/* 820A4BACh case   14:*/		regs.R4 = regs.R30;
		/* 820A4BACh case   14:*/		return 0x820A4BB0;
		  /* 820A4BB0h */ case   15:  		/* lwz R6, <#[R1 + 84]> */
		/* 820A4BB0h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820A4BB0h case   15:*/		return 0x820A4BB4;
		  /* 820A4BB4h */ case   16:  		/* mr R3, R31 */
		/* 820A4BB4h case   16:*/		regs.R3 = regs.R31;
		/* 820A4BB4h case   16:*/		return 0x820A4BB8;
		  /* 820A4BB8h */ case   17:  		/* lwz R5, <#[R1 + 80]> */
		/* 820A4BB8h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820A4BB8h case   17:*/		return 0x820A4BBC;
		  /* 820A4BBCh */ case   18:  		/* bl 804 */
		/* 820A4BBCh case   18:*/		regs.LR = 0x820A4BC0; return 0x820A4EE0;
		/* 820A4BBCh case   18:*/		return 0x820A4BC0;
		  /* 820A4BC0h */ case   19:  		/* cmpwi CR6, R3, 2 */
		/* 820A4BC0h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 820A4BC0h case   19:*/		return 0x820A4BC4;
		  /* 820A4BC4h */ case   20:  		/* bc 12, CR6_EQ, 32 */
		/* 820A4BC4h case   20:*/		if ( regs.CR[6].eq ) { return 0x820A4BE4;  }
		/* 820A4BC4h case   20:*/		return 0x820A4BC8;
		  /* 820A4BC8h */ case   21:  		/* cmpwi CR6, R3, 0 */
		/* 820A4BC8h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820A4BC8h case   21:*/		return 0x820A4BCC;
		  /* 820A4BCCh */ case   22:  		/* bc 4, CR6_EQ, 272 */
		/* 820A4BCCh case   22:*/		if ( !regs.CR[6].eq ) { return 0x820A4CDC;  }
		/* 820A4BCCh case   22:*/		return 0x820A4BD0;
		  /* 820A4BD0h */ case   23:  		/* lis R3, -32768 */
		/* 820A4BD0h case   23:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A4BD0h case   23:*/		return 0x820A4BD4;
		  /* 820A4BD4h */ case   24:  		/* stw R27, <#[R31 + 1644]> */
		/* 820A4BD4h case   24:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000066C) );
		/* 820A4BD4h case   24:*/		return 0x820A4BD8;
		  /* 820A4BD8h */ case   25:  		/* stw R27, <#[R31 + 1640]> */
		/* 820A4BD8h case   25:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000668) );
		/* 820A4BD8h case   25:*/		return 0x820A4BDC;
		  /* 820A4BDCh */ case   26:  		/* ori R3, R3, 16389 */
		/* 820A4BDCh case   26:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820A4BDCh case   26:*/		return 0x820A4BE0;
		  /* 820A4BE0h */ case   27:  		/* b 572 */
		/* 820A4BE0h case   27:*/		return 0x820A4E1C;
		/* 820A4BE0h case   27:*/		return 0x820A4BE4;
	}
	return 0x820A4BE4;
} // Block from 820A4B74h-820A4BE4h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820A4BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4BE4);
		  /* 820A4BE4h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820A4BE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A4BE4h case    0:*/		return 0x820A4BE8;
		  /* 820A4BE8h */ case    1:  		/* cmpwi CR6, R11, 11 */
		/* 820A4BE8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820A4BE8h case    1:*/		return 0x820A4BEC;
		  /* 820A4BECh */ case    2:  		/* bc 4, CR6_EQ, 208 */
		/* 820A4BECh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A4CBC;  }
		/* 820A4BECh case    2:*/		return 0x820A4BF0;
		  /* 820A4BF0h */ case    3:  		/* lwz R8, <#[R30 + 8]> */
		/* 820A4BF0h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000008) );
		/* 820A4BF0h case    3:*/		return 0x820A4BF4;
		  /* 820A4BF4h */ case    4:  		/* mr R10, R26 */
		/* 820A4BF4h case    4:*/		regs.R10 = regs.R26;
		/* 820A4BF4h case    4:*/		return 0x820A4BF8;
		  /* 820A4BF8h */ case    5:  		/* mr R11, R8 */
		/* 820A4BF8h case    5:*/		regs.R11 = regs.R8;
		/* 820A4BF8h case    5:*/		return 0x820A4BFC;
		  /* 820A4BFCh */ case    6:  		/* lbz R9, <#[R11]> */
		/* 820A4BFCh case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A4BFCh case    6:*/		return 0x820A4C00;
		  /* 820A4C00h */ case    7:  		/* lbz R7, <#[R10]> */
		/* 820A4C00h case    7:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A4C00h case    7:*/		return 0x820A4C04;
		  /* 820A4C04h */ case    8:  		/* cmpwi CR0, R9, 0 */
		/* 820A4C04h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A4C04h case    8:*/		return 0x820A4C08;
		  /* 820A4C08h */ case    9:  		/* subf R9, R7, R9 */
		/* 820A4C08h case    9:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A4C08h case    9:*/		return 0x820A4C0C;
		  /* 820A4C0Ch */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 820A4C0Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x820A4C20;  }
		/* 820A4C0Ch case   10:*/		return 0x820A4C10;
		  /* 820A4C10h */ case   11:  		/* addi R11, R11, 1 */
		/* 820A4C10h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A4C10h case   11:*/		return 0x820A4C14;
		  /* 820A4C14h */ case   12:  		/* addi R10, R10, 1 */
		/* 820A4C14h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A4C14h case   12:*/		return 0x820A4C18;
		  /* 820A4C18h */ case   13:  		/* cmpwi CR6, R9, 0 */
		/* 820A4C18h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A4C18h case   13:*/		return 0x820A4C1C;
		  /* 820A4C1Ch */ case   14:  		/* bc 12, CR6_EQ, -32 */
		/* 820A4C1Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x820A4BFC;  }
		/* 820A4C1Ch case   14:*/		return 0x820A4C20;
	}
	return 0x820A4C20;
} // Block from 820A4BE4h-820A4C20h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A4C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4C20);
		  /* 820A4C20h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A4C20h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A4C20h case    0:*/		return 0x820A4C24;
		  /* 820A4C24h */ case    1:  		/* bc 4, CR0_EQ, 60 */
		/* 820A4C24h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A4C60;  }
		/* 820A4C24h case    1:*/		return 0x820A4C28;
		  /* 820A4C28h */ case    2:  		/* li R11, 12 */
		/* 820A4C28h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820A4C28h case    2:*/		return 0x820A4C2C;
		  /* 820A4C2Ch */ case    3:  		/* stw R11, <#[R30]> */
		/* 820A4C2Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A4C2Ch case    3:*/		return 0x820A4C30;
		  /* 820A4C30h */ case    4:  		/* lwz R11, <#[R31 + 2204]> */
		/* 820A4C30h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4C30h case    4:*/		return 0x820A4C34;
		  /* 820A4C34h */ case    5:  		/* lwz R11, <#[R11 + 32]> */
		/* 820A4C34h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 820A4C34h case    5:*/		return 0x820A4C38;
		  /* 820A4C38h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820A4C38h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A4C38h case    6:*/		return 0x820A4C3C;
		  /* 820A4C3Ch */ case    7:  		/* stw R11, <#[R30 + 8]> */
		/* 820A4C3Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820A4C3Ch case    7:*/		return 0x820A4C40;
		  /* 820A4C40h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 820A4C40h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A4C48;  }
		/* 820A4C40h case    8:*/		return 0x820A4C44;
		  /* 820A4C44h */ case    9:  		/* stw R22, <#[R30 + 8]> */
		/* 820A4C44h case    9:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R30 + 0x00000008) );
		/* 820A4C44h case    9:*/		return 0x820A4C48;
	}
	return 0x820A4C48;
} // Block from 820A4C20h-820A4C48h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A4C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4C48);
		  /* 820A4C48h */ case    0:  		/* li R6, 1 */
		/* 820A4C48h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820A4C48h case    0:*/		return 0x820A4C4C;
		  /* 820A4C4Ch */ case    1:  		/* lwz R5, <#[R30 + 8]> */
		/* 820A4C4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000008) );
		/* 820A4C4Ch case    1:*/		return 0x820A4C50;
		  /* 820A4C50h */ case    2:  		/* mr R4, R30 */
		/* 820A4C50h case    2:*/		regs.R4 = regs.R30;
		/* 820A4C50h case    2:*/		return 0x820A4C54;
		  /* 820A4C54h */ case    3:  		/* mr R3, R31 */
		/* 820A4C54h case    3:*/		regs.R3 = regs.R31;
		/* 820A4C54h case    3:*/		return 0x820A4C58;
		  /* 820A4C58h */ case    4:  		/* bl -8464 */
		/* 820A4C58h case    4:*/		regs.LR = 0x820A4C5C; return 0x820A2B48;
		/* 820A4C58h case    4:*/		return 0x820A4C5C;
		  /* 820A4C5Ch */ case    5:  		/* b 88 */
		/* 820A4C5Ch case    5:*/		return 0x820A4CB4;
		/* 820A4C5Ch case    5:*/		return 0x820A4C60;
	}
	return 0x820A4C60;
} // Block from 820A4C48h-820A4C60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A4C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4C60);
		  /* 820A4C60h */ case    0:  		/* mr R10, R25 */
		/* 820A4C60h case    0:*/		regs.R10 = regs.R25;
		/* 820A4C60h case    0:*/		return 0x820A4C64;
		  /* 820A4C64h */ case    1:  		/* mr R11, R8 */
		/* 820A4C64h case    1:*/		regs.R11 = regs.R8;
		/* 820A4C64h case    1:*/		return 0x820A4C68;
		  /* 820A4C68h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A4C68h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A4C68h case    2:*/		return 0x820A4C6C;
		  /* 820A4C6Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A4C6Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A4C6Ch case    3:*/		return 0x820A4C70;
		  /* 820A4C70h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A4C70h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A4C70h case    4:*/		return 0x820A4C74;
		  /* 820A4C74h */ case    5:  		/* subf R9, R8, R9 */
		/* 820A4C74h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A4C74h case    5:*/		return 0x820A4C78;
		  /* 820A4C78h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820A4C78h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A4C8C;  }
		/* 820A4C78h case    6:*/		return 0x820A4C7C;
		  /* 820A4C7Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820A4C7Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A4C7Ch case    7:*/		return 0x820A4C80;
		  /* 820A4C80h */ case    8:  		/* addi R10, R10, 1 */
		/* 820A4C80h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A4C80h case    8:*/		return 0x820A4C84;
		  /* 820A4C84h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820A4C84h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A4C84h case    9:*/		return 0x820A4C88;
		  /* 820A4C88h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820A4C88h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A4C68;  }
		/* 820A4C88h case   10:*/		return 0x820A4C8C;
	}
	return 0x820A4C8C;
} // Block from 820A4C60h-820A4C8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A4C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4C8C);
		  /* 820A4C8Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A4C8Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A4C8Ch case    0:*/		return 0x820A4C90;
		  /* 820A4C90h */ case    1:  		/* bc 4, CR0_EQ, 44 */
		/* 820A4C90h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A4CBC;  }
		/* 820A4C90h case    1:*/		return 0x820A4C94;
		  /* 820A4C94h */ case    2:  		/* li R11, 2 */
		/* 820A4C94h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820A4C94h case    2:*/		return 0x820A4C98;
		  /* 820A4C98h */ case    3:  		/* mr R4, R30 */
		/* 820A4C98h case    3:*/		regs.R4 = regs.R30;
		/* 820A4C98h case    3:*/		return 0x820A4C9C;
		  /* 820A4C9Ch */ case    4:  		/* stw R11, <#[R30]> */
		/* 820A4C9Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A4C9Ch case    4:*/		return 0x820A4CA0;
	}
	return 0x820A4CA0;
} // Block from 820A4C8Ch-820A4CA0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A4CA0h
// Function '?d3d10tok_parse@CPreProcessorYaccStruct@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4CA0);
		  /* 820A4CA0h */ case    0:  		/* mr R3, R31 */
		/* 820A4CA0h case    0:*/		regs.R3 = regs.R31;
		/* 820A4CA0h case    0:*/		return 0x820A4CA4;
		  /* 820A4CA4h */ case    1:  		/* lwz R11, <#[R31 + 2204]> */
		/* 820A4CA4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4CA4h case    1:*/		return 0x820A4CA8;
		  /* 820A4CA8h */ case    2:  		/* lwz R5, <#[R11 + 40]> */
		/* 820A4CA8h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000028) );
		/* 820A4CA8h case    2:*/		return 0x820A4CAC;
		  /* 820A4CACh */ case    3:  		/* stw R5, <#[R30 + 8]> */
		/* 820A4CACh case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R30 + 0x00000008) );
		/* 820A4CACh case    3:*/		return 0x820A4CB0;
		  /* 820A4CB0h */ case    4:  		/* bl -8136 */
		/* 820A4CB0h case    4:*/		regs.LR = 0x820A4CB4; return 0x820A2CE8;
		/* 820A4CB0h case    4:*/		return 0x820A4CB4;
	}
	return 0x820A4CB4;
} // Block from 820A4CA0h-820A4CB4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A4CB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4CB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4CB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4CB4);
		  /* 820A4CB4h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820A4CB4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A4CB4h case    0:*/		return 0x820A4CB8;
		  /* 820A4CB8h */ case    1:  		/* bc 12, CR0_LT, 356 */
		/* 820A4CB8h case    1:*/		if ( regs.CR[0].lt ) { return 0x820A4E1C;  }
		/* 820A4CB8h case    1:*/		return 0x820A4CBC;
	}
	return 0x820A4CBC;
} // Block from 820A4CB4h-820A4CBCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A4CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4CBC);
		  /* 820A4CBCh */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820A4CBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A4CBCh case    0:*/		return 0x820A4CC0;
		  /* 820A4CC0h */ case    1:  		/* lwz R10, <#[R31 + 1652]> */
		/* 820A4CC0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000674) );
		/* 820A4CC0h case    1:*/		return 0x820A4CC4;
		  /* 820A4CC4h */ case    2:  		/* addi R11, R11, -16 */
		/* 820A4CC4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF0);
		/* 820A4CC4h case    2:*/		return 0x820A4CC8;
		  /* 820A4CC8h */ case    3:  		/* cmpwi CR6, R10, 0 */
		/* 820A4CC8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820A4CC8h case    3:*/		return 0x820A4CCC;
		  /* 820A4CCCh */ case    4:  		/* cntlzw R11, R11 */
		/* 820A4CCCh case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820A4CCCh case    4:*/		return 0x820A4CD0;
		  /* 820A4CD0h */ case    5:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 820A4CD0h case    5:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820A4CD0h case    5:*/		return 0x820A4CD4;
		  /* 820A4CD4h */ case    6:  		/* stw R11, <#[R31 + 1636]> */
		/* 820A4CD4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000664) );
		/* 820A4CD4h case    6:*/		return 0x820A4CD8;
		  /* 820A4CD8h */ case    7:  		/* bc 4, CR6_EQ, 184 */
		/* 820A4CD8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820A4D90;  }
		/* 820A4CD8h case    7:*/		return 0x820A4CDC;
	}
	return 0x820A4CDC;
} // Block from 820A4CBCh-820A4CDCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A4CDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4CDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4CDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4CDC);
		  /* 820A4CDCh */ case    0:  		/* lwz R11, <#[R31 + 1644]> */
		/* 820A4CDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000066C) );
		/* 820A4CDCh case    0:*/		return 0x820A4CE0;
		  /* 820A4CE0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820A4CE0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A4CE0h case    1:*/		return 0x820A4CE4;
		  /* 820A4CE4h */ case    2:  		/* bc 12, CR6_EQ, -1004 */
		/* 820A4CE4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A48F8;  }
		/* 820A4CE4h case    2:*/		return 0x820A4CE8;
	}
	return 0x820A4CE8;
} // Block from 820A4CDCh-820A4CE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A4CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4CE8);
		  /* 820A4CE8h */ case    0:  		/* lis R3, -32768 */
		/* 820A4CE8h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A4CE8h case    0:*/		return 0x820A4CEC;
		  /* 820A4CECh */ case    1:  		/* ori R3, R3, 16389 */
		/* 820A4CECh case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820A4CECh case    1:*/		return 0x820A4CF0;
		  /* 820A4CF0h */ case    2:  		/* lwz R11, <#[R31 + 2204]> */
		/* 820A4CF0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4CF0h case    2:*/		return 0x820A4CF4;
		  /* 820A4CF4h */ case    3:  		/* lwz R11, <#[R11 + 36]> */
		/* 820A4CF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 820A4CF4h case    3:*/		return 0x820A4CF8;
		  /* 820A4CF8h */ case    4:  		/* stw R11, <#[R30 + 20]> */
		/* 820A4CF8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820A4CF8h case    4:*/		return 0x820A4CFC;
		  /* 820A4CFCh */ case    5:  		/* lwz R11, <#[R31 + 2204]> */
		/* 820A4CFCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4CFCh case    5:*/		return 0x820A4D00;
		  /* 820A4D00h */ case    6:  		/* lwz R11, <#[R11 + 32]> */
		/* 820A4D00h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 820A4D00h case    6:*/		return 0x820A4D04;
		  /* 820A4D04h */ case    7:  		/* stw R11, <#[R30 + 16]> */
		/* 820A4D04h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820A4D04h case    7:*/		return 0x820A4D08;
		  /* 820A4D08h */ case    8:  		/* lwz R11, <#[R31 + 2204]> */
		/* 820A4D08h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4D08h case    8:*/		return 0x820A4D0C;
		  /* 820A4D0Ch */ case    9:  		/* lwz R11, <#[R11 + 40]> */
		/* 820A4D0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 820A4D0Ch case    9:*/		return 0x820A4D10;
		  /* 820A4D10h */ case   10:  		/* stw R11, <#[R30 + 24]> */
		/* 820A4D10h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820A4D10h case   10:*/		return 0x820A4D14;
		  /* 820A4D14h */ case   11:  		/* lwz R11, <#[R31 + 2204]> */
		/* 820A4D14h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4D14h case   11:*/		return 0x820A4D18;
		  /* 820A4D18h */ case   12:  		/* lwz R11, <#[R11 + 44]> */
		/* 820A4D18h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 820A4D18h case   12:*/		return 0x820A4D1C;
		  /* 820A4D1Ch */ case   13:  		/* stw R11, <#[R30 + 28]> */
		/* 820A4D1Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820A4D1Ch case   13:*/		return 0x820A4D20;
		  /* 820A4D20h */ case   14:  		/* li R11, 17 */
		/* 820A4D20h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x11);
		/* 820A4D20h case   14:*/		return 0x820A4D24;
		  /* 820A4D24h */ case   15:  		/* stw R11, <#[R30]> */
		/* 820A4D24h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A4D24h case   15:*/		return 0x820A4D28;
		  /* 820A4D28h */ case   16:  		/* b 244 */
		/* 820A4D28h case   16:*/		return 0x820A4E1C;
		/* 820A4D28h case   16:*/		return 0x820A4D2C;
	}
	return 0x820A4D2C;
} // Block from 820A4CE8h-820A4D2Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A4D2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4D2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4D2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4D2C);
		  /* 820A4D2Ch */ case    0:  		/* mr R3, R28 */
		/* 820A4D2Ch case    0:*/		regs.R3 = regs.R28;
		/* 820A4D2Ch case    0:*/		return 0x820A4D30;
		  /* 820A4D30h */ case    1:  		/* b -64 */
		/* 820A4D30h case    1:*/		return 0x820A4CF0;
		/* 820A4D30h case    1:*/		return 0x820A4D34;
	}
	return 0x820A4D34;
} // Block from 820A4D2Ch-820A4D34h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A4D34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4D34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4D34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4D34);
		  /* 820A4D34h */ case    0:  		/* lwz R11, <#[R31 + 2196]> */
		/* 820A4D34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000894) );
		/* 820A4D34h case    0:*/		return 0x820A4D38;
		  /* 820A4D38h */ case    1:  		/* lwz R11, <#[R11 + 80]> */
		/* 820A4D38h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 820A4D38h case    1:*/		return 0x820A4D3C;
		  /* 820A4D3Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820A4D3Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A4D3Ch case    2:*/		return 0x820A4D40;
		  /* 820A4D40h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 820A4D40h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A4D5C;  }
		/* 820A4D40h case    3:*/		return 0x820A4D44;
		  /* 820A4D44h */ case    4:  		/* lis R11, -32255 */
		/* 820A4D44h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A4D44h case    4:*/		return 0x820A4D48;
		  /* 820A4D48h */ case    5:  		/* li R5, 1502 */
		/* 820A4D48h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x5DE);
		/* 820A4D48h case    5:*/		return 0x820A4D4C;
		  /* 820A4D4Ch */ case    6:  		/* addi R6, R11, -9904 */
		/* 820A4D4Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD950);
		/* 820A4D4Ch case    6:*/		return 0x820A4D50;
		  /* 820A4D50h */ case    7:  		/* mr R4, R30 */
		/* 820A4D50h case    7:*/		regs.R4 = regs.R30;
		/* 820A4D50h case    7:*/		return 0x820A4D54;
		  /* 820A4D54h */ case    8:  		/* addi R3, R31, 24 */
		/* 820A4D54h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x18);
		/* 820A4D54h case    8:*/		return 0x820A4D58;
		  /* 820A4D58h */ case    9:  		/* bl 9272 */
		/* 820A4D58h case    9:*/		regs.LR = 0x820A4D5C; return 0x820A7190;
		/* 820A4D58h case    9:*/		return 0x820A4D5C;
	}
	return 0x820A4D5C;
} // Block from 820A4D34h-820A4D5Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A4D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4D5C);
		  /* 820A4D5Ch */ case    0:  		/* lwz R3, <#[R31 + 2196]> */
		/* 820A4D5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000894) );
		/* 820A4D5Ch case    0:*/		return 0x820A4D60;
		  /* 820A4D60h */ case    1:  		/* lwz R11, <#[R3 + 128]> */
		/* 820A4D60h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 820A4D60h case    1:*/		return 0x820A4D64;
		  /* 820A4D64h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820A4D64h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A4D64h case    2:*/		return 0x820A4D68;
		  /* 820A4D68h */ case    3:  		/* bc 12, CR6_EQ, 176 */
		/* 820A4D68h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A4E18;  }
		/* 820A4D68h case    3:*/		return 0x820A4D6C;
		  /* 820A4D6Ch */ case    4:  		/* bl -20604 */
		/* 820A4D6Ch case    4:*/		regs.LR = 0x820A4D70; return 0x8209FCF0;
		/* 820A4D6Ch case    4:*/		return 0x820A4D70;
		  /* 820A4D70h */ case    5:  		/* lwz R10, <#[R31 + 2196]> */
		/* 820A4D70h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000894) );
		/* 820A4D70h case    5:*/		return 0x820A4D74;
		  /* 820A4D74h */ case    6:  		/* li R11, 16 */
		/* 820A4D74h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 820A4D74h case    6:*/		return 0x820A4D78;
		  /* 820A4D78h */ case    7:  		/* lwz R10, <#[R10 + 128]> */
		/* 820A4D78h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000080) );
		/* 820A4D78h case    7:*/		return 0x820A4D7C;
		  /* 820A4D7Ch */ case    8:  		/* stw R10, <#[R31 + 2196]> */
		/* 820A4D7Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000894) );
		/* 820A4D7Ch case    8:*/		return 0x820A4D80;
		  /* 820A4D80h */ case    9:  		/* stw R10, <#[R31 + 2204]> */
		/* 820A4D80h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000089C) );
		/* 820A4D80h case    9:*/		return 0x820A4D84;
		  /* 820A4D84h */ case   10:  		/* stw R11, <#[R30]> */
		/* 820A4D84h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A4D84h case   10:*/		return 0x820A4D88;
		  /* 820A4D88h */ case   11:  		/* stw R27, <#[R31 + 1636]> */
		/* 820A4D88h case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000664) );
		/* 820A4D88h case   11:*/		return 0x820A4D8C;
		  /* 820A4D8Ch */ case   12:  		/* b 140 */
		/* 820A4D8Ch case   12:*/		return 0x820A4E18;
		/* 820A4D8Ch case   12:*/		return 0x820A4D90;
	}
	return 0x820A4D90;
} // Block from 820A4D5Ch-820A4D90h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A4D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4D90);
		  /* 820A4D90h */ case    0:  		/* lwz R11, <#[R31 + 1680]> */
		/* 820A4D90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000690) );
		/* 820A4D90h case    0:*/		return 0x820A4D94;
		  /* 820A4D94h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A4D94h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A4D94h case    1:*/		return 0x820A4D98;
		  /* 820A4D98h */ case    2:  		/* bc 12, CR6_EQ, 128 */
		/* 820A4D98h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A4E18;  }
		/* 820A4D98h case    2:*/		return 0x820A4D9C;
		  /* 820A4D9Ch */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 820A4D9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820A4D9Ch case    3:*/		return 0x820A4DA0;
		  /* 820A4DA0h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 820A4DA0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A4DA0h case    4:*/		return 0x820A4DA4;
		  /* 820A4DA4h */ case    5:  		/* bc 12, CR6_EQ, 116 */
		/* 820A4DA4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820A4E18;  }
		/* 820A4DA4h case    5:*/		return 0x820A4DA8;
		  /* 820A4DA8h */ case    6:  		/* lwz R10, <#[R30]> */
		/* 820A4DA8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820A4DA8h case    6:*/		return 0x820A4DAC;
		  /* 820A4DACh */ case    7:  		/* cmpwi CR6, R10, 1 */
		/* 820A4DACh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 820A4DACh case    7:*/		return 0x820A4DB0;
		  /* 820A4DB0h */ case    8:  		/* bc 4, CR6_EQ, 80 */
		/* 820A4DB0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A4E00;  }
		/* 820A4DB0h case    8:*/		return 0x820A4DB4;
		  /* 820A4DB4h */ case    9:  		/* lbz R10, <#[R30 + 9]> */
		/* 820A4DB4h case    9:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000009) );
		/* 820A4DB4h case    9:*/		return 0x820A4DB8;
		  /* 820A4DB8h */ case   10:  		/* cmplwi CR0, R10, 0 */
		/* 820A4DB8h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820A4DB8h case   10:*/		return 0x820A4DBC;
		  /* 820A4DBCh */ case   11:  		/* bc 4, CR0_EQ, 68 */
		/* 820A4DBCh case   11:*/		if ( !regs.CR[0].eq ) { return 0x820A4E00;  }
		/* 820A4DBCh case   11:*/		return 0x820A4DC0;
		  /* 820A4DC0h */ case   12:  		/* lbz R10, <#[R30 + 8]> */
		/* 820A4DC0h case   12:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 820A4DC0h case   12:*/		return 0x820A4DC4;
		  /* 820A4DC4h */ case   13:  		/* cmplwi CR6, R10, 123 */
		/* 820A4DC4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007B);
		/* 820A4DC4h case   13:*/		return 0x820A4DC8;
		  /* 820A4DC8h */ case   14:  		/* bc 4, CR6_EQ, 16 */
		/* 820A4DC8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820A4DD8;  }
		/* 820A4DC8h case   14:*/		return 0x820A4DCC;
		  /* 820A4DCCh */ case   15:  		/* lwz R10, <#[R11 + 8]> */
		/* 820A4DCCh case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820A4DCCh case   15:*/		return 0x820A4DD0;
		  /* 820A4DD0h */ case   16:  		/* addi R10, R10, 1 */
		/* 820A4DD0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A4DD0h case   16:*/		return 0x820A4DD4;
		  /* 820A4DD4h */ case   17:  		/* stw R10, <#[R11 + 8]> */
		/* 820A4DD4h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820A4DD4h case   17:*/		return 0x820A4DD8;
	}
	return 0x820A4DD8;
} // Block from 820A4D90h-820A4DD8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820A4DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4DD8);
		  /* 820A4DD8h */ case    0:  		/* lbz R11, <#[R30 + 8]> */
		/* 820A4DD8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820A4DD8h case    0:*/		return 0x820A4DDC;
		  /* 820A4DDCh */ case    1:  		/* cmplwi CR6, R11, 125 */
		/* 820A4DDCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 820A4DDCh case    1:*/		return 0x820A4DE0;
		  /* 820A4DE0h */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 820A4DE0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A4E00;  }
		/* 820A4DE0h case    2:*/		return 0x820A4DE4;
		  /* 820A4DE4h */ case    3:  		/* lwz R11, <#[R31 + 1680]> */
		/* 820A4DE4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000690) );
		/* 820A4DE4h case    3:*/		return 0x820A4DE8;
		  /* 820A4DE8h */ case    4:  		/* lwz R10, <#[R11 + 8]> */
		/* 820A4DE8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820A4DE8h case    4:*/		return 0x820A4DEC;
		  /* 820A4DECh */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 820A4DECh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A4DECh case    5:*/		return 0x820A4DF0;
		  /* 820A4DF0h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 820A4DF0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A4E00;  }
		/* 820A4DF0h case    6:*/		return 0x820A4DF4;
		  /* 820A4DF4h */ case    7:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 820A4DF4h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 820A4DF4h case    7:*/		return 0x820A4DF8;
		  /* 820A4DF8h */ case    8:  		/* addi R10, R10, -1 */
		/* 820A4DF8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820A4DF8h case    8:*/		return 0x820A4DFC;
		  /* 820A4DFCh */ case    9:  		/* stw R10, <#[R11 + 8]> */
		/* 820A4DFCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820A4DFCh case    9:*/		return 0x820A4E00;
	}
	return 0x820A4E00;
} // Block from 820A4DD8h-820A4E00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A4E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4E00);
		  /* 820A4E00h */ case    0:  		/* lwz R11, <#[R31 + 1680]> */
		/* 820A4E00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000690) );
		/* 820A4E00h case    0:*/		return 0x820A4E04;
		  /* 820A4E04h */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 820A4E04h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820A4E04h case    1:*/		return 0x820A4E08;
		  /* 820A4E08h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820A4E08h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A4E08h case    2:*/		return 0x820A4E0C;
		  /* 820A4E0Ch */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 820A4E0Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A4E18;  }
		/* 820A4E0Ch case    3:*/		return 0x820A4E10;
		  /* 820A4E10h */ case    4:  		/* li R11, 17 */
		/* 820A4E10h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x11);
		/* 820A4E10h case    4:*/		return 0x820A4E14;
		  /* 820A4E14h */ case    5:  		/* stw R11, <#[R30]> */
		/* 820A4E14h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A4E14h case    5:*/		return 0x820A4E18;
	}
	return 0x820A4E18;
} // Block from 820A4E00h-820A4E18h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A4E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4E18);
		  /* 820A4E18h */ case    0:  		/* li R3, 0 */
		/* 820A4E18h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A4E18h case    0:*/		return 0x820A4E1C;
	}
	return 0x820A4E1C;
} // Block from 820A4E18h-820A4E1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A4E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4E1C);
		  /* 820A4E1Ch */ case    0:  		/* addi R1, R1, 3232 */
		/* 820A4E1Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xCA0);
		/* 820A4E1Ch case    0:*/		return 0x820A4E20;
		  /* 820A4E20h */ case    1:  		/* b -80784 */
		/* 820A4E20h case    1:*/		return 0x82091290;
		/* 820A4E20h case    1:*/		return 0x820A4E24;
		  /* 820A4E24h */ case    2:  		/* nop */
		/* 820A4E24h case    2:*/		cpu::op::nop();
		/* 820A4E24h case    2:*/		return 0x820A4E28;
	}
	return 0x820A4E28;
} // Block from 820A4E1Ch-820A4E28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A4E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4E28);
		  /* 820A4E28h */ case    0:  		/* mfspr R12, LR */
		/* 820A4E28h case    0:*/		regs.R12 = regs.LR;
		/* 820A4E28h case    0:*/		return 0x820A4E2C;
		  /* 820A4E2Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A4E2Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A4E2Ch case    1:*/		return 0x820A4E30;
		  /* 820A4E30h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A4E30h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A4E30h case    2:*/		return 0x820A4E34;
		  /* 820A4E34h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A4E34h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A4E34h case    3:*/		return 0x820A4E38;
		  /* 820A4E38h */ case    4:  		/* stwu R1, <#[R1 - 144]> */
		/* 820A4E38h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820A4E38h case    4:*/		return 0x820A4E3C;
		  /* 820A4E3Ch */ case    5:  		/* mr R31, R3 */
		/* 820A4E3Ch case    5:*/		regs.R31 = regs.R3;
		/* 820A4E3Ch case    5:*/		return 0x820A4E40;
		  /* 820A4E40h */ case    6:  		/* li R30, 0 */
		/* 820A4E40h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A4E40h case    6:*/		return 0x820A4E44;
		  /* 820A4E44h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820A4E44h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A4E44h case    7:*/		return 0x820A4E48;
		  /* 820A4E48h */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 820A4E48h case    8:*/		if ( regs.CR[6].eq ) { return 0x820A4E50;  }
		/* 820A4E48h case    8:*/		return 0x820A4E4C;
		  /* 820A4E4Ch */ case    9:  		/* stw R30, <#[R4]> */
		/* 820A4E4Ch case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R4 + 0x00000000) );
		/* 820A4E4Ch case    9:*/		return 0x820A4E50;
	}
	return 0x820A4E50;
} // Block from 820A4E28h-820A4E50h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A4E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4E50);
		  /* 820A4E50h */ case    0:  		/* lwz R11, <#[R31 + 1680]> */
		/* 820A4E50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000690) );
		/* 820A4E50h case    0:*/		return 0x820A4E54;
		  /* 820A4E54h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A4E54h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A4E54h case    1:*/		return 0x820A4E58;
		  /* 820A4E58h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 820A4E58h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A4E74;  }
		/* 820A4E58h case    2:*/		return 0x820A4E5C;
		  /* 820A4E5Ch */ case    3:  		/* lis R3, -30602 */
		/* 820A4E5Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820A4E5Ch case    3:*/		return 0x820A4E60;
		  /* 820A4E60h */ case    4:  		/* ori R3, R3, 2156 */
		/* 820A4E60h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 820A4E60h case    4:*/		return 0x820A4E64;
		  /* 820A4E64h */ case    5:  		/* b 96 */
		/* 820A4E64h case    5:*/		return 0x820A4EC4;
		/* 820A4E64h case    5:*/		return 0x820A4E68;
		  /* 820A4E68h */ case    6:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A4E68h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A4E68h case    6:*/		return 0x820A4E6C;
		  /* 820A4E6Ch */ case    7:  		/* cmpwi CR6, R11, 17 */
		/* 820A4E6Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820A4E6Ch case    7:*/		return 0x820A4E70;
		  /* 820A4E70h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 820A4E70h case    8:*/		if ( regs.CR[6].eq ) { return 0x820A4E8C;  }
		/* 820A4E70h case    8:*/		return 0x820A4E74;
	}
	return 0x820A4E74;
} // Block from 820A4E50h-820A4E74h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A4E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4E74);
		  /* 820A4E74h */ case    0:  		/* addi R4, R1, 80 */
		/* 820A4E74h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820A4E74h case    0:*/		return 0x820A4E78;
		  /* 820A4E78h */ case    1:  		/* mr R3, R31 */
		/* 820A4E78h case    1:*/		regs.R3 = regs.R31;
		/* 820A4E78h case    1:*/		return 0x820A4E7C;
		  /* 820A4E7Ch */ case    2:  		/* bl -1492 */
		/* 820A4E7Ch case    2:*/		regs.LR = 0x820A4E80; return 0x820A48A8;
		/* 820A4E7Ch case    2:*/		return 0x820A4E80;
		  /* 820A4E80h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820A4E80h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A4E80h case    3:*/		return 0x820A4E84;
		  /* 820A4E84h */ case    4:  		/* bc 4, CR0_LT, -28 */
		/* 820A4E84h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820A4E68;  }
		/* 820A4E84h case    4:*/		return 0x820A4E88;
		  /* 820A4E88h */ case    5:  		/* b 60 */
		/* 820A4E88h case    5:*/		return 0x820A4EC4;
		/* 820A4E88h case    5:*/		return 0x820A4E8C;
	}
	return 0x820A4E8C;
} // Block from 820A4E74h-820A4E8Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A4E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4E8C);
		  /* 820A4E8Ch */ case    0:  		/* lwz R3, <#[R31 + 1680]> */
		/* 820A4E8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000690) );
		/* 820A4E8Ch case    0:*/		return 0x820A4E90;
		  /* 820A4E90h */ case    1:  		/* li R4, 1 */
		/* 820A4E90h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A4E90h case    1:*/		return 0x820A4E94;
		  /* 820A4E94h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 820A4E94h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820A4E94h case    2:*/		return 0x820A4E98;
		  /* 820A4E98h */ case    3:  		/* stw R11, <#[R31 + 1680]> */
		/* 820A4E98h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000690) );
		/* 820A4E98h case    3:*/		return 0x820A4E9C;
		  /* 820A4E9Ch */ case    4:  		/* stw R30, <#[R3 + 4]> */
		/* 820A4E9Ch case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 820A4E9Ch case    4:*/		return 0x820A4EA0;
		  /* 820A4EA0h */ case    5:  		/* bl -16096 */
		/* 820A4EA0h case    5:*/		regs.LR = 0x820A4EA4; return 0x820A0FC0;
		/* 820A4EA0h case    5:*/		return 0x820A4EA4;
		  /* 820A4EA4h */ case    6:  		/* lwz R11, <#[R31 + 1680]> */
		/* 820A4EA4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000690) );
		/* 820A4EA4h case    6:*/		return 0x820A4EA8;
		  /* 820A4EA8h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820A4EA8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A4EA8h case    7:*/		return 0x820A4EAC;
		  /* 820A4EACh */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 820A4EACh case    8:*/		if ( regs.CR[6].eq ) { return 0x820A4EB8;  }
		/* 820A4EACh case    8:*/		return 0x820A4EB0;
		  /* 820A4EB0h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 820A4EB0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A4EB0h case    9:*/		return 0x820A4EB4;
		  /* 820A4EB4h */ case   10:  		/* b 8 */
		/* 820A4EB4h case   10:*/		return 0x820A4EBC;
		/* 820A4EB4h case   10:*/		return 0x820A4EB8;
	}
	return 0x820A4EB8;
} // Block from 820A4E8Ch-820A4EB8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A4EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4EB8);
		  /* 820A4EB8h */ case    0:  		/* li R11, 1 */
		/* 820A4EB8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A4EB8h case    0:*/		return 0x820A4EBC;
	}
	return 0x820A4EBC;
} // Block from 820A4EB8h-820A4EBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A4EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4EBC);
		  /* 820A4EBCh */ case    0:  		/* stw R11, <#[R31 + 2256]> */
		/* 820A4EBCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000008D0) );
		/* 820A4EBCh case    0:*/		return 0x820A4EC0;
		  /* 820A4EC0h */ case    1:  		/* li R3, 0 */
		/* 820A4EC0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A4EC0h case    1:*/		return 0x820A4EC4;
	}
	return 0x820A4EC4;
} // Block from 820A4EBCh-820A4EC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A4EC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4EC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4EC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4EC4);
		  /* 820A4EC4h */ case    0:  		/* addi R1, R1, 144 */
		/* 820A4EC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820A4EC4h case    0:*/		return 0x820A4EC8;
		  /* 820A4EC8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A4EC8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A4EC8h case    1:*/		return 0x820A4ECC;
		  /* 820A4ECCh */ case    2:  		/* mtspr LR, R12 */
		/* 820A4ECCh case    2:*/		regs.LR = regs.R12;
		/* 820A4ECCh case    2:*/		return 0x820A4ED0;
		  /* 820A4ED0h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820A4ED0h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A4ED0h case    3:*/		return 0x820A4ED4;
		  /* 820A4ED4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820A4ED4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A4ED4h case    4:*/		return 0x820A4ED8;
		  /* 820A4ED8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820A4ED8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A4ED8h case    5:*/		return 0x820A4EDC;
	}
	return 0x820A4EDC;
} // Block from 820A4EC4h-820A4EDCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A4EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4EDC);
		  /* 820A4EDCh */ case    0:  		/* nop */
		/* 820A4EDCh case    0:*/		cpu::op::nop();
		/* 820A4EDCh case    0:*/		return 0x820A4EE0;
	}
	return 0x820A4EE0;
} // Block from 820A4EDCh-820A4EE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A4EE0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4EE0);
		  /* 820A4EE0h */ case    0:  		/* mfspr R12, LR */
		/* 820A4EE0h case    0:*/		regs.R12 = regs.LR;
		/* 820A4EE0h case    0:*/		return 0x820A4EE4;
		  /* 820A4EE4h */ case    1:  		/* bl -81076 */
		/* 820A4EE4h case    1:*/		regs.LR = 0x820A4EE8; return 0x82091230;
		/* 820A4EE4h case    1:*/		return 0x820A4EE8;
		  /* 820A4EE8h */ case    2:  		/* stwu R1, <#[R1 - 400]> */
		/* 820A4EE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE70);
		/* 820A4EE8h case    2:*/		return 0x820A4EEC;
		  /* 820A4EECh */ case    3:  		/* li R11, 5 */
		/* 820A4EECh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820A4EECh case    3:*/		return 0x820A4EF0;
		  /* 820A4EF0h */ case    4:  		/* addi R10, R1, 240 */
		/* 820A4EF0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xF0);
		/* 820A4EF0h case    4:*/		return 0x820A4EF4;
		  /* 820A4EF4h */ case    5:  		/* li R18, 0 */
		/* 820A4EF4h case    5:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 820A4EF4h case    5:*/		return 0x820A4EF8;
		  /* 820A4EF8h */ case    6:  		/* addi R9, R10, -8 */
		/* 820A4EF8h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xFFFFFFF8);
		/* 820A4EF8h case    6:*/		return 0x820A4EFC;
		  /* 820A4EFCh */ case    7:  		/* mr R20, R3 */
		/* 820A4EFCh case    7:*/		regs.R20 = regs.R3;
		/* 820A4EFCh case    7:*/		return 0x820A4F00;
		  /* 820A4F00h */ case    8:  		/* stw R18, <#[R1 + 96]> */
		/* 820A4F00h case    8:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000060) );
		/* 820A4F00h case    8:*/		return 0x820A4F04;
		  /* 820A4F04h */ case    9:  		/* mr R19, R5 */
		/* 820A4F04h case    9:*/		regs.R19 = regs.R5;
		/* 820A4F04h case    9:*/		return 0x820A4F08;
		  /* 820A4F08h */ case   10:  		/* stw R18, <#[R1 + 100]> */
		/* 820A4F08h case   10:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000064) );
		/* 820A4F08h case   10:*/		return 0x820A4F0C;
		  /* 820A4F0Ch */ case   11:  		/* mr R27, R6 */
		/* 820A4F0Ch case   11:*/		regs.R27 = regs.R6;
		/* 820A4F0Ch case   11:*/		return 0x820A4F10;
		  /* 820A4F10h */ case   12:  		/* mtspr CTR, R11 */
		/* 820A4F10h case   12:*/		regs.CTR = regs.R11;
		/* 820A4F10h case   12:*/		return 0x820A4F14;
		  /* 820A4F14h */ case   13:  		/* addi R10, R4, -8 */
		/* 820A4F14h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xFFFFFFF8);
		/* 820A4F14h case   13:*/		return 0x820A4F18;
		  /* 820A4F18h */ case   14:  		/* ldu R11, <#[R10 + 8]> */
		/* 820A4F18h case   14:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820A4F18h case   14:*/		return 0x820A4F1C;
		  /* 820A4F1Ch */ case   15:  		/* stdu R11, <#[R9 + 8]> */
		/* 820A4F1Ch case   15:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820A4F1Ch case   15:*/		return 0x820A4F20;
		  /* 820A4F20h */ case   16:  		/* bc 16, CR0_LT, -8 */
		/* 820A4F20h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A4F18;  }
		/* 820A4F20h case   16:*/		return 0x820A4F24;
		  /* 820A4F24h */ case   17:  		/* cmplwi CR6, R19, 0 */
		/* 820A4F24h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820A4F24h case   17:*/		return 0x820A4F28;
		  /* 820A4F28h */ case   18:  		/* bc 4, CR6_EQ, 84 */
		/* 820A4F28h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820A4F7C;  }
		/* 820A4F28h case   18:*/		return 0x820A4F2C;
		  /* 820A4F2Ch */ case   19:  		/* addi R31, R1, 96 */
		/* 820A4F2Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x60);
		/* 820A4F2Ch case   19:*/		return 0x820A4F30;
		  /* 820A4F30h */ case   20:  		/* b 56 */
		/* 820A4F30h case   20:*/		return 0x820A4F68;
		/* 820A4F30h case   20:*/		return 0x820A4F34;
		  /* 820A4F34h */ case   21:  		/* li R3, 56 */
		/* 820A4F34h case   21:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A4F34h case   21:*/		return 0x820A4F38;
		  /* 820A4F38h */ case   22:  		/* bl 148208 */
		/* 820A4F38h case   22:*/		regs.LR = 0x820A4F3C; return 0x820C9228;
		/* 820A4F38h case   22:*/		return 0x820A4F3C;
		  /* 820A4F3Ch */ case   23:  		/* cmplwi CR0, R3, 0 */
		/* 820A4F3Ch case   23:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A4F3Ch case   23:*/		return 0x820A4F40;
		  /* 820A4F40h */ case   24:  		/* bc 12, CR0_EQ, 16 */
		/* 820A4F40h case   24:*/		if ( regs.CR[0].eq ) { return 0x820A4F50;  }
		/* 820A4F40h case   24:*/		return 0x820A4F44;
		  /* 820A4F44h */ case   25:  		/* addi R4, R27, 16 */
		/* 820A4F44h case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R27,0x10);
		/* 820A4F44h case   25:*/		return 0x820A4F48;
		  /* 820A4F48h */ case   26:  		/* bl 149768 */
		/* 820A4F48h case   26:*/		regs.LR = 0x820A4F4C; return 0x820C9850;
		/* 820A4F48h case   26:*/		return 0x820A4F4C;
		  /* 820A4F4Ch */ case   27:  		/* b 8 */
		/* 820A4F4Ch case   27:*/		return 0x820A4F54;
		/* 820A4F4Ch case   27:*/		return 0x820A4F50;
	}
	return 0x820A4F50;
} // Block from 820A4EE0h-820A4F50h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820A4F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4F50);
		  /* 820A4F50h */ case    0:  		/* mr R3, R18 */
		/* 820A4F50h case    0:*/		regs.R3 = regs.R18;
		/* 820A4F50h case    0:*/		return 0x820A4F54;
	}
	return 0x820A4F54;
} // Block from 820A4F50h-820A4F54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A4F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4F54);
		  /* 820A4F54h */ case    0:  		/* stw R3, <#[R31]> */
		/* 820A4F54h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A4F54h case    0:*/		return 0x820A4F58;
		  /* 820A4F58h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A4F58h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A4F58h case    1:*/		return 0x820A4F5C;
		  /* 820A4F5Ch */ case    2:  		/* bc 12, CR6_EQ, 2184 */
		/* 820A4F5Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820A57E4;  }
		/* 820A4F5Ch case    2:*/		return 0x820A4F60;
		  /* 820A4F60h */ case    3:  		/* lwz R27, <#[R27 + 12]> */
		/* 820A4F60h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x0000000C) );
		/* 820A4F60h case    3:*/		return 0x820A4F64;
		  /* 820A4F64h */ case    4:  		/* addi R31, R3, 12 */
		/* 820A4F64h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0xC);
		/* 820A4F64h case    4:*/		return 0x820A4F68;
	}
	return 0x820A4F68;
} // Block from 820A4F54h-820A4F68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A4F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4F68);
		  /* 820A4F68h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820A4F68h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820A4F68h case    0:*/		return 0x820A4F6C;
		  /* 820A4F6Ch */ case    1:  		/* bc 4, CR6_EQ, -56 */
		/* 820A4F6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A4F34;  }
		/* 820A4F6Ch case    1:*/		return 0x820A4F70;
		  /* 820A4F70h */ case    2:  		/* lwz R11, <#[R20 + 1668]> */
		/* 820A4F70h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000684) );
		/* 820A4F70h case    2:*/		return 0x820A4F74;
		  /* 820A4F74h */ case    3:  		/* stw R11, <#[R31]> */
		/* 820A4F74h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A4F74h case    3:*/		return 0x820A4F78;
		  /* 820A4F78h */ case    4:  		/* b 2220 */
		/* 820A4F78h case    4:*/		return 0x820A5824;
		/* 820A4F78h case    4:*/		return 0x820A4F7C;
	}
	return 0x820A4F7C;
} // Block from 820A4F68h-820A4F7Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A4F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4F7C);
		  /* 820A4F7Ch */ case    0:  		/* lwz R7, <#[R20 + 1668]> */
		/* 820A4F7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R20 + 0x00000684) );
		/* 820A4F7Ch case    0:*/		return 0x820A4F80;
		  /* 820A4F80h */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 820A4F80h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820A4F80h case    1:*/		return 0x820A4F84;
		  /* 820A4F84h */ case    2:  		/* bc 12, CR6_EQ, 120 */
		/* 820A4F84h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A4FFC;  }
		/* 820A4F84h case    2:*/		return 0x820A4F88;
		  /* 820A4F88h */ case    3:  		/* li R11, 5 */
		/* 820A4F88h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820A4F88h case    3:*/		return 0x820A4F8C;
		  /* 820A4F8Ch */ case    4:  		/* addi R10, R20, 2216 */
		/* 820A4F8Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R20,0x8A8);
		/* 820A4F8Ch case    4:*/		return 0x820A4F90;
		  /* 820A4F90h */ case    5:  		/* addi R9, R7, 8 */
		/* 820A4F90h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R7,0x8);
		/* 820A4F90h case    5:*/		return 0x820A4F94;
		  /* 820A4F94h */ case    6:  		/* addi R8, R10, -8 */
		/* 820A4F94h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFF8);
		/* 820A4F94h case    6:*/		return 0x820A4F98;
		  /* 820A4F98h */ case    7:  		/* mtspr CTR, R11 */
		/* 820A4F98h case    7:*/		regs.CTR = regs.R11;
		/* 820A4F98h case    7:*/		return 0x820A4F9C;
		  /* 820A4F9Ch */ case    8:  		/* ldu R11, <#[R9 + 8]> */
		/* 820A4F9Ch case    8:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820A4F9Ch case    8:*/		return 0x820A4FA0;
		  /* 820A4FA0h */ case    9:  		/* stdu R11, <#[R8 + 8]> */
		/* 820A4FA0h case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R8 + 0x00000008) );
		regs.R8 = (uint32)(regs.R8 + 0x00000008);
		/* 820A4FA0h case    9:*/		return 0x820A4FA4;
		  /* 820A4FA4h */ case   10:  		/* bc 16, CR0_LT, -8 */
		/* 820A4FA4h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A4F9C;  }
		/* 820A4FA4h case   10:*/		return 0x820A4FA8;
		  /* 820A4FA8h */ case   11:  		/* lwz R11, <#[R10]> */
		/* 820A4FA8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820A4FA8h case   11:*/		return 0x820A4FAC;
		  /* 820A4FACh */ case   12:  		/* cmpwi CR6, R11, 1 */
		/* 820A4FACh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820A4FACh case   12:*/		return 0x820A4FB0;
		  /* 820A4FB0h */ case   13:  		/* bc 4, CR6_EQ, 2180 */
		/* 820A4FB0h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A5834;  }
		/* 820A4FB0h case   13:*/		return 0x820A4FB4;
		  /* 820A4FB4h */ case   14:  		/* lis R10, -32255 */
		/* 820A4FB4h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A4FB4h case   14:*/		return 0x820A4FB8;
		  /* 820A4FB8h */ case   15:  		/* addi R11, R20, 2224 */
		/* 820A4FB8h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R20,0x8B0);
		/* 820A4FB8h case   15:*/		return 0x820A4FBC;
		  /* 820A4FBCh */ case   16:  		/* addi R10, R10, -10828 */
		/* 820A4FBCh case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD5B4);
		/* 820A4FBCh case   16:*/		return 0x820A4FC0;
		  /* 820A4FC0h */ case   17:  		/* lbz R9, <#[R11]> */
		/* 820A4FC0h case   17:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A4FC0h case   17:*/		return 0x820A4FC4;
		  /* 820A4FC4h */ case   18:  		/* lbz R8, <#[R10]> */
		/* 820A4FC4h case   18:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A4FC4h case   18:*/		return 0x820A4FC8;
		  /* 820A4FC8h */ case   19:  		/* cmpwi CR0, R9, 0 */
		/* 820A4FC8h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A4FC8h case   19:*/		return 0x820A4FCC;
		  /* 820A4FCCh */ case   20:  		/* subf R9, R8, R9 */
		/* 820A4FCCh case   20:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A4FCCh case   20:*/		return 0x820A4FD0;
		  /* 820A4FD0h */ case   21:  		/* bc 12, CR0_EQ, 20 */
		/* 820A4FD0h case   21:*/		if ( regs.CR[0].eq ) { return 0x820A4FE4;  }
		/* 820A4FD0h case   21:*/		return 0x820A4FD4;
		  /* 820A4FD4h */ case   22:  		/* addi R11, R11, 1 */
		/* 820A4FD4h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A4FD4h case   22:*/		return 0x820A4FD8;
		  /* 820A4FD8h */ case   23:  		/* addi R10, R10, 1 */
		/* 820A4FD8h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A4FD8h case   23:*/		return 0x820A4FDC;
		  /* 820A4FDCh */ case   24:  		/* cmpwi CR6, R9, 0 */
		/* 820A4FDCh case   24:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A4FDCh case   24:*/		return 0x820A4FE0;
		  /* 820A4FE0h */ case   25:  		/* bc 12, CR6_EQ, -32 */
		/* 820A4FE0h case   25:*/		if ( regs.CR[6].eq ) { return 0x820A4FC0;  }
		/* 820A4FE0h case   25:*/		return 0x820A4FE4;
	}
	return 0x820A4FE4;
} // Block from 820A4F7Ch-820A4FE4h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820A4FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4FE4);
		  /* 820A4FE4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A4FE4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A4FE4h case    0:*/		return 0x820A4FE8;
		  /* 820A4FE8h */ case    1:  		/* bc 4, CR0_EQ, 2124 */
		/* 820A4FE8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A5834;  }
		/* 820A4FE8h case    1:*/		return 0x820A4FEC;
		  /* 820A4FECh */ case    2:  		/* lwz R11, <#[R7 + 12]> */
		/* 820A4FECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000000C) );
		/* 820A4FECh case    2:*/		return 0x820A4FF0;
		  /* 820A4FF0h */ case    3:  		/* stw R11, <#[R20 + 1668]> */
		/* 820A4FF0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000684) );
		/* 820A4FF0h case    3:*/		return 0x820A4FF4;
		  /* 820A4FF4h */ case    4:  		/* stw R18, <#[R7 + 12]> */
		/* 820A4FF4h case    4:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R7 + 0x0000000C) );
		/* 820A4FF4h case    4:*/		return 0x820A4FF8;
		  /* 820A4FF8h */ case    5:  		/* b 188 */
		/* 820A4FF8h case    5:*/		return 0x820A50B4;
		/* 820A4FF8h case    5:*/		return 0x820A4FFC;
	}
	return 0x820A4FFC;
} // Block from 820A4FE4h-820A4FFCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A4FFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A4FFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A4FFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A4FFC);
		  /* 820A4FFCh */ case    0:  		/* lwz R3, <#[R20 + 2204]> */
		/* 820A4FFCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R20 + 0x0000089C) );
		/* 820A4FFCh case    0:*/		return 0x820A5000;
		  /* 820A5000h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 820A5000h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A5000h case    1:*/		return 0x820A5004;
		  /* 820A5004h */ case    2:  		/* lwz R9, <#[R3 + 8]> */
		/* 820A5004h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 820A5004h case    2:*/		return 0x820A5008;
		  /* 820A5008h */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 820A5008h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820A5008h case    3:*/		return 0x820A500C;
		  /* 820A500Ch */ case    4:  		/* bc 4, CR6_LT, 76 */
		/* 820A500Ch case    4:*/		if ( !regs.CR[6].lt ) { return 0x820A5058;  }
		/* 820A500Ch case    4:*/		return 0x820A5010;
		  /* 820A5010h */ case    5:  		/* lbz R10, <#[R11]> */
		/* 820A5010h case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A5010h case    5:*/		return 0x820A5014;
		  /* 820A5014h */ case    6:  		/* extsb R10, R10 */
		/* 820A5014h case    6:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820A5014h case    6:*/		return 0x820A5018;
		  /* 820A5018h */ case    7:  		/* cmpwi CR6, R10, 32 */
		/* 820A5018h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000020);
		/* 820A5018h case    7:*/		return 0x820A501C;
		  /* 820A501Ch */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 820A501Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820A5030;  }
		/* 820A501Ch case    8:*/		return 0x820A5020;
		  /* 820A5020h */ case    9:  		/* cmpwi CR6, R10, 9 */
		/* 820A5020h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000009);
		/* 820A5020h case    9:*/		return 0x820A5024;
		  /* 820A5024h */ case   10:  		/* bc 12, CR6_LT, 32 */
		/* 820A5024h case   10:*/		if ( regs.CR[6].lt ) { return 0x820A5044;  }
		/* 820A5024h case   10:*/		return 0x820A5028;
		  /* 820A5028h */ case   11:  		/* cmpwi CR6, R10, 13 */
		/* 820A5028h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000D);
		/* 820A5028h case   11:*/		return 0x820A502C;
		  /* 820A502Ch */ case   12:  		/* bc 12, CR6_GT, 24 */
		/* 820A502Ch case   12:*/		if ( regs.CR[6].gt ) { return 0x820A5044;  }
		/* 820A502Ch case   12:*/		return 0x820A5030;
	}
	return 0x820A5030;
} // Block from 820A4FFCh-820A5030h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A5030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5030);
		  /* 820A5030h */ case    0:  		/* lwz R10, <#[R20 + 2204]> */
		/* 820A5030h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x0000089C) );
		/* 820A5030h case    0:*/		return 0x820A5034;
		  /* 820A5034h */ case    1:  		/* addi R11, R11, 1 */
		/* 820A5034h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A5034h case    1:*/		return 0x820A5038;
		  /* 820A5038h */ case    2:  		/* lwz R10, <#[R10 + 8]> */
		/* 820A5038h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820A5038h case    2:*/		return 0x820A503C;
		  /* 820A503Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820A503Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A503Ch case    3:*/		return 0x820A5040;
		  /* 820A5040h */ case    4:  		/* bc 12, CR6_LT, -48 */
		/* 820A5040h case    4:*/		if ( regs.CR[6].lt ) { return 0x820A5010;  }
		/* 820A5040h case    4:*/		return 0x820A5044;
	}
	return 0x820A5044;
} // Block from 820A5030h-820A5044h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A5044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5044);
		  /* 820A5044h */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 820A5044h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820A5044h case    0:*/		return 0x820A5048;
		  /* 820A5048h */ case    1:  		/* bc 4, CR6_LT, 16 */
		/* 820A5048h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820A5058;  }
		/* 820A5048h case    1:*/		return 0x820A504C;
		  /* 820A504Ch */ case    2:  		/* lbz R11, <#[R11]> */
		/* 820A504Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A504Ch case    2:*/		return 0x820A5050;
		  /* 820A5050h */ case    3:  		/* cmplwi CR6, R11, 40 */
		/* 820A5050h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000028);
		/* 820A5050h case    3:*/		return 0x820A5054;
		  /* 820A5054h */ case    4:  		/* bc 4, CR6_EQ, 2016 */
		/* 820A5054h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A5834;  }
		/* 820A5054h case    4:*/		return 0x820A5058;
	}
	return 0x820A5058;
} // Block from 820A5044h-820A5058h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A5058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5058);
		  /* 820A5058h */ case    0:  		/* addi R31, R20, 2216 */
		/* 820A5058h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R20,0x8A8);
		/* 820A5058h case    0:*/		return 0x820A505C;
		  /* 820A505Ch */ case    1:  		/* lwz R4, <#[R20 + 2256]> */
		/* 820A505Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R20 + 0x000008D0) );
		/* 820A505Ch case    1:*/		return 0x820A5060;
		  /* 820A5060h */ case    2:  		/* mr R5, R31 */
		/* 820A5060h case    2:*/		regs.R5 = regs.R31;
		/* 820A5060h case    2:*/		return 0x820A5064;
		  /* 820A5064h */ case    3:  		/* bl 12692 */
		/* 820A5064h case    3:*/		regs.LR = 0x820A5068; return 0x820A81F8;
		/* 820A5064h case    3:*/		return 0x820A5068;
		  /* 820A5068h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820A5068h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A5068h case    4:*/		return 0x820A506C;
		  /* 820A506Ch */ case    5:  		/* bc 12, CR0_LT, 1992 */
		/* 820A506Ch case    5:*/		if ( regs.CR[0].lt ) { return 0x820A5834;  }
		/* 820A506Ch case    5:*/		return 0x820A5070;
		  /* 820A5070h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 820A5070h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A5070h case    6:*/		return 0x820A5074;
		  /* 820A5074h */ case    7:  		/* cmpwi CR6, R11, 1 */
		/* 820A5074h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820A5074h case    7:*/		return 0x820A5078;
		  /* 820A5078h */ case    8:  		/* bc 4, CR6_EQ, 1980 */
		/* 820A5078h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A5834;  }
		/* 820A5078h case    8:*/		return 0x820A507C;
		  /* 820A507Ch */ case    9:  		/* lis R10, -32255 */
		/* 820A507Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A507Ch case    9:*/		return 0x820A5080;
		  /* 820A5080h */ case   10:  		/* addi R11, R20, 2224 */
		/* 820A5080h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R20,0x8B0);
		/* 820A5080h case   10:*/		return 0x820A5084;
		  /* 820A5084h */ case   11:  		/* addi R10, R10, -10828 */
		/* 820A5084h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD5B4);
		/* 820A5084h case   11:*/		return 0x820A5088;
		  /* 820A5088h */ case   12:  		/* lbz R9, <#[R11]> */
		/* 820A5088h case   12:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A5088h case   12:*/		return 0x820A508C;
		  /* 820A508Ch */ case   13:  		/* lbz R8, <#[R10]> */
		/* 820A508Ch case   13:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A508Ch case   13:*/		return 0x820A5090;
		  /* 820A5090h */ case   14:  		/* cmpwi CR0, R9, 0 */
		/* 820A5090h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A5090h case   14:*/		return 0x820A5094;
		  /* 820A5094h */ case   15:  		/* subf R9, R8, R9 */
		/* 820A5094h case   15:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A5094h case   15:*/		return 0x820A5098;
		  /* 820A5098h */ case   16:  		/* bc 12, CR0_EQ, 20 */
		/* 820A5098h case   16:*/		if ( regs.CR[0].eq ) { return 0x820A50AC;  }
		/* 820A5098h case   16:*/		return 0x820A509C;
		  /* 820A509Ch */ case   17:  		/* addi R11, R11, 1 */
		/* 820A509Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A509Ch case   17:*/		return 0x820A50A0;
		  /* 820A50A0h */ case   18:  		/* addi R10, R10, 1 */
		/* 820A50A0h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A50A0h case   18:*/		return 0x820A50A4;
		  /* 820A50A4h */ case   19:  		/* cmpwi CR6, R9, 0 */
		/* 820A50A4h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A50A4h case   19:*/		return 0x820A50A8;
		  /* 820A50A8h */ case   20:  		/* bc 12, CR6_EQ, -32 */
		/* 820A50A8h case   20:*/		if ( regs.CR[6].eq ) { return 0x820A5088;  }
		/* 820A50A8h case   20:*/		return 0x820A50AC;
	}
	return 0x820A50AC;
} // Block from 820A5058h-820A50ACh (21 instructions)

//////////////////////////////////////////////////////
// Block at 820A50ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A50AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A50AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A50AC);
		  /* 820A50ACh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A50ACh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A50ACh case    0:*/		return 0x820A50B0;
		  /* 820A50B0h */ case    1:  		/* bc 4, CR0_EQ, 1924 */
		/* 820A50B0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A5834;  }
		/* 820A50B0h case    1:*/		return 0x820A50B4;
	}
	return 0x820A50B4;
} // Block from 820A50ACh-820A50B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A50B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A50B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A50B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A50B4);
		  /* 820A50B4h */ case    0:  		/* lis R11, -32255 */
		/* 820A50B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A50B4h case    0:*/		return 0x820A50B8;
		  /* 820A50B8h */ case    1:  		/* li R29, 1 */
		/* 820A50B8h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820A50B8h case    1:*/		return 0x820A50BC;
		  /* 820A50BCh */ case    2:  		/* addi R30, R1, 100 */
		/* 820A50BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x64);
		/* 820A50BCh case    2:*/		return 0x820A50C0;
		  /* 820A50C0h */ case    3:  		/* mr R31, R18 */
		/* 820A50C0h case    3:*/		regs.R31 = regs.R18;
		/* 820A50C0h case    3:*/		return 0x820A50C4;
		  /* 820A50C4h */ case    4:  		/* addi R28, R11, -9680 */
		/* 820A50C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFDA30);
		/* 820A50C4h case    4:*/		return 0x820A50C8;
		  /* 820A50C8h */ case    5:  		/* addi R4, R1, 112 */
		/* 820A50C8h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820A50C8h case    5:*/		return 0x820A50CC;
		  /* 820A50CCh */ case    6:  		/* mr R3, R20 */
		/* 820A50CCh case    6:*/		regs.R3 = regs.R20;
		/* 820A50CCh case    6:*/		return 0x820A50D0;
		  /* 820A50D0h */ case    7:  		/* bl -2088 */
		/* 820A50D0h case    7:*/		regs.LR = 0x820A50D4; return 0x820A48A8;
		/* 820A50D0h case    7:*/		return 0x820A50D4;
		  /* 820A50D4h */ case    8:  		/* lwz R11, <#[R20 + 1644]> */
		/* 820A50D4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x0000066C) );
		/* 820A50D4h case    8:*/		return 0x820A50D8;
		  /* 820A50D8h */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 820A50D8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A50D8h case    9:*/		return 0x820A50DC;
		  /* 820A50DCh */ case   10:  		/* bc 4, CR6_EQ, 1800 */
		/* 820A50DCh case   10:*/		if ( !regs.CR[6].eq ) { return 0x820A57E4;  }
		/* 820A50DCh case   10:*/		return 0x820A50E0;
		  /* 820A50E0h */ case   11:  		/* lwz R11, <#[R1 + 112]> */
		/* 820A50E0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820A50E0h case   11:*/		return 0x820A50E4;
		  /* 820A50E4h */ case   12:  		/* cmpwi CR6, R11, 17 */
		/* 820A50E4h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820A50E4h case   12:*/		return 0x820A50E8;
		  /* 820A50E8h */ case   13:  		/* bc 12, CR6_EQ, 384 */
		/* 820A50E8h case   13:*/		if ( regs.CR[6].eq ) { return 0x820A5268;  }
		/* 820A50E8h case   13:*/		return 0x820A50EC;
		  /* 820A50ECh */ case   14:  		/* cmpwi CR6, R11, 16 */
		/* 820A50ECh case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820A50ECh case   14:*/		return 0x820A50F0;
		  /* 820A50F0h */ case   15:  		/* bc 12, CR6_EQ, 280 */
		/* 820A50F0h case   15:*/		if ( regs.CR[6].eq ) { return 0x820A5208;  }
		/* 820A50F0h case   15:*/		return 0x820A50F4;
		  /* 820A50F4h */ case   16:  		/* lwz R10, <#[R30]> */
		/* 820A50F4h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820A50F4h case   16:*/		return 0x820A50F8;
		  /* 820A50F8h */ case   17:  		/* cmplwi CR6, R10, 0 */
		/* 820A50F8h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A50F8h case   17:*/		return 0x820A50FC;
		  /* 820A50FCh */ case   18:  		/* bc 4, CR6_EQ, 64 */
		/* 820A50FCh case   18:*/		if ( !regs.CR[6].eq ) { return 0x820A513C;  }
		/* 820A50FCh case   18:*/		return 0x820A5100;
		  /* 820A5100h */ case   19:  		/* li R3, 20 */
		/* 820A5100h case   19:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820A5100h case   19:*/		return 0x820A5104;
		  /* 820A5104h */ case   20:  		/* bl 147748 */
		/* 820A5104h case   20:*/		regs.LR = 0x820A5108; return 0x820C9228;
		/* 820A5104h case   20:*/		return 0x820A5108;
		  /* 820A5108h */ case   21:  		/* cmplwi CR0, R3, 0 */
		/* 820A5108h case   21:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A5108h case   21:*/		return 0x820A510C;
		  /* 820A510Ch */ case   22:  		/* bc 12, CR0_EQ, 24 */
		/* 820A510Ch case   22:*/		if ( regs.CR[0].eq ) { return 0x820A5124;  }
		/* 820A510Ch case   22:*/		return 0x820A5110;
		  /* 820A5110h */ case   23:  		/* mr R6, R28 */
		/* 820A5110h case   23:*/		regs.R6 = regs.R28;
		/* 820A5110h case   23:*/		return 0x820A5114;
		  /* 820A5114h */ case   24:  		/* li R5, 0 */
		/* 820A5114h case   24:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A5114h case   24:*/		return 0x820A5118;
		  /* 820A5118h */ case   25:  		/* li R4, 0 */
		/* 820A5118h case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A5118h case   25:*/		return 0x820A511C;
		  /* 820A511Ch */ case   26:  		/* bl 148180 */
		/* 820A511Ch case   26:*/		regs.LR = 0x820A5120; return 0x820C93F0;
		/* 820A511Ch case   26:*/		return 0x820A5120;
		  /* 820A5120h */ case   27:  		/* b 8 */
		/* 820A5120h case   27:*/		return 0x820A5128;
		/* 820A5120h case   27:*/		return 0x820A5124;
	}
	return 0x820A5124;
} // Block from 820A50B4h-820A5124h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820A5124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5124);
		  /* 820A5124h */ case    0:  		/* mr R3, R18 */
		/* 820A5124h case    0:*/		regs.R3 = regs.R18;
		/* 820A5124h case    0:*/		return 0x820A5128;
	}
	return 0x820A5128;
} // Block from 820A5124h-820A5128h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5128);
		  /* 820A5128h */ case    0:  		/* stw R3, <#[R30]> */
		/* 820A5128h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A5128h case    0:*/		return 0x820A512C;
		  /* 820A512Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A512Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A512Ch case    1:*/		return 0x820A5130;
		  /* 820A5130h */ case    2:  		/* bc 12, CR6_EQ, 1716 */
		/* 820A5130h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A57E4;  }
		/* 820A5130h case    2:*/		return 0x820A5134;
		  /* 820A5134h */ case    3:  		/* lwz R11, <#[R1 + 112]> */
		/* 820A5134h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820A5134h case    3:*/		return 0x820A5138;
		  /* 820A5138h */ case    4:  		/* addi R31, R3, 8 */
		/* 820A5138h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x8);
		/* 820A5138h case    4:*/		return 0x820A513C;
	}
	return 0x820A513C;
} // Block from 820A5128h-820A513Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A513Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A513C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A513C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A513C);
		  /* 820A513Ch */ case    0:  		/* cmplwi CR6, R29, 1 */
		/* 820A513Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000001);
		/* 820A513Ch case    0:*/		return 0x820A5140;
		  /* 820A5140h */ case    1:  		/* bc 4, CR6_EQ, 60 */
		/* 820A5140h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A517C;  }
		/* 820A5140h case    1:*/		return 0x820A5144;
		  /* 820A5144h */ case    2:  		/* cmpwi CR6, R11, 1 */
		/* 820A5144h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820A5144h case    2:*/		return 0x820A5148;
		  /* 820A5148h */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 820A5148h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A517C;  }
		/* 820A5148h case    3:*/		return 0x820A514C;
		  /* 820A514Ch */ case    4:  		/* lbz R11, <#[R1 + 120]> */
		/* 820A514Ch case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820A514Ch case    4:*/		return 0x820A5150;
		  /* 820A5150h */ case    5:  		/* extsb R11, R11 */
		/* 820A5150h case    5:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820A5150h case    5:*/		return 0x820A5154;
		  /* 820A5154h */ case    6:  		/* cmpwi CR6, R11, 44 */
		/* 820A5154h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002C);
		/* 820A5154h case    6:*/		return 0x820A5158;
		  /* 820A5158h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820A5158h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A5164;  }
		/* 820A5158h case    7:*/		return 0x820A515C;
		  /* 820A515Ch */ case    8:  		/* cmpwi CR6, R11, 41 */
		/* 820A515Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000029);
		/* 820A515Ch case    8:*/		return 0x820A5160;
		  /* 820A5160h */ case    9:  		/* bc 4, CR6_EQ, 28 */
		/* 820A5160h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A517C;  }
		/* 820A5160h case    9:*/		return 0x820A5164;
	}
	return 0x820A5164;
} // Block from 820A513Ch-820A5164h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A5164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5164);
		  /* 820A5164h */ case    0:  		/* lbz R11, <#[R1 + 121]> */
		/* 820A5164h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000079) );
		/* 820A5164h case    0:*/		return 0x820A5168;
		  /* 820A5168h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820A5168h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A5168h case    1:*/		return 0x820A516C;
		  /* 820A516Ch */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 820A516Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A517C;  }
		/* 820A516Ch case    2:*/		return 0x820A5170;
		  /* 820A5170h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 820A5170h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A5170h case    3:*/		return 0x820A5174;
		  /* 820A5174h */ case    4:  		/* addi R30, R11, 12 */
		/* 820A5174h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xC);
		/* 820A5174h case    4:*/		return 0x820A5178;
		  /* 820A5178h */ case    5:  		/* b 64 */
		/* 820A5178h case    5:*/		return 0x820A51B8;
		/* 820A5178h case    5:*/		return 0x820A517C;
	}
	return 0x820A517C;
} // Block from 820A5164h-820A517Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A517Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A517C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A517C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A517C);
		  /* 820A517Ch */ case    0:  		/* li R3, 56 */
		/* 820A517Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A517Ch case    0:*/		return 0x820A5180;
		  /* 820A5180h */ case    1:  		/* bl 147624 */
		/* 820A5180h case    1:*/		regs.LR = 0x820A5184; return 0x820C9228;
		/* 820A5180h case    1:*/		return 0x820A5184;
		  /* 820A5184h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820A5184h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A5184h case    2:*/		return 0x820A5188;
		  /* 820A5188h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820A5188h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A5198;  }
		/* 820A5188h case    3:*/		return 0x820A518C;
		  /* 820A518Ch */ case    4:  		/* addi R4, R1, 112 */
		/* 820A518Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820A518Ch case    4:*/		return 0x820A5190;
		  /* 820A5190h */ case    5:  		/* bl 149184 */
		/* 820A5190h case    5:*/		regs.LR = 0x820A5194; return 0x820C9850;
		/* 820A5190h case    5:*/		return 0x820A5194;
		  /* 820A5194h */ case    6:  		/* b 8 */
		/* 820A5194h case    6:*/		return 0x820A519C;
		/* 820A5194h case    6:*/		return 0x820A5198;
	}
	return 0x820A5198;
} // Block from 820A517Ch-820A5198h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A5198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5198);
		  /* 820A5198h */ case    0:  		/* mr R3, R18 */
		/* 820A5198h case    0:*/		regs.R3 = regs.R18;
		/* 820A5198h case    0:*/		return 0x820A519C;
	}
	return 0x820A519C;
} // Block from 820A5198h-820A519Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A519Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A519C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A519C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A519C);
		  /* 820A519Ch */ case    0:  		/* stw R3, <#[R31]> */
		/* 820A519Ch case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A519Ch case    0:*/		return 0x820A51A0;
		  /* 820A51A0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A51A0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A51A0h case    1:*/		return 0x820A51A4;
		  /* 820A51A4h */ case    2:  		/* bc 12, CR6_EQ, 1600 */
		/* 820A51A4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A57E4;  }
		/* 820A51A4h case    2:*/		return 0x820A51A8;
		  /* 820A51A8h */ case    3:  		/* lwz R11, <#[R1 + 112]> */
		/* 820A51A8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820A51A8h case    3:*/		return 0x820A51AC;
		  /* 820A51ACh */ case    4:  		/* addi R31, R3, 12 */
		/* 820A51ACh case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0xC);
		/* 820A51ACh case    4:*/		return 0x820A51B0;
		  /* 820A51B0h */ case    5:  		/* cmpwi CR6, R11, 1 */
		/* 820A51B0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820A51B0h case    5:*/		return 0x820A51B4;
		  /* 820A51B4h */ case    6:  		/* bc 4, CR6_EQ, 84 */
		/* 820A51B4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A5208;  }
		/* 820A51B4h case    6:*/		return 0x820A51B8;
	}
	return 0x820A51B8;
} // Block from 820A519Ch-820A51B8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A51B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A51B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A51B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A51B8);
		  /* 820A51B8h */ case    0:  		/* lbz R11, <#[R1 + 121]> */
		/* 820A51B8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000079) );
		/* 820A51B8h case    0:*/		return 0x820A51BC;
		  /* 820A51BCh */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820A51BCh case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A51BCh case    1:*/		return 0x820A51C0;
		  /* 820A51C0h */ case    2:  		/* bc 4, CR0_EQ, 72 */
		/* 820A51C0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A5208;  }
		/* 820A51C0h case    2:*/		return 0x820A51C4;
		  /* 820A51C4h */ case    3:  		/* lbz R11, <#[R1 + 120]> */
		/* 820A51C4h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820A51C4h case    3:*/		return 0x820A51C8;
		  /* 820A51C8h */ case    4:  		/* extsb R11, R11 */
		/* 820A51C8h case    4:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820A51C8h case    4:*/		return 0x820A51CC;
		  /* 820A51CCh */ case    5:  		/* cmpwi CR6, R11, 40 */
		/* 820A51CCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000028);
		/* 820A51CCh case    5:*/		return 0x820A51D0;
		  /* 820A51D0h */ case    6:  		/* bc 12, CR6_EQ, 52 */
		/* 820A51D0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A5204;  }
		/* 820A51D0h case    6:*/		return 0x820A51D4;
		  /* 820A51D4h */ case    7:  		/* cmpwi CR6, R11, 41 */
		/* 820A51D4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000029);
		/* 820A51D4h case    7:*/		return 0x820A51D8;
		  /* 820A51D8h */ case    8:  		/* bc 12, CR6_EQ, 36 */
		/* 820A51D8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820A51FC;  }
		/* 820A51D8h case    8:*/		return 0x820A51DC;
		  /* 820A51DCh */ case    9:  		/* cmpwi CR6, R11, 91 */
		/* 820A51DCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005B);
		/* 820A51DCh case    9:*/		return 0x820A51E0;
		  /* 820A51E0h */ case   10:  		/* bc 12, CR6_EQ, 36 */
		/* 820A51E0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A5204;  }
		/* 820A51E0h case   10:*/		return 0x820A51E4;
		  /* 820A51E4h */ case   11:  		/* cmpwi CR6, R11, 93 */
		/* 820A51E4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005D);
		/* 820A51E4h case   11:*/		return 0x820A51E8;
		  /* 820A51E8h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 820A51E8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820A51FC;  }
		/* 820A51E8h case   12:*/		return 0x820A51EC;
		  /* 820A51ECh */ case   13:  		/* cmpwi CR6, R11, 123 */
		/* 820A51ECh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000007B);
		/* 820A51ECh case   13:*/		return 0x820A51F0;
		  /* 820A51F0h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 820A51F0h case   14:*/		if ( regs.CR[6].eq ) { return 0x820A5204;  }
		/* 820A51F0h case   14:*/		return 0x820A51F4;
		  /* 820A51F4h */ case   15:  		/* cmpwi CR6, R11, 125 */
		/* 820A51F4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000007D);
		/* 820A51F4h case   15:*/		return 0x820A51F8;
		  /* 820A51F8h */ case   16:  		/* bc 4, CR6_EQ, 16 */
		/* 820A51F8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820A5208;  }
		/* 820A51F8h case   16:*/		return 0x820A51FC;
	}
	return 0x820A51FC;
} // Block from 820A51B8h-820A51FCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A51FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A51FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A51FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A51FC);
		  /* 820A51FCh */ case    0:  		/* addi R29, R29, -1 */
		/* 820A51FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820A51FCh case    0:*/		return 0x820A5200;
		  /* 820A5200h */ case    1:  		/* b 8 */
		/* 820A5200h case    1:*/		return 0x820A5208;
		/* 820A5200h case    1:*/		return 0x820A5204;
	}
	return 0x820A5204;
} // Block from 820A51FCh-820A5204h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A5204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5204);
		  /* 820A5204h */ case    0:  		/* addi R29, R29, 1 */
		/* 820A5204h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820A5204h case    0:*/		return 0x820A5208;
	}
	return 0x820A5208;
} // Block from 820A5204h-820A5208h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5208);
		  /* 820A5208h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820A5208h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820A5208h case    0:*/		return 0x820A520C;
		  /* 820A520Ch */ case    1:  		/* bc 4, CR6_EQ, -324 */
		/* 820A520Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A50C8;  }
		/* 820A520Ch case    1:*/		return 0x820A5210;
		  /* 820A5210h */ case    2:  		/* lwz R21, <#[R1 + 100]> */
		/* 820A5210h case    2:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 820A5210h case    2:*/		return 0x820A5214;
		  /* 820A5214h */ case    3:  		/* mr R10, R19 */
		/* 820A5214h case    3:*/		regs.R10 = regs.R19;
		/* 820A5214h case    3:*/		return 0x820A5218;
		  /* 820A5218h */ case    4:  		/* mr R11, R21 */
		/* 820A5218h case    4:*/		regs.R11 = regs.R21;
		/* 820A5218h case    4:*/		return 0x820A521C;
		  /* 820A521Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820A521Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A521Ch case    5:*/		return 0x820A5220;
		  /* 820A5220h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 820A5220h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A5240;  }
		/* 820A5220h case    6:*/		return 0x820A5224;
		  /* 820A5224h */ case    7:  		/* lwz R9, <#[R11 + 8]> */
		/* 820A5224h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820A5224h case    7:*/		return 0x820A5228;
		  /* 820A5228h */ case    8:  		/* cmplwi CR6, R9, 0 */
		/* 820A5228h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A5228h case    8:*/		return 0x820A522C;
		  /* 820A522Ch */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 820A522Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820A5240;  }
		/* 820A522Ch case    9:*/		return 0x820A5230;
		  /* 820A5230h */ case   10:  		/* lwz R10, <#[R10 + 12]> */
		/* 820A5230h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820A5230h case   10:*/		return 0x820A5234;
		  /* 820A5234h */ case   11:  		/* lwz R11, <#[R11 + 12]> */
		/* 820A5234h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A5234h case   11:*/		return 0x820A5238;
		  /* 820A5238h */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 820A5238h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A5238h case   12:*/		return 0x820A523C;
		  /* 820A523Ch */ case   13:  		/* bc 4, CR6_EQ, -32 */
		/* 820A523Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A521C;  }
		/* 820A523Ch case   13:*/		return 0x820A5240;
	}
	return 0x820A5240;
} // Block from 820A5208h-820A5240h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A5240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5240);
		  /* 820A5240h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820A5240h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A5240h case    0:*/		return 0x820A5244;
		  /* 820A5244h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820A5244h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A5284;  }
		/* 820A5244h case    1:*/		return 0x820A5248;
		  /* 820A5248h */ case    2:  		/* lis R11, -32255 */
		/* 820A5248h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A5248h case    2:*/		return 0x820A524C;
		  /* 820A524Ch */ case    3:  		/* addi R6, R11, -9724 */
		/* 820A524Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFDA04);
		/* 820A524Ch case    3:*/		return 0x820A5250;
		  /* 820A5250h */ case    4:  		/* li R5, 1516 */
		/* 820A5250h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x5EC);
		/* 820A5250h case    4:*/		return 0x820A5254;
		  /* 820A5254h */ case    5:  		/* lwz R7, <#[R1 + 248]> */
		/* 820A5254h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000F8) );
		/* 820A5254h case    5:*/		return 0x820A5258;
		  /* 820A5258h */ case    6:  		/* addi R4, R1, 240 */
		/* 820A5258h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xF0);
		/* 820A5258h case    6:*/		return 0x820A525C;
		  /* 820A525Ch */ case    7:  		/* addi R3, R20, 24 */
		/* 820A525Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R20,0x18);
		/* 820A525Ch case    7:*/		return 0x820A5260;
		  /* 820A5260h */ case    8:  		/* bl 7984 */
		/* 820A5260h case    8:*/		regs.LR = 0x820A5264; return 0x820A7190;
		/* 820A5260h case    8:*/		return 0x820A5264;
		  /* 820A5264h */ case    9:  		/* b 1408 */
		/* 820A5264h case    9:*/		return 0x820A57E4;
		/* 820A5264h case    9:*/		return 0x820A5268;
	}
	return 0x820A5268;
} // Block from 820A5240h-820A5268h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A5268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5268);
		  /* 820A5268h */ case    0:  		/* lis R11, -32255 */
		/* 820A5268h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A5268h case    0:*/		return 0x820A526C;
		  /* 820A526Ch */ case    1:  		/* li R5, 1515 */
		/* 820A526Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x5EB);
		/* 820A526Ch case    1:*/		return 0x820A5270;
		  /* 820A5270h */ case    2:  		/* addi R6, R11, -9768 */
		/* 820A5270h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD9D8);
		/* 820A5270h case    2:*/		return 0x820A5274;
		  /* 820A5274h */ case    3:  		/* addi R4, R1, 240 */
		/* 820A5274h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xF0);
		/* 820A5274h case    3:*/		return 0x820A5278;
		  /* 820A5278h */ case    4:  		/* addi R3, R20, 24 */
		/* 820A5278h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R20,0x18);
		/* 820A5278h case    4:*/		return 0x820A527C;
		  /* 820A527Ch */ case    5:  		/* bl 7956 */
		/* 820A527Ch case    5:*/		regs.LR = 0x820A5280; return 0x820A7190;
		/* 820A527Ch case    5:*/		return 0x820A5280;
		  /* 820A5280h */ case    6:  		/* b 1380 */
		/* 820A5280h case    6:*/		return 0x820A57E4;
		/* 820A5280h case    6:*/		return 0x820A5284;
	}
	return 0x820A5284;
} // Block from 820A5268h-820A5284h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A5284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5284);
		  /* 820A5284h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820A5284h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A5284h case    0:*/		return 0x820A5288;
		  /* 820A5288h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820A5288h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A5298;  }
		/* 820A5288h case    1:*/		return 0x820A528C;
		  /* 820A528Ch */ case    2:  		/* lis R11, -32255 */
		/* 820A528Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A528Ch case    2:*/		return 0x820A5290;
		  /* 820A5290h */ case    3:  		/* addi R6, R11, -9804 */
		/* 820A5290h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD9B4);
		/* 820A5290h case    3:*/		return 0x820A5294;
		  /* 820A5294h */ case    4:  		/* b -68 */
		/* 820A5294h case    4:*/		return 0x820A5250;
		/* 820A5294h case    4:*/		return 0x820A5298;
	}
	return 0x820A5298;
} // Block from 820A5284h-820A5298h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A5298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5298);
		  /* 820A5298h */ case    0:  		/* mr R28, R18 */
		/* 820A5298h case    0:*/		regs.R28 = regs.R18;
		/* 820A5298h case    0:*/		return 0x820A529C;
		  /* 820A529Ch */ case    1:  		/* mr R29, R18 */
		/* 820A529Ch case    1:*/		regs.R29 = regs.R18;
		/* 820A529Ch case    1:*/		return 0x820A52A0;
		  /* 820A52A0h */ case    2:  		/* mr R25, R18 */
		/* 820A52A0h case    2:*/		regs.R25 = regs.R18;
		/* 820A52A0h case    2:*/		return 0x820A52A4;
		  /* 820A52A4h */ case    3:  		/* addi R30, R1, 96 */
		/* 820A52A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x60);
		/* 820A52A4h case    3:*/		return 0x820A52A8;
		  /* 820A52A8h */ case    4:  		/* mr R24, R27 */
		/* 820A52A8h case    4:*/		regs.R24 = regs.R27;
		/* 820A52A8h case    4:*/		return 0x820A52AC;
		  /* 820A52ACh */ case    5:  		/* cmplwi CR6, R27, 0 */
		/* 820A52ACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820A52ACh case    5:*/		return 0x820A52B0;
		  /* 820A52B0h */ case    6:  		/* bc 12, CR6_EQ, 852 */
		/* 820A52B0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A5604;  }
		/* 820A52B0h case    6:*/		return 0x820A52B4;
		  /* 820A52B4h */ case    7:  		/* lis R11, -32255 */
		/* 820A52B4h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A52B4h case    7:*/		return 0x820A52B8;
		  /* 820A52B8h */ case    8:  		/* lis R10, -32255 */
		/* 820A52B8h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A52B8h case    8:*/		return 0x820A52BC;
		  /* 820A52BCh */ case    9:  		/* addi R23, R11, -9808 */
		/* 820A52BCh case    9:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R11,0xFFFFD9B0);
		/* 820A52BCh case    9:*/		return 0x820A52C0;
	}
	return 0x820A52C0;
} // Block from 820A5298h-820A52C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A52C0h
// Function '?GetToken@CPreProcessor@D3DXShader@@QAAJPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A52C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A52C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A52C0);
		  /* 820A52C0h */ case    0:  		/* addi R22, R10, -9880 */
		/* 820A52C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R10,0xFFFFD968);
		/* 820A52C0h case    0:*/		return 0x820A52C4;
		  /* 820A52C4h */ case    1:  		/* addi R31, R24, 16 */
		/* 820A52C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R24,0x10);
		/* 820A52C4h case    1:*/		return 0x820A52C8;
		  /* 820A52C8h */ case    2:  		/* mr R26, R30 */
		/* 820A52C8h case    2:*/		regs.R26 = regs.R30;
		/* 820A52C8h case    2:*/		return 0x820A52CC;
		  /* 820A52CCh */ case    3:  		/* cmpwi CR6, R28, 0 */
		/* 820A52CCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820A52CCh case    3:*/		return 0x820A52D0;
		  /* 820A52D0h */ case    4:  		/* bc 4, CR6_EQ, 160 */
		/* 820A52D0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A5370;  }
		/* 820A52D0h case    4:*/		return 0x820A52D4;
		  /* 820A52D4h */ case    5:  		/* cmpwi CR6, R29, 0 */
		/* 820A52D4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820A52D4h case    5:*/		return 0x820A52D8;
		  /* 820A52D8h */ case    6:  		/* bc 4, CR6_EQ, 152 */
		/* 820A52D8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A5370;  }
		/* 820A52D8h case    6:*/		return 0x820A52DC;
		  /* 820A52DCh */ case    7:  		/* lwz R8, <#[R31]> */
		/* 820A52DCh case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 820A52DCh case    7:*/		return 0x820A52E0;
		  /* 820A52E0h */ case    8:  		/* cmpwi CR6, R8, 1 */
		/* 820A52E0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820A52E0h case    8:*/		return 0x820A52E4;
		  /* 820A52E4h */ case    9:  		/* bc 4, CR6_EQ, 140 */
		/* 820A52E4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A5370;  }
		/* 820A52E4h case    9:*/		return 0x820A52E8;
		  /* 820A52E8h */ case   10:  		/* mr R10, R22 */
		/* 820A52E8h case   10:*/		regs.R10 = regs.R22;
		/* 820A52E8h case   10:*/		return 0x820A52EC;
		  /* 820A52ECh */ case   11:  		/* addi R11, R31, 8 */
		/* 820A52ECh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x8);
		/* 820A52ECh case   11:*/		return 0x820A52F0;
		  /* 820A52F0h */ case   12:  		/* lbz R9, <#[R11]> */
		/* 820A52F0h case   12:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A52F0h case   12:*/		return 0x820A52F4;
		  /* 820A52F4h */ case   13:  		/* lbz R7, <#[R10]> */
		/* 820A52F4h case   13:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A52F4h case   13:*/		return 0x820A52F8;
		  /* 820A52F8h */ case   14:  		/* cmpwi CR0, R9, 0 */
		/* 820A52F8h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A52F8h case   14:*/		return 0x820A52FC;
		  /* 820A52FCh */ case   15:  		/* subf R9, R7, R9 */
		/* 820A52FCh case   15:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A52FCh case   15:*/		return 0x820A5300;
		  /* 820A5300h */ case   16:  		/* bc 12, CR0_EQ, 20 */
		/* 820A5300h case   16:*/		if ( regs.CR[0].eq ) { return 0x820A5314;  }
		/* 820A5300h case   16:*/		return 0x820A5304;
		  /* 820A5304h */ case   17:  		/* addi R11, R11, 1 */
		/* 820A5304h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A5304h case   17:*/		return 0x820A5308;
		  /* 820A5308h */ case   18:  		/* addi R10, R10, 1 */
		/* 820A5308h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A5308h case   18:*/		return 0x820A530C;
		  /* 820A530Ch */ case   19:  		/* cmpwi CR6, R9, 0 */
		/* 820A530Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A530Ch case   19:*/		return 0x820A5310;
		  /* 820A5310h */ case   20:  		/* bc 12, CR6_EQ, -32 */
		/* 820A5310h case   20:*/		if ( regs.CR[6].eq ) { return 0x820A52F0;  }
		/* 820A5310h case   20:*/		return 0x820A5314;
	}
	return 0x820A5314;
} // Block from 820A52C0h-820A5314h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820A5314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5314);
		  /* 820A5314h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A5314h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A5314h case    0:*/		return 0x820A5318;
		  /* 820A5318h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A5318h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A5328;  }
		/* 820A5318h case    1:*/		return 0x820A531C;
		  /* 820A531Ch */ case    2:  		/* mr R25, R31 */
		/* 820A531Ch case    2:*/		regs.R25 = regs.R31;
		/* 820A531Ch case    2:*/		return 0x820A5320;
		  /* 820A5320h */ case    3:  		/* li R28, 1 */
		/* 820A5320h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820A5320h case    3:*/		return 0x820A5324;
		  /* 820A5324h */ case    4:  		/* b 724 */
		/* 820A5324h case    4:*/		return 0x820A55F8;
		/* 820A5324h case    4:*/		return 0x820A5328;
	}
	return 0x820A5328;
} // Block from 820A5314h-820A5328h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A5328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5328);
		  /* 820A5328h */ case    0:  		/* cmpwi CR6, R8, 1 */
		/* 820A5328h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820A5328h case    0:*/		return 0x820A532C;
		  /* 820A532Ch */ case    1:  		/* bc 4, CR6_EQ, 68 */
		/* 820A532Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A5370;  }
		/* 820A532Ch case    1:*/		return 0x820A5330;
		  /* 820A5330h */ case    2:  		/* mr R10, R23 */
		/* 820A5330h case    2:*/		regs.R10 = regs.R23;
		/* 820A5330h case    2:*/		return 0x820A5334;
		  /* 820A5334h */ case    3:  		/* addi R11, R31, 8 */
		/* 820A5334h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x8);
		/* 820A5334h case    3:*/		return 0x820A5338;
		  /* 820A5338h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820A5338h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A5338h case    4:*/		return 0x820A533C;
		  /* 820A533Ch */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820A533Ch case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A533Ch case    5:*/		return 0x820A5340;
		  /* 820A5340h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820A5340h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A5340h case    6:*/		return 0x820A5344;
		  /* 820A5344h */ case    7:  		/* subf R9, R8, R9 */
		/* 820A5344h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A5344h case    7:*/		return 0x820A5348;
		  /* 820A5348h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820A5348h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A535C;  }
		/* 820A5348h case    8:*/		return 0x820A534C;
		  /* 820A534Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 820A534Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A534Ch case    9:*/		return 0x820A5350;
		  /* 820A5350h */ case   10:  		/* addi R10, R10, 1 */
		/* 820A5350h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A5350h case   10:*/		return 0x820A5354;
		  /* 820A5354h */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820A5354h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A5354h case   11:*/		return 0x820A5358;
		  /* 820A5358h */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820A5358h case   12:*/		if ( regs.CR[6].eq ) { return 0x820A5338;  }
		/* 820A5358h case   12:*/		return 0x820A535C;
	}
	return 0x820A535C;
} // Block from 820A5328h-820A535Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A535Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A535C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A535C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A535C);
		  /* 820A535Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A535Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A535Ch case    0:*/		return 0x820A5360;
		  /* 820A5360h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A5360h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A5370;  }
		/* 820A5360h case    1:*/		return 0x820A5364;
		  /* 820A5364h */ case    2:  		/* mr R25, R31 */
		/* 820A5364h case    2:*/		regs.R25 = regs.R31;
		/* 820A5364h case    2:*/		return 0x820A5368;
		  /* 820A5368h */ case    3:  		/* li R29, 1 */
		/* 820A5368h case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820A5368h case    3:*/		return 0x820A536C;
		  /* 820A536Ch */ case    4:  		/* b 652 */
		/* 820A536Ch case    4:*/		return 0x820A55F8;
		/* 820A536Ch case    4:*/		return 0x820A5370;
	}
	return 0x820A5370;
} // Block from 820A535Ch-820A5370h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A5370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5370);
		  /* 820A5370h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A5370h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A5370h case    0:*/		return 0x820A5374;
		  /* 820A5374h */ case    1:  		/* cmpwi CR6, R11, 11 */
		/* 820A5374h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820A5374h case    1:*/		return 0x820A5378;
		  /* 820A5378h */ case    2:  		/* bc 4, CR6_EQ, 164 */
		/* 820A5378h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A541C;  }
		/* 820A5378h case    2:*/		return 0x820A537C;
		  /* 820A537Ch */ case    3:  		/* lwz R7, <#[R31 + 8]> */
		/* 820A537Ch case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 820A537Ch case    3:*/		return 0x820A5380;
		  /* 820A5380h */ case    4:  		/* mr R9, R19 */
		/* 820A5380h case    4:*/		regs.R9 = regs.R19;
		/* 820A5380h case    4:*/		return 0x820A5384;
		  /* 820A5384h */ case    5:  		/* mr R6, R21 */
		/* 820A5384h case    5:*/		regs.R6 = regs.R21;
		/* 820A5384h case    5:*/		return 0x820A5388;
		  /* 820A5388h */ case    6:  		/* lwz R11, <#[R9 + 24]> */
		/* 820A5388h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000018) );
		/* 820A5388h case    6:*/		return 0x820A538C;
		  /* 820A538Ch */ case    7:  		/* mr R10, R7 */
		/* 820A538Ch case    7:*/		regs.R10 = regs.R7;
		/* 820A538Ch case    7:*/		return 0x820A5390;
		  /* 820A5390h */ case    8:  		/* lbz R8, <#[R11]> */
		/* 820A5390h case    8:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A5390h case    8:*/		return 0x820A5394;
		  /* 820A5394h */ case    9:  		/* lbz R5, <#[R10]> */
		/* 820A5394h case    9:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 820A5394h case    9:*/		return 0x820A5398;
		  /* 820A5398h */ case   10:  		/* cmpwi CR0, R8, 0 */
		/* 820A5398h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A5398h case   10:*/		return 0x820A539C;
		  /* 820A539Ch */ case   11:  		/* subf R8, R5, R8 */
		/* 820A539Ch case   11:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 820A539Ch case   11:*/		return 0x820A53A0;
		  /* 820A53A0h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 820A53A0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820A53B4;  }
		/* 820A53A0h case   12:*/		return 0x820A53A4;
		  /* 820A53A4h */ case   13:  		/* addi R11, R11, 1 */
		/* 820A53A4h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A53A4h case   13:*/		return 0x820A53A8;
		  /* 820A53A8h */ case   14:  		/* addi R10, R10, 1 */
		/* 820A53A8h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A53A8h case   14:*/		return 0x820A53AC;
		  /* 820A53ACh */ case   15:  		/* cmpwi CR6, R8, 0 */
		/* 820A53ACh case   15:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A53ACh case   15:*/		return 0x820A53B0;
		  /* 820A53B0h */ case   16:  		/* bc 12, CR6_EQ, -32 */
		/* 820A53B0h case   16:*/		if ( regs.CR[6].eq ) { return 0x820A5390;  }
		/* 820A53B0h case   16:*/		return 0x820A53B4;
	}
	return 0x820A53B4;
} // Block from 820A5370h-820A53B4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A53B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A53B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A53B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A53B4);
		  /* 820A53B4h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A53B4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A53B4h case    0:*/		return 0x820A53B8;
		  /* 820A53B8h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820A53B8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A53CC;  }
		/* 820A53B8h case    1:*/		return 0x820A53BC;
		  /* 820A53BCh */ case    2:  		/* lwz R9, <#[R9 + 12]> */
		/* 820A53BCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000000C) );
		/* 820A53BCh case    2:*/		return 0x820A53C0;
		  /* 820A53C0h */ case    3:  		/* lwz R6, <#[R6 + 12]> */
		/* 820A53C0h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x0000000C) );
		/* 820A53C0h case    3:*/		return 0x820A53C4;
		  /* 820A53C4h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 820A53C4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A53C4h case    4:*/		return 0x820A53C8;
		  /* 820A53C8h */ case    5:  		/* bc 4, CR6_EQ, -64 */
		/* 820A53C8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A5388;  }
		/* 820A53C8h case    5:*/		return 0x820A53CC;
	}
	return 0x820A53CC;
} // Block from 820A53B4h-820A53CCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A53CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A53CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A53CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A53CC);
		  /* 820A53CCh */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 820A53CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A53CCh case    0:*/		return 0x820A53D0;
		  /* 820A53D0h */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 820A53D0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A541C;  }
		/* 820A53D0h case    1:*/		return 0x820A53D4;
		  /* 820A53D4h */ case    2:  		/* lwz R31, <#[R6 + 8]> */
		/* 820A53D4h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R6 + 0x00000008) );
		/* 820A53D4h case    2:*/		return 0x820A53D8;
		  /* 820A53D8h */ case    3:  		/* b 56 */
		/* 820A53D8h case    3:*/		return 0x820A5410;
		/* 820A53D8h case    3:*/		return 0x820A53DC;
		  /* 820A53DCh */ case    4:  		/* li R3, 56 */
		/* 820A53DCh case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A53DCh case    4:*/		return 0x820A53E0;
		  /* 820A53E0h */ case    5:  		/* bl 147016 */
		/* 820A53E0h case    5:*/		regs.LR = 0x820A53E4; return 0x820C9228;
		/* 820A53E0h case    5:*/		return 0x820A53E4;
		  /* 820A53E4h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820A53E4h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A53E4h case    6:*/		return 0x820A53E8;
		  /* 820A53E8h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 820A53E8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A53F8;  }
		/* 820A53E8h case    7:*/		return 0x820A53EC;
		  /* 820A53ECh */ case    8:  		/* addi R4, R31, 16 */
		/* 820A53ECh case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 820A53ECh case    8:*/		return 0x820A53F0;
		  /* 820A53F0h */ case    9:  		/* bl 148576 */
		/* 820A53F0h case    9:*/		regs.LR = 0x820A53F4; return 0x820C9850;
		/* 820A53F0h case    9:*/		return 0x820A53F4;
		  /* 820A53F4h */ case   10:  		/* b 8 */
		/* 820A53F4h case   10:*/		return 0x820A53FC;
		/* 820A53F4h case   10:*/		return 0x820A53F8;
	}
	return 0x820A53F8;
} // Block from 820A53CCh-820A53F8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A53F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A53F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A53F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A53F8);
		  /* 820A53F8h */ case    0:  		/* mr R3, R18 */
		/* 820A53F8h case    0:*/		regs.R3 = regs.R18;
		/* 820A53F8h case    0:*/		return 0x820A53FC;
	}
	return 0x820A53FC;
} // Block from 820A53F8h-820A53FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A53FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A53FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A53FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A53FC);
		  /* 820A53FCh */ case    0:  		/* stw R3, <#[R30]> */
		/* 820A53FCh case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A53FCh case    0:*/		return 0x820A5400;
		  /* 820A5400h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A5400h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A5400h case    1:*/		return 0x820A5404;
		  /* 820A5404h */ case    2:  		/* bc 12, CR6_EQ, 992 */
		/* 820A5404h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A57E4;  }
		/* 820A5404h case    2:*/		return 0x820A5408;
		  /* 820A5408h */ case    3:  		/* lwz R31, <#[R31 + 12]> */
		/* 820A5408h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A5408h case    3:*/		return 0x820A540C;
		  /* 820A540Ch */ case    4:  		/* addi R30, R3, 12 */
		/* 820A540Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0xC);
		/* 820A540Ch case    4:*/		return 0x820A5410;
	}
	return 0x820A5410;
} // Block from 820A53FCh-820A5410h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A5410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5410);
		  /* 820A5410h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820A5410h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A5410h case    0:*/		return 0x820A5414;
		  /* 820A5414h */ case    1:  		/* bc 4, CR6_EQ, -56 */
		/* 820A5414h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A53DC;  }
		/* 820A5414h case    1:*/		return 0x820A5418;
		  /* 820A5418h */ case    2:  		/* b 52 */
		/* 820A5418h case    2:*/		return 0x820A544C;
		/* 820A5418h case    2:*/		return 0x820A541C;
	}
	return 0x820A541C;
} // Block from 820A5410h-820A541Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A541Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A541C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A541C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A541C);
		  /* 820A541Ch */ case    0:  		/* li R3, 56 */
		/* 820A541Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A541Ch case    0:*/		return 0x820A5420;
		  /* 820A5420h */ case    1:  		/* bl 146952 */
		/* 820A5420h case    1:*/		regs.LR = 0x820A5424; return 0x820C9228;
		/* 820A5420h case    1:*/		return 0x820A5424;
		  /* 820A5424h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820A5424h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A5424h case    2:*/		return 0x820A5428;
		  /* 820A5428h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820A5428h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A5438;  }
		/* 820A5428h case    3:*/		return 0x820A542C;
		  /* 820A542Ch */ case    4:  		/* mr R4, R31 */
		/* 820A542Ch case    4:*/		regs.R4 = regs.R31;
		/* 820A542Ch case    4:*/		return 0x820A5430;
		  /* 820A5430h */ case    5:  		/* bl 148512 */
		/* 820A5430h case    5:*/		regs.LR = 0x820A5434; return 0x820C9850;
		/* 820A5430h case    5:*/		return 0x820A5434;
		  /* 820A5434h */ case    6:  		/* b 8 */
		/* 820A5434h case    6:*/		return 0x820A543C;
		/* 820A5434h case    6:*/		return 0x820A5438;
	}
	return 0x820A5438;
} // Block from 820A541Ch-820A5438h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A5438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5438);
		  /* 820A5438h */ case    0:  		/* mr R3, R18 */
		/* 820A5438h case    0:*/		regs.R3 = regs.R18;
		/* 820A5438h case    0:*/		return 0x820A543C;
	}
	return 0x820A543C;
} // Block from 820A5438h-820A543Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A543Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A543C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A543C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A543C);
		  /* 820A543Ch */ case    0:  		/* stw R3, <#[R30]> */
		/* 820A543Ch case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A543Ch case    0:*/		return 0x820A5440;
		  /* 820A5440h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A5440h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A5440h case    1:*/		return 0x820A5444;
		  /* 820A5444h */ case    2:  		/* bc 12, CR6_EQ, 928 */
		/* 820A5444h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A57E4;  }
		/* 820A5444h case    2:*/		return 0x820A5448;
		  /* 820A5448h */ case    3:  		/* addi R30, R3, 12 */
		/* 820A5448h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0xC);
		/* 820A5448h case    3:*/		return 0x820A544C;
	}
	return 0x820A544C;
} // Block from 820A543Ch-820A544Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A544Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A544C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A544C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A544C);
		  /* 820A544Ch */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 820A544Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820A544Ch case    0:*/		return 0x820A5450;
		  /* 820A5450h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820A5450h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A545C;  }
		/* 820A5450h case    1:*/		return 0x820A5454;
		  /* 820A5454h */ case    2:  		/* cmpwi CR6, R29, 0 */
		/* 820A5454h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820A5454h case    2:*/		return 0x820A5458;
		  /* 820A5458h */ case    3:  		/* bc 12, CR6_EQ, 416 */
		/* 820A5458h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A55F8;  }
		/* 820A5458h case    3:*/		return 0x820A545C;
	}
	return 0x820A545C;
} // Block from 820A544Ch-820A545Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A545Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A545C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A545C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A545C);
		  /* 820A545Ch */ case    0:  		/* lwz R31, <#[R26]> */
		/* 820A545Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000000) );
		/* 820A545Ch case    0:*/		return 0x820A5460;
		  /* 820A5460h */ case    1:  		/* mr R11, R18 */
		/* 820A5460h case    1:*/		regs.R11 = regs.R18;
		/* 820A5460h case    1:*/		return 0x820A5464;
		  /* 820A5464h */ case    2:  		/* li R30, 1 */
		/* 820A5464h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820A5464h case    2:*/		return 0x820A5468;
		  /* 820A5468h */ case    3:  		/* b 72 */
		/* 820A5468h case    3:*/		return 0x820A54B0;
		/* 820A5468h case    3:*/		return 0x820A546C;
		  /* 820A546Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820A546Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A546Ch case    4:*/		return 0x820A5470;
		  /* 820A5470h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820A5470h case    5:*/		if ( regs.CR[6].eq ) { return 0x820A5484;  }
		/* 820A5470h case    5:*/		return 0x820A5474;
		  /* 820A5474h */ case    6:  		/* lwz R10, <#[R31 + 48]> */
		/* 820A5474h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 820A5474h case    6:*/		return 0x820A5478;
		  /* 820A5478h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820A5478h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A5478h case    7:*/		return 0x820A547C;
		  /* 820A547Ch */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 820A547Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820A5484;  }
		/* 820A547Ch case    8:*/		return 0x820A5480;
		  /* 820A5480h */ case    9:  		/* addi R30, R30, 1 */
		/* 820A5480h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820A5480h case    9:*/		return 0x820A5484;
	}
	return 0x820A5484;
} // Block from 820A545Ch-820A5484h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A5484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5484);
		  /* 820A5484h */ case    0:  		/* li R7, 0 */
		/* 820A5484h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820A5484h case    0:*/		return 0x820A5488;
		  /* 820A5488h */ case    1:  		/* lwz R5, <#[R31 + 52]> */
		/* 820A5488h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000034) );
		/* 820A5488h case    1:*/		return 0x820A548C;
		  /* 820A548Ch */ case    2:  		/* li R6, 0 */
		/* 820A548Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820A548Ch case    2:*/		return 0x820A5490;
		  /* 820A5490h */ case    3:  		/* lwz R4, <#[R31 + 48]> */
		/* 820A5490h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000030) );
		/* 820A5490h case    3:*/		return 0x820A5494;
		  /* 820A5494h */ case    4:  		/* mr R3, R20 */
		/* 820A5494h case    4:*/		regs.R3 = regs.R20;
		/* 820A5494h case    4:*/		return 0x820A5498;
		  /* 820A5498h */ case    5:  		/* bl -18176 */
		/* 820A5498h case    5:*/		regs.LR = 0x820A549C; return 0x820A0D98;
		/* 820A5498h case    5:*/		return 0x820A549C;
		  /* 820A549Ch */ case    6:  		/* lwz R10, <#[R31 + 52]> */
		/* 820A549Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000034) );
		/* 820A549Ch case    6:*/		return 0x820A54A0;
		  /* 820A54A0h */ case    7:  		/* lwz R11, <#[R31 + 48]> */
		/* 820A54A0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820A54A0h case    7:*/		return 0x820A54A4;
		  /* 820A54A4h */ case    8:  		/* add R30, R3, R30 */
		/* 820A54A4h case    8:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R30);
		/* 820A54A4h case    8:*/		return 0x820A54A8;
		  /* 820A54A8h */ case    9:  		/* lwz R31, <#[R31 + 12]> */
		/* 820A54A8h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A54A8h case    9:*/		return 0x820A54AC;
		  /* 820A54ACh */ case   10:  		/* add R11, R10, R11 */
		/* 820A54ACh case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A54ACh case   10:*/		return 0x820A54B0;
	}
	return 0x820A54B0;
} // Block from 820A5484h-820A54B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A54B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A54B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A54B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A54B0);
		  /* 820A54B0h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820A54B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A54B0h case    0:*/		return 0x820A54B4;
		  /* 820A54B4h */ case    1:  		/* bc 4, CR6_EQ, -72 */
		/* 820A54B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A546C;  }
		/* 820A54B4h case    1:*/		return 0x820A54B8;
		  /* 820A54B8h */ case    2:  		/* addi R4, R30, 1 */
		/* 820A54B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x1);
		/* 820A54B8h case    2:*/		return 0x820A54BC;
		  /* 820A54BCh */ case    3:  		/* li R5, 1 */
		/* 820A54BCh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A54BCh case    3:*/		return 0x820A54C0;
		  /* 820A54C0h */ case    4:  		/* mr R3, R20 */
		/* 820A54C0h case    4:*/		regs.R3 = regs.R20;
		/* 820A54C0h case    4:*/		return 0x820A54C4;
		  /* 820A54C4h */ case    5:  		/* mr R27, R4 */
		/* 820A54C4h case    5:*/		regs.R27 = regs.R4;
		/* 820A54C4h case    5:*/		return 0x820A54C8;
		  /* 820A54C8h */ case    6:  		/* bl 146456 */
		/* 820A54C8h case    6:*/		regs.LR = 0x820A54CC; return 0x820C90E0;
		/* 820A54C8h case    6:*/		return 0x820A54CC;
		  /* 820A54CCh */ case    7:  		/* or. R29, R3, R3 */
		/* 820A54CCh case    7:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820A54CCh case    7:*/		return 0x820A54D0;
		  /* 820A54D0h */ case    8:  		/* bc 12, CR0_EQ, 788 */
		/* 820A54D0h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A57E4;  }
		/* 820A54D0h case    8:*/		return 0x820A54D4;
		  /* 820A54D4h */ case    9:  		/* subfic R10, R28, 0 */
		/* 820A54D4h case    9:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R28,0x0);
		/* 820A54D4h case    9:*/		return 0x820A54D8;
		  /* 820A54D8h */ case   10:  		/* mr R11, R18 */
		/* 820A54D8h case   10:*/		regs.R11 = regs.R18;
		/* 820A54D8h case   10:*/		return 0x820A54DC;
		  /* 820A54DCh */ case   11:  		/* subfe R10, R10, R10 */
		/* 820A54DCh case   11:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820A54DCh case   11:*/		return 0x820A54E0;
		  /* 820A54E0h */ case   12:  		/* li R30, 1 */
		/* 820A54E0h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820A54E0h case   12:*/		return 0x820A54E4;
		  /* 820A54E4h */ case   13:  		/* rlwinm R10, R10, 0, 30, 28 */
		/* 820A54E4h case   13:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R10,regs.R10);
		/* 820A54E4h case   13:*/		return 0x820A54E8;
		  /* 820A54E8h */ case   14:  		/* addi R28, R10, 39 */
		/* 820A54E8h case   14:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0x27);
		/* 820A54E8h case   14:*/		return 0x820A54EC;
		  /* 820A54ECh */ case   15:  		/* stb R28, <#[R29]> */
		/* 820A54ECh case   15:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R29 + 0x00000000) );
		/* 820A54ECh case   15:*/		return 0x820A54F0;
		  /* 820A54F0h */ case   16:  		/* lwz R31, <#[R26]> */
		/* 820A54F0h case   16:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000000) );
		/* 820A54F0h case   16:*/		return 0x820A54F4;
		  /* 820A54F4h */ case   17:  		/* b 80 */
		/* 820A54F4h case   17:*/		return 0x820A5544;
		/* 820A54F4h case   17:*/		return 0x820A54F8;
		  /* 820A54F8h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 820A54F8h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A54F8h case   18:*/		return 0x820A54FC;
		  /* 820A54FCh */ case   19:  		/* bc 12, CR6_EQ, 28 */
		/* 820A54FCh case   19:*/		if ( regs.CR[6].eq ) { return 0x820A5518;  }
		/* 820A54FCh case   19:*/		return 0x820A5500;
		  /* 820A5500h */ case   20:  		/* lwz R10, <#[R31 + 48]> */
		/* 820A5500h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 820A5500h case   20:*/		return 0x820A5504;
		  /* 820A5504h */ case   21:  		/* cmplw CR6, R11, R10 */
		/* 820A5504h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A5504h case   21:*/		return 0x820A5508;
		  /* 820A5508h */ case   22:  		/* bc 12, CR6_EQ, 16 */
		/* 820A5508h case   22:*/		if ( regs.CR[6].eq ) { return 0x820A5518;  }
		/* 820A5508h case   22:*/		return 0x820A550C;
		  /* 820A550Ch */ case   23:  		/* li R11, 32 */
		/* 820A550Ch case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 820A550Ch case   23:*/		return 0x820A5510;
		  /* 820A5510h */ case   24:  		/* stbx R11, <#[R29 + R30]> */
		/* 820A5510h case   24:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 820A5510h case   24:*/		return 0x820A5514;
		  /* 820A5514h */ case   25:  		/* addi R30, R30, 1 */
		/* 820A5514h case   25:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820A5514h case   25:*/		return 0x820A5518;
	}
	return 0x820A5518;
} // Block from 820A54B0h-820A5518h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820A5518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5518);
		  /* 820A5518h */ case    0:  		/* subf R7, R30, R27 */
		/* 820A5518h case    0:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R30,regs.R27);
		/* 820A5518h case    0:*/		return 0x820A551C;
		  /* 820A551Ch */ case    1:  		/* lwz R5, <#[R31 + 52]> */
		/* 820A551Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000034) );
		/* 820A551Ch case    1:*/		return 0x820A5520;
		  /* 820A5520h */ case    2:  		/* add R6, R29, R30 */
		/* 820A5520h case    2:*/		cpu::op::add<0>(regs,&regs.R6,regs.R29,regs.R30);
		/* 820A5520h case    2:*/		return 0x820A5524;
		  /* 820A5524h */ case    3:  		/* lwz R4, <#[R31 + 48]> */
		/* 820A5524h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000030) );
		/* 820A5524h case    3:*/		return 0x820A5528;
		  /* 820A5528h */ case    4:  		/* mr R3, R20 */
		/* 820A5528h case    4:*/		regs.R3 = regs.R20;
		/* 820A5528h case    4:*/		return 0x820A552C;
		  /* 820A552Ch */ case    5:  		/* bl -18324 */
		/* 820A552Ch case    5:*/		regs.LR = 0x820A5530; return 0x820A0D98;
		/* 820A552Ch case    5:*/		return 0x820A5530;
		  /* 820A5530h */ case    6:  		/* lwz R10, <#[R31 + 52]> */
		/* 820A5530h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000034) );
		/* 820A5530h case    6:*/		return 0x820A5534;
		  /* 820A5534h */ case    7:  		/* lwz R11, <#[R31 + 48]> */
		/* 820A5534h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820A5534h case    7:*/		return 0x820A5538;
		  /* 820A5538h */ case    8:  		/* add R30, R3, R30 */
		/* 820A5538h case    8:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R30);
		/* 820A5538h case    8:*/		return 0x820A553C;
		  /* 820A553Ch */ case    9:  		/* lwz R31, <#[R31 + 12]> */
		/* 820A553Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A553Ch case    9:*/		return 0x820A5540;
		  /* 820A5540h */ case   10:  		/* add R11, R10, R11 */
		/* 820A5540h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A5540h case   10:*/		return 0x820A5544;
	}
	return 0x820A5544;
} // Block from 820A5518h-820A5544h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A5544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5544);
		  /* 820A5544h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820A5544h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A5544h case    0:*/		return 0x820A5548;
		  /* 820A5548h */ case    1:  		/* bc 4, CR6_EQ, -80 */
		/* 820A5548h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A54F8;  }
		/* 820A5548h case    1:*/		return 0x820A554C;
		  /* 820A554Ch */ case    2:  		/* stbx R28, <#[R29 + R30]> */
		/* 820A554Ch case    2:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 820A554Ch case    2:*/		return 0x820A5550;
		  /* 820A5550h */ case    3:  		/* addi R3, R1, 160 */
		/* 820A5550h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 820A5550h case    3:*/		return 0x820A5554;
		  /* 820A5554h */ case    4:  		/* bl 2612 */
		/* 820A5554h case    4:*/		regs.LR = 0x820A5558; return 0x820A5F88;
		/* 820A5554h case    4:*/		return 0x820A5558;
		  /* 820A5558h */ case    5:  		/* addi R11, R20, 80 */
		/* 820A5558h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R20,0x50);
		/* 820A5558h case    5:*/		return 0x820A555C;
		  /* 820A555Ch */ case    6:  		/* addi R10, R20, 24 */
		/* 820A555Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R20,0x18);
		/* 820A555Ch case    6:*/		return 0x820A5560;
		  /* 820A5560h */ case    7:  		/* lwz R8, <#[R25 + 24]> */
		/* 820A5560h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000018) );
		/* 820A5560h case    7:*/		return 0x820A5564;
		  /* 820A5564h */ case    8:  		/* mr R9, R20 */
		/* 820A5564h case    8:*/		regs.R9 = regs.R20;
		/* 820A5564h case    8:*/		return 0x820A5568;
		  /* 820A5568h */ case    9:  		/* lwz R7, <#[R25 + 16]> */
		/* 820A5568h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000010) );
		/* 820A5568h case    9:*/		return 0x820A556C;
		  /* 820A556Ch */ case   10:  		/* addi R5, R30, 1 */
		/* 820A556Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R30,0x1);
		/* 820A556Ch case   10:*/		return 0x820A5570;
		  /* 820A5570h */ case   11:  		/* lwz R6, <#[R25 + 20]> */
		/* 820A5570h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R25 + 0x00000014) );
		/* 820A5570h case   11:*/		return 0x820A5574;
		  /* 820A5574h */ case   12:  		/* mr R4, R29 */
		/* 820A5574h case   12:*/		regs.R4 = regs.R29;
		/* 820A5574h case   12:*/		return 0x820A5578;
		  /* 820A5578h */ case   13:  		/* stw R11, <#[R1 + 84]> */
		/* 820A5578h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A5578h case   13:*/		return 0x820A557C;
		  /* 820A557Ch */ case   14:  		/* addi R3, R1, 160 */
		/* 820A557Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 820A557Ch case   14:*/		return 0x820A5580;
		  /* 820A5580h */ case   15:  		/* bl 2624 */
		/* 820A5580h case   15:*/		regs.LR = 0x820A5584; return 0x820A5FC0;
		/* 820A5580h case   15:*/		return 0x820A5584;
		  /* 820A5584h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820A5584h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A5584h case   16:*/		return 0x820A5588;
		  /* 820A5588h */ case   17:  		/* addi R3, R1, 160 */
		/* 820A5588h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 820A5588h case   17:*/		return 0x820A558C;
		  /* 820A558Ch */ case   18:  		/* bc 12, CR0_LT, 596 */
		/* 820A558Ch case   18:*/		if ( regs.CR[0].lt ) { return 0x820A57E0;  }
		/* 820A558Ch case   18:*/		return 0x820A5590;
		  /* 820A5590h */ case   19:  		/* addi R5, R1, 112 */
		/* 820A5590h case   19:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820A5590h case   19:*/		return 0x820A5594;
		  /* 820A5594h */ case   20:  		/* lwz R4, <#[R20 + 2256]> */
		/* 820A5594h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R20 + 0x000008D0) );
		/* 820A5594h case   20:*/		return 0x820A5598;
		  /* 820A5598h */ case   21:  		/* bl 11360 */
		/* 820A5598h case   21:*/		regs.LR = 0x820A559C; return 0x820A81F8;
		/* 820A5598h case   21:*/		return 0x820A559C;
		  /* 820A559Ch */ case   22:  		/* cmpwi CR0, R3, 0 */
		/* 820A559Ch case   22:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A559Ch case   22:*/		return 0x820A55A0;
		  /* 820A55A0h */ case   23:  		/* bc 12, CR0_LT, 572 */
		/* 820A55A0h case   23:*/		if ( regs.CR[0].lt ) { return 0x820A57DC;  }
		/* 820A55A0h case   23:*/		return 0x820A55A4;
		  /* 820A55A4h */ case   24:  		/* lwz R10, <#[R1 + 140]> */
		/* 820A55A4h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000008C) );
		/* 820A55A4h case   24:*/		return 0x820A55A8;
		  /* 820A55A8h */ case   25:  		/* li R3, 56 */
		/* 820A55A8h case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A55A8h case   25:*/		return 0x820A55AC;
		  /* 820A55ACh */ case   26:  		/* lwz R11, <#[R25 + 28]> */
		/* 820A55ACh case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000001C) );
		/* 820A55ACh case   26:*/		return 0x820A55B0;
		  /* 820A55B0h */ case   27:  		/* add R11, R11, R10 */
		/* 820A55B0h case   27:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A55B0h case   27:*/		return 0x820A55B4;
		  /* 820A55B4h */ case   28:  		/* stw R11, <#[R1 + 140]> */
		/* 820A55B4h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 820A55B4h case   28:*/		return 0x820A55B8;
		  /* 820A55B8h */ case   29:  		/* bl 146544 */
		/* 820A55B8h case   29:*/		regs.LR = 0x820A55BC; return 0x820C9228;
		/* 820A55B8h case   29:*/		return 0x820A55BC;
		  /* 820A55BCh */ case   30:  		/* cmplwi CR0, R3, 0 */
		/* 820A55BCh case   30:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A55BCh case   30:*/		return 0x820A55C0;
		  /* 820A55C0h */ case   31:  		/* bc 12, CR0_EQ, 20 */
		/* 820A55C0h case   31:*/		if ( regs.CR[0].eq ) { return 0x820A55D4;  }
		/* 820A55C0h case   31:*/		return 0x820A55C4;
		  /* 820A55C4h */ case   32:  		/* addi R4, R1, 112 */
		/* 820A55C4h case   32:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820A55C4h case   32:*/		return 0x820A55C8;
		  /* 820A55C8h */ case   33:  		/* bl 148104 */
		/* 820A55C8h case   33:*/		regs.LR = 0x820A55CC; return 0x820C9850;
		/* 820A55C8h case   33:*/		return 0x820A55CC;
		  /* 820A55CCh */ case   34:  		/* mr R11, R3 */
		/* 820A55CCh case   34:*/		regs.R11 = regs.R3;
		/* 820A55CCh case   34:*/		return 0x820A55D0;
		  /* 820A55D0h */ case   35:  		/* b 8 */
		/* 820A55D0h case   35:*/		return 0x820A55D8;
		/* 820A55D0h case   35:*/		return 0x820A55D4;
	}
	return 0x820A55D4;
} // Block from 820A5544h-820A55D4h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820A55D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A55D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A55D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A55D4);
		  /* 820A55D4h */ case    0:  		/* mr R11, R18 */
		/* 820A55D4h case    0:*/		regs.R11 = regs.R18;
		/* 820A55D4h case    0:*/		return 0x820A55D8;
	}
	return 0x820A55D8;
} // Block from 820A55D4h-820A55D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A55D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A55D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A55D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A55D8);
		  /* 820A55D8h */ case    0:  		/* stw R11, <#[R26]> */
		/* 820A55D8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820A55D8h case    0:*/		return 0x820A55DC;
		  /* 820A55DCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A55DCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A55DCh case    1:*/		return 0x820A55E0;
		  /* 820A55E0h */ case    2:  		/* addi R3, R1, 160 */
		/* 820A55E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 820A55E0h case    2:*/		return 0x820A55E4;
		  /* 820A55E4h */ case    3:  		/* bc 12, CR6_EQ, 508 */
		/* 820A55E4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A57E0;  }
		/* 820A55E4h case    3:*/		return 0x820A55E8;
		  /* 820A55E8h */ case    4:  		/* addi R30, R11, 12 */
		/* 820A55E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xC);
		/* 820A55E8h case    4:*/		return 0x820A55EC;
		  /* 820A55ECh */ case    5:  		/* mr R29, R18 */
		/* 820A55ECh case    5:*/		regs.R29 = regs.R18;
		/* 820A55ECh case    5:*/		return 0x820A55F0;
		  /* 820A55F0h */ case    6:  		/* mr R28, R18 */
		/* 820A55F0h case    6:*/		regs.R28 = regs.R18;
		/* 820A55F0h case    6:*/		return 0x820A55F4;
		  /* 820A55F4h */ case    7:  		/* bl 1539532 */
		/* 820A55F4h case    7:*/		regs.LR = 0x820A55F8; return 0x8221D3C0;
		/* 820A55F4h case    7:*/		return 0x820A55F8;
	}
	return 0x820A55F8;
} // Block from 820A55D8h-820A55F8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A55F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A55F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A55F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A55F8);
		  /* 820A55F8h */ case    0:  		/* lwz R24, <#[R24 + 12]> */
		/* 820A55F8h case    0:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R24 + 0x0000000C) );
		/* 820A55F8h case    0:*/		return 0x820A55FC;
		  /* 820A55FCh */ case    1:  		/* cmplwi CR6, R24, 0 */
		/* 820A55FCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820A55FCh case    1:*/		return 0x820A5600;
		  /* 820A5600h */ case    2:  		/* bc 4, CR6_EQ, -828 */
		/* 820A5600h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A52C4;  }
		/* 820A5600h case    2:*/		return 0x820A5604;
	}
	return 0x820A5604;
} // Block from 820A55F8h-820A5604h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A5604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5604);
		  /* 820A5604h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 820A5604h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820A5604h case    0:*/		return 0x820A5608;
		  /* 820A5608h */ case    1:  		/* addi R25, R1, 96 */
		/* 820A5608h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R1,0x60);
		/* 820A5608h case    1:*/		return 0x820A560C;
		  /* 820A560Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820A560Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A560Ch case    2:*/		return 0x820A5610;
		  /* 820A5610h */ case    3:  		/* bc 12, CR6_EQ, 524 */
		/* 820A5610h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A581C;  }
		/* 820A5610h case    3:*/		return 0x820A5614;
		  /* 820A5614h */ case    4:  		/* lis R11, -32255 */
		/* 820A5614h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A5614h case    4:*/		return 0x820A5618;
		  /* 820A5618h */ case    5:  		/* addi R24, R11, -9812 */
		/* 820A5618h case    5:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0xFFFFD9AC);
		/* 820A5618h case    5:*/		return 0x820A561C;
		  /* 820A561Ch */ case    6:  		/* lwz R26, <#[R25]> */
		/* 820A561Ch case    6:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R25 + 0x00000000) );
		/* 820A561Ch case    6:*/		return 0x820A5620;
		  /* 820A5620h */ case    7:  		/* cmplwi CR0, R26, 0 */
		/* 820A5620h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R26,0x00000000);
		/* 820A5620h case    7:*/		return 0x820A5624;
		  /* 820A5624h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 820A5624h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A5630;  }
		/* 820A5624h case    8:*/		return 0x820A5628;
		  /* 820A5628h */ case    9:  		/* lwz R10, <#[R26 + 12]> */
		/* 820A5628h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x0000000C) );
		/* 820A5628h case    9:*/		return 0x820A562C;
		  /* 820A562Ch */ case   10:  		/* b 8 */
		/* 820A562Ch case   10:*/		return 0x820A5634;
		/* 820A562Ch case   10:*/		return 0x820A5630;
	}
	return 0x820A5630;
} // Block from 820A5604h-820A5630h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A5630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5630);
		  /* 820A5630h */ case    0:  		/* mr R10, R18 */
		/* 820A5630h case    0:*/		regs.R10 = regs.R18;
		/* 820A5630h case    0:*/		return 0x820A5634;
	}
	return 0x820A5634;
} // Block from 820A5630h-820A5634h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5634);
		  /* 820A5634h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820A5634h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A5634h case    0:*/		return 0x820A5638;
		  /* 820A5638h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820A5638h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A5644;  }
		/* 820A5638h case    1:*/		return 0x820A563C;
		  /* 820A563Ch */ case    2:  		/* lwz R27, <#[R10 + 12]> */
		/* 820A563Ch case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + 0x0000000C) );
		/* 820A563Ch case    2:*/		return 0x820A5640;
		  /* 820A5640h */ case    3:  		/* b 8 */
		/* 820A5640h case    3:*/		return 0x820A5648;
		/* 820A5640h case    3:*/		return 0x820A5644;
	}
	return 0x820A5644;
} // Block from 820A5634h-820A5644h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A5644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5644);
		  /* 820A5644h */ case    0:  		/* mr R27, R18 */
		/* 820A5644h case    0:*/		regs.R27 = regs.R18;
		/* 820A5644h case    0:*/		return 0x820A5648;
	}
	return 0x820A5648;
} // Block from 820A5644h-820A5648h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5648);
		  /* 820A5648h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 820A5648h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820A5648h case    0:*/		return 0x820A564C;
		  /* 820A564Ch */ case    1:  		/* addi R30, R26, 16 */
		/* 820A564Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R26,0x10);
		/* 820A564Ch case    1:*/		return 0x820A5650;
		  /* 820A5650h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820A5650h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A5658;  }
		/* 820A5650h case    2:*/		return 0x820A5654;
		  /* 820A5654h */ case    3:  		/* mr R30, R18 */
		/* 820A5654h case    3:*/		regs.R30 = regs.R18;
		/* 820A5654h case    3:*/		return 0x820A5658;
	}
	return 0x820A5658;
} // Block from 820A5648h-820A5658h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A5658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5658);
		  /* 820A5658h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820A5658h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A5658h case    0:*/		return 0x820A565C;
		  /* 820A565Ch */ case    1:  		/* addi R11, R10, 16 */
		/* 820A565Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x10);
		/* 820A565Ch case    1:*/		return 0x820A5660;
		  /* 820A5660h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820A5660h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A5668;  }
		/* 820A5660h case    2:*/		return 0x820A5664;
		  /* 820A5664h */ case    3:  		/* mr R11, R18 */
		/* 820A5664h case    3:*/		regs.R11 = regs.R18;
		/* 820A5664h case    3:*/		return 0x820A5668;
	}
	return 0x820A5668;
} // Block from 820A5658h-820A5668h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A5668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5668);
		  /* 820A5668h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820A5668h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820A5668h case    0:*/		return 0x820A566C;
		  /* 820A566Ch */ case    1:  		/* addi R28, R27, 16 */
		/* 820A566Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R27,0x10);
		/* 820A566Ch case    1:*/		return 0x820A5670;
		  /* 820A5670h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820A5670h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A5678;  }
		/* 820A5670h case    2:*/		return 0x820A5674;
		  /* 820A5674h */ case    3:  		/* mr R28, R18 */
		/* 820A5674h case    3:*/		regs.R28 = regs.R18;
		/* 820A5674h case    3:*/		return 0x820A5678;
	}
	return 0x820A5678;
} // Block from 820A5668h-820A5678h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A5678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5678);
		  /* 820A5678h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 820A5678h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820A5678h case    0:*/		return 0x820A567C;
		  /* 820A567Ch */ case    1:  		/* bc 12, CR6_EQ, 400 */
		/* 820A567Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820A580C;  }
		/* 820A567Ch case    1:*/		return 0x820A5680;
		  /* 820A5680h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 820A5680h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A5680h case    2:*/		return 0x820A5684;
		  /* 820A5684h */ case    3:  		/* bc 12, CR6_EQ, 392 */
		/* 820A5684h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A580C;  }
		/* 820A5684h case    3:*/		return 0x820A5688;
		  /* 820A5688h */ case    4:  		/* cmplwi CR6, R27, 0 */
		/* 820A5688h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820A5688h case    4:*/		return 0x820A568C;
		  /* 820A568Ch */ case    5:  		/* bc 12, CR6_EQ, 384 */
		/* 820A568Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820A580C;  }
		/* 820A568Ch case    5:*/		return 0x820A5690;
		  /* 820A5690h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 820A5690h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A5690h case    6:*/		return 0x820A5694;
		  /* 820A5694h */ case    7:  		/* cmpwi CR6, R10, 1 */
		/* 820A5694h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 820A5694h case    7:*/		return 0x820A5698;
		  /* 820A5698h */ case    8:  		/* bc 4, CR6_EQ, 372 */
		/* 820A5698h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A580C;  }
		/* 820A5698h case    8:*/		return 0x820A569C;
		  /* 820A569Ch */ case    9:  		/* mr R10, R24 */
		/* 820A569Ch case    9:*/		regs.R10 = regs.R24;
		/* 820A569Ch case    9:*/		return 0x820A56A0;
		  /* 820A56A0h */ case   10:  		/* addi R11, R11, 8 */
		/* 820A56A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820A56A0h case   10:*/		return 0x820A56A4;
		  /* 820A56A4h */ case   11:  		/* lbz R9, <#[R11]> */
		/* 820A56A4h case   11:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A56A4h case   11:*/		return 0x820A56A8;
		  /* 820A56A8h */ case   12:  		/* lbz R8, <#[R10]> */
		/* 820A56A8h case   12:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A56A8h case   12:*/		return 0x820A56AC;
		  /* 820A56ACh */ case   13:  		/* cmpwi CR0, R9, 0 */
		/* 820A56ACh case   13:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A56ACh case   13:*/		return 0x820A56B0;
		  /* 820A56B0h */ case   14:  		/* subf R9, R8, R9 */
		/* 820A56B0h case   14:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A56B0h case   14:*/		return 0x820A56B4;
		  /* 820A56B4h */ case   15:  		/* bc 12, CR0_EQ, 20 */
		/* 820A56B4h case   15:*/		if ( regs.CR[0].eq ) { return 0x820A56C8;  }
		/* 820A56B4h case   15:*/		return 0x820A56B8;
		  /* 820A56B8h */ case   16:  		/* addi R11, R11, 1 */
		/* 820A56B8h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A56B8h case   16:*/		return 0x820A56BC;
		  /* 820A56BCh */ case   17:  		/* addi R10, R10, 1 */
		/* 820A56BCh case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A56BCh case   17:*/		return 0x820A56C0;
		  /* 820A56C0h */ case   18:  		/* cmpwi CR6, R9, 0 */
		/* 820A56C0h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A56C0h case   18:*/		return 0x820A56C4;
		  /* 820A56C4h */ case   19:  		/* bc 12, CR6_EQ, -32 */
		/* 820A56C4h case   19:*/		if ( regs.CR[6].eq ) { return 0x820A56A4;  }
		/* 820A56C4h case   19:*/		return 0x820A56C8;
	}
	return 0x820A56C8;
} // Block from 820A5678h-820A56C8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A56C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A56C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A56C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A56C8);
		  /* 820A56C8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A56C8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A56C8h case    0:*/		return 0x820A56CC;
		  /* 820A56CCh */ case    1:  		/* bc 4, CR0_EQ, 320 */
		/* 820A56CCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A580C;  }
		/* 820A56CCh case    1:*/		return 0x820A56D0;
		  /* 820A56D0h */ case    2:  		/* lwz R10, <#[R28 + 36]> */
		/* 820A56D0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000024) );
		/* 820A56D0h case    2:*/		return 0x820A56D4;
		  /* 820A56D4h */ case    3:  		/* li R5, 1 */
		/* 820A56D4h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A56D4h case    3:*/		return 0x820A56D8;
		  /* 820A56D8h */ case    4:  		/* lwz R11, <#[R30 + 36]> */
		/* 820A56D8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820A56D8h case    4:*/		return 0x820A56DC;
		  /* 820A56DCh */ case    5:  		/* mr R3, R20 */
		/* 820A56DCh case    5:*/		regs.R3 = regs.R20;
		/* 820A56DCh case    5:*/		return 0x820A56E0;
		  /* 820A56E0h */ case    6:  		/* add R29, R11, R10 */
		/* 820A56E0h case    6:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R10);
		/* 820A56E0h case    6:*/		return 0x820A56E4;
		  /* 820A56E4h */ case    7:  		/* mr R4, R29 */
		/* 820A56E4h case    7:*/		regs.R4 = regs.R29;
		/* 820A56E4h case    7:*/		return 0x820A56E8;
		  /* 820A56E8h */ case    8:  		/* bl 145912 */
		/* 820A56E8h case    8:*/		regs.LR = 0x820A56EC; return 0x820C90E0;
		/* 820A56E8h case    8:*/		return 0x820A56EC;
		  /* 820A56ECh */ case    9:  		/* or. R31, R3, R3 */
		/* 820A56ECh case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A56ECh case    9:*/		return 0x820A56F0;
		  /* 820A56F0h */ case   10:  		/* bc 12, CR0_EQ, 244 */
		/* 820A56F0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820A57E4;  }
		/* 820A56F0h case   10:*/		return 0x820A56F4;
		  /* 820A56F4h */ case   11:  		/* mr R3, R31 */
		/* 820A56F4h case   11:*/		regs.R3 = regs.R31;
		/* 820A56F4h case   11:*/		return 0x820A56F8;
		  /* 820A56F8h */ case   12:  		/* lwz R5, <#[R30 + 36]> */
		/* 820A56F8h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000024) );
		/* 820A56F8h case   12:*/		return 0x820A56FC;
		  /* 820A56FCh */ case   13:  		/* lwz R4, <#[R30 + 32]> */
		/* 820A56FCh case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000020) );
		/* 820A56FCh case   13:*/		return 0x820A5700;
		  /* 820A5700h */ case   14:  		/* bl -81232 */
		/* 820A5700h case   14:*/		regs.LR = 0x820A5704; return 0x820919B0;
		/* 820A5700h case   14:*/		return 0x820A5704;
		  /* 820A5704h */ case   15:  		/* lwz R11, <#[R30 + 36]> */
		/* 820A5704h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820A5704h case   15:*/		return 0x820A5708;
		  /* 820A5708h */ case   16:  		/* lwz R5, <#[R28 + 36]> */
		/* 820A5708h case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x00000024) );
		/* 820A5708h case   16:*/		return 0x820A570C;
		  /* 820A570Ch */ case   17:  		/* add R3, R11, R31 */
		/* 820A570Ch case   17:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R31);
		/* 820A570Ch case   17:*/		return 0x820A5710;
		  /* 820A5710h */ case   18:  		/* lwz R4, <#[R28 + 32]> */
		/* 820A5710h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000020) );
		/* 820A5710h case   18:*/		return 0x820A5714;
		  /* 820A5714h */ case   19:  		/* bl -81252 */
		/* 820A5714h case   19:*/		regs.LR = 0x820A5718; return 0x820919B0;
		/* 820A5714h case   19:*/		return 0x820A5718;
		  /* 820A5718h */ case   20:  		/* addi R3, R1, 160 */
		/* 820A5718h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 820A5718h case   20:*/		return 0x820A571C;
		  /* 820A571Ch */ case   21:  		/* bl 2156 */
		/* 820A571Ch case   21:*/		regs.LR = 0x820A5720; return 0x820A5F88;
		/* 820A571Ch case   21:*/		return 0x820A5720;
		  /* 820A5720h */ case   22:  		/* addi R11, R20, 80 */
		/* 820A5720h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R20,0x50);
		/* 820A5720h case   22:*/		return 0x820A5724;
		  /* 820A5724h */ case   23:  		/* addi R10, R20, 24 */
		/* 820A5724h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R20,0x18);
		/* 820A5724h case   23:*/		return 0x820A5728;
		  /* 820A5728h */ case   24:  		/* lwz R8, <#[R30 + 24]> */
		/* 820A5728h case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000018) );
		/* 820A5728h case   24:*/		return 0x820A572C;
		  /* 820A572Ch */ case   25:  		/* mr R9, R20 */
		/* 820A572Ch case   25:*/		regs.R9 = regs.R20;
		/* 820A572Ch case   25:*/		return 0x820A5730;
		  /* 820A5730h */ case   26:  		/* lwz R7, <#[R30 + 16]> */
		/* 820A5730h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000010) );
		/* 820A5730h case   26:*/		return 0x820A5734;
		  /* 820A5734h */ case   27:  		/* mr R5, R29 */
		/* 820A5734h case   27:*/		regs.R5 = regs.R29;
		/* 820A5734h case   27:*/		return 0x820A5738;
		  /* 820A5738h */ case   28:  		/* lwz R6, <#[R30 + 20]> */
		/* 820A5738h case   28:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000014) );
		/* 820A5738h case   28:*/		return 0x820A573C;
		  /* 820A573Ch */ case   29:  		/* mr R4, R31 */
		/* 820A573Ch case   29:*/		regs.R4 = regs.R31;
		/* 820A573Ch case   29:*/		return 0x820A5740;
		  /* 820A5740h */ case   30:  		/* stw R11, <#[R1 + 84]> */
		/* 820A5740h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820A5740h case   30:*/		return 0x820A5744;
		  /* 820A5744h */ case   31:  		/* addi R3, R1, 160 */
		/* 820A5744h case   31:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 820A5744h case   31:*/		return 0x820A5748;
		  /* 820A5748h */ case   32:  		/* bl 2168 */
		/* 820A5748h case   32:*/		regs.LR = 0x820A574C; return 0x820A5FC0;
		/* 820A5748h case   32:*/		return 0x820A574C;
		  /* 820A574Ch */ case   33:  		/* cmpwi CR0, R3, 0 */
		/* 820A574Ch case   33:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A574Ch case   33:*/		return 0x820A5750;
		  /* 820A5750h */ case   34:  		/* bc 12, CR0_LT, 140 */
		/* 820A5750h case   34:*/		if ( regs.CR[0].lt ) { return 0x820A57DC;  }
		/* 820A5750h case   34:*/		return 0x820A5754;
		  /* 820A5754h */ case   35:  		/* lwz R30, <#[R27 + 12]> */
		/* 820A5754h case   35:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x0000000C) );
		/* 820A5754h case   35:*/		return 0x820A5758;
		  /* 820A5758h */ case   36:  		/* mr R31, R26 */
		/* 820A5758h case   36:*/		regs.R31 = regs.R26;
		/* 820A5758h case   36:*/		return 0x820A575C;
		  /* 820A575Ch */ case   37:  		/* addi R5, R1, 112 */
		/* 820A575Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820A575Ch case   37:*/		return 0x820A5760;
		  /* 820A5760h */ case   38:  		/* lwz R4, <#[R20 + 2256]> */
		/* 820A5760h case   38:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R20 + 0x000008D0) );
		/* 820A5760h case   38:*/		return 0x820A5764;
		  /* 820A5764h */ case   39:  		/* addi R3, R1, 160 */
		/* 820A5764h case   39:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 820A5764h case   39:*/		return 0x820A5768;
		  /* 820A5768h */ case   40:  		/* bl 10896 */
		/* 820A5768h case   40:*/		regs.LR = 0x820A576C; return 0x820A81F8;
		/* 820A5768h case   40:*/		return 0x820A576C;
		  /* 820A576Ch */ case   41:  		/* cmpwi CR0, R3, 0 */
		/* 820A576Ch case   41:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A576Ch case   41:*/		return 0x820A5770;
		  /* 820A5770h */ case   42:  		/* bc 12, CR0_LT, 108 */
		/* 820A5770h case   42:*/		if ( regs.CR[0].lt ) { return 0x820A57DC;  }
		/* 820A5770h case   42:*/		return 0x820A5774;
		  /* 820A5774h */ case   43:  		/* lwz R11, <#[R1 + 112]> */
		/* 820A5774h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820A5774h case   43:*/		return 0x820A5778;
		  /* 820A5778h */ case   44:  		/* cmpwi CR6, R11, 17 */
		/* 820A5778h case   44:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820A5778h case   44:*/		return 0x820A577C;
		  /* 820A577Ch */ case   45:  		/* bc 12, CR6_EQ, 112 */
		/* 820A577Ch case   45:*/		if ( regs.CR[6].eq ) { return 0x820A57EC;  }
		/* 820A577Ch case   45:*/		return 0x820A5780;
		  /* 820A5780h */ case   46:  		/* cmplwi CR6, R31, 0 */
		/* 820A5780h case   46:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A5780h case   46:*/		return 0x820A5784;
		  /* 820A5784h */ case   47:  		/* bc 12, CR6_EQ, 40 */
		/* 820A5784h case   47:*/		if ( regs.CR[6].eq ) { return 0x820A57AC;  }
		/* 820A5784h case   47:*/		return 0x820A5788;
		  /* 820A5788h */ case   48:  		/* li R11, 5 */
		/* 820A5788h case   48:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820A5788h case   48:*/		return 0x820A578C;
		  /* 820A578Ch */ case   49:  		/* addi R10, R1, 104 */
		/* 820A578Ch case   49:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x68);
		/* 820A578Ch case   49:*/		return 0x820A5790;
		  /* 820A5790h */ case   50:  		/* addi R9, R31, 8 */
		/* 820A5790h case   50:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x8);
		/* 820A5790h case   50:*/		return 0x820A5794;
		  /* 820A5794h */ case   51:  		/* mtspr CTR, R11 */
		/* 820A5794h case   51:*/		regs.CTR = regs.R11;
		/* 820A5794h case   51:*/		return 0x820A5798;
		  /* 820A5798h */ case   52:  		/* ldu R11, <#[R10 + 8]> */
		/* 820A5798h case   52:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820A5798h case   52:*/		return 0x820A579C;
		  /* 820A579Ch */ case   53:  		/* stdu R11, <#[R9 + 8]> */
		/* 820A579Ch case   53:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820A579Ch case   53:*/		return 0x820A57A0;
		  /* 820A57A0h */ case   54:  		/* bc 16, CR0_LT, -8 */
		/* 820A57A0h case   54:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A5798;  }
		/* 820A57A0h case   54:*/		return 0x820A57A4;
		  /* 820A57A4h */ case   55:  		/* mr R31, R18 */
		/* 820A57A4h case   55:*/		regs.R31 = regs.R18;
		/* 820A57A4h case   55:*/		return 0x820A57A8;
		  /* 820A57A8h */ case   56:  		/* b -76 */
		/* 820A57A8h case   56:*/		return 0x820A575C;
		/* 820A57A8h case   56:*/		return 0x820A57AC;
	}
	return 0x820A57AC;
} // Block from 820A56C8h-820A57ACh (57 instructions)

//////////////////////////////////////////////////////
// Block at 820A57ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A57AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A57AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A57AC);
		  /* 820A57ACh */ case    0:  		/* li R3, 56 */
		/* 820A57ACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820A57ACh case    0:*/		return 0x820A57B0;
		  /* 820A57B0h */ case    1:  		/* bl 146040 */
		/* 820A57B0h case    1:*/		regs.LR = 0x820A57B4; return 0x820C9228;
		/* 820A57B0h case    1:*/		return 0x820A57B4;
		  /* 820A57B4h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820A57B4h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A57B4h case    2:*/		return 0x820A57B8;
		  /* 820A57B8h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820A57B8h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A57C8;  }
		/* 820A57B8h case    3:*/		return 0x820A57BC;
		  /* 820A57BCh */ case    4:  		/* addi R4, R1, 112 */
		/* 820A57BCh case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820A57BCh case    4:*/		return 0x820A57C0;
		  /* 820A57C0h */ case    5:  		/* bl 147600 */
		/* 820A57C0h case    5:*/		regs.LR = 0x820A57C4; return 0x820C9850;
		/* 820A57C0h case    5:*/		return 0x820A57C4;
		  /* 820A57C4h */ case    6:  		/* b 8 */
		/* 820A57C4h case    6:*/		return 0x820A57CC;
		/* 820A57C4h case    6:*/		return 0x820A57C8;
	}
	return 0x820A57C8;
} // Block from 820A57ACh-820A57C8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A57C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A57C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A57C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A57C8);
		  /* 820A57C8h */ case    0:  		/* mr R3, R18 */
		/* 820A57C8h case    0:*/		regs.R3 = regs.R18;
		/* 820A57C8h case    0:*/		return 0x820A57CC;
	}
	return 0x820A57CC;
} // Block from 820A57C8h-820A57CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A57CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A57CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A57CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A57CC);
		  /* 820A57CCh */ case    0:  		/* stw R3, <#[R26 + 12]> */
		/* 820A57CCh case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R26 + 0x0000000C) );
		/* 820A57CCh case    0:*/		return 0x820A57D0;
		  /* 820A57D0h */ case    1:  		/* mr R26, R3 */
		/* 820A57D0h case    1:*/		regs.R26 = regs.R3;
		/* 820A57D0h case    1:*/		return 0x820A57D4;
		  /* 820A57D4h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820A57D4h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A57D4h case    2:*/		return 0x820A57D8;
		  /* 820A57D8h */ case    3:  		/* bc 4, CR0_EQ, -124 */
		/* 820A57D8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820A575C;  }
		/* 820A57D8h case    3:*/		return 0x820A57DC;
	}
	return 0x820A57DC;
} // Block from 820A57CCh-820A57DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A57DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A57DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A57DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A57DC);
		  /* 820A57DCh */ case    0:  		/* addi R3, R1, 160 */
		/* 820A57DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 820A57DCh case    0:*/		return 0x820A57E0;
	}
	return 0x820A57E0;
} // Block from 820A57DCh-820A57E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A57E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A57E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A57E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A57E0);
		  /* 820A57E0h */ case    0:  		/* bl 1539040 */
		/* 820A57E0h case    0:*/		regs.LR = 0x820A57E4; return 0x8221D3C0;
		/* 820A57E0h case    0:*/		return 0x820A57E4;
	}
	return 0x820A57E4;
} // Block from 820A57E0h-820A57E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A57E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A57E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A57E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A57E4);
		  /* 820A57E4h */ case    0:  		/* mr R3, R18 */
		/* 820A57E4h case    0:*/		regs.R3 = regs.R18;
		/* 820A57E4h case    0:*/		return 0x820A57E8;
		  /* 820A57E8h */ case    1:  		/* b 80 */
		/* 820A57E8h case    1:*/		return 0x820A5838;
		/* 820A57E8h case    1:*/		return 0x820A57EC;
	}
	return 0x820A57EC;
} // Block from 820A57E4h-820A57ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A57ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A57EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A57EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A57EC);
		  /* 820A57ECh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820A57ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A57ECh case    0:*/		return 0x820A57F0;
		  /* 820A57F0h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820A57F0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A57FC;  }
		/* 820A57F0h case    1:*/		return 0x820A57F4;
		  /* 820A57F4h */ case    2:  		/* stw R30, <#[R26 + 12]> */
		/* 820A57F4h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R26 + 0x0000000C) );
		/* 820A57F4h case    2:*/		return 0x820A57F8;
		  /* 820A57F8h */ case    3:  		/* b 8 */
		/* 820A57F8h case    3:*/		return 0x820A5800;
		/* 820A57F8h case    3:*/		return 0x820A57FC;
	}
	return 0x820A57FC;
} // Block from 820A57ECh-820A57FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A57FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A57FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A57FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A57FC);
		  /* 820A57FCh */ case    0:  		/* stw R30, <#[R25]> */
		/* 820A57FCh case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R25 + 0x00000000) );
		/* 820A57FCh case    0:*/		return 0x820A5800;
	}
	return 0x820A5800;
} // Block from 820A57FCh-820A5800h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5800);
		  /* 820A5800h */ case    0:  		/* addi R3, R1, 160 */
		/* 820A5800h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 820A5800h case    0:*/		return 0x820A5804;
		  /* 820A5804h */ case    1:  		/* bl 1539004 */
		/* 820A5804h case    1:*/		regs.LR = 0x820A5808; return 0x8221D3C0;
		/* 820A5804h case    1:*/		return 0x820A5808;
		  /* 820A5808h */ case    2:  		/* b 8 */
		/* 820A5808h case    2:*/		return 0x820A5810;
		/* 820A5808h case    2:*/		return 0x820A580C;
	}
	return 0x820A580C;
} // Block from 820A5800h-820A580Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A580Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A580C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A580C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A580C);
		  /* 820A580Ch */ case    0:  		/* addi R25, R26, 12 */
		/* 820A580Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R26,0xC);
		/* 820A580Ch case    0:*/		return 0x820A5810;
	}
	return 0x820A5810;
} // Block from 820A580Ch-820A5810h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5810);
		  /* 820A5810h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 820A5810h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820A5810h case    0:*/		return 0x820A5814;
		  /* 820A5814h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A5814h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A5814h case    1:*/		return 0x820A5818;
		  /* 820A5818h */ case    2:  		/* bc 4, CR6_EQ, -508 */
		/* 820A5818h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A561C;  }
		/* 820A5818h case    2:*/		return 0x820A581C;
	}
	return 0x820A581C;
} // Block from 820A5810h-820A581Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A581Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A581C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A581C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A581C);
		  /* 820A581Ch */ case    0:  		/* lwz R11, <#[R20 + 1668]> */
		/* 820A581Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000684) );
		/* 820A581Ch case    0:*/		return 0x820A5820;
		  /* 820A5820h */ case    1:  		/* stw R11, <#[R25]> */
		/* 820A5820h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820A5820h case    1:*/		return 0x820A5824;
	}
	return 0x820A5824;
} // Block from 820A581Ch-820A5824h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A5824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5824);
		  /* 820A5824h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 820A5824h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820A5824h case    0:*/		return 0x820A5828;
		  /* 820A5828h */ case    1:  		/* li R3, 1 */
		/* 820A5828h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820A5828h case    1:*/		return 0x820A582C;
		  /* 820A582Ch */ case    2:  		/* stw R11, <#[R20 + 1668]> */
		/* 820A582Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000684) );
		/* 820A582Ch case    2:*/		return 0x820A5830;
		  /* 820A5830h */ case    3:  		/* b 8 */
		/* 820A5830h case    3:*/		return 0x820A5838;
		/* 820A5830h case    3:*/		return 0x820A5834;
	}
	return 0x820A5834;
} // Block from 820A5824h-820A5834h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A5834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5834);
		  /* 820A5834h */ case    0:  		/* li R3, 2 */
		/* 820A5834h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 820A5834h case    0:*/		return 0x820A5838;
	}
	return 0x820A5838;
} // Block from 820A5834h-820A5838h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5838);
		  /* 820A5838h */ case    0:  		/* addi R1, R1, 400 */
		/* 820A5838h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x190);
		/* 820A5838h case    0:*/		return 0x820A583C;
		  /* 820A583Ch */ case    1:  		/* b -83388 */
		/* 820A583Ch case    1:*/		return 0x82091280;
		/* 820A583Ch case    1:*/		return 0x820A5840;
	}
	return 0x820A5840;
} // Block from 820A5838h-820A5840h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A5840h
// Function '?End@CPreProcessor@D3DXShader@@QAAJPAPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5840);
		  /* 820A5840h */ case    0:  		/* mfspr R12, LR */
		/* 820A5840h case    0:*/		regs.R12 = regs.LR;
		/* 820A5840h case    0:*/		return 0x820A5844;
		  /* 820A5844h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A5844h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A5844h case    1:*/		return 0x820A5848;
		  /* 820A5848h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A5848h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A5848h case    2:*/		return 0x820A584C;
		  /* 820A584Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A584Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A584Ch case    3:*/		return 0x820A5850;
		  /* 820A5850h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 820A5850h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820A5850h case    4:*/		return 0x820A5854;
		  /* 820A5854h */ case    5:  		/* addi R31, R11, -1 */
		/* 820A5854h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFFF);
		/* 820A5854h case    5:*/		return 0x820A5858;
		  /* 820A5858h */ case    6:  		/* cmplwi CR6, R11, 1 */
		/* 820A5858h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820A5858h case    6:*/		return 0x820A585C;
		  /* 820A585Ch */ case    7:  		/* stw R31, <#[R3 + 4]> */
		/* 820A585Ch case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000004) );
		/* 820A585Ch case    7:*/		return 0x820A5860;
		  /* 820A5860h */ case    8:  		/* bc 4, CR6_EQ, 24 */
		/* 820A5860h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A5878;  }
		/* 820A5860h case    8:*/		return 0x820A5864;
		  /* 820A5864h */ case    9:  		/* lwz R11, <#[R3]> */
		/* 820A5864h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A5864h case    9:*/		return 0x820A5868;
		  /* 820A5868h */ case   10:  		/* li R4, 1 */
		/* 820A5868h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A5868h case   10:*/		return 0x820A586C;
		  /* 820A586Ch */ case   11:  		/* lwz R11, <#[R11 + 20]> */
		/* 820A586Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820A586Ch case   11:*/		return 0x820A5870;
		  /* 820A5870h */ case   12:  		/* mtspr CTR, R11 */
		/* 820A5870h case   12:*/		regs.CTR = regs.R11;
		/* 820A5870h case   12:*/		return 0x820A5874;
		  /* 820A5874h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 820A5874h case   13:*/		if ( 1 ) { regs.LR = 0x820A5878; return (uint32)regs.CTR; }
		/* 820A5874h case   13:*/		return 0x820A5878;
	}
	return 0x820A5878;
} // Block from 820A5840h-820A5878h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A5878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5878);
		  /* 820A5878h */ case    0:  		/* mr R3, R31 */
		/* 820A5878h case    0:*/		regs.R3 = regs.R31;
		/* 820A5878h case    0:*/		return 0x820A587C;
		  /* 820A587Ch */ case    1:  		/* addi R1, R1, 96 */
		/* 820A587Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A587Ch case    1:*/		return 0x820A5880;
		  /* 820A5880h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A5880h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A5880h case    2:*/		return 0x820A5884;
		  /* 820A5884h */ case    3:  		/* mtspr LR, R12 */
		/* 820A5884h case    3:*/		regs.LR = regs.R12;
		/* 820A5884h case    3:*/		return 0x820A5888;
		  /* 820A5888h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820A5888h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A5888h case    4:*/		return 0x820A588C;
		  /* 820A588Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 820A588Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A588Ch case    5:*/		return 0x820A5890;
	}
	return 0x820A5890;
} // Block from 820A5878h-820A5890h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A5890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5890);
		  /* 820A5890h */ case    0:  		/* mfspr R12, LR */
		/* 820A5890h case    0:*/		regs.R12 = regs.LR;
		/* 820A5890h case    0:*/		return 0x820A5894;
		  /* 820A5894h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A5894h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A5894h case    1:*/		return 0x820A5898;
		  /* 820A5898h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A5898h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A5898h case    2:*/		return 0x820A589C;
		  /* 820A589Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A589Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A589Ch case    3:*/		return 0x820A58A0;
		  /* 820A58A0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A58A0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A58A0h case    4:*/		return 0x820A58A4;
		  /* 820A58A4h */ case    5:  		/* mr R30, R4 */
		/* 820A58A4h case    5:*/		regs.R30 = regs.R4;
		/* 820A58A4h case    5:*/		return 0x820A58A8;
		  /* 820A58A8h */ case    6:  		/* mr R31, R3 */
		/* 820A58A8h case    6:*/		regs.R31 = regs.R3;
		/* 820A58A8h case    6:*/		return 0x820A58AC;
		  /* 820A58ACh */ case    7:  		/* lis R4, 9345 */
		/* 820A58ACh case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A58ACh case    7:*/		return 0x820A58B0;
		  /* 820A58B0h */ case    8:  		/* mr R3, R30 */
		/* 820A58B0h case    8:*/		regs.R3 = regs.R30;
		/* 820A58B0h case    8:*/		return 0x820A58B4;
		  /* 820A58B4h */ case    9:  		/* bl -120500 */
		/* 820A58B4h case    9:*/		regs.LR = 0x820A58B8; return 0x82088200;
		/* 820A58B4h case    9:*/		return 0x820A58B8;
		  /* 820A58B8h */ case   10:  		/* stw R3, <#[R31 + 12]> */
		/* 820A58B8h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 820A58B8h case   10:*/		return 0x820A58BC;
		  /* 820A58BCh */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820A58BCh case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A58BCh case   11:*/		return 0x820A58C0;
		  /* 820A58C0h */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 820A58C0h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820A58D0;  }
		/* 820A58C0h case   12:*/		return 0x820A58C4;
		  /* 820A58C4h */ case   13:  		/* lis R3, -32761 */
		/* 820A58C4h case   13:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A58C4h case   13:*/		return 0x820A58C8;
		  /* 820A58C8h */ case   14:  		/* ori R3, R3, 14 */
		/* 820A58C8h case   14:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A58C8h case   14:*/		return 0x820A58CC;
		  /* 820A58CCh */ case   15:  		/* b 12 */
		/* 820A58CCh case   15:*/		return 0x820A58D8;
		/* 820A58CCh case   15:*/		return 0x820A58D0;
	}
	return 0x820A58D0;
} // Block from 820A5890h-820A58D0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A58D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A58D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A58D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A58D0);
		  /* 820A58D0h */ case    0:  		/* stw R30, <#[R31 + 8]> */
		/* 820A58D0h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 820A58D0h case    0:*/		return 0x820A58D4;
		  /* 820A58D4h */ case    1:  		/* li R3, 0 */
		/* 820A58D4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A58D4h case    1:*/		return 0x820A58D8;
	}
	return 0x820A58D8;
} // Block from 820A58D0h-820A58D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A58D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A58D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A58D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A58D8);
		  /* 820A58D8h */ case    0:  		/* addi R1, R1, 112 */
		/* 820A58D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A58D8h case    0:*/		return 0x820A58DC;
		  /* 820A58DCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A58DCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A58DCh case    1:*/		return 0x820A58E0;
		  /* 820A58E0h */ case    2:  		/* mtspr LR, R12 */
		/* 820A58E0h case    2:*/		regs.LR = regs.R12;
		/* 820A58E0h case    2:*/		return 0x820A58E4;
		  /* 820A58E4h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820A58E4h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A58E4h case    3:*/		return 0x820A58E8;
		  /* 820A58E8h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820A58E8h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A58E8h case    4:*/		return 0x820A58EC;
		  /* 820A58ECh */ case    5:  		/* bclr 20, CR0_LT */
		/* 820A58ECh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A58ECh case    5:*/		return 0x820A58F0;
	}
	return 0x820A58F0;
} // Block from 820A58D8h-820A58F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A58F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A58F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A58F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A58F0);
		  /* 820A58F0h */ case    0:  		/* mfspr R12, LR */
		/* 820A58F0h case    0:*/		regs.R12 = regs.LR;
		/* 820A58F0h case    0:*/		return 0x820A58F4;
		  /* 820A58F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A58F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A58F4h case    1:*/		return 0x820A58F8;
	}
	return 0x820A58F8;
} // Block from 820A58F0h-820A58F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A58F8h
// Function '?CallDefine@CPreProcessor@D3DXShader@@IAA?AW4CallDefineDisposition@12@PAUD3DXTOKEN@2@PAVCNode@2@1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A58F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A58F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A58F8);
		  /* 820A58F8h */ case    0:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A58F8h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A58F8h case    0:*/		return 0x820A58FC;
		  /* 820A58FCh */ case    1:  		/* li R11, 0 */
		/* 820A58FCh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A58FCh case    1:*/		return 0x820A5900;
		  /* 820A5900h */ case    2:  		/* lis R10, -32255 */
		/* 820A5900h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A5900h case    2:*/		return 0x820A5904;
		  /* 820A5904h */ case    3:  		/* stw R11, <#[R5]> */
		/* 820A5904h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820A5904h case    3:*/		return 0x820A5908;
		  /* 820A5908h */ case    4:  		/* mr R11, R4 */
		/* 820A5908h case    4:*/		regs.R11 = regs.R4;
		/* 820A5908h case    4:*/		return 0x820A590C;
		  /* 820A590Ch */ case    5:  		/* addi R10, R10, 11180 */
		/* 820A590Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2BAC);
		/* 820A590Ch case    5:*/		return 0x820A5910;
		  /* 820A5910h */ case    6:  		/* addi R9, R4, 16 */
		/* 820A5910h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x10);
		/* 820A5910h case    6:*/		return 0x820A5914;
		  /* 820A5914h */ case    7:  		/* lbz R8, <#[R11]> */
		/* 820A5914h case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A5914h case    7:*/		return 0x820A5918;
		  /* 820A5918h */ case    8:  		/* lbz R7, <#[R10]> */
		/* 820A5918h case    8:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A5918h case    8:*/		return 0x820A591C;
		  /* 820A591Ch */ case    9:  		/* subf. R8, R7, R8 */
		/* 820A591Ch case    9:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A591Ch case    9:*/		return 0x820A5920;
		  /* 820A5920h */ case   10:  		/* bc 4, CR0_EQ, 20 */
		/* 820A5920h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820A5934;  }
		/* 820A5920h case   10:*/		return 0x820A5924;
		  /* 820A5924h */ case   11:  		/* addi R11, R11, 1 */
		/* 820A5924h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A5924h case   11:*/		return 0x820A5928;
		  /* 820A5928h */ case   12:  		/* addi R10, R10, 1 */
		/* 820A5928h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A5928h case   12:*/		return 0x820A592C;
		  /* 820A592Ch */ case   13:  		/* cmpw CR6, R11, R9 */
		/* 820A592Ch case   13:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 820A592Ch case   13:*/		return 0x820A5930;
		  /* 820A5930h */ case   14:  		/* bc 4, CR6_EQ, -28 */
		/* 820A5930h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820A5914;  }
		/* 820A5930h case   14:*/		return 0x820A5934;
	}
	return 0x820A5934;
} // Block from 820A58F8h-820A5934h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A5934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5934);
		  /* 820A5934h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A5934h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A5934h case    0:*/		return 0x820A5938;
		  /* 820A5938h */ case    1:  		/* bc 12, CR0_EQ, 60 */
		/* 820A5938h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A5974;  }
		/* 820A5938h case    1:*/		return 0x820A593C;
		  /* 820A593Ch */ case    2:  		/* lis R10, -32255 */
		/* 820A593Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A593Ch case    2:*/		return 0x820A5940;
		  /* 820A5940h */ case    3:  		/* mr R11, R4 */
		/* 820A5940h case    3:*/		regs.R11 = regs.R4;
		/* 820A5940h case    3:*/		return 0x820A5944;
		  /* 820A5944h */ case    4:  		/* addi R10, R10, 11148 */
		/* 820A5944h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2B8C);
		/* 820A5944h case    4:*/		return 0x820A5948;
		  /* 820A5948h */ case    5:  		/* addi R8, R4, 16 */
		/* 820A5948h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R4,0x10);
		/* 820A5948h case    5:*/		return 0x820A594C;
		  /* 820A594Ch */ case    6:  		/* lbz R9, <#[R11]> */
		/* 820A594Ch case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A594Ch case    6:*/		return 0x820A5950;
		  /* 820A5950h */ case    7:  		/* lbz R7, <#[R10]> */
		/* 820A5950h case    7:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A5950h case    7:*/		return 0x820A5954;
		  /* 820A5954h */ case    8:  		/* subf. R9, R7, R9 */
		/* 820A5954h case    8:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A5954h case    8:*/		return 0x820A5958;
		  /* 820A5958h */ case    9:  		/* bc 4, CR0_EQ, 20 */
		/* 820A5958h case    9:*/		if ( !regs.CR[0].eq ) { return 0x820A596C;  }
		/* 820A5958h case    9:*/		return 0x820A595C;
		  /* 820A595Ch */ case   10:  		/* addi R11, R11, 1 */
		/* 820A595Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A595Ch case   10:*/		return 0x820A5960;
		  /* 820A5960h */ case   11:  		/* addi R10, R10, 1 */
		/* 820A5960h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A5960h case   11:*/		return 0x820A5964;
		  /* 820A5964h */ case   12:  		/* cmpw CR6, R11, R8 */
		/* 820A5964h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820A5964h case   12:*/		return 0x820A5968;
		  /* 820A5968h */ case   13:  		/* bc 4, CR6_EQ, -28 */
		/* 820A5968h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A594C;  }
		/* 820A5968h case   13:*/		return 0x820A596C;
	}
	return 0x820A596C;
} // Block from 820A5934h-820A596Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A596Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A596C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A596C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A596C);
		  /* 820A596Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A596Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A596Ch case    0:*/		return 0x820A5970;
		  /* 820A5970h */ case    1:  		/* bc 4, CR0_EQ, 32 */
		/* 820A5970h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A5990;  }
		/* 820A5970h case    1:*/		return 0x820A5974;
	}
	return 0x820A5974;
} // Block from 820A596Ch-820A5974h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A5974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5974);
		  /* 820A5974h */ case    0:  		/* stw R3, <#[R5]> */
		/* 820A5974h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R5 + 0x00000000) );
		/* 820A5974h case    0:*/		return 0x820A5978;
		  /* 820A5978h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 820A5978h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A5978h case    1:*/		return 0x820A597C;
		  /* 820A597Ch */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 820A597Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820A597Ch case    2:*/		return 0x820A5980;
		  /* 820A5980h */ case    3:  		/* mtspr CTR, R11 */
		/* 820A5980h case    3:*/		regs.CTR = regs.R11;
		/* 820A5980h case    3:*/		return 0x820A5984;
		  /* 820A5984h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820A5984h case    4:*/		if ( 1 ) { regs.LR = 0x820A5988; return (uint32)regs.CTR; }
		/* 820A5984h case    4:*/		return 0x820A5988;
		  /* 820A5988h */ case    5:  		/* li R3, 0 */
		/* 820A5988h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A5988h case    5:*/		return 0x820A598C;
		  /* 820A598Ch */ case    6:  		/* b 12 */
		/* 820A598Ch case    6:*/		return 0x820A5998;
		/* 820A598Ch case    6:*/		return 0x820A5990;
	}
	return 0x820A5990;
} // Block from 820A5974h-820A5990h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A5990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5990);
		  /* 820A5990h */ case    0:  		/* lis R3, -32768 */
		/* 820A5990h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A5990h case    0:*/		return 0x820A5994;
		  /* 820A5994h */ case    1:  		/* ori R3, R3, 16386 */
		/* 820A5994h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4002);
		/* 820A5994h case    1:*/		return 0x820A5998;
	}
	return 0x820A5998;
} // Block from 820A5990h-820A5998h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A5998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5998);
		  /* 820A5998h */ case    0:  		/* addi R1, R1, 96 */
		/* 820A5998h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A5998h case    0:*/		return 0x820A599C;
		  /* 820A599Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A599Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A599Ch case    1:*/		return 0x820A59A0;
		  /* 820A59A0h */ case    2:  		/* mtspr LR, R12 */
		/* 820A59A0h case    2:*/		regs.LR = regs.R12;
		/* 820A59A0h case    2:*/		return 0x820A59A4;
		  /* 820A59A4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820A59A4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A59A4h case    3:*/		return 0x820A59A8;
	}
	return 0x820A59A8;
} // Block from 820A5998h-820A59A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A59A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A59A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A59A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A59A8);
		  /* 820A59A8h */ case    0:  		/* mfspr R12, LR */
		/* 820A59A8h case    0:*/		regs.R12 = regs.LR;
		/* 820A59A8h case    0:*/		return 0x820A59AC;
		  /* 820A59ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A59ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A59ACh case    1:*/		return 0x820A59B0;
		  /* 820A59B0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A59B0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A59B0h case    2:*/		return 0x820A59B4;
		  /* 820A59B4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A59B4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A59B4h case    3:*/		return 0x820A59B8;
		  /* 820A59B8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A59B8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A59B8h case    4:*/		return 0x820A59BC;
		  /* 820A59BCh */ case    5:  		/* mr R31, R3 */
		/* 820A59BCh case    5:*/		regs.R31 = regs.R3;
		/* 820A59BCh case    5:*/		return 0x820A59C0;
		  /* 820A59C0h */ case    6:  		/* lwz R3, <#[R3 + 12]> */
		/* 820A59C0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A59C0h case    6:*/		return 0x820A59C4;
		  /* 820A59C4h */ case    7:  		/* lis R11, -32255 */
		/* 820A59C4h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A59C4h case    7:*/		return 0x820A59C8;
		  /* 820A59C8h */ case    8:  		/* mr R30, R4 */
		/* 820A59C8h case    8:*/		regs.R30 = regs.R4;
		/* 820A59C8h case    8:*/		return 0x820A59CC;
		  /* 820A59CCh */ case    9:  		/* addi R11, R11, -9676 */
		/* 820A59CCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFDA34);
		/* 820A59CCh case    9:*/		return 0x820A59D0;
		  /* 820A59D0h */ case   10:  		/* lis R4, 9345 */
		/* 820A59D0h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A59D0h case   10:*/		return 0x820A59D4;
		  /* 820A59D4h */ case   11:  		/* stw R11, <#[R31]> */
		/* 820A59D4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A59D4h case   11:*/		return 0x820A59D8;
		  /* 820A59D8h */ case   12:  		/* bl -120480 */
		/* 820A59D8h case   12:*/		regs.LR = 0x820A59DC; return 0x82088338;
		/* 820A59D8h case   12:*/		return 0x820A59DC;
		  /* 820A59DCh */ case   13:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 820A59DCh case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 820A59DCh case   13:*/		return 0x820A59E0;
		  /* 820A59E0h */ case   14:  		/* bc 12, CR0_EQ, 16 */
		/* 820A59E0h case   14:*/		if ( regs.CR[0].eq ) { return 0x820A59F0;  }
		/* 820A59E0h case   14:*/		return 0x820A59E4;
		  /* 820A59E4h */ case   15:  		/* lis R4, 9345 */
		/* 820A59E4h case   15:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A59E4h case   15:*/		return 0x820A59E8;
		  /* 820A59E8h */ case   16:  		/* mr R3, R31 */
		/* 820A59E8h case   16:*/		regs.R3 = regs.R31;
		/* 820A59E8h case   16:*/		return 0x820A59EC;
		  /* 820A59ECh */ case   17:  		/* bl -120500 */
		/* 820A59ECh case   17:*/		regs.LR = 0x820A59F0; return 0x82088338;
		/* 820A59ECh case   17:*/		return 0x820A59F0;
	}
	return 0x820A59F0;
} // Block from 820A59A8h-820A59F0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820A59F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A59F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A59F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A59F0);
		  /* 820A59F0h */ case    0:  		/* mr R3, R31 */
		/* 820A59F0h case    0:*/		regs.R3 = regs.R31;
		/* 820A59F0h case    0:*/		return 0x820A59F4;
		  /* 820A59F4h */ case    1:  		/* addi R1, R1, 112 */
		/* 820A59F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A59F4h case    1:*/		return 0x820A59F8;
		  /* 820A59F8h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A59F8h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A59F8h case    2:*/		return 0x820A59FC;
		  /* 820A59FCh */ case    3:  		/* mtspr LR, R12 */
		/* 820A59FCh case    3:*/		regs.LR = regs.R12;
		/* 820A59FCh case    3:*/		return 0x820A5A00;
		  /* 820A5A00h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820A5A00h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A5A00h case    4:*/		return 0x820A5A04;
		  /* 820A5A04h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820A5A04h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A5A04h case    5:*/		return 0x820A5A08;
		  /* 820A5A08h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820A5A08h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A5A08h case    6:*/		return 0x820A5A0C;
	}
	return 0x820A5A0C;
} // Block from 820A59F0h-820A5A0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A5A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5A0C);
		  /* 820A5A0Ch */ case    0:  		/* nop */
		/* 820A5A0Ch case    0:*/		cpu::op::nop();
		/* 820A5A0Ch case    0:*/		return 0x820A5A10;
	}
	return 0x820A5A10;
} // Block from 820A5A0Ch-820A5A10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5A10);
		  /* 820A5A10h */ case    0:  		/* mfspr R12, LR */
		/* 820A5A10h case    0:*/		regs.R12 = regs.LR;
		/* 820A5A10h case    0:*/		return 0x820A5A14;
		  /* 820A5A14h */ case    1:  		/* bl -83896 */
		/* 820A5A14h case    1:*/		regs.LR = 0x820A5A18; return 0x8209125C;
		/* 820A5A14h case    1:*/		return 0x820A5A18;
		  /* 820A5A18h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A5A18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A5A18h case    2:*/		return 0x820A5A1C;
		  /* 820A5A1Ch */ case    3:  		/* mr R30, R3 */
		/* 820A5A1Ch case    3:*/		regs.R30 = regs.R3;
		/* 820A5A1Ch case    3:*/		return 0x820A5A20;
		  /* 820A5A20h */ case    4:  		/* mr R29, R4 */
		/* 820A5A20h case    4:*/		regs.R29 = regs.R4;
		/* 820A5A20h case    4:*/		return 0x820A5A24;
		  /* 820A5A24h */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 820A5A24h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A5A24h case    5:*/		return 0x820A5A28;
		  /* 820A5A28h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820A5A28h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A5A38;  }
		/* 820A5A28h case    6:*/		return 0x820A5A2C;
		  /* 820A5A2Ch */ case    7:  		/* lis R3, -30602 */
		/* 820A5A2Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820A5A2Ch case    7:*/		return 0x820A5A30;
		  /* 820A5A30h */ case    8:  		/* ori R3, R3, 2156 */
		/* 820A5A30h case    8:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 820A5A30h case    8:*/		return 0x820A5A34;
		  /* 820A5A34h */ case    9:  		/* b 160 */
		/* 820A5A34h case    9:*/		return 0x820A5AD4;
		/* 820A5A34h case    9:*/		return 0x820A5A38;
	}
	return 0x820A5A38;
} // Block from 820A5A10h-820A5A38h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A5A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5A38);
		  /* 820A5A38h */ case    0:  		/* lis R4, 9345 */
		/* 820A5A38h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A5A38h case    0:*/		return 0x820A5A3C;
		  /* 820A5A3Ch */ case    1:  		/* li R3, 16 */
		/* 820A5A3Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x10);
		/* 820A5A3Ch case    1:*/		return 0x820A5A40;
		  /* 820A5A40h */ case    2:  		/* bl -120896 */
		/* 820A5A40h case    2:*/		regs.LR = 0x820A5A44; return 0x82088200;
		/* 820A5A40h case    2:*/		return 0x820A5A44;
		  /* 820A5A44h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820A5A44h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A5A44h case    3:*/		return 0x820A5A48;
		  /* 820A5A48h */ case    4:  		/* bc 12, CR0_EQ, 44 */
		/* 820A5A48h case    4:*/		if ( regs.CR[0].eq ) { return 0x820A5A74;  }
		/* 820A5A48h case    4:*/		return 0x820A5A4C;
		  /* 820A5A4Ch */ case    5:  		/* lis R10, -32255 */
		/* 820A5A4Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A5A4Ch case    5:*/		return 0x820A5A50;
		  /* 820A5A50h */ case    6:  		/* li R11, 0 */
		/* 820A5A50h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A5A50h case    6:*/		return 0x820A5A54;
		  /* 820A5A54h */ case    7:  		/* addi R10, R10, -9676 */
		/* 820A5A54h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFDA34);
		/* 820A5A54h case    7:*/		return 0x820A5A58;
		  /* 820A5A58h */ case    8:  		/* li R9, 1 */
		/* 820A5A58h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820A5A58h case    8:*/		return 0x820A5A5C;
		  /* 820A5A5Ch */ case    9:  		/* stw R11, <#[R3 + 12]> */
		/* 820A5A5Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A5A5Ch case    9:*/		return 0x820A5A60;
		  /* 820A5A60h */ case   10:  		/* stw R10, <#[R3]> */
		/* 820A5A60h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820A5A60h case   10:*/		return 0x820A5A64;
		  /* 820A5A64h */ case   11:  		/* mr R31, R3 */
		/* 820A5A64h case   11:*/		regs.R31 = regs.R3;
		/* 820A5A64h case   11:*/		return 0x820A5A68;
		  /* 820A5A68h */ case   12:  		/* stw R11, <#[R3 + 8]> */
		/* 820A5A68h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A5A68h case   12:*/		return 0x820A5A6C;
		  /* 820A5A6Ch */ case   13:  		/* stw R9, <#[R3 + 4]> */
		/* 820A5A6Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820A5A6Ch case   13:*/		return 0x820A5A70;
		  /* 820A5A70h */ case   14:  		/* b 8 */
		/* 820A5A70h case   14:*/		return 0x820A5A78;
		/* 820A5A70h case   14:*/		return 0x820A5A74;
	}
	return 0x820A5A74;
} // Block from 820A5A38h-820A5A74h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A5A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5A74);
		  /* 820A5A74h */ case    0:  		/* li R31, 0 */
		/* 820A5A74h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820A5A74h case    0:*/		return 0x820A5A78;
	}
	return 0x820A5A78;
} // Block from 820A5A74h-820A5A78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5A78);
		  /* 820A5A78h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820A5A78h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A5A78h case    0:*/		return 0x820A5A7C;
		  /* 820A5A7Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A5A7Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A5A8C;  }
		/* 820A5A7Ch case    1:*/		return 0x820A5A80;
		  /* 820A5A80h */ case    2:  		/* lis R3, -32761 */
		/* 820A5A80h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A5A80h case    2:*/		return 0x820A5A84;
		  /* 820A5A84h */ case    3:  		/* ori R3, R3, 14 */
		/* 820A5A84h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A5A84h case    3:*/		return 0x820A5A88;
		  /* 820A5A88h */ case    4:  		/* b 76 */
		/* 820A5A88h case    4:*/		return 0x820A5AD4;
		/* 820A5A88h case    4:*/		return 0x820A5A8C;
	}
	return 0x820A5A8C;
} // Block from 820A5A78h-820A5A8Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A5A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5A8C);
		  /* 820A5A8Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A5A8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A5A8Ch case    0:*/		return 0x820A5A90;
		  /* 820A5A90h */ case    1:  		/* mr R4, R30 */
		/* 820A5A90h case    1:*/		regs.R4 = regs.R30;
		/* 820A5A90h case    1:*/		return 0x820A5A94;
		  /* 820A5A94h */ case    2:  		/* mr R3, R31 */
		/* 820A5A94h case    2:*/		regs.R3 = regs.R31;
		/* 820A5A94h case    2:*/		return 0x820A5A98;
		  /* 820A5A98h */ case    3:  		/* lwz R11, <#[R11 + 24]> */
		/* 820A5A98h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820A5A98h case    3:*/		return 0x820A5A9C;
		  /* 820A5A9Ch */ case    4:  		/* mtspr CTR, R11 */
		/* 820A5A9Ch case    4:*/		regs.CTR = regs.R11;
		/* 820A5A9Ch case    4:*/		return 0x820A5AA0;
		  /* 820A5AA0h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820A5AA0h case    5:*/		if ( 1 ) { regs.LR = 0x820A5AA4; return (uint32)regs.CTR; }
		/* 820A5AA0h case    5:*/		return 0x820A5AA4;
		  /* 820A5AA4h */ case    6:  		/* or. R30, R3, R3 */
		/* 820A5AA4h case    6:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A5AA4h case    6:*/		return 0x820A5AA8;
		  /* 820A5AA8h */ case    7:  		/* bc 4, CR0_LT, 36 */
		/* 820A5AA8h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820A5ACC;  }
		/* 820A5AA8h case    7:*/		return 0x820A5AAC;
		  /* 820A5AACh */ case    8:  		/* lwz R11, <#[R31]> */
		/* 820A5AACh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A5AACh case    8:*/		return 0x820A5AB0;
		  /* 820A5AB0h */ case    9:  		/* li R4, 1 */
		/* 820A5AB0h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A5AB0h case    9:*/		return 0x820A5AB4;
		  /* 820A5AB4h */ case   10:  		/* mr R3, R31 */
		/* 820A5AB4h case   10:*/		regs.R3 = regs.R31;
		/* 820A5AB4h case   10:*/		return 0x820A5AB8;
		  /* 820A5AB8h */ case   11:  		/* lwz R11, <#[R11 + 20]> */
		/* 820A5AB8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820A5AB8h case   11:*/		return 0x820A5ABC;
		  /* 820A5ABCh */ case   12:  		/* mtspr CTR, R11 */
		/* 820A5ABCh case   12:*/		regs.CTR = regs.R11;
		/* 820A5ABCh case   12:*/		return 0x820A5AC0;
		  /* 820A5AC0h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 820A5AC0h case   13:*/		if ( 1 ) { regs.LR = 0x820A5AC4; return (uint32)regs.CTR; }
		/* 820A5AC0h case   13:*/		return 0x820A5AC4;
		  /* 820A5AC4h */ case   14:  		/* mr R3, R30 */
		/* 820A5AC4h case   14:*/		regs.R3 = regs.R30;
		/* 820A5AC4h case   14:*/		return 0x820A5AC8;
		  /* 820A5AC8h */ case   15:  		/* b 12 */
		/* 820A5AC8h case   15:*/		return 0x820A5AD4;
		/* 820A5AC8h case   15:*/		return 0x820A5ACC;
	}
	return 0x820A5ACC;
} // Block from 820A5A8Ch-820A5ACCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A5ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5ACC);
		  /* 820A5ACCh */ case    0:  		/* stw R31, <#[R29]> */
		/* 820A5ACCh case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 820A5ACCh case    0:*/		return 0x820A5AD0;
		  /* 820A5AD0h */ case    1:  		/* li R3, 0 */
		/* 820A5AD0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A5AD0h case    1:*/		return 0x820A5AD4;
	}
	return 0x820A5AD4;
} // Block from 820A5ACCh-820A5AD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A5AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5AD4);
		  /* 820A5AD4h */ case    0:  		/* addi R1, R1, 112 */
		/* 820A5AD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A5AD4h case    0:*/		return 0x820A5AD8;
		  /* 820A5AD8h */ case    1:  		/* b -84012 */
		/* 820A5AD8h case    1:*/		return 0x820912AC;
		/* 820A5AD8h case    1:*/		return 0x820A5ADC;
		  /* 820A5ADCh */ case    2:  		/* nop */
		/* 820A5ADCh case    2:*/		cpu::op::nop();
		/* 820A5ADCh case    2:*/		return 0x820A5AE0;
	}
	return 0x820A5AE0;
} // Block from 820A5AD4h-820A5AE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A5AE0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5AE0);
		  /* 820A5AE0h */ case    0:  		/* b -208 */
		/* 820A5AE0h case    0:*/		return 0x820A5A10;
		/* 820A5AE0h case    0:*/		return 0x820A5AE4;
		  /* 820A5AE4h */ case    1:  		/* nop */
		/* 820A5AE4h case    1:*/		cpu::op::nop();
		/* 820A5AE4h case    1:*/		return 0x820A5AE8;
		  /* 820A5AE8h */ case    2:  		/* li R11, 0 */
		/* 820A5AE8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A5AE8h case    2:*/		return 0x820A5AEC;
		  /* 820A5AECh */ case    3:  		/* cmplwi CR6, R5, 0 */
		/* 820A5AECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820A5AECh case    3:*/		return 0x820A5AF0;
		  /* 820A5AF0h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 820A5AF0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A5AF8;  }
		/* 820A5AF0h case    4:*/		return 0x820A5AF4;
		  /* 820A5AF4h */ case    5:  		/* stw R11, <#[R5]> */
		/* 820A5AF4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820A5AF4h case    5:*/		return 0x820A5AF8;
	}
	return 0x820A5AF8;
} // Block from 820A5AE0h-820A5AF8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A5AF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5AF8);
		  /* 820A5AF8h */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 820A5AF8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820A5AF8h case    0:*/		return 0x820A5AFC;
		  /* 820A5AFCh */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820A5AFCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820A5B04;  }
		/* 820A5AFCh case    1:*/		return 0x820A5B00;
		  /* 820A5B00h */ case    2:  		/* stw R11, <#[R6]> */
		/* 820A5B00h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 820A5B00h case    2:*/		return 0x820A5B04;
	}
	return 0x820A5B04;
} // Block from 820A5AF8h-820A5B04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A5B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5B04);
		  /* 820A5B04h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820A5B04h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A5B04h case    0:*/		return 0x820A5B08;
		  /* 820A5B08h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A5B08h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A5B18;  }
		/* 820A5B08h case    1:*/		return 0x820A5B0C;
		  /* 820A5B0Ch */ case    2:  		/* lis R3, -30602 */
		/* 820A5B0Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820A5B0Ch case    2:*/		return 0x820A5B10;
		  /* 820A5B10h */ case    3:  		/* ori R3, R3, 2156 */
		/* 820A5B10h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 820A5B10h case    3:*/		return 0x820A5B14;
		  /* 820A5B14h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A5B14h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A5B14h case    4:*/		return 0x820A5B18;
	}
	return 0x820A5B18;
} // Block from 820A5B04h-820A5B18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A5B18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5B18);
		  /* 820A5B18h */ case    0:  		/* lwz R8, <#[R3]> */
		/* 820A5B18h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820A5B18h case    0:*/		return 0x820A5B1C;
		  /* 820A5B1Ch */ case    1:  		/* lis R11, 4138 */
		/* 820A5B1Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0x102A);
		/* 820A5B1Ch case    1:*/		return 0x820A5B20;
		  /* 820A5B20h */ case    2:  		/* ori R11, R11, 4352 */
		/* 820A5B20h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1100);
		/* 820A5B20h case    2:*/		return 0x820A5B24;
		  /* 820A5B24h */ case    3:  		/* rlwinm R10, R8, 0, 0, 23 */
		/* 820A5B24h case    3:*/		cpu::op::rlwinm<0,0,0,23>(regs,&regs.R10,regs.R8);
		/* 820A5B24h case    3:*/		return 0x820A5B28;
		  /* 820A5B28h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 820A5B28h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820A5B28h case    4:*/		return 0x820A5B2C;
		  /* 820A5B2Ch */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 820A5B2Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A5B38;  }
		/* 820A5B2Ch case    5:*/		return 0x820A5B30;
		  /* 820A5B30h */ case    6:  		/* li R3, 1 */
		/* 820A5B30h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820A5B30h case    6:*/		return 0x820A5B34;
		  /* 820A5B34h */ case    7:  		/* bclr 20, CR0_LT */
		/* 820A5B34h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A5B34h case    7:*/		return 0x820A5B38;
	}
	return 0x820A5B38;
} // Block from 820A5B18h-820A5B38h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A5B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5B38);
		  /* 820A5B38h */ case    0:  		/* rlwinm R11, R8, 0, 0, 15 */
		/* 820A5B38h case    0:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R8);
		/* 820A5B38h case    0:*/		return 0x820A5B3C;
		  /* 820A5B3Ch */ case    1:  		/* lis R10, 18008 */
		/* 820A5B3Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x4658);
		/* 820A5B3Ch case    1:*/		return 0x820A5B40;
		  /* 820A5B40h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820A5B40h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A5B40h case    2:*/		return 0x820A5B44;
		  /* 820A5B44h */ case    3:  		/* bc 12, CR6_EQ, 76 */
		/* 820A5B44h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A5B90;  }
		/* 820A5B44h case    3:*/		return 0x820A5B48;
		  /* 820A5B48h */ case    4:  		/* lis R10, 21592 */
		/* 820A5B48h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x5458);
		/* 820A5B48h case    4:*/		return 0x820A5B4C;
		  /* 820A5B4Ch */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820A5B4Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A5B4Ch case    5:*/		return 0x820A5B50;
		  /* 820A5B50h */ case    6:  		/* bc 12, CR6_EQ, 64 */
		/* 820A5B50h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A5B90;  }
		/* 820A5B50h case    6:*/		return 0x820A5B54;
		  /* 820A5B54h */ case    7:  		/* lis R10, 32766 */
		/* 820A5B54h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FFE);
		/* 820A5B54h case    7:*/		return 0x820A5B58;
		  /* 820A5B58h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820A5B58h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A5B58h case    8:*/		return 0x820A5B5C;
		  /* 820A5B5Ch */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 820A5B5Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820A5B90;  }
		/* 820A5B5Ch case    9:*/		return 0x820A5B60;
		  /* 820A5B60h */ case   10:  		/* lis R10, 32767 */
		/* 820A5B60h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FFF);
		/* 820A5B60h case   10:*/		return 0x820A5B64;
		  /* 820A5B64h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820A5B64h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A5B64h case   11:*/		return 0x820A5B68;
		  /* 820A5B68h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 820A5B68h case   12:*/		if ( regs.CR[6].eq ) { return 0x820A5B90;  }
		/* 820A5B68h case   12:*/		return 0x820A5B6C;
		  /* 820A5B6Ch */ case   13:  		/* lis R10, -2 */
		/* 820A5B6Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820A5B6Ch case   13:*/		return 0x820A5B70;
		  /* 820A5B70h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 820A5B70h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A5B70h case   14:*/		return 0x820A5B74;
		  /* 820A5B74h */ case   15:  		/* bc 12, CR6_EQ, 28 */
		/* 820A5B74h case   15:*/		if ( regs.CR[6].eq ) { return 0x820A5B90;  }
		/* 820A5B74h case   15:*/		return 0x820A5B78;
		  /* 820A5B78h */ case   16:  		/* lis R10, -1 */
		/* 820A5B78h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820A5B78h case   16:*/		return 0x820A5B7C;
		  /* 820A5B7Ch */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 820A5B7Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A5B7Ch case   17:*/		return 0x820A5B80;
		  /* 820A5B80h */ case   18:  		/* bc 12, CR6_EQ, 16 */
		/* 820A5B80h case   18:*/		if ( regs.CR[6].eq ) { return 0x820A5B90;  }
		/* 820A5B80h case   18:*/		return 0x820A5B84;
		  /* 820A5B84h */ case   19:  		/* lis R3, -30602 */
		/* 820A5B84h case   19:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820A5B84h case   19:*/		return 0x820A5B88;
		  /* 820A5B88h */ case   20:  		/* ori R3, R3, 2905 */
		/* 820A5B88h case   20:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xB59);
		/* 820A5B88h case   20:*/		return 0x820A5B8C;
		  /* 820A5B8Ch */ case   21:  		/* bclr 20, CR0_LT */
		/* 820A5B8Ch case   21:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A5B8Ch case   21:*/		return 0x820A5B90;
	}
	return 0x820A5B90;
} // Block from 820A5B38h-820A5B90h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820A5B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5B90);
		  /* 820A5B90h */ case    0:  		/* addi R11, R3, 4 */
		/* 820A5B90h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x4);
		/* 820A5B90h case    0:*/		return 0x820A5B94;
		  /* 820A5B94h */ case    1:  		/* lwz R10, <#[R11]> */
		/* 820A5B94h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A5B94h case    1:*/		return 0x820A5B98;
		  /* 820A5B98h */ case    2:  		/* rlwinm. R9, R10, 0, 0, 0 */
		/* 820A5B98h case    2:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R10);
		/* 820A5B98h case    2:*/		return 0x820A5B9C;
		  /* 820A5B9Ch */ case    3:  		/* bc 4, CR0_EQ, 92 */
		/* 820A5B9Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x820A5BF8;  }
		/* 820A5B9Ch case    3:*/		return 0x820A5BA0;
		  /* 820A5BA0h */ case    4:  		/* rlwinm R9, R10, 0, 16, 31 */
		/* 820A5BA0h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R10);
		/* 820A5BA0h case    4:*/		return 0x820A5BA4;
		  /* 820A5BA4h */ case    5:  		/* cmplwi CR6, R9, 65535 */
		/* 820A5BA4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000FFFF);
		/* 820A5BA4h case    5:*/		return 0x820A5BA8;
		  /* 820A5BA8h */ case    6:  		/* bc 12, CR6_EQ, -120 */
		/* 820A5BA8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A5B30;  }
		/* 820A5BA8h case    6:*/		return 0x820A5BAC;
		  /* 820A5BACh */ case    7:  		/* cmplwi CR6, R9, 65534 */
		/* 820A5BACh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000FFFE);
		/* 820A5BACh case    7:*/		return 0x820A5BB0;
		  /* 820A5BB0h */ case    8:  		/* bc 4, CR6_EQ, 40 */
		/* 820A5BB0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A5BD8;  }
		/* 820A5BB0h case    8:*/		return 0x820A5BB4;
		  /* 820A5BB4h */ case    9:  		/* rlwinm R10, R10, 16, 17, 31 */
		/* 820A5BB4h case    9:*/		cpu::op::rlwinm<0,16,17,31>(regs,&regs.R10,regs.R10);
		/* 820A5BB4h case    9:*/		return 0x820A5BB8;
		  /* 820A5BB8h */ case   10:  		/* cmplwi CR6, R10, 1 */
		/* 820A5BB8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820A5BB8h case   10:*/		return 0x820A5BBC;
		  /* 820A5BBCh */ case   11:  		/* bc 4, CR6_GT, 16 */
		/* 820A5BBCh case   11:*/		if ( !regs.CR[6].gt ) { return 0x820A5BCC;  }
		/* 820A5BBCh case   11:*/		return 0x820A5BC0;
		  /* 820A5BC0h */ case   12:  		/* lwz R9, <#[R11 + 4]> */
		/* 820A5BC0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820A5BC0h case   12:*/		return 0x820A5BC4;
		  /* 820A5BC4h */ case   13:  		/* cmplw CR6, R4, R9 */
		/* 820A5BC4h case   13:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R9);
		/* 820A5BC4h case   13:*/		return 0x820A5BC8;
		  /* 820A5BC8h */ case   14:  		/* bc 12, CR6_EQ, 56 */
		/* 820A5BC8h case   14:*/		if ( regs.CR[6].eq ) { return 0x820A5C00;  }
		/* 820A5BC8h case   14:*/		return 0x820A5BCC;
	}
	return 0x820A5BCC;
} // Block from 820A5B90h-820A5BCCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A5BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5BCC);
		  /* 820A5BCCh */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820A5BCCh case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820A5BCCh case    0:*/		return 0x820A5BD0;
		  /* 820A5BD0h */ case    1:  		/* add R11, R10, R11 */
		/* 820A5BD0h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A5BD0h case    1:*/		return 0x820A5BD4;
		  /* 820A5BD4h */ case    2:  		/* b 36 */
		/* 820A5BD4h case    2:*/		return 0x820A5BF8;
		/* 820A5BD4h case    2:*/		return 0x820A5BD8;
	}
	return 0x820A5BD8;
} // Block from 820A5BCCh-820A5BD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A5BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5BD8);
		  /* 820A5BD8h */ case    0:  		/* rlwinm R7, R8, 0, 16, 31 */
		/* 820A5BD8h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R7,regs.R8);
		/* 820A5BD8h case    0:*/		return 0x820A5BDC;
		  /* 820A5BDCh */ case    1:  		/* cmplwi CR6, R7, 512 */
		/* 820A5BDCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000200);
		/* 820A5BDCh case    1:*/		return 0x820A5BE0;
		  /* 820A5BE0h */ case    2:  		/* bc 12, CR6_LT, 12 */
		/* 820A5BE0h case    2:*/		if ( regs.CR[6].lt ) { return 0x820A5BEC;  }
		/* 820A5BE0h case    2:*/		return 0x820A5BE4;
		  /* 820A5BE4h */ case    3:  		/* rlwinm R10, R10, 10, 26, 29 */
		/* 820A5BE4h case    3:*/		cpu::op::rlwinm<0,10,26,29>(regs,&regs.R10,regs.R10);
		/* 820A5BE4h case    3:*/		return 0x820A5BE8;
		  /* 820A5BE8h */ case    4:  		/* b -24 */
		/* 820A5BE8h case    4:*/		return 0x820A5BD0;
		/* 820A5BE8h case    4:*/		return 0x820A5BEC;
	}
	return 0x820A5BEC;
} // Block from 820A5BD8h-820A5BECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A5BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5BEC);
		  /* 820A5BECh */ case    0:  		/* cmplwi CR6, R9, 81 */
		/* 820A5BECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000051);
		/* 820A5BECh case    0:*/		return 0x820A5BF0;
		  /* 820A5BF0h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 820A5BF0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A5BF8;  }
		/* 820A5BF0h case    1:*/		return 0x820A5BF4;
		  /* 820A5BF4h */ case    2:  		/* addi R11, R11, 20 */
		/* 820A5BF4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x14);
		/* 820A5BF4h case    2:*/		return 0x820A5BF8;
	}
	return 0x820A5BF8;
} // Block from 820A5BECh-820A5BF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A5BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5BF8);
		  /* 820A5BF8h */ case    0:  		/* addi R11, R11, 4 */
		/* 820A5BF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820A5BF8h case    0:*/		return 0x820A5BFC;
		  /* 820A5BFCh */ case    1:  		/* b -104 */
		/* 820A5BFCh case    1:*/		return 0x820A5B94;
		/* 820A5BFCh case    1:*/		return 0x820A5C00;
	}
	return 0x820A5C00;
} // Block from 820A5BF8h-820A5C00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A5C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5C00);
		  /* 820A5C00h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820A5C00h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820A5C00h case    0:*/		return 0x820A5C04;
		  /* 820A5C04h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820A5C04h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A5C10;  }
		/* 820A5C04h case    1:*/		return 0x820A5C08;
		  /* 820A5C08h */ case    2:  		/* addi R11, R11, 8 */
		/* 820A5C08h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820A5C08h case    2:*/		return 0x820A5C0C;
		  /* 820A5C0Ch */ case    3:  		/* stw R11, <#[R5]> */
		/* 820A5C0Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820A5C0Ch case    3:*/		return 0x820A5C10;
	}
	return 0x820A5C10;
} // Block from 820A5C00h-820A5C10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A5C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5C10);
		  /* 820A5C10h */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 820A5C10h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820A5C10h case    0:*/		return 0x820A5C14;
		  /* 820A5C14h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820A5C14h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A5C24;  }
		/* 820A5C14h case    1:*/		return 0x820A5C18;
		  /* 820A5C18h */ case    2:  		/* addi R11, R10, -1 */
		/* 820A5C18h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 820A5C18h case    2:*/		return 0x820A5C1C;
		  /* 820A5C1Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820A5C1Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820A5C1Ch case    3:*/		return 0x820A5C20;
		  /* 820A5C20h */ case    4:  		/* stw R11, <#[R6]> */
		/* 820A5C20h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 820A5C20h case    4:*/		return 0x820A5C24;
	}
	return 0x820A5C24;
} // Block from 820A5C10h-820A5C24h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A5C24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5C24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5C24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5C24);
		  /* 820A5C24h */ case    0:  		/* li R3, 0 */
		/* 820A5C24h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A5C24h case    0:*/		return 0x820A5C28;
		  /* 820A5C28h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820A5C28h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A5C28h case    1:*/		return 0x820A5C2C;
	}
	return 0x820A5C2C;
} // Block from 820A5C24h-820A5C2Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A5C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5C2C);
		  /* 820A5C2Ch */ case    0:  		/* nop */
		/* 820A5C2Ch case    0:*/		cpu::op::nop();
		/* 820A5C2Ch case    0:*/		return 0x820A5C30;
	}
	return 0x820A5C30;
} // Block from 820A5C2Ch-820A5C30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5C30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5C30);
		  /* 820A5C30h */ case    0:  		/* li R11, 0 */
		/* 820A5C30h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A5C30h case    0:*/		return 0x820A5C34;
		  /* 820A5C34h */ case    1:  		/* li R10, 1 */
		/* 820A5C34h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820A5C34h case    1:*/		return 0x820A5C38;
		  /* 820A5C38h */ case    2:  		/* stw R11, <#[R3 + 20]> */
		/* 820A5C38h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820A5C38h case    2:*/		return 0x820A5C3C;
		  /* 820A5C3Ch */ case    3:  		/* stw R11, <#[R3 + 24]> */
		/* 820A5C3Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820A5C3Ch case    3:*/		return 0x820A5C40;
		  /* 820A5C40h */ case    4:  		/* stw R11, <#[R3 + 28]> */
		/* 820A5C40h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820A5C40h case    4:*/		return 0x820A5C44;
		  /* 820A5C44h */ case    5:  		/* stw R11, <#[R3 + 32]> */
		/* 820A5C44h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820A5C44h case    5:*/		return 0x820A5C48;
		  /* 820A5C48h */ case    6:  		/* stw R10, <#[R3 + 36]> */
		/* 820A5C48h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000024) );
		/* 820A5C48h case    6:*/		return 0x820A5C4C;
		  /* 820A5C4Ch */ case    7:  		/* stw R11, <#[R3]> */
		/* 820A5C4Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A5C4Ch case    7:*/		return 0x820A5C50;
		  /* 820A5C50h */ case    8:  		/* stw R11, <#[R3 + 4]> */
		/* 820A5C50h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820A5C50h case    8:*/		return 0x820A5C54;
		  /* 820A5C54h */ case    9:  		/* stw R11, <#[R3 + 8]> */
		/* 820A5C54h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A5C54h case    9:*/		return 0x820A5C58;
		  /* 820A5C58h */ case   10:  		/* stw R11, <#[R3 + 12]> */
		/* 820A5C58h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A5C58h case   10:*/		return 0x820A5C5C;
		  /* 820A5C5Ch */ case   11:  		/* stb R11, <#[R3 + 16]> */
		/* 820A5C5Ch case   11:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820A5C5Ch case   11:*/		return 0x820A5C60;
		  /* 820A5C60h */ case   12:  		/* bclr 20, CR0_LT */
		/* 820A5C60h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A5C60h case   12:*/		return 0x820A5C64;
	}
	return 0x820A5C64;
} // Block from 820A5C30h-820A5C64h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A5C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5C64);
		  /* 820A5C64h */ case    0:  		/* nop */
		/* 820A5C64h case    0:*/		cpu::op::nop();
		/* 820A5C64h case    0:*/		return 0x820A5C68;
	}
	return 0x820A5C68;
} // Block from 820A5C64h-820A5C68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5C68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5C68);
		  /* 820A5C68h */ case    0:  		/* mfspr R12, LR */
		/* 820A5C68h case    0:*/		regs.R12 = regs.LR;
		/* 820A5C68h case    0:*/		return 0x820A5C6C;
		  /* 820A5C6Ch */ case    1:  		/* bl -84496 */
		/* 820A5C6Ch case    1:*/		regs.LR = 0x820A5C70; return 0x8209125C;
		/* 820A5C6Ch case    1:*/		return 0x820A5C70;
		  /* 820A5C70h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A5C70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A5C70h case    2:*/		return 0x820A5C74;
		  /* 820A5C74h */ case    3:  		/* mr R29, R3 */
		/* 820A5C74h case    3:*/		regs.R29 = regs.R3;
		/* 820A5C74h case    3:*/		return 0x820A5C78;
		  /* 820A5C78h */ case    4:  		/* mr R31, R4 */
		/* 820A5C78h case    4:*/		regs.R31 = regs.R4;
		/* 820A5C78h case    4:*/		return 0x820A5C7C;
		  /* 820A5C7Ch */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 820A5C7Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A5C7Ch case    5:*/		return 0x820A5C80;
		  /* 820A5C80h */ case    6:  		/* bc 12, CR6_EQ, 148 */
		/* 820A5C80h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A5D14;  }
		/* 820A5C80h case    6:*/		return 0x820A5C84;
		  /* 820A5C84h */ case    7:  		/* lwz R11, <#[R3 + 24]> */
		/* 820A5C84h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820A5C84h case    7:*/		return 0x820A5C88;
		  /* 820A5C88h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820A5C88h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A5C88h case    8:*/		return 0x820A5C8C;
		  /* 820A5C8Ch */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 820A5C8Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A5C98;  }
		/* 820A5C8Ch case    9:*/		return 0x820A5C90;
		  /* 820A5C90h */ case   10:  		/* stw R11, <#[R4]> */
		/* 820A5C90h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820A5C90h case   10:*/		return 0x820A5C94;
		  /* 820A5C94h */ case   11:  		/* b 128 */
		/* 820A5C94h case   11:*/		return 0x820A5D14;
		/* 820A5C94h case   11:*/		return 0x820A5C98;
	}
	return 0x820A5C98;
} // Block from 820A5C68h-820A5C98h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A5C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5C98);
		  /* 820A5C98h */ case    0:  		/* mr R4, R31 */
		/* 820A5C98h case    0:*/		regs.R4 = regs.R31;
		/* 820A5C98h case    0:*/		return 0x820A5C9C;
		  /* 820A5C9Ch */ case    1:  		/* addi R3, R11, 1 */
		/* 820A5C9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 820A5C9Ch case    1:*/		return 0x820A5CA0;
		  /* 820A5CA0h */ case    2:  		/* bl -656 */
		/* 820A5CA0h case    2:*/		regs.LR = 0x820A5CA4; return 0x820A5A10;
		/* 820A5CA0h case    2:*/		return 0x820A5CA4;
		  /* 820A5CA4h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820A5CA4h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A5CA4h case    3:*/		return 0x820A5CA8;
		  /* 820A5CA8h */ case    4:  		/* bc 12, CR0_LT, 112 */
		/* 820A5CA8h case    4:*/		if ( regs.CR[0].lt ) { return 0x820A5D18;  }
		/* 820A5CA8h case    4:*/		return 0x820A5CAC;
		  /* 820A5CACh */ case    5:  		/* lwz R3, <#[R31]> */
		/* 820A5CACh case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A5CACh case    5:*/		return 0x820A5CB0;
		  /* 820A5CB0h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820A5CB0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A5CB0h case    6:*/		return 0x820A5CB4;
		  /* 820A5CB4h */ case    7:  		/* lwz R11, <#[R11 + 12]> */
		/* 820A5CB4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A5CB4h case    7:*/		return 0x820A5CB8;
		  /* 820A5CB8h */ case    8:  		/* mtspr CTR, R11 */
		/* 820A5CB8h case    8:*/		regs.CTR = regs.R11;
		/* 820A5CB8h case    8:*/		return 0x820A5CBC;
		  /* 820A5CBCh */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820A5CBCh case    9:*/		if ( 1 ) { regs.LR = 0x820A5CC0; return (uint32)regs.CTR; }
		/* 820A5CBCh case    9:*/		return 0x820A5CC0;
		  /* 820A5CC0h */ case   10:  		/* lwz R11, <#[R29 + 24]> */
		/* 820A5CC0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820A5CC0h case   10:*/		return 0x820A5CC4;
		  /* 820A5CC4h */ case   11:  		/* li R10, 0 */
		/* 820A5CC4h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A5CC4h case   11:*/		return 0x820A5CC8;
		  /* 820A5CC8h */ case   12:  		/* add R30, R3, R11 */
		/* 820A5CC8h case   12:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R11);
		/* 820A5CC8h case   12:*/		return 0x820A5CCC;
		  /* 820A5CCCh */ case   13:  		/* stb R10, <#[R30]> */
		/* 820A5CCCh case   13:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820A5CCCh case   13:*/		return 0x820A5CD0;
		  /* 820A5CD0h */ case   14:  		/* lwz R31, <#[R29 + 20]> */
		/* 820A5CD0h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000014) );
		/* 820A5CD0h case   14:*/		return 0x820A5CD4;
		  /* 820A5CD4h */ case   15:  		/* b 56 */
		/* 820A5CD4h case   15:*/		return 0x820A5D0C;
		/* 820A5CD4h case   15:*/		return 0x820A5CD8;
		  /* 820A5CD8h */ case   16:  		/* addi R4, R31, 4 */
		/* 820A5CD8h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x4);
		/* 820A5CD8h case   16:*/		return 0x820A5CDC;
		  /* 820A5CDCh */ case   17:  		/* mr R11, R4 */
		/* 820A5CDCh case   17:*/		regs.R11 = regs.R4;
		/* 820A5CDCh case   17:*/		return 0x820A5CE0;
		  /* 820A5CE0h */ case   18:  		/* lbz R10, <#[R11]> */
		/* 820A5CE0h case   18:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A5CE0h case   18:*/		return 0x820A5CE4;
		  /* 820A5CE4h */ case   19:  		/* addi R11, R11, 1 */
		/* 820A5CE4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A5CE4h case   19:*/		return 0x820A5CE8;
		  /* 820A5CE8h */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 820A5CE8h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A5CE8h case   20:*/		return 0x820A5CEC;
		  /* 820A5CECh */ case   21:  		/* bc 4, CR6_EQ, -12 */
		/* 820A5CECh case   21:*/		if ( !regs.CR[6].eq ) { return 0x820A5CE0;  }
		/* 820A5CECh case   21:*/		return 0x820A5CF0;
		  /* 820A5CF0h */ case   22:  		/* subf R11, R4, R11 */
		/* 820A5CF0h case   22:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 820A5CF0h case   22:*/		return 0x820A5CF4;
		  /* 820A5CF4h */ case   23:  		/* addi R11, R11, -1 */
		/* 820A5CF4h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A5CF4h case   23:*/		return 0x820A5CF8;
		  /* 820A5CF8h */ case   24:  		/* rlwinm R5, R11, 0, 0, 31 */
		/* 820A5CF8h case   24:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R5,regs.R11);
		/* 820A5CF8h case   24:*/		return 0x820A5CFC;
		  /* 820A5CFCh */ case   25:  		/* subf R30, R5, R30 */
		/* 820A5CFCh case   25:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R5,regs.R30);
		/* 820A5CFCh case   25:*/		return 0x820A5D00;
		  /* 820A5D00h */ case   26:  		/* mr R3, R30 */
		/* 820A5D00h case   26:*/		regs.R3 = regs.R30;
		/* 820A5D00h case   26:*/		return 0x820A5D04;
		  /* 820A5D04h */ case   27:  		/* bl -82772 */
		/* 820A5D04h case   27:*/		regs.LR = 0x820A5D08; return 0x820919B0;
		/* 820A5D04h case   27:*/		return 0x820A5D08;
		  /* 820A5D08h */ case   28:  		/* lwz R31, <#[R31]> */
		/* 820A5D08h case   28:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000000) );
		/* 820A5D08h case   28:*/		return 0x820A5D0C;
	}
	return 0x820A5D0C;
} // Block from 820A5C98h-820A5D0Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 820A5D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5D0C);
		  /* 820A5D0Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820A5D0Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A5D0Ch case    0:*/		return 0x820A5D10;
		  /* 820A5D10h */ case    1:  		/* bc 4, CR6_EQ, -56 */
		/* 820A5D10h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A5CD8;  }
		/* 820A5D10h case    1:*/		return 0x820A5D14;
	}
	return 0x820A5D14;
} // Block from 820A5D0Ch-820A5D14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A5D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5D14);
		  /* 820A5D14h */ case    0:  		/* li R3, 0 */
		/* 820A5D14h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A5D14h case    0:*/		return 0x820A5D18;
	}
	return 0x820A5D18;
} // Block from 820A5D14h-820A5D18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5D18);
		  /* 820A5D18h */ case    0:  		/* addi R1, R1, 112 */
		/* 820A5D18h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A5D18h case    0:*/		return 0x820A5D1C;
		  /* 820A5D1Ch */ case    1:  		/* b -84592 */
		/* 820A5D1Ch case    1:*/		return 0x820912AC;
		/* 820A5D1Ch case    1:*/		return 0x820A5D20;
	}
	return 0x820A5D20;
} // Block from 820A5D18h-820A5D20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A5D20h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5D20);
		  /* 820A5D20h */ case    0:  		/* lwz R3, <#[R3 + 28]> */
		/* 820A5D20h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000001C) );
		/* 820A5D20h case    0:*/		return 0x820A5D24;
		  /* 820A5D24h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820A5D24h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A5D24h case    1:*/		return 0x820A5D28;
	}
	return 0x820A5D28;
} // Block from 820A5D20h-820A5D28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A5D28h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5D28);
		  /* 820A5D28h */ case    0:  		/* mfspr R12, LR */
		/* 820A5D28h case    0:*/		regs.R12 = regs.LR;
		/* 820A5D28h case    0:*/		return 0x820A5D2C;
		  /* 820A5D2Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A5D2Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A5D2Ch case    1:*/		return 0x820A5D30;
		  /* 820A5D30h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A5D30h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A5D30h case    2:*/		return 0x820A5D34;
		  /* 820A5D34h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A5D34h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A5D34h case    3:*/		return 0x820A5D38;
		  /* 820A5D38h */ case    4:  		/* li R5, 1556 */
		/* 820A5D38h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x614);
		/* 820A5D38h case    4:*/		return 0x820A5D3C;
		  /* 820A5D3Ch */ case    5:  		/* li R4, 0 */
		/* 820A5D3Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A5D3Ch case    5:*/		return 0x820A5D40;
		  /* 820A5D40h */ case    6:  		/* mr R31, R3 */
		/* 820A5D40h case    6:*/		regs.R31 = regs.R3;
		/* 820A5D40h case    6:*/		return 0x820A5D44;
		  /* 820A5D44h */ case    7:  		/* bl -84484 */
		/* 820A5D44h case    7:*/		regs.LR = 0x820A5D48; return 0x82091340;
		/* 820A5D44h case    7:*/		return 0x820A5D48;
		  /* 820A5D48h */ case    8:  		/* mr R3, R31 */
		/* 820A5D48h case    8:*/		regs.R3 = regs.R31;
		/* 820A5D48h case    8:*/		return 0x820A5D4C;
		  /* 820A5D4Ch */ case    9:  		/* addi R1, R1, 96 */
		/* 820A5D4Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A5D4Ch case    9:*/		return 0x820A5D50;
		  /* 820A5D50h */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A5D50h case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A5D50h case   10:*/		return 0x820A5D54;
		  /* 820A5D54h */ case   11:  		/* mtspr LR, R12 */
		/* 820A5D54h case   11:*/		regs.LR = regs.R12;
		/* 820A5D54h case   11:*/		return 0x820A5D58;
		  /* 820A5D58h */ case   12:  		/* ld R31, <#[R1 - 16]> */
		/* 820A5D58h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A5D58h case   12:*/		return 0x820A5D5C;
		  /* 820A5D5Ch */ case   13:  		/* bclr 20, CR0_LT */
		/* 820A5D5Ch case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A5D5Ch case   13:*/		return 0x820A5D60;
	}
	return 0x820A5D60;
} // Block from 820A5D28h-820A5D60h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A5D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5D60);
		  /* 820A5D60h */ case    0:  		/* lis R11, -25033 */
		/* 820A5D60h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9E37);
		/* 820A5D60h case    0:*/		return 0x820A5D64;
		  /* 820A5D64h */ case    1:  		/* mr R8, R4 */
		/* 820A5D64h case    1:*/		regs.R8 = regs.R4;
		/* 820A5D64h case    1:*/		return 0x820A5D68;
		  /* 820A5D68h */ case    2:  		/* ori R9, R11, 31161 */
		/* 820A5D68h case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R11,0x79B9);
		/* 820A5D68h case    2:*/		return 0x820A5D6C;
		  /* 820A5D6Ch */ case    3:  		/* li R10, 0 */
		/* 820A5D6Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A5D6Ch case    3:*/		return 0x820A5D70;
		  /* 820A5D70h */ case    4:  		/* cmplwi CR6, R4, 12 */
		/* 820A5D70h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000000C);
		/* 820A5D70h case    4:*/		return 0x820A5D74;
		  /* 820A5D74h */ case    5:  		/* mr R11, R9 */
		/* 820A5D74h case    5:*/		regs.R11 = regs.R9;
		/* 820A5D74h case    5:*/		return 0x820A5D78;
		  /* 820A5D78h */ case    6:  		/* bc 12, CR6_LT, 196 */
		/* 820A5D78h case    6:*/		if ( regs.CR[6].lt ) { return 0x820A5E3C;  }
		/* 820A5D78h case    6:*/		return 0x820A5D7C;
		  /* 820A5D7Ch */ case    7:  		/* li R7, 12 */
		/* 820A5D7Ch case    7:*/		cpu::op::li<0>(regs,&regs.R7,0xC);
		/* 820A5D7Ch case    7:*/		return 0x820A5D80;
		  /* 820A5D80h */ case    8:  		/* divwu R7, R4, R7 */
		/* 820A5D80h case    8:*/		cpu::op::divwu<0>(regs,&regs.R7,regs.R4,regs.R7);
		/* 820A5D80h case    8:*/		return 0x820A5D84;
		  /* 820A5D84h */ case    9:  		/* mtspr CTR, R7 */
		/* 820A5D84h case    9:*/		regs.CTR = regs.R7;
		/* 820A5D84h case    9:*/		return 0x820A5D88;
		  /* 820A5D88h */ case   10:  		/* lwz R7, <#[R3 + 8]> */
		/* 820A5D88h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000008) );
		/* 820A5D88h case   10:*/		return 0x820A5D8C;
		  /* 820A5D8Ch */ case   11:  		/* addi R8, R8, -12 */
		/* 820A5D8Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFF4);
		/* 820A5D8Ch case   11:*/		return 0x820A5D90;
		  /* 820A5D90h */ case   12:  		/* lwz R6, <#[R3 + 4]> */
		/* 820A5D90h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000004) );
		/* 820A5D90h case   12:*/		return 0x820A5D94;
		  /* 820A5D94h */ case   13:  		/* add R10, R7, R10 */
		/* 820A5D94h case   13:*/		cpu::op::add<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 820A5D94h case   13:*/		return 0x820A5D98;
		  /* 820A5D98h */ case   14:  		/* lwz R5, <#[R3]> */
		/* 820A5D98h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000000) );
		/* 820A5D98h case   14:*/		return 0x820A5D9C;
		  /* 820A5D9Ch */ case   15:  		/* add R9, R6, R9 */
		/* 820A5D9Ch case   15:*/		cpu::op::add<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820A5D9Ch case   15:*/		return 0x820A5DA0;
		  /* 820A5DA0h */ case   16:  		/* subf R7, R10, R5 */
		/* 820A5DA0h case   16:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R10,regs.R5);
		/* 820A5DA0h case   16:*/		return 0x820A5DA4;
		  /* 820A5DA4h */ case   17:  		/* rlwinm R6, R10, 19, 13, 31 */
		/* 820A5DA4h case   17:*/		cpu::op::rlwinm<0,19,13,31>(regs,&regs.R6,regs.R10);
		/* 820A5DA4h case   17:*/		return 0x820A5DA8;
		  /* 820A5DA8h */ case   18:  		/* subf R7, R9, R7 */
		/* 820A5DA8h case   18:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R9,regs.R7);
		/* 820A5DA8h case   18:*/		return 0x820A5DAC;
		  /* 820A5DACh */ case   19:  		/* subf R9, R10, R9 */
		/* 820A5DACh case   19:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820A5DACh case   19:*/		return 0x820A5DB0;
		  /* 820A5DB0h */ case   20:  		/* add R11, R7, R11 */
		/* 820A5DB0h case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 820A5DB0h case   20:*/		return 0x820A5DB4;
		  /* 820A5DB4h */ case   21:  		/* addi R3, R3, 12 */
		/* 820A5DB4h case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xC);
		/* 820A5DB4h case   21:*/		return 0x820A5DB8;
		  /* 820A5DB8h */ case   22:  		/* xor R11, R11, R6 */
		/* 820A5DB8h case   22:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 820A5DB8h case   22:*/		return 0x820A5DBC;
		  /* 820A5DBCh */ case   23:  		/* subf R9, R11, R9 */
		/* 820A5DBCh case   23:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 820A5DBCh case   23:*/		return 0x820A5DC0;
		  /* 820A5DC0h */ case   24:  		/* rlwinm R7, R11, 8, 0, 23 */
		/* 820A5DC0h case   24:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R7,regs.R11);
		/* 820A5DC0h case   24:*/		return 0x820A5DC4;
		  /* 820A5DC4h */ case   25:  		/* xor R9, R9, R7 */
		/* 820A5DC4h case   25:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 820A5DC4h case   25:*/		return 0x820A5DC8;
		  /* 820A5DC8h */ case   26:  		/* subf R10, R9, R10 */
		/* 820A5DC8h case   26:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820A5DC8h case   26:*/		return 0x820A5DCC;
		  /* 820A5DCCh */ case   27:  		/* rlwinm R7, R9, 19, 13, 31 */
		/* 820A5DCCh case   27:*/		cpu::op::rlwinm<0,19,13,31>(regs,&regs.R7,regs.R9);
		/* 820A5DCCh case   27:*/		return 0x820A5DD0;
		  /* 820A5DD0h */ case   28:  		/* subf R10, R11, R10 */
		/* 820A5DD0h case   28:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820A5DD0h case   28:*/		return 0x820A5DD4;
		  /* 820A5DD4h */ case   29:  		/* xor R10, R10, R7 */
		/* 820A5DD4h case   29:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 820A5DD4h case   29:*/		return 0x820A5DD8;
		  /* 820A5DD8h */ case   30:  		/* subf R11, R10, R11 */
		/* 820A5DD8h case   30:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A5DD8h case   30:*/		return 0x820A5DDC;
		  /* 820A5DDCh */ case   31:  		/* rlwinm R7, R10, 20, 12, 31 */
		/* 820A5DDCh case   31:*/		cpu::op::rlwinm<0,20,12,31>(regs,&regs.R7,regs.R10);
		/* 820A5DDCh case   31:*/		return 0x820A5DE0;
		  /* 820A5DE0h */ case   32:  		/* subf R11, R9, R11 */
		/* 820A5DE0h case   32:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820A5DE0h case   32:*/		return 0x820A5DE4;
		  /* 820A5DE4h */ case   33:  		/* subf R9, R10, R9 */
		/* 820A5DE4h case   33:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820A5DE4h case   33:*/		return 0x820A5DE8;
		  /* 820A5DE8h */ case   34:  		/* xor R11, R11, R7 */
		/* 820A5DE8h case   34:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 820A5DE8h case   34:*/		return 0x820A5DEC;
		  /* 820A5DECh */ case   35:  		/* subf R9, R11, R9 */
		/* 820A5DECh case   35:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 820A5DECh case   35:*/		return 0x820A5DF0;
		  /* 820A5DF0h */ case   36:  		/* rlwinm R7, R11, 16, 0, 15 */
		/* 820A5DF0h case   36:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R7,regs.R11);
		/* 820A5DF0h case   36:*/		return 0x820A5DF4;
		  /* 820A5DF4h */ case   37:  		/* xor R9, R9, R7 */
		/* 820A5DF4h case   37:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 820A5DF4h case   37:*/		return 0x820A5DF8;
		  /* 820A5DF8h */ case   38:  		/* subf R10, R9, R10 */
		/* 820A5DF8h case   38:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820A5DF8h case   38:*/		return 0x820A5DFC;
		  /* 820A5DFCh */ case   39:  		/* rlwinm R7, R9, 27, 5, 31 */
		/* 820A5DFCh case   39:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R7,regs.R9);
		/* 820A5DFCh case   39:*/		return 0x820A5E00;
		  /* 820A5E00h */ case   40:  		/* subf R10, R11, R10 */
		/* 820A5E00h case   40:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820A5E00h case   40:*/		return 0x820A5E04;
		  /* 820A5E04h */ case   41:  		/* xor R10, R10, R7 */
		/* 820A5E04h case   41:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 820A5E04h case   41:*/		return 0x820A5E08;
		  /* 820A5E08h */ case   42:  		/* subf R11, R10, R11 */
		/* 820A5E08h case   42:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A5E08h case   42:*/		return 0x820A5E0C;
		  /* 820A5E0Ch */ case   43:  		/* rlwinm R7, R10, 29, 3, 31 */
		/* 820A5E0Ch case   43:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R7,regs.R10);
		/* 820A5E0Ch case   43:*/		return 0x820A5E10;
		  /* 820A5E10h */ case   44:  		/* subf R11, R9, R11 */
		/* 820A5E10h case   44:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820A5E10h case   44:*/		return 0x820A5E14;
		  /* 820A5E14h */ case   45:  		/* subf R9, R10, R9 */
		/* 820A5E14h case   45:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820A5E14h case   45:*/		return 0x820A5E18;
		  /* 820A5E18h */ case   46:  		/* xor R11, R11, R7 */
		/* 820A5E18h case   46:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 820A5E18h case   46:*/		return 0x820A5E1C;
		  /* 820A5E1Ch */ case   47:  		/* rlwinm R7, R11, 10, 0, 21 */
		/* 820A5E1Ch case   47:*/		cpu::op::rlwinm<0,10,0,21>(regs,&regs.R7,regs.R11);
		/* 820A5E1Ch case   47:*/		return 0x820A5E20;
		  /* 820A5E20h */ case   48:  		/* subf R9, R11, R9 */
		/* 820A5E20h case   48:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 820A5E20h case   48:*/		return 0x820A5E24;
		  /* 820A5E24h */ case   49:  		/* xor R9, R9, R7 */
		/* 820A5E24h case   49:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 820A5E24h case   49:*/		return 0x820A5E28;
		  /* 820A5E28h */ case   50:  		/* subf R10, R9, R10 */
		/* 820A5E28h case   50:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820A5E28h case   50:*/		return 0x820A5E2C;
		  /* 820A5E2Ch */ case   51:  		/* rlwinm R7, R9, 17, 15, 31 */
		/* 820A5E2Ch case   51:*/		cpu::op::rlwinm<0,17,15,31>(regs,&regs.R7,regs.R9);
		/* 820A5E2Ch case   51:*/		return 0x820A5E30;
		  /* 820A5E30h */ case   52:  		/* subf R10, R11, R10 */
		/* 820A5E30h case   52:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820A5E30h case   52:*/		return 0x820A5E34;
		  /* 820A5E34h */ case   53:  		/* xor R10, R10, R7 */
		/* 820A5E34h case   53:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 820A5E34h case   53:*/		return 0x820A5E38;
		  /* 820A5E38h */ case   54:  		/* bc 16, CR0_LT, -176 */
		/* 820A5E38h case   54:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A5D88;  }
		/* 820A5E38h case   54:*/		return 0x820A5E3C;
	}
	return 0x820A5E3C;
} // Block from 820A5D60h-820A5E3Ch (55 instructions)

//////////////////////////////////////////////////////
// Block at 820A5E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5E3C);
		  /* 820A5E3Ch */ case    0:  		/* addi R8, R8, -1 */
		/* 820A5E3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820A5E3Ch case    0:*/		return 0x820A5E40;
		  /* 820A5E40h */ case    1:  		/* add R10, R10, R4 */
		/* 820A5E40h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 820A5E40h case    1:*/		return 0x820A5E44;
		  /* 820A5E44h */ case    2:  		/* cmplwi CR6, R8, 10 */
		/* 820A5E44h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000000A);
		/* 820A5E44h case    2:*/		return 0x820A5E48;
		  /* 820A5E48h */ case    3:  		/* bc 12, CR6_GT, 168 */
		/* 820A5E48h case    3:*/		if ( regs.CR[6].gt ) { return 0x820A5EF0;  }
		/* 820A5E48h case    3:*/		return 0x820A5E4C;
		  /* 820A5E4Ch */ case    4:  		/* lis R12, -32255 */
		/* 820A5E4Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820A5E4Ch case    4:*/		return 0x820A5E50;
		  /* 820A5E50h */ case    5:  		/* addi R12, R12, -9576 */
		/* 820A5E50h case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFDA98);
		/* 820A5E50h case    5:*/		return 0x820A5E54;
		  /* 820A5E54h */ case    6:  		/* lbzx R0, <#[R12 + R8]> */
		/* 820A5E54h case    6:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R8 + 0x00000000) );
		/* 820A5E54h case    6:*/		return 0x820A5E58;
		  /* 820A5E58h */ case    7:  		/* lis R12, -32246 */
		/* 820A5E58h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820A);
		/* 820A5E58h case    7:*/		return 0x820A5E5C;
		  /* 820A5E5Ch */ case    8:  		/* ori R0, R0, 0 */
		/* 820A5E5Ch case    8:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820A5E5Ch case    8:*/		return 0x820A5E60;
		  /* 820A5E60h */ case    9:  		/* addi R12, R12, 24180 */
		/* 820A5E60h case    9:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x5E74);
		/* 820A5E60h case    9:*/		return 0x820A5E64;
		  /* 820A5E64h */ case   10:  		/* ori R0, R0, 0 */
		/* 820A5E64h case   10:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820A5E64h case   10:*/		return 0x820A5E68;
		  /* 820A5E68h */ case   11:  		/* add R12, R12, R0 */
		/* 820A5E68h case   11:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820A5E68h case   11:*/		return 0x820A5E6C;
		  /* 820A5E6Ch */ case   12:  		/* mtspr CTR, R12 */
		/* 820A5E6Ch case   12:*/		regs.CTR = regs.R12;
		/* 820A5E6Ch case   12:*/		return 0x820A5E70;
		  /* 820A5E70h */ case   13:  		/* bcctr 20, CR0_LT */
		/* 820A5E70h case   13:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820A5E70h case   13:*/		return 0x820A5E74;
		  /* 820A5E74h */ case   14:  		/* lbz R8, <#[R3 + 10]> */
		/* 820A5E74h case   14:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000000A) );
		/* 820A5E74h case   14:*/		return 0x820A5E78;
		  /* 820A5E78h */ case   15:  		/* rlwinm R8, R8, 24, 0, 31 */
		/* 820A5E78h case   15:*/		cpu::op::rlwinm<0,24,0,31>(regs,&regs.R8,regs.R8);
		/* 820A5E78h case   15:*/		return 0x820A5E7C;
		  /* 820A5E7Ch */ case   16:  		/* add R10, R8, R10 */
		/* 820A5E7Ch case   16:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 820A5E7Ch case   16:*/		return 0x820A5E80;
		  /* 820A5E80h */ case   17:  		/* lbz R8, <#[R3 + 9]> */
		/* 820A5E80h case   17:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000009) );
		/* 820A5E80h case   17:*/		return 0x820A5E84;
		  /* 820A5E84h */ case   18:  		/* rlwinm R8, R8, 16, 0, 31 */
		/* 820A5E84h case   18:*/		cpu::op::rlwinm<0,16,0,31>(regs,&regs.R8,regs.R8);
		/* 820A5E84h case   18:*/		return 0x820A5E88;
		  /* 820A5E88h */ case   19:  		/* add R10, R8, R10 */
		/* 820A5E88h case   19:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 820A5E88h case   19:*/		return 0x820A5E8C;
		  /* 820A5E8Ch */ case   20:  		/* lbz R8, <#[R3 + 8]> */
		/* 820A5E8Ch case   20:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 820A5E8Ch case   20:*/		return 0x820A5E90;
		  /* 820A5E90h */ case   21:  		/* rlwinm R8, R8, 8, 0, 31 */
		/* 820A5E90h case   21:*/		cpu::op::rlwinm<0,8,0,31>(regs,&regs.R8,regs.R8);
		/* 820A5E90h case   21:*/		return 0x820A5E94;
		  /* 820A5E94h */ case   22:  		/* add R10, R8, R10 */
		/* 820A5E94h case   22:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 820A5E94h case   22:*/		return 0x820A5E98;
		  /* 820A5E98h */ case   23:  		/* lbz R8, <#[R3 + 7]> */
		/* 820A5E98h case   23:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000007) );
		/* 820A5E98h case   23:*/		return 0x820A5E9C;
		  /* 820A5E9Ch */ case   24:  		/* rlwinm R8, R8, 24, 0, 31 */
		/* 820A5E9Ch case   24:*/		cpu::op::rlwinm<0,24,0,31>(regs,&regs.R8,regs.R8);
		/* 820A5E9Ch case   24:*/		return 0x820A5EA0;
		  /* 820A5EA0h */ case   25:  		/* add R9, R8, R9 */
		/* 820A5EA0h case   25:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A5EA0h case   25:*/		return 0x820A5EA4;
		  /* 820A5EA4h */ case   26:  		/* lbz R8, <#[R3 + 6]> */
		/* 820A5EA4h case   26:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000006) );
		/* 820A5EA4h case   26:*/		return 0x820A5EA8;
		  /* 820A5EA8h */ case   27:  		/* rlwinm R8, R8, 16, 0, 31 */
		/* 820A5EA8h case   27:*/		cpu::op::rlwinm<0,16,0,31>(regs,&regs.R8,regs.R8);
		/* 820A5EA8h case   27:*/		return 0x820A5EAC;
		  /* 820A5EACh */ case   28:  		/* add R9, R8, R9 */
		/* 820A5EACh case   28:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A5EACh case   28:*/		return 0x820A5EB0;
		  /* 820A5EB0h */ case   29:  		/* lbz R8, <#[R3 + 5]> */
		/* 820A5EB0h case   29:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000005) );
		/* 820A5EB0h case   29:*/		return 0x820A5EB4;
		  /* 820A5EB4h */ case   30:  		/* rlwinm R8, R8, 8, 0, 31 */
		/* 820A5EB4h case   30:*/		cpu::op::rlwinm<0,8,0,31>(regs,&regs.R8,regs.R8);
		/* 820A5EB4h case   30:*/		return 0x820A5EB8;
		  /* 820A5EB8h */ case   31:  		/* add R9, R8, R9 */
		/* 820A5EB8h case   31:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A5EB8h case   31:*/		return 0x820A5EBC;
		  /* 820A5EBCh */ case   32:  		/* lbz R8, <#[R3 + 4]> */
		/* 820A5EBCh case   32:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000004) );
		/* 820A5EBCh case   32:*/		return 0x820A5EC0;
		  /* 820A5EC0h */ case   33:  		/* add R9, R8, R9 */
		/* 820A5EC0h case   33:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A5EC0h case   33:*/		return 0x820A5EC4;
		  /* 820A5EC4h */ case   34:  		/* lbz R8, <#[R3 + 3]> */
		/* 820A5EC4h case   34:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000003) );
		/* 820A5EC4h case   34:*/		return 0x820A5EC8;
		  /* 820A5EC8h */ case   35:  		/* rlwinm R8, R8, 24, 0, 31 */
		/* 820A5EC8h case   35:*/		cpu::op::rlwinm<0,24,0,31>(regs,&regs.R8,regs.R8);
		/* 820A5EC8h case   35:*/		return 0x820A5ECC;
		  /* 820A5ECCh */ case   36:  		/* add R11, R8, R11 */
		/* 820A5ECCh case   36:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820A5ECCh case   36:*/		return 0x820A5ED0;
		  /* 820A5ED0h */ case   37:  		/* lbz R8, <#[R3 + 2]> */
		/* 820A5ED0h case   37:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000002) );
		/* 820A5ED0h case   37:*/		return 0x820A5ED4;
		  /* 820A5ED4h */ case   38:  		/* rlwinm R8, R8, 16, 0, 31 */
		/* 820A5ED4h case   38:*/		cpu::op::rlwinm<0,16,0,31>(regs,&regs.R8,regs.R8);
		/* 820A5ED4h case   38:*/		return 0x820A5ED8;
		  /* 820A5ED8h */ case   39:  		/* add R11, R8, R11 */
		/* 820A5ED8h case   39:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820A5ED8h case   39:*/		return 0x820A5EDC;
		  /* 820A5EDCh */ case   40:  		/* lbz R8, <#[R3 + 1]> */
		/* 820A5EDCh case   40:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000001) );
		/* 820A5EDCh case   40:*/		return 0x820A5EE0;
		  /* 820A5EE0h */ case   41:  		/* rlwinm R8, R8, 8, 0, 31 */
		/* 820A5EE0h case   41:*/		cpu::op::rlwinm<0,8,0,31>(regs,&regs.R8,regs.R8);
		/* 820A5EE0h case   41:*/		return 0x820A5EE4;
		  /* 820A5EE4h */ case   42:  		/* add R11, R8, R11 */
		/* 820A5EE4h case   42:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820A5EE4h case   42:*/		return 0x820A5EE8;
		  /* 820A5EE8h */ case   43:  		/* lbz R8, <#[R3]> */
		/* 820A5EE8h case   43:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820A5EE8h case   43:*/		return 0x820A5EEC;
		  /* 820A5EECh */ case   44:  		/* add R11, R8, R11 */
		/* 820A5EECh case   44:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820A5EECh case   44:*/		return 0x820A5EF0;
	}
	return 0x820A5EF0;
} // Block from 820A5E3Ch-820A5EF0h (45 instructions)

//////////////////////////////////////////////////////
// Block at 820A5EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5EF0);
		  /* 820A5EF0h */ case    0:  		/* subf R11, R10, R11 */
		/* 820A5EF0h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A5EF0h case    0:*/		return 0x820A5EF4;
		  /* 820A5EF4h */ case    1:  		/* rlwinm R8, R10, 19, 13, 31 */
		/* 820A5EF4h case    1:*/		cpu::op::rlwinm<0,19,13,31>(regs,&regs.R8,regs.R10);
		/* 820A5EF4h case    1:*/		return 0x820A5EF8;
		  /* 820A5EF8h */ case    2:  		/* subf R11, R9, R11 */
		/* 820A5EF8h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820A5EF8h case    2:*/		return 0x820A5EFC;
		  /* 820A5EFCh */ case    3:  		/* subf R9, R10, R9 */
		/* 820A5EFCh case    3:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820A5EFCh case    3:*/		return 0x820A5F00;
		  /* 820A5F00h */ case    4:  		/* xor R11, R11, R8 */
		/* 820A5F00h case    4:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820A5F00h case    4:*/		return 0x820A5F04;
		  /* 820A5F04h */ case    5:  		/* subf R9, R11, R9 */
		/* 820A5F04h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 820A5F04h case    5:*/		return 0x820A5F08;
		  /* 820A5F08h */ case    6:  		/* rlwinm R8, R11, 8, 0, 23 */
		/* 820A5F08h case    6:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R8,regs.R11);
		/* 820A5F08h case    6:*/		return 0x820A5F0C;
		  /* 820A5F0Ch */ case    7:  		/* xor R9, R9, R8 */
		/* 820A5F0Ch case    7:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820A5F0Ch case    7:*/		return 0x820A5F10;
		  /* 820A5F10h */ case    8:  		/* subf R10, R9, R10 */
		/* 820A5F10h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820A5F10h case    8:*/		return 0x820A5F14;
		  /* 820A5F14h */ case    9:  		/* rlwinm R8, R9, 19, 13, 31 */
		/* 820A5F14h case    9:*/		cpu::op::rlwinm<0,19,13,31>(regs,&regs.R8,regs.R9);
		/* 820A5F14h case    9:*/		return 0x820A5F18;
		  /* 820A5F18h */ case   10:  		/* subf R10, R11, R10 */
		/* 820A5F18h case   10:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820A5F18h case   10:*/		return 0x820A5F1C;
		  /* 820A5F1Ch */ case   11:  		/* xor R10, R10, R8 */
		/* 820A5F1Ch case   11:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820A5F1Ch case   11:*/		return 0x820A5F20;
		  /* 820A5F20h */ case   12:  		/* subf R11, R10, R11 */
		/* 820A5F20h case   12:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A5F20h case   12:*/		return 0x820A5F24;
		  /* 820A5F24h */ case   13:  		/* rlwinm R8, R10, 20, 12, 31 */
		/* 820A5F24h case   13:*/		cpu::op::rlwinm<0,20,12,31>(regs,&regs.R8,regs.R10);
		/* 820A5F24h case   13:*/		return 0x820A5F28;
		  /* 820A5F28h */ case   14:  		/* subf R11, R9, R11 */
		/* 820A5F28h case   14:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820A5F28h case   14:*/		return 0x820A5F2C;
		  /* 820A5F2Ch */ case   15:  		/* subf R9, R10, R9 */
		/* 820A5F2Ch case   15:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820A5F2Ch case   15:*/		return 0x820A5F30;
		  /* 820A5F30h */ case   16:  		/* xor R11, R11, R8 */
		/* 820A5F30h case   16:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820A5F30h case   16:*/		return 0x820A5F34;
		  /* 820A5F34h */ case   17:  		/* subf R9, R11, R9 */
		/* 820A5F34h case   17:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 820A5F34h case   17:*/		return 0x820A5F38;
		  /* 820A5F38h */ case   18:  		/* rlwinm R8, R11, 16, 0, 15 */
		/* 820A5F38h case   18:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R8,regs.R11);
		/* 820A5F38h case   18:*/		return 0x820A5F3C;
		  /* 820A5F3Ch */ case   19:  		/* xor R9, R9, R8 */
		/* 820A5F3Ch case   19:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820A5F3Ch case   19:*/		return 0x820A5F40;
		  /* 820A5F40h */ case   20:  		/* subf R10, R9, R10 */
		/* 820A5F40h case   20:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820A5F40h case   20:*/		return 0x820A5F44;
		  /* 820A5F44h */ case   21:  		/* rlwinm R8, R9, 27, 5, 31 */
		/* 820A5F44h case   21:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R8,regs.R9);
		/* 820A5F44h case   21:*/		return 0x820A5F48;
		  /* 820A5F48h */ case   22:  		/* subf R10, R11, R10 */
		/* 820A5F48h case   22:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820A5F48h case   22:*/		return 0x820A5F4C;
		  /* 820A5F4Ch */ case   23:  		/* xor R10, R10, R8 */
		/* 820A5F4Ch case   23:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820A5F4Ch case   23:*/		return 0x820A5F50;
		  /* 820A5F50h */ case   24:  		/* subf R11, R10, R11 */
		/* 820A5F50h case   24:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A5F50h case   24:*/		return 0x820A5F54;
		  /* 820A5F54h */ case   25:  		/* rlwinm R8, R10, 29, 3, 31 */
		/* 820A5F54h case   25:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R8,regs.R10);
		/* 820A5F54h case   25:*/		return 0x820A5F58;
		  /* 820A5F58h */ case   26:  		/* subf R11, R9, R11 */
		/* 820A5F58h case   26:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820A5F58h case   26:*/		return 0x820A5F5C;
		  /* 820A5F5Ch */ case   27:  		/* subf R9, R10, R9 */
		/* 820A5F5Ch case   27:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820A5F5Ch case   27:*/		return 0x820A5F60;
		  /* 820A5F60h */ case   28:  		/* xor R11, R11, R8 */
		/* 820A5F60h case   28:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820A5F60h case   28:*/		return 0x820A5F64;
		  /* 820A5F64h */ case   29:  		/* subf R9, R11, R9 */
		/* 820A5F64h case   29:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 820A5F64h case   29:*/		return 0x820A5F68;
		  /* 820A5F68h */ case   30:  		/* rlwinm R8, R11, 10, 0, 21 */
		/* 820A5F68h case   30:*/		cpu::op::rlwinm<0,10,0,21>(regs,&regs.R8,regs.R11);
		/* 820A5F68h case   30:*/		return 0x820A5F6C;
		  /* 820A5F6Ch */ case   31:  		/* xor R9, R9, R8 */
		/* 820A5F6Ch case   31:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820A5F6Ch case   31:*/		return 0x820A5F70;
		  /* 820A5F70h */ case   32:  		/* subf R10, R9, R10 */
		/* 820A5F70h case   32:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820A5F70h case   32:*/		return 0x820A5F74;
		  /* 820A5F74h */ case   33:  		/* rlwinm R9, R9, 17, 15, 31 */
		/* 820A5F74h case   33:*/		cpu::op::rlwinm<0,17,15,31>(regs,&regs.R9,regs.R9);
		/* 820A5F74h case   33:*/		return 0x820A5F78;
		  /* 820A5F78h */ case   34:  		/* subf R11, R11, R10 */
		/* 820A5F78h case   34:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A5F78h case   34:*/		return 0x820A5F7C;
		  /* 820A5F7Ch */ case   35:  		/* xor R3, R11, R9 */
		/* 820A5F7Ch case   35:*/		cpu::op::xor<0>(regs,&regs.R3,regs.R11,regs.R9);
		/* 820A5F7Ch case   35:*/		return 0x820A5F80;
		  /* 820A5F80h */ case   36:  		/* bclr 20, CR0_LT */
		/* 820A5F80h case   36:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A5F80h case   36:*/		return 0x820A5F84;
	}
	return 0x820A5F84;
} // Block from 820A5EF0h-820A5F84h (37 instructions)

//////////////////////////////////////////////////////
// Block at 820A5F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5F84);
		  /* 820A5F84h */ case    0:  		/* nop */
		/* 820A5F84h case    0:*/		cpu::op::nop();
		/* 820A5F84h case    0:*/		return 0x820A5F88;
	}
	return 0x820A5F88;
} // Block from 820A5F84h-820A5F88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A5F88h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5F88);
		  /* 820A5F88h */ case    0:  		/* li R11, 0 */
		/* 820A5F88h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A5F88h case    0:*/		return 0x820A5F8C;
		  /* 820A5F8Ch */ case    1:  		/* li R10, -1 */
		/* 820A5F8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820A5F8Ch case    1:*/		return 0x820A5F90;
		  /* 820A5F90h */ case    2:  		/* li R9, 1 */
		/* 820A5F90h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820A5F90h case    2:*/		return 0x820A5F94;
		  /* 820A5F94h */ case    3:  		/* stw R11, <#[R3]> */
		/* 820A5F94h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A5F94h case    3:*/		return 0x820A5F98;
		  /* 820A5F98h */ case    4:  		/* stw R11, <#[R3 + 4]> */
		/* 820A5F98h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820A5F98h case    4:*/		return 0x820A5F9C;
		  /* 820A5F9Ch */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 820A5F9Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A5F9Ch case    5:*/		return 0x820A5FA0;
		  /* 820A5FA0h */ case    6:  		/* stw R10, <#[R3 + 36]> */
		/* 820A5FA0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000024) );
		/* 820A5FA0h case    6:*/		return 0x820A5FA4;
		  /* 820A5FA4h */ case    7:  		/* stw R11, <#[R3 + 32]> */
		/* 820A5FA4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820A5FA4h case    7:*/		return 0x820A5FA8;
		  /* 820A5FA8h */ case    8:  		/* stw R9, <#[R3 + 40]> */
		/* 820A5FA8h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000028) );
		/* 820A5FA8h case    8:*/		return 0x820A5FAC;
		  /* 820A5FACh */ case    9:  		/* stw R11, <#[R3 + 44]> */
		/* 820A5FACh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820A5FACh case    9:*/		return 0x820A5FB0;
		  /* 820A5FB0h */ case   10:  		/* stw R11, <#[R3 + 60]> */
		/* 820A5FB0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 820A5FB0h case   10:*/		return 0x820A5FB4;
		  /* 820A5FB4h */ case   11:  		/* stw R11, <#[R3 + 64]> */
		/* 820A5FB4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000040) );
		/* 820A5FB4h case   11:*/		return 0x820A5FB8;
		  /* 820A5FB8h */ case   12:  		/* stw R11, <#[R3 + 68]> */
		/* 820A5FB8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 820A5FB8h case   12:*/		return 0x820A5FBC;
		  /* 820A5FBCh */ case   13:  		/* bclr 20, CR0_LT */
		/* 820A5FBCh case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A5FBCh case   13:*/		return 0x820A5FC0;
	}
	return 0x820A5FC0;
} // Block from 820A5F88h-820A5FC0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A5FC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A5FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A5FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A5FC0);
		  /* 820A5FC0h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 820A5FC0h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A5FC0h case    0:*/		return 0x820A5FC4;
		  /* 820A5FC4h */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 820A5FC4h case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A5FC4h case    1:*/		return 0x820A5FC8;
		  /* 820A5FC8h */ case    2:  		/* mr R11, R3 */
		/* 820A5FC8h case    2:*/		regs.R11 = regs.R3;
		/* 820A5FC8h case    2:*/		return 0x820A5FCC;
		  /* 820A5FCCh */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 820A5FCCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A5FCCh case    3:*/		return 0x820A5FD0;
		  /* 820A5FD0h */ case    4:  		/* bc 12, CR6_EQ, 144 */
		/* 820A5FD0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A6060;  }
		/* 820A5FD0h case    4:*/		return 0x820A5FD4;
		  /* 820A5FD4h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 820A5FD4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A5FD4h case    5:*/		return 0x820A5FD8;
		  /* 820A5FD8h */ case    6:  		/* bc 12, CR6_EQ, 136 */
		/* 820A5FD8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A6060;  }
		/* 820A5FD8h case    6:*/		return 0x820A5FDC;
		  /* 820A5FDCh */ case    7:  		/* cmpwi CR6, R5, -1 */
		/* 820A5FDCh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 820A5FDCh case    7:*/		return 0x820A5FE0;
		  /* 820A5FE0h */ case    8:  		/* bc 4, CR6_EQ, 52 */
		/* 820A5FE0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A6014;  }
		/* 820A5FE0h case    8:*/		return 0x820A5FE4;
		  /* 820A5FE4h */ case    9:  		/* cmplwi CR6, R4, 0 */
		/* 820A5FE4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A5FE4h case    9:*/		return 0x820A5FE8;
		  /* 820A5FE8h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820A5FE8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A6010;  }
		/* 820A5FE8h case   10:*/		return 0x820A5FEC;
		  /* 820A5FECh */ case   11:  		/* mr R5, R4 */
		/* 820A5FECh case   11:*/		regs.R5 = regs.R4;
		/* 820A5FECh case   11:*/		return 0x820A5FF0;
		  /* 820A5FF0h */ case   12:  		/* lbz R3, <#[R5]> */
		/* 820A5FF0h case   12:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R5 + 0x00000000) );
		/* 820A5FF0h case   12:*/		return 0x820A5FF4;
		  /* 820A5FF4h */ case   13:  		/* addi R5, R5, 1 */
		/* 820A5FF4h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820A5FF4h case   13:*/		return 0x820A5FF8;
		  /* 820A5FF8h */ case   14:  		/* cmplwi CR6, R3, 0 */
		/* 820A5FF8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A5FF8h case   14:*/		return 0x820A5FFC;
		  /* 820A5FFCh */ case   15:  		/* bc 4, CR6_EQ, -12 */
		/* 820A5FFCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x820A5FF0;  }
		/* 820A5FFCh case   15:*/		return 0x820A6000;
		  /* 820A6000h */ case   16:  		/* subf R5, R4, R5 */
		/* 820A6000h case   16:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R4,regs.R5);
		/* 820A6000h case   16:*/		return 0x820A6004;
		  /* 820A6004h */ case   17:  		/* addi R5, R5, -1 */
		/* 820A6004h case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 820A6004h case   17:*/		return 0x820A6008;
		  /* 820A6008h */ case   18:  		/* rlwinm R5, R5, 0, 0, 31 */
		/* 820A6008h case   18:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R5,regs.R5);
		/* 820A6008h case   18:*/		return 0x820A600C;
		  /* 820A600Ch */ case   19:  		/* b 8 */
		/* 820A600Ch case   19:*/		return 0x820A6014;
		/* 820A600Ch case   19:*/		return 0x820A6010;
	}
	return 0x820A6010;
} // Block from 820A5FC0h-820A6010h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A6010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6010);
		  /* 820A6010h */ case    0:  		/* li R5, 0 */
		/* 820A6010h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A6010h case    0:*/		return 0x820A6014;
	}
	return 0x820A6014;
} // Block from 820A6010h-820A6014h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6014);
		  /* 820A6014h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820A6014h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A6014h case    0:*/		return 0x820A6018;
		  /* 820A6018h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820A6018h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A6024;  }
		/* 820A6018h case    1:*/		return 0x820A601C;
		  /* 820A601Ch */ case    2:  		/* cmplwi CR6, R5, 0 */
		/* 820A601Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820A601Ch case    2:*/		return 0x820A6020;
		  /* 820A6020h */ case    3:  		/* bc 4, CR6_EQ, 64 */
		/* 820A6020h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A6060;  }
		/* 820A6020h case    3:*/		return 0x820A6024;
	}
	return 0x820A6024;
} // Block from 820A6014h-820A6024h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A6024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6024);
		  /* 820A6024h */ case    0:  		/* lwz R31, <#[R1 + 84]> */
		/* 820A6024h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 820A6024h case    0:*/		return 0x820A6028;
		  /* 820A6028h */ case    1:  		/* add R5, R4, R5 */
		/* 820A6028h case    1:*/		cpu::op::add<0>(regs,&regs.R5,regs.R4,regs.R5);
		/* 820A6028h case    1:*/		return 0x820A602C;
		  /* 820A602Ch */ case    2:  		/* li R30, 0 */
		/* 820A602Ch case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A602Ch case    2:*/		return 0x820A6030;
		  /* 820A6030h */ case    3:  		/* stw R4, <#[R11]> */
		/* 820A6030h case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6030h case    3:*/		return 0x820A6034;
		  /* 820A6034h */ case    4:  		/* stw R4, <#[R11 + 4]> */
		/* 820A6034h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 820A6034h case    4:*/		return 0x820A6038;
		  /* 820A6038h */ case    5:  		/* li R3, 0 */
		/* 820A6038h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A6038h case    5:*/		return 0x820A603C;
		  /* 820A603Ch */ case    6:  		/* stw R5, <#[R11 + 8]> */
		/* 820A603Ch case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000008) );
		/* 820A603Ch case    6:*/		return 0x820A6040;
		  /* 820A6040h */ case    7:  		/* stw R6, <#[R11 + 36]> */
		/* 820A6040h case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000024) );
		/* 820A6040h case    7:*/		return 0x820A6044;
		  /* 820A6044h */ case    8:  		/* stw R7, <#[R11 + 32]> */
		/* 820A6044h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000020) );
		/* 820A6044h case    8:*/		return 0x820A6048;
		  /* 820A6048h */ case    9:  		/* stw R8, <#[R11 + 40]> */
		/* 820A6048h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000028) );
		/* 820A6048h case    9:*/		return 0x820A604C;
		  /* 820A604Ch */ case   10:  		/* stw R9, <#[R11 + 60]> */
		/* 820A604Ch case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000003C) );
		/* 820A604Ch case   10:*/		return 0x820A6050;
		  /* 820A6050h */ case   11:  		/* stw R10, <#[R11 + 64]> */
		/* 820A6050h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000040) );
		/* 820A6050h case   11:*/		return 0x820A6054;
		  /* 820A6054h */ case   12:  		/* stw R30, <#[R11 + 68]> */
		/* 820A6054h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000044) );
		/* 820A6054h case   12:*/		return 0x820A6058;
		  /* 820A6058h */ case   13:  		/* stw R31, <#[R11 + 72]> */
		/* 820A6058h case   13:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000048) );
		/* 820A6058h case   13:*/		return 0x820A605C;
		  /* 820A605Ch */ case   14:  		/* b 12 */
		/* 820A605Ch case   14:*/		return 0x820A6068;
		/* 820A605Ch case   14:*/		return 0x820A6060;
	}
	return 0x820A6060;
} // Block from 820A6024h-820A6060h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A6060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6060);
		  /* 820A6060h */ case    0:  		/* lis R3, -32768 */
		/* 820A6060h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A6060h case    0:*/		return 0x820A6064;
		  /* 820A6064h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820A6064h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820A6064h case    1:*/		return 0x820A6068;
	}
	return 0x820A6068;
} // Block from 820A6060h-820A6068h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6068);
		  /* 820A6068h */ case    0:  		/* ld R30, <#[R1 - 16]> */
		/* 820A6068h case    0:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A6068h case    0:*/		return 0x820A606C;
		  /* 820A606Ch */ case    1:  		/* ld R31, <#[R1 - 8]> */
		/* 820A606Ch case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A606Ch case    1:*/		return 0x820A6070;
		  /* 820A6070h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820A6070h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A6070h case    2:*/		return 0x820A6074;
	}
	return 0x820A6074;
} // Block from 820A6068h-820A6074h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A6074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6074);
		  /* 820A6074h */ case    0:  		/* nop */
		/* 820A6074h case    0:*/		cpu::op::nop();
		/* 820A6074h case    0:*/		return 0x820A6078;
	}
	return 0x820A6078;
} // Block from 820A6074h-820A6078h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6078);
		  /* 820A6078h */ case    0:  		/* stw R4, <#[R3 + 68]> */
		/* 820A6078h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000044) );
		/* 820A6078h case    0:*/		return 0x820A607C;
		  /* 820A607Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820A607Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A607Ch case    1:*/		return 0x820A6080;
	}
	return 0x820A6080;
} // Block from 820A6078h-820A6080h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6080);
		  /* 820A6080h */ case    0:  		/* mfspr R12, LR */
		/* 820A6080h case    0:*/		regs.R12 = regs.LR;
		/* 820A6080h case    0:*/		return 0x820A6084;
		  /* 820A6084h */ case    1:  		/* bl -85544 */
		/* 820A6084h case    1:*/		regs.LR = 0x820A6088; return 0x8209125C;
		/* 820A6084h case    1:*/		return 0x820A6088;
		  /* 820A6088h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A6088h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A6088h case    2:*/		return 0x820A608C;
		  /* 820A608Ch */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820A608Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A608Ch case    3:*/		return 0x820A6090;
		  /* 820A6090h */ case    4:  		/* mr R29, R3 */
		/* 820A6090h case    4:*/		regs.R29 = regs.R3;
		/* 820A6090h case    4:*/		return 0x820A6094;
		  /* 820A6094h */ case    5:  		/* mr R30, R4 */
		/* 820A6094h case    5:*/		regs.R30 = regs.R4;
		/* 820A6094h case    5:*/		return 0x820A6098;
		  /* 820A6098h */ case    6:  		/* mr R31, R4 */
		/* 820A6098h case    6:*/		regs.R31 = regs.R4;
		/* 820A6098h case    6:*/		return 0x820A609C;
		  /* 820A609Ch */ case    7:  		/* cmplw CR6, R4, R11 */
		/* 820A609Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820A609Ch case    7:*/		return 0x820A60A0;
		  /* 820A60A0h */ case    8:  		/* bc 4, CR6_LT, 60 */
		/* 820A60A0h case    8:*/		if ( !regs.CR[6].lt ) { return 0x820A60DC;  }
		/* 820A60A0h case    8:*/		return 0x820A60A4;
		  /* 820A60A4h */ case    9:  		/* lbz R3, <#[R31]> */
		/* 820A60A4h case    9:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A60A4h case    9:*/		return 0x820A60A8;
		  /* 820A60A8h */ case   10:  		/* bl -51512 */
		/* 820A60A8h case   10:*/		regs.LR = 0x820A60AC; return 0x82099770;
		/* 820A60A8h case   10:*/		return 0x820A60AC;
		  /* 820A60ACh */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820A60ACh case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A60ACh case   11:*/		return 0x820A60B0;
		  /* 820A60B0h */ case   12:  		/* bc 4, CR0_EQ, 28 */
		/* 820A60B0h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820A60CC;  }
		/* 820A60B0h case   12:*/		return 0x820A60B4;
		  /* 820A60B4h */ case   13:  		/* lbz R11, <#[R31]> */
		/* 820A60B4h case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A60B4h case   13:*/		return 0x820A60B8;
		  /* 820A60B8h */ case   14:  		/* extsb R11, R11 */
		/* 820A60B8h case   14:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820A60B8h case   14:*/		return 0x820A60BC;
		  /* 820A60BCh */ case   15:  		/* cmpwi CR6, R11, 95 */
		/* 820A60BCh case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005F);
		/* 820A60BCh case   15:*/		return 0x820A60C0;
		  /* 820A60C0h */ case   16:  		/* bc 12, CR6_EQ, 12 */
		/* 820A60C0h case   16:*/		if ( regs.CR[6].eq ) { return 0x820A60CC;  }
		/* 820A60C0h case   16:*/		return 0x820A60C4;
		  /* 820A60C4h */ case   17:  		/* cmpwi CR6, R11, 46 */
		/* 820A60C4h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002E);
		/* 820A60C4h case   17:*/		return 0x820A60C8;
		  /* 820A60C8h */ case   18:  		/* bc 4, CR6_EQ, 20 */
		/* 820A60C8h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820A60DC;  }
		/* 820A60C8h case   18:*/		return 0x820A60CC;
	}
	return 0x820A60CC;
} // Block from 820A6080h-820A60CCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A60CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A60CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A60CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A60CC);
		  /* 820A60CCh */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 820A60CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820A60CCh case    0:*/		return 0x820A60D0;
		  /* 820A60D0h */ case    1:  		/* addi R31, R31, 1 */
		/* 820A60D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A60D0h case    1:*/		return 0x820A60D4;
		  /* 820A60D4h */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 820A60D4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820A60D4h case    2:*/		return 0x820A60D8;
		  /* 820A60D8h */ case    3:  		/* bc 12, CR6_LT, -52 */
		/* 820A60D8h case    3:*/		if ( regs.CR[6].lt ) { return 0x820A60A4;  }
		/* 820A60D8h case    3:*/		return 0x820A60DC;
	}
	return 0x820A60DC;
} // Block from 820A60CCh-820A60DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A60DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A60DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A60DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A60DC);
		  /* 820A60DCh */ case    0:  		/* subf R3, R30, R31 */
		/* 820A60DCh case    0:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R30,regs.R31);
		/* 820A60DCh case    0:*/		return 0x820A60E0;
		  /* 820A60E0h */ case    1:  		/* addi R1, R1, 112 */
		/* 820A60E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A60E0h case    1:*/		return 0x820A60E4;
		  /* 820A60E4h */ case    2:  		/* b -85560 */
		/* 820A60E4h case    2:*/		return 0x820912AC;
		/* 820A60E4h case    2:*/		return 0x820A60E8;
	}
	return 0x820A60E8;
} // Block from 820A60DCh-820A60E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A60E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A60E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A60E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A60E8);
		  /* 820A60E8h */ case    0:  		/* mfspr R12, LR */
		/* 820A60E8h case    0:*/		regs.R12 = regs.LR;
		/* 820A60E8h case    0:*/		return 0x820A60EC;
		  /* 820A60ECh */ case    1:  		/* bl -85668 */
		/* 820A60ECh case    1:*/		regs.LR = 0x820A60F0; return 0x82091248;
		/* 820A60ECh case    1:*/		return 0x820A60F0;
		  /* 820A60F0h */ case    2:  		/* addi R31, R1, -160 */
		/* 820A60F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF60);
		/* 820A60F0h case    2:*/		return 0x820A60F4;
		  /* 820A60F4h */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 820A60F4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820A60F4h case    3:*/		return 0x820A60F8;
		  /* 820A60F8h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 820A60F8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A60F8h case    4:*/		return 0x820A60FC;
		  /* 820A60FCh */ case    5:  		/* mr R28, R3 */
		/* 820A60FCh case    5:*/		regs.R28 = regs.R3;
		/* 820A60FCh case    5:*/		return 0x820A6100;
		  /* 820A6100h */ case    6:  		/* mr R26, R4 */
		/* 820A6100h case    6:*/		regs.R26 = regs.R4;
		/* 820A6100h case    6:*/		return 0x820A6104;
		  /* 820A6104h */ case    7:  		/* mr R24, R5 */
		/* 820A6104h case    7:*/		regs.R24 = regs.R5;
		/* 820A6104h case    7:*/		return 0x820A6108;
		  /* 820A6108h */ case    8:  		/* li R25, 0 */
		/* 820A6108h case    8:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820A6108h case    8:*/		return 0x820A610C;
		  /* 820A610Ch */ case    9:  		/* cmplw CR6, R4, R11 */
		/* 820A610Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820A610Ch case    9:*/		return 0x820A6110;
		  /* 820A6110h */ case   10:  		/* bc 4, CR6_LT, 128 */
		/* 820A6110h case   10:*/		if ( !regs.CR[6].lt ) { return 0x820A6190;  }
		/* 820A6110h case   10:*/		return 0x820A6114;
		  /* 820A6114h */ case   11:  		/* lbz R3, <#[R4]> */
		/* 820A6114h case   11:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000000) );
		/* 820A6114h case   11:*/		return 0x820A6118;
		  /* 820A6118h */ case   12:  		/* bl -51720 */
		/* 820A6118h case   12:*/		regs.LR = 0x820A611C; return 0x82099710;
		/* 820A6118h case   12:*/		return 0x820A611C;
		  /* 820A611Ch */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820A611Ch case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A611Ch case   13:*/		return 0x820A6120;
		  /* 820A6120h */ case   14:  		/* bc 12, CR0_EQ, 112 */
		/* 820A6120h case   14:*/		if ( regs.CR[0].eq ) { return 0x820A6190;  }
		/* 820A6120h case   14:*/		return 0x820A6124;
		  /* 820A6124h */ case   15:  		/* addi R30, R26, 1 */
		/* 820A6124h case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R26,0x1);
		/* 820A6124h case   15:*/		return 0x820A6128;
		  /* 820A6128h */ case   16:  		/* b 24 */
		/* 820A6128h case   16:*/		return 0x820A6140;
		/* 820A6128h case   16:*/		return 0x820A612C;
		  /* 820A612Ch */ case   17:  		/* lbz R3, <#[R30]> */
		/* 820A612Ch case   17:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A612Ch case   17:*/		return 0x820A6130;
		  /* 820A6130h */ case   18:  		/* bl -51744 */
		/* 820A6130h case   18:*/		regs.LR = 0x820A6134; return 0x82099710;
		/* 820A6130h case   18:*/		return 0x820A6134;
		  /* 820A6134h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820A6134h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6134h case   19:*/		return 0x820A6138;
		  /* 820A6138h */ case   20:  		/* bc 12, CR0_EQ, 20 */
		/* 820A6138h case   20:*/		if ( regs.CR[0].eq ) { return 0x820A614C;  }
		/* 820A6138h case   20:*/		return 0x820A613C;
		  /* 820A613Ch */ case   21:  		/* addi R30, R30, 1 */
		/* 820A613Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820A613Ch case   21:*/		return 0x820A6140;
	}
	return 0x820A6140;
} // Block from 820A60E8h-820A6140h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820A6140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6140);
		  /* 820A6140h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A6140h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A6140h case    0:*/		return 0x820A6144;
		  /* 820A6144h */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 820A6144h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A6144h case    1:*/		return 0x820A6148;
		  /* 820A6148h */ case    2:  		/* bc 12, CR6_LT, -28 */
		/* 820A6148h case    2:*/		if ( regs.CR[6].lt ) { return 0x820A612C;  }
		/* 820A6148h case    2:*/		return 0x820A614C;
	}
	return 0x820A614C;
} // Block from 820A6140h-820A614Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A614Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A614C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A614C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A614C);
		  /* 820A614Ch */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A614Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A614Ch case    0:*/		return 0x820A6150;
		  /* 820A6150h */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 820A6150h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A6150h case    1:*/		return 0x820A6154;
		  /* 820A6154h */ case    2:  		/* bc 4, CR6_LT, 16 */
		/* 820A6154h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820A6164;  }
		/* 820A6154h case    2:*/		return 0x820A6158;
		  /* 820A6158h */ case    3:  		/* lbz R10, <#[R30]> */
		/* 820A6158h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820A6158h case    3:*/		return 0x820A615C;
		  /* 820A615Ch */ case    4:  		/* cmplwi CR6, R10, 46 */
		/* 820A615Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000002E);
		/* 820A615Ch case    4:*/		return 0x820A6160;
		  /* 820A6160h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 820A6160h case    5:*/		if ( regs.CR[6].eq ) { return 0x820A6180;  }
		/* 820A6160h case    5:*/		return 0x820A6164;
	}
	return 0x820A6164;
} // Block from 820A614Ch-820A6164h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A6164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6164);
		  /* 820A6164h */ case    0:  		/* li R25, 1 */
		/* 820A6164h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820A6164h case    0:*/		return 0x820A6168;
		  /* 820A6168h */ case    1:  		/* b 124 */
		/* 820A6168h case    1:*/		return 0x820A61E4;
		/* 820A6168h case    1:*/		return 0x820A616C;
		  /* 820A616Ch */ case    2:  		/* lbz R3, <#[R30]> */
		/* 820A616Ch case    2:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A616Ch case    2:*/		return 0x820A6170;
		  /* 820A6170h */ case    3:  		/* bl -51808 */
		/* 820A6170h case    3:*/		regs.LR = 0x820A6174; return 0x82099710;
		/* 820A6170h case    3:*/		return 0x820A6174;
		  /* 820A6174h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820A6174h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6174h case    4:*/		return 0x820A6178;
		  /* 820A6178h */ case    5:  		/* bc 12, CR0_EQ, 108 */
		/* 820A6178h case    5:*/		if ( regs.CR[0].eq ) { return 0x820A61E4;  }
		/* 820A6178h case    5:*/		return 0x820A617C;
		  /* 820A617Ch */ case    6:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A617Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A617Ch case    6:*/		return 0x820A6180;
	}
	return 0x820A6180;
} // Block from 820A6164h-820A6180h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A6180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6180);
		  /* 820A6180h */ case    0:  		/* addi R30, R30, 1 */
		/* 820A6180h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820A6180h case    0:*/		return 0x820A6184;
		  /* 820A6184h */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 820A6184h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A6184h case    1:*/		return 0x820A6188;
		  /* 820A6188h */ case    2:  		/* bc 12, CR6_LT, -28 */
		/* 820A6188h case    2:*/		if ( regs.CR[6].lt ) { return 0x820A616C;  }
		/* 820A6188h case    2:*/		return 0x820A618C;
		  /* 820A618Ch */ case    3:  		/* b 88 */
		/* 820A618Ch case    3:*/		return 0x820A61E4;
		/* 820A618Ch case    3:*/		return 0x820A6190;
	}
	return 0x820A6190;
} // Block from 820A6180h-820A6190h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A6190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6190);
		  /* 820A6190h */ case    0:  		/* lwz R10, <#[R28 + 8]> */
		/* 820A6190h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 820A6190h case    0:*/		return 0x820A6194;
		  /* 820A6194h */ case    1:  		/* addi R11, R26, 1 */
		/* 820A6194h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1);
		/* 820A6194h case    1:*/		return 0x820A6198;
		  /* 820A6198h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820A6198h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A6198h case    2:*/		return 0x820A619C;
		  /* 820A619Ch */ case    3:  		/* bc 4, CR6_LT, 496 */
		/* 820A619Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x820A638C;  }
		/* 820A619Ch case    3:*/		return 0x820A61A0;
		  /* 820A61A0h */ case    4:  		/* lbz R10, <#[R26]> */
		/* 820A61A0h case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820A61A0h case    4:*/		return 0x820A61A4;
		  /* 820A61A4h */ case    5:  		/* cmplwi CR6, R10, 46 */
		/* 820A61A4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000002E);
		/* 820A61A4h case    5:*/		return 0x820A61A8;
		  /* 820A61A8h */ case    6:  		/* bc 4, CR6_EQ, 484 */
		/* 820A61A8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A638C;  }
		/* 820A61A8h case    6:*/		return 0x820A61AC;
		  /* 820A61ACh */ case    7:  		/* lbz R3, <#[R11]> */
		/* 820A61ACh case    7:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 820A61ACh case    7:*/		return 0x820A61B0;
		  /* 820A61B0h */ case    8:  		/* bl -51872 */
		/* 820A61B0h case    8:*/		regs.LR = 0x820A61B4; return 0x82099710;
		/* 820A61B0h case    8:*/		return 0x820A61B4;
		  /* 820A61B4h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820A61B4h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A61B4h case    9:*/		return 0x820A61B8;
		  /* 820A61B8h */ case   10:  		/* bc 12, CR0_EQ, 468 */
		/* 820A61B8h case   10:*/		if ( regs.CR[0].eq ) { return 0x820A638C;  }
		/* 820A61B8h case   10:*/		return 0x820A61BC;
		  /* 820A61BCh */ case   11:  		/* addi R30, R26, 2 */
		/* 820A61BCh case   11:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R26,0x2);
		/* 820A61BCh case   11:*/		return 0x820A61C0;
		  /* 820A61C0h */ case   12:  		/* b 24 */
		/* 820A61C0h case   12:*/		return 0x820A61D8;
		/* 820A61C0h case   12:*/		return 0x820A61C4;
		  /* 820A61C4h */ case   13:  		/* lbz R3, <#[R30]> */
		/* 820A61C4h case   13:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A61C4h case   13:*/		return 0x820A61C8;
		  /* 820A61C8h */ case   14:  		/* bl -51896 */
		/* 820A61C8h case   14:*/		regs.LR = 0x820A61CC; return 0x82099710;
		/* 820A61C8h case   14:*/		return 0x820A61CC;
		  /* 820A61CCh */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820A61CCh case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A61CCh case   15:*/		return 0x820A61D0;
		  /* 820A61D0h */ case   16:  		/* bc 12, CR0_EQ, 20 */
		/* 820A61D0h case   16:*/		if ( regs.CR[0].eq ) { return 0x820A61E4;  }
		/* 820A61D0h case   16:*/		return 0x820A61D4;
		  /* 820A61D4h */ case   17:  		/* addi R30, R30, 1 */
		/* 820A61D4h case   17:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820A61D4h case   17:*/		return 0x820A61D8;
	}
	return 0x820A61D8;
} // Block from 820A6190h-820A61D8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820A61D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A61D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A61D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A61D8);
		  /* 820A61D8h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A61D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A61D8h case    0:*/		return 0x820A61DC;
		  /* 820A61DCh */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 820A61DCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A61DCh case    1:*/		return 0x820A61E0;
		  /* 820A61E0h */ case    2:  		/* bc 12, CR6_LT, -28 */
		/* 820A61E0h case    2:*/		if ( regs.CR[6].lt ) { return 0x820A61C4;  }
		/* 820A61E0h case    2:*/		return 0x820A61E4;
	}
	return 0x820A61E4;
} // Block from 820A61D8h-820A61E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A61E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A61E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A61E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A61E4);
		  /* 820A61E4h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A61E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A61E4h case    0:*/		return 0x820A61E8;
		  /* 820A61E8h */ case    1:  		/* addi R29, R30, 1 */
		/* 820A61E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x1);
		/* 820A61E8h case    1:*/		return 0x820A61EC;
		  /* 820A61ECh */ case    2:  		/* cmplw CR6, R29, R11 */
		/* 820A61ECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820A61ECh case    2:*/		return 0x820A61F0;
		  /* 820A61F0h */ case    3:  		/* bc 4, CR6_LT, 80 */
		/* 820A61F0h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820A6240;  }
		/* 820A61F0h case    3:*/		return 0x820A61F4;
		  /* 820A61F4h */ case    4:  		/* lbz R3, <#[R30]> */
		/* 820A61F4h case    4:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A61F4h case    4:*/		return 0x820A61F8;
		  /* 820A61F8h */ case    5:  		/* bl -51816 */
		/* 820A61F8h case    5:*/		regs.LR = 0x820A61FC; return 0x82099790;
		/* 820A61F8h case    5:*/		return 0x820A61FC;
		  /* 820A61FCh */ case    6:  		/* cmpwi CR6, R3, 101 */
		/* 820A61FCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000065);
		/* 820A61FCh case    6:*/		return 0x820A6200;
		  /* 820A6200h */ case    7:  		/* bc 4, CR6_EQ, 64 */
		/* 820A6200h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820A6240;  }
		/* 820A6200h case    7:*/		return 0x820A6204;
		  /* 820A6204h */ case    8:  		/* lbz R3, <#[R29]> */
		/* 820A6204h case    8:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 820A6204h case    8:*/		return 0x820A6208;
		  /* 820A6208h */ case    9:  		/* bl -51960 */
		/* 820A6208h case    9:*/		regs.LR = 0x820A620C; return 0x82099710;
		/* 820A6208h case    9:*/		return 0x820A620C;
		  /* 820A620Ch */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820A620Ch case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A620Ch case   10:*/		return 0x820A6210;
		  /* 820A6210h */ case   11:  		/* bc 12, CR0_EQ, 48 */
		/* 820A6210h case   11:*/		if ( regs.CR[0].eq ) { return 0x820A6240;  }
		/* 820A6210h case   11:*/		return 0x820A6214;
		  /* 820A6214h */ case   12:  		/* addi R30, R30, 2 */
		/* 820A6214h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x2);
		/* 820A6214h case   12:*/		return 0x820A6218;
		  /* 820A6218h */ case   13:  		/* b 24 */
		/* 820A6218h case   13:*/		return 0x820A6230;
		/* 820A6218h case   13:*/		return 0x820A621C;
		  /* 820A621Ch */ case   14:  		/* lbz R3, <#[R30]> */
		/* 820A621Ch case   14:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A621Ch case   14:*/		return 0x820A6220;
		  /* 820A6220h */ case   15:  		/* bl -51984 */
		/* 820A6220h case   15:*/		regs.LR = 0x820A6224; return 0x82099710;
		/* 820A6220h case   15:*/		return 0x820A6224;
		  /* 820A6224h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820A6224h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6224h case   16:*/		return 0x820A6228;
		  /* 820A6228h */ case   17:  		/* bc 12, CR0_EQ, 256 */
		/* 820A6228h case   17:*/		if ( regs.CR[0].eq ) { return 0x820A6328;  }
		/* 820A6228h case   17:*/		return 0x820A622C;
		  /* 820A622Ch */ case   18:  		/* addi R30, R30, 1 */
		/* 820A622Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820A622Ch case   18:*/		return 0x820A6230;
	}
	return 0x820A6230;
} // Block from 820A61E4h-820A6230h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A6230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6230);
		  /* 820A6230h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A6230h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A6230h case    0:*/		return 0x820A6234;
		  /* 820A6234h */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 820A6234h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A6234h case    1:*/		return 0x820A6238;
		  /* 820A6238h */ case    2:  		/* bc 12, CR6_LT, -28 */
		/* 820A6238h case    2:*/		if ( regs.CR[6].lt ) { return 0x820A621C;  }
		/* 820A6238h case    2:*/		return 0x820A623C;
		  /* 820A623Ch */ case    3:  		/* b 236 */
		/* 820A623Ch case    3:*/		return 0x820A6328;
		/* 820A623Ch case    3:*/		return 0x820A6240;
	}
	return 0x820A6240;
} // Block from 820A6230h-820A6240h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A6240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6240);
		  /* 820A6240h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A6240h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A6240h case    0:*/		return 0x820A6244;
		  /* 820A6244h */ case    1:  		/* addi R27, R30, 2 */
		/* 820A6244h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R30,0x2);
		/* 820A6244h case    1:*/		return 0x820A6248;
		  /* 820A6248h */ case    2:  		/* cmplw CR6, R27, R11 */
		/* 820A6248h case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820A6248h case    2:*/		return 0x820A624C;
		  /* 820A624Ch */ case    3:  		/* bc 4, CR6_LT, 104 */
		/* 820A624Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x820A62B4;  }
		/* 820A624Ch case    3:*/		return 0x820A6250;
		  /* 820A6250h */ case    4:  		/* lbz R3, <#[R30]> */
		/* 820A6250h case    4:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A6250h case    4:*/		return 0x820A6254;
		  /* 820A6254h */ case    5:  		/* bl -51908 */
		/* 820A6254h case    5:*/		regs.LR = 0x820A6258; return 0x82099790;
		/* 820A6254h case    5:*/		return 0x820A6258;
	}
	return 0x820A6258;
} // Block from 820A6240h-820A6258h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A6258h
// Function '?Release@CBuffer@D3DXCore@@UAAKXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6258);
		  /* 820A6258h */ case    0:  		/* cmpwi CR6, R3, 101 */
		/* 820A6258h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000065);
		/* 820A6258h case    0:*/		return 0x820A625C;
		  /* 820A625Ch */ case    1:  		/* bc 4, CR6_EQ, 88 */
		/* 820A625Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A62B4;  }
		/* 820A625Ch case    1:*/		return 0x820A6260;
		  /* 820A6260h */ case    2:  		/* lbz R11, <#[R29]> */
		/* 820A6260h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820A6260h case    2:*/		return 0x820A6264;
		  /* 820A6264h */ case    3:  		/* extsb R11, R11 */
		/* 820A6264h case    3:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820A6264h case    3:*/		return 0x820A6268;
		  /* 820A6268h */ case    4:  		/* cmpwi CR6, R11, 43 */
		/* 820A6268h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002B);
		/* 820A6268h case    4:*/		return 0x820A626C;
		  /* 820A626Ch */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 820A626Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820A6278;  }
		/* 820A626Ch case    5:*/		return 0x820A6270;
		  /* 820A6270h */ case    6:  		/* cmpwi CR6, R11, 45 */
		/* 820A6270h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002D);
		/* 820A6270h case    6:*/		return 0x820A6274;
		  /* 820A6274h */ case    7:  		/* bc 4, CR6_EQ, 64 */
		/* 820A6274h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820A62B4;  }
		/* 820A6274h case    7:*/		return 0x820A6278;
	}
	return 0x820A6278;
} // Block from 820A6258h-820A6278h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A6278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6278);
		  /* 820A6278h */ case    0:  		/* lbz R3, <#[R27]> */
		/* 820A6278h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000000) );
		/* 820A6278h case    0:*/		return 0x820A627C;
		  /* 820A627Ch */ case    1:  		/* bl -52076 */
		/* 820A627Ch case    1:*/		regs.LR = 0x820A6280; return 0x82099710;
		/* 820A627Ch case    1:*/		return 0x820A6280;
		  /* 820A6280h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820A6280h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6280h case    2:*/		return 0x820A6284;
		  /* 820A6284h */ case    3:  		/* bc 12, CR0_EQ, 48 */
		/* 820A6284h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A62B4;  }
		/* 820A6284h case    3:*/		return 0x820A6288;
		  /* 820A6288h */ case    4:  		/* addi R30, R30, 3 */
		/* 820A6288h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x3);
		/* 820A6288h case    4:*/		return 0x820A628C;
		  /* 820A628Ch */ case    5:  		/* b 24 */
		/* 820A628Ch case    5:*/		return 0x820A62A4;
		/* 820A628Ch case    5:*/		return 0x820A6290;
		  /* 820A6290h */ case    6:  		/* lbz R3, <#[R30]> */
		/* 820A6290h case    6:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A6290h case    6:*/		return 0x820A6294;
		  /* 820A6294h */ case    7:  		/* bl -52100 */
		/* 820A6294h case    7:*/		regs.LR = 0x820A6298; return 0x82099710;
		/* 820A6294h case    7:*/		return 0x820A6298;
		  /* 820A6298h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820A6298h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6298h case    8:*/		return 0x820A629C;
		  /* 820A629Ch */ case    9:  		/* bc 12, CR0_EQ, 140 */
		/* 820A629Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x820A6328;  }
		/* 820A629Ch case    9:*/		return 0x820A62A0;
		  /* 820A62A0h */ case   10:  		/* addi R30, R30, 1 */
		/* 820A62A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820A62A0h case   10:*/		return 0x820A62A4;
	}
	return 0x820A62A4;
} // Block from 820A6278h-820A62A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A62A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A62A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A62A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A62A4);
		  /* 820A62A4h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A62A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A62A4h case    0:*/		return 0x820A62A8;
	}
	return 0x820A62A8;
} // Block from 820A62A4h-820A62A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A62A8h
// Function '?GetDefines@PreProcessorInitializeFromMemory@D3DXShader@@UAAPBU_D3DXMACRO@@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A62A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A62A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A62A8);
		  /* 820A62A8h */ case    0:  		/* cmplw CR6, R30, R11 */
		/* 820A62A8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A62A8h case    0:*/		return 0x820A62AC;
		  /* 820A62ACh */ case    1:  		/* bc 12, CR6_LT, -28 */
		/* 820A62ACh case    1:*/		if ( regs.CR[6].lt ) { return 0x820A6290;  }
		/* 820A62ACh case    1:*/		return 0x820A62B0;
	}
	return 0x820A62B0;
} // Block from 820A62A8h-820A62B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A62B0h
// Function '?GetBufferSize@CBuffer@D3DXCore@@UAAKXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A62B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A62B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A62B0);
		  /* 820A62B0h */ case    0:  		/* b 120 */
		/* 820A62B0h case    0:*/		return 0x820A6328;
		/* 820A62B0h case    0:*/		return 0x820A62B4;
	}
	return 0x820A62B4;
} // Block from 820A62B0h-820A62B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A62B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A62B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A62B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A62B4);
		  /* 820A62B4h */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820A62B4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A62B4h case    0:*/		return 0x820A62B8;
	}
	return 0x820A62B8;
} // Block from 820A62B4h-820A62B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A62B8h
// Function '?Init@CBuffer@D3DXCore@@UAAJK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A62B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A62B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A62B8);
		  /* 820A62B8h */ case    0:  		/* cmplwi CR6, R11, 35 */
		/* 820A62B8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000023);
		/* 820A62B8h case    0:*/		return 0x820A62BC;
		  /* 820A62BCh */ case    1:  		/* bc 4, CR6_EQ, 100 */
		/* 820A62BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A6320;  }
		/* 820A62BCh case    1:*/		return 0x820A62C0;
		  /* 820A62C0h */ case    2:  		/* lis R11, -32255 */
		/* 820A62C0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A62C0h case    2:*/		return 0x820A62C4;
		  /* 820A62C4h */ case    3:  		/* addi R27, R11, -9616 */
		/* 820A62C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFDA70);
		/* 820A62C4h case    3:*/		return 0x820A62C8;
		  /* 820A62C8h */ case    4:  		/* lwz R4, <#[R27]> */
		/* 820A62C8h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000000) );
		/* 820A62C8h case    4:*/		return 0x820A62CC;
		  /* 820A62CCh */ case    5:  		/* mr R11, R4 */
		/* 820A62CCh case    5:*/		regs.R11 = regs.R4;
		/* 820A62CCh case    5:*/		return 0x820A62D0;
		  /* 820A62D0h */ case    6:  		/* lbz R10, <#[R11]> */
		/* 820A62D0h case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A62D0h case    6:*/		return 0x820A62D4;
		  /* 820A62D4h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A62D4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A62D4h case    7:*/		return 0x820A62D8;
		  /* 820A62D8h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 820A62D8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A62D8h case    8:*/		return 0x820A62DC;
		  /* 820A62DCh */ case    9:  		/* bc 4, CR6_EQ, -12 */
		/* 820A62DCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A62D0;  }
		/* 820A62DCh case    9:*/		return 0x820A62E0;
		  /* 820A62E0h */ case   10:  		/* subf R11, R4, R11 */
		/* 820A62E0h case   10:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 820A62E0h case   10:*/		return 0x820A62E4;
		  /* 820A62E4h */ case   11:  		/* lwz R10, <#[R28 + 8]> */
		/* 820A62E4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 820A62E4h case   11:*/		return 0x820A62E8;
		  /* 820A62E8h */ case   12:  		/* addi R11, R11, -1 */
		/* 820A62E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A62E8h case   12:*/		return 0x820A62EC;
		  /* 820A62ECh */ case   13:  		/* subf R10, R26, R10 */
		/* 820A62ECh case   13:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R26,regs.R10);
		/* 820A62ECh case   13:*/		return 0x820A62F0;
		  /* 820A62F0h */ case   14:  		/* rlwinm R29, R11, 0, 0, 31 */
		/* 820A62F0h case   14:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R29,regs.R11);
		/* 820A62F0h case   14:*/		return 0x820A62F4;
		  /* 820A62F4h */ case   15:  		/* cmpw CR6, R10, R29 */
		/* 820A62F4h case   15:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R29);
		/* 820A62F4h case   15:*/		return 0x820A62F8;
		  /* 820A62F8h */ case   16:  		/* bc 12, CR6_LT, 24 */
		/* 820A62F8h case   16:*/		if ( regs.CR[6].lt ) { return 0x820A6310;  }
		/* 820A62F8h case   16:*/		return 0x820A62FC;
		  /* 820A62FCh */ case   17:  		/* mr R5, R29 */
		/* 820A62FCh case   17:*/		regs.R5 = regs.R29;
		/* 820A62FCh case   17:*/		return 0x820A6300;
		  /* 820A6300h */ case   18:  		/* mr R3, R26 */
		/* 820A6300h case   18:*/		regs.R3 = regs.R26;
		/* 820A6300h case   18:*/		return 0x820A6304;
		  /* 820A6304h */ case   19:  		/* bl -81812 */
		/* 820A6304h case   19:*/		regs.LR = 0x820A6308; return 0x82092370;
		/* 820A6304h case   19:*/		return 0x820A6308;
		  /* 820A6308h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820A6308h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6308h case   20:*/		return 0x820A630C;
		  /* 820A630Ch */ case   21:  		/* bc 12, CR0_EQ, 112 */
		/* 820A630Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x820A637C;  }
		/* 820A630Ch case   21:*/		return 0x820A6310;
	}
	return 0x820A6310;
} // Block from 820A62B8h-820A6310h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820A6310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6310);
		  /* 820A6310h */ case    0:  		/* addi R27, R27, 8 */
		/* 820A6310h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x8);
		/* 820A6310h case    0:*/		return 0x820A6314;
		  /* 820A6314h */ case    1:  		/* lwz R11, <#[R27 + 4]> */
		/* 820A6314h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 820A6314h case    1:*/		return 0x820A6318;
	}
	return 0x820A6318;
} // Block from 820A6310h-820A6318h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6318h
// Function '?QueryInterface@CBuffer@D3DXCore@@UAAJABU_GUID@@PAPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6318);
		  /* 820A6318h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820A6318h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A6318h case    0:*/		return 0x820A631C;
		  /* 820A631Ch */ case    1:  		/* bc 4, CR6_EQ, -84 */
		/* 820A631Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A62C8;  }
		/* 820A631Ch case    1:*/		return 0x820A6320;
	}
	return 0x820A6320;
} // Block from 820A6318h-820A6320h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6320);
		  /* 820A6320h */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 820A6320h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 820A6320h case    0:*/		return 0x820A6324;
		  /* 820A6324h */ case    1:  		/* bc 4, CR6_EQ, 104 */
		/* 820A6324h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A638C;  }
		/* 820A6324h case    1:*/		return 0x820A6328;
	}
	return 0x820A6328;
} // Block from 820A6320h-820A6328h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6328);
		  /* 820A6328h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 820A6328h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820A6328h case    0:*/		return 0x820A632C;
		  /* 820A632Ch */ case    1:  		/* bc 12, CR6_EQ, 72 */
		/* 820A632Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820A6374;  }
		/* 820A632Ch case    1:*/		return 0x820A6330;
		  /* 820A6330h */ case    2:  		/* subf R29, R26, R30 */
		/* 820A6330h case    2:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R26,regs.R30);
		/* 820A6330h case    2:*/		return 0x820A6334;
		  /* 820A6334h */ case    3:  		/* addi R11, R29, 1 */
		/* 820A6334h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x1);
		/* 820A6334h case    3:*/		return 0x820A6338;
		  /* 820A6338h */ case    4:  		/* neg R11, R11 */
		/* 820A6338h case    4:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 820A6338h case    4:*/		return 0x820A633C;
		  /* 820A633Ch */ case    5:  		/* rlwinm R12, R11, 0, 0, 27 */
		/* 820A633Ch case    5:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R12,regs.R11);
		/* 820A633Ch case    5:*/		return 0x820A6340;
		  /* 820A6340h */ case    6:  		/* bl -77724 */
		/* 820A6340h case    6:*/		regs.LR = 0x820A6344; return 0x820933A4;
		/* 820A6340h case    6:*/		return 0x820A6344;
		  /* 820A6344h */ case    7:  		/* lwz R11, <#[R1]> */
		/* 820A6344h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000000) );
		/* 820A6344h case    7:*/		return 0x820A6348;
		  /* 820A6348h */ case    8:  		/* mr R5, R29 */
		/* 820A6348h case    8:*/		regs.R5 = regs.R29;
		/* 820A6348h case    8:*/		return 0x820A634C;
		  /* 820A634Ch */ case    9:  		/* mr R4, R26 */
		/* 820A634Ch case    9:*/		regs.R4 = regs.R26;
		/* 820A634Ch case    9:*/		return 0x820A6350;
		  /* 820A6350h */ case   10:  		/* stwux R11, <#[R1 + R12]> */
		/* 820A6350h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + regs.R12 + 0x00000000) );
		regs.R1 = (uint32)(regs.R1 + regs.R12 + 0x00000000);
		/* 820A6350h case   10:*/		return 0x820A6354;
		  /* 820A6354h */ case   11:  		/* addi R28, R1, 80 */
		/* 820A6354h case   11:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x50);
		/* 820A6354h case   11:*/		return 0x820A6358;
		  /* 820A6358h */ case   12:  		/* mr R3, R28 */
		/* 820A6358h case   12:*/		regs.R3 = regs.R28;
		/* 820A6358h case   12:*/		return 0x820A635C;
		  /* 820A635Ch */ case   13:  		/* bl -84396 */
		/* 820A635Ch case   13:*/		regs.LR = 0x820A6360; return 0x820919B0;
		/* 820A635Ch case   13:*/		return 0x820A6360;
		  /* 820A6360h */ case   14:  		/* li R11, 0 */
		/* 820A6360h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A6360h case   14:*/		return 0x820A6364;
		  /* 820A6364h */ case   15:  		/* mr R3, R28 */
		/* 820A6364h case   15:*/		regs.R3 = regs.R28;
		/* 820A6364h case   15:*/		return 0x820A6368;
		  /* 820A6368h */ case   16:  		/* stbx R11, <#[R28 + R29]> */
		/* 820A6368h case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 820A6368h case   16:*/		return 0x820A636C;
		  /* 820A636Ch */ case   17:  		/* bl 1841932 */
		/* 820A636Ch case   17:*/		regs.LR = 0x820A6370; return 0x82267E78;
		/* 820A636Ch case   17:*/		return 0x820A6370;
		  /* 820A6370h */ case   18:  		/* stfd FR1, <#[R24]> */
		/* 820A6370h case   18:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R24 + 0x00000000) );
		/* 820A6370h case   18:*/		return 0x820A6374;
	}
	return 0x820A6374;
} // Block from 820A6328h-820A6374h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A6374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6374);
		  /* 820A6374h */ case    0:  		/* subf R3, R26, R30 */
		/* 820A6374h case    0:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R26,regs.R30);
		/* 820A6374h case    0:*/		return 0x820A6378;
		  /* 820A6378h */ case    1:  		/* b 24 */
		/* 820A6378h case    1:*/		return 0x820A6390;
		/* 820A6378h case    1:*/		return 0x820A637C;
	}
	return 0x820A637C;
} // Block from 820A6374h-820A637Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A637Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A637C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A637C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A637C);
		  /* 820A637Ch */ case    0:  		/* lfs FR0, <#[R27 + 4]> */
		/* 820A637Ch case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R27 + 0x00000004) );
		/* 820A637Ch case    0:*/		return 0x820A6380;
		  /* 820A6380h */ case    1:  		/* mr R3, R29 */
		/* 820A6380h case    1:*/		regs.R3 = regs.R29;
		/* 820A6380h case    1:*/		return 0x820A6384;
		  /* 820A6384h */ case    2:  		/* stfd FR0, <#[R24]> */
		/* 820A6384h case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R24 + 0x00000000) );
		/* 820A6384h case    2:*/		return 0x820A6388;
		  /* 820A6388h */ case    3:  		/* b 8 */
		/* 820A6388h case    3:*/		return 0x820A6390;
		/* 820A6388h case    3:*/		return 0x820A638C;
	}
	return 0x820A638C;
} // Block from 820A637Ch-820A638Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A638Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A638C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A638C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A638C);
		  /* 820A638Ch */ case    0:  		/* li R3, 0 */
		/* 820A638Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A638Ch case    0:*/		return 0x820A6390;
	}
	return 0x820A6390;
} // Block from 820A638Ch-820A6390h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6390);
		  /* 820A6390h */ case    0:  		/* addi R1, R31, 160 */
		/* 820A6390h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0xA0);
		/* 820A6390h case    0:*/		return 0x820A6394;
		  /* 820A6394h */ case    1:  		/* b -86268 */
		/* 820A6394h case    1:*/		return 0x82091298;
		/* 820A6394h case    1:*/		return 0x820A6398;
		  /* 820A6398h */ case    2:  		/* li R10, 0 */
		/* 820A6398h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A6398h case    2:*/		return 0x820A639C;
		  /* 820A639Ch */ case    3:  		/* addi R11, R4, 1 */
		/* 820A639Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1);
		/* 820A639Ch case    3:*/		return 0x820A63A0;
		  /* 820A63A0h */ case    4:  		/* stw R10, <#[R5]> */
		/* 820A63A0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 820A63A0h case    4:*/		return 0x820A63A4;
		  /* 820A63A4h */ case    5:  		/* lbz R10, <#[R4]> */
		/* 820A63A4h case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 820A63A4h case    5:*/		return 0x820A63A8;
		  /* 820A63A8h */ case    6:  		/* stb R10, <#[R5]> */
		/* 820A63A8h case    6:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 820A63A8h case    6:*/		return 0x820A63AC;
		  /* 820A63ACh */ case    7:  		/* lwz R6, <#[R3 + 8]> */
		/* 820A63ACh case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000008) );
		/* 820A63ACh case    7:*/		return 0x820A63B0;
		  /* 820A63B0h */ case    8:  		/* cmplw CR6, R11, R6 */
		/* 820A63B0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820A63B0h case    8:*/		return 0x820A63B4;
		  /* 820A63B4h */ case    9:  		/* bc 4, CR6_LT, 196 */
		/* 820A63B4h case    9:*/		if ( !regs.CR[6].lt ) { return 0x820A6478;  }
		/* 820A63B4h case    9:*/		return 0x820A63B8;
		  /* 820A63B8h */ case   10:  		/* lbz R7, <#[R4]> */
		/* 820A63B8h case   10:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000000) );
		/* 820A63B8h case   10:*/		return 0x820A63BC;
		  /* 820A63BCh */ case   11:  		/* extsb R8, R7 */
		/* 820A63BCh case   11:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R7);
		/* 820A63BCh case   11:*/		return 0x820A63C0;
		  /* 820A63C0h */ case   12:  		/* cmpwi CR6, R8, 35 */
		/* 820A63C0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000023);
		/* 820A63C0h case   12:*/		return 0x820A63C4;
		  /* 820A63C4h */ case   13:  		/* bc 4, CR6_EQ, 40 */
		/* 820A63C4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A63EC;  }
		/* 820A63C4h case   13:*/		return 0x820A63C8;
		  /* 820A63C8h */ case   14:  		/* lbz R10, <#[R11]> */
		/* 820A63C8h case   14:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A63C8h case   14:*/		return 0x820A63CC;
		  /* 820A63CCh */ case   15:  		/* mr R9, R10 */
		/* 820A63CCh case   15:*/		regs.R9 = regs.R10;
		/* 820A63CCh case   15:*/		return 0x820A63D0;
	}
	return 0x820A63D0;
} // Block from 820A6390h-820A63D0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A63D0h
// Function '??_GCBuffer@D3DXCore@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A63D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A63D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A63D0);
		  /* 820A63D0h */ case    0:  		/* cmplwi CR6, R10, 35 */
		/* 820A63D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000023);
		/* 820A63D0h case    0:*/		return 0x820A63D4;
		  /* 820A63D4h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820A63D4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A63D4h case    1:*/		return 0x820A63D8;
		  /* 820A63D8h */ case    2:  		/* cmplwi CR6, R10, 64 */
		/* 820A63D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000040);
		/* 820A63D8h case    2:*/		return 0x820A63DC;
		  /* 820A63DCh */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820A63DCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A63EC;  }
		/* 820A63DCh case    3:*/		return 0x820A63E0;
	}
	return 0x820A63E0;
} // Block from 820A63D0h-820A63E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A63E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A63E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A63E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A63E0);
		  /* 820A63E0h */ case    0:  		/* stb R10, <#[R5 + 1]> */
		/* 820A63E0h case    0:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R5 + 0x00000001) );
		/* 820A63E0h case    0:*/		return 0x820A63E4;
		  /* 820A63E4h */ case    1:  		/* li R3, 2 */
		/* 820A63E4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 820A63E4h case    1:*/		return 0x820A63E8;
		  /* 820A63E8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820A63E8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A63E8h case    2:*/		return 0x820A63EC;
	}
	return 0x820A63EC;
} // Block from 820A63E0h-820A63ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A63ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A63EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A63EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A63EC);
		  /* 820A63ECh */ case    0:  		/* lbz R10, <#[R11]> */
		/* 820A63ECh case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A63ECh case    0:*/		return 0x820A63F0;
		  /* 820A63F0h */ case    1:  		/* extsb R11, R10 */
		/* 820A63F0h case    1:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R10);
		/* 820A63F0h case    1:*/		return 0x820A63F4;
		  /* 820A63F4h */ case    2:  		/* cmpw CR6, R8, R11 */
		/* 820A63F4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R11);
		/* 820A63F4h case    2:*/		return 0x820A63F8;
		  /* 820A63F8h */ case    3:  		/* bc 4, CR6_EQ, 180 */
		/* 820A63F8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A64AC;  }
		/* 820A63F8h case    3:*/		return 0x820A63FC;
		  /* 820A63FCh */ case    4:  		/* rlwinm R11, R7, 0, 24, 31 */
		/* 820A63FCh case    4:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R7);
		/* 820A63FCh case    4:*/		return 0x820A6400;
		  /* 820A6400h */ case    5:  		/* cmplwi CR6, R11, 58 */
		/* 820A6400h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003A);
		/* 820A6400h case    5:*/		return 0x820A6404;
		  /* 820A6404h */ case    6:  		/* bc 12, CR6_GT, 84 */
		/* 820A6404h case    6:*/		if ( regs.CR[6].gt ) { return 0x820A6458;  }
		/* 820A6404h case    6:*/		return 0x820A6408;
		  /* 820A6408h */ case    7:  		/* bc 12, CR6_EQ, -40 */
		/* 820A6408h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A6408h case    7:*/		return 0x820A640C;
		  /* 820A640Ch */ case    8:  		/* cmplwi CR6, R11, 38 */
		/* 820A640Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000026);
		/* 820A640Ch case    8:*/		return 0x820A6410;
		  /* 820A6410h */ case    9:  		/* bc 12, CR6_EQ, -48 */
		/* 820A6410h case    9:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A6410h case    9:*/		return 0x820A6414;
		  /* 820A6414h */ case   10:  		/* cmplwi CR6, R11, 43 */
		/* 820A6414h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002B);
		/* 820A6414h case   10:*/		return 0x820A6418;
		  /* 820A6418h */ case   11:  		/* bc 12, CR6_EQ, -56 */
		/* 820A6418h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A6418h case   11:*/		return 0x820A641C;
		  /* 820A641Ch */ case   12:  		/* cmplwi CR6, R11, 45 */
		/* 820A641Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002D);
		/* 820A641Ch case   12:*/		return 0x820A6420;
		  /* 820A6420h */ case   13:  		/* bc 12, CR6_EQ, -64 */
		/* 820A6420h case   13:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A6420h case   13:*/		return 0x820A6424;
		  /* 820A6424h */ case   14:  		/* cmplwi CR6, R11, 46 */
		/* 820A6424h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002E);
		/* 820A6424h case   14:*/		return 0x820A6428;
		  /* 820A6428h */ case   15:  		/* bc 4, CR6_EQ, 80 */
		/* 820A6428h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820A6478;  }
		/* 820A6428h case   15:*/		return 0x820A642C;
		  /* 820A642Ch */ case   16:  		/* addi R11, R4, 2 */
		/* 820A642Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x2);
		/* 820A642Ch case   16:*/		return 0x820A6430;
		  /* 820A6430h */ case   17:  		/* cmplw CR6, R11, R6 */
		/* 820A6430h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820A6430h case   17:*/		return 0x820A6434;
		  /* 820A6434h */ case   18:  		/* bc 4, CR6_LT, 68 */
		/* 820A6434h case   18:*/		if ( !regs.CR[6].lt ) { return 0x820A6478;  }
		/* 820A6434h case   18:*/		return 0x820A6438;
	}
	return 0x820A6438;
} // Block from 820A63ECh-820A6438h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A6438h
// Function '?Create@CBuffer@D3DXCore@@SAJKPAPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6438);
		  /* 820A6438h */ case    0:  		/* lbz R9, <#[R11]> */
		/* 820A6438h case    0:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6438h case    0:*/		return 0x820A643C;
		  /* 820A643Ch */ case    1:  		/* cmplwi CR6, R9, 46 */
		/* 820A643Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000002E);
		/* 820A643Ch case    1:*/		return 0x820A6440;
		  /* 820A6440h */ case    2:  		/* bc 4, CR6_EQ, 56 */
		/* 820A6440h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A6478;  }
		/* 820A6440h case    2:*/		return 0x820A6444;
		  /* 820A6444h */ case    3:  		/* stb R10, <#[R5 + 1]> */
		/* 820A6444h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R5 + 0x00000001) );
		/* 820A6444h case    3:*/		return 0x820A6448;
		  /* 820A6448h */ case    4:  		/* li R3, 3 */
		/* 820A6448h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 820A6448h case    4:*/		return 0x820A644C;
		  /* 820A644Ch */ case    5:  		/* lbz R11, <#[R11]> */
		/* 820A644Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A644Ch case    5:*/		return 0x820A6450;
		  /* 820A6450h */ case    6:  		/* stb R11, <#[R5 + 2]> */
		/* 820A6450h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R5 + 0x00000002) );
		/* 820A6450h case    6:*/		return 0x820A6454;
		  /* 820A6454h */ case    7:  		/* bclr 20, CR0_LT */
		/* 820A6454h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A6454h case    7:*/		return 0x820A6458;
	}
	return 0x820A6458;
} // Block from 820A6438h-820A6458h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A6458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6458);
		  /* 820A6458h */ case    0:  		/* cmplwi CR6, R11, 60 */
		/* 820A6458h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003C);
		/* 820A6458h case    0:*/		return 0x820A645C;
		  /* 820A645Ch */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 820A645Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820A6480;  }
		/* 820A645Ch case    1:*/		return 0x820A6460;
		  /* 820A6460h */ case    2:  		/* cmplwi CR6, R11, 61 */
		/* 820A6460h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003D);
		/* 820A6460h case    2:*/		return 0x820A6464;
		  /* 820A6464h */ case    3:  		/* bc 12, CR6_EQ, -132 */
		/* 820A6464h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A6464h case    3:*/		return 0x820A6468;
		  /* 820A6468h */ case    4:  		/* cmplwi CR6, R11, 62 */
		/* 820A6468h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003E);
		/* 820A6468h case    4:*/		return 0x820A646C;
		  /* 820A646Ch */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820A646Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820A6480;  }
		/* 820A646Ch case    5:*/		return 0x820A6470;
		  /* 820A6470h */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 820A6470h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 820A6470h case    6:*/		return 0x820A6474;
		  /* 820A6474h */ case    7:  		/* bc 12, CR6_EQ, -148 */
		/* 820A6474h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A6474h case    7:*/		return 0x820A6478;
	}
	return 0x820A6478;
} // Block from 820A6458h-820A6478h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A6478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6478);
		  /* 820A6478h */ case    0:  		/* li R3, 1 */
		/* 820A6478h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820A6478h case    0:*/		return 0x820A647C;
		  /* 820A647Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820A647Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A647Ch case    1:*/		return 0x820A6480;
	}
	return 0x820A6480;
} // Block from 820A6478h-820A6480h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6480);
		  /* 820A6480h */ case    0:  		/* stb R10, <#[R5 + 1]> */
		/* 820A6480h case    0:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R5 + 0x00000001) );
		/* 820A6480h case    0:*/		return 0x820A6484;
		  /* 820A6484h */ case    1:  		/* addi R11, R4, 2 */
		/* 820A6484h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x2);
		/* 820A6484h case    1:*/		return 0x820A6488;
		  /* 820A6488h */ case    2:  		/* lwz R10, <#[R3 + 8]> */
		/* 820A6488h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820A6488h case    2:*/		return 0x820A648C;
		  /* 820A648Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820A648Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A648Ch case    3:*/		return 0x820A6490;
		  /* 820A6490h */ case    4:  		/* bc 4, CR6_LT, -172 */
		/* 820A6490h case    4:*/		if ( !regs.CR[6].lt ) { return 0x820A63E4;  }
		/* 820A6490h case    4:*/		return 0x820A6494;
		  /* 820A6494h */ case    5:  		/* lbz R11, <#[R11]> */
		/* 820A6494h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6494h case    5:*/		return 0x820A6498;
		  /* 820A6498h */ case    6:  		/* cmplwi CR6, R11, 61 */
		/* 820A6498h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003D);
		/* 820A6498h case    6:*/		return 0x820A649C;
		  /* 820A649Ch */ case    7:  		/* bc 4, CR6_EQ, -184 */
		/* 820A649Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820A63E4;  }
		/* 820A649Ch case    7:*/		return 0x820A64A0;
		  /* 820A64A0h */ case    8:  		/* stb R11, <#[R5 + 2]> */
		/* 820A64A0h case    8:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R5 + 0x00000002) );
		/* 820A64A0h case    8:*/		return 0x820A64A4;
		  /* 820A64A4h */ case    9:  		/* li R3, 3 */
		/* 820A64A4h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 820A64A4h case    9:*/		return 0x820A64A8;
		  /* 820A64A8h */ case   10:  		/* bclr 20, CR0_LT */
		/* 820A64A8h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A64A8h case   10:*/		return 0x820A64AC;
	}
	return 0x820A64AC;
} // Block from 820A6480h-820A64ACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A64ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A64AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A64AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A64AC);
		  /* 820A64ACh */ case    0:  		/* cmpwi CR6, R11, 61 */
		/* 820A64ACh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000003D);
		/* 820A64ACh case    0:*/		return 0x820A64B0;
		  /* 820A64B0h */ case    1:  		/* bc 4, CR6_EQ, 100 */
		/* 820A64B0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A6514;  }
		/* 820A64B0h case    1:*/		return 0x820A64B4;
		  /* 820A64B4h */ case    2:  		/* rlwinm R11, R7, 0, 24, 31 */
		/* 820A64B4h case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R7);
		/* 820A64B4h case    2:*/		return 0x820A64B8;
		  /* 820A64B8h */ case    3:  		/* cmplwi CR6, R11, 47 */
		/* 820A64B8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002F);
		/* 820A64B8h case    3:*/		return 0x820A64BC;
		  /* 820A64BCh */ case    4:  		/* bc 12, CR6_GT, 60 */
		/* 820A64BCh case    4:*/		if ( regs.CR[6].gt ) { return 0x820A64F8;  }
		/* 820A64BCh case    4:*/		return 0x820A64C0;
		  /* 820A64C0h */ case    5:  		/* bc 12, CR6_EQ, -224 */
		/* 820A64C0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A64C0h case    5:*/		return 0x820A64C4;
		  /* 820A64C4h */ case    6:  		/* cmplwi CR6, R11, 33 */
		/* 820A64C4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000021);
		/* 820A64C4h case    6:*/		return 0x820A64C8;
		  /* 820A64C8h */ case    7:  		/* bc 12, CR6_EQ, -232 */
		/* 820A64C8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A64C8h case    7:*/		return 0x820A64CC;
		  /* 820A64CCh */ case    8:  		/* cmplwi CR6, R11, 36 */
		/* 820A64CCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000024);
		/* 820A64CCh case    8:*/		return 0x820A64D0;
		  /* 820A64D0h */ case    9:  		/* bc 4, CR6_GT, -88 */
		/* 820A64D0h case    9:*/		if ( !regs.CR[6].gt ) { return 0x820A6478;  }
		/* 820A64D0h case    9:*/		return 0x820A64D4;
		  /* 820A64D4h */ case   10:  		/* cmplwi CR6, R11, 38 */
		/* 820A64D4h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000026);
		/* 820A64D4h case   10:*/		return 0x820A64D8;
		  /* 820A64D8h */ case   11:  		/* bc 4, CR6_GT, -248 */
		/* 820A64D8h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820A63E0;  }
		/* 820A64D8h case   11:*/		return 0x820A64DC;
		  /* 820A64DCh */ case   12:  		/* cmplwi CR6, R11, 41 */
		/* 820A64DCh case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000029);
		/* 820A64DCh case   12:*/		return 0x820A64E0;
		  /* 820A64E0h */ case   13:  		/* bc 4, CR6_GT, -104 */
		/* 820A64E0h case   13:*/		if ( !regs.CR[6].gt ) { return 0x820A6478;  }
		/* 820A64E0h case   13:*/		return 0x820A64E4;
		  /* 820A64E4h */ case   14:  		/* cmplwi CR6, R11, 43 */
		/* 820A64E4h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002B);
		/* 820A64E4h case   14:*/		return 0x820A64E8;
		  /* 820A64E8h */ case   15:  		/* bc 4, CR6_GT, -264 */
		/* 820A64E8h case   15:*/		if ( !regs.CR[6].gt ) { return 0x820A63E0;  }
		/* 820A64E8h case   15:*/		return 0x820A64EC;
		  /* 820A64ECh */ case   16:  		/* cmplwi CR6, R11, 45 */
		/* 820A64ECh case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002D);
		/* 820A64ECh case   16:*/		return 0x820A64F0;
		  /* 820A64F0h */ case   17:  		/* bc 12, CR6_EQ, -272 */
		/* 820A64F0h case   17:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A64F0h case   17:*/		return 0x820A64F4;
		  /* 820A64F4h */ case   18:  		/* b -124 */
		/* 820A64F4h case   18:*/		return 0x820A6478;
		/* 820A64F4h case   18:*/		return 0x820A64F8;
	}
	return 0x820A64F8;
} // Block from 820A64ACh-820A64F8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A64F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A64F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A64F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A64F8);
		  /* 820A64F8h */ case    0:  		/* cmplwi CR6, R11, 60 */
		/* 820A64F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003C);
		/* 820A64F8h case    0:*/		return 0x820A64FC;
		  /* 820A64FCh */ case    1:  		/* bc 12, CR6_EQ, -284 */
		/* 820A64FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A64FCh case    1:*/		return 0x820A6500;
		  /* 820A6500h */ case    2:  		/* cmplwi CR6, R11, 62 */
		/* 820A6500h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003E);
		/* 820A6500h case    2:*/		return 0x820A6504;
		  /* 820A6504h */ case    3:  		/* bc 12, CR6_EQ, -292 */
		/* 820A6504h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A6504h case    3:*/		return 0x820A6508;
	}
	return 0x820A6508;
} // Block from 820A64F8h-820A6508h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A6508h
// Function 'D3DXCreateBuffer'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6508);
		  /* 820A6508h */ case    0:  		/* cmplwi CR6, R11, 94 */
		/* 820A6508h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005E);
		/* 820A6508h case    0:*/		return 0x820A650C;
		  /* 820A650Ch */ case    1:  		/* bc 12, CR6_EQ, -300 */
		/* 820A650Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820A63E0;  }
		/* 820A650Ch case    1:*/		return 0x820A6510;
	}
	return 0x820A6510;
} // Block from 820A6508h-820A6510h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6510h
// Function 'D3DXFindShaderComment'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6510);
		  /* 820A6510h */ case    0:  		/* b -160 */
		/* 820A6510h case    0:*/		return 0x820A6470;
		/* 820A6510h case    0:*/		return 0x820A6514;
	}
	return 0x820A6514;
} // Block from 820A6510h-820A6514h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6514);
		  /* 820A6514h */ case    0:  		/* cmpwi CR6, R8, 45 */
		/* 820A6514h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000002D);
		/* 820A6514h case    0:*/		return 0x820A6518;
		  /* 820A6518h */ case    1:  		/* bc 4, CR6_EQ, -160 */
		/* 820A6518h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A6478;  }
		/* 820A6518h case    1:*/		return 0x820A651C;
		  /* 820A651Ch */ case    2:  		/* cmpwi CR6, R11, 62 */
		/* 820A651Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000003E);
		/* 820A651Ch case    2:*/		return 0x820A6520;
		  /* 820A6520h */ case    3:  		/* b -172 */
		/* 820A6520h case    3:*/		return 0x820A6474;
		/* 820A6520h case    3:*/		return 0x820A6524;
		  /* 820A6524h */ case    4:  		/* nop */
		/* 820A6524h case    4:*/		cpu::op::nop();
		/* 820A6524h case    4:*/		return 0x820A6528;
	}
	return 0x820A6528;
} // Block from 820A6514h-820A6528h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A6528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6528);
		  /* 820A6528h */ case    0:  		/* mfspr R12, LR */
		/* 820A6528h case    0:*/		regs.R12 = regs.LR;
		/* 820A6528h case    0:*/		return 0x820A652C;
		  /* 820A652Ch */ case    1:  		/* bl -86740 */
		/* 820A652Ch case    1:*/		regs.LR = 0x820A6530; return 0x82091258;
		/* 820A652Ch case    1:*/		return 0x820A6530;
		  /* 820A6530h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820A6530h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820A6530h case    2:*/		return 0x820A6534;
		  /* 820A6534h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820A6534h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A6534h case    3:*/		return 0x820A6538;
		  /* 820A6538h */ case    4:  		/* mr R31, R4 */
		/* 820A6538h case    4:*/		regs.R31 = regs.R4;
		/* 820A6538h case    4:*/		return 0x820A653C;
		  /* 820A653Ch */ case    5:  		/* mr R28, R5 */
		/* 820A653Ch case    5:*/		regs.R28 = regs.R5;
		/* 820A653Ch case    5:*/		return 0x820A6540;
		  /* 820A6540h */ case    6:  		/* mr R29, R4 */
		/* 820A6540h case    6:*/		regs.R29 = regs.R4;
		/* 820A6540h case    6:*/		return 0x820A6544;
		  /* 820A6544h */ case    7:  		/* li R30, 7 */
		/* 820A6544h case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x7);
		/* 820A6544h case    7:*/		return 0x820A6548;
		  /* 820A6548h */ case    8:  		/* cmplw CR6, R4, R11 */
		/* 820A6548h case    8:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820A6548h case    8:*/		return 0x820A654C;
		  /* 820A654Ch */ case    9:  		/* bc 12, CR6_LT, 12 */
		/* 820A654Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x820A6558;  }
		/* 820A654Ch case    9:*/		return 0x820A6550;
		  /* 820A6550h */ case   10:  		/* li R3, 0 */
		/* 820A6550h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A6550h case   10:*/		return 0x820A6554;
		  /* 820A6554h */ case   11:  		/* b 80 */
		/* 820A6554h case   11:*/		return 0x820A65A4;
		/* 820A6554h case   11:*/		return 0x820A6558;
	}
	return 0x820A6558;
} // Block from 820A6528h-820A6558h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A6558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6558);
		  /* 820A6558h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820A6558h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A6558h case    0:*/		return 0x820A655C;
		  /* 820A655Ch */ case    1:  		/* extsb R3, R11 */
		/* 820A655Ch case    1:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820A655Ch case    1:*/		return 0x820A6560;
		  /* 820A6560h */ case    2:  		/* bl -52688 */
		/* 820A6560h case    2:*/		regs.LR = 0x820A6564; return 0x82099790;
		/* 820A6560h case    2:*/		return 0x820A6564;
		  /* 820A6564h */ case    3:  		/* cmpwi CR6, R3, 102 */
		/* 820A6564h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000066);
		/* 820A6564h case    3:*/		return 0x820A6568;
		  /* 820A6568h */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 820A6568h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A658C;  }
		/* 820A6568h case    4:*/		return 0x820A656C;
		  /* 820A656Ch */ case    5:  		/* cmpwi CR6, R3, 104 */
		/* 820A656Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000068);
		/* 820A656Ch case    5:*/		return 0x820A6570;
		  /* 820A6570h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 820A6570h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A6584;  }
		/* 820A6570h case    6:*/		return 0x820A6574;
		  /* 820A6574h */ case    7:  		/* cmpwi CR6, R3, 108 */
		/* 820A6574h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000006C);
		/* 820A6574h case    7:*/		return 0x820A6578;
		  /* 820A6578h */ case    8:  		/* bc 4, CR6_EQ, 28 */
		/* 820A6578h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A6594;  }
		/* 820A6578h case    8:*/		return 0x820A657C;
		  /* 820A657Ch */ case    9:  		/* li R30, 10 */
		/* 820A657Ch case    9:*/		cpu::op::li<0>(regs,&regs.R30,0xA);
		/* 820A657Ch case    9:*/		return 0x820A6580;
		  /* 820A6580h */ case   10:  		/* b 16 */
		/* 820A6580h case   10:*/		return 0x820A6590;
		/* 820A6580h case   10:*/		return 0x820A6584;
	}
	return 0x820A6584;
} // Block from 820A6558h-820A6584h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A6584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6584);
		  /* 820A6584h */ case    0:  		/* li R30, 8 */
		/* 820A6584h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x8);
		/* 820A6584h case    0:*/		return 0x820A6588;
		  /* 820A6588h */ case    1:  		/* b 8 */
		/* 820A6588h case    1:*/		return 0x820A6590;
		/* 820A6588h case    1:*/		return 0x820A658C;
	}
	return 0x820A658C;
} // Block from 820A6584h-820A658Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A658Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A658C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A658C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A658C);
		  /* 820A658Ch */ case    0:  		/* li R30, 9 */
		/* 820A658Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x9);
		/* 820A658Ch case    0:*/		return 0x820A6590;
	}
	return 0x820A6590;
} // Block from 820A658Ch-820A6590h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6590);
		  /* 820A6590h */ case    0:  		/* addi R29, R31, 1 */
		/* 820A6590h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x1);
		/* 820A6590h case    0:*/		return 0x820A6594;
	}
	return 0x820A6594;
} // Block from 820A6590h-820A6594h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6594);
		  /* 820A6594h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820A6594h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820A6594h case    0:*/		return 0x820A6598;
		  /* 820A6598h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820A6598h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A65A0;  }
		/* 820A6598h case    1:*/		return 0x820A659C;
		  /* 820A659Ch */ case    2:  		/* stw R30, <#[R28]> */
		/* 820A659Ch case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 820A659Ch case    2:*/		return 0x820A65A0;
	}
	return 0x820A65A0;
} // Block from 820A6594h-820A65A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A65A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A65A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A65A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A65A0);
		  /* 820A65A0h */ case    0:  		/* subf R3, R31, R29 */
		/* 820A65A0h case    0:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R31,regs.R29);
		/* 820A65A0h case    0:*/		return 0x820A65A4;
	}
	return 0x820A65A4;
} // Block from 820A65A0h-820A65A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A65A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A65A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A65A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A65A4);
		  /* 820A65A4h */ case    0:  		/* addi R1, R1, 128 */
		/* 820A65A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820A65A4h case    0:*/		return 0x820A65A8;
		  /* 820A65A8h */ case    1:  		/* b -86784 */
		/* 820A65A8h case    1:*/		return 0x820912A8;
		/* 820A65A8h case    1:*/		return 0x820A65AC;
		  /* 820A65ACh */ case    2:  		/* nop */
		/* 820A65ACh case    2:*/		cpu::op::nop();
		/* 820A65ACh case    2:*/		return 0x820A65B0;
	}
	return 0x820A65B0;
} // Block from 820A65A4h-820A65B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A65B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A65B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A65B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A65B0);
		  /* 820A65B0h */ case    0:  		/* mfspr R12, LR */
		/* 820A65B0h case    0:*/		regs.R12 = regs.LR;
		/* 820A65B0h case    0:*/		return 0x820A65B4;
		  /* 820A65B4h */ case    1:  		/* bl -86892 */
		/* 820A65B4h case    1:*/		regs.LR = 0x820A65B8; return 0x82091248;
		/* 820A65B4h case    1:*/		return 0x820A65B8;
		  /* 820A65B8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820A65B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820A65B8h case    2:*/		return 0x820A65BC;
		  /* 820A65BCh */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820A65BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A65BCh case    3:*/		return 0x820A65C0;
		  /* 820A65C0h */ case    4:  		/* mr R28, R3 */
		/* 820A65C0h case    4:*/		regs.R28 = regs.R3;
		/* 820A65C0h case    4:*/		return 0x820A65C4;
		  /* 820A65C4h */ case    5:  		/* mr R26, R4 */
		/* 820A65C4h case    5:*/		regs.R26 = regs.R4;
		/* 820A65C4h case    5:*/		return 0x820A65C8;
		  /* 820A65C8h */ case    6:  		/* mr R24, R5 */
		/* 820A65C8h case    6:*/		regs.R24 = regs.R5;
		/* 820A65C8h case    6:*/		return 0x820A65CC;
		  /* 820A65CCh */ case    7:  		/* mr R31, R4 */
		/* 820A65CCh case    7:*/		regs.R31 = regs.R4;
		/* 820A65CCh case    7:*/		return 0x820A65D0;
		  /* 820A65D0h */ case    8:  		/* li R27, 0 */
		/* 820A65D0h case    8:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820A65D0h case    8:*/		return 0x820A65D4;
		  /* 820A65D4h */ case    9:  		/* li R25, 0 */
		/* 820A65D4h case    9:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820A65D4h case    9:*/		return 0x820A65D8;
		  /* 820A65D8h */ case   10:  		/* li R29, 0 */
		/* 820A65D8h case   10:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820A65D8h case   10:*/		return 0x820A65DC;
		  /* 820A65DCh */ case   11:  		/* cmplw CR6, R4, R11 */
		/* 820A65DCh case   11:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820A65DCh case   11:*/		return 0x820A65E0;
		  /* 820A65E0h */ case   12:  		/* bc 4, CR6_LT, 188 */
		/* 820A65E0h case   12:*/		if ( !regs.CR[6].lt ) { return 0x820A669C;  }
		/* 820A65E0h case   12:*/		return 0x820A65E4;
		  /* 820A65E4h */ case   13:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 820A65E4h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 820A65E4h case   13:*/		return 0x820A65E8;
		  /* 820A65E8h */ case   14:  		/* bc 4, CR0_EQ, 44 */
		/* 820A65E8h case   14:*/		if ( !regs.CR[0].eq ) { return 0x820A6614;  }
		/* 820A65E8h case   14:*/		return 0x820A65EC;
		  /* 820A65ECh */ case   15:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 820A65ECh case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 820A65ECh case   15:*/		return 0x820A65F0;
		  /* 820A65F0h */ case   16:  		/* bc 4, CR0_EQ, 36 */
		/* 820A65F0h case   16:*/		if ( !regs.CR[0].eq ) { return 0x820A6614;  }
		/* 820A65F0h case   16:*/		return 0x820A65F4;
		  /* 820A65F4h */ case   17:  		/* lbz R11, <#[R31]> */
		/* 820A65F4h case   17:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A65F4h case   17:*/		return 0x820A65F8;
		  /* 820A65F8h */ case   18:  		/* extsb R3, R11 */
		/* 820A65F8h case   18:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820A65F8h case   18:*/		return 0x820A65FC;
		  /* 820A65FCh */ case   19:  		/* bl -52844 */
		/* 820A65FCh case   19:*/		regs.LR = 0x820A6600; return 0x82099790;
		/* 820A65FCh case   19:*/		return 0x820A6600;
		  /* 820A6600h */ case   20:  		/* cmpwi CR6, R3, 117 */
		/* 820A6600h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000075);
		/* 820A6600h case   20:*/		return 0x820A6604;
		  /* 820A6604h */ case   21:  		/* bc 4, CR6_EQ, 16 */
		/* 820A6604h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820A6614;  }
		/* 820A6604h case   21:*/		return 0x820A6608;
		  /* 820A6608h */ case   22:  		/* li R27, 1 */
		/* 820A6608h case   22:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820A6608h case   22:*/		return 0x820A660C;
		  /* 820A660Ch */ case   23:  		/* addi R31, R31, 1 */
		/* 820A660Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A660Ch case   23:*/		return 0x820A6610;
		  /* 820A6610h */ case   24:  		/* b 128 */
		/* 820A6610h case   24:*/		return 0x820A6690;
		/* 820A6610h case   24:*/		return 0x820A6614;
	}
	return 0x820A6614;
} // Block from 820A65B0h-820A6614h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820A6614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6614);
		  /* 820A6614h */ case    0:  		/* rlwinm. R30, R25, 0, 24, 31 */
		/* 820A6614h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R30,regs.R25);
		/* 820A6614h case    0:*/		return 0x820A6618;
		  /* 820A6618h */ case    1:  		/* bc 4, CR0_EQ, 40 */
		/* 820A6618h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A6640;  }
		/* 820A6618h case    1:*/		return 0x820A661C;
		  /* 820A661Ch */ case    2:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 820A661Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 820A661Ch case    2:*/		return 0x820A6620;
		  /* 820A6620h */ case    3:  		/* bc 4, CR0_EQ, 32 */
		/* 820A6620h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820A6640;  }
		/* 820A6620h case    3:*/		return 0x820A6624;
		  /* 820A6624h */ case    4:  		/* lbz R11, <#[R31]> */
		/* 820A6624h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A6624h case    4:*/		return 0x820A6628;
		  /* 820A6628h */ case    5:  		/* extsb R3, R11 */
		/* 820A6628h case    5:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820A6628h case    5:*/		return 0x820A662C;
		  /* 820A662Ch */ case    6:  		/* bl -52892 */
		/* 820A662Ch case    6:*/		regs.LR = 0x820A6630; return 0x82099790;
		/* 820A662Ch case    6:*/		return 0x820A6630;
		  /* 820A6630h */ case    7:  		/* cmpwi CR6, R3, 108 */
		/* 820A6630h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000006C);
		/* 820A6630h case    7:*/		return 0x820A6634;
		  /* 820A6634h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 820A6634h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A6640;  }
		/* 820A6634h case    8:*/		return 0x820A6638;
		  /* 820A6638h */ case    9:  		/* li R25, 1 */
		/* 820A6638h case    9:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820A6638h case    9:*/		return 0x820A663C;
		  /* 820A663Ch */ case   10:  		/* b -48 */
		/* 820A663Ch case   10:*/		return 0x820A660C;
		/* 820A663Ch case   10:*/		return 0x820A6640;
	}
	return 0x820A6640;
} // Block from 820A6614h-820A6640h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A6640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6640);
		  /* 820A6640h */ case    0:  		/* rlwinm R11, R29, 0, 24, 31 */
		/* 820A6640h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R29);
		/* 820A6640h case    0:*/		return 0x820A6644;
		  /* 820A6644h */ case    1:  		/* cntlzw R10, R30 */
		/* 820A6644h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R30);
		/* 820A6644h case    1:*/		return 0x820A6648;
		  /* 820A6648h */ case    2:  		/* cntlzw R11, R11 */
		/* 820A6648h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820A6648h case    2:*/		return 0x820A664C;
		  /* 820A664Ch */ case    3:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 820A664Ch case    3:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 820A664Ch case    3:*/		return 0x820A6650;
		  /* 820A6650h */ case    4:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 820A6650h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820A6650h case    4:*/		return 0x820A6654;
		  /* 820A6654h */ case    5:  		/* and. R11, R11, R10 */
		/* 820A6654h case    5:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A6654h case    5:*/		return 0x820A6658;
	}
	return 0x820A6658;
} // Block from 820A6640h-820A6658h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A6658h
// Function '??0CTErrors@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6658);
		  /* 820A6658h */ case    0:  		/* bc 12, CR0_EQ, 68 */
		/* 820A6658h case    0:*/		if ( regs.CR[0].eq ) { return 0x820A669C;  }
		/* 820A6658h case    0:*/		return 0x820A665C;
		  /* 820A665Ch */ case    1:  		/* lbz R11, <#[R31]> */
		/* 820A665Ch case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A665Ch case    1:*/		return 0x820A6660;
		  /* 820A6660h */ case    2:  		/* extsb R3, R11 */
		/* 820A6660h case    2:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820A6660h case    2:*/		return 0x820A6664;
		  /* 820A6664h */ case    3:  		/* bl -52948 */
		/* 820A6664h case    3:*/		regs.LR = 0x820A6668; return 0x82099790;
		/* 820A6664h case    3:*/		return 0x820A6668;
		  /* 820A6668h */ case    4:  		/* cmpwi CR6, R3, 105 */
		/* 820A6668h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000069);
		/* 820A6668h case    4:*/		return 0x820A666C;
		  /* 820A666Ch */ case    5:  		/* bc 4, CR6_EQ, 48 */
		/* 820A666Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A669C;  }
		/* 820A666Ch case    5:*/		return 0x820A6670;
		  /* 820A6670h */ case    6:  		/* lbz R11, <#[R31 + 1]> */
		/* 820A6670h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		/* 820A6670h case    6:*/		return 0x820A6674;
		  /* 820A6674h */ case    7:  		/* cmplwi CR6, R11, 54 */
		/* 820A6674h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000036);
		/* 820A6674h case    7:*/		return 0x820A6678;
		  /* 820A6678h */ case    8:  		/* bc 4, CR6_EQ, 36 */
		/* 820A6678h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A669C;  }
		/* 820A6678h case    8:*/		return 0x820A667C;
		  /* 820A667Ch */ case    9:  		/* lbz R11, <#[R31 + 2]> */
		/* 820A667Ch case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000002) );
		/* 820A667Ch case    9:*/		return 0x820A6680;
		  /* 820A6680h */ case   10:  		/* cmplwi CR6, R11, 52 */
		/* 820A6680h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000034);
		/* 820A6680h case   10:*/		return 0x820A6684;
		  /* 820A6684h */ case   11:  		/* bc 4, CR6_EQ, 24 */
		/* 820A6684h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820A669C;  }
		/* 820A6684h case   11:*/		return 0x820A6688;
		  /* 820A6688h */ case   12:  		/* li R29, 1 */
		/* 820A6688h case   12:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820A6688h case   12:*/		return 0x820A668C;
		  /* 820A668Ch */ case   13:  		/* addi R31, R31, 3 */
		/* 820A668Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x3);
		/* 820A668Ch case   13:*/		return 0x820A6690;
	}
	return 0x820A6690;
} // Block from 820A6658h-820A6690h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A6690h
// Function '?GetErrorBuffer@CTErrors@D3DXShader@@QAAJPAPAUID3DXBuffer@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6690);
		  /* 820A6690h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A6690h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A6690h case    0:*/		return 0x820A6694;
		  /* 820A6694h */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 820A6694h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820A6694h case    1:*/		return 0x820A6698;
		  /* 820A6698h */ case    2:  		/* bc 12, CR6_LT, -180 */
		/* 820A6698h case    2:*/		if ( regs.CR[6].lt ) { return 0x820A65E4;  }
		/* 820A6698h case    2:*/		return 0x820A669C;
	}
	return 0x820A669C;
} // Block from 820A6690h-820A669Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A669Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A669C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A669C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A669C);
		  /* 820A669Ch */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 820A669Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820A669Ch case    0:*/		return 0x820A66A0;
		  /* 820A66A0h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 820A66A0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A66E4;  }
		/* 820A66A0h case    1:*/		return 0x820A66A4;
		  /* 820A66A4h */ case    2:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 820A66A4h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 820A66A4h case    2:*/		return 0x820A66A8;
		  /* 820A66A8h */ case    3:  		/* bc 12, CR0_EQ, 28 */
		/* 820A66A8h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A66C4;  }
		/* 820A66A8h case    3:*/		return 0x820A66AC;
		  /* 820A66ACh */ case    4:  		/* rlwinm R11, R27, 0, 24, 31 */
		/* 820A66ACh case    4:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R27);
		/* 820A66ACh case    4:*/		return 0x820A66B0;
		  /* 820A66B0h */ case    5:  		/* cntlzw R11, R11 */
		/* 820A66B0h case    5:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820A66B0h case    5:*/		return 0x820A66B4;
		  /* 820A66B4h */ case    6:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 820A66B4h case    6:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820A66B4h case    6:*/		return 0x820A66B8;
		  /* 820A66B8h */ case    7:  		/* xori R11, R11, 1 */
		/* 820A66B8h case    7:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A66B8h case    7:*/		return 0x820A66BC;
		  /* 820A66BCh */ case    8:  		/* addi R11, R11, 3 */
		/* 820A66BCh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820A66BCh case    8:*/		return 0x820A66C0;
		  /* 820A66C0h */ case    9:  		/* b 32 */
		/* 820A66C0h case    9:*/		return 0x820A66E0;
		/* 820A66C0h case    9:*/		return 0x820A66C4;
	}
	return 0x820A66C4;
} // Block from 820A669Ch-820A66C4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A66C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A66C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A66C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A66C4);
		  /* 820A66C4h */ case    0:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 820A66C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 820A66C4h case    0:*/		return 0x820A66C8;
		  /* 820A66C8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820A66C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A66D4;  }
		/* 820A66C8h case    1:*/		return 0x820A66CC;
		  /* 820A66CCh */ case    2:  		/* li R11, 4 */
		/* 820A66CCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820A66CCh case    2:*/		return 0x820A66D0;
		  /* 820A66D0h */ case    3:  		/* b 16 */
		/* 820A66D0h case    3:*/		return 0x820A66E0;
		/* 820A66D0h case    3:*/		return 0x820A66D4;
	}
	return 0x820A66D4;
} // Block from 820A66C4h-820A66D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A66D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A66D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A66D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A66D4);
		  /* 820A66D4h */ case    0:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 820A66D4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 820A66D4h case    0:*/		return 0x820A66D8;
		  /* 820A66D8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820A66D8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A66E4;  }
		/* 820A66D8h case    1:*/		return 0x820A66DC;
		  /* 820A66DCh */ case    2:  		/* li R11, 3 */
		/* 820A66DCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820A66DCh case    2:*/		return 0x820A66E0;
	}
	return 0x820A66E0;
} // Block from 820A66D4h-820A66E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A66E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A66E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A66E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A66E0);
		  /* 820A66E0h */ case    0:  		/* stw R11, <#[R24]> */
		/* 820A66E0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 820A66E0h case    0:*/		return 0x820A66E4;
	}
	return 0x820A66E4;
} // Block from 820A66E0h-820A66E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A66E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A66E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A66E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A66E4);
		  /* 820A66E4h */ case    0:  		/* subf R3, R26, R31 */
		/* 820A66E4h case    0:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R26,regs.R31);
		/* 820A66E4h case    0:*/		return 0x820A66E8;
		  /* 820A66E8h */ case    1:  		/* addi R1, R1, 160 */
		/* 820A66E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820A66E8h case    1:*/		return 0x820A66EC;
		  /* 820A66ECh */ case    2:  		/* b -87124 */
		/* 820A66ECh case    2:*/		return 0x82091298;
		/* 820A66ECh case    2:*/		return 0x820A66F0;
		  /* 820A66F0h */ case    3:  		/* mr R11, R3 */
		/* 820A66F0h case    3:*/		regs.R11 = regs.R3;
		/* 820A66F0h case    3:*/		return 0x820A66F4;
		  /* 820A66F4h */ case    4:  		/* li R3, 0 */
		/* 820A66F4h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A66F4h case    4:*/		return 0x820A66F8;
		  /* 820A66F8h */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 820A66F8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A66F8h case    5:*/		return 0x820A66FC;
		  /* 820A66FCh */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820A66FCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A670C;  }
		/* 820A66FCh case    6:*/		return 0x820A6700;
		  /* 820A6700h */ case    7:  		/* lis R3, -32761 */
		/* 820A6700h case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A6700h case    7:*/		return 0x820A6704;
		  /* 820A6704h */ case    8:  		/* ori R3, R3, 87 */
		/* 820A6704h case    8:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x57);
		/* 820A6704h case    8:*/		return 0x820A6708;
		  /* 820A6708h */ case    9:  		/* bclr 20, CR0_LT */
		/* 820A6708h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A6708h case    9:*/		return 0x820A670C;
	}
	return 0x820A670C;
} // Block from 820A66E4h-820A670Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A670Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A670C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A670C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A670C);
		  /* 820A670Ch */ case    0:  		/* subf R9, R11, R5 */
		/* 820A670Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R5);
		/* 820A670Ch case    0:*/		return 0x820A6710;
		  /* 820A6710h */ case    1:  		/* lbzx R10, <#[R9 + R11]> */
		/* 820A6710h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820A6710h case    1:*/		return 0x820A6714;
		  /* 820A6714h */ case    2:  		/* cmplwi CR0, R10, 0 */
		/* 820A6714h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820A6714h case    2:*/		return 0x820A6718;
		  /* 820A6718h */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 820A6718h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A672C;  }
		/* 820A6718h case    3:*/		return 0x820A671C;
		  /* 820A671Ch */ case    4:  		/* stb R10, <#[R11]> */
		/* 820A671Ch case    4:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A671Ch case    4:*/		return 0x820A6720;
		  /* 820A6720h */ case    5:  		/* addic. R4, R4, -1 */
		/* 820A6720h case    5:*/		cpu::op::addic<1>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 820A6720h case    5:*/		return 0x820A6724;
		  /* 820A6724h */ case    6:  		/* addi R11, R11, 1 */
		/* 820A6724h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A6724h case    6:*/		return 0x820A6728;
		  /* 820A6728h */ case    7:  		/* bc 4, CR0_EQ, -24 */
		/* 820A6728h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820A6710;  }
		/* 820A6728h case    7:*/		return 0x820A672C;
	}
	return 0x820A672C;
} // Block from 820A670Ch-820A672Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A672Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A672C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A672C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A672C);
		  /* 820A672Ch */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820A672Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A672Ch case    0:*/		return 0x820A6730;
		  /* 820A6730h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A6730h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A6740;  }
		/* 820A6730h case    1:*/		return 0x820A6734;
		  /* 820A6734h */ case    2:  		/* lis R3, -32761 */
		/* 820A6734h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A6734h case    2:*/		return 0x820A6738;
		  /* 820A6738h */ case    3:  		/* addi R11, R11, -1 */
		/* 820A6738h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A6738h case    3:*/		return 0x820A673C;
		  /* 820A673Ch */ case    4:  		/* ori R3, R3, 122 */
		/* 820A673Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x7A);
		/* 820A673Ch case    4:*/		return 0x820A6740;
	}
	return 0x820A6740;
} // Block from 820A672Ch-820A6740h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A6740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6740);
		  /* 820A6740h */ case    0:  		/* li R10, 0 */
		/* 820A6740h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A6740h case    0:*/		return 0x820A6744;
		  /* 820A6744h */ case    1:  		/* stb R10, <#[R11]> */
		/* 820A6744h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6744h case    1:*/		return 0x820A6748;
	}
	return 0x820A6748;
} // Block from 820A6740h-820A6748h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6748h
// Function '?GetErrorCount@CTErrors@D3DXShader@@QAAIXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6748);
		  /* 820A6748h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820A6748h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A6748h case    0:*/		return 0x820A674C;
	}
	return 0x820A674C;
} // Block from 820A6748h-820A674Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A674Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A674C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A674C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A674C);
		  /* 820A674Ch */ case    0:  		/* nop */
		/* 820A674Ch case    0:*/		cpu::op::nop();
		/* 820A674Ch case    0:*/		return 0x820A6750;
	}
	return 0x820A6750;
} // Block from 820A674Ch-820A6750h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6750h
// Function '??0CTokStringTable@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6750);
		  /* 820A6750h */ case    0:  		/* mr R11, R3 */
		/* 820A6750h case    0:*/		regs.R11 = regs.R3;
		/* 820A6750h case    0:*/		return 0x820A6754;
		  /* 820A6754h */ case    1:  		/* mr R10, R6 */
		/* 820A6754h case    1:*/		regs.R10 = regs.R6;
		/* 820A6754h case    1:*/		return 0x820A6758;
		  /* 820A6758h */ case    2:  		/* li R3, 0 */
		/* 820A6758h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A6758h case    2:*/		return 0x820A675C;
		  /* 820A675Ch */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 820A675Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A675Ch case    3:*/		return 0x820A6760;
		  /* 820A6760h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 820A6760h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A6770;  }
		/* 820A6760h case    4:*/		return 0x820A6764;
		  /* 820A6764h */ case    5:  		/* lis R3, -32761 */
		/* 820A6764h case    5:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A6764h case    5:*/		return 0x820A6768;
		  /* 820A6768h */ case    6:  		/* ori R3, R3, 87 */
		/* 820A6768h case    6:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x57);
		/* 820A6768h case    6:*/		return 0x820A676C;
		  /* 820A676Ch */ case    7:  		/* bclr 20, CR0_LT */
		/* 820A676Ch case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A676Ch case    7:*/		return 0x820A6770;
	}
	return 0x820A6770;
} // Block from 820A6750h-820A6770h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A6770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6770);
		  /* 820A6770h */ case    0:  		/* subf R8, R11, R5 */
		/* 820A6770h case    0:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R5);
		/* 820A6770h case    0:*/		return 0x820A6774;
		  /* 820A6774h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820A6774h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A6774h case    1:*/		return 0x820A6778;
		  /* 820A6778h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820A6778h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A679C;  }
		/* 820A6778h case    2:*/		return 0x820A677C;
		  /* 820A677Ch */ case    3:  		/* lbzx R9, <#[R8 + R11]> */
		/* 820A677Ch case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820A677Ch case    3:*/		return 0x820A6780;
		  /* 820A6780h */ case    4:  		/* cmplwi CR0, R9, 0 */
		/* 820A6780h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820A6780h case    4:*/		return 0x820A6784;
		  /* 820A6784h */ case    5:  		/* bc 12, CR0_EQ, 24 */
		/* 820A6784h case    5:*/		if ( regs.CR[0].eq ) { return 0x820A679C;  }
		/* 820A6784h case    5:*/		return 0x820A6788;
	}
	return 0x820A6788;
} // Block from 820A6770h-820A6788h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A6788h
// Function '?ComputeHash@D3DXShader@@YAIPAEI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6788);
		  /* 820A6788h */ case    0:  		/* stb R9, <#[R11]> */
		/* 820A6788h case    0:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6788h case    0:*/		return 0x820A678C;
		  /* 820A678Ch */ case    1:  		/* addic. R4, R4, -1 */
		/* 820A678Ch case    1:*/		cpu::op::addic<1>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 820A678Ch case    1:*/		return 0x820A6790;
		  /* 820A6790h */ case    2:  		/* addi R11, R11, 1 */
		/* 820A6790h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A6790h case    2:*/		return 0x820A6794;
		  /* 820A6794h */ case    3:  		/* addi R10, R10, -1 */
		/* 820A6794h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820A6794h case    3:*/		return 0x820A6798;
		  /* 820A6798h */ case    4:  		/* bc 4, CR0_EQ, -36 */
		/* 820A6798h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820A6774;  }
		/* 820A6798h case    4:*/		return 0x820A679C;
	}
	return 0x820A679C;
} // Block from 820A6788h-820A679Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A679Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A679C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A679C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A679C);
		  /* 820A679Ch */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820A679Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A679Ch case    0:*/		return 0x820A67A0;
		  /* 820A67A0h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820A67A0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A67B0;  }
		/* 820A67A0h case    1:*/		return 0x820A67A4;
		  /* 820A67A4h */ case    2:  		/* lis R3, -32761 */
		/* 820A67A4h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A67A4h case    2:*/		return 0x820A67A8;
		  /* 820A67A8h */ case    3:  		/* addi R11, R11, -1 */
		/* 820A67A8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A67A8h case    3:*/		return 0x820A67AC;
		  /* 820A67ACh */ case    4:  		/* ori R3, R3, 122 */
		/* 820A67ACh case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x7A);
		/* 820A67ACh case    4:*/		return 0x820A67B0;
	}
	return 0x820A67B0;
} // Block from 820A679Ch-820A67B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A67B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A67B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A67B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A67B0);
		  /* 820A67B0h */ case    0:  		/* li R10, 0 */
		/* 820A67B0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A67B0h case    0:*/		return 0x820A67B4;
		  /* 820A67B4h */ case    1:  		/* stb R10, <#[R11]> */
		/* 820A67B4h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A67B4h case    1:*/		return 0x820A67B8;
		  /* 820A67B8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820A67B8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A67B8h case    2:*/		return 0x820A67BC;
	}
	return 0x820A67BC;
} // Block from 820A67B0h-820A67BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A67BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A67BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A67BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A67BC);
		  /* 820A67BCh */ case    0:  		/* nop */
		/* 820A67BCh case    0:*/		cpu::op::nop();
		/* 820A67BCh case    0:*/		return 0x820A67C0;
	}
	return 0x820A67C0;
} // Block from 820A67BCh-820A67C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A67C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A67C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A67C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A67C0);
		  /* 820A67C0h */ case    0:  		/* mfspr R12, LR */
		/* 820A67C0h case    0:*/		regs.R12 = regs.LR;
		/* 820A67C0h case    0:*/		return 0x820A67C4;
		  /* 820A67C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A67C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A67C4h case    1:*/		return 0x820A67C8;
		  /* 820A67C8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A67C8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A67C8h case    2:*/		return 0x820A67CC;
		  /* 820A67CCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A67CCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A67CCh case    3:*/		return 0x820A67D0;
		  /* 820A67D0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A67D0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A67D0h case    4:*/		return 0x820A67D4;
		  /* 820A67D4h */ case    5:  		/* mr R31, R3 */
		/* 820A67D4h case    5:*/		regs.R31 = regs.R3;
		/* 820A67D4h case    5:*/		return 0x820A67D8;
		  /* 820A67D8h */ case    6:  		/* b 20 */
		/* 820A67D8h case    6:*/		return 0x820A67EC;
		/* 820A67D8h case    6:*/		return 0x820A67DC;
		  /* 820A67DCh */ case    7:  		/* lwz R3, <#[R31 + 20]> */
		/* 820A67DCh case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820A67DCh case    7:*/		return 0x820A67E0;
		  /* 820A67E0h */ case    8:  		/* lwz R30, <#[R3]> */
		/* 820A67E0h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 820A67E0h case    8:*/		return 0x820A67E4;
		  /* 820A67E4h */ case    9:  		/* bl -124076 */
		/* 820A67E4h case    9:*/		regs.LR = 0x820A67E8; return 0x82088338;
		/* 820A67E4h case    9:*/		return 0x820A67E8;
		  /* 820A67E8h */ case   10:  		/* stw R30, <#[R31 + 20]> */
		/* 820A67E8h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 820A67E8h case   10:*/		return 0x820A67EC;
	}
	return 0x820A67EC;
} // Block from 820A67C0h-820A67ECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A67ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A67EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A67EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A67EC);
		  /* 820A67ECh */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820A67ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820A67ECh case    0:*/		return 0x820A67F0;
		  /* 820A67F0h */ case    1:  		/* lis R4, 9345 */
		/* 820A67F0h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A67F0h case    1:*/		return 0x820A67F4;
		  /* 820A67F4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820A67F4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A67F4h case    2:*/		return 0x820A67F8;
		  /* 820A67F8h */ case    3:  		/* bc 4, CR6_EQ, -28 */
		/* 820A67F8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A67DC;  }
		/* 820A67F8h case    3:*/		return 0x820A67FC;
		  /* 820A67FCh */ case    4:  		/* lwz R3, <#[R31 + 4]> */
		/* 820A67FCh case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820A67FCh case    4:*/		return 0x820A6800;
		  /* 820A6800h */ case    5:  		/* bl -124104 */
		/* 820A6800h case    5:*/		regs.LR = 0x820A6804; return 0x82088338;
		/* 820A6800h case    5:*/		return 0x820A6804;
		  /* 820A6804h */ case    6:  		/* lis R4, 9345 */
		/* 820A6804h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A6804h case    6:*/		return 0x820A6808;
		  /* 820A6808h */ case    7:  		/* lwz R3, <#[R31 + 8]> */
		/* 820A6808h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820A6808h case    7:*/		return 0x820A680C;
		  /* 820A680Ch */ case    8:  		/* bl -124116 */
		/* 820A680Ch case    8:*/		regs.LR = 0x820A6810; return 0x82088338;
		/* 820A680Ch case    8:*/		return 0x820A6810;
		  /* 820A6810h */ case    9:  		/* addi R1, R1, 112 */
		/* 820A6810h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A6810h case    9:*/		return 0x820A6814;
		  /* 820A6814h */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A6814h case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A6814h case   10:*/		return 0x820A6818;
		  /* 820A6818h */ case   11:  		/* mtspr LR, R12 */
		/* 820A6818h case   11:*/		regs.LR = regs.R12;
		/* 820A6818h case   11:*/		return 0x820A681C;
		  /* 820A681Ch */ case   12:  		/* ld R30, <#[R1 - 24]> */
		/* 820A681Ch case   12:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A681Ch case   12:*/		return 0x820A6820;
		  /* 820A6820h */ case   13:  		/* ld R31, <#[R1 - 16]> */
		/* 820A6820h case   13:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A6820h case   13:*/		return 0x820A6824;
		  /* 820A6824h */ case   14:  		/* bclr 20, CR0_LT */
		/* 820A6824h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A6824h case   14:*/		return 0x820A6828;
	}
	return 0x820A6828;
} // Block from 820A67ECh-820A6828h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A6828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6828);
		  /* 820A6828h */ case    0:  		/* mfspr R12, LR */
		/* 820A6828h case    0:*/		regs.R12 = regs.LR;
		/* 820A6828h case    0:*/		return 0x820A682C;
		  /* 820A682Ch */ case    1:  		/* bl -87516 */
		/* 820A682Ch case    1:*/		regs.LR = 0x820A6830; return 0x82091250;
		/* 820A682Ch case    1:*/		return 0x820A6830;
		  /* 820A6830h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820A6830h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820A6830h case    2:*/		return 0x820A6834;
		  /* 820A6834h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820A6834h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A6834h case    3:*/		return 0x820A6838;
		  /* 820A6838h */ case    4:  		/* mr R31, R3 */
		/* 820A6838h case    4:*/		regs.R31 = regs.R3;
		/* 820A6838h case    4:*/		return 0x820A683C;
		  /* 820A683Ch */ case    5:  		/* mr R28, R4 */
		/* 820A683Ch case    5:*/		regs.R28 = regs.R4;
		/* 820A683Ch case    5:*/		return 0x820A6840;
		  /* 820A6840h */ case    6:  		/* mr R27, R5 */
		/* 820A6840h case    6:*/		regs.R27 = regs.R5;
		/* 820A6840h case    6:*/		return 0x820A6844;
		  /* 820A6844h */ case    7:  		/* li R26, 0 */
		/* 820A6844h case    7:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820A6844h case    7:*/		return 0x820A6848;
		  /* 820A6848h */ case    8:  		/* li R8, 0 */
		/* 820A6848h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820A6848h case    8:*/		return 0x820A684C;
		  /* 820A684Ch */ case    9:  		/* mr R9, R11 */
		/* 820A684Ch case    9:*/		regs.R9 = regs.R11;
		/* 820A684Ch case    9:*/		return 0x820A6850;
		  /* 820A6850h */ case   10:  		/* rlwinm R29, R11, 31, 1, 31 */
		/* 820A6850h case   10:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R29,regs.R11);
		/* 820A6850h case   10:*/		return 0x820A6854;
		  /* 820A6854h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 820A6854h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A6854h case   11:*/		return 0x820A6858;
		  /* 820A6858h */ case   12:  		/* bc 12, CR0_EQ, 64 */
		/* 820A6858h case   12:*/		if ( regs.CR[0].eq ) { return 0x820A6898;  }
		/* 820A6858h case   12:*/		return 0x820A685C;
		  /* 820A685Ch */ case   13:  		/* lwz R7, <#[R3 + 4]> */
		/* 820A685Ch case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 820A685Ch case   13:*/		return 0x820A6860;
		  /* 820A6860h */ case   14:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 820A6860h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 820A6860h case   14:*/		return 0x820A6864;
		  /* 820A6864h */ case   15:  		/* lwzx R10, <#[R10 + R7]> */
		/* 820A6864h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 820A6864h case   15:*/		return 0x820A6868;
		  /* 820A6868h */ case   16:  		/* cmplw CR6, R28, R10 */
		/* 820A6868h case   16:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 820A6868h case   16:*/		return 0x820A686C;
		  /* 820A686Ch */ case   17:  		/* bc 4, CR6_GT, 12 */
		/* 820A686Ch case   17:*/		if ( !regs.CR[6].gt ) { return 0x820A6878;  }
		/* 820A686Ch case   17:*/		return 0x820A6870;
		  /* 820A6870h */ case   18:  		/* addi R8, R29, 1 */
		/* 820A6870h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R29,0x1);
		/* 820A6870h case   18:*/		return 0x820A6874;
		  /* 820A6874h */ case   19:  		/* b 12 */
		/* 820A6874h case   19:*/		return 0x820A6880;
		/* 820A6874h case   19:*/		return 0x820A6878;
	}
	return 0x820A6878;
} // Block from 820A6828h-820A6878h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A6878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6878);
		  /* 820A6878h */ case    0:  		/* bc 4, CR6_LT, 24 */
		/* 820A6878h case    0:*/		if ( !regs.CR[6].lt ) { return 0x820A6890;  }
		/* 820A6878h case    0:*/		return 0x820A687C;
		  /* 820A687Ch */ case    1:  		/* mr R9, R29 */
		/* 820A687Ch case    1:*/		regs.R9 = regs.R29;
		/* 820A687Ch case    1:*/		return 0x820A6880;
	}
	return 0x820A6880;
} // Block from 820A6878h-820A6880h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6880);
		  /* 820A6880h */ case    0:  		/* add R10, R9, R8 */
		/* 820A6880h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R8);
		/* 820A6880h case    0:*/		return 0x820A6884;
		  /* 820A6884h */ case    1:  		/* cmplw CR6, R8, R9 */
		/* 820A6884h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820A6884h case    1:*/		return 0x820A6888;
		  /* 820A6888h */ case    2:  		/* rlwinm R29, R10, 31, 1, 31 */
		/* 820A6888h case    2:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R29,regs.R10);
		/* 820A6888h case    2:*/		return 0x820A688C;
		  /* 820A688Ch */ case    3:  		/* bc 12, CR6_LT, -44 */
		/* 820A688Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820A6860;  }
		/* 820A688Ch case    3:*/		return 0x820A6890;
	}
	return 0x820A6890;
} // Block from 820A6880h-820A6890h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A6890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6890);
		  /* 820A6890h */ case    0:  		/* cmplw CR6, R8, R9 */
		/* 820A6890h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820A6890h case    0:*/		return 0x820A6894;
		  /* 820A6894h */ case    1:  		/* bc 12, CR6_LT, 284 */
		/* 820A6894h case    1:*/		if ( regs.CR[6].lt ) { return 0x820A69B0;  }
		/* 820A6894h case    1:*/		return 0x820A6898;
	}
	return 0x820A6898;
} // Block from 820A6890h-820A6898h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6898);
		  /* 820A6898h */ case    0:  		/* nor R10, R11, R11 */
		/* 820A6898h case    0:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 820A6898h case    0:*/		return 0x820A689C;
		  /* 820A689Ch */ case    1:  		/* addi R10, R10, 1 */
		/* 820A689Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A689Ch case    1:*/		return 0x820A68A0;
		  /* 820A68A0h */ case    2:  		/* and R10, R10, R11 */
		/* 820A68A0h case    2:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820A68A0h case    2:*/		return 0x820A68A4;
		  /* 820A68A4h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820A68A4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A68A4h case    3:*/		return 0x820A68A8;
		  /* 820A68A8h */ case    4:  		/* bc 4, CR6_EQ, 164 */
		/* 820A68A8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A694C;  }
		/* 820A68A8h case    4:*/		return 0x820A68AC;
		  /* 820A68ACh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820A68ACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A68ACh case    5:*/		return 0x820A68B0;
		  /* 820A68B0h */ case    6:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 820A68B0h case    6:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 820A68B0h case    6:*/		return 0x820A68B4;
		  /* 820A68B4h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 820A68B4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820A68BC;  }
		/* 820A68B4h case    7:*/		return 0x820A68B8;
		  /* 820A68B8h */ case    8:  		/* li R11, 1 */
		/* 820A68B8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A68B8h case    8:*/		return 0x820A68BC;
	}
	return 0x820A68BC;
} // Block from 820A6898h-820A68BCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A68BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A68BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A68BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A68BC);
		  /* 820A68BCh */ case    0:  		/* lis R4, 9345 */
		/* 820A68BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A68BCh case    0:*/		return 0x820A68C0;
		  /* 820A68C0h */ case    1:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820A68C0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820A68C0h case    1:*/		return 0x820A68C4;
		  /* 820A68C4h */ case    2:  		/* bl -124612 */
		/* 820A68C4h case    2:*/		regs.LR = 0x820A68C8; return 0x82088200;
		/* 820A68C4h case    2:*/		return 0x820A68C8;
		  /* 820A68C8h */ case    3:  		/* or. R30, R3, R3 */
		/* 820A68C8h case    3:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A68C8h case    3:*/		return 0x820A68CC;
		  /* 820A68CCh */ case    4:  		/* bc 12, CR0_EQ, 80 */
		/* 820A68CCh case    4:*/		if ( regs.CR[0].eq ) { return 0x820A691C;  }
		/* 820A68CCh case    4:*/		return 0x820A68D0;
		  /* 820A68D0h */ case    5:  		/* lwz R11, <#[R31]> */
		/* 820A68D0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A68D0h case    5:*/		return 0x820A68D4;
		  /* 820A68D4h */ case    6:  		/* mr R3, R30 */
		/* 820A68D4h case    6:*/		regs.R3 = regs.R30;
		/* 820A68D4h case    6:*/		return 0x820A68D8;
		  /* 820A68D8h */ case    7:  		/* lwz R4, <#[R31 + 8]> */
		/* 820A68D8h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 820A68D8h case    7:*/		return 0x820A68DC;
		  /* 820A68DCh */ case    8:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820A68DCh case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820A68DCh case    8:*/		return 0x820A68E0;
		  /* 820A68E0h */ case    9:  		/* bl -85808 */
		/* 820A68E0h case    9:*/		regs.LR = 0x820A68E4; return 0x820919B0;
		/* 820A68E0h case    9:*/		return 0x820A68E4;
		  /* 820A68E4h */ case   10:  		/* lis R4, 9345 */
		/* 820A68E4h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A68E4h case   10:*/		return 0x820A68E8;
		  /* 820A68E8h */ case   11:  		/* lwz R3, <#[R31 + 8]> */
		/* 820A68E8h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820A68E8h case   11:*/		return 0x820A68EC;
		  /* 820A68ECh */ case   12:  		/* bl -124340 */
		/* 820A68ECh case   12:*/		regs.LR = 0x820A68F0; return 0x82088338;
		/* 820A68ECh case   12:*/		return 0x820A68F0;
		  /* 820A68F0h */ case   13:  		/* lwz R11, <#[R31]> */
		/* 820A68F0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A68F0h case   13:*/		return 0x820A68F4;
		  /* 820A68F4h */ case   14:  		/* stw R30, <#[R31 + 8]> */
		/* 820A68F4h case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 820A68F4h case   14:*/		return 0x820A68F8;
		  /* 820A68F8h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 820A68F8h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A68F8h case   15:*/		return 0x820A68FC;
		  /* 820A68FCh */ case   16:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 820A68FCh case   16:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 820A68FCh case   16:*/		return 0x820A6900;
		  /* 820A6900h */ case   17:  		/* bc 4, CR6_EQ, 8 */
		/* 820A6900h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820A6908;  }
		/* 820A6900h case   17:*/		return 0x820A6904;
		  /* 820A6904h */ case   18:  		/* li R11, 1 */
		/* 820A6904h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A6904h case   18:*/		return 0x820A6908;
	}
	return 0x820A6908;
} // Block from 820A68BCh-820A6908h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A6908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6908);
		  /* 820A6908h */ case    0:  		/* lis R4, 9345 */
		/* 820A6908h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A6908h case    0:*/		return 0x820A690C;
		  /* 820A690Ch */ case    1:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820A690Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820A690Ch case    1:*/		return 0x820A6910;
		  /* 820A6910h */ case    2:  		/* bl -124688 */
		/* 820A6910h case    2:*/		regs.LR = 0x820A6914; return 0x82088200;
		/* 820A6910h case    2:*/		return 0x820A6914;
		  /* 820A6914h */ case    3:  		/* or. R30, R3, R3 */
		/* 820A6914h case    3:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A6914h case    3:*/		return 0x820A6918;
		  /* 820A6918h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 820A6918h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820A6928;  }
		/* 820A6918h case    4:*/		return 0x820A691C;
	}
	return 0x820A691C;
} // Block from 820A6908h-820A691Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A691Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A691C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A691C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A691C);
		  /* 820A691Ch */ case    0:  		/* lis R26, -32761 */
		/* 820A691Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R26,0xFFFF8007);
		/* 820A691Ch case    0:*/		return 0x820A6920;
		  /* 820A6920h */ case    1:  		/* ori R26, R26, 14 */
		/* 820A6920h case    1:*/		cpu::op::ori<0>(regs,&regs.R26,regs.R26,0xE);
		/* 820A6920h case    1:*/		return 0x820A6924;
		  /* 820A6924h */ case    2:  		/* b 152 */
		/* 820A6924h case    2:*/		return 0x820A69BC;
		/* 820A6924h case    2:*/		return 0x820A6928;
	}
	return 0x820A6928;
} // Block from 820A691Ch-820A6928h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A6928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6928);
		  /* 820A6928h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A6928h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A6928h case    0:*/		return 0x820A692C;
		  /* 820A692Ch */ case    1:  		/* mr R3, R30 */
		/* 820A692Ch case    1:*/		regs.R3 = regs.R30;
		/* 820A692Ch case    1:*/		return 0x820A6930;
		  /* 820A6930h */ case    2:  		/* lwz R4, <#[R31 + 4]> */
		/* 820A6930h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 820A6930h case    2:*/		return 0x820A6934;
		  /* 820A6934h */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820A6934h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820A6934h case    3:*/		return 0x820A6938;
		  /* 820A6938h */ case    4:  		/* bl -85896 */
		/* 820A6938h case    4:*/		regs.LR = 0x820A693C; return 0x820919B0;
		/* 820A6938h case    4:*/		return 0x820A693C;
		  /* 820A693Ch */ case    5:  		/* lis R4, 9345 */
		/* 820A693Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A693Ch case    5:*/		return 0x820A6940;
		  /* 820A6940h */ case    6:  		/* lwz R3, <#[R31 + 4]> */
		/* 820A6940h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820A6940h case    6:*/		return 0x820A6944;
		  /* 820A6944h */ case    7:  		/* bl -124428 */
		/* 820A6944h case    7:*/		regs.LR = 0x820A6948; return 0x82088338;
		/* 820A6944h case    7:*/		return 0x820A6948;
		  /* 820A6948h */ case    8:  		/* stw R30, <#[R31 + 4]> */
		/* 820A6948h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 820A6948h case    8:*/		return 0x820A694C;
	}
	return 0x820A694C;
} // Block from 820A6928h-820A694Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A694Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A694C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A694C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A694C);
		  /* 820A694Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A694Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A694Ch case    0:*/		return 0x820A6950;
		  /* 820A6950h */ case    1:  		/* cmplw CR6, R11, R29 */
		/* 820A6950h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820A6950h case    1:*/		return 0x820A6954;
		  /* 820A6954h */ case    2:  		/* bc 4, CR6_GT, 56 */
		/* 820A6954h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820A698C;  }
		/* 820A6954h case    2:*/		return 0x820A6958;
		  /* 820A6958h */ case    3:  		/* subf R10, R29, R11 */
		/* 820A6958h case    3:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R29,regs.R11);
		/* 820A6958h case    3:*/		return 0x820A695C;
		  /* 820A695Ch */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820A695Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820A695Ch case    4:*/		return 0x820A6960;
		  /* 820A6960h */ case    5:  		/* mtspr CTR, R10 */
		/* 820A6960h case    5:*/		regs.CTR = regs.R10;
		/* 820A6960h case    5:*/		return 0x820A6964;
		  /* 820A6964h */ case    6:  		/* lwz R10, <#[R31 + 4]> */
		/* 820A6964h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820A6964h case    6:*/		return 0x820A6968;
		  /* 820A6968h */ case    7:  		/* add R10, R10, R11 */
		/* 820A6968h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820A6968h case    7:*/		return 0x820A696C;
		  /* 820A696Ch */ case    8:  		/* lwz R9, <#[R10 - 4]> */
		/* 820A696Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 820A696Ch case    8:*/		return 0x820A6970;
		  /* 820A6970h */ case    9:  		/* stw R9, <#[R10]> */
		/* 820A6970h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820A6970h case    9:*/		return 0x820A6974;
		  /* 820A6974h */ case   10:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A6974h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A6974h case   10:*/		return 0x820A6978;
		  /* 820A6978h */ case   11:  		/* add R10, R11, R10 */
		/* 820A6978h case   11:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820A6978h case   11:*/		return 0x820A697C;
		  /* 820A697Ch */ case   12:  		/* lwz R9, <#[R10 - 4]> */
		/* 820A697Ch case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 820A697Ch case   12:*/		return 0x820A6980;
		  /* 820A6980h */ case   13:  		/* addi R11, R11, -4 */
		/* 820A6980h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820A6980h case   13:*/		return 0x820A6984;
		  /* 820A6984h */ case   14:  		/* stw R9, <#[R10]> */
		/* 820A6984h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820A6984h case   14:*/		return 0x820A6988;
		  /* 820A6988h */ case   15:  		/* bc 16, CR0_LT, -36 */
		/* 820A6988h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A6964;  }
		/* 820A6988h case   15:*/		return 0x820A698C;
	}
	return 0x820A698C;
} // Block from 820A694Ch-820A698Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A698Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A698C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A698C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A698C);
		  /* 820A698Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820A698Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820A698Ch case    0:*/		return 0x820A6990;
		  /* 820A6990h */ case    1:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 820A6990h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 820A6990h case    1:*/		return 0x820A6994;
		  /* 820A6994h */ case    2:  		/* li R9, 1 */
		/* 820A6994h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820A6994h case    2:*/		return 0x820A6998;
		  /* 820A6998h */ case    3:  		/* stwx R28, <#[R11 + R10]> */
		/* 820A6998h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820A6998h case    3:*/		return 0x820A699C;
		  /* 820A699Ch */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 820A699Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820A699Ch case    4:*/		return 0x820A69A0;
		  /* 820A69A0h */ case    5:  		/* stwx R9, <#[R11 + R10]> */
		/* 820A69A0h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820A69A0h case    5:*/		return 0x820A69A4;
		  /* 820A69A4h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 820A69A4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A69A4h case    6:*/		return 0x820A69A8;
		  /* 820A69A8h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A69A8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A69A8h case    7:*/		return 0x820A69AC;
		  /* 820A69ACh */ case    8:  		/* stw R11, <#[R31]> */
		/* 820A69ACh case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A69ACh case    8:*/		return 0x820A69B0;
	}
	return 0x820A69B0;
} // Block from 820A698Ch-820A69B0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A69B0h
// Function '??0CTokenize@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A69B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A69B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A69B0);
		  /* 820A69B0h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820A69B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820A69B0h case    0:*/		return 0x820A69B4;
		  /* 820A69B4h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820A69B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A69BC;  }
		/* 820A69B4h case    1:*/		return 0x820A69B8;
		  /* 820A69B8h */ case    2:  		/* stw R29, <#[R27]> */
		/* 820A69B8h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + 0x00000000) );
		/* 820A69B8h case    2:*/		return 0x820A69BC;
	}
	return 0x820A69BC;
} // Block from 820A69B0h-820A69BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A69BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A69BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A69BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A69BC);
		  /* 820A69BCh */ case    0:  		/* lis R4, 9345 */
		/* 820A69BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A69BCh case    0:*/		return 0x820A69C0;
		  /* 820A69C0h */ case    1:  		/* li R3, 0 */
		/* 820A69C0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A69C0h case    1:*/		return 0x820A69C4;
		  /* 820A69C4h */ case    2:  		/* bl -124556 */
		/* 820A69C4h case    2:*/		regs.LR = 0x820A69C8; return 0x82088338;
		/* 820A69C4h case    2:*/		return 0x820A69C8;
		  /* 820A69C8h */ case    3:  		/* mr R3, R26 */
		/* 820A69C8h case    3:*/		regs.R3 = regs.R26;
		/* 820A69C8h case    3:*/		return 0x820A69CC;
		  /* 820A69CCh */ case    4:  		/* addi R1, R1, 144 */
		/* 820A69CCh case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820A69CCh case    4:*/		return 0x820A69D0;
		  /* 820A69D0h */ case    5:  		/* b -87856 */
		/* 820A69D0h case    5:*/		return 0x820912A0;
		/* 820A69D0h case    5:*/		return 0x820A69D4;
		  /* 820A69D4h */ case    6:  		/* nop */
		/* 820A69D4h case    6:*/		cpu::op::nop();
		/* 820A69D4h case    6:*/		return 0x820A69D8;
	}
	return 0x820A69D8;
} // Block from 820A69BCh-820A69D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A69D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A69D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A69D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A69D8);
		  /* 820A69D8h */ case    0:  		/* mfspr R12, LR */
		/* 820A69D8h case    0:*/		regs.R12 = regs.LR;
		/* 820A69D8h case    0:*/		return 0x820A69DC;
		  /* 820A69DCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A69DCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A69DCh case    1:*/		return 0x820A69E0;
		  /* 820A69E0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A69E0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A69E0h case    2:*/		return 0x820A69E4;
		  /* 820A69E4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A69E4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A69E4h case    3:*/		return 0x820A69E8;
	}
	return 0x820A69E8;
} // Block from 820A69D8h-820A69E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A69E8h
// Function '?Initialize@CTokenize@D3DXShader@@QAAJPBXIIPBDIPAVCAlloc@D3DXCore@@PAVCTErrors@2@PAVCTokStringTable@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A69E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A69E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A69E8);
		  /* 820A69E8h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A69E8h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A69E8h case    0:*/		return 0x820A69EC;
		  /* 820A69ECh */ case    1:  		/* mr R31, R3 */
		/* 820A69ECh case    1:*/		regs.R31 = regs.R3;
		/* 820A69ECh case    1:*/		return 0x820A69F0;
		  /* 820A69F0h */ case    2:  		/* b 24 */
		/* 820A69F0h case    2:*/		return 0x820A6A08;
		/* 820A69F0h case    2:*/		return 0x820A69F4;
		  /* 820A69F4h */ case    3:  		/* lwz R3, <#[R31 + 20]> */
		/* 820A69F4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820A69F4h case    3:*/		return 0x820A69F8;
		  /* 820A69F8h */ case    4:  		/* lis R4, 9345 */
		/* 820A69F8h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A69F8h case    4:*/		return 0x820A69FC;
		  /* 820A69FCh */ case    5:  		/* lwz R30, <#[R3]> */
		/* 820A69FCh case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 820A69FCh case    5:*/		return 0x820A6A00;
		  /* 820A6A00h */ case    6:  		/* bl -124616 */
		/* 820A6A00h case    6:*/		regs.LR = 0x820A6A04; return 0x82088338;
		/* 820A6A00h case    6:*/		return 0x820A6A04;
		  /* 820A6A04h */ case    7:  		/* stw R30, <#[R31 + 20]> */
		/* 820A6A04h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 820A6A04h case    7:*/		return 0x820A6A08;
	}
	return 0x820A6A08;
} // Block from 820A69E8h-820A6A08h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A6A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6A08);
		  /* 820A6A08h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820A6A08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820A6A08h case    0:*/		return 0x820A6A0C;
		  /* 820A6A0Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A6A0Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A6A0Ch case    1:*/		return 0x820A6A10;
		  /* 820A6A10h */ case    2:  		/* bc 4, CR6_EQ, -28 */
		/* 820A6A10h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A69F4;  }
		/* 820A6A10h case    2:*/		return 0x820A6A14;
		  /* 820A6A14h */ case    3:  		/* lwz R9, <#[R31]> */
		/* 820A6A14h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820A6A14h case    3:*/		return 0x820A6A18;
		  /* 820A6A18h */ case    4:  		/* mr R10, R11 */
		/* 820A6A18h case    4:*/		regs.R10 = regs.R11;
		/* 820A6A18h case    4:*/		return 0x820A6A1C;
		  /* 820A6A1Ch */ case    5:  		/* stw R11, <#[R31 + 24]> */
		/* 820A6A1Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820A6A1Ch case    5:*/		return 0x820A6A20;
		  /* 820A6A20h */ case    6:  		/* stw R11, <#[R31 + 28]> */
		/* 820A6A20h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820A6A20h case    6:*/		return 0x820A6A24;
		  /* 820A6A24h */ case    7:  		/* cmplwi CR6, R9, 0 */
		/* 820A6A24h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A6A24h case    7:*/		return 0x820A6A28;
		  /* 820A6A28h */ case    8:  		/* stw R11, <#[R31 + 32]> */
		/* 820A6A28h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820A6A28h case    8:*/		return 0x820A6A2C;
		  /* 820A6A2Ch */ case    9:  		/* bc 4, CR6_GT, 44 */
		/* 820A6A2Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x820A6A58;  }
		/* 820A6A2Ch case    9:*/		return 0x820A6A30;
		  /* 820A6A30h */ case   10:  		/* lwz R9, <#[R31 + 8]> */
		/* 820A6A30h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820A6A30h case   10:*/		return 0x820A6A34;
		  /* 820A6A34h */ case   11:  		/* addi R10, R10, 1 */
		/* 820A6A34h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A6A34h case   11:*/		return 0x820A6A38;
		  /* 820A6A38h */ case   12:  		/* add R9, R9, R11 */
		/* 820A6A38h case   12:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 820A6A38h case   12:*/		return 0x820A6A3C;
		  /* 820A6A3Ch */ case   13:  		/* addi R11, R11, 4 */
		/* 820A6A3Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820A6A3Ch case   13:*/		return 0x820A6A40;
		  /* 820A6A40h */ case   14:  		/* lwz R8, <#[R9]> */
		/* 820A6A40h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820A6A40h case   14:*/		return 0x820A6A44;
		  /* 820A6A44h */ case   15:  		/* rlwinm R8, R8, 0, 27, 25 */
		/* 820A6A44h case   15:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R8,regs.R8);
		/* 820A6A44h case   15:*/		return 0x820A6A48;
		  /* 820A6A48h */ case   16:  		/* stw R8, <#[R9]> */
		/* 820A6A48h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820A6A48h case   16:*/		return 0x820A6A4C;
		  /* 820A6A4Ch */ case   17:  		/* lwz R9, <#[R31]> */
		/* 820A6A4Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820A6A4Ch case   17:*/		return 0x820A6A50;
		  /* 820A6A50h */ case   18:  		/* cmplw CR6, R10, R9 */
		/* 820A6A50h case   18:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820A6A50h case   18:*/		return 0x820A6A54;
		  /* 820A6A54h */ case   19:  		/* bc 12, CR6_LT, -36 */
		/* 820A6A54h case   19:*/		if ( regs.CR[6].lt ) { return 0x820A6A30;  }
		/* 820A6A54h case   19:*/		return 0x820A6A58;
	}
	return 0x820A6A58;
} // Block from 820A6A08h-820A6A58h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A6A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6A58);
		  /* 820A6A58h */ case    0:  		/* li R3, 0 */
		/* 820A6A58h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A6A58h case    0:*/		return 0x820A6A5C;
		  /* 820A6A5Ch */ case    1:  		/* addi R1, R1, 112 */
		/* 820A6A5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A6A5Ch case    1:*/		return 0x820A6A60;
		  /* 820A6A60h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A6A60h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A6A60h case    2:*/		return 0x820A6A64;
		  /* 820A6A64h */ case    3:  		/* mtspr LR, R12 */
		/* 820A6A64h case    3:*/		regs.LR = regs.R12;
		/* 820A6A64h case    3:*/		return 0x820A6A68;
		  /* 820A6A68h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820A6A68h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A6A68h case    4:*/		return 0x820A6A6C;
		  /* 820A6A6Ch */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820A6A6Ch case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A6A6Ch case    5:*/		return 0x820A6A70;
		  /* 820A6A70h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820A6A70h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A6A70h case    6:*/		return 0x820A6A74;
	}
	return 0x820A6A74;
} // Block from 820A6A58h-820A6A74h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A6A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6A74);
		  /* 820A6A74h */ case    0:  		/* nop */
		/* 820A6A74h case    0:*/		cpu::op::nop();
		/* 820A6A74h case    0:*/		return 0x820A6A78;
	}
	return 0x820A6A78;
} // Block from 820A6A74h-820A6A78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6A78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6A78);
		  /* 820A6A78h */ case    0:  		/* mfspr R12, LR */
		/* 820A6A78h case    0:*/		regs.R12 = regs.LR;
		/* 820A6A78h case    0:*/		return 0x820A6A7C;
		  /* 820A6A7Ch */ case    1:  		/* bl -88096 */
		/* 820A6A7Ch case    1:*/		regs.LR = 0x820A6A80; return 0x8209125C;
		/* 820A6A7Ch case    1:*/		return 0x820A6A80;
		  /* 820A6A80h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A6A80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A6A80h case    2:*/		return 0x820A6A84;
		  /* 820A6A84h */ case    3:  		/* mr R30, R3 */
		/* 820A6A84h case    3:*/		regs.R30 = regs.R3;
		/* 820A6A84h case    3:*/		return 0x820A6A88;
		  /* 820A6A88h */ case    4:  		/* mr R29, R4 */
		/* 820A6A88h case    4:*/		regs.R29 = regs.R4;
		/* 820A6A88h case    4:*/		return 0x820A6A8C;
		  /* 820A6A8Ch */ case    5:  		/* mr R11, R4 */
		/* 820A6A8Ch case    5:*/		regs.R11 = regs.R4;
		/* 820A6A8Ch case    5:*/		return 0x820A6A90;
		  /* 820A6A90h */ case    6:  		/* lbz R10, <#[R11]> */
		/* 820A6A90h case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6A90h case    6:*/		return 0x820A6A94;
		  /* 820A6A94h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A6A94h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A6A94h case    7:*/		return 0x820A6A98;
		  /* 820A6A98h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 820A6A98h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A6A98h case    8:*/		return 0x820A6A9C;
		  /* 820A6A9Ch */ case    9:  		/* bc 4, CR6_EQ, -12 */
		/* 820A6A9Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A6A90;  }
		/* 820A6A9Ch case    9:*/		return 0x820A6AA0;
	}
	return 0x820A6AA0;
} // Block from 820A6A78h-820A6AA0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A6AA0h
// Function '?SetTreatDigitsAsLetters@CTokenize@D3DXShader@@QAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6AA0);
		  /* 820A6AA0h */ case    0:  		/* subf R11, R29, R11 */
		/* 820A6AA0h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 820A6AA0h case    0:*/		return 0x820A6AA4;
		  /* 820A6AA4h */ case    1:  		/* lis R4, 9345 */
		/* 820A6AA4h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A6AA4h case    1:*/		return 0x820A6AA8;
	}
	return 0x820A6AA8;
} // Block from 820A6AA0h-820A6AA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6AA8h
// Function '?LexDefNumber@CTokenize@D3DXShader@@IAAIPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6AA8);
		  /* 820A6AA8h */ case    0:  		/* addi R11, R11, -1 */
		/* 820A6AA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A6AA8h case    0:*/		return 0x820A6AAC;
		  /* 820A6AACh */ case    1:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820A6AACh case    1:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820A6AACh case    1:*/		return 0x820A6AB0;
		  /* 820A6AB0h */ case    2:  		/* addi R31, R11, 1 */
		/* 820A6AB0h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x1);
		/* 820A6AB0h case    2:*/		return 0x820A6AB4;
		  /* 820A6AB4h */ case    3:  		/* addi R3, R31, 4 */
		/* 820A6AB4h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 820A6AB4h case    3:*/		return 0x820A6AB8;
		  /* 820A6AB8h */ case    4:  		/* bl -125112 */
		/* 820A6AB8h case    4:*/		regs.LR = 0x820A6ABC; return 0x82088200;
		/* 820A6AB8h case    4:*/		return 0x820A6ABC;
		  /* 820A6ABCh */ case    5:  		/* or. R11, R3, R3 */
		/* 820A6ABCh case    5:*/		cpu::op::or<1>(regs,&regs.R11,regs.R3,regs.R3);
		/* 820A6ABCh case    5:*/		return 0x820A6AC0;
		  /* 820A6AC0h */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 820A6AC0h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820A6AD0;  }
		/* 820A6AC0h case    6:*/		return 0x820A6AC4;
		  /* 820A6AC4h */ case    7:  		/* lis R3, -32761 */
		/* 820A6AC4h case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A6AC4h case    7:*/		return 0x820A6AC8;
		  /* 820A6AC8h */ case    8:  		/* ori R3, R3, 14 */
		/* 820A6AC8h case    8:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A6AC8h case    8:*/		return 0x820A6ACC;
		  /* 820A6ACCh */ case    9:  		/* b 52 */
		/* 820A6ACCh case    9:*/		return 0x820A6B00;
		/* 820A6ACCh case    9:*/		return 0x820A6AD0;
	}
	return 0x820A6AD0;
} // Block from 820A6AA8h-820A6AD0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A6AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6AD0);
		  /* 820A6AD0h */ case    0:  		/* lwz R10, <#[R30 + 20]> */
		/* 820A6AD0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 820A6AD0h case    0:*/		return 0x820A6AD4;
		  /* 820A6AD4h */ case    1:  		/* addi R3, R11, 4 */
		/* 820A6AD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x4);
		/* 820A6AD4h case    1:*/		return 0x820A6AD8;
		  /* 820A6AD8h */ case    2:  		/* mr R5, R31 */
		/* 820A6AD8h case    2:*/		regs.R5 = regs.R31;
		/* 820A6AD8h case    2:*/		return 0x820A6ADC;
		  /* 820A6ADCh */ case    3:  		/* mr R4, R29 */
		/* 820A6ADCh case    3:*/		regs.R4 = regs.R29;
		/* 820A6ADCh case    3:*/		return 0x820A6AE0;
		  /* 820A6AE0h */ case    4:  		/* stw R10, <#[R11]> */
		/* 820A6AE0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6AE0h case    4:*/		return 0x820A6AE4;
		  /* 820A6AE4h */ case    5:  		/* lwz R10, <#[R30 + 24]> */
		/* 820A6AE4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 820A6AE4h case    5:*/		return 0x820A6AE8;
		  /* 820A6AE8h */ case    6:  		/* stw R11, <#[R30 + 20]> */
		/* 820A6AE8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820A6AE8h case    6:*/		return 0x820A6AEC;
		  /* 820A6AECh */ case    7:  		/* add R11, R10, R31 */
		/* 820A6AECh case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R31);
		/* 820A6AECh case    7:*/		return 0x820A6AF0;
		  /* 820A6AF0h */ case    8:  		/* addi R11, R11, -1 */
		/* 820A6AF0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A6AF0h case    8:*/		return 0x820A6AF4;
		  /* 820A6AF4h */ case    9:  		/* stw R11, <#[R30 + 24]> */
		/* 820A6AF4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820A6AF4h case    9:*/		return 0x820A6AF8;
		  /* 820A6AF8h */ case   10:  		/* bl -86344 */
		/* 820A6AF8h case   10:*/		regs.LR = 0x820A6AFC; return 0x820919B0;
		/* 820A6AF8h case   10:*/		return 0x820A6AFC;
		  /* 820A6AFCh */ case   11:  		/* li R3, 0 */
		/* 820A6AFCh case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A6AFCh case   11:*/		return 0x820A6B00;
	}
	return 0x820A6B00;
} // Block from 820A6AD0h-820A6B00h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A6B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6B00);
		  /* 820A6B00h */ case    0:  		/* addi R1, R1, 112 */
		/* 820A6B00h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A6B00h case    0:*/		return 0x820A6B04;
		  /* 820A6B04h */ case    1:  		/* b -88152 */
		/* 820A6B04h case    1:*/		return 0x820912AC;
		/* 820A6B04h case    1:*/		return 0x820A6B08;
	}
	return 0x820A6B08;
} // Block from 820A6B00h-820A6B08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6B08);
		  /* 820A6B08h */ case    0:  		/* mfspr R12, LR */
		/* 820A6B08h case    0:*/		regs.R12 = regs.LR;
		/* 820A6B08h case    0:*/		return 0x820A6B0C;
		  /* 820A6B0Ch */ case    1:  		/* bl -88256 */
		/* 820A6B0Ch case    1:*/		regs.LR = 0x820A6B10; return 0x8209124C;
		/* 820A6B0Ch case    1:*/		return 0x820A6B10;
	}
	return 0x820A6B10;
} // Block from 820A6B08h-820A6B10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6B10h
// Function '?LexFloat@CTokenize@D3DXShader@@IAAIPBDPAN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6B10);
		  /* 820A6B10h */ case    0:  		/* stwu R1, <#[R1 - 144]> */
		/* 820A6B10h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820A6B10h case    0:*/		return 0x820A6B14;
		  /* 820A6B14h */ case    1:  		/* lis R11, 32767 */
		/* 820A6B14h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 820A6B14h case    1:*/		return 0x820A6B18;
		  /* 820A6B18h */ case    2:  		/* mr R26, R3 */
		/* 820A6B18h case    2:*/		regs.R26 = regs.R3;
		/* 820A6B18h case    2:*/		return 0x820A6B1C;
		  /* 820A6B1Ch */ case    3:  		/* ori R11, R11, 65527 */
		/* 820A6B1Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFF7);
		/* 820A6B1Ch case    3:*/		return 0x820A6B20;
		  /* 820A6B20h */ case    4:  		/* mr R30, R4 */
		/* 820A6B20h case    4:*/		regs.R30 = regs.R4;
		/* 820A6B20h case    4:*/		return 0x820A6B24;
		  /* 820A6B24h */ case    5:  		/* mr R31, R5 */
		/* 820A6B24h case    5:*/		regs.R31 = regs.R5;
		/* 820A6B24h case    5:*/		return 0x820A6B28;
		  /* 820A6B28h */ case    6:  		/* mr R28, R6 */
		/* 820A6B28h case    6:*/		regs.R28 = regs.R6;
		/* 820A6B28h case    6:*/		return 0x820A6B2C;
		  /* 820A6B2Ch */ case    7:  		/* mr R25, R7 */
		/* 820A6B2Ch case    7:*/		regs.R25 = regs.R7;
		/* 820A6B2Ch case    7:*/		return 0x820A6B30;
		  /* 820A6B30h */ case    8:  		/* cmplw CR6, R5, R11 */
		/* 820A6B30h case    8:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 820A6B30h case    8:*/		return 0x820A6B34;
		  /* 820A6B34h */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 820A6B34h case    9:*/		if ( regs.CR[6].lt ) { return 0x820A6B44;  }
		/* 820A6B34h case    9:*/		return 0x820A6B38;
		  /* 820A6B38h */ case   10:  		/* lis R3, -32761 */
		/* 820A6B38h case   10:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A6B38h case   10:*/		return 0x820A6B3C;
		  /* 820A6B3Ch */ case   11:  		/* ori R3, R3, 87 */
		/* 820A6B3Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x57);
		/* 820A6B3Ch case   11:*/		return 0x820A6B40;
		  /* 820A6B40h */ case   12:  		/* b 236 */
		/* 820A6B40h case   12:*/		return 0x820A6C2C;
		/* 820A6B40h case   12:*/		return 0x820A6B44;
	}
	return 0x820A6B44;
} // Block from 820A6B10h-820A6B44h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A6B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6B44);
		  /* 820A6B44h */ case    0:  		/* mr R4, R31 */
		/* 820A6B44h case    0:*/		regs.R4 = regs.R31;
		/* 820A6B44h case    0:*/		return 0x820A6B48;
		  /* 820A6B48h */ case    1:  		/* mr R3, R28 */
		/* 820A6B48h case    1:*/		regs.R3 = regs.R28;
		/* 820A6B48h case    1:*/		return 0x820A6B4C;
		  /* 820A6B4Ch */ case    2:  		/* bl -3564 */
		/* 820A6B4Ch case    2:*/		regs.LR = 0x820A6B50; return 0x820A5D60;
		/* 820A6B4Ch case    2:*/		return 0x820A6B50;
		  /* 820A6B50h */ case    3:  		/* li R11, 389 */
		/* 820A6B50h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x185);
		/* 820A6B50h case    3:*/		return 0x820A6B54;
		  /* 820A6B54h */ case    4:  		/* divwu R11, R3, R11 */
		/* 820A6B54h case    4:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 820A6B54h case    4:*/		return 0x820A6B58;
		  /* 820A6B58h */ case    5:  		/* mulli R11, R11, 389 */
		/* 820A6B58h case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x185);
		/* 820A6B58h case    5:*/		return 0x820A6B5C;
		  /* 820A6B5Ch */ case    6:  		/* subf R11, R11, R3 */
		/* 820A6B5Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820A6B5Ch case    6:*/		return 0x820A6B60;
		  /* 820A6B60h */ case    7:  		/* rlwinm R27, R11, 2, 0, 29 */
		/* 820A6B60h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R11);
		/* 820A6B60h case    7:*/		return 0x820A6B64;
		  /* 820A6B64h */ case    8:  		/* lwzx R10, <#[R27 + R26]> */
		/* 820A6B64h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + regs.R26 + 0x00000000) );
		/* 820A6B64h case    8:*/		return 0x820A6B68;
		  /* 820A6B68h */ case    9:  		/* b 88 */
		/* 820A6B68h case    9:*/		return 0x820A6BC0;
		/* 820A6B68h case    9:*/		return 0x820A6B6C;
		  /* 820A6B6Ch */ case   10:  		/* lwz R11, <#[R10 + 4]> */
		/* 820A6B6Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820A6B6Ch case   10:*/		return 0x820A6B70;
		  /* 820A6B70h */ case   11:  		/* cmplw CR6, R31, R11 */
		/* 820A6B70h case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820A6B70h case   11:*/		return 0x820A6B74;
		  /* 820A6B74h */ case   12:  		/* bc 4, CR6_EQ, 72 */
		/* 820A6B74h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A6BBC;  }
		/* 820A6B74h case   12:*/		return 0x820A6B78;
		  /* 820A6B78h */ case   13:  		/* addi R7, R10, 8 */
		/* 820A6B78h case   13:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x8);
		/* 820A6B78h case   13:*/		return 0x820A6B7C;
		  /* 820A6B7Ch */ case   14:  		/* mr R11, R28 */
		/* 820A6B7Ch case   14:*/		regs.R11 = regs.R28;
		/* 820A6B7Ch case   14:*/		return 0x820A6B80;
		  /* 820A6B80h */ case   15:  		/* mr R9, R7 */
		/* 820A6B80h case   15:*/		regs.R9 = regs.R7;
		/* 820A6B80h case   15:*/		return 0x820A6B84;
		  /* 820A6B84h */ case   16:  		/* li R8, 0 */
		/* 820A6B84h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820A6B84h case   16:*/		return 0x820A6B88;
		  /* 820A6B88h */ case   17:  		/* cmplwi CR0, R31, 0 */
		/* 820A6B88h case   17:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820A6B88h case   17:*/		return 0x820A6B8C;
		  /* 820A6B8Ch */ case   18:  		/* bc 12, CR0_EQ, 40 */
		/* 820A6B8Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x820A6BB4;  }
		/* 820A6B8Ch case   18:*/		return 0x820A6B90;
		  /* 820A6B90h */ case   19:  		/* add R6, R28, R31 */
		/* 820A6B90h case   19:*/		cpu::op::add<0>(regs,&regs.R6,regs.R28,regs.R31);
		/* 820A6B90h case   19:*/		return 0x820A6B94;
		  /* 820A6B94h */ case   20:  		/* lbz R8, <#[R11]> */
		/* 820A6B94h case   20:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6B94h case   20:*/		return 0x820A6B98;
		  /* 820A6B98h */ case   21:  		/* lbz R5, <#[R9]> */
		/* 820A6B98h case   21:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000000) );
		/* 820A6B98h case   21:*/		return 0x820A6B9C;
		  /* 820A6B9Ch */ case   22:  		/* subf. R8, R5, R8 */
		/* 820A6B9Ch case   22:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R5,regs.R8);
		/* 820A6B9Ch case   22:*/		return 0x820A6BA0;
		  /* 820A6BA0h */ case   23:  		/* bc 4, CR0_EQ, 20 */
		/* 820A6BA0h case   23:*/		if ( !regs.CR[0].eq ) { return 0x820A6BB4;  }
		/* 820A6BA0h case   23:*/		return 0x820A6BA4;
		  /* 820A6BA4h */ case   24:  		/* addi R11, R11, 1 */
		/* 820A6BA4h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A6BA4h case   24:*/		return 0x820A6BA8;
		  /* 820A6BA8h */ case   25:  		/* addi R9, R9, 1 */
		/* 820A6BA8h case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A6BA8h case   25:*/		return 0x820A6BAC;
		  /* 820A6BACh */ case   26:  		/* cmpw CR6, R11, R6 */
		/* 820A6BACh case   26:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R6);
		/* 820A6BACh case   26:*/		return 0x820A6BB0;
		  /* 820A6BB0h */ case   27:  		/* bc 4, CR6_EQ, -28 */
		/* 820A6BB0h case   27:*/		if ( !regs.CR[6].eq ) { return 0x820A6B94;  }
		/* 820A6BB0h case   27:*/		return 0x820A6BB4;
	}
	return 0x820A6BB4;
} // Block from 820A6B44h-820A6BB4h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820A6BB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6BB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6BB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6BB4);
		  /* 820A6BB4h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A6BB4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A6BB4h case    0:*/		return 0x820A6BB8;
		  /* 820A6BB8h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 820A6BB8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A6BEC;  }
		/* 820A6BB8h case    1:*/		return 0x820A6BBC;
	}
	return 0x820A6BBC;
} // Block from 820A6BB4h-820A6BBCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6BBC);
		  /* 820A6BBCh */ case    0:  		/* lwz R10, <#[R10]> */
		/* 820A6BBCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820A6BBCh case    0:*/		return 0x820A6BC0;
	}
	return 0x820A6BC0;
} // Block from 820A6BBCh-820A6BC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6BC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6BC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6BC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6BC0);
		  /* 820A6BC0h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820A6BC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A6BC0h case    0:*/		return 0x820A6BC4;
		  /* 820A6BC4h */ case    1:  		/* bc 4, CR6_EQ, -88 */
		/* 820A6BC4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A6B6C;  }
		/* 820A6BC4h case    1:*/		return 0x820A6BC8;
		  /* 820A6BC8h */ case    2:  		/* li R5, 4 */
		/* 820A6BC8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820A6BC8h case    2:*/		return 0x820A6BCC;
		  /* 820A6BCCh */ case    3:  		/* addi R4, R31, 9 */
		/* 820A6BCCh case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x9);
		/* 820A6BCCh case    3:*/		return 0x820A6BD0;
		  /* 820A6BD0h */ case    4:  		/* mr R3, R30 */
		/* 820A6BD0h case    4:*/		regs.R3 = regs.R30;
		/* 820A6BD0h case    4:*/		return 0x820A6BD4;
		  /* 820A6BD4h */ case    5:  		/* bl 140556 */
		/* 820A6BD4h case    5:*/		regs.LR = 0x820A6BD8; return 0x820C90E0;
		/* 820A6BD4h case    5:*/		return 0x820A6BD8;
		  /* 820A6BD8h */ case    6:  		/* or. R30, R3, R3 */
		/* 820A6BD8h case    6:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A6BD8h case    6:*/		return 0x820A6BDC;
		  /* 820A6BDCh */ case    7:  		/* bc 4, CR0_EQ, 24 */
		/* 820A6BDCh case    7:*/		if ( !regs.CR[0].eq ) { return 0x820A6BF4;  }
		/* 820A6BDCh case    7:*/		return 0x820A6BE0;
		  /* 820A6BE0h */ case    8:  		/* lis R3, -32761 */
		/* 820A6BE0h case    8:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A6BE0h case    8:*/		return 0x820A6BE4;
		  /* 820A6BE4h */ case    9:  		/* ori R3, R3, 14 */
		/* 820A6BE4h case    9:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A6BE4h case    9:*/		return 0x820A6BE8;
		  /* 820A6BE8h */ case   10:  		/* b 68 */
		/* 820A6BE8h case   10:*/		return 0x820A6C2C;
		/* 820A6BE8h case   10:*/		return 0x820A6BEC;
	}
	return 0x820A6BEC;
} // Block from 820A6BC0h-820A6BECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A6BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6BEC);
		  /* 820A6BECh */ case    0:  		/* stw R7, <#[R25]> */
		/* 820A6BECh case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R25 + 0x00000000) );
		/* 820A6BECh case    0:*/		return 0x820A6BF0;
		  /* 820A6BF0h */ case    1:  		/* b 56 */
		/* 820A6BF0h case    1:*/		return 0x820A6C28;
		/* 820A6BF0h case    1:*/		return 0x820A6BF4;
	}
	return 0x820A6BF4;
} // Block from 820A6BECh-820A6BF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6BF4);
		  /* 820A6BF4h */ case    0:  		/* addi R29, R30, 8 */
		/* 820A6BF4h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x8);
		/* 820A6BF4h case    0:*/		return 0x820A6BF8;
		  /* 820A6BF8h */ case    1:  		/* mr R5, R31 */
		/* 820A6BF8h case    1:*/		regs.R5 = regs.R31;
		/* 820A6BF8h case    1:*/		return 0x820A6BFC;
		  /* 820A6BFCh */ case    2:  		/* mr R4, R28 */
		/* 820A6BFCh case    2:*/		regs.R4 = regs.R28;
		/* 820A6BFCh case    2:*/		return 0x820A6C00;
		  /* 820A6C00h */ case    3:  		/* mr R3, R29 */
		/* 820A6C00h case    3:*/		regs.R3 = regs.R29;
		/* 820A6C00h case    3:*/		return 0x820A6C04;
		  /* 820A6C04h */ case    4:  		/* bl -86612 */
		/* 820A6C04h case    4:*/		regs.LR = 0x820A6C08; return 0x820919B0;
		/* 820A6C04h case    4:*/		return 0x820A6C08;
		  /* 820A6C08h */ case    5:  		/* add R11, R30, R31 */
		/* 820A6C08h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R31);
		/* 820A6C08h case    5:*/		return 0x820A6C0C;
		  /* 820A6C0Ch */ case    6:  		/* li R10, 0 */
		/* 820A6C0Ch case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A6C0Ch case    6:*/		return 0x820A6C10;
		  /* 820A6C10h */ case    7:  		/* stb R10, <#[R11 + 8]> */
		/* 820A6C10h case    7:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820A6C10h case    7:*/		return 0x820A6C14;
		  /* 820A6C14h */ case    8:  		/* stw R31, <#[R30 + 4]> */
		/* 820A6C14h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 820A6C14h case    8:*/		return 0x820A6C18;
		  /* 820A6C18h */ case    9:  		/* lwzx R11, <#[R27 + R26]> */
		/* 820A6C18h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R26 + 0x00000000) );
		/* 820A6C18h case    9:*/		return 0x820A6C1C;
		  /* 820A6C1Ch */ case   10:  		/* stw R11, <#[R30]> */
		/* 820A6C1Ch case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A6C1Ch case   10:*/		return 0x820A6C20;
		  /* 820A6C20h */ case   11:  		/* stwx R30, <#[R27 + R26]> */
		/* 820A6C20h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R27 + regs.R26 + 0x00000000) );
		/* 820A6C20h case   11:*/		return 0x820A6C24;
		  /* 820A6C24h */ case   12:  		/* stw R29, <#[R25]> */
		/* 820A6C24h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R25 + 0x00000000) );
		/* 820A6C24h case   12:*/		return 0x820A6C28;
	}
	return 0x820A6C28;
} // Block from 820A6BF4h-820A6C28h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A6C28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6C28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6C28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6C28);
		  /* 820A6C28h */ case    0:  		/* li R3, 0 */
		/* 820A6C28h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A6C28h case    0:*/		return 0x820A6C2C;
	}
	return 0x820A6C2C;
} // Block from 820A6C28h-820A6C2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6C2C);
		  /* 820A6C2Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 820A6C2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820A6C2Ch case    0:*/		return 0x820A6C30;
		  /* 820A6C30h */ case    1:  		/* b -88468 */
		/* 820A6C30h case    1:*/		return 0x8209129C;
		/* 820A6C30h case    1:*/		return 0x820A6C34;
		  /* 820A6C34h */ case    2:  		/* nop */
		/* 820A6C34h case    2:*/		cpu::op::nop();
		/* 820A6C34h case    2:*/		return 0x820A6C38;
	}
	return 0x820A6C38;
} // Block from 820A6C2Ch-820A6C38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A6C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6C38);
		  /* 820A6C38h */ case    0:  		/* mfspr R12, LR */
		/* 820A6C38h case    0:*/		regs.R12 = regs.LR;
		/* 820A6C38h case    0:*/		return 0x820A6C3C;
		  /* 820A6C3Ch */ case    1:  		/* bl -88552 */
		/* 820A6C3Ch case    1:*/		regs.LR = 0x820A6C40; return 0x82091254;
		/* 820A6C3Ch case    1:*/		return 0x820A6C40;
		  /* 820A6C40h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820A6C40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820A6C40h case    2:*/		return 0x820A6C44;
		  /* 820A6C44h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820A6C44h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A6C44h case    3:*/		return 0x820A6C48;
		  /* 820A6C48h */ case    4:  		/* addi R10, R4, 3 */
		/* 820A6C48h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x3);
		/* 820A6C48h case    4:*/		return 0x820A6C4C;
		  /* 820A6C4Ch */ case    5:  		/* mr R29, R3 */
		/* 820A6C4Ch case    5:*/		regs.R29 = regs.R3;
		/* 820A6C4Ch case    5:*/		return 0x820A6C50;
		  /* 820A6C50h */ case    6:  		/* mr R28, R4 */
		/* 820A6C50h case    6:*/		regs.R28 = regs.R4;
		/* 820A6C50h case    6:*/		return 0x820A6C54;
		  /* 820A6C54h */ case    7:  		/* mr R27, R5 */
		/* 820A6C54h case    7:*/		regs.R27 = regs.R5;
		/* 820A6C54h case    7:*/		return 0x820A6C58;
		  /* 820A6C58h */ case    8:  		/* mr R31, R4 */
		/* 820A6C58h case    8:*/		regs.R31 = regs.R4;
		/* 820A6C58h case    8:*/		return 0x820A6C5C;
		  /* 820A6C5Ch */ case    9:  		/* cmplw CR6, R10, R11 */
		/* 820A6C5Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820A6C5Ch case    9:*/		return 0x820A6C60;
		  /* 820A6C60h */ case   10:  		/* bc 4, CR6_LT, 32 */
		/* 820A6C60h case   10:*/		if ( !regs.CR[6].lt ) { return 0x820A6C80;  }
		/* 820A6C60h case   10:*/		return 0x820A6C64;
		  /* 820A6C64h */ case   11:  		/* lbz R10, <#[R4]> */
		/* 820A6C64h case   11:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 820A6C64h case   11:*/		return 0x820A6C68;
		  /* 820A6C68h */ case   12:  		/* cmplwi CR6, R10, 58 */
		/* 820A6C68h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000003A);
		/* 820A6C68h case   12:*/		return 0x820A6C6C;
		  /* 820A6C6Ch */ case   13:  		/* bc 4, CR6_EQ, 20 */
		/* 820A6C6Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A6C80;  }
		/* 820A6C6Ch case   13:*/		return 0x820A6C70;
		  /* 820A6C70h */ case   14:  		/* lbz R10, <#[R4 + 1]> */
		/* 820A6C70h case   14:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000001) );
		/* 820A6C70h case   14:*/		return 0x820A6C74;
		  /* 820A6C74h */ case   15:  		/* cmplwi CR6, R10, 58 */
		/* 820A6C74h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000003A);
		/* 820A6C74h case   15:*/		return 0x820A6C78;
		  /* 820A6C78h */ case   16:  		/* bc 4, CR6_EQ, 8 */
		/* 820A6C78h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820A6C80;  }
		/* 820A6C78h case   16:*/		return 0x820A6C7C;
		  /* 820A6C7Ch */ case   17:  		/* addi R31, R4, 2 */
		/* 820A6C7Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R4,0x2);
		/* 820A6C7Ch case   17:*/		return 0x820A6C80;
	}
	return 0x820A6C80;
} // Block from 820A6C38h-820A6C80h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820A6C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6C80);
		  /* 820A6C80h */ case    0:  		/* cmplw CR6, R31, R11 */
		/* 820A6C80h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820A6C80h case    0:*/		return 0x820A6C84;
		  /* 820A6C84h */ case    1:  		/* bc 4, CR6_LT, 72 */
		/* 820A6C84h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820A6CCC;  }
		/* 820A6C84h case    1:*/		return 0x820A6C88;
		  /* 820A6C88h */ case    2:  		/* lbz R3, <#[R31]> */
		/* 820A6C88h case    2:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A6C88h case    2:*/		return 0x820A6C8C;
		  /* 820A6C8Ch */ case    3:  		/* bl -54684 */
		/* 820A6C8Ch case    3:*/		regs.LR = 0x820A6C90; return 0x820996F0;
		/* 820A6C8Ch case    3:*/		return 0x820A6C90;
		  /* 820A6C90h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820A6C90h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6C90h case    4:*/		return 0x820A6C94;
		  /* 820A6C94h */ case    5:  		/* bc 4, CR0_EQ, 96 */
		/* 820A6C94h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820A6CF4;  }
		/* 820A6C94h case    5:*/		return 0x820A6C98;
		  /* 820A6C98h */ case    6:  		/* lwz R11, <#[R29 + 68]> */
		/* 820A6C98h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000044) );
		/* 820A6C98h case    6:*/		return 0x820A6C9C;
		  /* 820A6C9Ch */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820A6C9Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A6C9Ch case    7:*/		return 0x820A6CA0;
		  /* 820A6CA0h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 820A6CA0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820A6CC0;  }
		/* 820A6CA0h case    8:*/		return 0x820A6CA4;
		  /* 820A6CA4h */ case    9:  		/* lwz R11, <#[R29 + 56]> */
		/* 820A6CA4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000038) );
		/* 820A6CA4h case    9:*/		return 0x820A6CA8;
		  /* 820A6CA8h */ case   10:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820A6CA8h case   10:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820A6CA8h case   10:*/		return 0x820A6CAC;
		  /* 820A6CACh */ case   11:  		/* bc 4, CR0_EQ, 20 */
		/* 820A6CACh case   11:*/		if ( !regs.CR[0].eq ) { return 0x820A6CC0;  }
		/* 820A6CACh case   11:*/		return 0x820A6CB0;
		  /* 820A6CB0h */ case   12:  		/* lbz R3, <#[R31]> */
		/* 820A6CB0h case   12:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A6CB0h case   12:*/		return 0x820A6CB4;
		  /* 820A6CB4h */ case   13:  		/* bl -54596 */
		/* 820A6CB4h case   13:*/		regs.LR = 0x820A6CB8; return 0x82099770;
		/* 820A6CB4h case   13:*/		return 0x820A6CB8;
		  /* 820A6CB8h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820A6CB8h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6CB8h case   14:*/		return 0x820A6CBC;
		  /* 820A6CBCh */ case   15:  		/* bc 4, CR0_EQ, 56 */
		/* 820A6CBCh case   15:*/		if ( !regs.CR[0].eq ) { return 0x820A6CF4;  }
		/* 820A6CBCh case   15:*/		return 0x820A6CC0;
	}
	return 0x820A6CC0;
} // Block from 820A6C80h-820A6CC0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A6CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6CC0);
		  /* 820A6CC0h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820A6CC0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A6CC0h case    0:*/		return 0x820A6CC4;
		  /* 820A6CC4h */ case    1:  		/* cmplwi CR6, R11, 95 */
		/* 820A6CC4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820A6CC4h case    1:*/		return 0x820A6CC8;
		  /* 820A6CC8h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 820A6CC8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A6CF4;  }
		/* 820A6CC8h case    2:*/		return 0x820A6CCC;
	}
	return 0x820A6CCC;
} // Block from 820A6CC0h-820A6CCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A6CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6CCC);
		  /* 820A6CCCh */ case    0:  		/* li R3, 0 */
		/* 820A6CCCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A6CCCh case    0:*/		return 0x820A6CD0;
		  /* 820A6CD0h */ case    1:  		/* addi R1, R1, 128 */
		/* 820A6CD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820A6CD0h case    1:*/		return 0x820A6CD4;
		  /* 820A6CD4h */ case    2:  		/* b -88624 */
		/* 820A6CD4h case    2:*/		return 0x820912A4;
		/* 820A6CD4h case    2:*/		return 0x820A6CD8;
		  /* 820A6CD8h */ case    3:  		/* lbz R3, <#[R31]> */
		/* 820A6CD8h case    3:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A6CD8h case    3:*/		return 0x820A6CDC;
		  /* 820A6CDCh */ case    4:  		/* bl -54636 */
		/* 820A6CDCh case    4:*/		regs.LR = 0x820A6CE0; return 0x82099770;
		/* 820A6CDCh case    4:*/		return 0x820A6CE0;
		  /* 820A6CE0h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820A6CE0h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6CE0h case    5:*/		return 0x820A6CE4;
		  /* 820A6CE4h */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 820A6CE4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820A6CF4;  }
		/* 820A6CE4h case    6:*/		return 0x820A6CE8;
		  /* 820A6CE8h */ case    7:  		/* lbz R11, <#[R31]> */
		/* 820A6CE8h case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A6CE8h case    7:*/		return 0x820A6CEC;
		  /* 820A6CECh */ case    8:  		/* cmplwi CR6, R11, 95 */
		/* 820A6CECh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820A6CECh case    8:*/		return 0x820A6CF0;
		  /* 820A6CF0h */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 820A6CF0h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A6D04;  }
		/* 820A6CF0h case    9:*/		return 0x820A6CF4;
	}
	return 0x820A6CF4;
} // Block from 820A6CCCh-820A6CF4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A6CF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6CF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6CF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6CF4);
		  /* 820A6CF4h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 820A6CF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820A6CF4h case    0:*/		return 0x820A6CF8;
		  /* 820A6CF8h */ case    1:  		/* addi R31, R31, 1 */
		/* 820A6CF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A6CF8h case    1:*/		return 0x820A6CFC;
		  /* 820A6CFCh */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 820A6CFCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820A6CFCh case    2:*/		return 0x820A6D00;
		  /* 820A6D00h */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 820A6D00h case    3:*/		if ( regs.CR[6].lt ) { return 0x820A6CD8;  }
		/* 820A6D00h case    3:*/		return 0x820A6D04;
	}
	return 0x820A6D04;
} // Block from 820A6CF4h-820A6D04h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A6D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6D04);
		  /* 820A6D04h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 820A6D04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820A6D04h case    0:*/		return 0x820A6D08;
		  /* 820A6D08h */ case    1:  		/* addi R30, R31, 2 */
		/* 820A6D08h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x2);
		/* 820A6D08h case    1:*/		return 0x820A6D0C;
		  /* 820A6D0Ch */ case    2:  		/* cmplw CR6, R30, R11 */
		/* 820A6D0Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A6D0Ch case    2:*/		return 0x820A6D10;
		  /* 820A6D10h */ case    3:  		/* bc 12, CR6_GT, 80 */
		/* 820A6D10h case    3:*/		if ( regs.CR[6].gt ) { return 0x820A6D60;  }
		/* 820A6D10h case    3:*/		return 0x820A6D14;
		  /* 820A6D14h */ case    4:  		/* lbz R10, <#[R31]> */
		/* 820A6D14h case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820A6D14h case    4:*/		return 0x820A6D18;
		  /* 820A6D18h */ case    5:  		/* cmplwi CR6, R10, 58 */
		/* 820A6D18h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000003A);
		/* 820A6D18h case    5:*/		return 0x820A6D1C;
		  /* 820A6D1Ch */ case    6:  		/* bc 4, CR6_EQ, 68 */
		/* 820A6D1Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A6D60;  }
		/* 820A6D1Ch case    6:*/		return 0x820A6D20;
		  /* 820A6D20h */ case    7:  		/* lbz R10, <#[R31 + 1]> */
		/* 820A6D20h case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000001) );
		/* 820A6D20h case    7:*/		return 0x820A6D24;
		  /* 820A6D24h */ case    8:  		/* cmplwi CR6, R10, 58 */
		/* 820A6D24h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000003A);
		/* 820A6D24h case    8:*/		return 0x820A6D28;
		  /* 820A6D28h */ case    9:  		/* bc 4, CR6_EQ, 56 */
		/* 820A6D28h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A6D60;  }
		/* 820A6D28h case    9:*/		return 0x820A6D2C;
		  /* 820A6D2Ch */ case   10:  		/* cmplw CR6, R30, R11 */
		/* 820A6D2Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A6D2Ch case   10:*/		return 0x820A6D30;
		  /* 820A6D30h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 820A6D30h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A6D50;  }
		/* 820A6D30h case   11:*/		return 0x820A6D34;
		  /* 820A6D34h */ case   12:  		/* lbz R3, <#[R30]> */
		/* 820A6D34h case   12:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A6D34h case   12:*/		return 0x820A6D38;
		  /* 820A6D38h */ case   13:  		/* bl -54728 */
		/* 820A6D38h case   13:*/		regs.LR = 0x820A6D3C; return 0x82099770;
		/* 820A6D38h case   13:*/		return 0x820A6D3C;
		  /* 820A6D3Ch */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820A6D3Ch case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6D3Ch case   14:*/		return 0x820A6D40;
		  /* 820A6D40h */ case   15:  		/* bc 4, CR0_EQ, 16 */
		/* 820A6D40h case   15:*/		if ( !regs.CR[0].eq ) { return 0x820A6D50;  }
		/* 820A6D40h case   15:*/		return 0x820A6D44;
		  /* 820A6D44h */ case   16:  		/* lbz R11, <#[R30]> */
		/* 820A6D44h case   16:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A6D44h case   16:*/		return 0x820A6D48;
		  /* 820A6D48h */ case   17:  		/* cmplwi CR6, R11, 95 */
		/* 820A6D48h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820A6D48h case   17:*/		return 0x820A6D4C;
		  /* 820A6D4Ch */ case   18:  		/* bc 4, CR6_EQ, 20 */
		/* 820A6D4Ch case   18:*/		if ( !regs.CR[6].eq ) { return 0x820A6D60;  }
		/* 820A6D4Ch case   18:*/		return 0x820A6D50;
	}
	return 0x820A6D50;
} // Block from 820A6D04h-820A6D50h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A6D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6D50);
		  /* 820A6D50h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 820A6D50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820A6D50h case    0:*/		return 0x820A6D54;
		  /* 820A6D54h */ case    1:  		/* mr R31, R30 */
		/* 820A6D54h case    1:*/		regs.R31 = regs.R30;
		/* 820A6D54h case    1:*/		return 0x820A6D58;
		  /* 820A6D58h */ case    2:  		/* cmplw CR6, R30, R11 */
		/* 820A6D58h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A6D58h case    2:*/		return 0x820A6D5C;
		  /* 820A6D5Ch */ case    3:  		/* bc 12, CR6_LT, -104 */
		/* 820A6D5Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820A6CF4;  }
		/* 820A6D5Ch case    3:*/		return 0x820A6D60;
	}
	return 0x820A6D60;
} // Block from 820A6D50h-820A6D60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A6D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6D60);
		  /* 820A6D60h */ case    0:  		/* subf R31, R28, R31 */
		/* 820A6D60h case    0:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R28,regs.R31);
		/* 820A6D60h case    0:*/		return 0x820A6D64;
		  /* 820A6D64h */ case    1:  		/* lwz R4, <#[R29 + 60]> */
		/* 820A6D64h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000003C) );
		/* 820A6D64h case    1:*/		return 0x820A6D68;
		  /* 820A6D68h */ case    2:  		/* mr R7, R27 */
		/* 820A6D68h case    2:*/		regs.R7 = regs.R27;
		/* 820A6D68h case    2:*/		return 0x820A6D6C;
		  /* 820A6D6Ch */ case    3:  		/* lwz R3, <#[R29 + 72]> */
		/* 820A6D6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000048) );
		/* 820A6D6Ch case    3:*/		return 0x820A6D70;
		  /* 820A6D70h */ case    4:  		/* mr R6, R28 */
		/* 820A6D70h case    4:*/		regs.R6 = regs.R28;
		/* 820A6D70h case    4:*/		return 0x820A6D74;
		  /* 820A6D74h */ case    5:  		/* mr R5, R31 */
		/* 820A6D74h case    5:*/		regs.R5 = regs.R31;
		/* 820A6D74h case    5:*/		return 0x820A6D78;
		  /* 820A6D78h */ case    6:  		/* bl -624 */
		/* 820A6D78h case    6:*/		regs.LR = 0x820A6D7C; return 0x820A6B08;
		/* 820A6D78h case    6:*/		return 0x820A6D7C;
		  /* 820A6D7Ch */ case    7:  		/* addic R11, R3, -1 */
		/* 820A6D7Ch case    7:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 820A6D7Ch case    7:*/		return 0x820A6D80;
		  /* 820A6D80h */ case    8:  		/* subfe R11, R11, R11 */
		/* 820A6D80h case    8:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820A6D80h case    8:*/		return 0x820A6D84;
		  /* 820A6D84h */ case    9:  		/* and R3, R11, R31 */
		/* 820A6D84h case    9:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R31);
		/* 820A6D84h case    9:*/		return 0x820A6D88;
		  /* 820A6D88h */ case   10:  		/* b -184 */
		/* 820A6D88h case   10:*/		return 0x820A6CD0;
		/* 820A6D88h case   10:*/		return 0x820A6D8C;
		  /* 820A6D8Ch */ case   11:  		/* nop */
		/* 820A6D8Ch case   11:*/		cpu::op::nop();
		/* 820A6D8Ch case   11:*/		return 0x820A6D90;
	}
	return 0x820A6D90;
} // Block from 820A6D60h-820A6D90h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A6D90h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6D90);
		  /* 820A6D90h */ case    0:  		/* mfspr R12, LR */
		/* 820A6D90h case    0:*/		regs.R12 = regs.LR;
		/* 820A6D90h case    0:*/		return 0x820A6D94;
		  /* 820A6D94h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A6D94h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A6D94h case    1:*/		return 0x820A6D98;
		  /* 820A6D98h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A6D98h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A6D98h case    2:*/		return 0x820A6D9C;
		  /* 820A6D9Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A6D9Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A6D9Ch case    3:*/		return 0x820A6DA0;
		  /* 820A6DA0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A6DA0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A6DA0h case    4:*/		return 0x820A6DA4;
		  /* 820A6DA4h */ case    5:  		/* mr R30, R5 */
		/* 820A6DA4h case    5:*/		regs.R30 = regs.R5;
		/* 820A6DA4h case    5:*/		return 0x820A6DA8;
		  /* 820A6DA8h */ case    6:  		/* addi R5, R1, 80 */
		/* 820A6DA8h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820A6DA8h case    6:*/		return 0x820A6DAC;
		  /* 820A6DACh */ case    7:  		/* mr R31, R3 */
		/* 820A6DACh case    7:*/		regs.R31 = regs.R3;
		/* 820A6DACh case    7:*/		return 0x820A6DB0;
		  /* 820A6DB0h */ case    8:  		/* bl -1416 */
		/* 820A6DB0h case    8:*/		regs.LR = 0x820A6DB4; return 0x820A6828;
		/* 820A6DB0h case    8:*/		return 0x820A6DB4;
		  /* 820A6DB4h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820A6DB4h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6DB4h case    9:*/		return 0x820A6DB8;
		  /* 820A6DB8h */ case   10:  		/* bc 12, CR0_LT, 108 */
		/* 820A6DB8h case   10:*/		if ( regs.CR[0].lt ) { return 0x820A6E24;  }
		/* 820A6DB8h case   10:*/		return 0x820A6DBC;
		  /* 820A6DBCh */ case   11:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A6DBCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A6DBCh case   11:*/		return 0x820A6DC0;
	}
	return 0x820A6DC0;
} // Block from 820A6D90h-820A6DC0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A6DC0h
// Function '?LexOperator@CTokenize@D3DXShader@@IAAIPBDPAD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6DC0);
		  /* 820A6DC0h */ case    0:  		/* cmplwi CR6, R30, 255 */
		/* 820A6DC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x000000FF);
		/* 820A6DC0h case    0:*/		return 0x820A6DC4;
		  /* 820A6DC4h */ case    1:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A6DC4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A6DC4h case    1:*/		return 0x820A6DC8;
		  /* 820A6DC8h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820A6DC8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820A6DC8h case    2:*/		return 0x820A6DCC;
		  /* 820A6DCCh */ case    3:  		/* bc 4, CR6_EQ, 32 */
		/* 820A6DCCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A6DEC;  }
		/* 820A6DCCh case    3:*/		return 0x820A6DD0;
		  /* 820A6DD0h */ case    4:  		/* lwzx R9, <#[R10 + R11]> */
		/* 820A6DD0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820A6DD0h case    4:*/		return 0x820A6DD4;
		  /* 820A6DD4h */ case    5:  		/* rlwinm R9, R9, 0, 26, 26 */
		/* 820A6DD4h case    5:*/		cpu::op::rlwinm<0,0,26,26>(regs,&regs.R9,regs.R9);
		/* 820A6DD4h case    5:*/		return 0x820A6DD8;
		  /* 820A6DD8h */ case    6:  		/* stwx R9, <#[R10 + R11]> */
		/* 820A6DD8h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820A6DD8h case    6:*/		return 0x820A6DDC;
		  /* 820A6DDCh */ case    7:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A6DDCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A6DDCh case    7:*/		return 0x820A6DE0;
		  /* 820A6DE0h */ case    8:  		/* lwzx R9, <#[R10 + R11]> */
		/* 820A6DE0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820A6DE0h case    8:*/		return 0x820A6DE4;
		  /* 820A6DE4h */ case    9:  		/* ori R9, R9, 1 */
		/* 820A6DE4h case    9:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A6DE4h case    9:*/		return 0x820A6DE8;
		  /* 820A6DE8h */ case   10:  		/* b 56 */
		/* 820A6DE8h case   10:*/		return 0x820A6E20;
		/* 820A6DE8h case   10:*/		return 0x820A6DEC;
	}
	return 0x820A6DEC;
} // Block from 820A6DC0h-820A6DECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A6DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6DEC);
		  /* 820A6DECh */ case    0:  		/* cmplwi CR6, R30, 16 */
		/* 820A6DECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000010);
		/* 820A6DECh case    0:*/		return 0x820A6DF0;
		  /* 820A6DF0h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 820A6DF0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A6E04;  }
		/* 820A6DF0h case    1:*/		return 0x820A6DF4;
		  /* 820A6DF4h */ case    2:  		/* lwzx R9, <#[R11 + R10]> */
		/* 820A6DF4h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820A6DF4h case    2:*/		return 0x820A6DF8;
		  /* 820A6DF8h */ case    3:  		/* ori R9, R9, 16 */
		/* 820A6DF8h case    3:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x10);
		/* 820A6DF8h case    3:*/		return 0x820A6DFC;
		  /* 820A6DFCh */ case    4:  		/* stwx R9, <#[R11 + R10]> */
		/* 820A6DFCh case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820A6DFCh case    4:*/		return 0x820A6E00;
		  /* 820A6E00h */ case    5:  		/* b 36 */
		/* 820A6E00h case    5:*/		return 0x820A6E24;
		/* 820A6E00h case    5:*/		return 0x820A6E04;
	}
	return 0x820A6E04;
} // Block from 820A6DECh-820A6E04h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A6E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6E04);
		  /* 820A6E04h */ case    0:  		/* lwzx R8, <#[R10 + R11]> */
		/* 820A6E04h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820A6E04h case    0:*/		return 0x820A6E08;
		  /* 820A6E08h */ case    1:  		/* rlwinm R9, R30, 0, 28, 31 */
		/* 820A6E08h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R30);
		/* 820A6E08h case    1:*/		return 0x820A6E0C;
		  /* 820A6E0Ch */ case    2:  		/* rlwinm R8, R8, 0, 0, 27 */
		/* 820A6E0Ch case    2:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R8,regs.R8);
		/* 820A6E0Ch case    2:*/		return 0x820A6E10;
		  /* 820A6E10h */ case    3:  		/* stwx R8, <#[R10 + R11]> */
		/* 820A6E10h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820A6E10h case    3:*/		return 0x820A6E14;
		  /* 820A6E14h */ case    4:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A6E14h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A6E14h case    4:*/		return 0x820A6E18;
		  /* 820A6E18h */ case    5:  		/* lwzx R8, <#[R10 + R11]> */
		/* 820A6E18h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820A6E18h case    5:*/		return 0x820A6E1C;
		  /* 820A6E1Ch */ case    6:  		/* or R9, R9, R8 */
		/* 820A6E1Ch case    6:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820A6E1Ch case    6:*/		return 0x820A6E20;
	}
	return 0x820A6E20;
} // Block from 820A6E04h-820A6E20h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A6E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6E20);
		  /* 820A6E20h */ case    0:  		/* stwx R9, <#[R10 + R11]> */
		/* 820A6E20h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820A6E20h case    0:*/		return 0x820A6E24;
	}
	return 0x820A6E24;
} // Block from 820A6E20h-820A6E24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6E24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6E24);
		  /* 820A6E24h */ case    0:  		/* addi R1, R1, 112 */
		/* 820A6E24h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A6E24h case    0:*/		return 0x820A6E28;
		  /* 820A6E28h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A6E28h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A6E28h case    1:*/		return 0x820A6E2C;
		  /* 820A6E2Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820A6E2Ch case    2:*/		regs.LR = regs.R12;
		/* 820A6E2Ch case    2:*/		return 0x820A6E30;
		  /* 820A6E30h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820A6E30h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A6E30h case    3:*/		return 0x820A6E34;
		  /* 820A6E34h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820A6E34h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A6E34h case    4:*/		return 0x820A6E38;
		  /* 820A6E38h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820A6E38h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A6E38h case    5:*/		return 0x820A6E3C;
	}
	return 0x820A6E3C;
} // Block from 820A6E24h-820A6E3Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A6E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6E3C);
		  /* 820A6E3Ch */ case    0:  		/* nop */
		/* 820A6E3Ch case    0:*/		cpu::op::nop();
		/* 820A6E3Ch case    0:*/		return 0x820A6E40;
	}
	return 0x820A6E40;
} // Block from 820A6E3Ch-820A6E40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A6E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6E40);
		  /* 820A6E40h */ case    0:  		/* mfspr R12, LR */
		/* 820A6E40h case    0:*/		regs.R12 = regs.LR;
		/* 820A6E40h case    0:*/		return 0x820A6E44;
		  /* 820A6E44h */ case    1:  		/* bl -89084 */
		/* 820A6E44h case    1:*/		regs.LR = 0x820A6E48; return 0x82091248;
		/* 820A6E44h case    1:*/		return 0x820A6E48;
		  /* 820A6E48h */ case    2:  		/* stwu R1, <#[R1 - 672]> */
		/* 820A6E48h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFD60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFD60);
		/* 820A6E48h case    2:*/		return 0x820A6E4C;
		  /* 820A6E4Ch */ case    3:  		/* mr R26, R3 */
		/* 820A6E4Ch case    3:*/		regs.R26 = regs.R3;
		/* 820A6E4Ch case    3:*/		return 0x820A6E50;
		  /* 820A6E50h */ case    4:  		/* mr R30, R4 */
		/* 820A6E50h case    4:*/		regs.R30 = regs.R4;
		/* 820A6E50h case    4:*/		return 0x820A6E54;
		  /* 820A6E54h */ case    5:  		/* mr R31, R5 */
		/* 820A6E54h case    5:*/		regs.R31 = regs.R5;
		/* 820A6E54h case    5:*/		return 0x820A6E58;
		  /* 820A6E58h */ case    6:  		/* mr R29, R6 */
		/* 820A6E58h case    6:*/		regs.R29 = regs.R6;
		/* 820A6E58h case    6:*/		return 0x820A6E5C;
		  /* 820A6E5Ch */ case    7:  		/* mr R28, R7 */
		/* 820A6E5Ch case    7:*/		regs.R28 = regs.R7;
		/* 820A6E5Ch case    7:*/		return 0x820A6E60;
		  /* 820A6E60h */ case    8:  		/* mr R25, R8 */
		/* 820A6E60h case    8:*/		regs.R25 = regs.R8;
		/* 820A6E60h case    8:*/		return 0x820A6E64;
		  /* 820A6E64h */ case    9:  		/* mr R27, R9 */
		/* 820A6E64h case    9:*/		regs.R27 = regs.R9;
		/* 820A6E64h case    9:*/		return 0x820A6E68;
		  /* 820A6E68h */ case   10:  		/* mr R24, R10 */
		/* 820A6E68h case   10:*/		regs.R24 = regs.R10;
		/* 820A6E68h case   10:*/		return 0x820A6E6C;
		  /* 820A6E6Ch */ case   11:  		/* cmplwi CR6, R6, 0 */
		/* 820A6E6Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820A6E6Ch case   11:*/		return 0x820A6E70;
		  /* 820A6E70h */ case   12:  		/* bc 12, CR6_EQ, 172 */
		/* 820A6E70h case   12:*/		if ( regs.CR[6].eq ) { return 0x820A6F1C;  }
		/* 820A6E70h case   12:*/		return 0x820A6E74;
		  /* 820A6E74h */ case   13:  		/* lwz R6, <#[R6 + 16]> */
		/* 820A6E74h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000010) );
		/* 820A6E74h case   13:*/		return 0x820A6E78;
		  /* 820A6E78h */ case   14:  		/* cmplwi CR6, R6, 0 */
		/* 820A6E78h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820A6E78h case   14:*/		return 0x820A6E7C;
		  /* 820A6E7Ch */ case   15:  		/* bc 12, CR6_EQ, 68 */
		/* 820A6E7Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820A6EC0;  }
		/* 820A6E7Ch case   15:*/		return 0x820A6E80;
		  /* 820A6E80h */ case   16:  		/* lis R11, -32255 */
		/* 820A6E80h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A6E80h case   16:*/		return 0x820A6E84;
		  /* 820A6E84h */ case   17:  		/* mr R3, R31 */
		/* 820A6E84h case   17:*/		regs.R3 = regs.R31;
		/* 820A6E84h case   17:*/		return 0x820A6E88;
		  /* 820A6E88h */ case   18:  		/* addi R5, R11, -10432 */
		/* 820A6E88h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFD740);
		/* 820A6E88h case   18:*/		return 0x820A6E8C;
		  /* 820A6E8Ch */ case   19:  		/* bl -18508 */
		/* 820A6E8Ch case   19:*/		regs.LR = 0x820A6E90; return 0x820A2640;
		/* 820A6E8Ch case   19:*/		return 0x820A6E90;
		  /* 820A6E90h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820A6E90h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6E90h case   20:*/		return 0x820A6E94;
		  /* 820A6E94h */ case   21:  		/* bc 12, CR0_LT, 468 */
		/* 820A6E94h case   21:*/		if ( regs.CR[0].lt ) { return 0x820A7068;  }
		/* 820A6E94h case   21:*/		return 0x820A6E98;
		  /* 820A6E98h */ case   22:  		/* mr R11, R31 */
		/* 820A6E98h case   22:*/		regs.R11 = regs.R31;
		/* 820A6E98h case   22:*/		return 0x820A6E9C;
		  /* 820A6E9Ch */ case   23:  		/* lbz R10, <#[R11]> */
		/* 820A6E9Ch case   23:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6E9Ch case   23:*/		return 0x820A6EA0;
		  /* 820A6EA0h */ case   24:  		/* addi R11, R11, 1 */
		/* 820A6EA0h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A6EA0h case   24:*/		return 0x820A6EA4;
		  /* 820A6EA4h */ case   25:  		/* cmplwi CR6, R10, 0 */
		/* 820A6EA4h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A6EA4h case   25:*/		return 0x820A6EA8;
		  /* 820A6EA8h */ case   26:  		/* bc 4, CR6_EQ, -12 */
		/* 820A6EA8h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820A6E9C;  }
		/* 820A6EA8h case   26:*/		return 0x820A6EAC;
		  /* 820A6EACh */ case   27:  		/* subf R11, R31, R11 */
		/* 820A6EACh case   27:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820A6EACh case   27:*/		return 0x820A6EB0;
		  /* 820A6EB0h */ case   28:  		/* addi R11, R11, -1 */
		/* 820A6EB0h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A6EB0h case   28:*/		return 0x820A6EB4;
		  /* 820A6EB4h */ case   29:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820A6EB4h case   29:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820A6EB4h case   29:*/		return 0x820A6EB8;
		  /* 820A6EB8h */ case   30:  		/* add R31, R11, R31 */
		/* 820A6EB8h case   30:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 820A6EB8h case   30:*/		return 0x820A6EBC;
		  /* 820A6EBCh */ case   31:  		/* subf R30, R11, R30 */
		/* 820A6EBCh case   31:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 820A6EBCh case   31:*/		return 0x820A6EC0;
	}
	return 0x820A6EC0;
} // Block from 820A6E40h-820A6EC0h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820A6EC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6EC0);
		  /* 820A6EC0h */ case    0:  		/* lwz R6, <#[R29 + 24]> */
		/* 820A6EC0h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000018) );
		/* 820A6EC0h case    0:*/		return 0x820A6EC4;
		  /* 820A6EC4h */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 820A6EC4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820A6EC4h case    1:*/		return 0x820A6EC8;
		  /* 820A6EC8h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820A6EC8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A6ED0;  }
		/* 820A6EC8h case    2:*/		return 0x820A6ECC;
		  /* 820A6ECCh */ case    3:  		/* li R6, 1 */
		/* 820A6ECCh case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820A6ECCh case    3:*/		return 0x820A6ED0;
	}
	return 0x820A6ED0;
} // Block from 820A6EC0h-820A6ED0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A6ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6ED0);
		  /* 820A6ED0h */ case    0:  		/* lwz R11, <#[R29 + 28]> */
		/* 820A6ED0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 820A6ED0h case    0:*/		return 0x820A6ED4;
		  /* 820A6ED4h */ case    1:  		/* lis R10, -32255 */
		/* 820A6ED4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A6ED4h case    1:*/		return 0x820A6ED8;
		  /* 820A6ED8h */ case    2:  		/* mr R4, R30 */
		/* 820A6ED8h case    2:*/		regs.R4 = regs.R30;
		/* 820A6ED8h case    2:*/		return 0x820A6EDC;
		  /* 820A6EDCh */ case    3:  		/* addi R5, R10, -9528 */
		/* 820A6EDCh case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFDAC8);
		/* 820A6EDCh case    3:*/		return 0x820A6EE0;
		  /* 820A6EE0h */ case    4:  		/* addi R7, R11, 1 */
		/* 820A6EE0h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x1);
		/* 820A6EE0h case    4:*/		return 0x820A6EE4;
		  /* 820A6EE4h */ case    5:  		/* mr R3, R31 */
		/* 820A6EE4h case    5:*/		regs.R3 = regs.R31;
		/* 820A6EE4h case    5:*/		return 0x820A6EE8;
		  /* 820A6EE8h */ case    6:  		/* bl -18600 */
		/* 820A6EE8h case    6:*/		regs.LR = 0x820A6EEC; return 0x820A2640;
		/* 820A6EE8h case    6:*/		return 0x820A6EEC;
		  /* 820A6EECh */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820A6EECh case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6EECh case    7:*/		return 0x820A6EF0;
		  /* 820A6EF0h */ case    8:  		/* bc 12, CR0_LT, 376 */
		/* 820A6EF0h case    8:*/		if ( regs.CR[0].lt ) { return 0x820A7068;  }
		/* 820A6EF0h case    8:*/		return 0x820A6EF4;
		  /* 820A6EF4h */ case    9:  		/* mr R11, R31 */
		/* 820A6EF4h case    9:*/		regs.R11 = regs.R31;
		/* 820A6EF4h case    9:*/		return 0x820A6EF8;
		  /* 820A6EF8h */ case   10:  		/* lbz R10, <#[R11]> */
		/* 820A6EF8h case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6EF8h case   10:*/		return 0x820A6EFC;
		  /* 820A6EFCh */ case   11:  		/* addi R11, R11, 1 */
		/* 820A6EFCh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A6EFCh case   11:*/		return 0x820A6F00;
		  /* 820A6F00h */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 820A6F00h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A6F00h case   12:*/		return 0x820A6F04;
		  /* 820A6F04h */ case   13:  		/* bc 4, CR6_EQ, -12 */
		/* 820A6F04h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A6EF8;  }
		/* 820A6F04h case   13:*/		return 0x820A6F08;
		  /* 820A6F08h */ case   14:  		/* subf R11, R31, R11 */
		/* 820A6F08h case   14:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820A6F08h case   14:*/		return 0x820A6F0C;
		  /* 820A6F0Ch */ case   15:  		/* addi R11, R11, -1 */
		/* 820A6F0Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A6F0Ch case   15:*/		return 0x820A6F10;
		  /* 820A6F10h */ case   16:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820A6F10h case   16:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820A6F10h case   16:*/		return 0x820A6F14;
		  /* 820A6F14h */ case   17:  		/* add R31, R11, R31 */
		/* 820A6F14h case   17:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 820A6F14h case   17:*/		return 0x820A6F18;
		  /* 820A6F18h */ case   18:  		/* subf R30, R11, R30 */
		/* 820A6F18h case   18:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 820A6F18h case   18:*/		return 0x820A6F1C;
	}
	return 0x820A6F1C;
} // Block from 820A6ED0h-820A6F1Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A6F1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6F1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6F1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6F1C);
		  /* 820A6F1Ch */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820A6F1Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820A6F1Ch case    0:*/		return 0x820A6F20;
		  /* 820A6F20h */ case    1:  		/* bc 12, CR6_EQ, 80 */
		/* 820A6F20h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A6F70;  }
		/* 820A6F20h case    1:*/		return 0x820A6F24;
		  /* 820A6F24h */ case    2:  		/* lis R11, -32255 */
		/* 820A6F24h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A6F24h case    2:*/		return 0x820A6F28;
		  /* 820A6F28h */ case    3:  		/* mr R7, R28 */
		/* 820A6F28h case    3:*/		regs.R7 = regs.R28;
		/* 820A6F28h case    3:*/		return 0x820A6F2C;
		  /* 820A6F2Ch */ case    4:  		/* addi R5, R11, -9540 */
		/* 820A6F2Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDABC);
		/* 820A6F2Ch case    4:*/		return 0x820A6F30;
		  /* 820A6F30h */ case    5:  		/* mr R6, R27 */
		/* 820A6F30h case    5:*/		regs.R6 = regs.R27;
		/* 820A6F30h case    5:*/		return 0x820A6F34;
		  /* 820A6F34h */ case    6:  		/* mr R4, R30 */
		/* 820A6F34h case    6:*/		regs.R4 = regs.R30;
		/* 820A6F34h case    6:*/		return 0x820A6F38;
		  /* 820A6F38h */ case    7:  		/* mr R3, R31 */
		/* 820A6F38h case    7:*/		regs.R3 = regs.R31;
		/* 820A6F38h case    7:*/		return 0x820A6F3C;
		  /* 820A6F3Ch */ case    8:  		/* bl -18684 */
		/* 820A6F3Ch case    8:*/		regs.LR = 0x820A6F40; return 0x820A2640;
		/* 820A6F3Ch case    8:*/		return 0x820A6F40;
		  /* 820A6F40h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820A6F40h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A6F40h case    9:*/		return 0x820A6F44;
		  /* 820A6F44h */ case   10:  		/* bc 12, CR0_LT, 292 */
		/* 820A6F44h case   10:*/		if ( regs.CR[0].lt ) { return 0x820A7068;  }
		/* 820A6F44h case   10:*/		return 0x820A6F48;
		  /* 820A6F48h */ case   11:  		/* mr R11, R31 */
		/* 820A6F48h case   11:*/		regs.R11 = regs.R31;
		/* 820A6F48h case   11:*/		return 0x820A6F4C;
		  /* 820A6F4Ch */ case   12:  		/* lbz R10, <#[R11]> */
		/* 820A6F4Ch case   12:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6F4Ch case   12:*/		return 0x820A6F50;
	}
	return 0x820A6F50;
} // Block from 820A6F1Ch-820A6F50h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A6F50h
// Function '?LexFloatSuffix@CTokenize@D3DXShader@@IAAIPBDPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6F50);
		  /* 820A6F50h */ case    0:  		/* addi R11, R11, 1 */
		/* 820A6F50h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A6F50h case    0:*/		return 0x820A6F54;
		  /* 820A6F54h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820A6F54h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A6F54h case    1:*/		return 0x820A6F58;
		  /* 820A6F58h */ case    2:  		/* bc 4, CR6_EQ, -12 */
		/* 820A6F58h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A6F4C;  }
		/* 820A6F58h case    2:*/		return 0x820A6F5C;
		  /* 820A6F5Ch */ case    3:  		/* subf R11, R31, R11 */
		/* 820A6F5Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820A6F5Ch case    3:*/		return 0x820A6F60;
		  /* 820A6F60h */ case    4:  		/* addi R11, R11, -1 */
		/* 820A6F60h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A6F60h case    4:*/		return 0x820A6F64;
		  /* 820A6F64h */ case    5:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820A6F64h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820A6F64h case    5:*/		return 0x820A6F68;
		  /* 820A6F68h */ case    6:  		/* add R31, R11, R31 */
		/* 820A6F68h case    6:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 820A6F68h case    6:*/		return 0x820A6F6C;
		  /* 820A6F6Ch */ case    7:  		/* subf R30, R11, R30 */
		/* 820A6F6Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 820A6F6Ch case    7:*/		return 0x820A6F70;
	}
	return 0x820A6F70;
} // Block from 820A6F50h-820A6F70h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A6F70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6F70);
		  /* 820A6F70h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 820A6F70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 820A6F70h case    0:*/		return 0x820A6F74;
		  /* 820A6F74h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A6F74h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A6F74h case    1:*/		return 0x820A6F78;
		  /* 820A6F78h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820A6F78h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A6FA0;  }
		/* 820A6F78h case    2:*/		return 0x820A6F7C;
		  /* 820A6F7Ch */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820A6F7Ch case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820A6F7Ch case    3:*/		return 0x820A6F80;
		  /* 820A6F80h */ case    4:  		/* mr R5, R30 */
		/* 820A6F80h case    4:*/		regs.R5 = regs.R30;
		/* 820A6F80h case    4:*/		return 0x820A6F84;
		  /* 820A6F84h */ case    5:  		/* mr R4, R31 */
		/* 820A6F84h case    5:*/		regs.R4 = regs.R31;
		/* 820A6F84h case    5:*/		return 0x820A6F88;
		  /* 820A6F88h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820A6F88h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A6F88h case    6:*/		return 0x820A6F8C;
		  /* 820A6F8Ch */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820A6F8Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A6F8Ch case    7:*/		return 0x820A6F90;
		  /* 820A6F90h */ case    8:  		/* mtspr CTR, R11 */
		/* 820A6F90h case    8:*/		regs.CTR = regs.R11;
		/* 820A6F90h case    8:*/		return 0x820A6F94;
		  /* 820A6F94h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820A6F94h case    9:*/		if ( 1 ) { regs.LR = 0x820A6F98; return (uint32)regs.CTR; }
		/* 820A6F94h case    9:*/		return 0x820A6F98;
		  /* 820A6F98h */ case   10:  		/* add R31, R3, R31 */
		/* 820A6F98h case   10:*/		cpu::op::add<0>(regs,&regs.R31,regs.R3,regs.R31);
		/* 820A6F98h case   10:*/		return 0x820A6F9C;
		  /* 820A6F9Ch */ case   11:  		/* subf R30, R3, R30 */
		/* 820A6F9Ch case   11:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R3,regs.R30);
		/* 820A6F9Ch case   11:*/		return 0x820A6FA0;
	}
	return 0x820A6FA0;
} // Block from 820A6F70h-820A6FA0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A6FA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6FA0);
		  /* 820A6FA0h */ case    0:  		/* li R4, 60 */
		/* 820A6FA0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x3C);
		/* 820A6FA0h case    0:*/		return 0x820A6FA4;
		  /* 820A6FA4h */ case    1:  		/* mr R3, R25 */
		/* 820A6FA4h case    1:*/		regs.R3 = regs.R25;
		/* 820A6FA4h case    1:*/		return 0x820A6FA8;
		  /* 820A6FA8h */ case    2:  		/* bl 1838808 */
		/* 820A6FA8h case    2:*/		regs.LR = 0x820A6FAC; return 0x82267E80;
		/* 820A6FA8h case    2:*/		return 0x820A6FAC;
		  /* 820A6FACh */ case    3:  		/* lis R11, 32767 */
		/* 820A6FACh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 820A6FACh case    3:*/		return 0x820A6FB0;
		  /* 820A6FB0h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820A6FB0h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A6FB0h case    4:*/		return 0x820A6FB4;
		  /* 820A6FB4h */ case    5:  		/* ori R29, R11, 65535 */
		/* 820A6FB4h case    5:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R11,0xFFFF);
		/* 820A6FB4h case    5:*/		return 0x820A6FB8;
		  /* 820A6FB8h */ case    6:  		/* bc 12, CR0_EQ, 128 */
		/* 820A6FB8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A7038;  }
		/* 820A6FB8h case    6:*/		return 0x820A6FBC;
		  /* 820A6FBCh */ case    7:  		/* lbz R10, <#[R3 + 1]> */
		/* 820A6FBCh case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000001) );
		/* 820A6FBCh case    7:*/		return 0x820A6FC0;
		  /* 820A6FC0h */ case    8:  		/* addi R11, R3, 1 */
		/* 820A6FC0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 820A6FC0h case    8:*/		return 0x820A6FC4;
		  /* 820A6FC4h */ case    9:  		/* cmplwi CR6, R10, 124 */
		/* 820A6FC4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 820A6FC4h case    9:*/		return 0x820A6FC8;
		  /* 820A6FC8h */ case   10:  		/* bc 12, CR6_EQ, 24 */
		/* 820A6FC8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A6FE0;  }
		/* 820A6FC8h case   10:*/		return 0x820A6FCC;
		  /* 820A6FCCh */ case   11:  		/* li R4, 60 */
		/* 820A6FCCh case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x3C);
		/* 820A6FCCh case   11:*/		return 0x820A6FD0;
		  /* 820A6FD0h */ case   12:  		/* mr R3, R11 */
		/* 820A6FD0h case   12:*/		regs.R3 = regs.R11;
		/* 820A6FD0h case   12:*/		return 0x820A6FD4;
		  /* 820A6FD4h */ case   13:  		/* bl 1838764 */
		/* 820A6FD4h case   13:*/		regs.LR = 0x820A6FD8; return 0x82267E80;
		/* 820A6FD4h case   13:*/		return 0x820A6FD8;
	}
	return 0x820A6FD8;
} // Block from 820A6FA0h-820A6FD8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A6FD8h
// Function '?LexIntegerSuffix@CTokenize@D3DXShader@@IAAIPBDPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6FD8);
		  /* 820A6FD8h */ case    0:  		/* cmplwi CR0, R3, 0 */
		/* 820A6FD8h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A6FD8h case    0:*/		return 0x820A6FDC;
		  /* 820A6FDCh */ case    1:  		/* bc 4, CR0_EQ, -32 */
		/* 820A6FDCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A6FBC;  }
		/* 820A6FDCh case    1:*/		return 0x820A6FE0;
	}
	return 0x820A6FE0;
} // Block from 820A6FD8h-820A6FE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A6FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A6FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A6FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A6FE0);
		  /* 820A6FE0h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820A6FE0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A6FE0h case    0:*/		return 0x820A6FE4;
		  /* 820A6FE4h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 820A6FE4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A7038;  }
		/* 820A6FE4h case    1:*/		return 0x820A6FE8;
		  /* 820A6FE8h */ case    2:  		/* cmplw CR6, R3, R25 */
		/* 820A6FE8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R25);
		/* 820A6FE8h case    2:*/		return 0x820A6FEC;
		  /* 820A6FECh */ case    3:  		/* bc 4, CR6_GT, 24 */
		/* 820A6FECh case    3:*/		if ( !regs.CR[6].gt ) { return 0x820A7004;  }
		/* 820A6FECh case    3:*/		return 0x820A6FF0;
		  /* 820A6FF0h */ case    4:  		/* lbz R10, <#[R3 - 1]> */
		/* 820A6FF0h case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R3 + 0xFFFFFFFF) );
		/* 820A6FF0h case    4:*/		return 0x820A6FF4;
		  /* 820A6FF4h */ case    5:  		/* addi R11, R3, -1 */
		/* 820A6FF4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 820A6FF4h case    5:*/		return 0x820A6FF8;
		  /* 820A6FF8h */ case    6:  		/* cmplwi CR6, R10, 32 */
		/* 820A6FF8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000020);
		/* 820A6FF8h case    6:*/		return 0x820A6FFC;
		  /* 820A6FFCh */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 820A6FFCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x820A7004;  }
		/* 820A6FFCh case    7:*/		return 0x820A7000;
		  /* 820A7000h */ case    8:  		/* mr R3, R11 */
		/* 820A7000h case    8:*/		regs.R3 = regs.R11;
		/* 820A7000h case    8:*/		return 0x820A7004;
	}
	return 0x820A7004;
} // Block from 820A6FE0h-820A7004h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A7004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7004);
		  /* 820A7004h */ case    0:  		/* subf R6, R25, R3 */
		/* 820A7004h case    0:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R25,regs.R3);
		/* 820A7004h case    0:*/		return 0x820A7008;
		  /* 820A7008h */ case    1:  		/* cmplw CR6, R6, R29 */
		/* 820A7008h case    1:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R29);
		/* 820A7008h case    1:*/		return 0x820A700C;
		  /* 820A700Ch */ case    2:  		/* bc 12, CR6_GT, 24 */
		/* 820A700Ch case    2:*/		if ( regs.CR[6].gt ) { return 0x820A7024;  }
		/* 820A700Ch case    2:*/		return 0x820A7010;
		  /* 820A7010h */ case    3:  		/* mr R5, R25 */
		/* 820A7010h case    3:*/		regs.R5 = regs.R25;
		/* 820A7010h case    3:*/		return 0x820A7014;
		  /* 820A7014h */ case    4:  		/* li R4, 520 */
		/* 820A7014h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x208);
		/* 820A7014h case    4:*/		return 0x820A7018;
		  /* 820A7018h */ case    5:  		/* addi R3, R1, 80 */
		/* 820A7018h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820A7018h case    5:*/		return 0x820A701C;
		  /* 820A701Ch */ case    6:  		/* bl -2252 */
		/* 820A701Ch case    6:*/		regs.LR = 0x820A7020; return 0x820A6750;
		/* 820A701Ch case    6:*/		return 0x820A7020;
		  /* 820A7020h */ case    7:  		/* b 12 */
		/* 820A7020h case    7:*/		return 0x820A702C;
		/* 820A7020h case    7:*/		return 0x820A7024;
	}
	return 0x820A7024;
} // Block from 820A7004h-820A7024h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A7024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7024);
		  /* 820A7024h */ case    0:  		/* lis R3, -32761 */
		/* 820A7024h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A7024h case    0:*/		return 0x820A7028;
		  /* 820A7028h */ case    1:  		/* ori R3, R3, 87 */
		/* 820A7028h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x57);
		/* 820A7028h case    1:*/		return 0x820A702C;
	}
	return 0x820A702C;
} // Block from 820A7024h-820A702Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A702Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A702C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A702C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A702C);
		  /* 820A702Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820A702Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820A702Ch case    0:*/		return 0x820A7030;
		  /* 820A7030h */ case    1:  		/* bc 12, CR6_LT, 56 */
		/* 820A7030h case    1:*/		if ( regs.CR[6].lt ) { return 0x820A7068;  }
		/* 820A7030h case    1:*/		return 0x820A7034;
		  /* 820A7034h */ case    2:  		/* addi R25, R1, 80 */
		/* 820A7034h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R1,0x50);
		/* 820A7034h case    2:*/		return 0x820A7038;
	}
	return 0x820A7038;
} // Block from 820A702Ch-820A7038h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7038);
		  /* 820A7038h */ case    0:  		/* cmplw CR6, R30, R29 */
		/* 820A7038h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 820A7038h case    0:*/		return 0x820A703C;
		  /* 820A703Ch */ case    1:  		/* bc 4, CR6_GT, 16 */
		/* 820A703Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x820A704C;  }
		/* 820A703Ch case    1:*/		return 0x820A7040;
		  /* 820A7040h */ case    2:  		/* lis R3, -32761 */
		/* 820A7040h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A7040h case    2:*/		return 0x820A7044;
		  /* 820A7044h */ case    3:  		/* ori R3, R3, 87 */
		/* 820A7044h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x57);
		/* 820A7044h case    3:*/		return 0x820A7048;
		  /* 820A7048h */ case    4:  		/* b 24 */
		/* 820A7048h case    4:*/		return 0x820A7060;
		/* 820A7048h case    4:*/		return 0x820A704C;
	}
	return 0x820A704C;
} // Block from 820A7038h-820A704Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A704Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A704C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A704C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A704C);
		  /* 820A704Ch */ case    0:  		/* mr R6, R24 */
		/* 820A704Ch case    0:*/		regs.R6 = regs.R24;
		/* 820A704Ch case    0:*/		return 0x820A7050;
		  /* 820A7050h */ case    1:  		/* mr R5, R25 */
		/* 820A7050h case    1:*/		regs.R5 = regs.R25;
		/* 820A7050h case    1:*/		return 0x820A7054;
		  /* 820A7054h */ case    2:  		/* mr R4, R30 */
		/* 820A7054h case    2:*/		regs.R4 = regs.R30;
		/* 820A7054h case    2:*/		return 0x820A7058;
		  /* 820A7058h */ case    3:  		/* mr R3, R31 */
		/* 820A7058h case    3:*/		regs.R3 = regs.R31;
		/* 820A7058h case    3:*/		return 0x820A705C;
		  /* 820A705Ch */ case    4:  		/* bl -33140 */
		/* 820A705Ch case    4:*/		regs.LR = 0x820A7060; return 0x8209EEE8;
		/* 820A705Ch case    4:*/		return 0x820A7060;
	}
	return 0x820A7060;
} // Block from 820A704Ch-820A7060h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A7060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7060);
		  /* 820A7060h */ case    0:  		/* srawi R11, R3, 31 */
		/* 820A7060h case    0:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820A7060h case    0:*/		return 0x820A7064;
		  /* 820A7064h */ case    1:  		/* and R3, R11, R3 */
		/* 820A7064h case    1:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820A7064h case    1:*/		return 0x820A7068;
	}
	return 0x820A7068;
} // Block from 820A7060h-820A7068h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7068);
		  /* 820A7068h */ case    0:  		/* addi R1, R1, 672 */
		/* 820A7068h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x2A0);
		/* 820A7068h case    0:*/		return 0x820A706C;
		  /* 820A706Ch */ case    1:  		/* b -89556 */
		/* 820A706Ch case    1:*/		return 0x82091298;
		/* 820A706Ch case    1:*/		return 0x820A7070;
	}
	return 0x820A7070;
} // Block from 820A7068h-820A7070h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7070);
		  /* 820A7070h */ case    0:  		/* mfspr R12, LR */
		/* 820A7070h case    0:*/		regs.R12 = regs.LR;
		/* 820A7070h case    0:*/		return 0x820A7074;
		  /* 820A7074h */ case    1:  		/* bl -89624 */
		/* 820A7074h case    1:*/		regs.LR = 0x820A7078; return 0x8209125C;
		/* 820A7074h case    1:*/		return 0x820A7078;
		  /* 820A7078h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820A7078h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820A7078h case    2:*/		return 0x820A707C;
		  /* 820A707Ch */ case    3:  		/* lis R11, 32767 */
		/* 820A707Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 820A707Ch case    3:*/		return 0x820A7080;
		  /* 820A7080h */ case    4:  		/* mr R30, R3 */
		/* 820A7080h case    4:*/		regs.R30 = regs.R3;
		/* 820A7080h case    4:*/		return 0x820A7084;
		  /* 820A7084h */ case    5:  		/* ori R11, R11, 65535 */
		/* 820A7084h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 820A7084h case    5:*/		return 0x820A7088;
		  /* 820A7088h */ case    6:  		/* mr R31, R4 */
		/* 820A7088h case    6:*/		regs.R31 = regs.R4;
		/* 820A7088h case    6:*/		return 0x820A708C;
		  /* 820A708Ch */ case    7:  		/* mr R29, R5 */
		/* 820A708Ch case    7:*/		regs.R29 = regs.R5;
		/* 820A708Ch case    7:*/		return 0x820A7090;
		  /* 820A7090h */ case    8:  		/* cmplw CR6, R4, R11 */
		/* 820A7090h case    8:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820A7090h case    8:*/		return 0x820A7094;
		  /* 820A7094h */ case    9:  		/* bc 4, CR6_GT, 16 */
		/* 820A7094h case    9:*/		if ( !regs.CR[6].gt ) { return 0x820A70A4;  }
		/* 820A7094h case    9:*/		return 0x820A7098;
		  /* 820A7098h */ case   10:  		/* lis R3, -32761 */
		/* 820A7098h case   10:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A7098h case   10:*/		return 0x820A709C;
		  /* 820A709Ch */ case   11:  		/* ori R3, R3, 87 */
		/* 820A709Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x57);
		/* 820A709Ch case   11:*/		return 0x820A70A0;
		  /* 820A70A0h */ case   12:  		/* b 48 */
		/* 820A70A0h case   12:*/		return 0x820A70D0;
		/* 820A70A0h case   12:*/		return 0x820A70A4;
	}
	return 0x820A70A4;
} // Block from 820A7070h-820A70A4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A70A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A70A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A70A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A70A4);
		  /* 820A70A4h */ case    0:  		/* addi R5, R1, 80 */
		/* 820A70A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820A70A4h case    0:*/		return 0x820A70A8;
		  /* 820A70A8h */ case    1:  		/* mr R4, R31 */
		/* 820A70A8h case    1:*/		regs.R4 = regs.R31;
		/* 820A70A8h case    1:*/		return 0x820A70AC;
		  /* 820A70ACh */ case    2:  		/* mr R3, R30 */
		/* 820A70ACh case    2:*/		regs.R3 = regs.R30;
		/* 820A70ACh case    2:*/		return 0x820A70B0;
		  /* 820A70B0h */ case    3:  		/* bl -25088 */
		/* 820A70B0h case    3:*/		regs.LR = 0x820A70B4; return 0x820A0EB0;
		/* 820A70B0h case    3:*/		return 0x820A70B4;
		  /* 820A70B4h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820A70B4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A70B4h case    4:*/		return 0x820A70B8;
		  /* 820A70B8h */ case    5:  		/* bc 12, CR0_LT, 24 */
		/* 820A70B8h case    5:*/		if ( regs.CR[0].lt ) { return 0x820A70D0;  }
		/* 820A70B8h case    5:*/		return 0x820A70BC;
		  /* 820A70BCh */ case    6:  		/* lwz R11, <#[R1 + 80]> */
		/* 820A70BCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A70BCh case    6:*/		return 0x820A70C0;
		  /* 820A70C0h */ case    7:  		/* mr R5, R29 */
		/* 820A70C0h case    7:*/		regs.R5 = regs.R29;
		/* 820A70C0h case    7:*/		return 0x820A70C4;
		  /* 820A70C4h */ case    8:  		/* subf R4, R11, R31 */
		/* 820A70C4h case    8:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R11,regs.R31);
		/* 820A70C4h case    8:*/		return 0x820A70C8;
		  /* 820A70C8h */ case    9:  		/* add R3, R11, R30 */
		/* 820A70C8h case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 820A70C8h case    9:*/		return 0x820A70CC;
		  /* 820A70CCh */ case   10:  		/* bl -2524 */
		/* 820A70CCh case   10:*/		regs.LR = 0x820A70D0; return 0x820A66F0;
		/* 820A70CCh case   10:*/		return 0x820A70D0;
	}
	return 0x820A70D0;
} // Block from 820A70A4h-820A70D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A70D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A70D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A70D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A70D0);
		  /* 820A70D0h */ case    0:  		/* addi R1, R1, 128 */
		/* 820A70D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820A70D0h case    0:*/		return 0x820A70D4;
		  /* 820A70D4h */ case    1:  		/* b -89640 */
		/* 820A70D4h case    1:*/		return 0x820912AC;
		/* 820A70D4h case    1:*/		return 0x820A70D8;
	}
	return 0x820A70D8;
} // Block from 820A70D0h-820A70D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A70D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A70D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A70D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A70D8);
		  /* 820A70D8h */ case    0:  		/* mfspr R12, LR */
		/* 820A70D8h case    0:*/		regs.R12 = regs.LR;
		/* 820A70D8h case    0:*/		return 0x820A70DC;
		  /* 820A70DCh */ case    1:  		/* bl -89736 */
		/* 820A70DCh case    1:*/		regs.LR = 0x820A70E0; return 0x82091254;
		/* 820A70DCh case    1:*/		return 0x820A70E0;
		  /* 820A70E0h */ case    2:  		/* ld R12, <#[R1 - 4096]> */
		/* 820A70E0h case    2:*/		cpu::mem::load64( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFF000) );
		/* 820A70E0h case    2:*/		return 0x820A70E4;
		  /* 820A70E4h */ case    3:  		/* stwu R1, <#[R1 - 4224]> */
		/* 820A70E4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFEF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFEF80);
		/* 820A70E4h case    3:*/		return 0x820A70E8;
		  /* 820A70E8h */ case    4:  		/* mr R31, R3 */
		/* 820A70E8h case    4:*/		regs.R31 = regs.R3;
		/* 820A70E8h case    4:*/		return 0x820A70EC;
		  /* 820A70ECh */ case    5:  		/* mr R30, R4 */
		/* 820A70ECh case    5:*/		regs.R30 = regs.R4;
		/* 820A70ECh case    5:*/		return 0x820A70F0;
		  /* 820A70F0h */ case    6:  		/* mr R29, R5 */
		/* 820A70F0h case    6:*/		regs.R29 = regs.R5;
		/* 820A70F0h case    6:*/		return 0x820A70F4;
		  /* 820A70F4h */ case    7:  		/* li R11, 0 */
		/* 820A70F4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A70F4h case    7:*/		return 0x820A70F8;
		  /* 820A70F8h */ case    8:  		/* li R5, 4095 */
		/* 820A70F8h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0xFFF);
		/* 820A70F8h case    8:*/		return 0x820A70FC;
		  /* 820A70FCh */ case    9:  		/* li R4, 0 */
		/* 820A70FCh case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A70FCh case    9:*/		return 0x820A7100;
		  /* 820A7100h */ case   10:  		/* stb R11, <#[R1 + 80]> */
		/* 820A7100h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A7100h case   10:*/		return 0x820A7104;
		  /* 820A7104h */ case   11:  		/* addi R3, R1, 81 */
		/* 820A7104h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x51);
		/* 820A7104h case   11:*/		return 0x820A7108;
		  /* 820A7108h */ case   12:  		/* mr R28, R6 */
		/* 820A7108h case   12:*/		regs.R28 = regs.R6;
		/* 820A7108h case   12:*/		return 0x820A710C;
		  /* 820A710Ch */ case   13:  		/* mr R27, R7 */
		/* 820A710Ch case   13:*/		regs.R27 = regs.R7;
		/* 820A710Ch case   13:*/		return 0x820A7110;
		  /* 820A7110h */ case   14:  		/* bl -89552 */
		/* 820A7110h case   14:*/		regs.LR = 0x820A7114; return 0x82091340;
		/* 820A7110h case   14:*/		return 0x820A7114;
		  /* 820A7114h */ case   15:  		/* lis R11, -32255 */
		/* 820A7114h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7114h case   15:*/		return 0x820A7118;
	}
	return 0x820A7118;
} // Block from 820A70D8h-820A7118h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A7118h
// Function '?StringCopyWorkerA@@YAJPADIPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7118);
		  /* 820A7118h */ case    0:  		/* mr R10, R27 */
		/* 820A7118h case    0:*/		regs.R10 = regs.R27;
		/* 820A7118h case    0:*/		return 0x820A711C;
		  /* 820A711Ch */ case    1:  		/* addi R9, R11, -10816 */
		/* 820A711Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFD5C0);
		/* 820A711Ch case    1:*/		return 0x820A7120;
		  /* 820A7120h */ case    2:  		/* mr R8, R28 */
		/* 820A7120h case    2:*/		regs.R8 = regs.R28;
		/* 820A7120h case    2:*/		return 0x820A7124;
		  /* 820A7124h */ case    3:  		/* mr R7, R29 */
		/* 820A7124h case    3:*/		regs.R7 = regs.R29;
		/* 820A7124h case    3:*/		return 0x820A7128;
		  /* 820A7128h */ case    4:  		/* mr R6, R30 */
		/* 820A7128h case    4:*/		regs.R6 = regs.R30;
		/* 820A7128h case    4:*/		return 0x820A712C;
		  /* 820A712Ch */ case    5:  		/* addi R5, R1, 80 */
		/* 820A712Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820A712Ch case    5:*/		return 0x820A7130;
		  /* 820A7130h */ case    6:  		/* li R4, 4096 */
		/* 820A7130h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1000);
		/* 820A7130h case    6:*/		return 0x820A7134;
		  /* 820A7134h */ case    7:  		/* mr R3, R31 */
		/* 820A7134h case    7:*/		regs.R3 = regs.R31;
		/* 820A7134h case    7:*/		return 0x820A7138;
		  /* 820A7138h */ case    8:  		/* bl -760 */
		/* 820A7138h case    8:*/		regs.LR = 0x820A713C; return 0x820A6E40;
		/* 820A7138h case    8:*/		return 0x820A713C;
		  /* 820A713Ch */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820A713Ch case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A713Ch case    9:*/		return 0x820A7140;
		  /* 820A7140h */ case   10:  		/* bc 12, CR0_LT, 32 */
		/* 820A7140h case   10:*/		if ( regs.CR[0].lt ) { return 0x820A7160;  }
		/* 820A7140h case   10:*/		return 0x820A7144;
		  /* 820A7144h */ case   11:  		/* lis R11, -32256 */
		/* 820A7144h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820A7144h case   11:*/		return 0x820A7148;
		  /* 820A7148h */ case   12:  		/* li R4, 4096 */
		/* 820A7148h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x1000);
		/* 820A7148h case   12:*/		return 0x820A714C;
		  /* 820A714Ch */ case   13:  		/* addi R5, R11, 17768 */
		/* 820A714Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x4568);
		/* 820A714Ch case   13:*/		return 0x820A7150;
		  /* 820A7150h */ case   14:  		/* addi R3, R1, 80 */
		/* 820A7150h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820A7150h case   14:*/		return 0x820A7154;
		  /* 820A7154h */ case   15:  		/* bl -228 */
		/* 820A7154h case   15:*/		regs.LR = 0x820A7158; return 0x820A7070;
		/* 820A7154h case   15:*/		return 0x820A7158;
		  /* 820A7158h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820A7158h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A7158h case   16:*/		return 0x820A715C;
		  /* 820A715Ch */ case   17:  		/* bc 4, CR0_LT, 16 */
		/* 820A715Ch case   17:*/		if ( !regs.CR[0].lt ) { return 0x820A716C;  }
		/* 820A715Ch case   17:*/		return 0x820A7160;
	}
	return 0x820A7160;
} // Block from 820A7118h-820A7160h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820A7160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7160);
		  /* 820A7160h */ case    0:  		/* lis R10, -32255 */
		/* 820A7160h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A7160h case    0:*/		return 0x820A7164;
		  /* 820A7164h */ case    1:  		/* addi R4, R10, -9516 */
		/* 820A7164h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFDAD4);
		/* 820A7164h case    1:*/		return 0x820A7168;
		  /* 820A7168h */ case    2:  		/* b 8 */
		/* 820A7168h case    2:*/		return 0x820A7170;
		/* 820A7168h case    2:*/		return 0x820A716C;
	}
	return 0x820A716C;
} // Block from 820A7160h-820A716Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A716Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A716C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A716C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A716C);
		  /* 820A716Ch */ case    0:  		/* addi R4, R1, 80 */
		/* 820A716Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820A716Ch case    0:*/		return 0x820A7170;
	}
	return 0x820A7170;
} // Block from 820A716Ch-820A7170h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7170);
		  /* 820A7170h */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 820A7170h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820A7170h case    0:*/		return 0x820A7174;
		  /* 820A7174h */ case    1:  		/* mr R3, R31 */
		/* 820A7174h case    1:*/		regs.R3 = regs.R31;
		/* 820A7174h case    1:*/		return 0x820A7178;
	}
	return 0x820A7178;
} // Block from 820A7170h-820A7178h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7178h
// Function '?StringCopyNWorkerA@@YAJPADIPBDI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7178);
		  /* 820A7178h */ case    0:  		/* addi R11, R11, 1 */
		/* 820A7178h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A7178h case    0:*/		return 0x820A717C;
		  /* 820A717Ch */ case    1:  		/* stw R11, <#[R31 + 28]> */
		/* 820A717Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820A717Ch case    1:*/		return 0x820A7180;
		  /* 820A7180h */ case    2:  		/* bl -1800 */
		/* 820A7180h case    2:*/		regs.LR = 0x820A7184; return 0x820A6A78;
		/* 820A7180h case    2:*/		return 0x820A7184;
		  /* 820A7184h */ case    3:  		/* addi R1, R1, 4224 */
		/* 820A7184h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1080);
		/* 820A7184h case    3:*/		return 0x820A7188;
		  /* 820A7188h */ case    4:  		/* b -89828 */
		/* 820A7188h case    4:*/		return 0x820912A4;
		/* 820A7188h case    4:*/		return 0x820A718C;
		  /* 820A718Ch */ case    5:  		/* nop */
		/* 820A718Ch case    5:*/		cpu::op::nop();
		/* 820A718Ch case    5:*/		return 0x820A7190;
	}
	return 0x820A7190;
} // Block from 820A7178h-820A7190h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A7190h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7190);
		  /* 820A7190h */ case    0:  		/* mfspr R12, LR */
		/* 820A7190h case    0:*/		regs.R12 = regs.LR;
		/* 820A7190h case    0:*/		return 0x820A7194;
		  /* 820A7194h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A7194h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A7194h case    1:*/		return 0x820A7198;
		  /* 820A7198h */ case    2:  		/* std R7, <#[R1 + 48]> */
		/* 820A7198h case    2:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820A7198h case    2:*/		return 0x820A719C;
		  /* 820A719Ch */ case    3:  		/* std R8, <#[R1 + 56]> */
		/* 820A719Ch case    3:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820A719Ch case    3:*/		return 0x820A71A0;
		  /* 820A71A0h */ case    4:  		/* std R9, <#[R1 + 64]> */
		/* 820A71A0h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820A71A0h case    4:*/		return 0x820A71A4;
		  /* 820A71A4h */ case    5:  		/* std R10, <#[R1 + 72]> */
		/* 820A71A4h case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820A71A4h case    5:*/		return 0x820A71A8;
		  /* 820A71A8h */ case    6:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A71A8h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A71A8h case    6:*/		return 0x820A71AC;
		  /* 820A71ACh */ case    7:  		/* stw R6, <#[R1 + 140]> */
		/* 820A71ACh case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000008C) );
		/* 820A71ACh case    7:*/		return 0x820A71B0;
		  /* 820A71B0h */ case    8:  		/* addi R11, R1, 80 */
		/* 820A71B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A71B0h case    8:*/		return 0x820A71B4;
		  /* 820A71B4h */ case    9:  		/* addi R10, R1, 144 */
		/* 820A71B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 820A71B4h case    9:*/		return 0x820A71B8;
		  /* 820A71B8h */ case   10:  		/* stw R10, <#[R11]> */
		/* 820A71B8h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A71B8h case   10:*/		return 0x820A71BC;
		  /* 820A71BCh */ case   11:  		/* lwz R7, <#[R1 + 80]> */
		/* 820A71BCh case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 820A71BCh case   11:*/		return 0x820A71C0;
		  /* 820A71C0h */ case   12:  		/* bl -232 */
		/* 820A71C0h case   12:*/		regs.LR = 0x820A71C4; return 0x820A70D8;
		/* 820A71C0h case   12:*/		return 0x820A71C4;
		  /* 820A71C4h */ case   13:  		/* addi R1, R1, 96 */
		/* 820A71C4h case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A71C4h case   13:*/		return 0x820A71C8;
		  /* 820A71C8h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A71C8h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A71C8h case   14:*/		return 0x820A71CC;
		  /* 820A71CCh */ case   15:  		/* mtspr LR, R12 */
		/* 820A71CCh case   15:*/		regs.LR = regs.R12;
		/* 820A71CCh case   15:*/		return 0x820A71D0;
		  /* 820A71D0h */ case   16:  		/* bclr 20, CR0_LT */
		/* 820A71D0h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A71D0h case   16:*/		return 0x820A71D4;
	}
	return 0x820A71D4;
} // Block from 820A7190h-820A71D4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A71D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A71D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A71D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A71D4);
		  /* 820A71D4h */ case    0:  		/* nop */
		/* 820A71D4h case    0:*/		cpu::op::nop();
		/* 820A71D4h case    0:*/		return 0x820A71D8;
	}
	return 0x820A71D8;
} // Block from 820A71D4h-820A71D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A71D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A71D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A71D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A71D8);
		  /* 820A71D8h */ case    0:  		/* mfspr R12, LR */
		/* 820A71D8h case    0:*/		regs.R12 = regs.LR;
		/* 820A71D8h case    0:*/		return 0x820A71DC;
		  /* 820A71DCh */ case    1:  		/* bl -90004 */
		/* 820A71DCh case    1:*/		regs.LR = 0x820A71E0; return 0x82091248;
		/* 820A71DCh case    1:*/		return 0x820A71E0;
		  /* 820A71E0h */ case    2:  		/* ld R12, <#[R1 - 4096]> */
		/* 820A71E0h case    2:*/		cpu::mem::load64( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFF000) );
		/* 820A71E0h case    2:*/		return 0x820A71E4;
		  /* 820A71E4h */ case    3:  		/* stwu R1, <#[R1 - 4320]> */
		/* 820A71E4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFEF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFEF20);
		/* 820A71E4h case    3:*/		return 0x820A71E8;
	}
	return 0x820A71E8;
} // Block from 820A71D8h-820A71E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A71E8h
// Function '??1CTErrors@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A71E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A71E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A71E8);
		  /* 820A71E8h */ case    0:  		/* mr R31, R3 */
		/* 820A71E8h case    0:*/		regs.R31 = regs.R3;
		/* 820A71E8h case    0:*/		return 0x820A71EC;
		  /* 820A71ECh */ case    1:  		/* mr R26, R4 */
		/* 820A71ECh case    1:*/		regs.R26 = regs.R4;
		/* 820A71ECh case    1:*/		return 0x820A71F0;
		  /* 820A71F0h */ case    2:  		/* mr R27, R5 */
		/* 820A71F0h case    2:*/		regs.R27 = regs.R5;
		/* 820A71F0h case    2:*/		return 0x820A71F4;
		  /* 820A71F4h */ case    3:  		/* li R11, 0 */
		/* 820A71F4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A71F4h case    3:*/		return 0x820A71F8;
		  /* 820A71F8h */ case    4:  		/* li R5, 4095 */
		/* 820A71F8h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0xFFF);
		/* 820A71F8h case    4:*/		return 0x820A71FC;
		  /* 820A71FCh */ case    5:  		/* li R4, 0 */
		/* 820A71FCh case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A71FCh case    5:*/		return 0x820A7200;
		  /* 820A7200h */ case    6:  		/* stb R11, <#[R1 + 144]> */
		/* 820A7200h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 820A7200h case    6:*/		return 0x820A7204;
		  /* 820A7204h */ case    7:  		/* addi R3, R1, 145 */
		/* 820A7204h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x91);
		/* 820A7204h case    7:*/		return 0x820A7208;
		  /* 820A7208h */ case    8:  		/* mr R25, R6 */
		/* 820A7208h case    8:*/		regs.R25 = regs.R6;
		/* 820A7208h case    8:*/		return 0x820A720C;
		  /* 820A720Ch */ case    9:  		/* mr R24, R7 */
		/* 820A720Ch case    9:*/		regs.R24 = regs.R7;
		/* 820A720Ch case    9:*/		return 0x820A7210;
		  /* 820A7210h */ case   10:  		/* bl -89808 */
		/* 820A7210h case   10:*/		regs.LR = 0x820A7214; return 0x82091340;
		/* 820A7210h case   10:*/		return 0x820A7214;
		  /* 820A7214h */ case   11:  		/* addi R5, R1, 128 */
		/* 820A7214h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 820A7214h case   11:*/		return 0x820A7218;
		  /* 820A7218h */ case   12:  		/* mr R4, R27 */
		/* 820A7218h case   12:*/		regs.R4 = regs.R27;
		/* 820A7218h case   12:*/		return 0x820A721C;
		  /* 820A721Ch */ case   13:  		/* mr R3, R31 */
		/* 820A721Ch case   13:*/		regs.R3 = regs.R31;
		/* 820A721Ch case   13:*/		return 0x820A7220;
		  /* 820A7220h */ case   14:  		/* bl -2552 */
		/* 820A7220h case   14:*/		regs.LR = 0x820A7224; return 0x820A6828;
		/* 820A7220h case   14:*/		return 0x820A7224;
		  /* 820A7224h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820A7224h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A7224h case   15:*/		return 0x820A7228;
		  /* 820A7228h */ case   16:  		/* bc 12, CR0_LT, 292 */
		/* 820A7228h case   16:*/		if ( regs.CR[0].lt ) { return 0x820A734C;  }
		/* 820A7228h case   16:*/		return 0x820A722C;
		  /* 820A722Ch */ case   17:  		/* lwz R11, <#[R1 + 128]> */
		/* 820A722Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820A722Ch case   17:*/		return 0x820A7230;
		  /* 820A7230h */ case   18:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A7230h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7230h case   18:*/		return 0x820A7234;
		  /* 820A7234h */ case   19:  		/* rlwinm R28, R11, 2, 0, 29 */
		/* 820A7234h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R11);
		/* 820A7234h case   19:*/		return 0x820A7238;
		  /* 820A7238h */ case   20:  		/* lbz R11, <#[R31 + 16]> */
		/* 820A7238h case   20:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820A7238h case   20:*/		return 0x820A723C;
		  /* 820A723Ch */ case   21:  		/* cmplwi CR0, R11, 0 */
		/* 820A723Ch case   21:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A723Ch case   21:*/		return 0x820A7240;
		  /* 820A7240h */ case   22:  		/* lwzx R11, <#[R10 + R28]> */
		/* 820A7240h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 820A7240h case   22:*/		return 0x820A7244;
		  /* 820A7244h */ case   23:  		/* rlwinm R29, R11, 0, 28, 31 */
		/* 820A7244h case   23:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R29,regs.R11);
		/* 820A7244h case   23:*/		return 0x820A7248;
		  /* 820A7248h */ case   24:  		/* bc 12, CR0_EQ, 44 */
		/* 820A7248h case   24:*/		if ( regs.CR[0].eq ) { return 0x820A7274;  }
		/* 820A7248h case   24:*/		return 0x820A724C;
		  /* 820A724Ch */ case   25:  		/* lwz R11, <#[R31 + 28]> */
		/* 820A724Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820A724Ch case   25:*/		return 0x820A7250;
	}
	return 0x820A7250;
} // Block from 820A71E8h-820A7250h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820A7250h
// Function '?Push@CTErrors@D3DXShader@@IAAJIPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7250);
		  /* 820A7250h */ case    0:  		/* li R29, 15 */
		/* 820A7250h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0xF);
		/* 820A7250h case    0:*/		return 0x820A7254;
		  /* 820A7254h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820A7254h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A7254h case    1:*/		return 0x820A7258;
		  /* 820A7258h */ case    2:  		/* bc 4, CR6_EQ, 36 */
		/* 820A7258h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820A727C;  }
		/* 820A7258h case    2:*/		return 0x820A725C;
		  /* 820A725Ch */ case    3:  		/* lis R11, -32255 */
		/* 820A725Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A725Ch case    3:*/		return 0x820A7260;
		  /* 820A7260h */ case    4:  		/* li R5, 3129 */
		/* 820A7260h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0xC39);
		/* 820A7260h case    4:*/		return 0x820A7264;
		  /* 820A7264h */ case    5:  		/* addi R6, R11, -9456 */
		/* 820A7264h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFDB10);
		/* 820A7264h case    5:*/		return 0x820A7268;
		  /* 820A7268h */ case    6:  		/* mr R4, R26 */
		/* 820A7268h case    6:*/		regs.R4 = regs.R26;
		/* 820A7268h case    6:*/		return 0x820A726C;
		  /* 820A726Ch */ case    7:  		/* mr R3, R31 */
		/* 820A726Ch case    7:*/		regs.R3 = regs.R31;
		/* 820A726Ch case    7:*/		return 0x820A7270;
		  /* 820A7270h */ case    8:  		/* bl -224 */
		/* 820A7270h case    8:*/		regs.LR = 0x820A7274; return 0x820A7190;
		/* 820A7270h case    8:*/		return 0x820A7274;
	}
	return 0x820A7274;
} // Block from 820A7250h-820A7274h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A7274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7274);
		  /* 820A7274h */ case    0:  		/* cmplwi CR6, R29, 15 */
		/* 820A7274h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000000F);
		/* 820A7274h case    0:*/		return 0x820A7278;
		  /* 820A7278h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 820A7278h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A728C;  }
		/* 820A7278h case    1:*/		return 0x820A727C;
	}
	return 0x820A727C;
} // Block from 820A7274h-820A727Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A727Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A727C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A727C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A727C);
		  /* 820A727Ch */ case    0:  		/* lis R11, -32255 */
		/* 820A727Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A727Ch case    0:*/		return 0x820A7280;
		  /* 820A7280h */ case    1:  		/* addi R30, R31, 28 */
		/* 820A7280h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x1C);
		/* 820A7280h case    1:*/		return 0x820A7284;
		  /* 820A7284h */ case    2:  		/* addi R9, R11, -10816 */
		/* 820A7284h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFD5C0);
		/* 820A7284h case    2:*/		return 0x820A7288;
		  /* 820A7288h */ case    3:  		/* b 84 */
		/* 820A7288h case    3:*/		return 0x820A72DC;
		/* 820A7288h case    3:*/		return 0x820A728C;
	}
	return 0x820A728C;
} // Block from 820A727Ch-820A728Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A728Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A728C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A728C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A728C);
		  /* 820A728Ch */ case    0:  		/* lwz R11, <#[R31 + 36]> */
		/* 820A728Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820A728Ch case    0:*/		return 0x820A7290;
		  /* 820A7290h */ case    1:  		/* lis R10, -32255 */
		/* 820A7290h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A7290h case    1:*/		return 0x820A7294;
		  /* 820A7294h */ case    2:  		/* addi R30, R31, 32 */
		/* 820A7294h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x20);
		/* 820A7294h case    2:*/		return 0x820A7298;
		  /* 820A7298h */ case    3:  		/* addi R9, R10, -10288 */
		/* 820A7298h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xFFFFD7D0);
		/* 820A7298h case    3:*/		return 0x820A729C;
		  /* 820A729Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820A729Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A729Ch case    4:*/		return 0x820A72A0;
		  /* 820A72A0h */ case    5:  		/* bc 12, CR6_EQ, 168 */
		/* 820A72A0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820A7348;  }
		/* 820A72A0h case    5:*/		return 0x820A72A4;
		  /* 820A72A4h */ case    6:  		/* cmplwi CR6, R29, 0 */
		/* 820A72A4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820A72A4h case    6:*/		return 0x820A72A8;
		  /* 820A72A8h */ case    7:  		/* bc 12, CR6_EQ, 160 */
		/* 820A72A8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A7348;  }
		/* 820A72A8h case    7:*/		return 0x820A72AC;
		  /* 820A72ACh */ case    8:  		/* cmplw CR6, R11, R29 */
		/* 820A72ACh case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820A72ACh case    8:*/		return 0x820A72B0;
		  /* 820A72B0h */ case    9:  		/* bc 12, CR6_LT, 152 */
		/* 820A72B0h case    9:*/		if ( regs.CR[6].lt ) { return 0x820A7348;  }
		/* 820A72B0h case    9:*/		return 0x820A72B4;
		  /* 820A72B4h */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 820A72B4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820A72B4h case   10:*/		return 0x820A72B8;
		  /* 820A72B8h */ case   11:  		/* lwzx R11, <#[R11 + R28]> */
		/* 820A72B8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 820A72B8h case   11:*/		return 0x820A72BC;
		  /* 820A72BCh */ case   12:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820A72BCh case   12:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820A72BCh case   12:*/		return 0x820A72C0;
		  /* 820A72C0h */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 820A72C0h case   13:*/		if ( regs.CR[0].eq ) { return 0x820A72CC;  }
		/* 820A72C0h case   13:*/		return 0x820A72C4;
		  /* 820A72C4h */ case   14:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820A72C4h case   14:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820A72C4h case   14:*/		return 0x820A72C8;
		  /* 820A72C8h */ case   15:  		/* bc 4, CR0_EQ, 128 */
		/* 820A72C8h case   15:*/		if ( !regs.CR[0].eq ) { return 0x820A7348;  }
		/* 820A72C8h case   15:*/		return 0x820A72CC;
	}
	return 0x820A72CC;
} // Block from 820A728Ch-820A72CCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A72CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A72CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A72CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A72CC);
		  /* 820A72CCh */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820A72CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820A72CCh case    0:*/		return 0x820A72D0;
		  /* 820A72D0h */ case    1:  		/* lwzx R10, <#[R11 + R28]> */
		/* 820A72D0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 820A72D0h case    1:*/		return 0x820A72D4;
		  /* 820A72D4h */ case    2:  		/* ori R10, R10, 32 */
		/* 820A72D4h case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x20);
		/* 820A72D4h case    2:*/		return 0x820A72D8;
		  /* 820A72D8h */ case    3:  		/* stwx R10, <#[R11 + R28]> */
		/* 820A72D8h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 820A72D8h case    3:*/		return 0x820A72DC;
	}
	return 0x820A72DC;
} // Block from 820A72CCh-820A72DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A72DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A72DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A72DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A72DC);
		  /* 820A72DCh */ case    0:  		/* mr R10, R24 */
		/* 820A72DCh case    0:*/		regs.R10 = regs.R24;
		/* 820A72DCh case    0:*/		return 0x820A72E0;
		  /* 820A72E0h */ case    1:  		/* mr R8, R25 */
		/* 820A72E0h case    1:*/		regs.R8 = regs.R25;
		/* 820A72E0h case    1:*/		return 0x820A72E4;
		  /* 820A72E4h */ case    2:  		/* mr R7, R27 */
		/* 820A72E4h case    2:*/		regs.R7 = regs.R27;
		/* 820A72E4h case    2:*/		return 0x820A72E8;
		  /* 820A72E8h */ case    3:  		/* mr R6, R26 */
		/* 820A72E8h case    3:*/		regs.R6 = regs.R26;
		/* 820A72E8h case    3:*/		return 0x820A72EC;
		  /* 820A72ECh */ case    4:  		/* addi R5, R1, 144 */
		/* 820A72ECh case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x90);
		/* 820A72ECh case    4:*/		return 0x820A72F0;
		  /* 820A72F0h */ case    5:  		/* li R4, 4096 */
		/* 820A72F0h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1000);
		/* 820A72F0h case    5:*/		return 0x820A72F4;
		  /* 820A72F4h */ case    6:  		/* mr R3, R31 */
		/* 820A72F4h case    6:*/		regs.R3 = regs.R31;
		/* 820A72F4h case    6:*/		return 0x820A72F8;
		  /* 820A72F8h */ case    7:  		/* bl -1208 */
		/* 820A72F8h case    7:*/		regs.LR = 0x820A72FC; return 0x820A6E40;
		/* 820A72F8h case    7:*/		return 0x820A72FC;
		  /* 820A72FCh */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820A72FCh case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A72FCh case    8:*/		return 0x820A7300;
		  /* 820A7300h */ case    9:  		/* bc 12, CR0_LT, 32 */
		/* 820A7300h case    9:*/		if ( regs.CR[0].lt ) { return 0x820A7320;  }
		/* 820A7300h case    9:*/		return 0x820A7304;
		  /* 820A7304h */ case   10:  		/* lis R11, -32256 */
		/* 820A7304h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820A7304h case   10:*/		return 0x820A7308;
		  /* 820A7308h */ case   11:  		/* li R4, 4096 */
		/* 820A7308h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x1000);
		/* 820A7308h case   11:*/		return 0x820A730C;
		  /* 820A730Ch */ case   12:  		/* addi R5, R11, 17768 */
		/* 820A730Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x4568);
		/* 820A730Ch case   12:*/		return 0x820A7310;
		  /* 820A7310h */ case   13:  		/* addi R3, R1, 144 */
		/* 820A7310h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x90);
		/* 820A7310h case   13:*/		return 0x820A7314;
		  /* 820A7314h */ case   14:  		/* bl -676 */
		/* 820A7314h case   14:*/		regs.LR = 0x820A7318; return 0x820A7070;
		/* 820A7314h case   14:*/		return 0x820A7318;
		  /* 820A7318h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820A7318h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A7318h case   15:*/		return 0x820A731C;
		  /* 820A731Ch */ case   16:  		/* bc 4, CR0_LT, 16 */
		/* 820A731Ch case   16:*/		if ( !regs.CR[0].lt ) { return 0x820A732C;  }
		/* 820A731Ch case   16:*/		return 0x820A7320;
	}
	return 0x820A7320;
} // Block from 820A72DCh-820A7320h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A7320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7320);
		  /* 820A7320h */ case    0:  		/* lis R10, -32255 */
		/* 820A7320h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A7320h case    0:*/		return 0x820A7324;
		  /* 820A7324h */ case    1:  		/* addi R4, R10, -9488 */
		/* 820A7324h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFDAF0);
		/* 820A7324h case    1:*/		return 0x820A7328;
		  /* 820A7328h */ case    2:  		/* b 8 */
		/* 820A7328h case    2:*/		return 0x820A7330;
		/* 820A7328h case    2:*/		return 0x820A732C;
	}
	return 0x820A732C;
} // Block from 820A7320h-820A732Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A732Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A732C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A732C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A732C);
		  /* 820A732Ch */ case    0:  		/* addi R4, R1, 144 */
		/* 820A732Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 820A732Ch case    0:*/		return 0x820A7330;
	}
	return 0x820A7330;
} // Block from 820A732Ch-820A7330h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7330);
		  /* 820A7330h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820A7330h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A7330h case    0:*/		return 0x820A7334;
		  /* 820A7334h */ case    1:  		/* mr R3, R31 */
		/* 820A7334h case    1:*/		regs.R3 = regs.R31;
		/* 820A7334h case    1:*/		return 0x820A7338;
		  /* 820A7338h */ case    2:  		/* addi R11, R11, 1 */
		/* 820A7338h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A7338h case    2:*/		return 0x820A733C;
		  /* 820A733Ch */ case    3:  		/* stw R11, <#[R30]> */
		/* 820A733Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A733Ch case    3:*/		return 0x820A7340;
		  /* 820A7340h */ case    4:  		/* bl -2248 */
		/* 820A7340h case    4:*/		regs.LR = 0x820A7344; return 0x820A6A78;
		/* 820A7340h case    4:*/		return 0x820A7344;
		  /* 820A7344h */ case    5:  		/* b 8 */
		/* 820A7344h case    5:*/		return 0x820A734C;
		/* 820A7344h case    5:*/		return 0x820A7348;
	}
	return 0x820A7348;
} // Block from 820A7330h-820A7348h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A7348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7348);
		  /* 820A7348h */ case    0:  		/* li R3, 0 */
		/* 820A7348h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A7348h case    0:*/		return 0x820A734C;
	}
	return 0x820A734C;
} // Block from 820A7348h-820A734Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A734Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A734C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A734C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A734C);
		  /* 820A734Ch */ case    0:  		/* addi R1, R1, 4320 */
		/* 820A734Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x10E0);
		/* 820A734Ch case    0:*/		return 0x820A7350;
		  /* 820A7350h */ case    1:  		/* b -90296 */
		/* 820A7350h case    1:*/		return 0x82091298;
		/* 820A7350h case    1:*/		return 0x820A7354;
		  /* 820A7354h */ case    2:  		/* nop */
		/* 820A7354h case    2:*/		cpu::op::nop();
		/* 820A7354h case    2:*/		return 0x820A7358;
	}
	return 0x820A7358;
} // Block from 820A734Ch-820A7358h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7358h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7358);
		  /* 820A7358h */ case    0:  		/* mfspr R12, LR */
		/* 820A7358h case    0:*/		regs.R12 = regs.LR;
		/* 820A7358h case    0:*/		return 0x820A735C;
		  /* 820A735Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A735Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A735Ch case    1:*/		return 0x820A7360;
		  /* 820A7360h */ case    2:  		/* std R7, <#[R1 + 48]> */
		/* 820A7360h case    2:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820A7360h case    2:*/		return 0x820A7364;
		  /* 820A7364h */ case    3:  		/* std R8, <#[R1 + 56]> */
		/* 820A7364h case    3:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820A7364h case    3:*/		return 0x820A7368;
		  /* 820A7368h */ case    4:  		/* std R9, <#[R1 + 64]> */
		/* 820A7368h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820A7368h case    4:*/		return 0x820A736C;
		  /* 820A736Ch */ case    5:  		/* std R10, <#[R1 + 72]> */
		/* 820A736Ch case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820A736Ch case    5:*/		return 0x820A7370;
		  /* 820A7370h */ case    6:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A7370h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A7370h case    6:*/		return 0x820A7374;
		  /* 820A7374h */ case    7:  		/* stw R6, <#[R1 + 140]> */
		/* 820A7374h case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000008C) );
		/* 820A7374h case    7:*/		return 0x820A7378;
		  /* 820A7378h */ case    8:  		/* addi R11, R1, 80 */
		/* 820A7378h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A7378h case    8:*/		return 0x820A737C;
		  /* 820A737Ch */ case    9:  		/* addi R10, R1, 144 */
		/* 820A737Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 820A737Ch case    9:*/		return 0x820A7380;
		  /* 820A7380h */ case   10:  		/* stw R10, <#[R11]> */
		/* 820A7380h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7380h case   10:*/		return 0x820A7384;
		  /* 820A7384h */ case   11:  		/* lwz R7, <#[R1 + 80]> */
		/* 820A7384h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 820A7384h case   11:*/		return 0x820A7388;
		  /* 820A7388h */ case   12:  		/* bl -432 */
		/* 820A7388h case   12:*/		regs.LR = 0x820A738C; return 0x820A71D8;
		/* 820A7388h case   12:*/		return 0x820A738C;
		  /* 820A738Ch */ case   13:  		/* addi R1, R1, 96 */
		/* 820A738Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A738Ch case   13:*/		return 0x820A7390;
		  /* 820A7390h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A7390h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A7390h case   14:*/		return 0x820A7394;
		  /* 820A7394h */ case   15:  		/* mtspr LR, R12 */
		/* 820A7394h case   15:*/		regs.LR = regs.R12;
		/* 820A7394h case   15:*/		return 0x820A7398;
		  /* 820A7398h */ case   16:  		/* bclr 20, CR0_LT */
		/* 820A7398h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A7398h case   16:*/		return 0x820A739C;
	}
	return 0x820A739C;
} // Block from 820A7358h-820A739Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A739Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A739C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A739C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A739C);
		  /* 820A739Ch */ case    0:  		/* nop */
		/* 820A739Ch case    0:*/		cpu::op::nop();
		/* 820A739Ch case    0:*/		return 0x820A73A0;
	}
	return 0x820A73A0;
} // Block from 820A739Ch-820A73A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A73A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A73A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A73A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A73A0);
		  /* 820A73A0h */ case    0:  		/* mfspr R12, LR */
		/* 820A73A0h case    0:*/		regs.R12 = regs.LR;
		/* 820A73A0h case    0:*/		return 0x820A73A4;
		  /* 820A73A4h */ case    1:  		/* bl -90440 */
		/* 820A73A4h case    1:*/		regs.LR = 0x820A73A8; return 0x8209125C;
		/* 820A73A4h case    1:*/		return 0x820A73A8;
		  /* 820A73A8h */ case    2:  		/* stwu R1, <#[R1 - 416]> */
		/* 820A73A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE60);
		/* 820A73A8h case    2:*/		return 0x820A73AC;
		  /* 820A73ACh */ case    3:  		/* lwz R11, <#[R5]> */
		/* 820A73ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820A73ACh case    3:*/		return 0x820A73B0;
		  /* 820A73B0h */ case    4:  		/* mr R30, R3 */
		/* 820A73B0h case    4:*/		regs.R30 = regs.R3;
		/* 820A73B0h case    4:*/		return 0x820A73B4;
		  /* 820A73B4h */ case    5:  		/* mr R29, R4 */
		/* 820A73B4h case    5:*/		regs.R29 = regs.R4;
		/* 820A73B4h case    5:*/		return 0x820A73B8;
		  /* 820A73B8h */ case    6:  		/* mr R31, R5 */
		/* 820A73B8h case    6:*/		regs.R31 = regs.R5;
		/* 820A73B8h case    6:*/		return 0x820A73BC;
		  /* 820A73BCh */ case    7:  		/* cmplwi CR6, R11, 17 */
		/* 820A73BCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000011);
		/* 820A73BCh case    7:*/		return 0x820A73C0;
		  /* 820A73C0h */ case    8:  		/* bc 12, CR6_GT, 360 */
		/* 820A73C0h case    8:*/		if ( regs.CR[6].gt ) { return 0x820A7528;  }
		/* 820A73C0h case    8:*/		return 0x820A73C4;
		  /* 820A73C4h */ case    9:  		/* lis R12, -32255 */
		/* 820A73C4h case    9:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820A73C4h case    9:*/		return 0x820A73C8;
		  /* 820A73C8h */ case   10:  		/* addi R12, R12, -9560 */
		/* 820A73C8h case   10:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFDAA8);
		/* 820A73C8h case   10:*/		return 0x820A73CC;
		  /* 820A73CCh */ case   11:  		/* lbzx R0, <#[R12 + R11]> */
		/* 820A73CCh case   11:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 820A73CCh case   11:*/		return 0x820A73D0;
		  /* 820A73D0h */ case   12:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 820A73D0h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 820A73D0h case   12:*/		return 0x820A73D4;
		  /* 820A73D4h */ case   13:  		/* lis R12, -32246 */
		/* 820A73D4h case   13:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820A);
		/* 820A73D4h case   13:*/		return 0x820A73D8;
		  /* 820A73D8h */ case   14:  		/* ori R0, R0, 0 */
		/* 820A73D8h case   14:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820A73D8h case   14:*/		return 0x820A73DC;
		  /* 820A73DCh */ case   15:  		/* addi R12, R12, 29676 */
		/* 820A73DCh case   15:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x73EC);
		/* 820A73DCh case   15:*/		return 0x820A73E0;
		  /* 820A73E0h */ case   16:  		/* add R12, R12, R0 */
		/* 820A73E0h case   16:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820A73E0h case   16:*/		return 0x820A73E4;
		  /* 820A73E4h */ case   17:  		/* mtspr CTR, R12 */
		/* 820A73E4h case   17:*/		regs.CTR = regs.R12;
		/* 820A73E4h case   17:*/		return 0x820A73E8;
		  /* 820A73E8h */ case   18:  		/* bcctr 20, CR0_LT */
		/* 820A73E8h case   18:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820A73E8h case   18:*/		return 0x820A73EC;
		  /* 820A73ECh */ case   19:  		/* lis R11, -32255 */
		/* 820A73ECh case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A73ECh case   19:*/		return 0x820A73F0;
		  /* 820A73F0h */ case   20:  		/* addi R5, R11, -9204 */
		/* 820A73F0h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDC0C);
		/* 820A73F0h case   20:*/		return 0x820A73F4;
		  /* 820A73F4h */ case   21:  		/* b 316 */
		/* 820A73F4h case   21:*/		return 0x820A7530;
		/* 820A73F4h case   21:*/		return 0x820A73F8;
		  /* 820A73F8h */ case   22:  		/* addi R6, R31, 8 */
		/* 820A73F8h case   22:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x8);
		/* 820A73F8h case   22:*/		return 0x820A73FC;
		  /* 820A73FCh */ case   23:  		/* lis R11, -32255 */
		/* 820A73FCh case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A73FCh case   23:*/		return 0x820A7400;
	}
	return 0x820A7400;
} // Block from 820A73A0h-820A7400h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820A7400h
// Function '?Clear@CTErrors@D3DXShader@@QAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7400);
		  /* 820A7400h */ case    0:  		/* addi R5, R11, -9216 */
		/* 820A7400h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDC00);
		/* 820A7400h case    0:*/		return 0x820A7404;
		  /* 820A7404h */ case    1:  		/* li R4, 256 */
		/* 820A7404h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 820A7404h case    1:*/		return 0x820A7408;
		  /* 820A7408h */ case    2:  		/* addi R3, R1, 128 */
		/* 820A7408h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 820A7408h case    2:*/		return 0x820A740C;
		  /* 820A740Ch */ case    3:  		/* bl -19916 */
		/* 820A740Ch case    3:*/		regs.LR = 0x820A7410; return 0x820A2640;
		/* 820A740Ch case    3:*/		return 0x820A7410;
		  /* 820A7410h */ case    4:  		/* b 300 */
		/* 820A7410h case    4:*/		return 0x820A753C;
		/* 820A7410h case    4:*/		return 0x820A7414;
		  /* 820A7414h */ case    5:  		/* lis R11, -32255 */
		/* 820A7414h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7414h case    5:*/		return 0x820A7418;
		  /* 820A7418h */ case    6:  		/* lwz R6, <#[R31 + 8]> */
		/* 820A7418h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7418h case    6:*/		return 0x820A741C;
		  /* 820A741Ch */ case    7:  		/* addi R5, R11, -9232 */
		/* 820A741Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDBF0);
		/* 820A741Ch case    7:*/		return 0x820A7420;
		  /* 820A7420h */ case    8:  		/* b -28 */
		/* 820A7420h case    8:*/		return 0x820A7404;
		/* 820A7420h case    8:*/		return 0x820A7424;
		  /* 820A7424h */ case    9:  		/* lis R11, -32255 */
		/* 820A7424h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7424h case    9:*/		return 0x820A7428;
		  /* 820A7428h */ case   10:  		/* lwz R6, <#[R31 + 8]> */
		/* 820A7428h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7428h case   10:*/		return 0x820A742C;
		  /* 820A742Ch */ case   11:  		/* addi R5, R11, -9248 */
		/* 820A742Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDBE0);
		/* 820A742Ch case   11:*/		return 0x820A7430;
		  /* 820A7430h */ case   12:  		/* b -44 */
		/* 820A7430h case   12:*/		return 0x820A7404;
		/* 820A7430h case   12:*/		return 0x820A7434;
		  /* 820A7434h */ case   13:  		/* lis R11, -32255 */
		/* 820A7434h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7434h case   13:*/		return 0x820A7438;
		  /* 820A7438h */ case   14:  		/* lwz R6, <#[R31 + 8]> */
		/* 820A7438h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7438h case   14:*/		return 0x820A743C;
		  /* 820A743Ch */ case   15:  		/* addi R5, R11, -9264 */
		/* 820A743Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDBD0);
		/* 820A743Ch case   15:*/		return 0x820A7440;
		  /* 820A7440h */ case   16:  		/* b -60 */
		/* 820A7440h case   16:*/		return 0x820A7404;
		/* 820A7440h case   16:*/		return 0x820A7444;
		  /* 820A7444h */ case   17:  		/* lis R11, -32255 */
		/* 820A7444h case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7444h case   17:*/		return 0x820A7448;
		  /* 820A7448h */ case   18:  		/* addi R5, R11, -9280 */
		/* 820A7448h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDBC0);
		/* 820A7448h case   18:*/		return 0x820A744C;
		  /* 820A744Ch */ case   19:  		/* li R4, 256 */
		/* 820A744Ch case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 820A744Ch case   19:*/		return 0x820A7450;
		  /* 820A7450h */ case   20:  		/* ld R6, <#[R31 + 8]> */
		/* 820A7450h case   20:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7450h case   20:*/		return 0x820A7454;
		  /* 820A7454h */ case   21:  		/* addi R3, R1, 128 */
		/* 820A7454h case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 820A7454h case   21:*/		return 0x820A7458;
		  /* 820A7458h */ case   22:  		/* bl -19992 */
		/* 820A7458h case   22:*/		regs.LR = 0x820A745C; return 0x820A2640;
		/* 820A7458h case   22:*/		return 0x820A745C;
		  /* 820A745Ch */ case   23:  		/* b 224 */
		/* 820A745Ch case   23:*/		return 0x820A753C;
		/* 820A745Ch case   23:*/		return 0x820A7460;
		  /* 820A7460h */ case   24:  		/* lis R11, -32255 */
		/* 820A7460h case   24:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7460h case   24:*/		return 0x820A7464;
		  /* 820A7464h */ case   25:  		/* addi R5, R11, -9300 */
		/* 820A7464h case   25:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDBAC);
		/* 820A7464h case   25:*/		return 0x820A7468;
		  /* 820A7468h */ case   26:  		/* b -28 */
		/* 820A7468h case   26:*/		return 0x820A744C;
		/* 820A7468h case   26:*/		return 0x820A746C;
		  /* 820A746Ch */ case   27:  		/* lfd FR1, <#[R31 + 8]> */
		/* 820A746Ch case   27:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R31 + 0x00000008) );
		/* 820A746Ch case   27:*/		return 0x820A7470;
		  /* 820A7470h */ case   28:  		/* lis R11, -32255 */
		/* 820A7470h case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7470h case   28:*/		return 0x820A7474;
		  /* 820A7474h */ case   29:  		/* stfd FR1, <#[R1 + 40]> */
		/* 820A7474h case   29:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000028) );
		/* 820A7474h case   29:*/		return 0x820A7478;
		  /* 820A7478h */ case   30:  		/* ld R6, <#[R1 + 40]> */
		/* 820A7478h case   30:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820A7478h case   30:*/		return 0x820A747C;
		  /* 820A747Ch */ case   31:  		/* addi R5, R11, -9312 */
		/* 820A747Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDBA0);
		/* 820A747Ch case   31:*/		return 0x820A7480;
		  /* 820A7480h */ case   32:  		/* li R4, 256 */
		/* 820A7480h case   32:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 820A7480h case   32:*/		return 0x820A7484;
		  /* 820A7484h */ case   33:  		/* addi R3, R1, 128 */
		/* 820A7484h case   33:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 820A7484h case   33:*/		return 0x820A7488;
		  /* 820A7488h */ case   34:  		/* bl -20040 */
		/* 820A7488h case   34:*/		regs.LR = 0x820A748C; return 0x820A2640;
		/* 820A7488h case   34:*/		return 0x820A748C;
		  /* 820A748Ch */ case   35:  		/* b 176 */
		/* 820A748Ch case   35:*/		return 0x820A753C;
		/* 820A748Ch case   35:*/		return 0x820A7490;
		  /* 820A7490h */ case   36:  		/* lfd FR1, <#[R31 + 8]> */
		/* 820A7490h case   36:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7490h case   36:*/		return 0x820A7494;
		  /* 820A7494h */ case   37:  		/* lis R11, -32255 */
		/* 820A7494h case   37:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7494h case   37:*/		return 0x820A7498;
		  /* 820A7498h */ case   38:  		/* stfd FR1, <#[R1 + 40]> */
		/* 820A7498h case   38:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000028) );
		/* 820A7498h case   38:*/		return 0x820A749C;
		  /* 820A749Ch */ case   39:  		/* ld R6, <#[R1 + 40]> */
		/* 820A749Ch case   39:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820A749Ch case   39:*/		return 0x820A74A0;
	}
	return 0x820A74A0;
} // Block from 820A7400h-820A74A0h (40 instructions)

//////////////////////////////////////////////////////
// Block at 820A74A0h
// Function '?PreformattedError@CTErrors@D3DXShader@@QAAJPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A74A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A74A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A74A0);
		  /* 820A74A0h */ case    0:  		/* li R4, 256 */
		/* 820A74A0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 820A74A0h case    0:*/		return 0x820A74A4;
		  /* 820A74A4h */ case    1:  		/* addi R5, R11, -9324 */
		/* 820A74A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDB94);
		/* 820A74A4h case    1:*/		return 0x820A74A8;
		  /* 820A74A8h */ case    2:  		/* addi R3, R1, 128 */
		/* 820A74A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 820A74A8h case    2:*/		return 0x820A74AC;
		  /* 820A74ACh */ case    3:  		/* bl -20076 */
		/* 820A74ACh case    3:*/		regs.LR = 0x820A74B0; return 0x820A2640;
		/* 820A74ACh case    3:*/		return 0x820A74B0;
		  /* 820A74B0h */ case    4:  		/* b 140 */
		/* 820A74B0h case    4:*/		return 0x820A753C;
		/* 820A74B0h case    4:*/		return 0x820A74B4;
		  /* 820A74B4h */ case    5:  		/* lfd FR1, <#[R31 + 8]> */
		/* 820A74B4h case    5:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R31 + 0x00000008) );
		/* 820A74B4h case    5:*/		return 0x820A74B8;
		  /* 820A74B8h */ case    6:  		/* lis R11, -32255 */
		/* 820A74B8h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A74B8h case    6:*/		return 0x820A74BC;
		  /* 820A74BCh */ case    7:  		/* stfd FR1, <#[R1 + 40]> */
		/* 820A74BCh case    7:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000028) );
		/* 820A74BCh case    7:*/		return 0x820A74C0;
		  /* 820A74C0h */ case    8:  		/* li R4, 256 */
		/* 820A74C0h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 820A74C0h case    8:*/		return 0x820A74C4;
		  /* 820A74C4h */ case    9:  		/* addi R5, R11, -9336 */
		/* 820A74C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDB88);
		/* 820A74C4h case    9:*/		return 0x820A74C8;
		  /* 820A74C8h */ case   10:  		/* addi R3, R1, 128 */
		/* 820A74C8h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 820A74C8h case   10:*/		return 0x820A74CC;
		  /* 820A74CCh */ case   11:  		/* ld R6, <#[R1 + 40]> */
		/* 820A74CCh case   11:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820A74CCh case   11:*/		return 0x820A74D0;
		  /* 820A74D0h */ case   12:  		/* bl -20112 */
		/* 820A74D0h case   12:*/		regs.LR = 0x820A74D4; return 0x820A2640;
		/* 820A74D0h case   12:*/		return 0x820A74D4;
		  /* 820A74D4h */ case   13:  		/* b 104 */
		/* 820A74D4h case   13:*/		return 0x820A753C;
		/* 820A74D4h case   13:*/		return 0x820A74D8;
		  /* 820A74D8h */ case   14:  		/* lfd FR1, <#[R31 + 8]> */
		/* 820A74D8h case   14:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R31 + 0x00000008) );
		/* 820A74D8h case   14:*/		return 0x820A74DC;
		  /* 820A74DCh */ case   15:  		/* lis R11, -32255 */
		/* 820A74DCh case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A74DCh case   15:*/		return 0x820A74E0;
		  /* 820A74E0h */ case   16:  		/* stfd FR1, <#[R1 + 40]> */
		/* 820A74E0h case   16:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000028) );
		/* 820A74E0h case   16:*/		return 0x820A74E4;
		  /* 820A74E4h */ case   17:  		/* li R4, 256 */
		/* 820A74E4h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 820A74E4h case   17:*/		return 0x820A74E8;
		  /* 820A74E8h */ case   18:  		/* addi R5, R11, -9348 */
		/* 820A74E8h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDB7C);
		/* 820A74E8h case   18:*/		return 0x820A74EC;
		  /* 820A74ECh */ case   19:  		/* addi R3, R1, 128 */
		/* 820A74ECh case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 820A74ECh case   19:*/		return 0x820A74F0;
		  /* 820A74F0h */ case   20:  		/* ld R6, <#[R1 + 40]> */
		/* 820A74F0h case   20:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820A74F0h case   20:*/		return 0x820A74F4;
		  /* 820A74F4h */ case   21:  		/* bl -20148 */
		/* 820A74F4h case   21:*/		regs.LR = 0x820A74F8; return 0x820A2640;
		/* 820A74F4h case   21:*/		return 0x820A74F8;
		  /* 820A74F8h */ case   22:  		/* b 68 */
		/* 820A74F8h case   22:*/		return 0x820A753C;
		/* 820A74F8h case   22:*/		return 0x820A74FC;
		  /* 820A74FCh */ case   23:  		/* lwz R6, <#[R31 + 8]> */
		/* 820A74FCh case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 820A74FCh case   23:*/		return 0x820A7500;
		  /* 820A7500h */ case   24:  		/* b -260 */
		/* 820A7500h case   24:*/		return 0x820A73FC;
		/* 820A7500h case   24:*/		return 0x820A7504;
		  /* 820A7504h */ case   25:  		/* lis R11, -32255 */
		/* 820A7504h case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7504h case   25:*/		return 0x820A7508;
		  /* 820A7508h */ case   26:  		/* addi R5, R11, -9364 */
		/* 820A7508h case   26:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDB6C);
		/* 820A7508h case   26:*/		return 0x820A750C;
		  /* 820A750Ch */ case   27:  		/* b 36 */
		/* 820A750Ch case   27:*/		return 0x820A7530;
		/* 820A750Ch case   27:*/		return 0x820A7510;
		  /* 820A7510h */ case   28:  		/* lis R11, -32255 */
		/* 820A7510h case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7510h case   28:*/		return 0x820A7514;
		  /* 820A7514h */ case   29:  		/* addi R5, R11, -9376 */
		/* 820A7514h case   29:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDB60);
		/* 820A7514h case   29:*/		return 0x820A7518;
		  /* 820A7518h */ case   30:  		/* b 24 */
		/* 820A7518h case   30:*/		return 0x820A7530;
		/* 820A7518h case   30:*/		return 0x820A751C;
		  /* 820A751Ch */ case   31:  		/* lis R11, -32255 */
		/* 820A751Ch case   31:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A751Ch case   31:*/		return 0x820A7520;
		  /* 820A7520h */ case   32:  		/* addi R5, R11, -9388 */
		/* 820A7520h case   32:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDB54);
		/* 820A7520h case   32:*/		return 0x820A7524;
		  /* 820A7524h */ case   33:  		/* b 12 */
		/* 820A7524h case   33:*/		return 0x820A7530;
		/* 820A7524h case   33:*/		return 0x820A7528;
	}
	return 0x820A7528;
} // Block from 820A74A0h-820A7528h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820A7528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7528);
		  /* 820A7528h */ case    0:  		/* lis R11, -32255 */
		/* 820A7528h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7528h case    0:*/		return 0x820A752C;
		  /* 820A752Ch */ case    1:  		/* addi R5, R11, -9396 */
		/* 820A752Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDB4C);
		/* 820A752Ch case    1:*/		return 0x820A7530;
	}
	return 0x820A7530;
} // Block from 820A7528h-820A7530h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7530h
// Function '?Add@CTokStringTable@D3DXShader@@QAAJPAVCAlloc@D3DXCore@@IPBDPAPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7530);
		  /* 820A7530h */ case    0:  		/* li R4, 256 */
		/* 820A7530h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 820A7530h case    0:*/		return 0x820A7534;
		  /* 820A7534h */ case    1:  		/* addi R3, R1, 128 */
		/* 820A7534h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 820A7534h case    1:*/		return 0x820A7538;
		  /* 820A7538h */ case    2:  		/* bl -20216 */
		/* 820A7538h case    2:*/		regs.LR = 0x820A753C; return 0x820A2640;
		/* 820A7538h case    2:*/		return 0x820A753C;
	}
	return 0x820A753C;
} // Block from 820A7530h-820A753Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A753Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A753C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A753C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A753C);
		  /* 820A753Ch */ case    0:  		/* lis R11, -32255 */
		/* 820A753Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A753Ch case    0:*/		return 0x820A7540;
		  /* 820A7540h */ case    1:  		/* addi R7, R1, 128 */
		/* 820A7540h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x80);
		/* 820A7540h case    1:*/		return 0x820A7544;
		  /* 820A7544h */ case    2:  		/* addi R6, R11, -9428 */
		/* 820A7544h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFDB2C);
		/* 820A7544h case    2:*/		return 0x820A7548;
		  /* 820A7548h */ case    3:  		/* mr R5, R29 */
		/* 820A7548h case    3:*/		regs.R5 = regs.R29;
		/* 820A7548h case    3:*/		return 0x820A754C;
		  /* 820A754Ch */ case    4:  		/* mr R4, R31 */
		/* 820A754Ch case    4:*/		regs.R4 = regs.R31;
		/* 820A754Ch case    4:*/		return 0x820A7550;
		  /* 820A7550h */ case    5:  		/* mr R3, R30 */
		/* 820A7550h case    5:*/		regs.R3 = regs.R30;
		/* 820A7550h case    5:*/		return 0x820A7554;
		  /* 820A7554h */ case    6:  		/* bl -964 */
		/* 820A7554h case    6:*/		regs.LR = 0x820A7558; return 0x820A7190;
		/* 820A7554h case    6:*/		return 0x820A7558;
		  /* 820A7558h */ case    7:  		/* addi R1, R1, 416 */
		/* 820A7558h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1A0);
		/* 820A7558h case    7:*/		return 0x820A755C;
		  /* 820A755Ch */ case    8:  		/* b -90800 */
		/* 820A755Ch case    8:*/		return 0x820912AC;
		/* 820A755Ch case    8:*/		return 0x820A7560;
	}
	return 0x820A7560;
} // Block from 820A753Ch-820A7560h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A7560h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7560);
		  /* 820A7560h */ case    0:  		/* mfspr R12, LR */
		/* 820A7560h case    0:*/		regs.R12 = regs.LR;
		/* 820A7560h case    0:*/		return 0x820A7564;
		  /* 820A7564h */ case    1:  		/* bl -90888 */
		/* 820A7564h case    1:*/		regs.LR = 0x820A7568; return 0x8209125C;
		/* 820A7564h case    1:*/		return 0x820A7568;
		  /* 820A7568h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820A7568h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820A7568h case    2:*/		return 0x820A756C;
		  /* 820A756Ch */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820A756Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A756Ch case    3:*/		return 0x820A7570;
		  /* 820A7570h */ case    4:  		/* mr R31, R3 */
		/* 820A7570h case    4:*/		regs.R31 = regs.R3;
		/* 820A7570h case    4:*/		return 0x820A7574;
		  /* 820A7574h */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 820A7574h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820A7574h case    5:*/		return 0x820A7578;
		  /* 820A7578h */ case    6:  		/* mr R30, R4 */
		/* 820A7578h case    6:*/		regs.R30 = regs.R4;
		/* 820A7578h case    6:*/		return 0x820A757C;
		  /* 820A757Ch */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820A757Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A757Ch case    7:*/		return 0x820A7580;
		  /* 820A7580h */ case    8:  		/* bc 4, CR6_LT, 308 */
		/* 820A7580h case    8:*/		if ( !regs.CR[6].lt ) { return 0x820A76B4;  }
		/* 820A7580h case    8:*/		return 0x820A7584;
		  /* 820A7584h */ case    9:  		/* lis R11, -32255 */
		/* 820A7584h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7584h case    9:*/		return 0x820A7588;
		  /* 820A7588h */ case   10:  		/* addi R29, R11, -9184 */
		/* 820A7588h case   10:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFDC20);
		/* 820A7588h case   10:*/		return 0x820A758C;
		  /* 820A758Ch */ case   11:  		/* lwz R11, <#[R31]> */
		/* 820A758Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A758Ch case   11:*/		return 0x820A7590;
		  /* 820A7590h */ case   12:  		/* lbz R10, <#[R11]> */
		/* 820A7590h case   12:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7590h case   12:*/		return 0x820A7594;
		  /* 820A7594h */ case   13:  		/* extsb R9, R10 */
		/* 820A7594h case   13:*/		cpu::op::extsb<0>(regs,&regs.R9,regs.R10);
		/* 820A7594h case   13:*/		return 0x820A7598;
		  /* 820A7598h */ case   14:  		/* cmpwi CR6, R9, 10 */
		/* 820A7598h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000A);
		/* 820A7598h case   14:*/		return 0x820A759C;
		  /* 820A759Ch */ case   15:  		/* bc 12, CR6_EQ, 292 */
		/* 820A759Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820A76C0;  }
		/* 820A759Ch case   15:*/		return 0x820A75A0;
		  /* 820A75A0h */ case   16:  		/* cmpwi CR6, R9, 92 */
		/* 820A75A0h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000005C);
		/* 820A75A0h case   16:*/		return 0x820A75A4;
		  /* 820A75A4h */ case   17:  		/* bc 4, CR6_EQ, 180 */
		/* 820A75A4h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820A7658;  }
		/* 820A75A4h case   17:*/		return 0x820A75A8;
		  /* 820A75A8h */ case   18:  		/* lwz R8, <#[R31 + 8]> */
		/* 820A75A8h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 820A75A8h case   18:*/		return 0x820A75AC;
		  /* 820A75ACh */ case   19:  		/* addi R10, R11, 1 */
		/* 820A75ACh case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 820A75ACh case   19:*/		return 0x820A75B0;
		  /* 820A75B0h */ case   20:  		/* cmplw CR6, R10, R8 */
		/* 820A75B0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820A75B0h case   20:*/		return 0x820A75B4;
		  /* 820A75B4h */ case   21:  		/* bc 4, CR6_LT, 72 */
		/* 820A75B4h case   21:*/		if ( !regs.CR[6].lt ) { return 0x820A75FC;  }
		/* 820A75B4h case   21:*/		return 0x820A75B8;
		  /* 820A75B8h */ case   22:  		/* lbz R10, <#[R10]> */
		/* 820A75B8h case   22:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820A75B8h case   22:*/		return 0x820A75BC;
		  /* 820A75BCh */ case   23:  		/* cmplwi CR6, R10, 10 */
		/* 820A75BCh case   23:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000A);
		/* 820A75BCh case   23:*/		return 0x820A75C0;
		  /* 820A75C0h */ case   24:  		/* bc 4, CR6_EQ, 60 */
		/* 820A75C0h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820A75FC;  }
		/* 820A75C0h case   24:*/		return 0x820A75C4;
		  /* 820A75C4h */ case   25:  		/* cmpwi CR6, R30, 0 */
		/* 820A75C4h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820A75C4h case   25:*/		return 0x820A75C8;
		  /* 820A75C8h */ case   26:  		/* bc 12, CR6_EQ, 24 */
		/* 820A75C8h case   26:*/		if ( regs.CR[6].eq ) { return 0x820A75E0;  }
		/* 820A75C8h case   26:*/		return 0x820A75CC;
		  /* 820A75CCh */ case   27:  		/* mr R6, R29 */
		/* 820A75CCh case   27:*/		regs.R6 = regs.R29;
		/* 820A75CCh case   27:*/		return 0x820A75D0;
		  /* 820A75D0h */ case   28:  		/* lwz R3, <#[R31 + 64]> */
		/* 820A75D0h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000040) );
		/* 820A75D0h case   28:*/		return 0x820A75D4;
		  /* 820A75D4h */ case   29:  		/* li R5, 1050 */
		/* 820A75D4h case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x41A);
		/* 820A75D4h case   29:*/		return 0x820A75D8;
		  /* 820A75D8h */ case   30:  		/* addi R4, R31, 16 */
		/* 820A75D8h case   30:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 820A75D8h case   30:*/		return 0x820A75DC;
		  /* 820A75DCh */ case   31:  		/* bl -644 */
		/* 820A75DCh case   31:*/		regs.LR = 0x820A75E0; return 0x820A7358;
		/* 820A75DCh case   31:*/		return 0x820A75E0;
	}
	return 0x820A75E0;
} // Block from 820A7560h-820A75E0h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820A75E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A75E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A75E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A75E0);
		  /* 820A75E0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A75E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A75E0h case    0:*/		return 0x820A75E4;
		  /* 820A75E4h */ case    1:  		/* addi R11, R11, 2 */
		/* 820A75E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A75E4h case    1:*/		return 0x820A75E8;
		  /* 820A75E8h */ case    2:  		/* lwz R10, <#[R31 + 40]> */
		/* 820A75E8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 820A75E8h case    2:*/		return 0x820A75EC;
		  /* 820A75ECh */ case    3:  		/* stw R11, <#[R31 + 4]> */
		/* 820A75ECh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820A75ECh case    3:*/		return 0x820A75F0;
		  /* 820A75F0h */ case    4:  		/* addi R10, R10, 1 */
		/* 820A75F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A75F0h case    4:*/		return 0x820A75F4;
		  /* 820A75F4h */ case    5:  		/* stw R10, <#[R31 + 40]> */
		/* 820A75F4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 820A75F4h case    5:*/		return 0x820A75F8;
		  /* 820A75F8h */ case    6:  		/* b 168 */
		/* 820A75F8h case    6:*/		return 0x820A76A0;
		/* 820A75F8h case    6:*/		return 0x820A75FC;
	}
	return 0x820A75FC;
} // Block from 820A75E0h-820A75FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A75FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A75FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A75FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A75FC);
		  /* 820A75FCh */ case    0:  		/* cmpwi CR6, R9, 92 */
		/* 820A75FCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000005C);
		/* 820A75FCh case    0:*/		return 0x820A7600;
		  /* 820A7600h */ case    1:  		/* bc 4, CR6_EQ, 88 */
		/* 820A7600h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A7658;  }
		/* 820A7600h case    1:*/		return 0x820A7604;
		  /* 820A7604h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A7604h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7604h case    2:*/		return 0x820A7608;
		  /* 820A7608h */ case    3:  		/* addi R11, R11, 2 */
		/* 820A7608h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A7608h case    3:*/		return 0x820A760C;
		  /* 820A760Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820A760Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A760Ch case    4:*/		return 0x820A7610;
		  /* 820A7610h */ case    5:  		/* bc 4, CR6_LT, 72 */
		/* 820A7610h case    5:*/		if ( !regs.CR[6].lt ) { return 0x820A7658;  }
		/* 820A7610h case    5:*/		return 0x820A7614;
		  /* 820A7614h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 820A7614h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7614h case    6:*/		return 0x820A7618;
		  /* 820A7618h */ case    7:  		/* lbz R10, <#[R11 + 1]> */
		/* 820A7618h case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000001) );
		/* 820A7618h case    7:*/		return 0x820A761C;
		  /* 820A761Ch */ case    8:  		/* cmplwi CR6, R10, 13 */
		/* 820A761Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000D);
		/* 820A761Ch case    8:*/		return 0x820A7620;
		  /* 820A7620h */ case    9:  		/* bc 4, CR6_EQ, 56 */
		/* 820A7620h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A7658;  }
		/* 820A7620h case    9:*/		return 0x820A7624;
		  /* 820A7624h */ case   10:  		/* lbz R11, <#[R11 + 2]> */
		/* 820A7624h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000002) );
		/* 820A7624h case   10:*/		return 0x820A7628;
		  /* 820A7628h */ case   11:  		/* cmplwi CR6, R11, 10 */
		/* 820A7628h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 820A7628h case   11:*/		return 0x820A762C;
		  /* 820A762Ch */ case   12:  		/* bc 4, CR6_EQ, 44 */
		/* 820A762Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A7658;  }
		/* 820A762Ch case   12:*/		return 0x820A7630;
		  /* 820A7630h */ case   13:  		/* cmpwi CR6, R30, 0 */
		/* 820A7630h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820A7630h case   13:*/		return 0x820A7634;
		  /* 820A7634h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 820A7634h case   14:*/		if ( regs.CR[6].eq ) { return 0x820A764C;  }
		/* 820A7634h case   14:*/		return 0x820A7638;
		  /* 820A7638h */ case   15:  		/* mr R6, R29 */
		/* 820A7638h case   15:*/		regs.R6 = regs.R29;
		/* 820A7638h case   15:*/		return 0x820A763C;
		  /* 820A763Ch */ case   16:  		/* lwz R3, <#[R31 + 64]> */
		/* 820A763Ch case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000040) );
		/* 820A763Ch case   16:*/		return 0x820A7640;
		  /* 820A7640h */ case   17:  		/* li R5, 1050 */
		/* 820A7640h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x41A);
		/* 820A7640h case   17:*/		return 0x820A7644;
		  /* 820A7644h */ case   18:  		/* addi R4, R31, 16 */
		/* 820A7644h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 820A7644h case   18:*/		return 0x820A7648;
		  /* 820A7648h */ case   19:  		/* bl -752 */
		/* 820A7648h case   19:*/		regs.LR = 0x820A764C; return 0x820A7358;
		/* 820A7648h case   19:*/		return 0x820A764C;
	}
	return 0x820A764C;
} // Block from 820A75FCh-820A764Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A764Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A764C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A764C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A764C);
		  /* 820A764Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A764Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A764Ch case    0:*/		return 0x820A7650;
		  /* 820A7650h */ case    1:  		/* addi R11, R11, 3 */
		/* 820A7650h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820A7650h case    1:*/		return 0x820A7654;
		  /* 820A7654h */ case    2:  		/* b -108 */
		/* 820A7654h case    2:*/		return 0x820A75E8;
		/* 820A7654h case    2:*/		return 0x820A7658;
	}
	return 0x820A7658;
} // Block from 820A764Ch-820A7658h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7658);
		  /* 820A7658h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 820A7658h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820A7658h case    0:*/		return 0x820A765C;
		  /* 820A765Ch */ case    1:  		/* bc 4, CR6_EQ, 60 */
		/* 820A765Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A7698;  }
		/* 820A765Ch case    1:*/		return 0x820A7660;
	}
	return 0x820A7660;
} // Block from 820A7658h-820A7660h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7660h
// Function '?LexIdentifier@CTokenize@D3DXShader@@IAAIPBDPAPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7660);
		  /* 820A7660h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A7660h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7660h case    0:*/		return 0x820A7664;
		  /* 820A7664h */ case    1:  		/* lbz R10, <#[R11]> */
		/* 820A7664h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7664h case    1:*/		return 0x820A7668;
		  /* 820A7668h */ case    2:  		/* cmplwi CR6, R10, 47 */
		/* 820A7668h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000002F);
		/* 820A7668h case    2:*/		return 0x820A766C;
		  /* 820A766Ch */ case    3:  		/* bc 4, CR6_EQ, 44 */
		/* 820A766Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A7698;  }
		/* 820A766Ch case    3:*/		return 0x820A7670;
		  /* 820A7670h */ case    4:  		/* lwz R9, <#[R31 + 8]> */
		/* 820A7670h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7670h case    4:*/		return 0x820A7674;
		  /* 820A7674h */ case    5:  		/* addi R10, R11, 1 */
		/* 820A7674h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 820A7674h case    5:*/		return 0x820A7678;
		  /* 820A7678h */ case    6:  		/* cmplw CR6, R10, R9 */
		/* 820A7678h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820A7678h case    6:*/		return 0x820A767C;
		  /* 820A767Ch */ case    7:  		/* bc 4, CR6_LT, 28 */
		/* 820A767Ch case    7:*/		if ( !regs.CR[6].lt ) { return 0x820A7698;  }
		/* 820A767Ch case    7:*/		return 0x820A7680;
		  /* 820A7680h */ case    8:  		/* lbz R10, <#[R10]> */
		/* 820A7680h case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820A7680h case    8:*/		return 0x820A7684;
		  /* 820A7684h */ case    9:  		/* cmplwi CR6, R10, 47 */
		/* 820A7684h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000002F);
		/* 820A7684h case    9:*/		return 0x820A7688;
		  /* 820A7688h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 820A7688h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820A7698;  }
		/* 820A7688h case   10:*/		return 0x820A768C;
		  /* 820A768Ch */ case   11:  		/* addi R11, R11, 2 */
		/* 820A768Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A768Ch case   11:*/		return 0x820A7690;
		  /* 820A7690h */ case   12:  		/* li R30, 1 */
		/* 820A7690h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820A7690h case   12:*/		return 0x820A7694;
		  /* 820A7694h */ case   13:  		/* b 12 */
		/* 820A7694h case   13:*/		return 0x820A76A0;
		/* 820A7694h case   13:*/		return 0x820A7698;
	}
	return 0x820A7698;
} // Block from 820A7660h-820A7698h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A7698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7698);
		  /* 820A7698h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A7698h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7698h case    0:*/		return 0x820A769C;
		  /* 820A769Ch */ case    1:  		/* addi R11, R11, 1 */
		/* 820A769Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A769Ch case    1:*/		return 0x820A76A0;
	}
	return 0x820A76A0;
} // Block from 820A7698h-820A76A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A76A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A76A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A76A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A76A0);
		  /* 820A76A0h */ case    0:  		/* stw R11, <#[R31]> */
		/* 820A76A0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A76A0h case    0:*/		return 0x820A76A4;
		  /* 820A76A4h */ case    1:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820A76A4h case    1:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820A76A4h case    1:*/		return 0x820A76A8;
		  /* 820A76A8h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A76A8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A76A8h case    2:*/		return 0x820A76AC;
		  /* 820A76ACh */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820A76ACh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A76ACh case    3:*/		return 0x820A76B0;
		  /* 820A76B0h */ case    4:  		/* bc 12, CR6_LT, -292 */
		/* 820A76B0h case    4:*/		if ( regs.CR[6].lt ) { return 0x820A758C;  }
		/* 820A76B0h case    4:*/		return 0x820A76B4;
	}
	return 0x820A76B4;
} // Block from 820A76A0h-820A76B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A76B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A76B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A76B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A76B4);
		  /* 820A76B4h */ case    0:  		/* li R3, 0 */
		/* 820A76B4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A76B4h case    0:*/		return 0x820A76B8;
		  /* 820A76B8h */ case    1:  		/* addi R1, R1, 144 */
		/* 820A76B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820A76B8h case    1:*/		return 0x820A76BC;
		  /* 820A76BCh */ case    2:  		/* b -91152 */
		/* 820A76BCh case    2:*/		return 0x820912AC;
		/* 820A76BCh case    2:*/		return 0x820A76C0;
	}
	return 0x820A76C0;
} // Block from 820A76B4h-820A76C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A76C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A76C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A76C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A76C0);
		  /* 820A76C0h */ case    0:  		/* li R3, 1 */
		/* 820A76C0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820A76C0h case    0:*/		return 0x820A76C4;
		  /* 820A76C4h */ case    1:  		/* b -12 */
		/* 820A76C4h case    1:*/		return 0x820A76B8;
		/* 820A76C4h case    1:*/		return 0x820A76C8;
	}
	return 0x820A76C8;
} // Block from 820A76C0h-820A76C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A76C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A76C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A76C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A76C8);
		  /* 820A76C8h */ case    0:  		/* mfspr R12, LR */
		/* 820A76C8h case    0:*/		regs.R12 = regs.LR;
		/* 820A76C8h case    0:*/		return 0x820A76CC;
		  /* 820A76CCh */ case    1:  		/* bl -91256 */
		/* 820A76CCh case    1:*/		regs.LR = 0x820A76D0; return 0x82091254;
		/* 820A76CCh case    1:*/		return 0x820A76D0;
		  /* 820A76D0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820A76D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820A76D0h case    2:*/		return 0x820A76D4;
		  /* 820A76D4h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820A76D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A76D4h case    3:*/		return 0x820A76D8;
		  /* 820A76D8h */ case    4:  		/* addi R30, R4, 2 */
		/* 820A76D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R4,0x2);
		/* 820A76D8h case    4:*/		return 0x820A76DC;
		  /* 820A76DCh */ case    5:  		/* mr R29, R3 */
		/* 820A76DCh case    5:*/		regs.R29 = regs.R3;
		/* 820A76DCh case    5:*/		return 0x820A76E0;
		  /* 820A76E0h */ case    6:  		/* mr R28, R4 */
		/* 820A76E0h case    6:*/		regs.R28 = regs.R4;
		/* 820A76E0h case    6:*/		return 0x820A76E4;
		  /* 820A76E4h */ case    7:  		/* mr R27, R5 */
		/* 820A76E4h case    7:*/		regs.R27 = regs.R5;
		/* 820A76E4h case    7:*/		return 0x820A76E8;
		  /* 820A76E8h */ case    8:  		/* cmplw CR6, R30, R11 */
		/* 820A76E8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A76E8h case    8:*/		return 0x820A76EC;
		  /* 820A76ECh */ case    9:  		/* bc 4, CR6_LT, 196 */
		/* 820A76ECh case    9:*/		if ( !regs.CR[6].lt ) { return 0x820A77B0;  }
		/* 820A76ECh case    9:*/		return 0x820A76F0;
		  /* 820A76F0h */ case   10:  		/* lbz R11, <#[R4]> */
		/* 820A76F0h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820A76F0h case   10:*/		return 0x820A76F4;
		  /* 820A76F4h */ case   11:  		/* cmplwi CR6, R11, 48 */
		/* 820A76F4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 820A76F4h case   11:*/		return 0x820A76F8;
		  /* 820A76F8h */ case   12:  		/* bc 4, CR6_EQ, 184 */
		/* 820A76F8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A77B0;  }
		/* 820A76F8h case   12:*/		return 0x820A76FC;
		  /* 820A76FCh */ case   13:  		/* lbz R11, <#[R4 + 1]> */
		/* 820A76FCh case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000001) );
		/* 820A76FCh case   13:*/		return 0x820A7700;
		  /* 820A7700h */ case   14:  		/* cmplwi CR6, R11, 120 */
		/* 820A7700h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000078);
		/* 820A7700h case   14:*/		return 0x820A7704;
		  /* 820A7704h */ case   15:  		/* bc 4, CR6_EQ, 172 */
		/* 820A7704h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820A77B0;  }
		/* 820A7704h case   15:*/		return 0x820A7708;
		  /* 820A7708h */ case   16:  		/* lbz R3, <#[R30]> */
		/* 820A7708h case   16:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A7708h case   16:*/		return 0x820A770C;
		  /* 820A770Ch */ case   17:  		/* bl -57308 */
		/* 820A770Ch case   17:*/		regs.LR = 0x820A7710; return 0x82099730;
		/* 820A770Ch case   17:*/		return 0x820A7710;
		  /* 820A7710h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820A7710h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A7710h case   18:*/		return 0x820A7714;
		  /* 820A7714h */ case   19:  		/* bc 12, CR0_EQ, 156 */
		/* 820A7714h case   19:*/		if ( regs.CR[0].eq ) { return 0x820A77B0;  }
		/* 820A7714h case   19:*/		return 0x820A7718;
		  /* 820A7718h */ case   20:  		/* li R31, 0 */
		/* 820A7718h case   20:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820A7718h case   20:*/		return 0x820A771C;
		  /* 820A771Ch */ case   21:  		/* b 80 */
		/* 820A771Ch case   21:*/		return 0x820A776C;
		/* 820A771Ch case   21:*/		return 0x820A7720;
		  /* 820A7720h */ case   22:  		/* lbz R3, <#[R30]> */
		/* 820A7720h case   22:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A7720h case   22:*/		return 0x820A7724;
		  /* 820A7724h */ case   23:  		/* bl -57332 */
		/* 820A7724h case   23:*/		regs.LR = 0x820A7728; return 0x82099730;
		/* 820A7724h case   23:*/		return 0x820A7728;
		  /* 820A7728h */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 820A7728h case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A7728h case   24:*/		return 0x820A772C;
		  /* 820A772Ch */ case   25:  		/* bc 12, CR0_EQ, 76 */
		/* 820A772Ch case   25:*/		if ( regs.CR[0].eq ) { return 0x820A7778;  }
		/* 820A772Ch case   25:*/		return 0x820A7730;
		  /* 820A7730h */ case   26:  		/* lbz R11, <#[R30]> */
		/* 820A7730h case   26:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A7730h case   26:*/		return 0x820A7734;
		  /* 820A7734h */ case   27:  		/* rldicr R10, R31, 4, 59 */
		/* 820A7734h case   27:*/		cpu::op::rldicr<0,4,59>(regs,&regs.R10,regs.R31);
		/* 820A7734h case   27:*/		return 0x820A7738;
		  /* 820A7738h */ case   28:  		/* extsb R11, R11 */
		/* 820A7738h case   28:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820A7738h case   28:*/		return 0x820A773C;
		  /* 820A773Ch */ case   29:  		/* cmpwi CR6, R11, 97 */
		/* 820A773Ch case   29:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000061);
		/* 820A773Ch case   29:*/		return 0x820A7740;
		  /* 820A7740h */ case   30:  		/* bc 12, CR6_LT, 12 */
		/* 820A7740h case   30:*/		if ( regs.CR[6].lt ) { return 0x820A774C;  }
		/* 820A7740h case   30:*/		return 0x820A7744;
		  /* 820A7744h */ case   31:  		/* addi R11, R11, -87 */
		/* 820A7744h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFA9);
		/* 820A7744h case   31:*/		return 0x820A7748;
		  /* 820A7748h */ case   32:  		/* b 24 */
		/* 820A7748h case   32:*/		return 0x820A7760;
		/* 820A7748h case   32:*/		return 0x820A774C;
	}
	return 0x820A774C;
} // Block from 820A76C8h-820A774Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 820A774Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A774C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A774C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A774C);
		  /* 820A774Ch */ case    0:  		/* cmpwi CR6, R11, 65 */
		/* 820A774Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000041);
		/* 820A774Ch case    0:*/		return 0x820A7750;
		  /* 820A7750h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 820A7750h case    1:*/		if ( regs.CR[6].lt ) { return 0x820A775C;  }
		/* 820A7750h case    1:*/		return 0x820A7754;
		  /* 820A7754h */ case    2:  		/* addi R11, R11, -55 */
		/* 820A7754h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFC9);
		/* 820A7754h case    2:*/		return 0x820A7758;
		  /* 820A7758h */ case    3:  		/* b 8 */
		/* 820A7758h case    3:*/		return 0x820A7760;
		/* 820A7758h case    3:*/		return 0x820A775C;
	}
	return 0x820A775C;
} // Block from 820A774Ch-820A775Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A775Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A775C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A775C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A775C);
		  /* 820A775Ch */ case    0:  		/* addi R11, R11, -48 */
		/* 820A775Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD0);
		/* 820A775Ch case    0:*/		return 0x820A7760;
	}
	return 0x820A7760;
} // Block from 820A775Ch-820A7760h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7760);
		  /* 820A7760h */ case    0:  		/* extsw R11, R11 */
		/* 820A7760h case    0:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 820A7760h case    0:*/		return 0x820A7764;
		  /* 820A7764h */ case    1:  		/* addi R30, R30, 1 */
		/* 820A7764h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820A7764h case    1:*/		return 0x820A7768;
		  /* 820A7768h */ case    2:  		/* add R31, R11, R10 */
		/* 820A7768h case    2:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R10);
		/* 820A7768h case    2:*/		return 0x820A776C;
	}
	return 0x820A776C;
} // Block from 820A7760h-820A776Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A776Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A776C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A776C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A776C);
		  /* 820A776Ch */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 820A776Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820A776Ch case    0:*/		return 0x820A7770;
		  /* 820A7770h */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 820A7770h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A7770h case    1:*/		return 0x820A7774;
		  /* 820A7774h */ case    2:  		/* bc 12, CR6_LT, -84 */
		/* 820A7774h case    2:*/		if ( regs.CR[6].lt ) { return 0x820A7720;  }
		/* 820A7774h case    2:*/		return 0x820A7778;
	}
	return 0x820A7778;
} // Block from 820A776Ch-820A7778h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7778);
		  /* 820A7778h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820A7778h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820A7778h case    0:*/		return 0x820A777C;
		  /* 820A777Ch */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820A777Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820A7784;  }
		/* 820A777Ch case    1:*/		return 0x820A7780;
		  /* 820A7780h */ case    2:  		/* std R31, <#[R27]> */
		/* 820A7780h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R27 + 0x00000000) );
		/* 820A7780h case    2:*/		return 0x820A7784;
	}
	return 0x820A7784;
} // Block from 820A7778h-820A7784h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7784);
		  /* 820A7784h */ case    0:  		/* subf R31, R28, R30 */
		/* 820A7784h case    0:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R28,regs.R30);
		/* 820A7784h case    0:*/		return 0x820A7788;
		  /* 820A7788h */ case    1:  		/* cmpwi CR6, R31, 10 */
		/* 820A7788h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x0000000A);
		/* 820A7788h case    1:*/		return 0x820A778C;
		  /* 820A778Ch */ case    2:  		/* bc 4, CR6_GT, 28 */
		/* 820A778Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x820A77A8;  }
		/* 820A778Ch case    2:*/		return 0x820A7790;
		  /* 820A7790h */ case    3:  		/* lis R11, -32255 */
		/* 820A7790h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7790h case    3:*/		return 0x820A7794;
		  /* 820A7794h */ case    4:  		/* lwz R3, <#[R29 + 64]> */
		/* 820A7794h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000040) );
		/* 820A7794h case    4:*/		return 0x820A7798;
		  /* 820A7798h */ case    5:  		/* li R5, 1002 */
		/* 820A7798h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x3EA);
		/* 820A7798h case    5:*/		return 0x820A779C;
		  /* 820A779Ch */ case    6:  		/* addi R6, R11, -9084 */
		/* 820A779Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFDC84);
		/* 820A779Ch case    6:*/		return 0x820A77A0;
		  /* 820A77A0h */ case    7:  		/* addi R4, R29, 16 */
		/* 820A77A0h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0x10);
		/* 820A77A0h case    7:*/		return 0x820A77A4;
		  /* 820A77A4h */ case    8:  		/* bl -1556 */
		/* 820A77A4h case    8:*/		regs.LR = 0x820A77A8; return 0x820A7190;
		/* 820A77A4h case    8:*/		return 0x820A77A8;
	}
	return 0x820A77A8;
} // Block from 820A7784h-820A77A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A77A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A77A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A77A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A77A8);
		  /* 820A77A8h */ case    0:  		/* mr R3, R31 */
		/* 820A77A8h case    0:*/		regs.R3 = regs.R31;
		/* 820A77A8h case    0:*/		return 0x820A77AC;
		  /* 820A77ACh */ case    1:  		/* b 8 */
		/* 820A77ACh case    1:*/		return 0x820A77B4;
		/* 820A77ACh case    1:*/		return 0x820A77B0;
	}
	return 0x820A77B0;
} // Block from 820A77A8h-820A77B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A77B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A77B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A77B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A77B0);
		  /* 820A77B0h */ case    0:  		/* li R3, 0 */
		/* 820A77B0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A77B0h case    0:*/		return 0x820A77B4;
	}
	return 0x820A77B4;
} // Block from 820A77B0h-820A77B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A77B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A77B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A77B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A77B4);
		  /* 820A77B4h */ case    0:  		/* addi R1, R1, 160 */
		/* 820A77B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820A77B4h case    0:*/		return 0x820A77B8;
	}
	return 0x820A77B8;
} // Block from 820A77B4h-820A77B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A77B8h
// Function '?SetWarningSpecifier@CTErrors@D3DXShader@@QAAJII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A77B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A77B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A77B8);
		  /* 820A77B8h */ case    0:  		/* b -91412 */
		/* 820A77B8h case    0:*/		return 0x820912A4;
		/* 820A77B8h case    0:*/		return 0x820A77BC;
		  /* 820A77BCh */ case    1:  		/* nop */
		/* 820A77BCh case    1:*/		cpu::op::nop();
		/* 820A77BCh case    1:*/		return 0x820A77C0;
	}
	return 0x820A77C0;
} // Block from 820A77B8h-820A77C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A77C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A77C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A77C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A77C0);
		  /* 820A77C0h */ case    0:  		/* mfspr R12, LR */
		/* 820A77C0h case    0:*/		regs.R12 = regs.LR;
		/* 820A77C0h case    0:*/		return 0x820A77C4;
		  /* 820A77C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A77C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A77C4h case    1:*/		return 0x820A77C8;
		  /* 820A77C8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A77C8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A77C8h case    2:*/		return 0x820A77CC;
		  /* 820A77CCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A77CCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A77CCh case    3:*/		return 0x820A77D0;
		  /* 820A77D0h */ case    4:  		/* stwu R1, <#[R1 - 144]> */
		/* 820A77D0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820A77D0h case    4:*/		return 0x820A77D4;
		  /* 820A77D4h */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 820A77D4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820A77D4h case    5:*/		return 0x820A77D8;
		  /* 820A77D8h */ case    6:  		/* mr R7, R3 */
		/* 820A77D8h case    6:*/		regs.R7 = regs.R3;
		/* 820A77D8h case    6:*/		return 0x820A77DC;
		  /* 820A77DCh */ case    7:  		/* mr R30, R4 */
		/* 820A77DCh case    7:*/		regs.R30 = regs.R4;
		/* 820A77DCh case    7:*/		return 0x820A77E0;
		  /* 820A77E0h */ case    8:  		/* cmplw CR6, R4, R10 */
		/* 820A77E0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 820A77E0h case    8:*/		return 0x820A77E4;
		  /* 820A77E4h */ case    9:  		/* bc 4, CR6_LT, 152 */
		/* 820A77E4h case    9:*/		if ( !regs.CR[6].lt ) { return 0x820A787C;  }
		/* 820A77E4h case    9:*/		return 0x820A77E8;
		  /* 820A77E8h */ case   10:  		/* lbz R11, <#[R4]> */
		/* 820A77E8h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820A77E8h case   10:*/		return 0x820A77EC;
		  /* 820A77ECh */ case   11:  		/* cmplwi CR6, R11, 48 */
		/* 820A77ECh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 820A77ECh case   11:*/		return 0x820A77F0;
		  /* 820A77F0h */ case   12:  		/* bc 4, CR6_EQ, 140 */
		/* 820A77F0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A787C;  }
		/* 820A77F0h case   12:*/		return 0x820A77F4;
		  /* 820A77F4h */ case   13:  		/* addi R31, R4, 1 */
		/* 820A77F4h case   13:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R4,0x1);
		/* 820A77F4h case   13:*/		return 0x820A77F8;
		  /* 820A77F8h */ case   14:  		/* li R11, 0 */
		/* 820A77F8h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A77F8h case   14:*/		return 0x820A77FC;
		  /* 820A77FCh */ case   15:  		/* li R8, 0 */
		/* 820A77FCh case   15:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820A77FCh case   15:*/		return 0x820A7800;
		  /* 820A7800h */ case   16:  		/* b 64 */
		/* 820A7800h case   16:*/		return 0x820A7840;
		/* 820A7800h case   16:*/		return 0x820A7804;
		  /* 820A7804h */ case   17:  		/* lbz R9, <#[R31]> */
		/* 820A7804h case   17:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7804h case   17:*/		return 0x820A7808;
		  /* 820A7808h */ case   18:  		/* extsb R9, R9 */
		/* 820A7808h case   18:*/		cpu::op::extsb<0>(regs,&regs.R9,regs.R9);
		/* 820A7808h case   18:*/		return 0x820A780C;
		  /* 820A780Ch */ case   19:  		/* cmpwi CR6, R9, 48 */
		/* 820A780Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000030);
		/* 820A780Ch case   19:*/		return 0x820A7810;
		  /* 820A7810h */ case   20:  		/* bc 12, CR6_LT, 56 */
		/* 820A7810h case   20:*/		if ( regs.CR[6].lt ) { return 0x820A7848;  }
		/* 820A7810h case   20:*/		return 0x820A7814;
		  /* 820A7814h */ case   21:  		/* cmpwi CR6, R9, 55 */
		/* 820A7814h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000037);
		/* 820A7814h case   21:*/		return 0x820A7818;
		  /* 820A7818h */ case   22:  		/* bc 12, CR6_GT, 48 */
		/* 820A7818h case   22:*/		if ( regs.CR[6].gt ) { return 0x820A7848;  }
		/* 820A7818h case   22:*/		return 0x820A781C;
		  /* 820A781Ch */ case   23:  		/* rlwinm R6, R11, 0, 0, 2 */
		/* 820A781Ch case   23:*/		cpu::op::rlwinm<0,0,0,2>(regs,&regs.R6,regs.R11);
		/* 820A781Ch case   23:*/		return 0x820A7820;
		  /* 820A7820h */ case   24:  		/* cmpldi CR6, R6, 0 */
		/* 820A7820h case   24:*/		cpu::op::cmpldi<6>(regs,regs.R6,0x00000000);
		/* 820A7820h case   24:*/		return 0x820A7824;
		  /* 820A7824h */ case   25:  		/* bc 12, CR6_EQ, 8 */
		/* 820A7824h case   25:*/		if ( regs.CR[6].eq ) { return 0x820A782C;  }
		/* 820A7824h case   25:*/		return 0x820A7828;
		  /* 820A7828h */ case   26:  		/* li R8, 1 */
		/* 820A7828h case   26:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820A7828h case   26:*/		return 0x820A782C;
	}
	return 0x820A782C;
} // Block from 820A77C0h-820A782Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 820A782Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A782C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A782C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A782C);
		  /* 820A782Ch */ case    0:  		/* addi R6, R9, -48 */
		/* 820A782Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R9,0xFFFFFFD0);
		/* 820A782Ch case    0:*/		return 0x820A7830;
		  /* 820A7830h */ case    1:  		/* rldicr R9, R11, 3, 60 */
		/* 820A7830h case    1:*/		cpu::op::rldicr<0,3,60>(regs,&regs.R9,regs.R11);
		/* 820A7830h case    1:*/		return 0x820A7834;
		  /* 820A7834h */ case    2:  		/* extsw R11, R6 */
		/* 820A7834h case    2:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R6);
		/* 820A7834h case    2:*/		return 0x820A7838;
		  /* 820A7838h */ case    3:  		/* addi R31, R31, 1 */
		/* 820A7838h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A7838h case    3:*/		return 0x820A783C;
		  /* 820A783Ch */ case    4:  		/* add R11, R11, R9 */
		/* 820A783Ch case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820A783Ch case    4:*/		return 0x820A7840;
	}
	return 0x820A7840;
} // Block from 820A782Ch-820A7840h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A7840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7840);
		  /* 820A7840h */ case    0:  		/* cmplw CR6, R31, R10 */
		/* 820A7840h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 820A7840h case    0:*/		return 0x820A7844;
		  /* 820A7844h */ case    1:  		/* bc 12, CR6_LT, -64 */
		/* 820A7844h case    1:*/		if ( regs.CR[6].lt ) { return 0x820A7804;  }
		/* 820A7844h case    1:*/		return 0x820A7848;
	}
	return 0x820A7848;
} // Block from 820A7840h-820A7848h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7848);
		  /* 820A7848h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820A7848h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820A7848h case    0:*/		return 0x820A784C;
		  /* 820A784Ch */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820A784Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820A7854;  }
		/* 820A784Ch case    1:*/		return 0x820A7850;
		  /* 820A7850h */ case    2:  		/* std R11, <#[R5]> */
		/* 820A7850h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820A7850h case    2:*/		return 0x820A7854;
	}
	return 0x820A7854;
} // Block from 820A7848h-820A7854h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7854);
		  /* 820A7854h */ case    0:  		/* cmpwi CR6, R8, 0 */
		/* 820A7854h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A7854h case    0:*/		return 0x820A7858;
		  /* 820A7858h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820A7858h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A7874;  }
		/* 820A7858h case    1:*/		return 0x820A785C;
		  /* 820A785Ch */ case    2:  		/* lis R11, -32255 */
		/* 820A785Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A785Ch case    2:*/		return 0x820A7860;
		  /* 820A7860h */ case    3:  		/* lwz R3, <#[R7 + 64]> */
		/* 820A7860h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R7 + 0x00000040) );
		/* 820A7860h case    3:*/		return 0x820A7864;
		  /* 820A7864h */ case    4:  		/* li R5, 1003 */
		/* 820A7864h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x3EB);
		/* 820A7864h case    4:*/		return 0x820A7868;
	}
	return 0x820A7868;
} // Block from 820A7854h-820A7868h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A7868h
// Function '?FillMessageBuf@CTErrors@D3DXShader@@QAAJIPADPBUD3DXTOKEN@2@IPBD20@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7868);
		  /* 820A7868h */ case    0:  		/* addi R6, R11, -9052 */
		/* 820A7868h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFDCA4);
		/* 820A7868h case    0:*/		return 0x820A786C;
		  /* 820A786Ch */ case    1:  		/* addi R4, R7, 16 */
		/* 820A786Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R7,0x10);
		/* 820A786Ch case    1:*/		return 0x820A7870;
		  /* 820A7870h */ case    2:  		/* bl -1760 */
		/* 820A7870h case    2:*/		regs.LR = 0x820A7874; return 0x820A7190;
		/* 820A7870h case    2:*/		return 0x820A7874;
	}
	return 0x820A7874;
} // Block from 820A7868h-820A7874h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7874);
		  /* 820A7874h */ case    0:  		/* subf R3, R30, R31 */
		/* 820A7874h case    0:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R30,regs.R31);
		/* 820A7874h case    0:*/		return 0x820A7878;
		  /* 820A7878h */ case    1:  		/* b 8 */
		/* 820A7878h case    1:*/		return 0x820A7880;
		/* 820A7878h case    1:*/		return 0x820A787C;
	}
	return 0x820A787C;
} // Block from 820A7874h-820A787Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A787Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A787C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A787C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A787C);
		  /* 820A787Ch */ case    0:  		/* li R3, 0 */
		/* 820A787Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A787Ch case    0:*/		return 0x820A7880;
	}
	return 0x820A7880;
} // Block from 820A787Ch-820A7880h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7880);
		  /* 820A7880h */ case    0:  		/* addi R1, R1, 144 */
		/* 820A7880h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820A7880h case    0:*/		return 0x820A7884;
		  /* 820A7884h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A7884h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A7884h case    1:*/		return 0x820A7888;
		  /* 820A7888h */ case    2:  		/* mtspr LR, R12 */
		/* 820A7888h case    2:*/		regs.LR = regs.R12;
		/* 820A7888h case    2:*/		return 0x820A788C;
		  /* 820A788Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820A788Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A788Ch case    3:*/		return 0x820A7890;
		  /* 820A7890h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820A7890h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A7890h case    4:*/		return 0x820A7894;
		  /* 820A7894h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820A7894h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A7894h case    5:*/		return 0x820A7898;
	}
	return 0x820A7898;
} // Block from 820A7880h-820A7898h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A7898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7898);
		  /* 820A7898h */ case    0:  		/* mfspr R12, LR */
		/* 820A7898h case    0:*/		regs.R12 = regs.LR;
		/* 820A7898h case    0:*/		return 0x820A789C;
		  /* 820A789Ch */ case    1:  		/* bl -91724 */
		/* 820A789Ch case    1:*/		regs.LR = 0x820A78A0; return 0x82091250;
		/* 820A789Ch case    1:*/		return 0x820A78A0;
		  /* 820A78A0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820A78A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820A78A0h case    2:*/		return 0x820A78A4;
		  /* 820A78A4h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820A78A4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A78A4h case    3:*/		return 0x820A78A8;
		  /* 820A78A8h */ case    4:  		/* mr R29, R3 */
		/* 820A78A8h case    4:*/		regs.R29 = regs.R3;
		/* 820A78A8h case    4:*/		return 0x820A78AC;
		  /* 820A78ACh */ case    5:  		/* mr R28, R4 */
		/* 820A78ACh case    5:*/		regs.R28 = regs.R4;
		/* 820A78ACh case    5:*/		return 0x820A78B0;
		  /* 820A78B0h */ case    6:  		/* mr R26, R5 */
		/* 820A78B0h case    6:*/		regs.R26 = regs.R5;
		/* 820A78B0h case    6:*/		return 0x820A78B4;
		  /* 820A78B4h */ case    7:  		/* mr R31, R4 */
		/* 820A78B4h case    7:*/		regs.R31 = regs.R4;
		/* 820A78B4h case    7:*/		return 0x820A78B8;
		  /* 820A78B8h */ case    8:  		/* cmplw CR6, R4, R11 */
		/* 820A78B8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820A78B8h case    8:*/		return 0x820A78BC;
		  /* 820A78BCh */ case    9:  		/* bc 4, CR6_LT, 192 */
		/* 820A78BCh case    9:*/		if ( !regs.CR[6].lt ) { return 0x820A797C;  }
		/* 820A78BCh case    9:*/		return 0x820A78C0;
		  /* 820A78C0h */ case   10:  		/* lbz R3, <#[R4]> */
		/* 820A78C0h case   10:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000000) );
		/* 820A78C0h case   10:*/		return 0x820A78C4;
		  /* 820A78C4h */ case   11:  		/* bl -57780 */
		/* 820A78C4h case   11:*/		regs.LR = 0x820A78C8; return 0x82099710;
		/* 820A78C4h case   11:*/		return 0x820A78C8;
		  /* 820A78C8h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820A78C8h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A78C8h case   12:*/		return 0x820A78CC;
		  /* 820A78CCh */ case   13:  		/* bc 12, CR0_EQ, 176 */
		/* 820A78CCh case   13:*/		if ( regs.CR[0].eq ) { return 0x820A797C;  }
		/* 820A78CCh case   13:*/		return 0x820A78D0;
		  /* 820A78D0h */ case   14:  		/* lwz R11, <#[R29 + 8]> */
		/* 820A78D0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820A78D0h case   14:*/		return 0x820A78D4;
		  /* 820A78D4h */ case   15:  		/* li R30, 0 */
		/* 820A78D4h case   15:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A78D4h case   15:*/		return 0x820A78D8;
		  /* 820A78D8h */ case   16:  		/* li R27, 0 */
		/* 820A78D8h case   16:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820A78D8h case   16:*/		return 0x820A78DC;
		  /* 820A78DCh */ case   17:  		/* cmplw CR6, R31, R11 */
		/* 820A78DCh case   17:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820A78DCh case   17:*/		return 0x820A78E0;
		  /* 820A78E0h */ case   18:  		/* bc 4, CR6_LT, 104 */
		/* 820A78E0h case   18:*/		if ( !regs.CR[6].lt ) { return 0x820A7948;  }
		/* 820A78E0h case   18:*/		return 0x820A78E4;
		  /* 820A78E4h */ case   19:  		/* lbz R3, <#[R31]> */
		/* 820A78E4h case   19:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A78E4h case   19:*/		return 0x820A78E8;
		  /* 820A78E8h */ case   20:  		/* bl -57816 */
		/* 820A78E8h case   20:*/		regs.LR = 0x820A78EC; return 0x82099710;
		/* 820A78E8h case   20:*/		return 0x820A78EC;
		  /* 820A78ECh */ case   21:  		/* cmpwi CR0, R3, 0 */
		/* 820A78ECh case   21:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A78ECh case   21:*/		return 0x820A78F0;
		  /* 820A78F0h */ case   22:  		/* bc 12, CR0_EQ, 88 */
		/* 820A78F0h case   22:*/		if ( regs.CR[0].eq ) { return 0x820A7948;  }
		/* 820A78F0h case   22:*/		return 0x820A78F4;
		  /* 820A78F4h */ case   23:  		/* lis R11, 6553 */
		/* 820A78F4h case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0x1999);
		/* 820A78F4h case   23:*/		return 0x820A78F8;
		  /* 820A78F8h */ case   24:  		/* ori R11, R11, 39321 */
		/* 820A78F8h case   24:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x9999);
		/* 820A78F8h case   24:*/		return 0x820A78FC;
		  /* 820A78FCh */ case   25:  		/* cmpld CR6, R30, R11 */
		/* 820A78FCh case   25:*/		cpu::op::cmpld<6>(regs,regs.R30,regs.R11);
		/* 820A78FCh case   25:*/		return 0x820A7900;
		  /* 820A7900h */ case   26:  		/* bc 4, CR6_GT, 8 */
		/* 820A7900h case   26:*/		if ( !regs.CR[6].gt ) { return 0x820A7908;  }
		/* 820A7900h case   26:*/		return 0x820A7904;
		  /* 820A7904h */ case   27:  		/* li R27, 1 */
		/* 820A7904h case   27:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820A7904h case   27:*/		return 0x820A7908;
	}
	return 0x820A7908;
} // Block from 820A7898h-820A7908h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820A7908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7908);
		  /* 820A7908h */ case    0:  		/* lbz R10, <#[R31]> */
		/* 820A7908h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7908h case    0:*/		return 0x820A790C;
		  /* 820A790Ch */ case    1:  		/* mulli R11, R30, 10 */
		/* 820A790Ch case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R30,0xA);
		/* 820A790Ch case    1:*/		return 0x820A7910;
		  /* 820A7910h */ case    2:  		/* extsb R9, R10 */
		/* 820A7910h case    2:*/		cpu::op::extsb<0>(regs,&regs.R9,regs.R10);
		/* 820A7910h case    2:*/		return 0x820A7914;
		  /* 820A7914h */ case    3:  		/* add R9, R9, R11 */
		/* 820A7914h case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 820A7914h case    3:*/		return 0x820A7918;
		  /* 820A7918h */ case    4:  		/* addi R9, R9, -48 */
		/* 820A7918h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFD0);
		/* 820A7918h case    4:*/		return 0x820A791C;
		  /* 820A791Ch */ case    5:  		/* cmpld CR6, R9, R11 */
		/* 820A791Ch case    5:*/		cpu::op::cmpld<6>(regs,regs.R9,regs.R11);
		/* 820A791Ch case    5:*/		return 0x820A7920;
		  /* 820A7920h */ case    6:  		/* bc 4, CR6_LT, 8 */
		/* 820A7920h case    6:*/		if ( !regs.CR[6].lt ) { return 0x820A7928;  }
		/* 820A7920h case    6:*/		return 0x820A7924;
		  /* 820A7924h */ case    7:  		/* li R27, 1 */
		/* 820A7924h case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820A7924h case    7:*/		return 0x820A7928;
	}
	return 0x820A7928;
} // Block from 820A7908h-820A7928h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A7928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7928);
		  /* 820A7928h */ case    0:  		/* extsb R10, R10 */
		/* 820A7928h case    0:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820A7928h case    0:*/		return 0x820A792C;
		  /* 820A792Ch */ case    1:  		/* lwz R9, <#[R29 + 8]> */
		/* 820A792Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 820A792Ch case    1:*/		return 0x820A7930;
		  /* 820A7930h */ case    2:  		/* addi R31, R31, 1 */
		/* 820A7930h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A7930h case    2:*/		return 0x820A7934;
		  /* 820A7934h */ case    3:  		/* addi R10, R10, -48 */
		/* 820A7934h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFD0);
		/* 820A7934h case    3:*/		return 0x820A7938;
		  /* 820A7938h */ case    4:  		/* cmplw CR6, R31, R9 */
		/* 820A7938h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 820A7938h case    4:*/		return 0x820A793C;
		  /* 820A793Ch */ case    5:  		/* extsw R10, R10 */
		/* 820A793Ch case    5:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R10);
		/* 820A793Ch case    5:*/		return 0x820A7940;
		  /* 820A7940h */ case    6:  		/* add R30, R10, R11 */
		/* 820A7940h case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 820A7940h case    6:*/		return 0x820A7944;
		  /* 820A7944h */ case    7:  		/* bc 12, CR6_LT, -96 */
		/* 820A7944h case    7:*/		if ( regs.CR[6].lt ) { return 0x820A78E4;  }
		/* 820A7944h case    7:*/		return 0x820A7948;
	}
	return 0x820A7948;
} // Block from 820A7928h-820A7948h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A7948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7948);
		  /* 820A7948h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 820A7948h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820A7948h case    0:*/		return 0x820A794C;
		  /* 820A794Ch */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820A794Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820A7954;  }
		/* 820A794Ch case    1:*/		return 0x820A7950;
		  /* 820A7950h */ case    2:  		/* std R30, <#[R26]> */
		/* 820A7950h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R26 + 0x00000000) );
		/* 820A7950h case    2:*/		return 0x820A7954;
	}
	return 0x820A7954;
} // Block from 820A7948h-820A7954h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7954);
		  /* 820A7954h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 820A7954h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820A7954h case    0:*/		return 0x820A7958;
		  /* 820A7958h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820A7958h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A7974;  }
		/* 820A7958h case    1:*/		return 0x820A795C;
		  /* 820A795Ch */ case    2:  		/* lis R11, -32255 */
		/* 820A795Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A795Ch case    2:*/		return 0x820A7960;
		  /* 820A7960h */ case    3:  		/* lwz R3, <#[R29 + 64]> */
		/* 820A7960h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000040) );
		/* 820A7960h case    3:*/		return 0x820A7964;
		  /* 820A7964h */ case    4:  		/* li R5, 1004 */
		/* 820A7964h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x3EC);
		/* 820A7964h case    4:*/		return 0x820A7968;
		  /* 820A7968h */ case    5:  		/* addi R6, R11, -9016 */
		/* 820A7968h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFDCC8);
		/* 820A7968h case    5:*/		return 0x820A796C;
		  /* 820A796Ch */ case    6:  		/* addi R4, R29, 16 */
		/* 820A796Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0x10);
		/* 820A796Ch case    6:*/		return 0x820A7970;
		  /* 820A7970h */ case    7:  		/* bl -2016 */
		/* 820A7970h case    7:*/		regs.LR = 0x820A7974; return 0x820A7190;
		/* 820A7970h case    7:*/		return 0x820A7974;
	}
	return 0x820A7974;
} // Block from 820A7954h-820A7974h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A7974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7974);
		  /* 820A7974h */ case    0:  		/* subf R3, R28, R31 */
		/* 820A7974h case    0:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R28,regs.R31);
		/* 820A7974h case    0:*/		return 0x820A7978;
		  /* 820A7978h */ case    1:  		/* b 8 */
		/* 820A7978h case    1:*/		return 0x820A7980;
		/* 820A7978h case    1:*/		return 0x820A797C;
	}
	return 0x820A797C;
} // Block from 820A7974h-820A797Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A797Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A797C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A797C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A797C);
		  /* 820A797Ch */ case    0:  		/* li R3, 0 */
		/* 820A797Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A797Ch case    0:*/		return 0x820A7980;
	}
	return 0x820A7980;
} // Block from 820A797Ch-820A7980h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7980);
		  /* 820A7980h */ case    0:  		/* addi R1, R1, 176 */
		/* 820A7980h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820A7980h case    0:*/		return 0x820A7984;
		  /* 820A7984h */ case    1:  		/* b -91876 */
		/* 820A7984h case    1:*/		return 0x820912A0;
		/* 820A7984h case    1:*/		return 0x820A7988;
	}
	return 0x820A7988;
} // Block from 820A7980h-820A7988h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7988);
		  /* 820A7988h */ case    0:  		/* mfspr R12, LR */
		/* 820A7988h case    0:*/		regs.R12 = regs.LR;
		/* 820A7988h case    0:*/		return 0x820A798C;
		  /* 820A798Ch */ case    1:  		/* bl -91964 */
		/* 820A798Ch case    1:*/		regs.LR = 0x820A7990; return 0x82091250;
		/* 820A798Ch case    1:*/		return 0x820A7990;
		  /* 820A7990h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820A7990h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820A7990h case    2:*/		return 0x820A7994;
		  /* 820A7994h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820A7994h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A7994h case    3:*/		return 0x820A7998;
		  /* 820A7998h */ case    4:  		/* mr R28, R3 */
		/* 820A7998h case    4:*/		regs.R28 = regs.R3;
		/* 820A7998h case    4:*/		return 0x820A799C;
		  /* 820A799Ch */ case    5:  		/* mr R26, R4 */
		/* 820A799Ch case    5:*/		regs.R26 = regs.R4;
		/* 820A799Ch case    5:*/		return 0x820A79A0;
		  /* 820A79A0h */ case    6:  		/* mr R27, R5 */
		/* 820A79A0h case    6:*/		regs.R27 = regs.R5;
		/* 820A79A0h case    6:*/		return 0x820A79A4;
		  /* 820A79A4h */ case    7:  		/* cmplw CR6, R4, R11 */
		/* 820A79A4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820A79A4h case    7:*/		return 0x820A79A8;
		  /* 820A79A8h */ case    8:  		/* bc 12, CR6_LT, 12 */
		/* 820A79A8h case    8:*/		if ( regs.CR[6].lt ) { return 0x820A79B4;  }
		/* 820A79A8h case    8:*/		return 0x820A79AC;
		  /* 820A79ACh */ case    9:  		/* li R3, 0 */
		/* 820A79ACh case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A79ACh case    9:*/		return 0x820A79B0;
		  /* 820A79B0h */ case   10:  		/* b 472 */
		/* 820A79B0h case   10:*/		return 0x820A7B88;
		/* 820A79B0h case   10:*/		return 0x820A79B4;
	}
	return 0x820A79B4;
} // Block from 820A7988h-820A79B4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A79B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A79B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A79B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A79B4);
		  /* 820A79B4h */ case    0:  		/* lbz R10, <#[R26]> */
		/* 820A79B4h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820A79B4h case    0:*/		return 0x820A79B8;
		  /* 820A79B8h */ case    1:  		/* extsb R10, R10 */
		/* 820A79B8h case    1:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820A79B8h case    1:*/		return 0x820A79BC;
		  /* 820A79BCh */ case    2:  		/* cmpwi CR6, R10, 92 */
		/* 820A79BCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000005C);
		/* 820A79BCh case    2:*/		return 0x820A79C0;
		  /* 820A79C0h */ case    3:  		/* bc 4, CR6_EQ, 444 */
		/* 820A79C0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A7B7C;  }
		/* 820A79C0h case    3:*/		return 0x820A79C4;
		  /* 820A79C4h */ case    4:  		/* lwz R9, <#[R28 + 56]> */
		/* 820A79C4h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000038) );
		/* 820A79C4h case    4:*/		return 0x820A79C8;
		  /* 820A79C8h */ case    5:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 820A79C8h case    5:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 820A79C8h case    5:*/		return 0x820A79CC;
		  /* 820A79CCh */ case    6:  		/* bc 4, CR0_EQ, 432 */
		/* 820A79CCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x820A7B7C;  }
		/* 820A79CCh case    6:*/		return 0x820A79D0;
		  /* 820A79D0h */ case    7:  		/* addi R31, R26, 1 */
		/* 820A79D0h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R26,0x1);
		/* 820A79D0h case    7:*/		return 0x820A79D4;
		  /* 820A79D4h */ case    8:  		/* cmplw CR6, R31, R11 */
		/* 820A79D4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820A79D4h case    8:*/		return 0x820A79D8;
		  /* 820A79D8h */ case    9:  		/* bc 12, CR6_LT, 28 */
		/* 820A79D8h case    9:*/		if ( regs.CR[6].lt ) { return 0x820A79F4;  }
		/* 820A79D8h case    9:*/		return 0x820A79DC;
		  /* 820A79DCh */ case   10:  		/* lis R11, -32255 */
		/* 820A79DCh case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A79DCh case   10:*/		return 0x820A79E0;
		  /* 820A79E0h */ case   11:  		/* lwz R3, <#[R28 + 64]> */
		/* 820A79E0h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000040) );
		/* 820A79E0h case   11:*/		return 0x820A79E4;
		  /* 820A79E4h */ case   12:  		/* li R5, 1007 */
		/* 820A79E4h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x3EF);
		/* 820A79E4h case   12:*/		return 0x820A79E8;
		  /* 820A79E8h */ case   13:  		/* addi R6, R11, -8980 */
		/* 820A79E8h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFDCEC);
		/* 820A79E8h case   13:*/		return 0x820A79EC;
		  /* 820A79ECh */ case   14:  		/* addi R4, R28, 16 */
		/* 820A79ECh case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R28,0x10);
		/* 820A79ECh case   14:*/		return 0x820A79F0;
		  /* 820A79F0h */ case   15:  		/* bl -2144 */
		/* 820A79F0h case   15:*/		regs.LR = 0x820A79F4; return 0x820A7190;
		/* 820A79F0h case   15:*/		return 0x820A79F4;
	}
	return 0x820A79F4;
} // Block from 820A79B4h-820A79F4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A79F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A79F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A79F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A79F4);
		  /* 820A79F4h */ case    0:  		/* lbz R10, <#[R31]> */
		/* 820A79F4h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820A79F4h case    0:*/		return 0x820A79F8;
		  /* 820A79F8h */ case    1:  		/* mr R11, R10 */
		/* 820A79F8h case    1:*/		regs.R11 = regs.R10;
		/* 820A79F8h case    1:*/		return 0x820A79FC;
		  /* 820A79FCh */ case    2:  		/* cmplwi CR6, R10, 97 */
		/* 820A79FCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000061);
		/* 820A79FCh case    2:*/		return 0x820A7A00;
		  /* 820A7A00h */ case    3:  		/* bc 12, CR6_EQ, 364 */
		/* 820A7A00h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A7B6C;  }
		/* 820A7A00h case    3:*/		return 0x820A7A04;
		  /* 820A7A04h */ case    4:  		/* cmplwi CR6, R10, 98 */
		/* 820A7A04h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000062);
		/* 820A7A04h case    4:*/		return 0x820A7A08;
		  /* 820A7A08h */ case    5:  		/* bc 12, CR6_EQ, 348 */
		/* 820A7A08h case    5:*/		if ( regs.CR[6].eq ) { return 0x820A7B64;  }
		/* 820A7A08h case    5:*/		return 0x820A7A0C;
		  /* 820A7A0Ch */ case    6:  		/* cmplwi CR6, R10, 102 */
		/* 820A7A0Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 820A7A0Ch case    6:*/		return 0x820A7A10;
		  /* 820A7A10h */ case    7:  		/* bc 12, CR6_EQ, 332 */
		/* 820A7A10h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A7B5C;  }
		/* 820A7A10h case    7:*/		return 0x820A7A14;
		  /* 820A7A14h */ case    8:  		/* cmplwi CR6, R10, 110 */
		/* 820A7A14h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000006E);
		/* 820A7A14h case    8:*/		return 0x820A7A18;
		  /* 820A7A18h */ case    9:  		/* bc 12, CR6_EQ, 316 */
		/* 820A7A18h case    9:*/		if ( regs.CR[6].eq ) { return 0x820A7B54;  }
		/* 820A7A18h case    9:*/		return 0x820A7A1C;
		  /* 820A7A1Ch */ case   10:  		/* cmplwi CR6, R10, 114 */
		/* 820A7A1Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000072);
		/* 820A7A1Ch case   10:*/		return 0x820A7A20;
		  /* 820A7A20h */ case   11:  		/* bc 12, CR6_EQ, 300 */
		/* 820A7A20h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A7B4C;  }
		/* 820A7A20h case   11:*/		return 0x820A7A24;
		  /* 820A7A24h */ case   12:  		/* cmplwi CR6, R10, 116 */
		/* 820A7A24h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000074);
		/* 820A7A24h case   12:*/		return 0x820A7A28;
		  /* 820A7A28h */ case   13:  		/* bc 12, CR6_EQ, 284 */
		/* 820A7A28h case   13:*/		if ( regs.CR[6].eq ) { return 0x820A7B44;  }
		/* 820A7A28h case   13:*/		return 0x820A7A2C;
		  /* 820A7A2Ch */ case   14:  		/* cmplwi CR6, R10, 118 */
		/* 820A7A2Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000076);
		/* 820A7A2Ch case   14:*/		return 0x820A7A30;
		  /* 820A7A30h */ case   15:  		/* bc 12, CR6_EQ, 268 */
		/* 820A7A30h case   15:*/		if ( regs.CR[6].eq ) { return 0x820A7B3C;  }
		/* 820A7A30h case   15:*/		return 0x820A7A34;
		  /* 820A7A34h */ case   16:  		/* extsb R11, R10 */
		/* 820A7A34h case   16:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R10);
		/* 820A7A34h case   16:*/		return 0x820A7A38;
		  /* 820A7A38h */ case   17:  		/* cmpwi CR6, R11, 48 */
		/* 820A7A38h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 820A7A38h case   17:*/		return 0x820A7A3C;
		  /* 820A7A3Ch */ case   18:  		/* bc 12, CR6_LT, 92 */
		/* 820A7A3Ch case   18:*/		if ( regs.CR[6].lt ) { return 0x820A7A98;  }
		/* 820A7A3Ch case   18:*/		return 0x820A7A40;
		  /* 820A7A40h */ case   19:  		/* cmpwi CR6, R11, 55 */
		/* 820A7A40h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000037);
		/* 820A7A40h case   19:*/		return 0x820A7A44;
		  /* 820A7A44h */ case   20:  		/* bc 12, CR6_GT, 84 */
		/* 820A7A44h case   20:*/		if ( regs.CR[6].gt ) { return 0x820A7A98;  }
		/* 820A7A44h case   20:*/		return 0x820A7A48;
		  /* 820A7A48h */ case   21:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A7A48h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A7A48h case   21:*/		return 0x820A7A4C;
		  /* 820A7A4Ch */ case   22:  		/* addi R9, R31, 3 */
		/* 820A7A4Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x3);
		/* 820A7A4Ch case   22:*/		return 0x820A7A50;
		  /* 820A7A50h */ case   23:  		/* cmplw CR6, R9, R11 */
		/* 820A7A50h case   23:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820A7A50h case   23:*/		return 0x820A7A54;
		  /* 820A7A54h */ case   24:  		/* bc 12, CR6_LT, 8 */
		/* 820A7A54h case   24:*/		if ( regs.CR[6].lt ) { return 0x820A7A5C;  }
		/* 820A7A54h case   24:*/		return 0x820A7A58;
		  /* 820A7A58h */ case   25:  		/* mr R9, R11 */
		/* 820A7A58h case   25:*/		regs.R9 = regs.R11;
		/* 820A7A58h case   25:*/		return 0x820A7A5C;
	}
	return 0x820A7A5C;
} // Block from 820A79F4h-820A7A5Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 820A7A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7A5C);
		  /* 820A7A5Ch */ case    0:  		/* li R11, 0 */
		/* 820A7A5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A7A5Ch case    0:*/		return 0x820A7A60;
		  /* 820A7A60h */ case    1:  		/* b 44 */
		/* 820A7A60h case    1:*/		return 0x820A7A8C;
		/* 820A7A60h case    1:*/		return 0x820A7A64;
		  /* 820A7A64h */ case    2:  		/* lbz R10, <#[R31]> */
		/* 820A7A64h case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7A64h case    2:*/		return 0x820A7A68;
		  /* 820A7A68h */ case    3:  		/* extsb R10, R10 */
		/* 820A7A68h case    3:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820A7A68h case    3:*/		return 0x820A7A6C;
		  /* 820A7A6Ch */ case    4:  		/* cmpwi CR6, R10, 48 */
		/* 820A7A6Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000030);
		/* 820A7A6Ch case    4:*/		return 0x820A7A70;
		  /* 820A7A70h */ case    5:  		/* bc 12, CR6_LT, 260 */
		/* 820A7A70h case    5:*/		if ( regs.CR[6].lt ) { return 0x820A7B74;  }
		/* 820A7A70h case    5:*/		return 0x820A7A74;
		  /* 820A7A74h */ case    6:  		/* cmpwi CR6, R10, 55 */
		/* 820A7A74h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000037);
		/* 820A7A74h case    6:*/		return 0x820A7A78;
		  /* 820A7A78h */ case    7:  		/* bc 12, CR6_GT, 252 */
		/* 820A7A78h case    7:*/		if ( regs.CR[6].gt ) { return 0x820A7B74;  }
		/* 820A7A78h case    7:*/		return 0x820A7A7C;
		  /* 820A7A7Ch */ case    8:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 820A7A7Ch case    8:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 820A7A7Ch case    8:*/		return 0x820A7A80;
		  /* 820A7A80h */ case    9:  		/* addi R31, R31, 1 */
		/* 820A7A80h case    9:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A7A80h case    9:*/		return 0x820A7A84;
		  /* 820A7A84h */ case   10:  		/* add R11, R11, R10 */
		/* 820A7A84h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A7A84h case   10:*/		return 0x820A7A88;
		  /* 820A7A88h */ case   11:  		/* addi R11, R11, -48 */
		/* 820A7A88h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD0);
		/* 820A7A88h case   11:*/		return 0x820A7A8C;
	}
	return 0x820A7A8C;
} // Block from 820A7A5Ch-820A7A8Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A7A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7A8C);
		  /* 820A7A8Ch */ case    0:  		/* cmplw CR6, R31, R9 */
		/* 820A7A8Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 820A7A8Ch case    0:*/		return 0x820A7A90;
		  /* 820A7A90h */ case    1:  		/* bc 12, CR6_LT, -44 */
		/* 820A7A90h case    1:*/		if ( regs.CR[6].lt ) { return 0x820A7A64;  }
		/* 820A7A90h case    1:*/		return 0x820A7A94;
		  /* 820A7A94h */ case    2:  		/* b 224 */
		/* 820A7A94h case    2:*/		return 0x820A7B74;
		/* 820A7A94h case    2:*/		return 0x820A7A98;
	}
	return 0x820A7A98;
} // Block from 820A7A8Ch-820A7A98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7A98h
// Function '?StringCbCatA@@YAJPADIPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7A98);
		  /* 820A7A98h */ case    0:  		/* cmpwi CR6, R11, 120 */
		/* 820A7A98h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000078);
		/* 820A7A98h case    0:*/		return 0x820A7A9C;
		  /* 820A7A9Ch */ case    1:  		/* bc 4, CR6_EQ, 148 */
		/* 820A7A9Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A7B30;  }
		/* 820A7A9Ch case    1:*/		return 0x820A7AA0;
		  /* 820A7AA0h */ case    2:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A7AA0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A7AA0h case    2:*/		return 0x820A7AA4;
		  /* 820A7AA4h */ case    3:  		/* addi R29, R31, 1 */
		/* 820A7AA4h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x1);
		/* 820A7AA4h case    3:*/		return 0x820A7AA8;
		  /* 820A7AA8h */ case    4:  		/* cmplw CR6, R29, R11 */
		/* 820A7AA8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820A7AA8h case    4:*/		return 0x820A7AAC;
		  /* 820A7AACh */ case    5:  		/* bc 4, CR6_LT, 132 */
		/* 820A7AACh case    5:*/		if ( !regs.CR[6].lt ) { return 0x820A7B30;  }
		/* 820A7AACh case    5:*/		return 0x820A7AB0;
		  /* 820A7AB0h */ case    6:  		/* lbz R3, <#[R29]> */
		/* 820A7AB0h case    6:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 820A7AB0h case    6:*/		return 0x820A7AB4;
		  /* 820A7AB4h */ case    7:  		/* bl -58244 */
		/* 820A7AB4h case    7:*/		regs.LR = 0x820A7AB8; return 0x82099730;
		/* 820A7AB4h case    7:*/		return 0x820A7AB8;
		  /* 820A7AB8h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820A7AB8h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A7AB8h case    8:*/		return 0x820A7ABC;
		  /* 820A7ABCh */ case    9:  		/* bc 12, CR0_EQ, 116 */
		/* 820A7ABCh case    9:*/		if ( regs.CR[0].eq ) { return 0x820A7B30;  }
		/* 820A7ABCh case    9:*/		return 0x820A7AC0;
		  /* 820A7AC0h */ case   10:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A7AC0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A7AC0h case   10:*/		return 0x820A7AC4;
		  /* 820A7AC4h */ case   11:  		/* mr R31, R29 */
		/* 820A7AC4h case   11:*/		regs.R31 = regs.R29;
		/* 820A7AC4h case   11:*/		return 0x820A7AC8;
		  /* 820A7AC8h */ case   12:  		/* li R30, 0 */
		/* 820A7AC8h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A7AC8h case   12:*/		return 0x820A7ACC;
		  /* 820A7ACCh */ case   13:  		/* cmplw CR6, R29, R11 */
		/* 820A7ACCh case   13:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820A7ACCh case   13:*/		return 0x820A7AD0;
		  /* 820A7AD0h */ case   14:  		/* bc 4, CR6_LT, 88 */
		/* 820A7AD0h case   14:*/		if ( !regs.CR[6].lt ) { return 0x820A7B28;  }
		/* 820A7AD0h case   14:*/		return 0x820A7AD4;
		  /* 820A7AD4h */ case   15:  		/* lbz R3, <#[R31]> */
		/* 820A7AD4h case   15:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7AD4h case   15:*/		return 0x820A7AD8;
		  /* 820A7AD8h */ case   16:  		/* bl -58280 */
		/* 820A7AD8h case   16:*/		regs.LR = 0x820A7ADC; return 0x82099730;
		/* 820A7AD8h case   16:*/		return 0x820A7ADC;
		  /* 820A7ADCh */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820A7ADCh case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A7ADCh case   17:*/		return 0x820A7AE0;
		  /* 820A7AE0h */ case   18:  		/* bc 12, CR0_EQ, 72 */
		/* 820A7AE0h case   18:*/		if ( regs.CR[0].eq ) { return 0x820A7B28;  }
		/* 820A7AE0h case   18:*/		return 0x820A7AE4;
		  /* 820A7AE4h */ case   19:  		/* lbz R11, <#[R31]> */
		/* 820A7AE4h case   19:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7AE4h case   19:*/		return 0x820A7AE8;
		  /* 820A7AE8h */ case   20:  		/* rlwinm R10, R30, 4, 0, 27 */
		/* 820A7AE8h case   20:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R30);
		/* 820A7AE8h case   20:*/		return 0x820A7AEC;
		  /* 820A7AECh */ case   21:  		/* extsb R11, R11 */
		/* 820A7AECh case   21:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820A7AECh case   21:*/		return 0x820A7AF0;
		  /* 820A7AF0h */ case   22:  		/* cmpwi CR6, R11, 97 */
		/* 820A7AF0h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000061);
		/* 820A7AF0h case   22:*/		return 0x820A7AF4;
		  /* 820A7AF4h */ case   23:  		/* bc 12, CR6_LT, 16 */
		/* 820A7AF4h case   23:*/		if ( regs.CR[6].lt ) { return 0x820A7B04;  }
		/* 820A7AF4h case   23:*/		return 0x820A7AF8;
		  /* 820A7AF8h */ case   24:  		/* add R11, R11, R10 */
		/* 820A7AF8h case   24:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A7AF8h case   24:*/		return 0x820A7AFC;
		  /* 820A7AFCh */ case   25:  		/* addi R30, R11, -87 */
		/* 820A7AFCh case   25:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFA9);
		/* 820A7AFCh case   25:*/		return 0x820A7B00;
	}
	return 0x820A7B00;
} // Block from 820A7A98h-820A7B00h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B00h
// Function '?ErrorVa@CTErrors@D3DXShader@@QAAJPBUD3DXTOKEN@2@IPBDPAD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B00);
		  /* 820A7B00h */ case    0:  		/* b 24 */
		/* 820A7B00h case    0:*/		return 0x820A7B18;
		/* 820A7B00h case    0:*/		return 0x820A7B04;
	}
	return 0x820A7B04;
} // Block from 820A7B00h-820A7B04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B04);
		  /* 820A7B04h */ case    0:  		/* cmpwi CR6, R11, 65 */
		/* 820A7B04h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000041);
		/* 820A7B04h case    0:*/		return 0x820A7B08;
		  /* 820A7B08h */ case    1:  		/* add R11, R11, R10 */
		/* 820A7B08h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820A7B08h case    1:*/		return 0x820A7B0C;
		  /* 820A7B0Ch */ case    2:  		/* addi R30, R11, -55 */
		/* 820A7B0Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFC9);
		/* 820A7B0Ch case    2:*/		return 0x820A7B10;
		  /* 820A7B10h */ case    3:  		/* bc 4, CR6_LT, 8 */
		/* 820A7B10h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820A7B18;  }
		/* 820A7B10h case    3:*/		return 0x820A7B14;
		  /* 820A7B14h */ case    4:  		/* addi R30, R11, -48 */
		/* 820A7B14h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFD0);
		/* 820A7B14h case    4:*/		return 0x820A7B18;
	}
	return 0x820A7B18;
} // Block from 820A7B04h-820A7B18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B18);
		  /* 820A7B18h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 820A7B18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820A7B18h case    0:*/		return 0x820A7B1C;
		  /* 820A7B1Ch */ case    1:  		/* addi R31, R31, 1 */
		/* 820A7B1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A7B1Ch case    1:*/		return 0x820A7B20;
		  /* 820A7B20h */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 820A7B20h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820A7B20h case    2:*/		return 0x820A7B24;
		  /* 820A7B24h */ case    3:  		/* bc 12, CR6_LT, -80 */
		/* 820A7B24h case    3:*/		if ( regs.CR[6].lt ) { return 0x820A7AD4;  }
		/* 820A7B24h case    3:*/		return 0x820A7B28;
	}
	return 0x820A7B28;
} // Block from 820A7B18h-820A7B28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B28);
		  /* 820A7B28h */ case    0:  		/* stw R30, <#[R27]> */
		/* 820A7B28h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R27 + 0x00000000) );
		/* 820A7B28h case    0:*/		return 0x820A7B2C;
		  /* 820A7B2Ch */ case    1:  		/* b 88 */
		/* 820A7B2Ch case    1:*/		return 0x820A7B84;
		/* 820A7B2Ch case    1:*/		return 0x820A7B30;
	}
	return 0x820A7B30;
} // Block from 820A7B28h-820A7B30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B30);
		  /* 820A7B30h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820A7B30h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7B30h case    0:*/		return 0x820A7B34;
		  /* 820A7B34h */ case    1:  		/* extsb R11, R11 */
		/* 820A7B34h case    1:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820A7B34h case    1:*/		return 0x820A7B38;
		  /* 820A7B38h */ case    2:  		/* b 56 */
		/* 820A7B38h case    2:*/		return 0x820A7B70;
		/* 820A7B38h case    2:*/		return 0x820A7B3C;
	}
	return 0x820A7B3C;
} // Block from 820A7B30h-820A7B3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B3C);
		  /* 820A7B3Ch */ case    0:  		/* li R11, 11 */
		/* 820A7B3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 820A7B3Ch case    0:*/		return 0x820A7B40;
		  /* 820A7B40h */ case    1:  		/* b 48 */
		/* 820A7B40h case    1:*/		return 0x820A7B70;
		/* 820A7B40h case    1:*/		return 0x820A7B44;
	}
	return 0x820A7B44;
} // Block from 820A7B3Ch-820A7B44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B44);
		  /* 820A7B44h */ case    0:  		/* li R11, 9 */
		/* 820A7B44h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 820A7B44h case    0:*/		return 0x820A7B48;
		  /* 820A7B48h */ case    1:  		/* b 40 */
		/* 820A7B48h case    1:*/		return 0x820A7B70;
		/* 820A7B48h case    1:*/		return 0x820A7B4C;
	}
	return 0x820A7B4C;
} // Block from 820A7B44h-820A7B4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B4C);
		  /* 820A7B4Ch */ case    0:  		/* li R11, 13 */
		/* 820A7B4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 820A7B4Ch case    0:*/		return 0x820A7B50;
		  /* 820A7B50h */ case    1:  		/* b 32 */
		/* 820A7B50h case    1:*/		return 0x820A7B70;
		/* 820A7B50h case    1:*/		return 0x820A7B54;
	}
	return 0x820A7B54;
} // Block from 820A7B4Ch-820A7B54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B54);
		  /* 820A7B54h */ case    0:  		/* li R11, 10 */
		/* 820A7B54h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 820A7B54h case    0:*/		return 0x820A7B58;
		  /* 820A7B58h */ case    1:  		/* b 24 */
		/* 820A7B58h case    1:*/		return 0x820A7B70;
		/* 820A7B58h case    1:*/		return 0x820A7B5C;
	}
	return 0x820A7B5C;
} // Block from 820A7B54h-820A7B5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B5C);
		  /* 820A7B5Ch */ case    0:  		/* li R11, 12 */
		/* 820A7B5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820A7B5Ch case    0:*/		return 0x820A7B60;
		  /* 820A7B60h */ case    1:  		/* b 16 */
		/* 820A7B60h case    1:*/		return 0x820A7B70;
		/* 820A7B60h case    1:*/		return 0x820A7B64;
	}
	return 0x820A7B64;
} // Block from 820A7B5Ch-820A7B64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B64);
		  /* 820A7B64h */ case    0:  		/* li R11, 8 */
		/* 820A7B64h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820A7B64h case    0:*/		return 0x820A7B68;
		  /* 820A7B68h */ case    1:  		/* b 8 */
		/* 820A7B68h case    1:*/		return 0x820A7B70;
		/* 820A7B68h case    1:*/		return 0x820A7B6C;
	}
	return 0x820A7B6C;
} // Block from 820A7B64h-820A7B6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B6C);
		  /* 820A7B6Ch */ case    0:  		/* li R11, 7 */
		/* 820A7B6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820A7B6Ch case    0:*/		return 0x820A7B70;
	}
	return 0x820A7B70;
} // Block from 820A7B6Ch-820A7B70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B70);
		  /* 820A7B70h */ case    0:  		/* addi R31, R31, 1 */
		/* 820A7B70h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A7B70h case    0:*/		return 0x820A7B74;
	}
	return 0x820A7B74;
} // Block from 820A7B70h-820A7B74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B74);
		  /* 820A7B74h */ case    0:  		/* stw R11, <#[R27]> */
		/* 820A7B74h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A7B74h case    0:*/		return 0x820A7B78;
		  /* 820A7B78h */ case    1:  		/* b 12 */
		/* 820A7B78h case    1:*/		return 0x820A7B84;
		/* 820A7B78h case    1:*/		return 0x820A7B7C;
	}
	return 0x820A7B7C;
} // Block from 820A7B74h-820A7B7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B7C);
		  /* 820A7B7Ch */ case    0:  		/* stw R10, <#[R27]> */
		/* 820A7B7Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 820A7B7Ch case    0:*/		return 0x820A7B80;
		  /* 820A7B80h */ case    1:  		/* addi R31, R26, 1 */
		/* 820A7B80h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R26,0x1);
		/* 820A7B80h case    1:*/		return 0x820A7B84;
	}
	return 0x820A7B84;
} // Block from 820A7B7Ch-820A7B84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B84);
		  /* 820A7B84h */ case    0:  		/* subf R3, R26, R31 */
		/* 820A7B84h case    0:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R26,regs.R31);
		/* 820A7B84h case    0:*/		return 0x820A7B88;
	}
	return 0x820A7B88;
} // Block from 820A7B84h-820A7B88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B88);
		  /* 820A7B88h */ case    0:  		/* addi R1, R1, 176 */
		/* 820A7B88h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820A7B88h case    0:*/		return 0x820A7B8C;
		  /* 820A7B8Ch */ case    1:  		/* b -92396 */
		/* 820A7B8Ch case    1:*/		return 0x820912A0;
		/* 820A7B8Ch case    1:*/		return 0x820A7B90;
	}
	return 0x820A7B90;
} // Block from 820A7B88h-820A7B90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A7B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7B90);
		  /* 820A7B90h */ case    0:  		/* mfspr R12, LR */
		/* 820A7B90h case    0:*/		regs.R12 = regs.LR;
		/* 820A7B90h case    0:*/		return 0x820A7B94;
		  /* 820A7B94h */ case    1:  		/* bl -92476 */
		/* 820A7B94h case    1:*/		regs.LR = 0x820A7B98; return 0x82091258;
		/* 820A7B94h case    1:*/		return 0x820A7B98;
		  /* 820A7B98h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820A7B98h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820A7B98h case    2:*/		return 0x820A7B9C;
		  /* 820A7B9Ch */ case    3:  		/* lwz R11, <#[R3 + 56]> */
		/* 820A7B9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820A7B9Ch case    3:*/		return 0x820A7BA0;
		  /* 820A7BA0h */ case    4:  		/* mr R31, R3 */
		/* 820A7BA0h case    4:*/		regs.R31 = regs.R3;
		/* 820A7BA0h case    4:*/		return 0x820A7BA4;
		  /* 820A7BA4h */ case    5:  		/* mr R29, R4 */
		/* 820A7BA4h case    5:*/		regs.R29 = regs.R4;
		/* 820A7BA4h case    5:*/		return 0x820A7BA8;
		  /* 820A7BA8h */ case    6:  		/* mr R28, R5 */
		/* 820A7BA8h case    6:*/		regs.R28 = regs.R5;
		/* 820A7BA8h case    6:*/		return 0x820A7BAC;
		  /* 820A7BACh */ case    7:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820A7BACh case    7:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820A7BACh case    7:*/		return 0x820A7BB0;
		  /* 820A7BB0h */ case    8:  		/* bc 12, CR0_EQ, 304 */
		/* 820A7BB0h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A7CE0;  }
		/* 820A7BB0h case    8:*/		return 0x820A7BB4;
		  /* 820A7BB4h */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 820A7BB4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A7BB4h case    9:*/		return 0x820A7BB8;
	}
	return 0x820A7BB8;
} // Block from 820A7B90h-820A7BB8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A7BB8h
// Function '?Error@CTErrors@D3DXShader@@QAAJPBUD3DXTOKEN@2@IPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7BB8);
		  /* 820A7BB8h */ case    0:  		/* addi R30, R4, 1 */
		/* 820A7BB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R4,0x1);
		/* 820A7BB8h case    0:*/		return 0x820A7BBC;
		  /* 820A7BBCh */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 820A7BBCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820A7BBCh case    1:*/		return 0x820A7BC0;
		  /* 820A7BC0h */ case    2:  		/* bc 4, CR6_LT, 288 */
		/* 820A7BC0h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820A7CE0;  }
		/* 820A7BC0h case    2:*/		return 0x820A7BC4;
		  /* 820A7BC4h */ case    3:  		/* lbz R3, <#[R4]> */
		/* 820A7BC4h case    3:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000000) );
		/* 820A7BC4h case    3:*/		return 0x820A7BC8;
		  /* 820A7BC8h */ case    4:  		/* bl -58584 */
		/* 820A7BC8h case    4:*/		regs.LR = 0x820A7BCC; return 0x820996F0;
		/* 820A7BC8h case    4:*/		return 0x820A7BCC;
		  /* 820A7BCCh */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820A7BCCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A7BCCh case    5:*/		return 0x820A7BD0;
		  /* 820A7BD0h */ case    6:  		/* bc 12, CR0_EQ, 272 */
		/* 820A7BD0h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A7CE0;  }
		/* 820A7BD0h case    6:*/		return 0x820A7BD4;
		  /* 820A7BD4h */ case    7:  		/* lbz R3, <#[R30]> */
		/* 820A7BD4h case    7:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A7BD4h case    7:*/		return 0x820A7BD8;
		  /* 820A7BD8h */ case    8:  		/* bl -58600 */
		/* 820A7BD8h case    8:*/		regs.LR = 0x820A7BDC; return 0x820996F0;
		/* 820A7BD8h case    8:*/		return 0x820A7BDC;
		  /* 820A7BDCh */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820A7BDCh case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A7BDCh case    9:*/		return 0x820A7BE0;
		  /* 820A7BE0h */ case   10:  		/* bc 12, CR0_EQ, 256 */
		/* 820A7BE0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820A7CE0;  }
		/* 820A7BE0h case   10:*/		return 0x820A7BE4;
		  /* 820A7BE4h */ case   11:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A7BE4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7BE4h case   11:*/		return 0x820A7BE8;
		  /* 820A7BE8h */ case   12:  		/* addi R11, R29, 2 */
		/* 820A7BE8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x2);
		/* 820A7BE8h case   12:*/		return 0x820A7BEC;
		  /* 820A7BECh */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820A7BECh case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7BECh case   13:*/		return 0x820A7BF0;
		  /* 820A7BF0h */ case   14:  		/* bc 4, CR6_LT, 240 */
		/* 820A7BF0h case   14:*/		if ( !regs.CR[6].lt ) { return 0x820A7CE0;  }
		/* 820A7BF0h case   14:*/		return 0x820A7BF4;
		  /* 820A7BF4h */ case   15:  		/* lbz R10, <#[R11]> */
		/* 820A7BF4h case   15:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7BF4h case   15:*/		return 0x820A7BF8;
		  /* 820A7BF8h */ case   16:  		/* cmplwi CR6, R10, 46 */
		/* 820A7BF8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000002E);
		/* 820A7BF8h case   16:*/		return 0x820A7BFC;
		  /* 820A7BFCh */ case   17:  		/* bc 4, CR6_EQ, 228 */
		/* 820A7BFCh case   17:*/		if ( !regs.CR[6].eq ) { return 0x820A7CE0;  }
		/* 820A7BFCh case   17:*/		return 0x820A7C00;
	}
	return 0x820A7C00;
} // Block from 820A7BB8h-820A7C00h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820A7C00h
// Function '?WarningVa@CTErrors@D3DXShader@@QAAJPBUD3DXTOKEN@2@IPBDPAD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7C00);
		  /* 820A7C00h */ case    0:  		/* addi R30, R11, 1 */
		/* 820A7C00h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1);
		/* 820A7C00h case    0:*/		return 0x820A7C04;
		  /* 820A7C04h */ case    1:  		/* addi R5, R1, 80 */
		/* 820A7C04h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820A7C04h case    1:*/		return 0x820A7C08;
		  /* 820A7C08h */ case    2:  		/* mr R4, R30 */
		/* 820A7C08h case    2:*/		regs.R4 = regs.R30;
		/* 820A7C08h case    2:*/		return 0x820A7C0C;
		  /* 820A7C0Ch */ case    3:  		/* mr R3, R31 */
		/* 820A7C0Ch case    3:*/		regs.R3 = regs.R31;
		/* 820A7C0Ch case    3:*/		return 0x820A7C10;
		  /* 820A7C10h */ case    4:  		/* bl -888 */
		/* 820A7C10h case    4:*/		regs.LR = 0x820A7C14; return 0x820A7898;
		/* 820A7C10h case    4:*/		return 0x820A7C14;
		  /* 820A7C14h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820A7C14h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A7C14h case    5:*/		return 0x820A7C18;
		  /* 820A7C18h */ case    6:  		/* bc 12, CR0_EQ, 200 */
		/* 820A7C18h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A7CE0;  }
		/* 820A7C18h case    6:*/		return 0x820A7C1C;
		  /* 820A7C1Ch */ case    7:  		/* ld R11, <#[R1 + 80]> */
		/* 820A7C1Ch case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A7C1Ch case    7:*/		return 0x820A7C20;
		  /* 820A7C20h */ case    8:  		/* cmpldi CR6, R11, 255 */
		/* 820A7C20h case    8:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x000000FF);
		/* 820A7C20h case    8:*/		return 0x820A7C24;
		  /* 820A7C24h */ case    9:  		/* bc 12, CR6_GT, 188 */
		/* 820A7C24h case    9:*/		if ( regs.CR[6].gt ) { return 0x820A7CE0;  }
		/* 820A7C24h case    9:*/		return 0x820A7C28;
		  /* 820A7C28h */ case   10:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A7C28h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7C28h case   10:*/		return 0x820A7C2C;
		  /* 820A7C2Ch */ case   11:  		/* add R11, R3, R30 */
		/* 820A7C2Ch case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R30);
		/* 820A7C2Ch case   11:*/		return 0x820A7C30;
		  /* 820A7C30h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 820A7C30h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7C30h case   12:*/		return 0x820A7C34;
		  /* 820A7C34h */ case   13:  		/* bc 4, CR6_LT, 172 */
		/* 820A7C34h case   13:*/		if ( !regs.CR[6].lt ) { return 0x820A7CE0;  }
		/* 820A7C34h case   13:*/		return 0x820A7C38;
		  /* 820A7C38h */ case   14:  		/* lbz R10, <#[R11]> */
		/* 820A7C38h case   14:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7C38h case   14:*/		return 0x820A7C3C;
		  /* 820A7C3Ch */ case   15:  		/* cmplwi CR6, R10, 46 */
		/* 820A7C3Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000002E);
		/* 820A7C3Ch case   15:*/		return 0x820A7C40;
		  /* 820A7C40h */ case   16:  		/* bc 4, CR6_EQ, 160 */
		/* 820A7C40h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820A7CE0;  }
		/* 820A7C40h case   16:*/		return 0x820A7C44;
		  /* 820A7C44h */ case   17:  		/* addi R30, R11, 1 */
		/* 820A7C44h case   17:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1);
		/* 820A7C44h case   17:*/		return 0x820A7C48;
		  /* 820A7C48h */ case   18:  		/* addi R5, R1, 80 */
		/* 820A7C48h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820A7C48h case   18:*/		return 0x820A7C4C;
		  /* 820A7C4Ch */ case   19:  		/* mr R4, R30 */
		/* 820A7C4Ch case   19:*/		regs.R4 = regs.R30;
		/* 820A7C4Ch case   19:*/		return 0x820A7C50;
		  /* 820A7C50h */ case   20:  		/* mr R3, R31 */
		/* 820A7C50h case   20:*/		regs.R3 = regs.R31;
		/* 820A7C50h case   20:*/		return 0x820A7C54;
		  /* 820A7C54h */ case   21:  		/* bl -956 */
		/* 820A7C54h case   21:*/		regs.LR = 0x820A7C58; return 0x820A7898;
		/* 820A7C54h case   21:*/		return 0x820A7C58;
		  /* 820A7C58h */ case   22:  		/* cmplwi CR0, R3, 0 */
		/* 820A7C58h case   22:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A7C58h case   22:*/		return 0x820A7C5C;
		  /* 820A7C5Ch */ case   23:  		/* bc 4, CR0_EQ, 36 */
		/* 820A7C5Ch case   23:*/		if ( !regs.CR[0].eq ) { return 0x820A7C80;  }
		/* 820A7C5Ch case   23:*/		return 0x820A7C60;
		  /* 820A7C60h */ case   24:  		/* addi R5, R1, 80 */
		/* 820A7C60h case   24:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820A7C60h case   24:*/		return 0x820A7C64;
		  /* 820A7C64h */ case   25:  		/* mr R4, R30 */
		/* 820A7C64h case   25:*/		regs.R4 = regs.R30;
		/* 820A7C64h case   25:*/		return 0x820A7C68;
		  /* 820A7C68h */ case   26:  		/* mr R3, R31 */
		/* 820A7C68h case   26:*/		regs.R3 = regs.R31;
		/* 820A7C68h case   26:*/		return 0x820A7C6C;
		  /* 820A7C6Ch */ case   27:  		/* bl -4148 */
		/* 820A7C6Ch case   27:*/		regs.LR = 0x820A7C70; return 0x820A6C38;
		/* 820A7C6Ch case   27:*/		return 0x820A7C70;
		  /* 820A7C70h */ case   28:  		/* cmplwi CR0, R3, 0 */
		/* 820A7C70h case   28:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A7C70h case   28:*/		return 0x820A7C74;
		  /* 820A7C74h */ case   29:  		/* bc 12, CR0_EQ, 108 */
		/* 820A7C74h case   29:*/		if ( regs.CR[0].eq ) { return 0x820A7CE0;  }
		/* 820A7C74h case   29:*/		return 0x820A7C78;
		  /* 820A7C78h */ case   30:  		/* li R11, 0 */
		/* 820A7C78h case   30:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A7C78h case   30:*/		return 0x820A7C7C;
		  /* 820A7C7Ch */ case   31:  		/* b 8 */
		/* 820A7C7Ch case   31:*/		return 0x820A7C84;
		/* 820A7C7Ch case   31:*/		return 0x820A7C80;
	}
	return 0x820A7C80;
} // Block from 820A7C00h-820A7C80h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820A7C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7C80);
		  /* 820A7C80h */ case    0:  		/* ld R11, <#[R1 + 80]> */
		/* 820A7C80h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A7C80h case    0:*/		return 0x820A7C84;
	}
	return 0x820A7C84;
} // Block from 820A7C80h-820A7C84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7C84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7C84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7C84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7C84);
		  /* 820A7C84h */ case    0:  		/* cmpldi CR6, R11, 255 */
		/* 820A7C84h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x000000FF);
		/* 820A7C84h case    0:*/		return 0x820A7C88;
		  /* 820A7C88h */ case    1:  		/* bc 12, CR6_GT, 88 */
		/* 820A7C88h case    1:*/		if ( regs.CR[6].gt ) { return 0x820A7CE0;  }
		/* 820A7C88h case    1:*/		return 0x820A7C8C;
		  /* 820A7C8Ch */ case    2:  		/* add R11, R3, R30 */
		/* 820A7C8Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R30);
		/* 820A7C8Ch case    2:*/		return 0x820A7C90;
		  /* 820A7C90h */ case    3:  		/* subf R31, R29, R11 */
		/* 820A7C90h case    3:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R29,regs.R11);
		/* 820A7C90h case    3:*/		return 0x820A7C94;
		  /* 820A7C94h */ case    4:  		/* cmplwi CR6, R31, 32 */
		/* 820A7C94h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000020);
		/* 820A7C94h case    4:*/		return 0x820A7C98;
		  /* 820A7C98h */ case    5:  		/* bc 4, CR6_LT, 72 */
		/* 820A7C98h case    5:*/		if ( !regs.CR[6].lt ) { return 0x820A7CE0;  }
		/* 820A7C98h case    5:*/		return 0x820A7C9C;
		  /* 820A7C9Ch */ case    6:  		/* mr R5, R31 */
		/* 820A7C9Ch case    6:*/		regs.R5 = regs.R31;
		/* 820A7C9Ch case    6:*/		return 0x820A7CA0;
		  /* 820A7CA0h */ case    7:  		/* mr R4, R29 */
		/* 820A7CA0h case    7:*/		regs.R4 = regs.R29;
		/* 820A7CA0h case    7:*/		return 0x820A7CA4;
		  /* 820A7CA4h */ case    8:  		/* addi R3, R1, 112 */
		/* 820A7CA4h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 820A7CA4h case    8:*/		return 0x820A7CA8;
		  /* 820A7CA8h */ case    9:  		/* bl -90872 */
		/* 820A7CA8h case    9:*/		regs.LR = 0x820A7CAC; return 0x820919B0;
		/* 820A7CA8h case    9:*/		return 0x820A7CAC;
		  /* 820A7CACh */ case   10:  		/* addi R11, R1, 112 */
		/* 820A7CACh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820A7CACh case   10:*/		return 0x820A7CB0;
		  /* 820A7CB0h */ case   11:  		/* li R10, 0 */
		/* 820A7CB0h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A7CB0h case   11:*/		return 0x820A7CB4;
		  /* 820A7CB4h */ case   12:  		/* addi R5, R1, 88 */
		/* 820A7CB4h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 820A7CB4h case   12:*/		return 0x820A7CB8;
		  /* 820A7CB8h */ case   13:  		/* li R4, 1 */
		/* 820A7CB8h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A7CB8h case   13:*/		return 0x820A7CBC;
		  /* 820A7CBCh */ case   14:  		/* addi R3, R1, 112 */
		/* 820A7CBCh case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 820A7CBCh case   14:*/		return 0x820A7CC0;
		  /* 820A7CC0h */ case   15:  		/* stbx R10, <#[R31 + R11]> */
		/* 820A7CC0h case   15:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820A7CC0h case   15:*/		return 0x820A7CC4;
		  /* 820A7CC4h */ case   16:  		/* bl -36660 */
		/* 820A7CC4h case   16:*/		regs.LR = 0x820A7CC8; return 0x8209ED90;
		/* 820A7CC4h case   16:*/		return 0x820A7CC8;
		  /* 820A7CC8h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820A7CC8h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A7CC8h case   17:*/		return 0x820A7CCC;
		  /* 820A7CCCh */ case   18:  		/* bc 12, CR0_LT, 20 */
		/* 820A7CCCh case   18:*/		if ( regs.CR[0].lt ) { return 0x820A7CE0;  }
		/* 820A7CCCh case   18:*/		return 0x820A7CD0;
		  /* 820A7CD0h */ case   19:  		/* lwz R11, <#[R1 + 92]> */
		/* 820A7CD0h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820A7CD0h case   19:*/		return 0x820A7CD4;
		  /* 820A7CD4h */ case   20:  		/* mr R3, R31 */
		/* 820A7CD4h case   20:*/		regs.R3 = regs.R31;
		/* 820A7CD4h case   20:*/		return 0x820A7CD8;
		  /* 820A7CD8h */ case   21:  		/* stw R11, <#[R28]> */
		/* 820A7CD8h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820A7CD8h case   21:*/		return 0x820A7CDC;
		  /* 820A7CDCh */ case   22:  		/* b 8 */
		/* 820A7CDCh case   22:*/		return 0x820A7CE4;
		/* 820A7CDCh case   22:*/		return 0x820A7CE0;
	}
	return 0x820A7CE0;
} // Block from 820A7C84h-820A7CE0h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820A7CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7CE0);
		  /* 820A7CE0h */ case    0:  		/* li R3, 0 */
		/* 820A7CE0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A7CE0h case    0:*/		return 0x820A7CE4;
	}
	return 0x820A7CE4;
} // Block from 820A7CE0h-820A7CE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7CE4);
		  /* 820A7CE4h */ case    0:  		/* addi R1, R1, 192 */
		/* 820A7CE4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820A7CE4h case    0:*/		return 0x820A7CE8;
		  /* 820A7CE8h */ case    1:  		/* b -92736 */
		/* 820A7CE8h case    1:*/		return 0x820912A8;
		/* 820A7CE8h case    1:*/		return 0x820A7CEC;
		  /* 820A7CECh */ case    2:  		/* nop */
		/* 820A7CECh case    2:*/		cpu::op::nop();
		/* 820A7CECh case    2:*/		return 0x820A7CF0;
	}
	return 0x820A7CF0;
} // Block from 820A7CE4h-820A7CF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7CF0);
		  /* 820A7CF0h */ case    0:  		/* mfspr R12, LR */
		/* 820A7CF0h case    0:*/		regs.R12 = regs.LR;
		/* 820A7CF0h case    0:*/		return 0x820A7CF4;
		  /* 820A7CF4h */ case    1:  		/* bl -92824 */
		/* 820A7CF4h case    1:*/		regs.LR = 0x820A7CF8; return 0x8209125C;
		/* 820A7CF4h case    1:*/		return 0x820A7CF8;
		  /* 820A7CF8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820A7CF8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820A7CF8h case    2:*/		return 0x820A7CFC;
		  /* 820A7CFCh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820A7CFCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A7CFCh case    3:*/		return 0x820A7D00;
		  /* 820A7D00h */ case    4:  		/* mr R31, R3 */
		/* 820A7D00h case    4:*/		regs.R31 = regs.R3;
		/* 820A7D00h case    4:*/		return 0x820A7D04;
		  /* 820A7D04h */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 820A7D04h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820A7D04h case    5:*/		return 0x820A7D08;
		  /* 820A7D08h */ case    6:  		/* li R30, 0 */
		/* 820A7D08h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A7D08h case    6:*/		return 0x820A7D0C;
		  /* 820A7D0Ch */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820A7D0Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7D0Ch case    7:*/		return 0x820A7D10;
		  /* 820A7D10h */ case    8:  		/* bc 4, CR6_LT, 576 */
		/* 820A7D10h case    8:*/		if ( !regs.CR[6].lt ) { return 0x820A7F50;  }
		/* 820A7D10h case    8:*/		return 0x820A7D14;
		  /* 820A7D14h */ case    9:  		/* lis R11, -32255 */
		/* 820A7D14h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A7D14h case    9:*/		return 0x820A7D18;
		  /* 820A7D18h */ case   10:  		/* addi R29, R11, -8940 */
		/* 820A7D18h case   10:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFDD14);
		/* 820A7D18h case   10:*/		return 0x820A7D1C;
		  /* 820A7D1Ch */ case   11:  		/* lwz R11, <#[R31]> */
		/* 820A7D1Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7D1Ch case   11:*/		return 0x820A7D20;
		  /* 820A7D20h */ case   12:  		/* lbz R10, <#[R11]> */
		/* 820A7D20h case   12:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7D20h case   12:*/		return 0x820A7D24;
		  /* 820A7D24h */ case   13:  		/* extsb R10, R10 */
		/* 820A7D24h case   13:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820A7D24h case   13:*/		return 0x820A7D28;
		  /* 820A7D28h */ case   14:  		/* cmpwi CR6, R10, 10 */
		/* 820A7D28h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000A);
		/* 820A7D28h case   14:*/		return 0x820A7D2C;
		  /* 820A7D2Ch */ case   15:  		/* bc 4, CR6_EQ, 36 */
		/* 820A7D2Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x820A7D50;  }
		/* 820A7D2Ch case   15:*/		return 0x820A7D30;
		  /* 820A7D30h */ case   16:  		/* addi R11, R11, 1 */
		/* 820A7D30h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A7D30h case   16:*/		return 0x820A7D34;
		  /* 820A7D34h */ case   17:  		/* li R30, 1 */
		/* 820A7D34h case   17:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820A7D34h case   17:*/		return 0x820A7D38;
		  /* 820A7D38h */ case   18:  		/* stw R11, <#[R31]> */
		/* 820A7D38h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7D38h case   18:*/		return 0x820A7D3C;
		  /* 820A7D3Ch */ case   19:  		/* stw R11, <#[R31 + 4]> */
		/* 820A7D3Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820A7D3Ch case   19:*/		return 0x820A7D40;
		  /* 820A7D40h */ case   20:  		/* lwz R11, <#[R31 + 40]> */
		/* 820A7D40h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820A7D40h case   20:*/		return 0x820A7D44;
		  /* 820A7D44h */ case   21:  		/* addi R11, R11, 1 */
		/* 820A7D44h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A7D44h case   21:*/		return 0x820A7D48;
		  /* 820A7D48h */ case   22:  		/* stw R11, <#[R31 + 40]> */
		/* 820A7D48h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820A7D48h case   22:*/		return 0x820A7D4C;
		  /* 820A7D4Ch */ case   23:  		/* b 500 */
		/* 820A7D4Ch case   23:*/		return 0x820A7F40;
		/* 820A7D4Ch case   23:*/		return 0x820A7D50;
	}
	return 0x820A7D50;
} // Block from 820A7CF0h-820A7D50h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820A7D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7D50);
		  /* 820A7D50h */ case    0:  		/* cmpwi CR6, R10, 32 */
		/* 820A7D50h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000020);
		/* 820A7D50h case    0:*/		return 0x820A7D54;
		  /* 820A7D54h */ case    1:  		/* bc 12, CR6_EQ, 484 */
		/* 820A7D54h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A7F38;  }
		/* 820A7D54h case    1:*/		return 0x820A7D58;
		  /* 820A7D58h */ case    2:  		/* cmpwi CR6, R10, 9 */
		/* 820A7D58h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000009);
		/* 820A7D58h case    2:*/		return 0x820A7D5C;
		  /* 820A7D5Ch */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 820A7D5Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820A7D68;  }
		/* 820A7D5Ch case    3:*/		return 0x820A7D60;
		  /* 820A7D60h */ case    4:  		/* cmpwi CR6, R10, 13 */
		/* 820A7D60h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000D);
		/* 820A7D60h case    4:*/		return 0x820A7D64;
		  /* 820A7D64h */ case    5:  		/* bc 4, CR6_GT, 468 */
		/* 820A7D64h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820A7F38;  }
		/* 820A7D64h case    5:*/		return 0x820A7D68;
	}
	return 0x820A7D68;
} // Block from 820A7D50h-820A7D68h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A7D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7D68);
		  /* 820A7D68h */ case    0:  		/* cmpwi CR6, R10, 47 */
		/* 820A7D68h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000002F);
		/* 820A7D68h case    0:*/		return 0x820A7D6C;
		  /* 820A7D6Ch */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 820A7D6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A7D98;  }
		/* 820A7D6Ch case    1:*/		return 0x820A7D70;
		  /* 820A7D70h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A7D70h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7D70h case    2:*/		return 0x820A7D74;
		  /* 820A7D74h */ case    3:  		/* addi R11, R11, 1 */
		/* 820A7D74h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A7D74h case    3:*/		return 0x820A7D78;
		  /* 820A7D78h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820A7D78h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7D78h case    4:*/		return 0x820A7D7C;
		  /* 820A7D7Ch */ case    5:  		/* bc 4, CR6_LT, 28 */
		/* 820A7D7Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x820A7D98;  }
		/* 820A7D7Ch case    5:*/		return 0x820A7D80;
	}
	return 0x820A7D80;
} // Block from 820A7D68h-820A7D80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A7D80h
// Function '?Warning@CTErrors@D3DXShader@@QAAJPBUD3DXTOKEN@2@IPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7D80);
		  /* 820A7D80h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A7D80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7D80h case    0:*/		return 0x820A7D84;
		  /* 820A7D84h */ case    1:  		/* lbz R11, <#[R11 + 1]> */
		/* 820A7D84h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000001) );
		/* 820A7D84h case    1:*/		return 0x820A7D88;
		  /* 820A7D88h */ case    2:  		/* cmplwi CR6, R11, 47 */
		/* 820A7D88h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002F);
		/* 820A7D88h case    2:*/		return 0x820A7D8C;
		  /* 820A7D8Ch */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 820A7D8Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A7D98;  }
		/* 820A7D8Ch case    3:*/		return 0x820A7D90;
		  /* 820A7D90h */ case    4:  		/* li R4, 1 */
		/* 820A7D90h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820A7D90h case    4:*/		return 0x820A7D94;
		  /* 820A7D94h */ case    5:  		/* b 256 */
		/* 820A7D94h case    5:*/		return 0x820A7E94;
		/* 820A7D94h case    5:*/		return 0x820A7D98;
	}
	return 0x820A7D98;
} // Block from 820A7D80h-820A7D98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A7D98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7D98);
		  /* 820A7D98h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A7D98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7D98h case    0:*/		return 0x820A7D9C;
		  /* 820A7D9Ch */ case    1:  		/* lbz R10, <#[R11]> */
		/* 820A7D9Ch case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7D9Ch case    1:*/		return 0x820A7DA0;
		  /* 820A7DA0h */ case    2:  		/* cmplwi CR6, R10, 47 */
		/* 820A7DA0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000002F);
		/* 820A7DA0h case    2:*/		return 0x820A7DA4;
		  /* 820A7DA4h */ case    3:  		/* bc 4, CR6_EQ, 208 */
		/* 820A7DA4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A7E74;  }
		/* 820A7DA4h case    3:*/		return 0x820A7DA8;
		  /* 820A7DA8h */ case    4:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A7DA8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7DA8h case    4:*/		return 0x820A7DAC;
		  /* 820A7DACh */ case    5:  		/* addi R11, R11, 1 */
		/* 820A7DACh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A7DACh case    5:*/		return 0x820A7DB0;
		  /* 820A7DB0h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820A7DB0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7DB0h case    6:*/		return 0x820A7DB4;
		  /* 820A7DB4h */ case    7:  		/* bc 4, CR6_LT, 192 */
		/* 820A7DB4h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820A7E74;  }
		/* 820A7DB4h case    7:*/		return 0x820A7DB8;
		  /* 820A7DB8h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 820A7DB8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7DB8h case    8:*/		return 0x820A7DBC;
		  /* 820A7DBCh */ case    9:  		/* lbz R11, <#[R11 + 1]> */
		/* 820A7DBCh case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000001) );
		/* 820A7DBCh case    9:*/		return 0x820A7DC0;
		  /* 820A7DC0h */ case   10:  		/* cmplwi CR6, R11, 42 */
		/* 820A7DC0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002A);
		/* 820A7DC0h case   10:*/		return 0x820A7DC4;
		  /* 820A7DC4h */ case   11:  		/* bc 4, CR6_EQ, 176 */
		/* 820A7DC4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820A7E74;  }
		/* 820A7DC4h case   11:*/		return 0x820A7DC8;
	}
	return 0x820A7DC8;
} // Block from 820A7D98h-820A7DC8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A7DC8h
// Function '?SyntaxError@CTErrors@D3DXShader@@QAAJIPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7DC8);
		  /* 820A7DC8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A7DC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7DC8h case    0:*/		return 0x820A7DCC;
		  /* 820A7DCCh */ case    1:  		/* addi R11, R11, 2 */
		/* 820A7DCCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A7DCCh case    1:*/		return 0x820A7DD0;
		  /* 820A7DD0h */ case    2:  		/* stw R11, <#[R31]> */
		/* 820A7DD0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7DD0h case    2:*/		return 0x820A7DD4;
		  /* 820A7DD4h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820A7DD4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7DD4h case    3:*/		return 0x820A7DD8;
		  /* 820A7DD8h */ case    4:  		/* bc 4, CR6_LT, 112 */
		/* 820A7DD8h case    4:*/		if ( !regs.CR[6].lt ) { return 0x820A7E48;  }
		/* 820A7DD8h case    4:*/		return 0x820A7DDC;
		  /* 820A7DDCh */ case    5:  		/* lwz R11, <#[R31]> */
		/* 820A7DDCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7DDCh case    5:*/		return 0x820A7DE0;
		  /* 820A7DE0h */ case    6:  		/* lbz R9, <#[R11]> */
		/* 820A7DE0h case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7DE0h case    6:*/		return 0x820A7DE4;
		  /* 820A7DE4h */ case    7:  		/* cmplwi CR6, R9, 42 */
		/* 820A7DE4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000002A);
		/* 820A7DE4h case    7:*/		return 0x820A7DE8;
		  /* 820A7DE8h */ case    8:  		/* bc 4, CR6_EQ, 32 */
		/* 820A7DE8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820A7E08;  }
		/* 820A7DE8h case    8:*/		return 0x820A7DEC;
		  /* 820A7DECh */ case    9:  		/* addi R11, R11, 1 */
		/* 820A7DECh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A7DECh case    9:*/		return 0x820A7DF0;
		  /* 820A7DF0h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820A7DF0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7DF0h case   10:*/		return 0x820A7DF4;
		  /* 820A7DF4h */ case   11:  		/* bc 4, CR6_LT, 20 */
		/* 820A7DF4h case   11:*/		if ( !regs.CR[6].lt ) { return 0x820A7E08;  }
		/* 820A7DF4h case   11:*/		return 0x820A7DF8;
		  /* 820A7DF8h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 820A7DF8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7DF8h case   12:*/		return 0x820A7DFC;
		  /* 820A7DFCh */ case   13:  		/* lbz R11, <#[R11 + 1]> */
		/* 820A7DFCh case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000001) );
		/* 820A7DFCh case   13:*/		return 0x820A7E00;
		  /* 820A7E00h */ case   14:  		/* cmplwi CR6, R11, 47 */
		/* 820A7E00h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002F);
		/* 820A7E00h case   14:*/		return 0x820A7E04;
		  /* 820A7E04h */ case   15:  		/* bc 12, CR6_EQ, 68 */
		/* 820A7E04h case   15:*/		if ( regs.CR[6].eq ) { return 0x820A7E48;  }
		/* 820A7E04h case   15:*/		return 0x820A7E08;
	}
	return 0x820A7E08;
} // Block from 820A7DC8h-820A7E08h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A7E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7E08);
		  /* 820A7E08h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A7E08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7E08h case    0:*/		return 0x820A7E0C;
		  /* 820A7E0Ch */ case    1:  		/* lbz R9, <#[R11]> */
		/* 820A7E0Ch case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7E0Ch case    1:*/		return 0x820A7E10;
		  /* 820A7E10h */ case    2:  		/* cmplwi CR6, R9, 10 */
		/* 820A7E10h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000A);
		/* 820A7E10h case    2:*/		return 0x820A7E14;
		  /* 820A7E14h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 820A7E14h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A7E2C;  }
		/* 820A7E14h case    3:*/		return 0x820A7E18;
		  /* 820A7E18h */ case    4:  		/* addi R9, R11, 1 */
		/* 820A7E18h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 820A7E18h case    4:*/		return 0x820A7E1C;
		  /* 820A7E1Ch */ case    5:  		/* lwz R11, <#[R31 + 40]> */
		/* 820A7E1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820A7E1Ch case    5:*/		return 0x820A7E20;
		  /* 820A7E20h */ case    6:  		/* addi R11, R11, 1 */
		/* 820A7E20h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A7E20h case    6:*/		return 0x820A7E24;
		  /* 820A7E24h */ case    7:  		/* stw R9, <#[R31 + 4]> */
		/* 820A7E24h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 820A7E24h case    7:*/		return 0x820A7E28;
		  /* 820A7E28h */ case    8:  		/* stw R11, <#[R31 + 40]> */
		/* 820A7E28h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820A7E28h case    8:*/		return 0x820A7E2C;
	}
	return 0x820A7E2C;
} // Block from 820A7E08h-820A7E2Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A7E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7E2C);
		  /* 820A7E2Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A7E2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7E2Ch case    0:*/		return 0x820A7E30;
		  /* 820A7E30h */ case    1:  		/* addi R11, R11, 1 */
		/* 820A7E30h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A7E30h case    1:*/		return 0x820A7E34;
		  /* 820A7E34h */ case    2:  		/* stw R11, <#[R31]> */
		/* 820A7E34h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7E34h case    2:*/		return 0x820A7E38;
		  /* 820A7E38h */ case    3:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820A7E38h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820A7E38h case    3:*/		return 0x820A7E3C;
		  /* 820A7E3Ch */ case    4:  		/* lwz R9, <#[R31 + 8]> */
		/* 820A7E3Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7E3Ch case    4:*/		return 0x820A7E40;
		  /* 820A7E40h */ case    5:  		/* cmplw CR6, R11, R9 */
		/* 820A7E40h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820A7E40h case    5:*/		return 0x820A7E44;
		  /* 820A7E44h */ case    6:  		/* bc 12, CR6_LT, -104 */
		/* 820A7E44h case    6:*/		if ( regs.CR[6].lt ) { return 0x820A7DDC;  }
		/* 820A7E44h case    6:*/		return 0x820A7E48;
	}
	return 0x820A7E48;
} // Block from 820A7E2Ch-820A7E48h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A7E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7E48);
		  /* 820A7E48h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A7E48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7E48h case    0:*/		return 0x820A7E4C;
		  /* 820A7E4Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820A7E4Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7E4Ch case    1:*/		return 0x820A7E50;
		  /* 820A7E50h */ case    2:  		/* bc 4, CR6_LT, 12 */
		/* 820A7E50h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820A7E5C;  }
		/* 820A7E50h case    2:*/		return 0x820A7E54;
		  /* 820A7E54h */ case    3:  		/* addi R11, R11, 2 */
		/* 820A7E54h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A7E54h case    3:*/		return 0x820A7E58;
		  /* 820A7E58h */ case    4:  		/* b 228 */
		/* 820A7E58h case    4:*/		return 0x820A7F3C;
		/* 820A7E58h case    4:*/		return 0x820A7E5C;
	}
	return 0x820A7E5C;
} // Block from 820A7E48h-820A7E5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A7E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7E5C);
		  /* 820A7E5Ch */ case    0:  		/* mr R6, R29 */
		/* 820A7E5Ch case    0:*/		regs.R6 = regs.R29;
		/* 820A7E5Ch case    0:*/		return 0x820A7E60;
		  /* 820A7E60h */ case    1:  		/* lwz R3, <#[R31 + 64]> */
		/* 820A7E60h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000040) );
		/* 820A7E60h case    1:*/		return 0x820A7E64;
		  /* 820A7E64h */ case    2:  		/* li R5, 1001 */
		/* 820A7E64h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x3E9);
		/* 820A7E64h case    2:*/		return 0x820A7E68;
		  /* 820A7E68h */ case    3:  		/* addi R4, R31, 16 */
		/* 820A7E68h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 820A7E68h case    3:*/		return 0x820A7E6C;
		  /* 820A7E6Ch */ case    4:  		/* bl -3292 */
		/* 820A7E6Ch case    4:*/		regs.LR = 0x820A7E70; return 0x820A7190;
		/* 820A7E6Ch case    4:*/		return 0x820A7E70;
		  /* 820A7E70h */ case    5:  		/* b 208 */
		/* 820A7E70h case    5:*/		return 0x820A7F40;
		/* 820A7E70h case    5:*/		return 0x820A7E74;
	}
	return 0x820A7E74;
} // Block from 820A7E5Ch-820A7E74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A7E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7E74);
		  /* 820A7E74h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 820A7E74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820A7E74h case    0:*/		return 0x820A7E78;
		  /* 820A7E78h */ case    1:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820A7E78h case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820A7E78h case    1:*/		return 0x820A7E7C;
		  /* 820A7E7Ch */ case    2:  		/* bc 12, CR0_EQ, 36 */
		/* 820A7E7Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820A7EA0;  }
		/* 820A7E7Ch case    2:*/		return 0x820A7E80;
		  /* 820A7E80h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820A7E80h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7E80h case    3:*/		return 0x820A7E84;
		  /* 820A7E84h */ case    4:  		/* lbz R11, <#[R11]> */
		/* 820A7E84h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7E84h case    4:*/		return 0x820A7E88;
		  /* 820A7E88h */ case    5:  		/* cmplwi CR6, R11, 59 */
		/* 820A7E88h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003B);
		/* 820A7E88h case    5:*/		return 0x820A7E8C;
		  /* 820A7E8Ch */ case    6:  		/* bc 4, CR6_EQ, 20 */
		/* 820A7E8Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A7EA0;  }
		/* 820A7E8Ch case    6:*/		return 0x820A7E90;
		  /* 820A7E90h */ case    7:  		/* li R4, 0 */
		/* 820A7E90h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A7E90h case    7:*/		return 0x820A7E94;
	}
	return 0x820A7E94;
} // Block from 820A7E74h-820A7E94h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A7E94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7E94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7E94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7E94);
		  /* 820A7E94h */ case    0:  		/* mr R3, R31 */
		/* 820A7E94h case    0:*/		regs.R3 = regs.R31;
		/* 820A7E94h case    0:*/		return 0x820A7E98;
		  /* 820A7E98h */ case    1:  		/* bl -2360 */
		/* 820A7E98h case    1:*/		regs.LR = 0x820A7E9C; return 0x820A7560;
		/* 820A7E98h case    1:*/		return 0x820A7E9C;
		  /* 820A7E9Ch */ case    2:  		/* b 164 */
		/* 820A7E9Ch case    2:*/		return 0x820A7F40;
		/* 820A7E9Ch case    2:*/		return 0x820A7EA0;
	}
	return 0x820A7EA0;
} // Block from 820A7E94h-820A7EA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7EA0);
		  /* 820A7EA0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A7EA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7EA0h case    0:*/		return 0x820A7EA4;
		  /* 820A7EA4h */ case    1:  		/* lbz R10, <#[R11]> */
		/* 820A7EA4h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7EA4h case    1:*/		return 0x820A7EA8;
		  /* 820A7EA8h */ case    2:  		/* cmplwi CR6, R10, 92 */
		/* 820A7EA8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005C);
		/* 820A7EA8h case    2:*/		return 0x820A7EAC;
		  /* 820A7EACh */ case    3:  		/* bc 4, CR6_EQ, 64 */
		/* 820A7EACh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A7EEC;  }
		/* 820A7EACh case    3:*/		return 0x820A7EB0;
		  /* 820A7EB0h */ case    4:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A7EB0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7EB0h case    4:*/		return 0x820A7EB4;
		  /* 820A7EB4h */ case    5:  		/* addi R11, R11, 1 */
		/* 820A7EB4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A7EB4h case    5:*/		return 0x820A7EB8;
		  /* 820A7EB8h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820A7EB8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7EB8h case    6:*/		return 0x820A7EBC;
		  /* 820A7EBCh */ case    7:  		/* bc 4, CR6_LT, 48 */
		/* 820A7EBCh case    7:*/		if ( !regs.CR[6].lt ) { return 0x820A7EEC;  }
		/* 820A7EBCh case    7:*/		return 0x820A7EC0;
		  /* 820A7EC0h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 820A7EC0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7EC0h case    8:*/		return 0x820A7EC4;
		  /* 820A7EC4h */ case    9:  		/* lbz R11, <#[R11 + 1]> */
		/* 820A7EC4h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000001) );
		/* 820A7EC4h case    9:*/		return 0x820A7EC8;
		  /* 820A7EC8h */ case   10:  		/* cmplwi CR6, R11, 10 */
		/* 820A7EC8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 820A7EC8h case   10:*/		return 0x820A7ECC;
		  /* 820A7ECCh */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 820A7ECCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x820A7EEC;  }
		/* 820A7ECCh case   11:*/		return 0x820A7ED0;
		  /* 820A7ED0h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 820A7ED0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7ED0h case   12:*/		return 0x820A7ED4;
		  /* 820A7ED4h */ case   13:  		/* addi R11, R11, 2 */
		/* 820A7ED4h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A7ED4h case   13:*/		return 0x820A7ED8;
		  /* 820A7ED8h */ case   14:  		/* lwz R10, <#[R31 + 40]> */
		/* 820A7ED8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 820A7ED8h case   14:*/		return 0x820A7EDC;
		  /* 820A7EDCh */ case   15:  		/* stw R11, <#[R31 + 4]> */
		/* 820A7EDCh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820A7EDCh case   15:*/		return 0x820A7EE0;
		  /* 820A7EE0h */ case   16:  		/* addi R10, R10, 1 */
		/* 820A7EE0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A7EE0h case   16:*/		return 0x820A7EE4;
		  /* 820A7EE4h */ case   17:  		/* stw R10, <#[R31 + 40]> */
		/* 820A7EE4h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 820A7EE4h case   17:*/		return 0x820A7EE8;
		  /* 820A7EE8h */ case   18:  		/* b 84 */
		/* 820A7EE8h case   18:*/		return 0x820A7F3C;
		/* 820A7EE8h case   18:*/		return 0x820A7EEC;
	}
	return 0x820A7EEC;
} // Block from 820A7EA0h-820A7EECh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A7EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7EEC);
		  /* 820A7EECh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A7EECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7EECh case    0:*/		return 0x820A7EF0;
		  /* 820A7EF0h */ case    1:  		/* lbz R10, <#[R11]> */
		/* 820A7EF0h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7EF0h case    1:*/		return 0x820A7EF4;
		  /* 820A7EF4h */ case    2:  		/* cmplwi CR6, R10, 92 */
		/* 820A7EF4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005C);
		/* 820A7EF4h case    2:*/		return 0x820A7EF8;
		  /* 820A7EF8h */ case    3:  		/* bc 4, CR6_EQ, 88 */
		/* 820A7EF8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A7F50;  }
		/* 820A7EF8h case    3:*/		return 0x820A7EFC;
		  /* 820A7EFCh */ case    4:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A7EFCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7EFCh case    4:*/		return 0x820A7F00;
		  /* 820A7F00h */ case    5:  		/* addi R11, R11, 2 */
		/* 820A7F00h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A7F00h case    5:*/		return 0x820A7F04;
		  /* 820A7F04h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820A7F04h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7F04h case    6:*/		return 0x820A7F08;
		  /* 820A7F08h */ case    7:  		/* bc 4, CR6_LT, 72 */
		/* 820A7F08h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820A7F50;  }
		/* 820A7F08h case    7:*/		return 0x820A7F0C;
		  /* 820A7F0Ch */ case    8:  		/* lwz R11, <#[R31]> */
		/* 820A7F0Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7F0Ch case    8:*/		return 0x820A7F10;
		  /* 820A7F10h */ case    9:  		/* lbz R11, <#[R11 + 1]> */
		/* 820A7F10h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000001) );
		/* 820A7F10h case    9:*/		return 0x820A7F14;
		  /* 820A7F14h */ case   10:  		/* cmplwi CR6, R11, 13 */
		/* 820A7F14h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000D);
		/* 820A7F14h case   10:*/		return 0x820A7F18;
		  /* 820A7F18h */ case   11:  		/* bc 4, CR6_EQ, 56 */
		/* 820A7F18h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820A7F50;  }
		/* 820A7F18h case   11:*/		return 0x820A7F1C;
		  /* 820A7F1Ch */ case   12:  		/* lwz R11, <#[R31]> */
		/* 820A7F1Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7F1Ch case   12:*/		return 0x820A7F20;
		  /* 820A7F20h */ case   13:  		/* lbz R11, <#[R11 + 2]> */
		/* 820A7F20h case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000002) );
		/* 820A7F20h case   13:*/		return 0x820A7F24;
		  /* 820A7F24h */ case   14:  		/* cmplwi CR6, R11, 10 */
		/* 820A7F24h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 820A7F24h case   14:*/		return 0x820A7F28;
		  /* 820A7F28h */ case   15:  		/* bc 4, CR6_EQ, 40 */
		/* 820A7F28h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820A7F50;  }
		/* 820A7F28h case   15:*/		return 0x820A7F2C;
		  /* 820A7F2Ch */ case   16:  		/* lwz R11, <#[R31]> */
		/* 820A7F2Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7F2Ch case   16:*/		return 0x820A7F30;
		  /* 820A7F30h */ case   17:  		/* addi R11, R11, 3 */
		/* 820A7F30h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820A7F30h case   17:*/		return 0x820A7F34;
		  /* 820A7F34h */ case   18:  		/* b -92 */
		/* 820A7F34h case   18:*/		return 0x820A7ED8;
		/* 820A7F34h case   18:*/		return 0x820A7F38;
	}
	return 0x820A7F38;
} // Block from 820A7EECh-820A7F38h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A7F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7F38);
		  /* 820A7F38h */ case    0:  		/* addi R11, R11, 1 */
		/* 820A7F38h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A7F38h case    0:*/		return 0x820A7F3C;
	}
	return 0x820A7F3C;
} // Block from 820A7F38h-820A7F3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7F3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7F3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7F3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7F3C);
		  /* 820A7F3Ch */ case    0:  		/* stw R11, <#[R31]> */
		/* 820A7F3Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7F3Ch case    0:*/		return 0x820A7F40;
	}
	return 0x820A7F40;
} // Block from 820A7F3Ch-820A7F40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7F40);
		  /* 820A7F40h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A7F40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A7F40h case    0:*/		return 0x820A7F44;
		  /* 820A7F44h */ case    1:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A7F44h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A7F44h case    1:*/		return 0x820A7F48;
		  /* 820A7F48h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820A7F48h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7F48h case    2:*/		return 0x820A7F4C;
		  /* 820A7F4Ch */ case    3:  		/* bc 12, CR6_LT, -560 */
		/* 820A7F4Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820A7D1C;  }
		/* 820A7F4Ch case    3:*/		return 0x820A7F50;
	}
	return 0x820A7F50;
} // Block from 820A7F40h-820A7F50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A7F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7F50);
		  /* 820A7F50h */ case    0:  		/* mr R3, R30 */
		/* 820A7F50h case    0:*/		regs.R3 = regs.R30;
		/* 820A7F50h case    0:*/		return 0x820A7F54;
		  /* 820A7F54h */ case    1:  		/* addi R1, R1, 144 */
		/* 820A7F54h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820A7F54h case    1:*/		return 0x820A7F58;
		  /* 820A7F58h */ case    2:  		/* b -93356 */
		/* 820A7F58h case    2:*/		return 0x820912AC;
		/* 820A7F58h case    2:*/		return 0x820A7F5C;
		  /* 820A7F5Ch */ case    3:  		/* nop */
		/* 820A7F5Ch case    3:*/		cpu::op::nop();
		/* 820A7F5Ch case    3:*/		return 0x820A7F60;
	}
	return 0x820A7F60;
} // Block from 820A7F50h-820A7F60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A7F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7F60);
		  /* 820A7F60h */ case    0:  		/* mfspr R12, LR */
		/* 820A7F60h case    0:*/		regs.R12 = regs.LR;
		/* 820A7F60h case    0:*/		return 0x820A7F64;
		  /* 820A7F64h */ case    1:  		/* bl -93448 */
		/* 820A7F64h case    1:*/		regs.LR = 0x820A7F68; return 0x8209125C;
		/* 820A7F64h case    1:*/		return 0x820A7F68;
		  /* 820A7F68h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A7F68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A7F68h case    2:*/		return 0x820A7F6C;
		  /* 820A7F6Ch */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820A7F6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A7F6Ch case    3:*/		return 0x820A7F70;
		  /* 820A7F70h */ case    4:  		/* mr R30, R3 */
		/* 820A7F70h case    4:*/		regs.R30 = regs.R3;
		/* 820A7F70h case    4:*/		return 0x820A7F74;
		  /* 820A7F74h */ case    5:  		/* mr R29, R4 */
		/* 820A7F74h case    5:*/		regs.R29 = regs.R4;
		/* 820A7F74h case    5:*/		return 0x820A7F78;
		  /* 820A7F78h */ case    6:  		/* cmplw CR6, R4, R11 */
		/* 820A7F78h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820A7F78h case    6:*/		return 0x820A7F7C;
		  /* 820A7F7Ch */ case    7:  		/* bc 4, CR6_LT, 76 */
		/* 820A7F7Ch case    7:*/		if ( !regs.CR[6].lt ) { return 0x820A7FC8;  }
		/* 820A7F7Ch case    7:*/		return 0x820A7F80;
		  /* 820A7F80h */ case    8:  		/* lbz R11, <#[R4]> */
		/* 820A7F80h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820A7F80h case    8:*/		return 0x820A7F84;
		  /* 820A7F84h */ case    9:  		/* cmplwi CR6, R11, 39 */
		/* 820A7F84h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000027);
		/* 820A7F84h case    9:*/		return 0x820A7F88;
	}
	return 0x820A7F88;
} // Block from 820A7F60h-820A7F88h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A7F88h
// Function '?SkipToEOL@CTokenize@D3DXShader@@QAAHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7F88);
		  /* 820A7F88h */ case    0:  		/* bc 4, CR6_EQ, 64 */
		/* 820A7F88h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820A7FC8;  }
		/* 820A7F88h case    0:*/		return 0x820A7F8C;
		  /* 820A7F8Ch */ case    1:  		/* addi R31, R4, 1 */
		/* 820A7F8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R4,0x1);
		/* 820A7F8Ch case    1:*/		return 0x820A7F90;
		  /* 820A7F90h */ case    2:  		/* mr R4, R31 */
		/* 820A7F90h case    2:*/		regs.R4 = regs.R31;
		/* 820A7F90h case    2:*/		return 0x820A7F94;
		  /* 820A7F94h */ case    3:  		/* bl -1548 */
		/* 820A7F94h case    3:*/		regs.LR = 0x820A7F98; return 0x820A7988;
		/* 820A7F94h case    3:*/		return 0x820A7F98;
		  /* 820A7F98h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820A7F98h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A7F98h case    4:*/		return 0x820A7F9C;
		  /* 820A7F9Ch */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 820A7F9Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820A7FC8;  }
		/* 820A7F9Ch case    5:*/		return 0x820A7FA0;
		  /* 820A7FA0h */ case    6:  		/* lwz R10, <#[R30 + 8]> */
		/* 820A7FA0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 820A7FA0h case    6:*/		return 0x820A7FA4;
		  /* 820A7FA4h */ case    7:  		/* add R11, R3, R31 */
		/* 820A7FA4h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R31);
		/* 820A7FA4h case    7:*/		return 0x820A7FA8;
		  /* 820A7FA8h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820A7FA8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A7FA8h case    8:*/		return 0x820A7FAC;
		  /* 820A7FACh */ case    9:  		/* bc 4, CR6_LT, 28 */
		/* 820A7FACh case    9:*/		if ( !regs.CR[6].lt ) { return 0x820A7FC8;  }
		/* 820A7FACh case    9:*/		return 0x820A7FB0;
		  /* 820A7FB0h */ case   10:  		/* lbz R10, <#[R11]> */
		/* 820A7FB0h case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A7FB0h case   10:*/		return 0x820A7FB4;
		  /* 820A7FB4h */ case   11:  		/* cmplwi CR6, R10, 39 */
		/* 820A7FB4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000027);
		/* 820A7FB4h case   11:*/		return 0x820A7FB8;
		  /* 820A7FB8h */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 820A7FB8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A7FC8;  }
		/* 820A7FB8h case   12:*/		return 0x820A7FBC;
		  /* 820A7FBCh */ case   13:  		/* subf R11, R29, R11 */
		/* 820A7FBCh case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 820A7FBCh case   13:*/		return 0x820A7FC0;
		  /* 820A7FC0h */ case   14:  		/* addi R3, R11, 1 */
		/* 820A7FC0h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 820A7FC0h case   14:*/		return 0x820A7FC4;
		  /* 820A7FC4h */ case   15:  		/* b 8 */
		/* 820A7FC4h case   15:*/		return 0x820A7FCC;
		/* 820A7FC4h case   15:*/		return 0x820A7FC8;
	}
	return 0x820A7FC8;
} // Block from 820A7F88h-820A7FC8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A7FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7FC8);
		  /* 820A7FC8h */ case    0:  		/* li R3, 0 */
		/* 820A7FC8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A7FC8h case    0:*/		return 0x820A7FCC;
	}
	return 0x820A7FCC;
} // Block from 820A7FC8h-820A7FCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A7FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7FCC);
		  /* 820A7FCCh */ case    0:  		/* addi R1, R1, 112 */
		/* 820A7FCCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A7FCCh case    0:*/		return 0x820A7FD0;
		  /* 820A7FD0h */ case    1:  		/* b -93476 */
		/* 820A7FD0h case    1:*/		return 0x820912AC;
		/* 820A7FD0h case    1:*/		return 0x820A7FD4;
		  /* 820A7FD4h */ case    2:  		/* nop */
		/* 820A7FD4h case    2:*/		cpu::op::nop();
		/* 820A7FD4h case    2:*/		return 0x820A7FD8;
	}
	return 0x820A7FD8;
} // Block from 820A7FCCh-820A7FD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A7FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A7FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A7FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A7FD8);
		  /* 820A7FD8h */ case    0:  		/* mfspr R12, LR */
		/* 820A7FD8h case    0:*/		regs.R12 = regs.LR;
		/* 820A7FD8h case    0:*/		return 0x820A7FDC;
		  /* 820A7FDCh */ case    1:  		/* bl -93580 */
		/* 820A7FDCh case    1:*/		regs.LR = 0x820A7FE0; return 0x82091250;
		/* 820A7FDCh case    1:*/		return 0x820A7FE0;
		  /* 820A7FE0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820A7FE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820A7FE0h case    2:*/		return 0x820A7FE4;
		  /* 820A7FE4h */ case    3:  		/* lwz R9, <#[R3 + 8]> */
		/* 820A7FE4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 820A7FE4h case    3:*/		return 0x820A7FE8;
		  /* 820A7FE8h */ case    4:  		/* mr R28, R3 */
		/* 820A7FE8h case    4:*/		regs.R28 = regs.R3;
		/* 820A7FE8h case    4:*/		return 0x820A7FEC;
		  /* 820A7FECh */ case    5:  		/* mr R29, R4 */
		/* 820A7FECh case    5:*/		regs.R29 = regs.R4;
		/* 820A7FECh case    5:*/		return 0x820A7FF0;
		  /* 820A7FF0h */ case    6:  		/* mr R26, R5 */
		/* 820A7FF0h case    6:*/		regs.R26 = regs.R5;
		/* 820A7FF0h case    6:*/		return 0x820A7FF4;
		  /* 820A7FF4h */ case    7:  		/* cmplw CR6, R4, R9 */
		/* 820A7FF4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R9);
		/* 820A7FF4h case    7:*/		return 0x820A7FF8;
		  /* 820A7FF8h */ case    8:  		/* bc 4, CR6_LT, 496 */
		/* 820A7FF8h case    8:*/		if ( !regs.CR[6].lt ) { return 0x820A81E8;  }
		/* 820A7FF8h case    8:*/		return 0x820A7FFC;
		  /* 820A7FFCh */ case    9:  		/* lbz R11, <#[R4]> */
		/* 820A7FFCh case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820A7FFCh case    9:*/		return 0x820A8000;
		  /* 820A8000h */ case   10:  		/* extsb R11, R11 */
		/* 820A8000h case   10:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820A8000h case   10:*/		return 0x820A8004;
		  /* 820A8004h */ case   11:  		/* cmpwi CR6, R11, 34 */
		/* 820A8004h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000022);
		/* 820A8004h case   11:*/		return 0x820A8008;
		  /* 820A8008h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 820A8008h case   12:*/		if ( regs.CR[6].eq ) { return 0x820A8024;  }
		/* 820A8008h case   12:*/		return 0x820A800C;
		  /* 820A800Ch */ case   13:  		/* cmpwi CR6, R11, 60 */
		/* 820A800Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000003C);
		/* 820A800Ch case   13:*/		return 0x820A8010;
		  /* 820A8010h */ case   14:  		/* bc 4, CR6_EQ, 472 */
		/* 820A8010h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820A81E8;  }
		/* 820A8010h case   14:*/		return 0x820A8014;
		  /* 820A8014h */ case   15:  		/* lwz R11, <#[R28 + 56]> */
		/* 820A8014h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000038) );
		/* 820A8014h case   15:*/		return 0x820A8018;
		  /* 820A8018h */ case   16:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 820A8018h case   16:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 820A8018h case   16:*/		return 0x820A801C;
		  /* 820A801Ch */ case   17:  		/* bc 12, CR0_EQ, 460 */
		/* 820A801Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x820A81E8;  }
		/* 820A801Ch case   17:*/		return 0x820A8020;
		  /* 820A8020h */ case   18:  		/* li R11, 62 */
		/* 820A8020h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x3E);
		/* 820A8020h case   18:*/		return 0x820A8024;
	}
	return 0x820A8024;
} // Block from 820A7FD8h-820A8024h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A8024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8024);
		  /* 820A8024h */ case    0:  		/* addi R30, R29, 1 */
		/* 820A8024h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0x1);
		/* 820A8024h case    0:*/		return 0x820A8028;
		  /* 820A8028h */ case    1:  		/* mr R31, R30 */
		/* 820A8028h case    1:*/		regs.R31 = regs.R30;
		/* 820A8028h case    1:*/		return 0x820A802C;
		  /* 820A802Ch */ case    2:  		/* cmplw CR6, R30, R9 */
		/* 820A802Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R9);
		/* 820A802Ch case    2:*/		return 0x820A8030;
		  /* 820A8030h */ case    3:  		/* bc 4, CR6_LT, 160 */
		/* 820A8030h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820A80D0;  }
		/* 820A8030h case    3:*/		return 0x820A8034;
		  /* 820A8034h */ case    4:  		/* extsb R8, R11 */
		/* 820A8034h case    4:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R11);
		/* 820A8034h case    4:*/		return 0x820A8038;
		  /* 820A8038h */ case    5:  		/* addi R11, R30, 1 */
		/* 820A8038h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 820A8038h case    5:*/		return 0x820A803C;
		  /* 820A803Ch */ case    6:  		/* lbz R10, <#[R31]> */
		/* 820A803Ch case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820A803Ch case    6:*/		return 0x820A8040;
		  /* 820A8040h */ case    7:  		/* extsb R10, R10 */
		/* 820A8040h case    7:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820A8040h case    7:*/		return 0x820A8044;
		  /* 820A8044h */ case    8:  		/* cmpw CR6, R8, R10 */
		/* 820A8044h case    8:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R10);
		/* 820A8044h case    8:*/		return 0x820A8048;
		  /* 820A8048h */ case    9:  		/* bc 12, CR6_EQ, 136 */
		/* 820A8048h case    9:*/		if ( regs.CR[6].eq ) { return 0x820A80D0;  }
		/* 820A8048h case    9:*/		return 0x820A804C;
		  /* 820A804Ch */ case   10:  		/* cmpwi CR6, R10, 10 */
		/* 820A804Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000A);
		/* 820A804Ch case   10:*/		return 0x820A8050;
		  /* 820A8050h */ case   11:  		/* bc 12, CR6_EQ, 128 */
		/* 820A8050h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A80D0;  }
		/* 820A8050h case   11:*/		return 0x820A8054;
		  /* 820A8054h */ case   12:  		/* cmpwi CR6, R10, 92 */
		/* 820A8054h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000005C);
		/* 820A8054h case   12:*/		return 0x820A8058;
		  /* 820A8058h */ case   13:  		/* bc 4, CR6_EQ, 100 */
		/* 820A8058h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A80BC;  }
		/* 820A8058h case   13:*/		return 0x820A805C;
		  /* 820A805Ch */ case   14:  		/* lwz R10, <#[R28 + 56]> */
		/* 820A805Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000038) );
		/* 820A805Ch case   14:*/		return 0x820A8060;
		  /* 820A8060h */ case   15:  		/* rlwinm. R10, R10, 0, 29, 29 */
		/* 820A8060h case   15:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R10);
		/* 820A8060h case   15:*/		return 0x820A8064;
		  /* 820A8064h */ case   16:  		/* bc 4, CR0_EQ, 88 */
		/* 820A8064h case   16:*/		if ( !regs.CR[0].eq ) { return 0x820A80BC;  }
		/* 820A8064h case   16:*/		return 0x820A8068;
		  /* 820A8068h */ case   17:  		/* addi R31, R31, 1 */
		/* 820A8068h case   17:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A8068h case   17:*/		return 0x820A806C;
		  /* 820A806Ch */ case   18:  		/* addi R11, R11, 1 */
		/* 820A806Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A806Ch case   18:*/		return 0x820A8070;
		  /* 820A8070h */ case   19:  		/* cmplw CR6, R31, R9 */
		/* 820A8070h case   19:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 820A8070h case   19:*/		return 0x820A8074;
		  /* 820A8074h */ case   20:  		/* bc 4, CR6_LT, 72 */
		/* 820A8074h case   20:*/		if ( !regs.CR[6].lt ) { return 0x820A80BC;  }
		/* 820A8074h case   20:*/		return 0x820A8078;
		  /* 820A8078h */ case   21:  		/* lbz R10, <#[R31]> */
		/* 820A8078h case   21:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8078h case   21:*/		return 0x820A807C;
		  /* 820A807Ch */ case   22:  		/* extsb R10, R10 */
		/* 820A807Ch case   22:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820A807Ch case   22:*/		return 0x820A8080;
		  /* 820A8080h */ case   23:  		/* cmpwi CR6, R10, 10 */
		/* 820A8080h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000A);
		/* 820A8080h case   23:*/		return 0x820A8084;
		  /* 820A8084h */ case   24:  		/* bc 12, CR6_EQ, 40 */
		/* 820A8084h case   24:*/		if ( regs.CR[6].eq ) { return 0x820A80AC;  }
		/* 820A8084h case   24:*/		return 0x820A8088;
		  /* 820A8088h */ case   25:  		/* cmpwi CR6, R10, 13 */
		/* 820A8088h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000D);
		/* 820A8088h case   25:*/		return 0x820A808C;
		  /* 820A808Ch */ case   26:  		/* bc 4, CR6_EQ, 48 */
		/* 820A808Ch case   26:*/		if ( !regs.CR[6].eq ) { return 0x820A80BC;  }
		/* 820A808Ch case   26:*/		return 0x820A8090;
		  /* 820A8090h */ case   27:  		/* cmplw CR6, R11, R9 */
		/* 820A8090h case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820A8090h case   27:*/		return 0x820A8094;
		  /* 820A8094h */ case   28:  		/* bc 4, CR6_LT, 40 */
		/* 820A8094h case   28:*/		if ( !regs.CR[6].lt ) { return 0x820A80BC;  }
		/* 820A8094h case   28:*/		return 0x820A8098;
		  /* 820A8098h */ case   29:  		/* lbz R10, <#[R11]> */
		/* 820A8098h case   29:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8098h case   29:*/		return 0x820A809C;
		  /* 820A809Ch */ case   30:  		/* cmplwi CR6, R10, 10 */
		/* 820A809Ch case   30:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000A);
		/* 820A809Ch case   30:*/		return 0x820A80A0;
		  /* 820A80A0h */ case   31:  		/* bc 4, CR6_EQ, 28 */
		/* 820A80A0h case   31:*/		if ( !regs.CR[6].eq ) { return 0x820A80BC;  }
		/* 820A80A0h case   31:*/		return 0x820A80A4;
		  /* 820A80A4h */ case   32:  		/* addi R11, R11, 1 */
		/* 820A80A4h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A80A4h case   32:*/		return 0x820A80A8;
		  /* 820A80A8h */ case   33:  		/* addi R31, R31, 1 */
		/* 820A80A8h case   33:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A80A8h case   33:*/		return 0x820A80AC;
	}
	return 0x820A80AC;
} // Block from 820A8024h-820A80ACh (34 instructions)

//////////////////////////////////////////////////////
// Block at 820A80ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A80AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A80AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A80AC);
		  /* 820A80ACh */ case    0:  		/* lwz R10, <#[R28 + 40]> */
		/* 820A80ACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000028) );
		/* 820A80ACh case    0:*/		return 0x820A80B0;
		  /* 820A80B0h */ case    1:  		/* stw R11, <#[R28 + 4]> */
		/* 820A80B0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 820A80B0h case    1:*/		return 0x820A80B4;
		  /* 820A80B4h */ case    2:  		/* addi R10, R10, 1 */
		/* 820A80B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A80B4h case    2:*/		return 0x820A80B8;
		  /* 820A80B8h */ case    3:  		/* stw R10, <#[R28 + 40]> */
		/* 820A80B8h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000028) );
		/* 820A80B8h case    3:*/		return 0x820A80BC;
	}
	return 0x820A80BC;
} // Block from 820A80ACh-820A80BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A80BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A80BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A80BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A80BC);
		  /* 820A80BCh */ case    0:  		/* lwz R10, <#[R28 + 8]> */
		/* 820A80BCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 820A80BCh case    0:*/		return 0x820A80C0;
		  /* 820A80C0h */ case    1:  		/* addi R31, R31, 1 */
		/* 820A80C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A80C0h case    1:*/		return 0x820A80C4;
		  /* 820A80C4h */ case    2:  		/* addi R11, R11, 1 */
		/* 820A80C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A80C4h case    2:*/		return 0x820A80C8;
		  /* 820A80C8h */ case    3:  		/* cmplw CR6, R31, R10 */
		/* 820A80C8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 820A80C8h case    3:*/		return 0x820A80CC;
		  /* 820A80CCh */ case    4:  		/* bc 12, CR6_LT, -144 */
		/* 820A80CCh case    4:*/		if ( regs.CR[6].lt ) { return 0x820A803C;  }
		/* 820A80CCh case    4:*/		return 0x820A80D0;
	}
	return 0x820A80D0;
} // Block from 820A80BCh-820A80D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A80D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A80D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A80D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A80D0);
		  /* 820A80D0h */ case    0:  		/* cmplw CR6, R31, R9 */
		/* 820A80D0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 820A80D0h case    0:*/		return 0x820A80D4;
		  /* 820A80D4h */ case    1:  		/* bc 12, CR6_LT, 24 */
		/* 820A80D4h case    1:*/		if ( regs.CR[6].lt ) { return 0x820A80EC;  }
		/* 820A80D4h case    1:*/		return 0x820A80D8;
		  /* 820A80D8h */ case    2:  		/* lis R11, -32255 */
		/* 820A80D8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A80D8h case    2:*/		return 0x820A80DC;
		  /* 820A80DCh */ case    3:  		/* li R5, 1006 */
		/* 820A80DCh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x3EE);
		/* 820A80DCh case    3:*/		return 0x820A80E0;
		  /* 820A80E0h */ case    4:  		/* addi R6, R11, -8868 */
		/* 820A80E0h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFDD5C);
		/* 820A80E0h case    4:*/		return 0x820A80E4;
		  /* 820A80E4h */ case    5:  		/* mr R31, R9 */
		/* 820A80E4h case    5:*/		regs.R31 = regs.R9;
		/* 820A80E4h case    5:*/		return 0x820A80E8;
		  /* 820A80E8h */ case    6:  		/* b 28 */
		/* 820A80E8h case    6:*/		return 0x820A8104;
		/* 820A80E8h case    6:*/		return 0x820A80EC;
	}
	return 0x820A80EC;
} // Block from 820A80D0h-820A80ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A80ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A80EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A80EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A80EC);
		  /* 820A80ECh */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820A80ECh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A80ECh case    0:*/		return 0x820A80F0;
	}
	return 0x820A80F0;
} // Block from 820A80ECh-820A80F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A80F0h
// Function '?LexHex@CTokenize@D3DXShader@@IAAIPBDPA_K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A80F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A80F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A80F0);
		  /* 820A80F0h */ case    0:  		/* cmplwi CR6, R11, 10 */
		/* 820A80F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 820A80F0h case    0:*/		return 0x820A80F4;
		  /* 820A80F4h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820A80F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A8110;  }
		/* 820A80F4h case    1:*/		return 0x820A80F8;
		  /* 820A80F8h */ case    2:  		/* lis R11, -32255 */
		/* 820A80F8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A80F8h case    2:*/		return 0x820A80FC;
		  /* 820A80FCh */ case    3:  		/* li R5, 1005 */
		/* 820A80FCh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x3ED);
		/* 820A80FCh case    3:*/		return 0x820A8100;
		  /* 820A8100h */ case    4:  		/* addi R6, R11, -8904 */
		/* 820A8100h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFDD38);
		/* 820A8100h case    4:*/		return 0x820A8104;
	}
	return 0x820A8104;
} // Block from 820A80F0h-820A8104h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A8104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8104);
		  /* 820A8104h */ case    0:  		/* addi R4, R28, 16 */
		/* 820A8104h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R28,0x10);
		/* 820A8104h case    0:*/		return 0x820A8108;
		  /* 820A8108h */ case    1:  		/* lwz R3, <#[R28 + 64]> */
		/* 820A8108h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000040) );
		/* 820A8108h case    1:*/		return 0x820A810C;
		  /* 820A810Ch */ case    2:  		/* bl -3964 */
		/* 820A810Ch case    2:*/		regs.LR = 0x820A8110; return 0x820A7190;
		/* 820A810Ch case    2:*/		return 0x820A8110;
	}
	return 0x820A8110;
} // Block from 820A8104h-820A8110h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A8110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8110);
		  /* 820A8110h */ case    0:  		/* subf R27, R29, R31 */
		/* 820A8110h case    0:*/		cpu::op::subf<0>(regs,&regs.R27,regs.R29,regs.R31);
		/* 820A8110h case    0:*/		return 0x820A8114;
		  /* 820A8114h */ case    1:  		/* lwz R3, <#[R28 + 60]> */
		/* 820A8114h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x0000003C) );
		/* 820A8114h case    1:*/		return 0x820A8118;
		  /* 820A8118h */ case    2:  		/* li R5, 1 */
		/* 820A8118h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820A8118h case    2:*/		return 0x820A811C;
		  /* 820A811Ch */ case    3:  		/* mr R4, R27 */
		/* 820A811Ch case    3:*/		regs.R4 = regs.R27;
		/* 820A811Ch case    3:*/		return 0x820A8120;
		  /* 820A8120h */ case    4:  		/* bl 135104 */
		/* 820A8120h case    4:*/		regs.LR = 0x820A8124; return 0x820C90E0;
		/* 820A8120h case    4:*/		return 0x820A8124;
		  /* 820A8124h */ case    5:  		/* or. R29, R3, R3 */
		/* 820A8124h case    5:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820A8124h case    5:*/		return 0x820A8128;
		  /* 820A8128h */ case    6:  		/* bc 12, CR0_EQ, 192 */
		/* 820A8128h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A81E8;  }
		/* 820A8128h case    6:*/		return 0x820A812C;
		  /* 820A812Ch */ case    7:  		/* stw R29, <#[R26]> */
		/* 820A812Ch case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R26 + 0x00000000) );
		/* 820A812Ch case    7:*/		return 0x820A8130;
		  /* 820A8130h */ case    8:  		/* addi R11, R30, 1 */
		/* 820A8130h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 820A8130h case    8:*/		return 0x820A8134;
		  /* 820A8134h */ case    9:  		/* cmplw CR6, R11, R31 */
		/* 820A8134h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820A8134h case    9:*/		return 0x820A8138;
		  /* 820A8138h */ case   10:  		/* bc 4, CR6_LT, 112 */
		/* 820A8138h case   10:*/		if ( !regs.CR[6].lt ) { return 0x820A81A8;  }
		/* 820A8138h case   10:*/		return 0x820A813C;
		  /* 820A813Ch */ case   11:  		/* addi R10, R30, 2 */
		/* 820A813Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x2);
		/* 820A813Ch case   11:*/		return 0x820A8140;
		  /* 820A8140h */ case   12:  		/* lbz R9, <#[R30]> */
		/* 820A8140h case   12:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 820A8140h case   12:*/		return 0x820A8144;
		  /* 820A8144h */ case   13:  		/* cmplwi CR6, R9, 92 */
		/* 820A8144h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000005C);
		/* 820A8144h case   13:*/		return 0x820A8148;
		  /* 820A8148h */ case   14:  		/* bc 4, CR6_EQ, 96 */
		/* 820A8148h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820A81A8;  }
		/* 820A8148h case   14:*/		return 0x820A814C;
		  /* 820A814Ch */ case   15:  		/* lwz R9, <#[R28 + 56]> */
		/* 820A814Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000038) );
		/* 820A814Ch case   15:*/		return 0x820A8150;
		  /* 820A8150h */ case   16:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 820A8150h case   16:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 820A8150h case   16:*/		return 0x820A8154;
		  /* 820A8154h */ case   17:  		/* bc 4, CR0_EQ, 84 */
		/* 820A8154h case   17:*/		if ( !regs.CR[0].eq ) { return 0x820A81A8;  }
		/* 820A8154h case   17:*/		return 0x820A8158;
		  /* 820A8158h */ case   18:  		/* lbz R9, <#[R11]> */
		/* 820A8158h case   18:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8158h case   18:*/		return 0x820A815C;
		  /* 820A815Ch */ case   19:  		/* extsb R9, R9 */
		/* 820A815Ch case   19:*/		cpu::op::extsb<0>(regs,&regs.R9,regs.R9);
		/* 820A815Ch case   19:*/		return 0x820A8160;
		  /* 820A8160h */ case   20:  		/* cmpwi CR6, R9, 10 */
		/* 820A8160h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000A);
		/* 820A8160h case   20:*/		return 0x820A8164;
		  /* 820A8164h */ case   21:  		/* bc 4, CR6_EQ, 20 */
		/* 820A8164h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820A8178;  }
		/* 820A8164h case   21:*/		return 0x820A8168;
		  /* 820A8168h */ case   22:  		/* addi R30, R30, 2 */
		/* 820A8168h case   22:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x2);
		/* 820A8168h case   22:*/		return 0x820A816C;
		  /* 820A816Ch */ case   23:  		/* addi R10, R10, 2 */
		/* 820A816Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 820A816Ch case   23:*/		return 0x820A8170;
		  /* 820A8170h */ case   24:  		/* addi R11, R11, 2 */
		/* 820A8170h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820A8170h case   24:*/		return 0x820A8174;
		  /* 820A8174h */ case   25:  		/* b 44 */
		/* 820A8174h case   25:*/		return 0x820A81A0;
		/* 820A8174h case   25:*/		return 0x820A8178;
	}
	return 0x820A8178;
} // Block from 820A8110h-820A8178h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820A8178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8178);
		  /* 820A8178h */ case    0:  		/* cmpwi CR6, R9, 13 */
		/* 820A8178h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000D);
		/* 820A8178h case    0:*/		return 0x820A817C;
		  /* 820A817Ch */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 820A817Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A81A8;  }
		/* 820A817Ch case    1:*/		return 0x820A8180;
		  /* 820A8180h */ case    2:  		/* cmplw CR6, R10, R31 */
		/* 820A8180h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 820A8180h case    2:*/		return 0x820A8184;
		  /* 820A8184h */ case    3:  		/* bc 4, CR6_LT, 36 */
		/* 820A8184h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820A81A8;  }
		/* 820A8184h case    3:*/		return 0x820A8188;
		  /* 820A8188h */ case    4:  		/* lbz R9, <#[R10]> */
		/* 820A8188h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8188h case    4:*/		return 0x820A818C;
		  /* 820A818Ch */ case    5:  		/* cmplwi CR6, R9, 10 */
		/* 820A818Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000A);
		/* 820A818Ch case    5:*/		return 0x820A8190;
		  /* 820A8190h */ case    6:  		/* bc 4, CR6_EQ, 24 */
		/* 820A8190h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A81A8;  }
		/* 820A8190h case    6:*/		return 0x820A8194;
		  /* 820A8194h */ case    7:  		/* addi R30, R30, 3 */
		/* 820A8194h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x3);
		/* 820A8194h case    7:*/		return 0x820A8198;
		  /* 820A8198h */ case    8:  		/* addi R10, R10, 3 */
		/* 820A8198h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3);
		/* 820A8198h case    8:*/		return 0x820A819C;
		  /* 820A819Ch */ case    9:  		/* addi R11, R11, 3 */
		/* 820A819Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820A819Ch case    9:*/		return 0x820A81A0;
	}
	return 0x820A81A0;
} // Block from 820A8178h-820A81A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A81A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A81A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A81A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A81A0);
		  /* 820A81A0h */ case    0:  		/* cmplw CR6, R11, R31 */
		/* 820A81A0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820A81A0h case    0:*/		return 0x820A81A4;
		  /* 820A81A4h */ case    1:  		/* bc 12, CR6_LT, -100 */
		/* 820A81A4h case    1:*/		if ( regs.CR[6].lt ) { return 0x820A8140;  }
		/* 820A81A4h case    1:*/		return 0x820A81A8;
	}
	return 0x820A81A8;
} // Block from 820A81A0h-820A81A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A81A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A81A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A81A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A81A8);
		  /* 820A81A8h */ case    0:  		/* cmplw CR6, R30, R31 */
		/* 820A81A8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R31);
		/* 820A81A8h case    0:*/		return 0x820A81AC;
		  /* 820A81ACh */ case    1:  		/* bc 4, CR6_LT, 44 */
		/* 820A81ACh case    1:*/		if ( !regs.CR[6].lt ) { return 0x820A81D8;  }
		/* 820A81ACh case    1:*/		return 0x820A81B0;
		  /* 820A81B0h */ case    2:  		/* addi R5, R1, 112 */
		/* 820A81B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820A81B0h case    2:*/		return 0x820A81B4;
		  /* 820A81B4h */ case    3:  		/* mr R4, R30 */
		/* 820A81B4h case    3:*/		regs.R4 = regs.R30;
		/* 820A81B4h case    3:*/		return 0x820A81B8;
		  /* 820A81B8h */ case    4:  		/* mr R3, R28 */
		/* 820A81B8h case    4:*/		regs.R3 = regs.R28;
		/* 820A81B8h case    4:*/		return 0x820A81BC;
		  /* 820A81BCh */ case    5:  		/* bl -2100 */
		/* 820A81BCh case    5:*/		regs.LR = 0x820A81C0; return 0x820A7988;
		/* 820A81BCh case    5:*/		return 0x820A81C0;
		  /* 820A81C0h */ case    6:  		/* lwz R11, <#[R1 + 112]> */
		/* 820A81C0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820A81C0h case    6:*/		return 0x820A81C4;
		  /* 820A81C4h */ case    7:  		/* add R30, R3, R30 */
		/* 820A81C4h case    7:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R30);
		/* 820A81C4h case    7:*/		return 0x820A81C8;
		  /* 820A81C8h */ case    8:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 820A81C8h case    8:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 820A81C8h case    8:*/		return 0x820A81CC;
		  /* 820A81CCh */ case    9:  		/* stb R11, <#[R29]> */
		/* 820A81CCh case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820A81CCh case    9:*/		return 0x820A81D0;
		  /* 820A81D0h */ case   10:  		/* addi R29, R29, 1 */
		/* 820A81D0h case   10:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820A81D0h case   10:*/		return 0x820A81D4;
		  /* 820A81D4h */ case   11:  		/* b -164 */
		/* 820A81D4h case   11:*/		return 0x820A8130;
		/* 820A81D4h case   11:*/		return 0x820A81D8;
	}
	return 0x820A81D8;
} // Block from 820A81A8h-820A81D8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A81D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A81D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A81D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A81D8);
		  /* 820A81D8h */ case    0:  		/* li R11, 0 */
		/* 820A81D8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A81D8h case    0:*/		return 0x820A81DC;
		  /* 820A81DCh */ case    1:  		/* addi R3, R27, 1 */
		/* 820A81DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R27,0x1);
		/* 820A81DCh case    1:*/		return 0x820A81E0;
		  /* 820A81E0h */ case    2:  		/* stb R11, <#[R29]> */
		/* 820A81E0h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820A81E0h case    2:*/		return 0x820A81E4;
		  /* 820A81E4h */ case    3:  		/* b 8 */
		/* 820A81E4h case    3:*/		return 0x820A81EC;
		/* 820A81E4h case    3:*/		return 0x820A81E8;
	}
	return 0x820A81E8;
} // Block from 820A81D8h-820A81E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A81E8h
// Function '?LexOctal@CTokenize@D3DXShader@@IAAIPBDPA_K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A81E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A81E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A81E8);
		  /* 820A81E8h */ case    0:  		/* li R3, 0 */
		/* 820A81E8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A81E8h case    0:*/		return 0x820A81EC;
	}
	return 0x820A81EC;
} // Block from 820A81E8h-820A81ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A81ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A81EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A81EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A81EC);
		  /* 820A81ECh */ case    0:  		/* addi R1, R1, 176 */
		/* 820A81ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820A81ECh case    0:*/		return 0x820A81F0;
		  /* 820A81F0h */ case    1:  		/* b -94032 */
		/* 820A81F0h case    1:*/		return 0x820912A0;
		/* 820A81F0h case    1:*/		return 0x820A81F4;
		  /* 820A81F4h */ case    2:  		/* nop */
		/* 820A81F4h case    2:*/		cpu::op::nop();
		/* 820A81F4h case    2:*/		return 0x820A81F8;
	}
	return 0x820A81F8;
} // Block from 820A81ECh-820A81F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A81F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A81F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A81F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A81F8);
		  /* 820A81F8h */ case    0:  		/* mfspr R12, LR */
		/* 820A81F8h case    0:*/		regs.R12 = regs.LR;
		/* 820A81F8h case    0:*/		return 0x820A81FC;
		  /* 820A81FCh */ case    1:  		/* bl -94116 */
		/* 820A81FCh case    1:*/		regs.LR = 0x820A8200; return 0x82091258;
		/* 820A81FCh case    1:*/		return 0x820A8200;
		  /* 820A8200h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820A8200h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820A8200h case    2:*/		return 0x820A8204;
		  /* 820A8204h */ case    3:  		/* lwz R11, <#[R3 + 36]> */
		/* 820A8204h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820A8204h case    3:*/		return 0x820A8208;
		  /* 820A8208h */ case    4:  		/* li R28, 0 */
		/* 820A8208h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820A8208h case    4:*/		return 0x820A820C;
		  /* 820A820Ch */ case    5:  		/* stw R4, <#[R3 + 56]> */
		/* 820A820Ch case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000038) );
		/* 820A820Ch case    5:*/		return 0x820A8210;
		  /* 820A8210h */ case    6:  		/* mr R31, R3 */
		/* 820A8210h case    6:*/		regs.R31 = regs.R3;
		/* 820A8210h case    6:*/		return 0x820A8214;
		  /* 820A8214h */ case    7:  		/* mr R29, R5 */
		/* 820A8214h case    7:*/		regs.R29 = regs.R5;
		/* 820A8214h case    7:*/		return 0x820A8218;
		  /* 820A8218h */ case    8:  		/* mr R30, R28 */
		/* 820A8218h case    8:*/		regs.R30 = regs.R28;
		/* 820A8218h case    8:*/		return 0x820A821C;
		  /* 820A821Ch */ case    9:  		/* stw R11, <#[R5 + 20]> */
		/* 820A821Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000014) );
		/* 820A821Ch case    9:*/		return 0x820A8220;
		  /* 820A8220h */ case   10:  		/* lwz R11, <#[R3 + 32]> */
		/* 820A8220h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820A8220h case   10:*/		return 0x820A8224;
		  /* 820A8224h */ case   11:  		/* stw R11, <#[R5 + 16]> */
		/* 820A8224h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000010) );
		/* 820A8224h case   11:*/		return 0x820A8228;
		  /* 820A8228h */ case   12:  		/* lwz R11, <#[R3 + 40]> */
		/* 820A8228h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820A8228h case   12:*/		return 0x820A822C;
		  /* 820A822Ch */ case   13:  		/* stw R11, <#[R5 + 24]> */
		/* 820A822Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000018) );
		/* 820A822Ch case   13:*/		return 0x820A8230;
		  /* 820A8230h */ case   14:  		/* lwz R11, <#[R3]> */
		/* 820A8230h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A8230h case   14:*/		return 0x820A8234;
		  /* 820A8234h */ case   15:  		/* lwz R10, <#[R3 + 4]> */
		/* 820A8234h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820A8234h case   15:*/		return 0x820A8238;
		  /* 820A8238h */ case   16:  		/* subf R11, R10, R11 */
		/* 820A8238h case   16:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A8238h case   16:*/		return 0x820A823C;
		  /* 820A823Ch */ case   17:  		/* stw R11, <#[R3 + 44]> */
		/* 820A823Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820A823Ch case   17:*/		return 0x820A8240;
		  /* 820A8240h */ case   18:  		/* stw R11, <#[R5 + 28]> */
		/* 820A8240h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x0000001C) );
		/* 820A8240h case   18:*/		return 0x820A8244;
		  /* 820A8244h */ case   19:  		/* bl -1364 */
		/* 820A8244h case   19:*/		regs.LR = 0x820A8248; return 0x820A7CF0;
		/* 820A8244h case   19:*/		return 0x820A8248;
		  /* 820A8248h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820A8248h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A8248h case   20:*/		return 0x820A824C;
		  /* 820A824Ch */ case   21:  		/* bc 12, CR0_EQ, 12 */
		/* 820A824Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x820A8258;  }
		/* 820A824Ch case   21:*/		return 0x820A8250;
		  /* 820A8250h */ case   22:  		/* li R11, 16 */
		/* 820A8250h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 820A8250h case   22:*/		return 0x820A8254;
		  /* 820A8254h */ case   23:  		/* b 848 */
		/* 820A8254h case   23:*/		return 0x820A85A4;
		/* 820A8254h case   23:*/		return 0x820A8258;
	}
	return 0x820A8258;
} // Block from 820A81F8h-820A8258h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820A8258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8258);
		  /* 820A8258h */ case    0:  		/* lwz R11, <#[R31 + 36]> */
		/* 820A8258h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820A8258h case    0:*/		return 0x820A825C;
		  /* 820A825Ch */ case    1:  		/* stw R11, <#[R29 + 20]> */
		/* 820A825Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 820A825Ch case    1:*/		return 0x820A8260;
		  /* 820A8260h */ case    2:  		/* lwz R11, <#[R31 + 32]> */
		/* 820A8260h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820A8260h case    2:*/		return 0x820A8264;
		  /* 820A8264h */ case    3:  		/* stw R11, <#[R29 + 16]> */
		/* 820A8264h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 820A8264h case    3:*/		return 0x820A8268;
		  /* 820A8268h */ case    4:  		/* lwz R11, <#[R31 + 40]> */
		/* 820A8268h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820A8268h case    4:*/		return 0x820A826C;
		  /* 820A826Ch */ case    5:  		/* stw R11, <#[R29 + 24]> */
		/* 820A826Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820A826Ch case    5:*/		return 0x820A8270;
		  /* 820A8270h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 820A8270h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8270h case    6:*/		return 0x820A8274;
		  /* 820A8274h */ case    7:  		/* lwz R10, <#[R31 + 4]> */
		/* 820A8274h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820A8274h case    7:*/		return 0x820A8278;
		  /* 820A8278h */ case    8:  		/* subf R11, R10, R11 */
		/* 820A8278h case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820A8278h case    8:*/		return 0x820A827C;
		  /* 820A827Ch */ case    9:  		/* stw R11, <#[R31 + 44]> */
		/* 820A827Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820A827Ch case    9:*/		return 0x820A8280;
		  /* 820A8280h */ case   10:  		/* stw R11, <#[R29 + 28]> */
		/* 820A8280h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 820A8280h case   10:*/		return 0x820A8284;
		  /* 820A8284h */ case   11:  		/* lwz R4, <#[R31]> */
		/* 820A8284h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8284h case   11:*/		return 0x820A8288;
		  /* 820A8288h */ case   12:  		/* lwz R11, <#[R31 + 8]> */
		/* 820A8288h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820A8288h case   12:*/		return 0x820A828C;
		  /* 820A828Ch */ case   13:  		/* cmplw CR6, R4, R11 */
		/* 820A828Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820A828Ch case   13:*/		return 0x820A8290;
		  /* 820A8290h */ case   14:  		/* bc 12, CR6_LT, 12 */
		/* 820A8290h case   14:*/		if ( regs.CR[6].lt ) { return 0x820A829C;  }
		/* 820A8290h case   14:*/		return 0x820A8294;
		  /* 820A8294h */ case   15:  		/* li R11, 17 */
		/* 820A8294h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x11);
		/* 820A8294h case   15:*/		return 0x820A8298;
		  /* 820A8298h */ case   16:  		/* b 780 */
		/* 820A8298h case   16:*/		return 0x820A85A4;
		/* 820A8298h case   16:*/		return 0x820A829C;
	}
	return 0x820A829C;
} // Block from 820A8258h-820A829Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A829Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A829C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A829C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A829C);
		  /* 820A829Ch */ case    0:  		/* lbz R10, <#[R4]> */
		/* 820A829Ch case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 820A829Ch case    0:*/		return 0x820A82A0;
		  /* 820A82A0h */ case    1:  		/* extsb R11, R10 */
		/* 820A82A0h case    1:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R10);
		/* 820A82A0h case    1:*/		return 0x820A82A4;
		  /* 820A82A4h */ case    2:  		/* cmpwi CR6, R11, 48 */
		/* 820A82A4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 820A82A4h case    2:*/		return 0x820A82A8;
		  /* 820A82A8h */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 820A82A8h case    3:*/		if ( regs.CR[6].lt ) { return 0x820A82B4;  }
		/* 820A82A8h case    3:*/		return 0x820A82AC;
		  /* 820A82ACh */ case    4:  		/* cmpwi CR6, R11, 57 */
		/* 820A82ACh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 820A82ACh case    4:*/		return 0x820A82B0;
		  /* 820A82B0h */ case    5:  		/* bc 4, CR6_GT, 12 */
		/* 820A82B0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820A82BC;  }
		/* 820A82B0h case    5:*/		return 0x820A82B4;
	}
	return 0x820A82B4;
} // Block from 820A829Ch-820A82B4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A82B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A82B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A82B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A82B4);
		  /* 820A82B4h */ case    0:  		/* cmpwi CR6, R11, 46 */
		/* 820A82B4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002E);
		/* 820A82B4h case    0:*/		return 0x820A82B8;
		  /* 820A82B8h */ case    1:  		/* bc 4, CR6_EQ, 372 */
		/* 820A82B8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A842C;  }
		/* 820A82B8h case    1:*/		return 0x820A82BC;
	}
	return 0x820A82BC;
} // Block from 820A82B4h-820A82BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A82BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A82BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A82BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A82BC);
		  /* 820A82BCh */ case    0:  		/* lwz R9, <#[R31 + 68]> */
		/* 820A82BCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000044) );
		/* 820A82BCh case    0:*/		return 0x820A82C0;
	}
	return 0x820A82C0;
} // Block from 820A82BCh-820A82C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A82C0h
// Function '?LexDecimal@CTokenize@D3DXShader@@IAAIPBDPA_K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A82C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A82C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A82C0);
		  /* 820A82C0h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 820A82C0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A82C0h case    0:*/		return 0x820A82C4;
		  /* 820A82C4h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820A82C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A82D4;  }
		/* 820A82C4h case    1:*/		return 0x820A82C8;
		  /* 820A82C8h */ case    2:  		/* lwz R9, <#[R31 + 56]> */
		/* 820A82C8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000038) );
		/* 820A82C8h case    2:*/		return 0x820A82CC;
		  /* 820A82CCh */ case    3:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 820A82CCh case    3:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 820A82CCh case    3:*/		return 0x820A82D0;
		  /* 820A82D0h */ case    4:  		/* bc 12, CR0_EQ, 348 */
		/* 820A82D0h case    4:*/		if ( regs.CR[0].eq ) { return 0x820A842C;  }
		/* 820A82D0h case    4:*/		return 0x820A82D4;
	}
	return 0x820A82D4;
} // Block from 820A82C0h-820A82D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A82D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A82D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A82D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A82D4);
		  /* 820A82D4h */ case    0:  		/* addi R28, R29, 8 */
		/* 820A82D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R29,0x8);
		/* 820A82D4h case    0:*/		return 0x820A82D8;
		  /* 820A82D8h */ case    1:  		/* mr R3, R31 */
		/* 820A82D8h case    1:*/		regs.R3 = regs.R31;
		/* 820A82D8h case    1:*/		return 0x820A82DC;
		  /* 820A82DCh */ case    2:  		/* mr R5, R28 */
		/* 820A82DCh case    2:*/		regs.R5 = regs.R28;
		/* 820A82DCh case    2:*/		return 0x820A82E0;
		  /* 820A82E0h */ case    3:  		/* bl -8696 */
		/* 820A82E0h case    3:*/		regs.LR = 0x820A82E4; return 0x820A60E8;
		/* 820A82E0h case    3:*/		return 0x820A82E4;
		  /* 820A82E4h */ case    4:  		/* or. R30, R3, R3 */
		/* 820A82E4h case    4:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A82E4h case    4:*/		return 0x820A82E8;
		  /* 820A82E8h */ case    5:  		/* mr R3, R31 */
		/* 820A82E8h case    5:*/		regs.R3 = regs.R31;
		/* 820A82E8h case    5:*/		return 0x820A82EC;
		  /* 820A82ECh */ case    6:  		/* bc 12, CR0_EQ, 32 */
		/* 820A82ECh case    6:*/		if ( regs.CR[0].eq ) { return 0x820A830C;  }
		/* 820A82ECh case    6:*/		return 0x820A82F0;
		  /* 820A82F0h */ case    7:  		/* li R11, 7 */
		/* 820A82F0h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820A82F0h case    7:*/		return 0x820A82F4;
		  /* 820A82F4h */ case    8:  		/* mr R5, R29 */
		/* 820A82F4h case    8:*/		regs.R5 = regs.R29;
		/* 820A82F4h case    8:*/		return 0x820A82F8;
		  /* 820A82F8h */ case    9:  		/* stw R11, <#[R29]> */
		/* 820A82F8h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820A82F8h case    9:*/		return 0x820A82FC;
		  /* 820A82FCh */ case   10:  		/* lwz R11, <#[R31]> */
		/* 820A82FCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A82FCh case   10:*/		return 0x820A8300;
		  /* 820A8300h */ case   11:  		/* add R4, R11, R30 */
		/* 820A8300h case   11:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 820A8300h case   11:*/		return 0x820A8304;
		  /* 820A8304h */ case   12:  		/* bl -7644 */
		/* 820A8304h case   12:*/		regs.LR = 0x820A8308; return 0x820A6528;
		/* 820A8304h case   12:*/		return 0x820A8308;
		  /* 820A8308h */ case   13:  		/* b 156 */
		/* 820A8308h case   13:*/		return 0x820A83A4;
		/* 820A8308h case   13:*/		return 0x820A830C;
	}
	return 0x820A830C;
} // Block from 820A82D4h-820A830Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A830Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A830C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A830C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A830C);
		  /* 820A830Ch */ case    0:  		/* mr R5, R28 */
		/* 820A830Ch case    0:*/		regs.R5 = regs.R28;
		/* 820A830Ch case    0:*/		return 0x820A8310;
		  /* 820A8310h */ case    1:  		/* lwz R4, <#[R31]> */
		/* 820A8310h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8310h case    1:*/		return 0x820A8314;
		  /* 820A8314h */ case    2:  		/* bl -3148 */
		/* 820A8314h case    2:*/		regs.LR = 0x820A8318; return 0x820A76C8;
		/* 820A8314h case    2:*/		return 0x820A8318;
		  /* 820A8318h */ case    3:  		/* or. R30, R3, R3 */
		/* 820A8318h case    3:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A8318h case    3:*/		return 0x820A831C;
		  /* 820A831Ch */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 820A831Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x820A8328;  }
		/* 820A831Ch case    4:*/		return 0x820A8320;
		  /* 820A8320h */ case    5:  		/* li R10, 4 */
		/* 820A8320h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820A8320h case    5:*/		return 0x820A8324;
		  /* 820A8324h */ case    6:  		/* b 96 */
		/* 820A8324h case    6:*/		return 0x820A8384;
		/* 820A8324h case    6:*/		return 0x820A8328;
	}
	return 0x820A8328;
} // Block from 820A830Ch-820A8328h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A8328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8328);
		  /* 820A8328h */ case    0:  		/* mr R5, R28 */
		/* 820A8328h case    0:*/		regs.R5 = regs.R28;
		/* 820A8328h case    0:*/		return 0x820A832C;
		  /* 820A832Ch */ case    1:  		/* lwz R4, <#[R31]> */
		/* 820A832Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820A832Ch case    1:*/		return 0x820A8330;
		  /* 820A8330h */ case    2:  		/* mr R3, R31 */
		/* 820A8330h case    2:*/		regs.R3 = regs.R31;
		/* 820A8330h case    2:*/		return 0x820A8334;
		  /* 820A8334h */ case    3:  		/* bl -2932 */
		/* 820A8334h case    3:*/		regs.LR = 0x820A8338; return 0x820A77C0;
		/* 820A8334h case    3:*/		return 0x820A8338;
		  /* 820A8338h */ case    4:  		/* or. R30, R3, R3 */
		/* 820A8338h case    4:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A8338h case    4:*/		return 0x820A833C;
		  /* 820A833Ch */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 820A833Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820A8368;  }
		/* 820A833Ch case    5:*/		return 0x820A8340;
		  /* 820A8340h */ case    6:  		/* ld R11, <#[R28]> */
		/* 820A8340h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820A8340h case    6:*/		return 0x820A8344;
		  /* 820A8344h */ case    7:  		/* li R10, 4 */
		/* 820A8344h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820A8344h case    7:*/		return 0x820A8348;
		  /* 820A8348h */ case    8:  		/* stw R10, <#[R29]> */
		/* 820A8348h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 820A8348h case    8:*/		return 0x820A834C;
		  /* 820A834Ch */ case    9:  		/* stw R11, <#[R28]> */
		/* 820A834Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820A834Ch case    9:*/		return 0x820A8350;
		  /* 820A8350h */ case   10:  		/* ld R11, <#[R28]> */
		/* 820A8350h case   10:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820A8350h case   10:*/		return 0x820A8354;
		  /* 820A8354h */ case   11:  		/* cmpldi CR6, R11, 0 */
		/* 820A8354h case   11:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 820A8354h case   11:*/		return 0x820A8358;
		  /* 820A8358h */ case   12:  		/* bc 4, CR6_EQ, 56 */
		/* 820A8358h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A8390;  }
		/* 820A8358h case   12:*/		return 0x820A835C;
		  /* 820A835Ch */ case   13:  		/* li R11, 3 */
		/* 820A835Ch case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820A835Ch case   13:*/		return 0x820A8360;
		  /* 820A8360h */ case   14:  		/* stw R11, <#[R29]> */
		/* 820A8360h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820A8360h case   14:*/		return 0x820A8364;
		  /* 820A8364h */ case   15:  		/* b 44 */
		/* 820A8364h case   15:*/		return 0x820A8390;
		/* 820A8364h case   15:*/		return 0x820A8368;
	}
	return 0x820A8368;
} // Block from 820A8328h-820A8368h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A8368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8368);
		  /* 820A8368h */ case    0:  		/* mr R5, R28 */
		/* 820A8368h case    0:*/		regs.R5 = regs.R28;
		/* 820A8368h case    0:*/		return 0x820A836C;
		  /* 820A836Ch */ case    1:  		/* lwz R4, <#[R31]> */
		/* 820A836Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820A836Ch case    1:*/		return 0x820A8370;
		  /* 820A8370h */ case    2:  		/* mr R3, R31 */
		/* 820A8370h case    2:*/		regs.R3 = regs.R31;
		/* 820A8370h case    2:*/		return 0x820A8374;
		  /* 820A8374h */ case    3:  		/* bl -2780 */
		/* 820A8374h case    3:*/		regs.LR = 0x820A8378; return 0x820A7898;
		/* 820A8374h case    3:*/		return 0x820A8378;
		  /* 820A8378h */ case    4:  		/* or. R30, R3, R3 */
		/* 820A8378h case    4:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A8378h case    4:*/		return 0x820A837C;
		  /* 820A837Ch */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 820A837Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820A83A8;  }
		/* 820A837Ch case    5:*/		return 0x820A8380;
		  /* 820A8380h */ case    6:  		/* li R10, 3 */
		/* 820A8380h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820A8380h case    6:*/		return 0x820A8384;
	}
	return 0x820A8384;
} // Block from 820A8368h-820A8384h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A8384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8384);
		  /* 820A8384h */ case    0:  		/* ld R11, <#[R28]> */
		/* 820A8384h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820A8384h case    0:*/		return 0x820A8388;
		  /* 820A8388h */ case    1:  		/* stw R10, <#[R29]> */
		/* 820A8388h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 820A8388h case    1:*/		return 0x820A838C;
		  /* 820A838Ch */ case    2:  		/* stw R11, <#[R28]> */
		/* 820A838Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820A838Ch case    2:*/		return 0x820A8390;
	}
	return 0x820A8390;
} // Block from 820A8384h-820A8390h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A8390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8390);
		  /* 820A8390h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A8390h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8390h case    0:*/		return 0x820A8394;
		  /* 820A8394h */ case    1:  		/* mr R5, R29 */
		/* 820A8394h case    1:*/		regs.R5 = regs.R29;
		/* 820A8394h case    1:*/		return 0x820A8398;
		  /* 820A8398h */ case    2:  		/* mr R3, R31 */
		/* 820A8398h case    2:*/		regs.R3 = regs.R31;
		/* 820A8398h case    2:*/		return 0x820A839C;
		  /* 820A839Ch */ case    3:  		/* add R4, R11, R30 */
		/* 820A839Ch case    3:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 820A839Ch case    3:*/		return 0x820A83A0;
		  /* 820A83A0h */ case    4:  		/* bl -7664 */
		/* 820A83A0h case    4:*/		regs.LR = 0x820A83A4; return 0x820A65B0;
		/* 820A83A0h case    4:*/		return 0x820A83A4;
	}
	return 0x820A83A4;
} // Block from 820A8390h-820A83A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A83A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A83A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A83A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A83A4);
		  /* 820A83A4h */ case    0:  		/* add R30, R3, R30 */
		/* 820A83A4h case    0:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R30);
		/* 820A83A4h case    0:*/		return 0x820A83A8;
	}
	return 0x820A83A8;
} // Block from 820A83A4h-820A83A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A83A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A83A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A83A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A83A8);
		  /* 820A83A8h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820A83A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820A83A8h case    0:*/		return 0x820A83AC;
		  /* 820A83ACh */ case    1:  		/* bc 12, CR6_EQ, 480 */
		/* 820A83ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x820A858C;  }
		/* 820A83ACh case    1:*/		return 0x820A83B0;
	}
	return 0x820A83B0;
} // Block from 820A83A8h-820A83B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A83B0h
// Function '?LexStringChar@CTokenize@D3DXShader@@IAAIPBDPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A83B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A83B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A83B0);
		  /* 820A83B0h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 820A83B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820A83B0h case    0:*/		return 0x820A83B4;
		  /* 820A83B4h */ case    1:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 820A83B4h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 820A83B4h case    1:*/		return 0x820A83B8;
		  /* 820A83B8h */ case    2:  		/* bc 12, CR0_EQ, 496 */
		/* 820A83B8h case    2:*/		if ( regs.CR[0].eq ) { return 0x820A85A8;  }
		/* 820A83B8h case    2:*/		return 0x820A83BC;
		  /* 820A83BCh */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820A83BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A83BCh case    3:*/		return 0x820A83C0;
		  /* 820A83C0h */ case    4:  		/* lwz R10, <#[R31 + 8]> */
		/* 820A83C0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820A83C0h case    4:*/		return 0x820A83C4;
		  /* 820A83C4h */ case    5:  		/* add R11, R11, R30 */
		/* 820A83C4h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820A83C4h case    5:*/		return 0x820A83C8;
		  /* 820A83C8h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820A83C8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820A83C8h case    6:*/		return 0x820A83CC;
		  /* 820A83CCh */ case    7:  		/* bc 4, CR6_LT, 476 */
		/* 820A83CCh case    7:*/		if ( !regs.CR[6].lt ) { return 0x820A85A8;  }
		/* 820A83CCh case    7:*/		return 0x820A83D0;
		  /* 820A83D0h */ case    8:  		/* lbz R3, <#[R11]> */
		/* 820A83D0h case    8:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 820A83D0h case    8:*/		return 0x820A83D4;
		  /* 820A83D4h */ case    9:  		/* bl -60516 */
		/* 820A83D4h case    9:*/		regs.LR = 0x820A83D8; return 0x82099770;
		/* 820A83D4h case    9:*/		return 0x820A83D8;
		  /* 820A83D8h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820A83D8h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A83D8h case   10:*/		return 0x820A83DC;
		  /* 820A83DCh */ case   11:  		/* bc 4, CR0_EQ, 20 */
		/* 820A83DCh case   11:*/		if ( !regs.CR[0].eq ) { return 0x820A83F0;  }
		/* 820A83DCh case   11:*/		return 0x820A83E0;
		  /* 820A83E0h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 820A83E0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A83E0h case   12:*/		return 0x820A83E4;
		  /* 820A83E4h */ case   13:  		/* lbzx R11, <#[R11 + R30]> */
		/* 820A83E4h case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820A83E4h case   13:*/		return 0x820A83E8;
		  /* 820A83E8h */ case   14:  		/* cmplwi CR6, R11, 95 */
		/* 820A83E8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820A83E8h case   14:*/		return 0x820A83EC;
		  /* 820A83ECh */ case   15:  		/* bc 4, CR6_EQ, 444 */
		/* 820A83ECh case   15:*/		if ( !regs.CR[6].eq ) { return 0x820A85A8;  }
		/* 820A83ECh case   15:*/		return 0x820A83F0;
	}
	return 0x820A83F0;
} // Block from 820A83B0h-820A83F0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A83F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A83F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A83F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A83F0);
		  /* 820A83F0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A83F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A83F0h case    0:*/		return 0x820A83F4;
		  /* 820A83F4h */ case    1:  		/* mr R3, R31 */
		/* 820A83F4h case    1:*/		regs.R3 = regs.R31;
		/* 820A83F4h case    1:*/		return 0x820A83F8;
		  /* 820A83F8h */ case    2:  		/* add R4, R11, R30 */
		/* 820A83F8h case    2:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 820A83F8h case    2:*/		return 0x820A83FC;
		  /* 820A83FCh */ case    3:  		/* bl -9084 */
		/* 820A83FCh case    3:*/		regs.LR = 0x820A8400; return 0x820A6080;
		/* 820A83FCh case    3:*/		return 0x820A8400;
		  /* 820A8400h */ case    4:  		/* add R30, R3, R30 */
		/* 820A8400h case    4:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R30);
		/* 820A8400h case    4:*/		return 0x820A8404;
		  /* 820A8404h */ case    5:  		/* mr R7, R28 */
		/* 820A8404h case    5:*/		regs.R7 = regs.R28;
		/* 820A8404h case    5:*/		return 0x820A8408;
		  /* 820A8408h */ case    6:  		/* lwz R6, <#[R31]> */
		/* 820A8408h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8408h case    6:*/		return 0x820A840C;
		  /* 820A840Ch */ case    7:  		/* mr R5, R30 */
		/* 820A840Ch case    7:*/		regs.R5 = regs.R30;
		/* 820A840Ch case    7:*/		return 0x820A8410;
		  /* 820A8410h */ case    8:  		/* lwz R4, <#[R31 + 60]> */
		/* 820A8410h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000003C) );
		/* 820A8410h case    8:*/		return 0x820A8414;
		  /* 820A8414h */ case    9:  		/* lwz R3, <#[R31 + 72]> */
		/* 820A8414h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000048) );
		/* 820A8414h case    9:*/		return 0x820A8418;
		  /* 820A8418h */ case   10:  		/* bl -6416 */
		/* 820A8418h case   10:*/		regs.LR = 0x820A841C; return 0x820A6B08;
		/* 820A8418h case   10:*/		return 0x820A841C;
		  /* 820A841Ch */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820A841Ch case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A841Ch case   11:*/		return 0x820A8420;
		  /* 820A8420h */ case   12:  		/* bc 4, CR0_EQ, 420 */
		/* 820A8420h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820A85C4;  }
		/* 820A8420h case   12:*/		return 0x820A8424;
		  /* 820A8424h */ case   13:  		/* li R11, 11 */
		/* 820A8424h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 820A8424h case   13:*/		return 0x820A8428;
		  /* 820A8428h */ case   14:  		/* b 380 */
		/* 820A8428h case   14:*/		return 0x820A85A4;
		/* 820A8428h case   14:*/		return 0x820A842C;
	}
	return 0x820A842C;
} // Block from 820A83F0h-820A842Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A842Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A842C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A842C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A842C);
		  /* 820A842Ch */ case    0:  		/* cmpwi CR6, R11, 39 */
		/* 820A842Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000027);
		/* 820A842Ch case    0:*/		return 0x820A8430;
		  /* 820A8430h */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 820A8430h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A8458;  }
		/* 820A8430h case    1:*/		return 0x820A8434;
		  /* 820A8434h */ case    2:  		/* std R28, <#[R29 + 8]> */
		/* 820A8434h case    2:*/		cpu::mem::store64( regs, regs.R28, (uint32)(regs.R29 + 0x00000008) );
		/* 820A8434h case    2:*/		return 0x820A8438;
		  /* 820A8438h */ case    3:  		/* addi R5, R29, 8 */
		/* 820A8438h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x8);
		/* 820A8438h case    3:*/		return 0x820A843C;
		  /* 820A843Ch */ case    4:  		/* mr R3, R31 */
		/* 820A843Ch case    4:*/		regs.R3 = regs.R31;
		/* 820A843Ch case    4:*/		return 0x820A8440;
		  /* 820A8440h */ case    5:  		/* lwz R4, <#[R31]> */
		/* 820A8440h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8440h case    5:*/		return 0x820A8444;
		  /* 820A8444h */ case    6:  		/* bl -1252 */
		/* 820A8444h case    6:*/		regs.LR = 0x820A8448; return 0x820A7F60;
		/* 820A8444h case    6:*/		return 0x820A8448;
		  /* 820A8448h */ case    7:  		/* or. R30, R3, R3 */
		/* 820A8448h case    7:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A8448h case    7:*/		return 0x820A844C;
		  /* 820A844Ch */ case    8:  		/* bc 12, CR0_EQ, 320 */
		/* 820A844Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x820A858C;  }
		/* 820A844Ch case    8:*/		return 0x820A8450;
		  /* 820A8450h */ case    9:  		/* li R11, 4 */
		/* 820A8450h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820A8450h case    9:*/		return 0x820A8454;
		  /* 820A8454h */ case   10:  		/* b 336 */
		/* 820A8454h case   10:*/		return 0x820A85A4;
		/* 820A8454h case   10:*/		return 0x820A8458;
	}
	return 0x820A8458;
} // Block from 820A842Ch-820A8458h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A8458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8458);
		  /* 820A8458h */ case    0:  		/* cmpwi CR6, R11, 34 */
		/* 820A8458h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000022);
		/* 820A8458h case    0:*/		return 0x820A845C;
		  /* 820A845Ch */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 820A845Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A847C;  }
		/* 820A845Ch case    1:*/		return 0x820A8460;
		  /* 820A8460h */ case    2:  		/* addi R5, R29, 8 */
		/* 820A8460h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x8);
		/* 820A8460h case    2:*/		return 0x820A8464;
		  /* 820A8464h */ case    3:  		/* mr R3, R31 */
		/* 820A8464h case    3:*/		regs.R3 = regs.R31;
		/* 820A8464h case    3:*/		return 0x820A8468;
		  /* 820A8468h */ case    4:  		/* bl -1168 */
		/* 820A8468h case    4:*/		regs.LR = 0x820A846C; return 0x820A7FD8;
		/* 820A8468h case    4:*/		return 0x820A846C;
		  /* 820A846Ch */ case    5:  		/* or. R30, R3, R3 */
		/* 820A846Ch case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A846Ch case    5:*/		return 0x820A8470;
		  /* 820A8470h */ case    6:  		/* bc 12, CR0_EQ, 284 */
		/* 820A8470h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A858C;  }
		/* 820A8470h case    6:*/		return 0x820A8474;
		  /* 820A8474h */ case    7:  		/* li R11, 12 */
		/* 820A8474h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820A8474h case    7:*/		return 0x820A8478;
		  /* 820A8478h */ case    8:  		/* b 300 */
		/* 820A8478h case    8:*/		return 0x820A85A4;
		/* 820A8478h case    8:*/		return 0x820A847C;
	}
	return 0x820A847C;
} // Block from 820A8458h-820A847Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A847Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A847C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A847C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A847C);
		  /* 820A847Ch */ case    0:  		/* lwz R9, <#[R31 + 56]> */
		/* 820A847Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000038) );
		/* 820A847Ch case    0:*/		return 0x820A8480;
		  /* 820A8480h */ case    1:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 820A8480h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 820A8480h case    1:*/		return 0x820A8484;
		  /* 820A8484h */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 820A8484h case    2:*/		if ( regs.CR[0].eq ) { return 0x820A84AC;  }
		/* 820A8484h case    2:*/		return 0x820A8488;
		  /* 820A8488h */ case    3:  		/* cmpwi CR6, R11, 60 */
		/* 820A8488h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000003C);
		/* 820A8488h case    3:*/		return 0x820A848C;
		  /* 820A848Ch */ case    4:  		/* bc 4, CR6_EQ, 32 */
		/* 820A848Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820A84AC;  }
		/* 820A848Ch case    4:*/		return 0x820A8490;
		  /* 820A8490h */ case    5:  		/* addi R5, R29, 8 */
		/* 820A8490h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x8);
		/* 820A8490h case    5:*/		return 0x820A8494;
		  /* 820A8494h */ case    6:  		/* mr R3, R31 */
		/* 820A8494h case    6:*/		regs.R3 = regs.R31;
		/* 820A8494h case    6:*/		return 0x820A8498;
		  /* 820A8498h */ case    7:  		/* bl -1216 */
		/* 820A8498h case    7:*/		regs.LR = 0x820A849C; return 0x820A7FD8;
		/* 820A8498h case    7:*/		return 0x820A849C;
		  /* 820A849Ch */ case    8:  		/* or. R30, R3, R3 */
		/* 820A849Ch case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A849Ch case    8:*/		return 0x820A84A0;
		  /* 820A84A0h */ case    9:  		/* bc 12, CR0_EQ, 236 */
		/* 820A84A0h case    9:*/		if ( regs.CR[0].eq ) { return 0x820A858C;  }
		/* 820A84A0h case    9:*/		return 0x820A84A4;
		  /* 820A84A4h */ case   10:  		/* li R11, 13 */
		/* 820A84A4h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 820A84A4h case   10:*/		return 0x820A84A8;
		  /* 820A84A8h */ case   11:  		/* b 252 */
		/* 820A84A8h case   11:*/		return 0x820A85A4;
		/* 820A84A8h case   11:*/		return 0x820A84AC;
	}
	return 0x820A84AC;
} // Block from 820A847Ch-820A84ACh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A84ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A84AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A84AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A84AC);
		  /* 820A84ACh */ case    0:  		/* rlwinm R3, R10, 0, 24, 31 */
		/* 820A84ACh case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R10);
		/* 820A84ACh case    0:*/		return 0x820A84B0;
		  /* 820A84B0h */ case    1:  		/* bl -60864 */
		/* 820A84B0h case    1:*/		regs.LR = 0x820A84B4; return 0x820996F0;
		/* 820A84B0h case    1:*/		return 0x820A84B4;
		  /* 820A84B4h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820A84B4h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A84B4h case    2:*/		return 0x820A84B8;
		  /* 820A84B8h */ case    3:  		/* bc 4, CR0_EQ, 144 */
		/* 820A84B8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820A8548;  }
		/* 820A84B8h case    3:*/		return 0x820A84BC;
		  /* 820A84BCh */ case    4:  		/* lwz R11, <#[R31 + 68]> */
		/* 820A84BCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820A84BCh case    4:*/		return 0x820A84C0;
		  /* 820A84C0h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 820A84C0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A84C0h case    5:*/		return 0x820A84C4;
		  /* 820A84C4h */ case    6:  		/* bc 12, CR6_EQ, 44 */
		/* 820A84C4h case    6:*/		if ( regs.CR[6].eq ) { return 0x820A84F0;  }
		/* 820A84C4h case    6:*/		return 0x820A84C8;
		  /* 820A84C8h */ case    7:  		/* lwz R11, <#[R31 + 56]> */
		/* 820A84C8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820A84C8h case    7:*/		return 0x820A84CC;
		  /* 820A84CCh */ case    8:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820A84CCh case    8:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820A84CCh case    8:*/		return 0x820A84D0;
		  /* 820A84D0h */ case    9:  		/* bc 4, CR0_EQ, 32 */
		/* 820A84D0h case    9:*/		if ( !regs.CR[0].eq ) { return 0x820A84F0;  }
		/* 820A84D0h case    9:*/		return 0x820A84D4;
		  /* 820A84D4h */ case   10:  		/* lwz R11, <#[R31]> */
		/* 820A84D4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A84D4h case   10:*/		return 0x820A84D8;
		  /* 820A84D8h */ case   11:  		/* lbz R11, <#[R11]> */
		/* 820A84D8h case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820A84D8h case   11:*/		return 0x820A84DC;
		  /* 820A84DCh */ case   12:  		/* extsb R11, R11 */
		/* 820A84DCh case   12:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820A84DCh case   12:*/		return 0x820A84E0;
		  /* 820A84E0h */ case   13:  		/* cmpwi CR6, R11, 48 */
		/* 820A84E0h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 820A84E0h case   13:*/		return 0x820A84E4;
		  /* 820A84E4h */ case   14:  		/* bc 12, CR6_LT, 12 */
		/* 820A84E4h case   14:*/		if ( regs.CR[6].lt ) { return 0x820A84F0;  }
		/* 820A84E4h case   14:*/		return 0x820A84E8;
		  /* 820A84E8h */ case   15:  		/* cmpwi CR6, R11, 57 */
		/* 820A84E8h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 820A84E8h case   15:*/		return 0x820A84EC;
		  /* 820A84ECh */ case   16:  		/* bc 4, CR6_GT, 92 */
		/* 820A84ECh case   16:*/		if ( !regs.CR[6].gt ) { return 0x820A8548;  }
		/* 820A84ECh case   16:*/		return 0x820A84F0;
	}
	return 0x820A84F0;
} // Block from 820A84ACh-820A84F0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A84F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A84F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A84F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A84F0);
		  /* 820A84F0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A84F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A84F0h case    0:*/		return 0x820A84F4;
		  /* 820A84F4h */ case    1:  		/* lbz R10, <#[R11]> */
		/* 820A84F4h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A84F4h case    1:*/		return 0x820A84F8;
		  /* 820A84F8h */ case    2:  		/* extsb R10, R10 */
		/* 820A84F8h case    2:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820A84F8h case    2:*/		return 0x820A84FC;
		  /* 820A84FCh */ case    3:  		/* cmpwi CR6, R10, 95 */
		/* 820A84FCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000005F);
		/* 820A84FCh case    3:*/		return 0x820A8500;
		  /* 820A8500h */ case    4:  		/* bc 12, CR6_EQ, 72 */
		/* 820A8500h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A8548;  }
		/* 820A8500h case    4:*/		return 0x820A8504;
		  /* 820A8504h */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 820A8504h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820A8504h case    5:*/		return 0x820A8508;
		  /* 820A8508h */ case    6:  		/* addi R8, R11, 3 */
		/* 820A8508h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x3);
		/* 820A8508h case    6:*/		return 0x820A850C;
		  /* 820A850Ch */ case    7:  		/* cmplw CR6, R8, R9 */
		/* 820A850Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820A850Ch case    7:*/		return 0x820A8510;
		  /* 820A8510h */ case    8:  		/* bc 12, CR6_GT, 124 */
		/* 820A8510h case    8:*/		if ( regs.CR[6].gt ) { return 0x820A858C;  }
		/* 820A8510h case    8:*/		return 0x820A8514;
		  /* 820A8514h */ case    9:  		/* cmpwi CR6, R10, 58 */
		/* 820A8514h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000003A);
		/* 820A8514h case    9:*/		return 0x820A8518;
		  /* 820A8518h */ case   10:  		/* bc 4, CR6_EQ, 116 */
		/* 820A8518h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820A858C;  }
		/* 820A8518h case   10:*/		return 0x820A851C;
		  /* 820A851Ch */ case   11:  		/* lbz R10, <#[R11 + 1]> */
		/* 820A851Ch case   11:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000001) );
		/* 820A851Ch case   11:*/		return 0x820A8520;
		  /* 820A8520h */ case   12:  		/* cmplwi CR6, R10, 58 */
		/* 820A8520h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000003A);
		/* 820A8520h case   12:*/		return 0x820A8524;
		  /* 820A8524h */ case   13:  		/* bc 4, CR6_EQ, 104 */
		/* 820A8524h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A858C;  }
		/* 820A8524h case   13:*/		return 0x820A8528;
		  /* 820A8528h */ case   14:  		/* lbz R3, <#[R11 + 2]> */
		/* 820A8528h case   14:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000002) );
		/* 820A8528h case   14:*/		return 0x820A852C;
		  /* 820A852Ch */ case   15:  		/* bl -60988 */
		/* 820A852Ch case   15:*/		regs.LR = 0x820A8530; return 0x820996F0;
		/* 820A852Ch case   15:*/		return 0x820A8530;
		  /* 820A8530h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820A8530h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A8530h case   16:*/		return 0x820A8534;
		  /* 820A8534h */ case   17:  		/* bc 4, CR0_EQ, 20 */
		/* 820A8534h case   17:*/		if ( !regs.CR[0].eq ) { return 0x820A8548;  }
		/* 820A8534h case   17:*/		return 0x820A8538;
		  /* 820A8538h */ case   18:  		/* lwz R11, <#[R31]> */
		/* 820A8538h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8538h case   18:*/		return 0x820A853C;
		  /* 820A853Ch */ case   19:  		/* lbz R11, <#[R11 + 2]> */
		/* 820A853Ch case   19:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000002) );
		/* 820A853Ch case   19:*/		return 0x820A8540;
		  /* 820A8540h */ case   20:  		/* cmplwi CR6, R11, 95 */
		/* 820A8540h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820A8540h case   20:*/		return 0x820A8544;
		  /* 820A8544h */ case   21:  		/* bc 4, CR6_EQ, 72 */
		/* 820A8544h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820A858C;  }
		/* 820A8544h case   21:*/		return 0x820A8548;
	}
	return 0x820A8548;
} // Block from 820A84F0h-820A8548h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820A8548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8548);
		  /* 820A8548h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 820A8548h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820A8548h case    0:*/		return 0x820A854C;
		  /* 820A854Ch */ case    1:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820A854Ch case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820A854Ch case    1:*/		return 0x820A8550;
		  /* 820A8550h */ case    2:  		/* bc 12, CR0_EQ, 36 */
		/* 820A8550h case    2:*/		if ( regs.CR[0].eq ) { return 0x820A8574;  }
		/* 820A8550h case    2:*/		return 0x820A8554;
		  /* 820A8554h */ case    3:  		/* addi R5, R29, 8 */
		/* 820A8554h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x8);
		/* 820A8554h case    3:*/		return 0x820A8558;
		  /* 820A8558h */ case    4:  		/* lwz R4, <#[R31]> */
		/* 820A8558h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8558h case    4:*/		return 0x820A855C;
		  /* 820A855Ch */ case    5:  		/* mr R3, R31 */
		/* 820A855Ch case    5:*/		regs.R3 = regs.R31;
		/* 820A855Ch case    5:*/		return 0x820A8560;
		  /* 820A8560h */ case    6:  		/* bl -2512 */
		/* 820A8560h case    6:*/		regs.LR = 0x820A8564; return 0x820A7B90;
		/* 820A8560h case    6:*/		return 0x820A8564;
		  /* 820A8564h */ case    7:  		/* or. R30, R3, R3 */
		/* 820A8564h case    7:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A8564h case    7:*/		return 0x820A8568;
		  /* 820A8568h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 820A8568h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A8574;  }
		/* 820A8568h case    8:*/		return 0x820A856C;
		  /* 820A856Ch */ case    9:  		/* stw R28, <#[R29]> */
		/* 820A856Ch case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R29 + 0x00000000) );
		/* 820A856Ch case    9:*/		return 0x820A8570;
		  /* 820A8570h */ case   10:  		/* b 56 */
		/* 820A8570h case   10:*/		return 0x820A85A8;
		/* 820A8570h case   10:*/		return 0x820A8574;
	}
	return 0x820A8574;
} // Block from 820A8548h-820A8574h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A8574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8574);
		  /* 820A8574h */ case    0:  		/* addi R5, R29, 8 */
		/* 820A8574h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x8);
		/* 820A8574h case    0:*/		return 0x820A8578;
		  /* 820A8578h */ case    1:  		/* lwz R4, <#[R31]> */
		/* 820A8578h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8578h case    1:*/		return 0x820A857C;
		  /* 820A857Ch */ case    2:  		/* mr R3, R31 */
		/* 820A857Ch case    2:*/		regs.R3 = regs.R31;
		/* 820A857Ch case    2:*/		return 0x820A8580;
		  /* 820A8580h */ case    3:  		/* bl -6472 */
		/* 820A8580h case    3:*/		regs.LR = 0x820A8584; return 0x820A6C38;
		/* 820A8580h case    3:*/		return 0x820A8584;
		  /* 820A8584h */ case    4:  		/* or. R30, R3, R3 */
		/* 820A8584h case    4:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A8584h case    4:*/		return 0x820A8588;
		  /* 820A8588h */ case    5:  		/* bc 4, CR0_EQ, -356 */
		/* 820A8588h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820A8424;  }
		/* 820A8588h case    5:*/		return 0x820A858C;
	}
	return 0x820A858C;
} // Block from 820A8574h-820A858Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A858Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A858C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A858C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A858C);
		  /* 820A858Ch */ case    0:  		/* addi R5, R29, 8 */
		/* 820A858Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x8);
		/* 820A858Ch case    0:*/		return 0x820A8590;
		  /* 820A8590h */ case    1:  		/* lwz R4, <#[R31]> */
		/* 820A8590h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8590h case    1:*/		return 0x820A8594;
		  /* 820A8594h */ case    2:  		/* mr R3, R31 */
		/* 820A8594h case    2:*/		regs.R3 = regs.R31;
		/* 820A8594h case    2:*/		return 0x820A8598;
		  /* 820A8598h */ case    3:  		/* bl -8704 */
		/* 820A8598h case    3:*/		regs.LR = 0x820A859C; return 0x820A6398;
		/* 820A8598h case    3:*/		return 0x820A859C;
		  /* 820A859Ch */ case    4:  		/* li R11, 1 */
		/* 820A859Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A859Ch case    4:*/		return 0x820A85A0;
		  /* 820A85A0h */ case    5:  		/* mr R30, R3 */
		/* 820A85A0h case    5:*/		regs.R30 = regs.R3;
		/* 820A85A0h case    5:*/		return 0x820A85A4;
	}
	return 0x820A85A4;
} // Block from 820A858Ch-820A85A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A85A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A85A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A85A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A85A4);
		  /* 820A85A4h */ case    0:  		/* stw R11, <#[R29]> */
		/* 820A85A4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820A85A4h case    0:*/		return 0x820A85A8;
	}
	return 0x820A85A8;
} // Block from 820A85A4h-820A85A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A85A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A85A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A85A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A85A8);
		  /* 820A85A8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A85A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A85A8h case    0:*/		return 0x820A85AC;
		  /* 820A85ACh */ case    1:  		/* li R3, 0 */
		/* 820A85ACh case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A85ACh case    1:*/		return 0x820A85B0;
		  /* 820A85B0h */ case    2:  		/* stw R30, <#[R29 + 36]> */
		/* 820A85B0h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R29 + 0x00000024) );
		/* 820A85B0h case    2:*/		return 0x820A85B4;
		  /* 820A85B4h */ case    3:  		/* stw R11, <#[R29 + 32]> */
		/* 820A85B4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000020) );
		/* 820A85B4h case    3:*/		return 0x820A85B8;
	}
	return 0x820A85B8;
} // Block from 820A85A8h-820A85B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A85B8h
// Function '?LexVersion@CTokenize@D3DXShader@@IAAIPBDPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A85B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A85B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A85B8);
		  /* 820A85B8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820A85B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A85B8h case    0:*/		return 0x820A85BC;
		  /* 820A85BCh */ case    1:  		/* add R11, R11, R30 */
		/* 820A85BCh case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820A85BCh case    1:*/		return 0x820A85C0;
		  /* 820A85C0h */ case    2:  		/* stw R11, <#[R31]> */
		/* 820A85C0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A85C0h case    2:*/		return 0x820A85C4;
	}
	return 0x820A85C4;
} // Block from 820A85B8h-820A85C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A85C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A85C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A85C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A85C4);
		  /* 820A85C4h */ case    0:  		/* addi R1, R1, 128 */
		/* 820A85C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820A85C4h case    0:*/		return 0x820A85C8;
		  /* 820A85C8h */ case    1:  		/* b -95008 */
		/* 820A85C8h case    1:*/		return 0x820912A8;
		/* 820A85C8h case    1:*/		return 0x820A85CC;
		  /* 820A85CCh */ case    2:  		/* nop */
		/* 820A85CCh case    2:*/		cpu::op::nop();
		/* 820A85CCh case    2:*/		return 0x820A85D0;
	}
	return 0x820A85D0;
} // Block from 820A85C4h-820A85D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A85D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A85D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A85D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A85D0);
		  /* 820A85D0h */ case    0:  		/* mfspr R12, LR */
		/* 820A85D0h case    0:*/		regs.R12 = regs.LR;
		/* 820A85D0h case    0:*/		return 0x820A85D4;
		  /* 820A85D4h */ case    1:  		/* bl -95112 */
		/* 820A85D4h case    1:*/		regs.LR = 0x820A85D8; return 0x8209124C;
		/* 820A85D4h case    1:*/		return 0x820A85D8;
		  /* 820A85D8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820A85D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820A85D8h case    2:*/		return 0x820A85DC;
		  /* 820A85DCh */ case    3:  		/* lbz R11, <#[R3]> */
		/* 820A85DCh case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A85DCh case    3:*/		return 0x820A85E0;
		  /* 820A85E0h */ case    4:  		/* mr R30, R3 */
		/* 820A85E0h case    4:*/		regs.R30 = regs.R3;
		/* 820A85E0h case    4:*/		return 0x820A85E4;
		  /* 820A85E4h */ case    5:  		/* mr R26, R4 */
		/* 820A85E4h case    5:*/		regs.R26 = regs.R4;
		/* 820A85E4h case    5:*/		return 0x820A85E8;
		  /* 820A85E8h */ case    6:  		/* mr R25, R5 */
		/* 820A85E8h case    6:*/		regs.R25 = regs.R5;
		/* 820A85E8h case    6:*/		return 0x820A85EC;
		  /* 820A85ECh */ case    7:  		/* mr R31, R3 */
		/* 820A85ECh case    7:*/		regs.R31 = regs.R3;
		/* 820A85ECh case    7:*/		return 0x820A85F0;
		  /* 820A85F0h */ case    8:  		/* b 28 */
		/* 820A85F0h case    8:*/		return 0x820A860C;
		/* 820A85F0h case    8:*/		return 0x820A85F4;
		  /* 820A85F4h */ case    9:  		/* lbz R11, <#[R31]> */
		/* 820A85F4h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A85F4h case    9:*/		return 0x820A85F8;
		  /* 820A85F8h */ case   10:  		/* extsb R3, R11 */
		/* 820A85F8h case   10:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820A85F8h case   10:*/		return 0x820A85FC;
		  /* 820A85FCh */ case   11:  		/* bl -61196 */
		/* 820A85FCh case   11:*/		regs.LR = 0x820A8600; return 0x820996F0;
		/* 820A85FCh case   11:*/		return 0x820A8600;
		  /* 820A8600h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820A8600h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A8600h case   12:*/		return 0x820A8604;
		  /* 820A8604h */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 820A8604h case   13:*/		if ( regs.CR[0].eq ) { return 0x820A8614;  }
		/* 820A8604h case   13:*/		return 0x820A8608;
		  /* 820A8608h */ case   14:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820A8608h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820A8608h case   14:*/		return 0x820A860C;
	}
	return 0x820A860C;
} // Block from 820A85D0h-820A860Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A860Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A860C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A860C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A860C);
		  /* 820A860Ch */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 820A860Ch case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A860Ch case    0:*/		return 0x820A8610;
		  /* 820A8610h */ case    1:  		/* bc 4, CR0_EQ, -28 */
		/* 820A8610h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A85F4;  }
		/* 820A8610h case    1:*/		return 0x820A8614;
	}
	return 0x820A8614;
} // Block from 820A860Ch-820A8614h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A8614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8614);
		  /* 820A8614h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820A8614h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8614h case    0:*/		return 0x820A8618;
		  /* 820A8618h */ case    1:  		/* li R28, 0 */
		/* 820A8618h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820A8618h case    1:*/		return 0x820A861C;
		  /* 820A861Ch */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 820A861Ch case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A861Ch case    2:*/		return 0x820A8620;
		  /* 820A8620h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820A8620h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A8630;  }
		/* 820A8620h case    3:*/		return 0x820A8624;
		  /* 820A8624h */ case    4:  		/* mr R3, R31 */
		/* 820A8624h case    4:*/		regs.R3 = regs.R31;
		/* 820A8624h case    4:*/		return 0x820A8628;
		  /* 820A8628h */ case    5:  		/* bl -88768 */
		/* 820A8628h case    5:*/		regs.LR = 0x820A862C; return 0x82092B68;
		/* 820A8628h case    5:*/		return 0x820A862C;
		  /* 820A862Ch */ case    6:  		/* b 8 */
		/* 820A862Ch case    6:*/		return 0x820A8634;
		/* 820A862Ch case    6:*/		return 0x820A8630;
	}
	return 0x820A8630;
} // Block from 820A8614h-820A8630h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A8630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8630);
		  /* 820A8630h */ case    0:  		/* mr R3, R28 */
		/* 820A8630h case    0:*/		regs.R3 = regs.R28;
		/* 820A8630h case    0:*/		return 0x820A8634;
	}
	return 0x820A8634;
} // Block from 820A8630h-820A8634h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A8634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8634);
		  /* 820A8634h */ case    0:  		/* rlwinm R27, R3, 0, 24, 31 */
		/* 820A8634h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R27,regs.R3);
		/* 820A8634h case    0:*/		return 0x820A8638;
		  /* 820A8638h */ case    1:  		/* cmplwi CR6, R27, 15 */
		/* 820A8638h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x0000000F);
		/* 820A8638h case    1:*/		return 0x820A863C;
		  /* 820A863Ch */ case    2:  		/* bc 4, CR6_GT, 32 */
		/* 820A863Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x820A865C;  }
		/* 820A863Ch case    2:*/		return 0x820A8640;
		  /* 820A8640h */ case    3:  		/* li R11, 255 */
		/* 820A8640h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xFF);
		/* 820A8640h case    3:*/		return 0x820A8644;
		  /* 820A8644h */ case    4:  		/* stb R28, <#[R26]> */
		/* 820A8644h case    4:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R26 + 0x00000000) );
		/* 820A8644h case    4:*/		return 0x820A8648;
		  /* 820A8648h */ case    5:  		/* stb R11, <#[R25]> */
		/* 820A8648h case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820A8648h case    5:*/		return 0x820A864C;
		  /* 820A864Ch */ case    6:  		/* lis R3, -32768 */
		/* 820A864Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A864Ch case    6:*/		return 0x820A8650;
		  /* 820A8650h */ case    7:  		/* ori R3, R3, 16389 */
		/* 820A8650h case    7:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820A8650h case    7:*/		return 0x820A8654;
		  /* 820A8654h */ case    8:  		/* addi R1, R1, 176 */
		/* 820A8654h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820A8654h case    8:*/		return 0x820A8658;
		  /* 820A8658h */ case    9:  		/* b -95164 */
		/* 820A8658h case    9:*/		return 0x8209129C;
		/* 820A8658h case    9:*/		return 0x820A865C;
	}
	return 0x820A865C;
} // Block from 820A8634h-820A865Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A865Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A865C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A865C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A865C);
		  /* 820A865Ch */ case    0:  		/* subf. R29, R30, R31 */
		/* 820A865Ch case    0:*/		cpu::op::subf<1>(regs,&regs.R29,regs.R30,regs.R31);
		/* 820A865Ch case    0:*/		return 0x820A8660;
		  /* 820A8660h */ case    1:  		/* bc 12, CR0_EQ, -20 */
		/* 820A8660h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A864C;  }
		/* 820A8660h case    1:*/		return 0x820A8664;
		  /* 820A8664h */ case    2:  		/* cmplwi CR6, R29, 20 */
		/* 820A8664h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000014);
		/* 820A8664h case    2:*/		return 0x820A8668;
		  /* 820A8668h */ case    3:  		/* bc 12, CR6_GT, -28 */
		/* 820A8668h case    3:*/		if ( regs.CR[6].gt ) { return 0x820A864C;  }
		/* 820A8668h case    3:*/		return 0x820A866C;
		  /* 820A866Ch */ case    4:  		/* lbz R11, <#[R31]> */
		/* 820A866Ch case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A866Ch case    4:*/		return 0x820A8670;
		  /* 820A8670h */ case    5:  		/* b 20 */
		/* 820A8670h case    5:*/		return 0x820A8684;
		/* 820A8670h case    5:*/		return 0x820A8674;
		  /* 820A8674h */ case    6:  		/* bl -61284 */
		/* 820A8674h case    6:*/		regs.LR = 0x820A8678; return 0x82099710;
		/* 820A8674h case    6:*/		return 0x820A8678;
		  /* 820A8678h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820A8678h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A8678h case    7:*/		return 0x820A867C;
		  /* 820A867Ch */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 820A867Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x820A868C;  }
		/* 820A867Ch case    8:*/		return 0x820A8680;
		  /* 820A8680h */ case    9:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820A8680h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820A8680h case    9:*/		return 0x820A8684;
	}
	return 0x820A8684;
} // Block from 820A865Ch-820A8684h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A8684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8684);
		  /* 820A8684h */ case    0:  		/* extsb. R3, R11 */
		/* 820A8684h case    0:*/		cpu::op::extsb<1>(regs,&regs.R3,regs.R11);
		/* 820A8684h case    0:*/		return 0x820A8688;
		  /* 820A8688h */ case    1:  		/* bc 4, CR0_EQ, -20 */
		/* 820A8688h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8674;  }
		/* 820A8688h case    1:*/		return 0x820A868C;
	}
	return 0x820A868C;
} // Block from 820A8684h-820A868Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A868Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A868C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A868C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A868C);
		  /* 820A868Ch */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820A868Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A868Ch case    0:*/		return 0x820A8690;
		  /* 820A8690h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820A8690h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A8690h case    1:*/		return 0x820A8694;
		  /* 820A8694h */ case    2:  		/* bc 4, CR0_EQ, -72 */
		/* 820A8694h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A864C;  }
		/* 820A8694h case    2:*/		return 0x820A8698;
		  /* 820A8698h */ case    3:  		/* lbz R11, <#[R30]> */
		/* 820A8698h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820A8698h case    3:*/		return 0x820A869C;
		  /* 820A869Ch */ case    4:  		/* mr R31, R30 */
		/* 820A869Ch case    4:*/		regs.R31 = regs.R30;
		/* 820A869Ch case    4:*/		return 0x820A86A0;
		  /* 820A86A0h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 820A86A0h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A86A0h case    5:*/		return 0x820A86A4;
		  /* 820A86A4h */ case    6:  		/* bc 12, CR0_EQ, 60 */
		/* 820A86A4h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A86E0;  }
		/* 820A86A4h case    6:*/		return 0x820A86A8;
		  /* 820A86A8h */ case    7:  		/* addi R11, R1, 80 */
		/* 820A86A8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A86A8h case    7:*/		return 0x820A86AC;
		  /* 820A86ACh */ case    8:  		/* subf R30, R30, R11 */
		/* 820A86ACh case    8:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R30,regs.R11);
		/* 820A86ACh case    8:*/		return 0x820A86B0;
		  /* 820A86B0h */ case    9:  		/* lbz R11, <#[R31]> */
		/* 820A86B0h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A86B0h case    9:*/		return 0x820A86B4;
		  /* 820A86B4h */ case   10:  		/* extsb R3, R11 */
		/* 820A86B4h case   10:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820A86B4h case   10:*/		return 0x820A86B8;
		  /* 820A86B8h */ case   11:  		/* bl -61384 */
		/* 820A86B8h case   11:*/		regs.LR = 0x820A86BC; return 0x820996F0;
		/* 820A86B8h case   11:*/		return 0x820A86BC;
		  /* 820A86BCh */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820A86BCh case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A86BCh case   12:*/		return 0x820A86C0;
		  /* 820A86C0h */ case   13:  		/* bc 12, CR0_EQ, 32 */
		/* 820A86C0h case   13:*/		if ( regs.CR[0].eq ) { return 0x820A86E0;  }
		/* 820A86C0h case   13:*/		return 0x820A86C4;
		  /* 820A86C4h */ case   14:  		/* lbz R11, <#[R31]> */
		/* 820A86C4h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A86C4h case   14:*/		return 0x820A86C8;
		  /* 820A86C8h */ case   15:  		/* extsb R3, R11 */
		/* 820A86C8h case   15:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820A86C8h case   15:*/		return 0x820A86CC;
		  /* 820A86CCh */ case   16:  		/* bl 1832948 */
		/* 820A86CCh case   16:*/		regs.LR = 0x820A86D0; return 0x82267EC0;
		/* 820A86CCh case   16:*/		return 0x820A86D0;
		  /* 820A86D0h */ case   17:  		/* stbx R3, <#[R30 + R31]> */
		/* 820A86D0h case   17:*/		cpu::mem::store8( regs, regs.R3, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 820A86D0h case   17:*/		return 0x820A86D4;
		  /* 820A86D4h */ case   18:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820A86D4h case   18:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820A86D4h case   18:*/		return 0x820A86D8;
		  /* 820A86D8h */ case   19:  		/* cmplwi CR0, R11, 0 */
		/* 820A86D8h case   19:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A86D8h case   19:*/		return 0x820A86DC;
		  /* 820A86DCh */ case   20:  		/* bc 4, CR0_EQ, -44 */
		/* 820A86DCh case   20:*/		if ( !regs.CR[0].eq ) { return 0x820A86B0;  }
		/* 820A86DCh case   20:*/		return 0x820A86E0;
	}
	return 0x820A86E0;
} // Block from 820A868Ch-820A86E0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820A86E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A86E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A86E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A86E0);
		  /* 820A86E0h */ case    0:  		/* addi R9, R1, 80 */
		/* 820A86E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 820A86E0h case    0:*/		return 0x820A86E4;
		  /* 820A86E4h */ case    1:  		/* lis R10, -32255 */
		/* 820A86E4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A86E4h case    1:*/		return 0x820A86E8;
		  /* 820A86E8h */ case    2:  		/* addi R11, R1, 80 */
		/* 820A86E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A86E8h case    2:*/		return 0x820A86EC;
		  /* 820A86ECh */ case    3:  		/* addi R10, R10, 2424 */
		/* 820A86ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x978);
		/* 820A86ECh case    3:*/		return 0x820A86F0;
		  /* 820A86F0h */ case    4:  		/* stbx R28, <#[R29 + R9]> */
		/* 820A86F0h case    4:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R29 + regs.R9 + 0x00000000) );
		/* 820A86F0h case    4:*/		return 0x820A86F4;
		  /* 820A86F4h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820A86F4h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A86F4h case    5:*/		return 0x820A86F8;
		  /* 820A86F8h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820A86F8h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A86F8h case    6:*/		return 0x820A86FC;
		  /* 820A86FCh */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820A86FCh case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A86FCh case    7:*/		return 0x820A8700;
		  /* 820A8700h */ case    8:  		/* subf R9, R8, R9 */
		/* 820A8700h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8700h case    8:*/		return 0x820A8704;
		  /* 820A8704h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8704h case    9:*/		if ( regs.CR[0].eq ) { return 0x820A8718;  }
		/* 820A8704h case    9:*/		return 0x820A8708;
		  /* 820A8708h */ case   10:  		/* addi R11, R11, 1 */
		/* 820A8708h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8708h case   10:*/		return 0x820A870C;
		  /* 820A870Ch */ case   11:  		/* addi R10, R10, 1 */
		/* 820A870Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A870Ch case   11:*/		return 0x820A8710;
		  /* 820A8710h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820A8710h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8710h case   12:*/		return 0x820A8714;
		  /* 820A8714h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8714h case   13:*/		if ( regs.CR[6].eq ) { return 0x820A86F4;  }
		/* 820A8714h case   13:*/		return 0x820A8718;
	}
	return 0x820A8718;
} // Block from 820A86E0h-820A8718h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A8718h
// Function '?SkipWhitespace@CTokenize@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8718);
		  /* 820A8718h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8718h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8718h case    0:*/		return 0x820A871C;
		  /* 820A871Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A871Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8728;  }
		/* 820A871Ch case    1:*/		return 0x820A8720;
		  /* 820A8720h */ case    2:  		/* mr R11, R28 */
		/* 820A8720h case    2:*/		regs.R11 = regs.R28;
		/* 820A8720h case    2:*/		return 0x820A8724;
		  /* 820A8724h */ case    3:  		/* b 1084 */
		/* 820A8724h case    3:*/		return 0x820A8B60;
		/* 820A8724h case    3:*/		return 0x820A8728;
	}
	return 0x820A8728;
} // Block from 820A8718h-820A8728h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8728);
		  /* 820A8728h */ case    0:  		/* lis R10, -32255 */
		/* 820A8728h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A8728h case    0:*/		return 0x820A872C;
		  /* 820A872Ch */ case    1:  		/* addi R11, R1, 80 */
		/* 820A872Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A872Ch case    1:*/		return 0x820A8730;
		  /* 820A8730h */ case    2:  		/* addi R10, R10, 2412 */
		/* 820A8730h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x96C);
		/* 820A8730h case    2:*/		return 0x820A8734;
		  /* 820A8734h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A8734h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8734h case    3:*/		return 0x820A8738;
		  /* 820A8738h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A8738h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8738h case    4:*/		return 0x820A873C;
		  /* 820A873Ch */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A873Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A873Ch case    5:*/		return 0x820A8740;
		  /* 820A8740h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8740h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8740h case    6:*/		return 0x820A8744;
		  /* 820A8744h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8744h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8758;  }
		/* 820A8744h case    7:*/		return 0x820A8748;
		  /* 820A8748h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8748h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8748h case    8:*/		return 0x820A874C;
		  /* 820A874Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820A874Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A874Ch case    9:*/		return 0x820A8750;
		  /* 820A8750h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8750h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8750h case   10:*/		return 0x820A8754;
		  /* 820A8754h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8754h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A8734;  }
		/* 820A8754h case   11:*/		return 0x820A8758;
	}
	return 0x820A8758;
} // Block from 820A8728h-820A8758h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8758);
		  /* 820A8758h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8758h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8758h case    0:*/		return 0x820A875C;
		  /* 820A875Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A875Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8768;  }
		/* 820A875Ch case    1:*/		return 0x820A8760;
		  /* 820A8760h */ case    2:  		/* li R11, 1 */
		/* 820A8760h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A8760h case    2:*/		return 0x820A8764;
		  /* 820A8764h */ case    3:  		/* b 1020 */
		/* 820A8764h case    3:*/		return 0x820A8B60;
		/* 820A8764h case    3:*/		return 0x820A8768;
	}
	return 0x820A8768;
} // Block from 820A8758h-820A8768h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8768);
		  /* 820A8768h */ case    0:  		/* lis R10, -32255 */
		/* 820A8768h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A8768h case    0:*/		return 0x820A876C;
		  /* 820A876Ch */ case    1:  		/* addi R11, R1, 80 */
		/* 820A876Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A876Ch case    1:*/		return 0x820A8770;
		  /* 820A8770h */ case    2:  		/* addi R10, R10, 2396 */
		/* 820A8770h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x95C);
		/* 820A8770h case    2:*/		return 0x820A8774;
		  /* 820A8774h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A8774h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8774h case    3:*/		return 0x820A8778;
		  /* 820A8778h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A8778h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8778h case    4:*/		return 0x820A877C;
		  /* 820A877Ch */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A877Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A877Ch case    5:*/		return 0x820A8780;
		  /* 820A8780h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8780h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8780h case    6:*/		return 0x820A8784;
		  /* 820A8784h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8784h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8798;  }
		/* 820A8784h case    7:*/		return 0x820A8788;
		  /* 820A8788h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8788h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8788h case    8:*/		return 0x820A878C;
		  /* 820A878Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820A878Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A878Ch case    9:*/		return 0x820A8790;
		  /* 820A8790h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8790h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8790h case   10:*/		return 0x820A8794;
		  /* 820A8794h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8794h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A8774;  }
		/* 820A8794h case   11:*/		return 0x820A8798;
	}
	return 0x820A8798;
} // Block from 820A8768h-820A8798h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8798);
		  /* 820A8798h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8798h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8798h case    0:*/		return 0x820A879C;
		  /* 820A879Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A879Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A87A8;  }
		/* 820A879Ch case    1:*/		return 0x820A87A0;
		  /* 820A87A0h */ case    2:  		/* li R11, 2 */
		/* 820A87A0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820A87A0h case    2:*/		return 0x820A87A4;
		  /* 820A87A4h */ case    3:  		/* b 956 */
		/* 820A87A4h case    3:*/		return 0x820A8B60;
		/* 820A87A4h case    3:*/		return 0x820A87A8;
	}
	return 0x820A87A8;
} // Block from 820A8798h-820A87A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A87A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A87A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A87A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A87A8);
		  /* 820A87A8h */ case    0:  		/* lis R10, -32255 */
		/* 820A87A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A87A8h case    0:*/		return 0x820A87AC;
		  /* 820A87ACh */ case    1:  		/* addi R11, R1, 80 */
		/* 820A87ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A87ACh case    1:*/		return 0x820A87B0;
		  /* 820A87B0h */ case    2:  		/* addi R10, R10, 2388 */
		/* 820A87B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x954);
		/* 820A87B0h case    2:*/		return 0x820A87B4;
		  /* 820A87B4h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A87B4h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A87B4h case    3:*/		return 0x820A87B8;
		  /* 820A87B8h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A87B8h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A87B8h case    4:*/		return 0x820A87BC;
		  /* 820A87BCh */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A87BCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A87BCh case    5:*/		return 0x820A87C0;
		  /* 820A87C0h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A87C0h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A87C0h case    6:*/		return 0x820A87C4;
		  /* 820A87C4h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A87C4h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A87D8;  }
		/* 820A87C4h case    7:*/		return 0x820A87C8;
		  /* 820A87C8h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A87C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A87C8h case    8:*/		return 0x820A87CC;
		  /* 820A87CCh */ case    9:  		/* addi R10, R10, 1 */
		/* 820A87CCh case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A87CCh case    9:*/		return 0x820A87D0;
		  /* 820A87D0h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A87D0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A87D0h case   10:*/		return 0x820A87D4;
		  /* 820A87D4h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A87D4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A87B4;  }
		/* 820A87D4h case   11:*/		return 0x820A87D8;
	}
	return 0x820A87D8;
} // Block from 820A87A8h-820A87D8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A87D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A87D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A87D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A87D8);
		  /* 820A87D8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A87D8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A87D8h case    0:*/		return 0x820A87DC;
		  /* 820A87DCh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A87DCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A87E8;  }
		/* 820A87DCh case    1:*/		return 0x820A87E0;
		  /* 820A87E0h */ case    2:  		/* li R11, 3 */
		/* 820A87E0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820A87E0h case    2:*/		return 0x820A87E4;
		  /* 820A87E4h */ case    3:  		/* b 892 */
		/* 820A87E4h case    3:*/		return 0x820A8B60;
		/* 820A87E4h case    3:*/		return 0x820A87E8;
	}
	return 0x820A87E8;
} // Block from 820A87D8h-820A87E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A87E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A87E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A87E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A87E8);
		  /* 820A87E8h */ case    0:  		/* lis R10, -32255 */
		/* 820A87E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A87E8h case    0:*/		return 0x820A87EC;
		  /* 820A87ECh */ case    1:  		/* addi R11, R1, 80 */
		/* 820A87ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A87ECh case    1:*/		return 0x820A87F0;
		  /* 820A87F0h */ case    2:  		/* addi R10, R10, 2380 */
		/* 820A87F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x94C);
		/* 820A87F0h case    2:*/		return 0x820A87F4;
		  /* 820A87F4h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A87F4h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A87F4h case    3:*/		return 0x820A87F8;
		  /* 820A87F8h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A87F8h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A87F8h case    4:*/		return 0x820A87FC;
		  /* 820A87FCh */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A87FCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A87FCh case    5:*/		return 0x820A8800;
		  /* 820A8800h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8800h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8800h case    6:*/		return 0x820A8804;
		  /* 820A8804h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8804h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8818;  }
		/* 820A8804h case    7:*/		return 0x820A8808;
		  /* 820A8808h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8808h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8808h case    8:*/		return 0x820A880C;
		  /* 820A880Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820A880Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A880Ch case    9:*/		return 0x820A8810;
		  /* 820A8810h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8810h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8810h case   10:*/		return 0x820A8814;
		  /* 820A8814h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8814h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A87F4;  }
		/* 820A8814h case   11:*/		return 0x820A8818;
	}
	return 0x820A8818;
} // Block from 820A87E8h-820A8818h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8818);
		  /* 820A8818h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8818h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8818h case    0:*/		return 0x820A881C;
		  /* 820A881Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A881Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8828;  }
		/* 820A881Ch case    1:*/		return 0x820A8820;
		  /* 820A8820h */ case    2:  		/* li R11, 4 */
		/* 820A8820h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820A8820h case    2:*/		return 0x820A8824;
		  /* 820A8824h */ case    3:  		/* b 828 */
		/* 820A8824h case    3:*/		return 0x820A8B60;
		/* 820A8824h case    3:*/		return 0x820A8828;
	}
	return 0x820A8828;
} // Block from 820A8818h-820A8828h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8828);
		  /* 820A8828h */ case    0:  		/* lis R10, -32255 */
		/* 820A8828h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A8828h case    0:*/		return 0x820A882C;
		  /* 820A882Ch */ case    1:  		/* addi R11, R1, 80 */
		/* 820A882Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A882Ch case    1:*/		return 0x820A8830;
		  /* 820A8830h */ case    2:  		/* addi R10, R10, 2368 */
		/* 820A8830h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x940);
		/* 820A8830h case    2:*/		return 0x820A8834;
		  /* 820A8834h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A8834h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8834h case    3:*/		return 0x820A8838;
		  /* 820A8838h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A8838h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8838h case    4:*/		return 0x820A883C;
		  /* 820A883Ch */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A883Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A883Ch case    5:*/		return 0x820A8840;
		  /* 820A8840h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8840h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8840h case    6:*/		return 0x820A8844;
		  /* 820A8844h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8844h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8858;  }
		/* 820A8844h case    7:*/		return 0x820A8848;
		  /* 820A8848h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8848h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8848h case    8:*/		return 0x820A884C;
		  /* 820A884Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820A884Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A884Ch case    9:*/		return 0x820A8850;
		  /* 820A8850h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8850h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8850h case   10:*/		return 0x820A8854;
		  /* 820A8854h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8854h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A8834;  }
		/* 820A8854h case   11:*/		return 0x820A8858;
	}
	return 0x820A8858;
} // Block from 820A8828h-820A8858h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8858);
		  /* 820A8858h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8858h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8858h case    0:*/		return 0x820A885C;
		  /* 820A885Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A885Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8868;  }
		/* 820A885Ch case    1:*/		return 0x820A8860;
		  /* 820A8860h */ case    2:  		/* li R11, 5 */
		/* 820A8860h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820A8860h case    2:*/		return 0x820A8864;
		  /* 820A8864h */ case    3:  		/* b 764 */
		/* 820A8864h case    3:*/		return 0x820A8B60;
		/* 820A8864h case    3:*/		return 0x820A8868;
	}
	return 0x820A8868;
} // Block from 820A8858h-820A8868h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8868);
		  /* 820A8868h */ case    0:  		/* lis R10, -32255 */
		/* 820A8868h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A8868h case    0:*/		return 0x820A886C;
		  /* 820A886Ch */ case    1:  		/* addi R11, R1, 80 */
		/* 820A886Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A886Ch case    1:*/		return 0x820A8870;
		  /* 820A8870h */ case    2:  		/* addi R10, R10, 2360 */
		/* 820A8870h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x938);
		/* 820A8870h case    2:*/		return 0x820A8874;
		  /* 820A8874h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A8874h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8874h case    3:*/		return 0x820A8878;
		  /* 820A8878h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A8878h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8878h case    4:*/		return 0x820A887C;
		  /* 820A887Ch */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A887Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A887Ch case    5:*/		return 0x820A8880;
		  /* 820A8880h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8880h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8880h case    6:*/		return 0x820A8884;
		  /* 820A8884h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8884h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8898;  }
		/* 820A8884h case    7:*/		return 0x820A8888;
		  /* 820A8888h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8888h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8888h case    8:*/		return 0x820A888C;
		  /* 820A888Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820A888Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A888Ch case    9:*/		return 0x820A8890;
		  /* 820A8890h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8890h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8890h case   10:*/		return 0x820A8894;
		  /* 820A8894h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8894h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A8874;  }
		/* 820A8894h case   11:*/		return 0x820A8898;
	}
	return 0x820A8898;
} // Block from 820A8868h-820A8898h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8898);
		  /* 820A8898h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8898h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8898h case    0:*/		return 0x820A889C;
		  /* 820A889Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A889Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A88A8;  }
		/* 820A889Ch case    1:*/		return 0x820A88A0;
		  /* 820A88A0h */ case    2:  		/* li R11, 6 */
		/* 820A88A0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820A88A0h case    2:*/		return 0x820A88A4;
		  /* 820A88A4h */ case    3:  		/* b 700 */
		/* 820A88A4h case    3:*/		return 0x820A8B60;
		/* 820A88A4h case    3:*/		return 0x820A88A8;
	}
	return 0x820A88A8;
} // Block from 820A8898h-820A88A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A88A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A88A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A88A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A88A8);
		  /* 820A88A8h */ case    0:  		/* lis R10, -32255 */
		/* 820A88A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A88A8h case    0:*/		return 0x820A88AC;
		  /* 820A88ACh */ case    1:  		/* addi R11, R1, 80 */
		/* 820A88ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A88ACh case    1:*/		return 0x820A88B0;
		  /* 820A88B0h */ case    2:  		/* addi R10, R10, 2348 */
		/* 820A88B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x92C);
		/* 820A88B0h case    2:*/		return 0x820A88B4;
		  /* 820A88B4h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A88B4h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A88B4h case    3:*/		return 0x820A88B8;
		  /* 820A88B8h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A88B8h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A88B8h case    4:*/		return 0x820A88BC;
		  /* 820A88BCh */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A88BCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A88BCh case    5:*/		return 0x820A88C0;
		  /* 820A88C0h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A88C0h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A88C0h case    6:*/		return 0x820A88C4;
		  /* 820A88C4h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A88C4h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A88D8;  }
		/* 820A88C4h case    7:*/		return 0x820A88C8;
		  /* 820A88C8h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A88C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A88C8h case    8:*/		return 0x820A88CC;
		  /* 820A88CCh */ case    9:  		/* addi R10, R10, 1 */
		/* 820A88CCh case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A88CCh case    9:*/		return 0x820A88D0;
		  /* 820A88D0h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A88D0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A88D0h case   10:*/		return 0x820A88D4;
		  /* 820A88D4h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A88D4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A88B4;  }
		/* 820A88D4h case   11:*/		return 0x820A88D8;
	}
	return 0x820A88D8;
} // Block from 820A88A8h-820A88D8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A88D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A88D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A88D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A88D8);
		  /* 820A88D8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A88D8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A88D8h case    0:*/		return 0x820A88DC;
		  /* 820A88DCh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A88DCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A88E8;  }
		/* 820A88DCh case    1:*/		return 0x820A88E0;
		  /* 820A88E0h */ case    2:  		/* li R11, 7 */
		/* 820A88E0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820A88E0h case    2:*/		return 0x820A88E4;
		  /* 820A88E4h */ case    3:  		/* b 636 */
		/* 820A88E4h case    3:*/		return 0x820A8B60;
		/* 820A88E4h case    3:*/		return 0x820A88E8;
	}
	return 0x820A88E8;
} // Block from 820A88D8h-820A88E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A88E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A88E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A88E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A88E8);
		  /* 820A88E8h */ case    0:  		/* lis R10, -32255 */
		/* 820A88E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A88E8h case    0:*/		return 0x820A88EC;
		  /* 820A88ECh */ case    1:  		/* addi R11, R1, 80 */
		/* 820A88ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A88ECh case    1:*/		return 0x820A88F0;
		  /* 820A88F0h */ case    2:  		/* addi R10, R10, 2336 */
		/* 820A88F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x920);
		/* 820A88F0h case    2:*/		return 0x820A88F4;
		  /* 820A88F4h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A88F4h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A88F4h case    3:*/		return 0x820A88F8;
		  /* 820A88F8h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A88F8h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A88F8h case    4:*/		return 0x820A88FC;
		  /* 820A88FCh */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A88FCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A88FCh case    5:*/		return 0x820A8900;
		  /* 820A8900h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8900h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8900h case    6:*/		return 0x820A8904;
		  /* 820A8904h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8904h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8918;  }
		/* 820A8904h case    7:*/		return 0x820A8908;
		  /* 820A8908h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8908h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8908h case    8:*/		return 0x820A890C;
		  /* 820A890Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820A890Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A890Ch case    9:*/		return 0x820A8910;
		  /* 820A8910h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8910h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8910h case   10:*/		return 0x820A8914;
		  /* 820A8914h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8914h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A88F4;  }
		/* 820A8914h case   11:*/		return 0x820A8918;
	}
	return 0x820A8918;
} // Block from 820A88E8h-820A8918h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8918);
		  /* 820A8918h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8918h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8918h case    0:*/		return 0x820A891C;
		  /* 820A891Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A891Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8928;  }
		/* 820A891Ch case    1:*/		return 0x820A8920;
		  /* 820A8920h */ case    2:  		/* li R11, 8 */
		/* 820A8920h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820A8920h case    2:*/		return 0x820A8924;
		  /* 820A8924h */ case    3:  		/* b 572 */
		/* 820A8924h case    3:*/		return 0x820A8B60;
		/* 820A8924h case    3:*/		return 0x820A8928;
	}
	return 0x820A8928;
} // Block from 820A8918h-820A8928h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8928);
		  /* 820A8928h */ case    0:  		/* lis R10, -32255 */
		/* 820A8928h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A8928h case    0:*/		return 0x820A892C;
		  /* 820A892Ch */ case    1:  		/* addi R11, R1, 80 */
		/* 820A892Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A892Ch case    1:*/		return 0x820A8930;
		  /* 820A8930h */ case    2:  		/* addi R10, R10, 2324 */
		/* 820A8930h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x914);
		/* 820A8930h case    2:*/		return 0x820A8934;
		  /* 820A8934h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A8934h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8934h case    3:*/		return 0x820A8938;
		  /* 820A8938h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A8938h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8938h case    4:*/		return 0x820A893C;
		  /* 820A893Ch */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A893Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A893Ch case    5:*/		return 0x820A8940;
		  /* 820A8940h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8940h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8940h case    6:*/		return 0x820A8944;
		  /* 820A8944h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8944h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8958;  }
		/* 820A8944h case    7:*/		return 0x820A8948;
		  /* 820A8948h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8948h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8948h case    8:*/		return 0x820A894C;
		  /* 820A894Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820A894Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A894Ch case    9:*/		return 0x820A8950;
		  /* 820A8950h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8950h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8950h case   10:*/		return 0x820A8954;
		  /* 820A8954h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8954h case   11:*/		if ( regs.CR[6].eq ) { return 0x820A8934;  }
		/* 820A8954h case   11:*/		return 0x820A8958;
	}
	return 0x820A8958;
} // Block from 820A8928h-820A8958h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8958);
		  /* 820A8958h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8958h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8958h case    0:*/		return 0x820A895C;
		  /* 820A895Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A895Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8968;  }
		/* 820A895Ch case    1:*/		return 0x820A8960;
		  /* 820A8960h */ case    2:  		/* li R11, 9 */
		/* 820A8960h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 820A8960h case    2:*/		return 0x820A8964;
		  /* 820A8964h */ case    3:  		/* b 508 */
		/* 820A8964h case    3:*/		return 0x820A8B60;
		/* 820A8964h case    3:*/		return 0x820A8968;
	}
	return 0x820A8968;
} // Block from 820A8958h-820A8968h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8968);
		  /* 820A8968h */ case    0:  		/* lis R10, -32255 */
		/* 820A8968h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A8968h case    0:*/		return 0x820A896C;
		  /* 820A896Ch */ case    1:  		/* addi R11, R1, 80 */
		/* 820A896Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A896Ch case    1:*/		return 0x820A8970;
		  /* 820A8970h */ case    2:  		/* addi R10, R10, 2316 */
		/* 820A8970h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x90C);
		/* 820A8970h case    2:*/		return 0x820A8974;
		  /* 820A8974h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A8974h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8974h case    3:*/		return 0x820A8978;
		  /* 820A8978h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A8978h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8978h case    4:*/		return 0x820A897C;
		  /* 820A897Ch */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A897Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A897Ch case    5:*/		return 0x820A8980;
		  /* 820A8980h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8980h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8980h case    6:*/		return 0x820A8984;
		  /* 820A8984h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8984h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8998;  }
		/* 820A8984h case    7:*/		return 0x820A8988;
	}
	return 0x820A8988;
} // Block from 820A8968h-820A8988h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A8988h
// Function '?LexChar@CTokenize@D3DXShader@@IAAIPBDPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8988);
		  /* 820A8988h */ case    0:  		/* addi R11, R11, 1 */
		/* 820A8988h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8988h case    0:*/		return 0x820A898C;
		  /* 820A898Ch */ case    1:  		/* addi R10, R10, 1 */
		/* 820A898Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A898Ch case    1:*/		return 0x820A8990;
		  /* 820A8990h */ case    2:  		/* cmpwi CR6, R9, 0 */
		/* 820A8990h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8990h case    2:*/		return 0x820A8994;
		  /* 820A8994h */ case    3:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8994h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A8974;  }
		/* 820A8994h case    3:*/		return 0x820A8998;
	}
	return 0x820A8998;
} // Block from 820A8988h-820A8998h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8998);
		  /* 820A8998h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8998h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8998h case    0:*/		return 0x820A899C;
		  /* 820A899Ch */ case    1:  		/* bc 12, CR0_EQ, 448 */
		/* 820A899Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820A8B5C;  }
		/* 820A899Ch case    1:*/		return 0x820A89A0;
		  /* 820A89A0h */ case    2:  		/* lis R10, -32255 */
		/* 820A89A0h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A89A0h case    2:*/		return 0x820A89A4;
		  /* 820A89A4h */ case    3:  		/* addi R11, R1, 80 */
		/* 820A89A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A89A4h case    3:*/		return 0x820A89A8;
		  /* 820A89A8h */ case    4:  		/* addi R10, R10, 2312 */
		/* 820A89A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x908);
		/* 820A89A8h case    4:*/		return 0x820A89AC;
		  /* 820A89ACh */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820A89ACh case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A89ACh case    5:*/		return 0x820A89B0;
		  /* 820A89B0h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820A89B0h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A89B0h case    6:*/		return 0x820A89B4;
		  /* 820A89B4h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820A89B4h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A89B4h case    7:*/		return 0x820A89B8;
		  /* 820A89B8h */ case    8:  		/* subf R9, R8, R9 */
		/* 820A89B8h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A89B8h case    8:*/		return 0x820A89BC;
		  /* 820A89BCh */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820A89BCh case    9:*/		if ( regs.CR[0].eq ) { return 0x820A89D0;  }
		/* 820A89BCh case    9:*/		return 0x820A89C0;
		  /* 820A89C0h */ case   10:  		/* addi R11, R11, 1 */
		/* 820A89C0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A89C0h case   10:*/		return 0x820A89C4;
		  /* 820A89C4h */ case   11:  		/* addi R10, R10, 1 */
		/* 820A89C4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A89C4h case   11:*/		return 0x820A89C8;
		  /* 820A89C8h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820A89C8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A89C8h case   12:*/		return 0x820A89CC;
		  /* 820A89CCh */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820A89CCh case   13:*/		if ( regs.CR[6].eq ) { return 0x820A89AC;  }
		/* 820A89CCh case   13:*/		return 0x820A89D0;
	}
	return 0x820A89D0;
} // Block from 820A8998h-820A89D0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A89D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A89D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A89D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A89D0);
		  /* 820A89D0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A89D0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A89D0h case    0:*/		return 0x820A89D4;
		  /* 820A89D4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A89D4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A89E0;  }
		/* 820A89D4h case    1:*/		return 0x820A89D8;
		  /* 820A89D8h */ case    2:  		/* li R11, 11 */
		/* 820A89D8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 820A89D8h case    2:*/		return 0x820A89DC;
		  /* 820A89DCh */ case    3:  		/* b 388 */
		/* 820A89DCh case    3:*/		return 0x820A8B60;
		/* 820A89DCh case    3:*/		return 0x820A89E0;
	}
	return 0x820A89E0;
} // Block from 820A89D0h-820A89E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A89E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A89E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A89E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A89E0);
		  /* 820A89E0h */ case    0:  		/* lis R10, -32255 */
		/* 820A89E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A89E0h case    0:*/		return 0x820A89E4;
		  /* 820A89E4h */ case    1:  		/* addi R11, R1, 80 */
		/* 820A89E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A89E4h case    1:*/		return 0x820A89E8;
		  /* 820A89E8h */ case    2:  		/* addi R10, R10, 2304 */
		/* 820A89E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x900);
		/* 820A89E8h case    2:*/		return 0x820A89EC;
		  /* 820A89ECh */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A89ECh case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A89ECh case    3:*/		return 0x820A89F0;
		  /* 820A89F0h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A89F0h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A89F0h case    4:*/		return 0x820A89F4;
		  /* 820A89F4h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A89F4h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A89F4h case    5:*/		return 0x820A89F8;
		  /* 820A89F8h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A89F8h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A89F8h case    6:*/		return 0x820A89FC;
		  /* 820A89FCh */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A89FCh case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8A10;  }
		/* 820A89FCh case    7:*/		return 0x820A8A00;
	}
	return 0x820A8A00;
} // Block from 820A89E0h-820A8A00h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A8A00h
// Function '?LexString@CTokenize@D3DXShader@@IAAIPBDPAPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8A00);
		  /* 820A8A00h */ case    0:  		/* addi R11, R11, 1 */
		/* 820A8A00h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8A00h case    0:*/		return 0x820A8A04;
		  /* 820A8A04h */ case    1:  		/* addi R10, R10, 1 */
		/* 820A8A04h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A8A04h case    1:*/		return 0x820A8A08;
		  /* 820A8A08h */ case    2:  		/* cmpwi CR6, R9, 0 */
		/* 820A8A08h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8A08h case    2:*/		return 0x820A8A0C;
		  /* 820A8A0Ch */ case    3:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8A0Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820A89EC;  }
		/* 820A8A0Ch case    3:*/		return 0x820A8A10;
	}
	return 0x820A8A10;
} // Block from 820A8A00h-820A8A10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8A10);
		  /* 820A8A10h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8A10h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8A10h case    0:*/		return 0x820A8A14;
		  /* 820A8A14h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A8A14h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8A20;  }
		/* 820A8A14h case    1:*/		return 0x820A8A18;
		  /* 820A8A18h */ case    2:  		/* li R11, 12 */
		/* 820A8A18h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820A8A18h case    2:*/		return 0x820A8A1C;
		  /* 820A8A1Ch */ case    3:  		/* b 324 */
		/* 820A8A1Ch case    3:*/		return 0x820A8B60;
		/* 820A8A1Ch case    3:*/		return 0x820A8A20;
	}
	return 0x820A8A20;
} // Block from 820A8A10h-820A8A20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8A20);
		  /* 820A8A20h */ case    0:  		/* lis R10, -32255 */
		/* 820A8A20h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A8A20h case    0:*/		return 0x820A8A24;
		  /* 820A8A24h */ case    1:  		/* addi R11, R1, 80 */
		/* 820A8A24h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A8A24h case    1:*/		return 0x820A8A28;
		  /* 820A8A28h */ case    2:  		/* addi R10, R10, 2296 */
		/* 820A8A28h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8F8);
		/* 820A8A28h case    2:*/		return 0x820A8A2C;
		  /* 820A8A2Ch */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A8A2Ch case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8A2Ch case    3:*/		return 0x820A8A30;
		  /* 820A8A30h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A8A30h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8A30h case    4:*/		return 0x820A8A34;
		  /* 820A8A34h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A8A34h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8A34h case    5:*/		return 0x820A8A38;
		  /* 820A8A38h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8A38h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8A38h case    6:*/		return 0x820A8A3C;
		  /* 820A8A3Ch */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8A3Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8A50;  }
		/* 820A8A3Ch case    7:*/		return 0x820A8A40;
		  /* 820A8A40h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8A40h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8A40h case    8:*/		return 0x820A8A44;
		  /* 820A8A44h */ case    9:  		/* addi R10, R10, 1 */
		/* 820A8A44h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A8A44h case    9:*/		return 0x820A8A48;
		  /* 820A8A48h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8A48h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8A48h case   10:*/		return 0x820A8A4C;
		  /* 820A8A4Ch */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8A4Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820A8A2C;  }
		/* 820A8A4Ch case   11:*/		return 0x820A8A50;
	}
	return 0x820A8A50;
} // Block from 820A8A20h-820A8A50h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8A50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8A50);
		  /* 820A8A50h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8A50h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8A50h case    0:*/		return 0x820A8A54;
		  /* 820A8A54h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A8A54h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8A60;  }
		/* 820A8A54h case    1:*/		return 0x820A8A58;
		  /* 820A8A58h */ case    2:  		/* li R11, 13 */
		/* 820A8A58h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 820A8A58h case    2:*/		return 0x820A8A5C;
		  /* 820A8A5Ch */ case    3:  		/* b 260 */
		/* 820A8A5Ch case    3:*/		return 0x820A8B60;
		/* 820A8A5Ch case    3:*/		return 0x820A8A60;
	}
	return 0x820A8A60;
} // Block from 820A8A50h-820A8A60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8A60);
		  /* 820A8A60h */ case    0:  		/* lis R10, -32255 */
		/* 820A8A60h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A8A60h case    0:*/		return 0x820A8A64;
		  /* 820A8A64h */ case    1:  		/* addi R11, R1, 80 */
		/* 820A8A64h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A8A64h case    1:*/		return 0x820A8A68;
		  /* 820A8A68h */ case    2:  		/* addi R10, R10, 2288 */
		/* 820A8A68h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8F0);
		/* 820A8A68h case    2:*/		return 0x820A8A6C;
		  /* 820A8A6Ch */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A8A6Ch case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8A6Ch case    3:*/		return 0x820A8A70;
		  /* 820A8A70h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A8A70h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8A70h case    4:*/		return 0x820A8A74;
		  /* 820A8A74h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A8A74h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8A74h case    5:*/		return 0x820A8A78;
		  /* 820A8A78h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8A78h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8A78h case    6:*/		return 0x820A8A7C;
		  /* 820A8A7Ch */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8A7Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8A90;  }
		/* 820A8A7Ch case    7:*/		return 0x820A8A80;
		  /* 820A8A80h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8A80h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8A80h case    8:*/		return 0x820A8A84;
		  /* 820A8A84h */ case    9:  		/* addi R10, R10, 1 */
		/* 820A8A84h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A8A84h case    9:*/		return 0x820A8A88;
		  /* 820A8A88h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8A88h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8A88h case   10:*/		return 0x820A8A8C;
		  /* 820A8A8Ch */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8A8Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820A8A6C;  }
		/* 820A8A8Ch case   11:*/		return 0x820A8A90;
	}
	return 0x820A8A90;
} // Block from 820A8A60h-820A8A90h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8A90);
		  /* 820A8A90h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8A90h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8A90h case    0:*/		return 0x820A8A94;
		  /* 820A8A94h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A8A94h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8AA0;  }
		/* 820A8A94h case    1:*/		return 0x820A8A98;
		  /* 820A8A98h */ case    2:  		/* li R11, 14 */
		/* 820A8A98h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xE);
		/* 820A8A98h case    2:*/		return 0x820A8A9C;
		  /* 820A8A9Ch */ case    3:  		/* b 196 */
		/* 820A8A9Ch case    3:*/		return 0x820A8B60;
		/* 820A8A9Ch case    3:*/		return 0x820A8AA0;
	}
	return 0x820A8AA0;
} // Block from 820A8A90h-820A8AA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8AA0);
		  /* 820A8AA0h */ case    0:  		/* lis R10, -32255 */
		/* 820A8AA0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A8AA0h case    0:*/		return 0x820A8AA4;
		  /* 820A8AA4h */ case    1:  		/* addi R11, R1, 80 */
		/* 820A8AA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A8AA4h case    1:*/		return 0x820A8AA8;
		  /* 820A8AA8h */ case    2:  		/* addi R10, R10, 2280 */
		/* 820A8AA8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8E8);
		/* 820A8AA8h case    2:*/		return 0x820A8AAC;
		  /* 820A8AACh */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A8AACh case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8AACh case    3:*/		return 0x820A8AB0;
		  /* 820A8AB0h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A8AB0h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8AB0h case    4:*/		return 0x820A8AB4;
		  /* 820A8AB4h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A8AB4h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8AB4h case    5:*/		return 0x820A8AB8;
		  /* 820A8AB8h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8AB8h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8AB8h case    6:*/		return 0x820A8ABC;
		  /* 820A8ABCh */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8ABCh case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8AD0;  }
		/* 820A8ABCh case    7:*/		return 0x820A8AC0;
		  /* 820A8AC0h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8AC0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8AC0h case    8:*/		return 0x820A8AC4;
		  /* 820A8AC4h */ case    9:  		/* addi R10, R10, 1 */
		/* 820A8AC4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A8AC4h case    9:*/		return 0x820A8AC8;
		  /* 820A8AC8h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8AC8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8AC8h case   10:*/		return 0x820A8ACC;
		  /* 820A8ACCh */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8ACCh case   11:*/		if ( regs.CR[6].eq ) { return 0x820A8AAC;  }
		/* 820A8ACCh case   11:*/		return 0x820A8AD0;
	}
	return 0x820A8AD0;
} // Block from 820A8AA0h-820A8AD0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8AD0);
		  /* 820A8AD0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8AD0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8AD0h case    0:*/		return 0x820A8AD4;
		  /* 820A8AD4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A8AD4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8AE0;  }
		/* 820A8AD4h case    1:*/		return 0x820A8AD8;
		  /* 820A8AD8h */ case    2:  		/* li R11, 15 */
		/* 820A8AD8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xF);
		/* 820A8AD8h case    2:*/		return 0x820A8ADC;
		  /* 820A8ADCh */ case    3:  		/* b 132 */
		/* 820A8ADCh case    3:*/		return 0x820A8B60;
		/* 820A8ADCh case    3:*/		return 0x820A8AE0;
	}
	return 0x820A8AE0;
} // Block from 820A8AD0h-820A8AE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8AE0);
		  /* 820A8AE0h */ case    0:  		/* lis R10, -32255 */
		/* 820A8AE0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A8AE0h case    0:*/		return 0x820A8AE4;
		  /* 820A8AE4h */ case    1:  		/* addi R11, R1, 80 */
		/* 820A8AE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A8AE4h case    1:*/		return 0x820A8AE8;
		  /* 820A8AE8h */ case    2:  		/* addi R10, R10, 2272 */
		/* 820A8AE8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8E0);
		/* 820A8AE8h case    2:*/		return 0x820A8AEC;
		  /* 820A8AECh */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A8AECh case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8AECh case    3:*/		return 0x820A8AF0;
		  /* 820A8AF0h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A8AF0h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8AF0h case    4:*/		return 0x820A8AF4;
		  /* 820A8AF4h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A8AF4h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8AF4h case    5:*/		return 0x820A8AF8;
		  /* 820A8AF8h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8AF8h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8AF8h case    6:*/		return 0x820A8AFC;
		  /* 820A8AFCh */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8AFCh case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8B10;  }
		/* 820A8AFCh case    7:*/		return 0x820A8B00;
		  /* 820A8B00h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8B00h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8B00h case    8:*/		return 0x820A8B04;
		  /* 820A8B04h */ case    9:  		/* addi R10, R10, 1 */
		/* 820A8B04h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A8B04h case    9:*/		return 0x820A8B08;
		  /* 820A8B08h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8B08h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8B08h case   10:*/		return 0x820A8B0C;
		  /* 820A8B0Ch */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8B0Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820A8AEC;  }
		/* 820A8B0Ch case   11:*/		return 0x820A8B10;
	}
	return 0x820A8B10;
} // Block from 820A8AE0h-820A8B10h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8B10);
		  /* 820A8B10h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8B10h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8B10h case    0:*/		return 0x820A8B14;
		  /* 820A8B14h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820A8B14h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A8B20;  }
		/* 820A8B14h case    1:*/		return 0x820A8B18;
		  /* 820A8B18h */ case    2:  		/* mr R27, R28 */
		/* 820A8B18h case    2:*/		regs.R27 = regs.R28;
		/* 820A8B18h case    2:*/		return 0x820A8B1C;
		  /* 820A8B1Ch */ case    3:  		/* b 64 */
		/* 820A8B1Ch case    3:*/		return 0x820A8B5C;
		/* 820A8B1Ch case    3:*/		return 0x820A8B20;
	}
	return 0x820A8B20;
} // Block from 820A8B10h-820A8B20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8B20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8B20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8B20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8B20);
		  /* 820A8B20h */ case    0:  		/* lis R10, -32255 */
		/* 820A8B20h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A8B20h case    0:*/		return 0x820A8B24;
		  /* 820A8B24h */ case    1:  		/* addi R11, R1, 80 */
		/* 820A8B24h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820A8B24h case    1:*/		return 0x820A8B28;
		  /* 820A8B28h */ case    2:  		/* addi R10, R10, 2260 */
		/* 820A8B28h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8D4);
		/* 820A8B28h case    2:*/		return 0x820A8B2C;
		  /* 820A8B2Ch */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820A8B2Ch case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A8B2Ch case    3:*/		return 0x820A8B30;
		  /* 820A8B30h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820A8B30h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A8B30h case    4:*/		return 0x820A8B34;
		  /* 820A8B34h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820A8B34h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8B34h case    5:*/		return 0x820A8B38;
		  /* 820A8B38h */ case    6:  		/* subf R9, R8, R9 */
		/* 820A8B38h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A8B38h case    6:*/		return 0x820A8B3C;
		  /* 820A8B3Ch */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820A8B3Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8B50;  }
		/* 820A8B3Ch case    7:*/		return 0x820A8B40;
		  /* 820A8B40h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A8B40h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8B40h case    8:*/		return 0x820A8B44;
		  /* 820A8B44h */ case    9:  		/* addi R10, R10, 1 */
		/* 820A8B44h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A8B44h case    9:*/		return 0x820A8B48;
		  /* 820A8B48h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820A8B48h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A8B48h case   10:*/		return 0x820A8B4C;
		  /* 820A8B4Ch */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820A8B4Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820A8B2C;  }
		/* 820A8B4Ch case   11:*/		return 0x820A8B50;
	}
	return 0x820A8B50;
} // Block from 820A8B20h-820A8B50h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8B50);
		  /* 820A8B50h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A8B50h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A8B50h case    0:*/		return 0x820A8B54;
		  /* 820A8B54h */ case    1:  		/* bc 4, CR0_EQ, -1288 */
		/* 820A8B54h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A864C;  }
		/* 820A8B54h case    1:*/		return 0x820A8B58;
		  /* 820A8B58h */ case    2:  		/* li R27, 1 */
		/* 820A8B58h case    2:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820A8B58h case    2:*/		return 0x820A8B5C;
	}
	return 0x820A8B5C;
} // Block from 820A8B50h-820A8B5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A8B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8B5C);
		  /* 820A8B5Ch */ case    0:  		/* li R11, 10 */
		/* 820A8B5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 820A8B5Ch case    0:*/		return 0x820A8B60;
	}
	return 0x820A8B60;
} // Block from 820A8B5Ch-820A8B60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A8B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8B60);
		  /* 820A8B60h */ case    0:  		/* stb R11, <#[R26]> */
		/* 820A8B60h case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820A8B60h case    0:*/		return 0x820A8B64;
		  /* 820A8B64h */ case    1:  		/* li R3, 0 */
		/* 820A8B64h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A8B64h case    1:*/		return 0x820A8B68;
		  /* 820A8B68h */ case    2:  		/* stb R27, <#[R25]> */
		/* 820A8B68h case    2:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R25 + 0x00000000) );
		/* 820A8B68h case    2:*/		return 0x820A8B6C;
		  /* 820A8B6Ch */ case    3:  		/* b -1304 */
		/* 820A8B6Ch case    3:*/		return 0x820A8654;
		/* 820A8B6Ch case    3:*/		return 0x820A8B70;
	}
	return 0x820A8B70;
} // Block from 820A8B60h-820A8B70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A8B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8B70);
		  /* 820A8B70h */ case    0:  		/* mfspr R12, LR */
		/* 820A8B70h case    0:*/		regs.R12 = regs.LR;
		/* 820A8B70h case    0:*/		return 0x820A8B74;
		  /* 820A8B74h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A8B74h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8B74h case    1:*/		return 0x820A8B78;
		  /* 820A8B78h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A8B78h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A8B78h case    2:*/		return 0x820A8B7C;
		  /* 820A8B7Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A8B7Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A8B7Ch case    3:*/		return 0x820A8B80;
		  /* 820A8B80h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A8B80h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A8B80h case    4:*/		return 0x820A8B84;
		  /* 820A8B84h */ case    5:  		/* mr R31, R3 */
		/* 820A8B84h case    5:*/		regs.R31 = regs.R3;
		/* 820A8B84h case    5:*/		return 0x820A8B88;
		  /* 820A8B88h */ case    6:  		/* li R30, 0 */
		/* 820A8B88h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820A8B88h case    6:*/		return 0x820A8B8C;
		  /* 820A8B8Ch */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 820A8B8Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A8B8Ch case    7:*/		return 0x820A8B90;
		  /* 820A8B90h */ case    8:  		/* bc 12, CR6_EQ, 64 */
		/* 820A8B90h case    8:*/		if ( regs.CR[6].eq ) { return 0x820A8BD0;  }
		/* 820A8B90h case    8:*/		return 0x820A8B94;
		  /* 820A8B94h */ case    9:  		/* lbz R11, <#[R3]> */
		/* 820A8B94h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A8B94h case    9:*/		return 0x820A8B98;
		  /* 820A8B98h */ case   10:  		/* extsb. R11, R11 */
		/* 820A8B98h case   10:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R11);
		/* 820A8B98h case   10:*/		return 0x820A8B9C;
		  /* 820A8B9Ch */ case   11:  		/* bc 12, CR0_EQ, 52 */
		/* 820A8B9Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x820A8BD0;  }
		/* 820A8B9Ch case   11:*/		return 0x820A8BA0;
		  /* 820A8BA0h */ case   12:  		/* mr R3, R11 */
		/* 820A8BA0h case   12:*/		regs.R3 = regs.R11;
		/* 820A8BA0h case   12:*/		return 0x820A8BA4;
		  /* 820A8BA4h */ case   13:  		/* bl 1831708 */
		/* 820A8BA4h case   13:*/		regs.LR = 0x820A8BA8; return 0x82267EC0;
		/* 820A8BA4h case   13:*/		return 0x820A8BA8;
		  /* 820A8BA8h */ case   14:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820A8BA8h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820A8BA8h case   14:*/		return 0x820A8BAC;
		  /* 820A8BACh */ case   15:  		/* mulli R10, R30, 19 */
		/* 820A8BACh case   15:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R30,0x13);
		/* 820A8BACh case   15:*/		return 0x820A8BB0;
		  /* 820A8BB0h */ case   16:  		/* extsb. R11, R11 */
		/* 820A8BB0h case   16:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R11);
		/* 820A8BB0h case   16:*/		return 0x820A8BB4;
		  /* 820A8BB4h */ case   17:  		/* add R30, R3, R10 */
		/* 820A8BB4h case   17:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R10);
		/* 820A8BB4h case   17:*/		return 0x820A8BB8;
		  /* 820A8BB8h */ case   18:  		/* bc 4, CR0_EQ, -24 */
		/* 820A8BB8h case   18:*/		if ( !regs.CR[0].eq ) { return 0x820A8BA0;  }
		/* 820A8BB8h case   18:*/		return 0x820A8BBC;
		  /* 820A8BBCh */ case   19:  		/* li R11, 7 */
		/* 820A8BBCh case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820A8BBCh case   19:*/		return 0x820A8BC0;
		  /* 820A8BC0h */ case   20:  		/* divwu R11, R30, R11 */
		/* 820A8BC0h case   20:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 820A8BC0h case   20:*/		return 0x820A8BC4;
		  /* 820A8BC4h */ case   21:  		/* mulli R11, R11, 7 */
		/* 820A8BC4h case   21:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x7);
		/* 820A8BC4h case   21:*/		return 0x820A8BC8;
		  /* 820A8BC8h */ case   22:  		/* subf R3, R11, R30 */
		/* 820A8BC8h case   22:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 820A8BC8h case   22:*/		return 0x820A8BCC;
		  /* 820A8BCCh */ case   23:  		/* b 8 */
		/* 820A8BCCh case   23:*/		return 0x820A8BD4;
		/* 820A8BCCh case   23:*/		return 0x820A8BD0;
	}
	return 0x820A8BD0;
} // Block from 820A8B70h-820A8BD0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820A8BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8BD0);
		  /* 820A8BD0h */ case    0:  		/* li R3, 0 */
		/* 820A8BD0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A8BD0h case    0:*/		return 0x820A8BD4;
	}
	return 0x820A8BD4;
} // Block from 820A8BD0h-820A8BD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A8BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8BD4);
		  /* 820A8BD4h */ case    0:  		/* addi R1, R1, 112 */
		/* 820A8BD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A8BD4h case    0:*/		return 0x820A8BD8;
		  /* 820A8BD8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A8BD8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8BD8h case    1:*/		return 0x820A8BDC;
		  /* 820A8BDCh */ case    2:  		/* mtspr LR, R12 */
		/* 820A8BDCh case    2:*/		regs.LR = regs.R12;
		/* 820A8BDCh case    2:*/		return 0x820A8BE0;
		  /* 820A8BE0h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820A8BE0h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A8BE0h case    3:*/		return 0x820A8BE4;
		  /* 820A8BE4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820A8BE4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A8BE4h case    4:*/		return 0x820A8BE8;
		  /* 820A8BE8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820A8BE8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A8BE8h case    5:*/		return 0x820A8BEC;
	}
	return 0x820A8BEC;
} // Block from 820A8BD4h-820A8BECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A8BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8BEC);
		  /* 820A8BECh */ case    0:  		/* nop */
		/* 820A8BECh case    0:*/		cpu::op::nop();
		/* 820A8BECh case    0:*/		return 0x820A8BF0;
	}
	return 0x820A8BF0;
} // Block from 820A8BECh-820A8BF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A8BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8BF0);
		  /* 820A8BF0h */ case    0:  		/* mfspr R12, LR */
		/* 820A8BF0h case    0:*/		regs.R12 = regs.LR;
		/* 820A8BF0h case    0:*/		return 0x820A8BF4;
		  /* 820A8BF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A8BF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8BF4h case    1:*/		return 0x820A8BF8;
		  /* 820A8BF8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A8BF8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A8BF8h case    2:*/		return 0x820A8BFC;
		  /* 820A8BFCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A8BFCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A8BFCh case    3:*/		return 0x820A8C00;
		  /* 820A8C00h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A8C00h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A8C00h case    4:*/		return 0x820A8C04;
		  /* 820A8C04h */ case    5:  		/* mr R31, R3 */
		/* 820A8C04h case    5:*/		regs.R31 = regs.R3;
		/* 820A8C04h case    5:*/		return 0x820A8C08;
		  /* 820A8C08h */ case    6:  		/* mr R3, R4 */
		/* 820A8C08h case    6:*/		regs.R3 = regs.R4;
		/* 820A8C08h case    6:*/		return 0x820A8C0C;
		  /* 820A8C0Ch */ case    7:  		/* mr R30, R4 */
		/* 820A8C0Ch case    7:*/		regs.R30 = regs.R4;
		/* 820A8C0Ch case    7:*/		return 0x820A8C10;
		  /* 820A8C10h */ case    8:  		/* bl -160 */
		/* 820A8C10h case    8:*/		regs.LR = 0x820A8C14; return 0x820A8B70;
		/* 820A8C10h case    8:*/		return 0x820A8C14;
		  /* 820A8C14h */ case    9:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 820A8C14h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 820A8C14h case    9:*/		return 0x820A8C18;
		  /* 820A8C18h */ case   10:  		/* lwzx R31, <#[R11 + R31]> */
		/* 820A8C18h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820A8C18h case   10:*/		return 0x820A8C1C;
		  /* 820A8C1Ch */ case   11:  		/* b 28 */
		/* 820A8C1Ch case   11:*/		return 0x820A8C38;
		/* 820A8C1Ch case   11:*/		return 0x820A8C20;
	}
	return 0x820A8C20;
} // Block from 820A8BF0h-820A8C20h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8C20h
// Function '?GetToken@CTokenize@D3DXShader@@QAAJIPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8C20);
		  /* 820A8C20h */ case    0:  		/* mr R4, R30 */
		/* 820A8C20h case    0:*/		regs.R4 = regs.R30;
		/* 820A8C20h case    0:*/		return 0x820A8C24;
		  /* 820A8C24h */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820A8C24h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8C24h case    1:*/		return 0x820A8C28;
		  /* 820A8C28h */ case    2:  		/* bl 1829352 */
		/* 820A8C28h case    2:*/		regs.LR = 0x820A8C2C; return 0x82267610;
		/* 820A8C28h case    2:*/		return 0x820A8C2C;
		  /* 820A8C2Ch */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820A8C2Ch case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A8C2Ch case    3:*/		return 0x820A8C30;
		  /* 820A8C30h */ case    4:  		/* bc 12, CR0_EQ, 44 */
		/* 820A8C30h case    4:*/		if ( regs.CR[0].eq ) { return 0x820A8C5C;  }
		/* 820A8C30h case    4:*/		return 0x820A8C34;
		  /* 820A8C34h */ case    5:  		/* lwz R31, <#[R31 + 32]> */
		/* 820A8C34h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000020) );
		/* 820A8C34h case    5:*/		return 0x820A8C38;
	}
	return 0x820A8C38;
} // Block from 820A8C20h-820A8C38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A8C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8C38);
		  /* 820A8C38h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820A8C38h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A8C38h case    0:*/		return 0x820A8C3C;
		  /* 820A8C3Ch */ case    1:  		/* bc 4, CR6_EQ, -28 */
		/* 820A8C3Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A8C20;  }
		/* 820A8C3Ch case    1:*/		return 0x820A8C40;
		  /* 820A8C40h */ case    2:  		/* li R3, 0 */
		/* 820A8C40h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A8C40h case    2:*/		return 0x820A8C44;
		  /* 820A8C44h */ case    3:  		/* addi R1, R1, 112 */
		/* 820A8C44h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A8C44h case    3:*/		return 0x820A8C48;
		  /* 820A8C48h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A8C48h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8C48h case    4:*/		return 0x820A8C4C;
		  /* 820A8C4Ch */ case    5:  		/* mtspr LR, R12 */
		/* 820A8C4Ch case    5:*/		regs.LR = regs.R12;
		/* 820A8C4Ch case    5:*/		return 0x820A8C50;
		  /* 820A8C50h */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 820A8C50h case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A8C50h case    6:*/		return 0x820A8C54;
		  /* 820A8C54h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 820A8C54h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A8C54h case    7:*/		return 0x820A8C58;
		  /* 820A8C58h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820A8C58h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A8C58h case    8:*/		return 0x820A8C5C;
	}
	return 0x820A8C5C;
} // Block from 820A8C38h-820A8C5Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A8C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8C5C);
		  /* 820A8C5Ch */ case    0:  		/* mr R3, R31 */
		/* 820A8C5Ch case    0:*/		regs.R3 = regs.R31;
		/* 820A8C5Ch case    0:*/		return 0x820A8C60;
		  /* 820A8C60h */ case    1:  		/* b -28 */
		/* 820A8C60h case    1:*/		return 0x820A8C44;
		/* 820A8C60h case    1:*/		return 0x820A8C64;
		  /* 820A8C64h */ case    2:  		/* nop */
		/* 820A8C64h case    2:*/		cpu::op::nop();
		/* 820A8C64h case    2:*/		return 0x820A8C68;
		  /* 820A8C68h */ case    3:  		/* li R10, 7 */
		/* 820A8C68h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x7);
		/* 820A8C68h case    3:*/		return 0x820A8C6C;
		  /* 820A8C6Ch */ case    4:  		/* li R11, 0 */
		/* 820A8C6Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A8C6Ch case    4:*/		return 0x820A8C70;
		  /* 820A8C70h */ case    5:  		/* mtspr CTR, R10 */
		/* 820A8C70h case    5:*/		regs.CTR = regs.R10;
		/* 820A8C70h case    5:*/		return 0x820A8C74;
		  /* 820A8C74h */ case    6:  		/* lwz R9, <#[R3]> */
		/* 820A8C74h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 820A8C74h case    6:*/		return 0x820A8C78;
		  /* 820A8C78h */ case    7:  		/* cmplwi CR6, R9, 0 */
		/* 820A8C78h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A8C78h case    7:*/		return 0x820A8C7C;
		  /* 820A8C7Ch */ case    8:  		/* bc 12, CR6_EQ, 36 */
		/* 820A8C7Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820A8CA0;  }
		/* 820A8C7Ch case    8:*/		return 0x820A8C80;
		  /* 820A8C80h */ case    9:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 820A8C80h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820A8C80h case    9:*/		return 0x820A8C84;
		  /* 820A8C84h */ case   10:  		/* add R10, R10, R4 */
		/* 820A8C84h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 820A8C84h case   10:*/		return 0x820A8C88;
		  /* 820A8C88h */ case   11:  		/* addi R10, R10, -4 */
		/* 820A8C88h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 820A8C88h case   11:*/		return 0x820A8C8C;
		  /* 820A8C8Ch */ case   12:  		/* stwu R9, <#[R10 + 4]> */
		/* 820A8C8Ch case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820A8C8Ch case   12:*/		return 0x820A8C90;
		  /* 820A8C90h */ case   13:  		/* addi R11, R11, 1 */
		/* 820A8C90h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A8C90h case   13:*/		return 0x820A8C94;
		  /* 820A8C94h */ case   14:  		/* lwz R9, <#[R9 + 32]> */
		/* 820A8C94h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000020) );
		/* 820A8C94h case   14:*/		return 0x820A8C98;
		  /* 820A8C98h */ case   15:  		/* cmplwi CR6, R9, 0 */
		/* 820A8C98h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A8C98h case   15:*/		return 0x820A8C9C;
		  /* 820A8C9Ch */ case   16:  		/* bc 4, CR6_EQ, -16 */
		/* 820A8C9Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x820A8C8C;  }
		/* 820A8C9Ch case   16:*/		return 0x820A8CA0;
	}
	return 0x820A8CA0;
} // Block from 820A8C5Ch-820A8CA0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A8CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8CA0);
		  /* 820A8CA0h */ case    0:  		/* addi R3, R3, 4 */
		/* 820A8CA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 820A8CA0h case    0:*/		return 0x820A8CA4;
		  /* 820A8CA4h */ case    1:  		/* bc 16, CR0_LT, -48 */
		/* 820A8CA4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820A8C74;  }
		/* 820A8CA4h case    1:*/		return 0x820A8CA8;
		  /* 820A8CA8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820A8CA8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A8CA8h case    2:*/		return 0x820A8CAC;
	}
	return 0x820A8CAC;
} // Block from 820A8CA0h-820A8CACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A8CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8CAC);
		  /* 820A8CACh */ case    0:  		/* nop */
		/* 820A8CACh case    0:*/		cpu::op::nop();
		/* 820A8CACh case    0:*/		return 0x820A8CB0;
		  /* 820A8CB0h */ case    1:  		/* li R11, 0 */
		/* 820A8CB0h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A8CB0h case    1:*/		return 0x820A8CB4;
		  /* 820A8CB4h */ case    2:  		/* stw R4, <#[R3 + 92]> */
		/* 820A8CB4h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x0000005C) );
		/* 820A8CB4h case    2:*/		return 0x820A8CB8;
		  /* 820A8CB8h */ case    3:  		/* stw R11, <#[R3]> */
		/* 820A8CB8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A8CB8h case    3:*/		return 0x820A8CBC;
		  /* 820A8CBCh */ case    4:  		/* stw R11, <#[R3 + 4]> */
		/* 820A8CBCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820A8CBCh case    4:*/		return 0x820A8CC0;
		  /* 820A8CC0h */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 820A8CC0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820A8CC0h case    5:*/		return 0x820A8CC4;
		  /* 820A8CC4h */ case    6:  		/* stw R11, <#[R3 + 60]> */
		/* 820A8CC4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 820A8CC4h case    6:*/		return 0x820A8CC8;
		  /* 820A8CC8h */ case    7:  		/* stw R11, <#[R3 + 100]> */
		/* 820A8CC8h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000064) );
		/* 820A8CC8h case    7:*/		return 0x820A8CCC;
		  /* 820A8CCCh */ case    8:  		/* stw R11, <#[R3 + 104]> */
		/* 820A8CCCh case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000068) );
		/* 820A8CCCh case    8:*/		return 0x820A8CD0;
		  /* 820A8CD0h */ case    9:  		/* stw R11, <#[R3 + 108]> */
		/* 820A8CD0h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 820A8CD0h case    9:*/		return 0x820A8CD4;
		  /* 820A8CD4h */ case   10:  		/* stw R11, <#[R3 + 132]> */
		/* 820A8CD4h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000084) );
		/* 820A8CD4h case   10:*/		return 0x820A8CD8;
		  /* 820A8CD8h */ case   11:  		/* bclr 20, CR0_LT */
		/* 820A8CD8h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A8CD8h case   11:*/		return 0x820A8CDC;
	}
	return 0x820A8CDC;
} // Block from 820A8CACh-820A8CDCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A8CDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8CDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8CDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8CDC);
		  /* 820A8CDCh */ case    0:  		/* nop */
		/* 820A8CDCh case    0:*/		cpu::op::nop();
		/* 820A8CDCh case    0:*/		return 0x820A8CE0;
	}
	return 0x820A8CE0;
} // Block from 820A8CDCh-820A8CE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A8CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8CE0);
		  /* 820A8CE0h */ case    0:  		/* mfspr R12, LR */
		/* 820A8CE0h case    0:*/		regs.R12 = regs.LR;
		/* 820A8CE0h case    0:*/		return 0x820A8CE4;
		  /* 820A8CE4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A8CE4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8CE4h case    1:*/		return 0x820A8CE8;
		  /* 820A8CE8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A8CE8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A8CE8h case    2:*/		return 0x820A8CEC;
		  /* 820A8CECh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A8CECh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A8CECh case    3:*/		return 0x820A8CF0;
		  /* 820A8CF0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A8CF0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A8CF0h case    4:*/		return 0x820A8CF4;
		  /* 820A8CF4h */ case    5:  		/* mr R31, R3 */
		/* 820A8CF4h case    5:*/		regs.R31 = regs.R3;
		/* 820A8CF4h case    5:*/		return 0x820A8CF8;
		  /* 820A8CF8h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 820A8CF8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820A8CF8h case    6:*/		return 0x820A8CFC;
		  /* 820A8CFCh */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820A8CFCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820A8D08;  }
		/* 820A8CFCh case    7:*/		return 0x820A8D00;
		  /* 820A8D00h */ case    8:  		/* mr R3, R4 */
		/* 820A8D00h case    8:*/		regs.R3 = regs.R4;
		/* 820A8D00h case    8:*/		return 0x820A8D04;
		  /* 820A8D04h */ case    9:  		/* b 56 */
		/* 820A8D04h case    9:*/		return 0x820A8D3C;
		/* 820A8D04h case    9:*/		return 0x820A8D08;
	}
	return 0x820A8D08;
} // Block from 820A8CE0h-820A8D08h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A8D08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8D08);
		  /* 820A8D08h */ case    0:  		/* lwz R11, <#[R31 + 84]> */
		/* 820A8D08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820A8D08h case    0:*/		return 0x820A8D0C;
		  /* 820A8D0Ch */ case    1:  		/* li R30, 1 */
		/* 820A8D0Ch case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820A8D0Ch case    1:*/		return 0x820A8D10;
		  /* 820A8D10h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 820A8D10h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A8D10h case    2:*/		return 0x820A8D14;
		  /* 820A8D14h */ case    3:  		/* bc 4, CR6_EQ, 32 */
		/* 820A8D14h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820A8D34;  }
		/* 820A8D14h case    3:*/		return 0x820A8D18;
		  /* 820A8D18h */ case    4:  		/* lis R11, -32255 */
		/* 820A8D18h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A8D18h case    4:*/		return 0x820A8D1C;
		  /* 820A8D1Ch */ case    5:  		/* lwz R3, <#[R31]> */
		/* 820A8D1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8D1Ch case    5:*/		return 0x820A8D20;
		  /* 820A8D20h */ case    6:  		/* li R5, 0 */
		/* 820A8D20h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820A8D20h case    6:*/		return 0x820A8D24;
		  /* 820A8D24h */ case    7:  		/* addi R6, R11, -10784 */
		/* 820A8D24h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD5E0);
		/* 820A8D24h case    7:*/		return 0x820A8D28;
		  /* 820A8D28h */ case    8:  		/* addi R4, R31, 16 */
		/* 820A8D28h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 820A8D28h case    8:*/		return 0x820A8D2C;
		  /* 820A8D2Ch */ case    9:  		/* bl -7068 */
		/* 820A8D2Ch case    9:*/		regs.LR = 0x820A8D30; return 0x820A7190;
		/* 820A8D2Ch case    9:*/		return 0x820A8D30;
		  /* 820A8D30h */ case   10:  		/* stw R30, <#[R31 + 84]> */
		/* 820A8D30h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000054) );
		/* 820A8D30h case   10:*/		return 0x820A8D34;
	}
	return 0x820A8D34;
} // Block from 820A8D08h-820A8D34h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A8D34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8D34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8D34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8D34);
		  /* 820A8D34h */ case    0:  		/* li R3, 0 */
		/* 820A8D34h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A8D34h case    0:*/		return 0x820A8D38;
		  /* 820A8D38h */ case    1:  		/* stw R30, <#[R31 + 88]> */
		/* 820A8D38h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000058) );
		/* 820A8D38h case    1:*/		return 0x820A8D3C;
	}
	return 0x820A8D3C;
} // Block from 820A8D34h-820A8D3Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A8D3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8D3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8D3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8D3C);
		  /* 820A8D3Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820A8D3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A8D3Ch case    0:*/		return 0x820A8D40;
		  /* 820A8D40h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A8D40h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8D40h case    1:*/		return 0x820A8D44;
		  /* 820A8D44h */ case    2:  		/* mtspr LR, R12 */
		/* 820A8D44h case    2:*/		regs.LR = regs.R12;
		/* 820A8D44h case    2:*/		return 0x820A8D48;
		  /* 820A8D48h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820A8D48h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A8D48h case    3:*/		return 0x820A8D4C;
		  /* 820A8D4Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820A8D4Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A8D4Ch case    4:*/		return 0x820A8D50;
		  /* 820A8D50h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820A8D50h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A8D50h case    5:*/		return 0x820A8D54;
	}
	return 0x820A8D54;
} // Block from 820A8D3Ch-820A8D54h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A8D54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8D54);
		  /* 820A8D54h */ case    0:  		/* nop */
		/* 820A8D54h case    0:*/		cpu::op::nop();
		/* 820A8D54h case    0:*/		return 0x820A8D58;
	}
	return 0x820A8D58;
} // Block from 820A8D54h-820A8D58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A8D58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8D58);
		  /* 820A8D58h */ case    0:  		/* mfspr R12, LR */
		/* 820A8D58h case    0:*/		regs.R12 = regs.LR;
		/* 820A8D58h case    0:*/		return 0x820A8D5C;
		  /* 820A8D5Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A8D5Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8D5Ch case    1:*/		return 0x820A8D60;
		  /* 820A8D60h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A8D60h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A8D60h case    2:*/		return 0x820A8D64;
		  /* 820A8D64h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A8D64h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A8D64h case    3:*/		return 0x820A8D68;
		  /* 820A8D68h */ case    4:  		/* lwz R7, <#[R4 + 8]> */
		/* 820A8D68h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000008) );
		/* 820A8D68h case    4:*/		return 0x820A8D6C;
		  /* 820A8D6Ch */ case    5:  		/* mr R31, R3 */
		/* 820A8D6Ch case    5:*/		regs.R31 = regs.R3;
		/* 820A8D6Ch case    5:*/		return 0x820A8D70;
		  /* 820A8D70h */ case    6:  		/* li R3, 0 */
		/* 820A8D70h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A8D70h case    6:*/		return 0x820A8D74;
		  /* 820A8D74h */ case    7:  		/* li R8, 0 */
		/* 820A8D74h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820A8D74h case    7:*/		return 0x820A8D78;
		  /* 820A8D78h */ case    8:  		/* cmplwi CR6, R7, 0 */
		/* 820A8D78h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820A8D78h case    8:*/		return 0x820A8D7C;
		  /* 820A8D7Ch */ case    9:  		/* bc 12, CR6_EQ, 208 */
		/* 820A8D7Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820A8E4C;  }
		/* 820A8D7Ch case    9:*/		return 0x820A8D80;
		  /* 820A8D80h */ case   10:  		/* lbz R10, <#[R7]> */
		/* 820A8D80h case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 820A8D80h case   10:*/		return 0x820A8D84;
		  /* 820A8D84h */ case   11:  		/* cmplwi CR0, R10, 0 */
		/* 820A8D84h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820A8D84h case   11:*/		return 0x820A8D88;
		  /* 820A8D88h */ case   12:  		/* bc 12, CR0_EQ, 196 */
		/* 820A8D88h case   12:*/		if ( regs.CR[0].eq ) { return 0x820A8E4C;  }
		/* 820A8D88h case   12:*/		return 0x820A8D8C;
		  /* 820A8D8Ch */ case   13:  		/* mr R9, R7 */
		/* 820A8D8Ch case   13:*/		regs.R9 = regs.R7;
		/* 820A8D8Ch case   13:*/		return 0x820A8D90;
		  /* 820A8D90h */ case   14:  		/* rlwinm R11, R10, 0, 24, 31 */
		/* 820A8D90h case   14:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R10);
		/* 820A8D90h case   14:*/		return 0x820A8D94;
		  /* 820A8D94h */ case   15:  		/* cmplwi CR6, R11, 119 */
		/* 820A8D94h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000077);
		/* 820A8D94h case   15:*/		return 0x820A8D98;
		  /* 820A8D98h */ case   16:  		/* bc 12, CR6_GT, 96 */
		/* 820A8D98h case   16:*/		if ( regs.CR[6].gt ) { return 0x820A8DF8;  }
		/* 820A8D98h case   16:*/		return 0x820A8D9C;
		  /* 820A8D9Ch */ case   17:  		/* bc 12, CR6_EQ, 80 */
		/* 820A8D9Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x820A8DEC;  }
		/* 820A8D9Ch case   17:*/		return 0x820A8DA0;
		  /* 820A8DA0h */ case   18:  		/* cmplwi CR6, R11, 97 */
		/* 820A8DA0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 820A8DA0h case   18:*/		return 0x820A8DA4;
		  /* 820A8DA4h */ case   19:  		/* bc 12, CR6_EQ, 72 */
		/* 820A8DA4h case   19:*/		if ( regs.CR[6].eq ) { return 0x820A8DEC;  }
		/* 820A8DA4h case   19:*/		return 0x820A8DA8;
		  /* 820A8DA8h */ case   20:  		/* cmplwi CR6, R11, 98 */
		/* 820A8DA8h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000062);
		/* 820A8DA8h case   20:*/		return 0x820A8DAC;
		  /* 820A8DACh */ case   21:  		/* bc 12, CR6_EQ, 100 */
		/* 820A8DACh case   21:*/		if ( regs.CR[6].eq ) { return 0x820A8E10;  }
		/* 820A8DACh case   21:*/		return 0x820A8DB0;
		  /* 820A8DB0h */ case   22:  		/* cmplwi CR6, R11, 103 */
		/* 820A8DB0h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000067);
		/* 820A8DB0h case   22:*/		return 0x820A8DB4;
		  /* 820A8DB4h */ case   23:  		/* bc 12, CR6_EQ, 104 */
		/* 820A8DB4h case   23:*/		if ( regs.CR[6].eq ) { return 0x820A8E1C;  }
		/* 820A8DB4h case   23:*/		return 0x820A8DB8;
		  /* 820A8DB8h */ case   24:  		/* cmplwi CR6, R11, 114 */
		/* 820A8DB8h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000072);
		/* 820A8DB8h case   24:*/		return 0x820A8DBC;
		  /* 820A8DBCh */ case   25:  		/* bc 4, CR6_EQ, 108 */
		/* 820A8DBCh case   25:*/		if ( !regs.CR[6].eq ) { return 0x820A8E28;  }
		/* 820A8DBCh case   25:*/		return 0x820A8DC0;
		  /* 820A8DC0h */ case   26:  		/* li R11, 0 */
		/* 820A8DC0h case   26:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A8DC0h case   26:*/		return 0x820A8DC4;
		  /* 820A8DC4h */ case   27:  		/* oris R3, R3, 1 */
		/* 820A8DC4h case   27:*/		cpu::op::oris<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820A8DC4h case   27:*/		return 0x820A8DC8;
		  /* 820A8DC8h */ case   28:  		/* cmplw CR6, R9, R7 */
		/* 820A8DC8h case   28:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 820A8DC8h case   28:*/		return 0x820A8DCC;
		  /* 820A8DCCh */ case   29:  		/* bc 12, CR6_EQ, 12 */
		/* 820A8DCCh case   29:*/		if ( regs.CR[6].eq ) { return 0x820A8DD8;  }
		/* 820A8DCCh case   29:*/		return 0x820A8DD0;
		  /* 820A8DD0h */ case   30:  		/* cmplw CR6, R11, R8 */
		/* 820A8DD0h case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820A8DD0h case   30:*/		return 0x820A8DD4;
		  /* 820A8DD4h */ case   31:  		/* bc 4, CR6_GT, 84 */
		/* 820A8DD4h case   31:*/		if ( !regs.CR[6].gt ) { return 0x820A8E28;  }
		/* 820A8DD4h case   31:*/		return 0x820A8DD8;
	}
	return 0x820A8DD8;
} // Block from 820A8D58h-820A8DD8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820A8DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8DD8);
		  /* 820A8DD8h */ case    0:  		/* lbzu R10, <#[R9 + 1]> */
		/* 820A8DD8h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000001) );
		regs.R9 = (uint32)(regs.R9 + 0x00000001);
		/* 820A8DD8h case    0:*/		return 0x820A8DDC;
		  /* 820A8DDCh */ case    1:  		/* mr R8, R11 */
		/* 820A8DDCh case    1:*/		regs.R8 = regs.R11;
		/* 820A8DDCh case    1:*/		return 0x820A8DE0;
		  /* 820A8DE0h */ case    2:  		/* extsb. R11, R10 */
		/* 820A8DE0h case    2:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R10);
		/* 820A8DE0h case    2:*/		return 0x820A8DE4;
		  /* 820A8DE4h */ case    3:  		/* bc 4, CR0_EQ, -84 */
		/* 820A8DE4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820A8D90;  }
		/* 820A8DE4h case    3:*/		return 0x820A8DE8;
		  /* 820A8DE8h */ case    4:  		/* b 104 */
		/* 820A8DE8h case    4:*/		return 0x820A8E50;
		/* 820A8DE8h case    4:*/		return 0x820A8DEC;
	}
	return 0x820A8DEC;
} // Block from 820A8DD8h-820A8DECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A8DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8DEC);
		  /* 820A8DECh */ case    0:  		/* li R11, 3 */
		/* 820A8DECh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820A8DECh case    0:*/		return 0x820A8DF0;
		  /* 820A8DF0h */ case    1:  		/* oris R3, R3, 8 */
		/* 820A8DF0h case    1:*/		cpu::op::oris<0>(regs,&regs.R3,regs.R3,0x8);
		/* 820A8DF0h case    1:*/		return 0x820A8DF4;
		  /* 820A8DF4h */ case    2:  		/* b -44 */
		/* 820A8DF4h case    2:*/		return 0x820A8DC8;
		/* 820A8DF4h case    2:*/		return 0x820A8DF8;
	}
	return 0x820A8DF8;
} // Block from 820A8DECh-820A8DF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A8DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8DF8);
		  /* 820A8DF8h */ case    0:  		/* cmplwi CR6, R11, 120 */
		/* 820A8DF8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000078);
		/* 820A8DF8h case    0:*/		return 0x820A8DFC;
		  /* 820A8DFCh */ case    1:  		/* bc 12, CR6_EQ, -60 */
		/* 820A8DFCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820A8DC0;  }
		/* 820A8DFCh case    1:*/		return 0x820A8E00;
		  /* 820A8E00h */ case    2:  		/* cmplwi CR6, R11, 121 */
		/* 820A8E00h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000079);
		/* 820A8E00h case    2:*/		return 0x820A8E04;
		  /* 820A8E04h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820A8E04h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A8E1C;  }
		/* 820A8E04h case    3:*/		return 0x820A8E08;
		  /* 820A8E08h */ case    4:  		/* cmplwi CR6, R11, 122 */
		/* 820A8E08h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007A);
		/* 820A8E08h case    4:*/		return 0x820A8E0C;
		  /* 820A8E0Ch */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 820A8E0Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A8E28;  }
		/* 820A8E0Ch case    5:*/		return 0x820A8E10;
	}
	return 0x820A8E10;
} // Block from 820A8DF8h-820A8E10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A8E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8E10);
		  /* 820A8E10h */ case    0:  		/* li R11, 2 */
		/* 820A8E10h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820A8E10h case    0:*/		return 0x820A8E14;
		  /* 820A8E14h */ case    1:  		/* oris R3, R3, 4 */
		/* 820A8E14h case    1:*/		cpu::op::oris<0>(regs,&regs.R3,regs.R3,0x4);
		/* 820A8E14h case    1:*/		return 0x820A8E18;
		  /* 820A8E18h */ case    2:  		/* b -80 */
		/* 820A8E18h case    2:*/		return 0x820A8DC8;
		/* 820A8E18h case    2:*/		return 0x820A8E1C;
	}
	return 0x820A8E1C;
} // Block from 820A8E10h-820A8E1Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A8E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8E1C);
		  /* 820A8E1Ch */ case    0:  		/* li R11, 1 */
		/* 820A8E1Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A8E1Ch case    0:*/		return 0x820A8E20;
		  /* 820A8E20h */ case    1:  		/* oris R3, R3, 2 */
		/* 820A8E20h case    1:*/		cpu::op::oris<0>(regs,&regs.R3,regs.R3,0x2);
		/* 820A8E20h case    1:*/		return 0x820A8E24;
		  /* 820A8E24h */ case    2:  		/* b -92 */
		/* 820A8E24h case    2:*/		return 0x820A8DC8;
		/* 820A8E24h case    2:*/		return 0x820A8E28;
	}
	return 0x820A8E28;
} // Block from 820A8E1Ch-820A8E28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A8E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8E28);
		  /* 820A8E28h */ case    0:  		/* lis R11, -32255 */
		/* 820A8E28h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A8E28h case    0:*/		return 0x820A8E2C;
		  /* 820A8E2Ch */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820A8E2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8E2Ch case    1:*/		return 0x820A8E30;
		  /* 820A8E30h */ case    2:  		/* li R5, 2003 */
		/* 820A8E30h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7D3);
		/* 820A8E30h case    2:*/		return 0x820A8E34;
		  /* 820A8E34h */ case    3:  		/* addi R6, R11, 2436 */
		/* 820A8E34h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x984);
		/* 820A8E34h case    3:*/		return 0x820A8E38;
		  /* 820A8E38h */ case    4:  		/* bl -7336 */
		/* 820A8E38h case    4:*/		regs.LR = 0x820A8E3C; return 0x820A7190;
		/* 820A8E38h case    4:*/		return 0x820A8E3C;
		  /* 820A8E3Ch */ case    5:  		/* li R11, 1 */
		/* 820A8E3Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A8E3Ch case    5:*/		return 0x820A8E40;
		  /* 820A8E40h */ case    6:  		/* li R3, 0 */
		/* 820A8E40h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A8E40h case    6:*/		return 0x820A8E44;
		  /* 820A8E44h */ case    7:  		/* stw R11, <#[R31 + 84]> */
		/* 820A8E44h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820A8E44h case    7:*/		return 0x820A8E48;
		  /* 820A8E48h */ case    8:  		/* b 8 */
		/* 820A8E48h case    8:*/		return 0x820A8E50;
		/* 820A8E48h case    8:*/		return 0x820A8E4C;
	}
	return 0x820A8E4C;
} // Block from 820A8E28h-820A8E4Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A8E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8E4C);
		  /* 820A8E4Ch */ case    0:  		/* lis R3, 15 */
		/* 820A8E4Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xF);
		/* 820A8E4Ch case    0:*/		return 0x820A8E50;
	}
	return 0x820A8E50;
} // Block from 820A8E4Ch-820A8E50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A8E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8E50);
		  /* 820A8E50h */ case    0:  		/* addi R1, R1, 96 */
		/* 820A8E50h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A8E50h case    0:*/		return 0x820A8E54;
		  /* 820A8E54h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A8E54h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8E54h case    1:*/		return 0x820A8E58;
		  /* 820A8E58h */ case    2:  		/* mtspr LR, R12 */
		/* 820A8E58h case    2:*/		regs.LR = regs.R12;
		/* 820A8E58h case    2:*/		return 0x820A8E5C;
		  /* 820A8E5Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A8E5Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A8E5Ch case    3:*/		return 0x820A8E60;
		  /* 820A8E60h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A8E60h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A8E60h case    4:*/		return 0x820A8E64;
	}
	return 0x820A8E64;
} // Block from 820A8E50h-820A8E64h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A8E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8E64);
		  /* 820A8E64h */ case    0:  		/* nop */
		/* 820A8E64h case    0:*/		cpu::op::nop();
		/* 820A8E64h case    0:*/		return 0x820A8E68;
	}
	return 0x820A8E68;
} // Block from 820A8E64h-820A8E68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A8E68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8E68);
		  /* 820A8E68h */ case    0:  		/* mfspr R12, LR */
		/* 820A8E68h case    0:*/		regs.R12 = regs.LR;
		/* 820A8E68h case    0:*/		return 0x820A8E6C;
		  /* 820A8E6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A8E6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8E6Ch case    1:*/		return 0x820A8E70;
		  /* 820A8E70h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A8E70h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A8E70h case    2:*/		return 0x820A8E74;
		  /* 820A8E74h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A8E74h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A8E74h case    3:*/		return 0x820A8E78;
		  /* 820A8E78h */ case    4:  		/* lwz R7, <#[R4 + 8]> */
		/* 820A8E78h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000008) );
		/* 820A8E78h case    4:*/		return 0x820A8E7C;
		  /* 820A8E7Ch */ case    5:  		/* mr R31, R3 */
		/* 820A8E7Ch case    5:*/		regs.R31 = regs.R3;
		/* 820A8E7Ch case    5:*/		return 0x820A8E80;
		  /* 820A8E80h */ case    6:  		/* li R11, 0 */
		/* 820A8E80h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A8E80h case    6:*/		return 0x820A8E84;
		  /* 820A8E84h */ case    7:  		/* li R3, 0 */
		/* 820A8E84h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A8E84h case    7:*/		return 0x820A8E88;
		  /* 820A8E88h */ case    8:  		/* mr R8, R7 */
		/* 820A8E88h case    8:*/		regs.R8 = regs.R7;
		/* 820A8E88h case    8:*/		return 0x820A8E8C;
		  /* 820A8E8Ch */ case    9:  		/* cmplwi CR6, R7, 0 */
		/* 820A8E8Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820A8E8Ch case    9:*/		return 0x820A8E90;
		  /* 820A8E90h */ case   10:  		/* bc 12, CR6_EQ, 204 */
		/* 820A8E90h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A8F5C;  }
		/* 820A8E90h case   10:*/		return 0x820A8E94;
		  /* 820A8E94h */ case   11:  		/* lbz R10, <#[R7]> */
		/* 820A8E94h case   11:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 820A8E94h case   11:*/		return 0x820A8E98;
		  /* 820A8E98h */ case   12:  		/* cmplwi CR0, R10, 0 */
		/* 820A8E98h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820A8E98h case   12:*/		return 0x820A8E9C;
		  /* 820A8E9Ch */ case   13:  		/* bc 12, CR0_EQ, 192 */
		/* 820A8E9Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x820A8F5C;  }
		/* 820A8E9Ch case   13:*/		return 0x820A8EA0;
		  /* 820A8EA0h */ case   14:  		/* li R9, 16 */
		/* 820A8EA0h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 820A8EA0h case   14:*/		return 0x820A8EA4;
		  /* 820A8EA4h */ case   15:  		/* lbz R10, <#[R8]> */
		/* 820A8EA4h case   15:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820A8EA4h case   15:*/		return 0x820A8EA8;
		  /* 820A8EA8h */ case   16:  		/* cmplwi CR0, R10, 0 */
		/* 820A8EA8h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820A8EA8h case   16:*/		return 0x820A8EAC;
		  /* 820A8EACh */ case   17:  		/* bc 12, CR0_EQ, 60 */
		/* 820A8EACh case   17:*/		if ( regs.CR[0].eq ) { return 0x820A8EE8;  }
		/* 820A8EACh case   17:*/		return 0x820A8EB0;
		  /* 820A8EB0h */ case   18:  		/* rlwinm R11, R10, 0, 24, 31 */
		/* 820A8EB0h case   18:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R10);
		/* 820A8EB0h case   18:*/		return 0x820A8EB4;
		  /* 820A8EB4h */ case   19:  		/* cmplwi CR6, R11, 119 */
		/* 820A8EB4h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000077);
		/* 820A8EB4h case   19:*/		return 0x820A8EB8;
		  /* 820A8EB8h */ case   20:  		/* bc 12, CR6_GT, 124 */
		/* 820A8EB8h case   20:*/		if ( regs.CR[6].gt ) { return 0x820A8F34;  }
		/* 820A8EB8h case   20:*/		return 0x820A8EBC;
		  /* 820A8EBCh */ case   21:  		/* bc 12, CR6_EQ, 112 */
		/* 820A8EBCh case   21:*/		if ( regs.CR[6].eq ) { return 0x820A8F2C;  }
		/* 820A8EBCh case   21:*/		return 0x820A8EC0;
		  /* 820A8EC0h */ case   22:  		/* cmplwi CR6, R11, 97 */
		/* 820A8EC0h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 820A8EC0h case   22:*/		return 0x820A8EC4;
		  /* 820A8EC4h */ case   23:  		/* bc 12, CR6_EQ, 104 */
		/* 820A8EC4h case   23:*/		if ( regs.CR[6].eq ) { return 0x820A8F2C;  }
		/* 820A8EC4h case   23:*/		return 0x820A8EC8;
		  /* 820A8EC8h */ case   24:  		/* cmplwi CR6, R11, 98 */
		/* 820A8EC8h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000062);
		/* 820A8EC8h case   24:*/		return 0x820A8ECC;
		  /* 820A8ECCh */ case   25:  		/* bc 12, CR6_EQ, 128 */
		/* 820A8ECCh case   25:*/		if ( regs.CR[6].eq ) { return 0x820A8F4C;  }
		/* 820A8ECCh case   25:*/		return 0x820A8ED0;
		  /* 820A8ED0h */ case   26:  		/* cmplwi CR6, R11, 103 */
		/* 820A8ED0h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000067);
		/* 820A8ED0h case   26:*/		return 0x820A8ED4;
		  /* 820A8ED4h */ case   27:  		/* bc 12, CR6_EQ, 128 */
		/* 820A8ED4h case   27:*/		if ( regs.CR[6].eq ) { return 0x820A8F54;  }
		/* 820A8ED4h case   27:*/		return 0x820A8ED8;
		  /* 820A8ED8h */ case   28:  		/* cmplwi CR6, R11, 114 */
		/* 820A8ED8h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000072);
		/* 820A8ED8h case   28:*/		return 0x820A8EDC;
		  /* 820A8EDCh */ case   29:  		/* bc 4, CR6_EQ, 44 */
		/* 820A8EDCh case   29:*/		if ( !regs.CR[6].eq ) { return 0x820A8F08;  }
		/* 820A8EDCh case   29:*/		return 0x820A8EE0;
		  /* 820A8EE0h */ case   30:  		/* li R11, 0 */
		/* 820A8EE0h case   30:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A8EE0h case   30:*/		return 0x820A8EE4;
		  /* 820A8EE4h */ case   31:  		/* addi R8, R8, 1 */
		/* 820A8EE4h case   31:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820A8EE4h case   31:*/		return 0x820A8EE8;
	}
	return 0x820A8EE8;
} // Block from 820A8E68h-820A8EE8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820A8EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8EE8);
		  /* 820A8EE8h */ case    0:  		/* slw R10, R11, R9 */
		/* 820A8EE8h case    0:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 820A8EE8h case    0:*/		return 0x820A8EEC;
		  /* 820A8EECh */ case    1:  		/* addi R9, R9, 2 */
		/* 820A8EECh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 820A8EECh case    1:*/		return 0x820A8EF0;
		  /* 820A8EF0h */ case    2:  		/* or R3, R10, R3 */
		/* 820A8EF0h case    2:*/		cpu::op::or<0>(regs,&regs.R3,regs.R10,regs.R3);
		/* 820A8EF0h case    2:*/		return 0x820A8EF4;
		  /* 820A8EF4h */ case    3:  		/* cmplwi CR6, R9, 24 */
		/* 820A8EF4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000018);
		/* 820A8EF4h case    3:*/		return 0x820A8EF8;
		  /* 820A8EF8h */ case    4:  		/* bc 12, CR6_LT, -84 */
		/* 820A8EF8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820A8EA4;  }
		/* 820A8EF8h case    4:*/		return 0x820A8EFC;
		  /* 820A8EFCh */ case    5:  		/* lbz R11, <#[R8]> */
		/* 820A8EFCh case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820A8EFCh case    5:*/		return 0x820A8F00;
		  /* 820A8F00h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 820A8F00h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A8F00h case    6:*/		return 0x820A8F04;
		  /* 820A8F04h */ case    7:  		/* bc 12, CR0_EQ, 92 */
		/* 820A8F04h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A8F60;  }
		/* 820A8F04h case    7:*/		return 0x820A8F08;
	}
	return 0x820A8F08;
} // Block from 820A8EE8h-820A8F08h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A8F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8F08);
		  /* 820A8F08h */ case    0:  		/* lis R11, -32255 */
		/* 820A8F08h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A8F08h case    0:*/		return 0x820A8F0C;
		  /* 820A8F0Ch */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820A8F0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A8F0Ch case    1:*/		return 0x820A8F10;
		  /* 820A8F10h */ case    2:  		/* li R5, 2004 */
		/* 820A8F10h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7D4);
		/* 820A8F10h case    2:*/		return 0x820A8F14;
		  /* 820A8F14h */ case    3:  		/* addi R6, R11, 2456 */
		/* 820A8F14h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x998);
		/* 820A8F14h case    3:*/		return 0x820A8F18;
		  /* 820A8F18h */ case    4:  		/* bl -7560 */
		/* 820A8F18h case    4:*/		regs.LR = 0x820A8F1C; return 0x820A7190;
		/* 820A8F18h case    4:*/		return 0x820A8F1C;
		  /* 820A8F1Ch */ case    5:  		/* li R11, 1 */
		/* 820A8F1Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A8F1Ch case    5:*/		return 0x820A8F20;
		  /* 820A8F20h */ case    6:  		/* li R3, 0 */
		/* 820A8F20h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A8F20h case    6:*/		return 0x820A8F24;
		  /* 820A8F24h */ case    7:  		/* stw R11, <#[R31 + 84]> */
		/* 820A8F24h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820A8F24h case    7:*/		return 0x820A8F28;
		  /* 820A8F28h */ case    8:  		/* b 56 */
		/* 820A8F28h case    8:*/		return 0x820A8F60;
		/* 820A8F28h case    8:*/		return 0x820A8F2C;
	}
	return 0x820A8F2C;
} // Block from 820A8F08h-820A8F2Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A8F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8F2C);
		  /* 820A8F2Ch */ case    0:  		/* li R11, 3 */
		/* 820A8F2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820A8F2Ch case    0:*/		return 0x820A8F30;
		  /* 820A8F30h */ case    1:  		/* b -76 */
		/* 820A8F30h case    1:*/		return 0x820A8EE4;
		/* 820A8F30h case    1:*/		return 0x820A8F34;
	}
	return 0x820A8F34;
} // Block from 820A8F2Ch-820A8F34h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A8F34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8F34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8F34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8F34);
		  /* 820A8F34h */ case    0:  		/* cmplwi CR6, R11, 120 */
		/* 820A8F34h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000078);
		/* 820A8F34h case    0:*/		return 0x820A8F38;
		  /* 820A8F38h */ case    1:  		/* bc 12, CR6_EQ, -88 */
		/* 820A8F38h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A8EE0;  }
		/* 820A8F38h case    1:*/		return 0x820A8F3C;
		  /* 820A8F3Ch */ case    2:  		/* cmplwi CR6, R11, 121 */
		/* 820A8F3Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000079);
		/* 820A8F3Ch case    2:*/		return 0x820A8F40;
		  /* 820A8F40h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 820A8F40h case    3:*/		if ( regs.CR[6].eq ) { return 0x820A8F54;  }
		/* 820A8F40h case    3:*/		return 0x820A8F44;
		  /* 820A8F44h */ case    4:  		/* cmplwi CR6, R11, 122 */
		/* 820A8F44h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007A);
		/* 820A8F44h case    4:*/		return 0x820A8F48;
		  /* 820A8F48h */ case    5:  		/* bc 4, CR6_EQ, -64 */
		/* 820A8F48h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820A8F08;  }
		/* 820A8F48h case    5:*/		return 0x820A8F4C;
	}
	return 0x820A8F4C;
} // Block from 820A8F34h-820A8F4Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A8F4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8F4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8F4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8F4C);
		  /* 820A8F4Ch */ case    0:  		/* li R11, 2 */
		/* 820A8F4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820A8F4Ch case    0:*/		return 0x820A8F50;
		  /* 820A8F50h */ case    1:  		/* b -108 */
		/* 820A8F50h case    1:*/		return 0x820A8EE4;
		/* 820A8F50h case    1:*/		return 0x820A8F54;
	}
	return 0x820A8F54;
} // Block from 820A8F4Ch-820A8F54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A8F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8F54);
		  /* 820A8F54h */ case    0:  		/* li R11, 1 */
		/* 820A8F54h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A8F54h case    0:*/		return 0x820A8F58;
		  /* 820A8F58h */ case    1:  		/* b -116 */
		/* 820A8F58h case    1:*/		return 0x820A8EE4;
		/* 820A8F58h case    1:*/		return 0x820A8F5C;
	}
	return 0x820A8F5C;
} // Block from 820A8F54h-820A8F5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A8F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8F5C);
		  /* 820A8F5Ch */ case    0:  		/* lis R3, 228 */
		/* 820A8F5Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xE4);
		/* 820A8F5Ch case    0:*/		return 0x820A8F60;
	}
	return 0x820A8F60;
} // Block from 820A8F5Ch-820A8F60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A8F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8F60);
		  /* 820A8F60h */ case    0:  		/* addi R1, R1, 96 */
		/* 820A8F60h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A8F60h case    0:*/		return 0x820A8F64;
		  /* 820A8F64h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A8F64h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8F64h case    1:*/		return 0x820A8F68;
		  /* 820A8F68h */ case    2:  		/* mtspr LR, R12 */
		/* 820A8F68h case    2:*/		regs.LR = regs.R12;
		/* 820A8F68h case    2:*/		return 0x820A8F6C;
		  /* 820A8F6Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A8F6Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A8F6Ch case    3:*/		return 0x820A8F70;
		  /* 820A8F70h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A8F70h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A8F70h case    4:*/		return 0x820A8F74;
	}
	return 0x820A8F74;
} // Block from 820A8F60h-820A8F74h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A8F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8F74);
		  /* 820A8F74h */ case    0:  		/* nop */
		/* 820A8F74h case    0:*/		cpu::op::nop();
		/* 820A8F74h case    0:*/		return 0x820A8F78;
	}
	return 0x820A8F78;
} // Block from 820A8F74h-820A8F78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A8F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8F78);
		  /* 820A8F78h */ case    0:  		/* mfspr R12, LR */
		/* 820A8F78h case    0:*/		regs.R12 = regs.LR;
		/* 820A8F78h case    0:*/		return 0x820A8F7C;
		  /* 820A8F7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A8F7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8F7Ch case    1:*/		return 0x820A8F80;
		  /* 820A8F80h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A8F80h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A8F80h case    2:*/		return 0x820A8F84;
		  /* 820A8F84h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A8F84h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A8F84h case    3:*/		return 0x820A8F88;
		  /* 820A8F88h */ case    4:  		/* mr R31, R3 */
		/* 820A8F88h case    4:*/		regs.R31 = regs.R3;
		/* 820A8F88h case    4:*/		return 0x820A8F8C;
		  /* 820A8F8Ch */ case    5:  		/* lwz R3, <#[R3 + 8]> */
		/* 820A8F8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 820A8F8Ch case    5:*/		return 0x820A8F90;
		  /* 820A8F90h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 820A8F90h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A8F90h case    6:*/		return 0x820A8F94;
		  /* 820A8F94h */ case    7:  		/* bc 12, CR6_EQ, 96 */
		/* 820A8F94h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A8FF4;  }
		/* 820A8F94h case    7:*/		return 0x820A8F98;
		  /* 820A8F98h */ case    8:  		/* lwz R11, <#[R31 + 112]> */
		/* 820A8F98h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820A8F98h case    8:*/		return 0x820A8F9C;
		  /* 820A8F9Ch */ case    9:  		/* lwz R9, <#[R31 + 104]> */
		/* 820A8F9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000068) );
		/* 820A8F9Ch case    9:*/		return 0x820A8FA0;
		  /* 820A8FA0h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 820A8FA0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820A8FA0h case   10:*/		return 0x820A8FA4;
		  /* 820A8FA4h */ case   11:  		/* bc 4, CR6_LT, 80 */
		/* 820A8FA4h case   11:*/		if ( !regs.CR[6].lt ) { return 0x820A8FF4;  }
		/* 820A8FA4h case   11:*/		return 0x820A8FA8;
		  /* 820A8FA8h */ case   12:  		/* stw R4, <#[R31 + 56]> */
		/* 820A8FA8h case   12:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x00000038) );
		/* 820A8FA8h case   12:*/		return 0x820A8FAC;
		  /* 820A8FACh */ case   13:  		/* subf R7, R11, R9 */
		/* 820A8FACh case   13:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R11,regs.R9);
		/* 820A8FACh case   13:*/		return 0x820A8FB0;
		  /* 820A8FB0h */ case   14:  		/* lwz R8, <#[R3]> */
		/* 820A8FB0h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820A8FB0h case   14:*/		return 0x820A8FB4;
		  /* 820A8FB4h */ case   15:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 820A8FB4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820A8FB4h case   15:*/		return 0x820A8FB8;
		  /* 820A8FB8h */ case   16:  		/* lwz R9, <#[R8 + 12]> */
		/* 820A8FB8h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x0000000C) );
		/* 820A8FB8h case   16:*/		return 0x820A8FBC;
		  /* 820A8FBCh */ case   17:  		/* lwz R11, <#[R31 + 100]> */
		/* 820A8FBCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 820A8FBCh case   17:*/		return 0x820A8FC0;
		  /* 820A8FC0h */ case   18:  		/* lwz R5, <#[R4 + 24]> */
		/* 820A8FC0h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x00000018) );
		/* 820A8FC0h case   18:*/		return 0x820A8FC4;
		  /* 820A8FC4h */ case   19:  		/* add R6, R10, R11 */
		/* 820A8FC4h case   19:*/		cpu::op::add<0>(regs,&regs.R6,regs.R10,regs.R11);
		/* 820A8FC4h case   19:*/		return 0x820A8FC8;
		  /* 820A8FC8h */ case   20:  		/* lwz R4, <#[R4 + 16]> */
		/* 820A8FC8h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000010) );
		/* 820A8FC8h case   20:*/		return 0x820A8FCC;
		  /* 820A8FCCh */ case   21:  		/* mtspr CTR, R9 */
		/* 820A8FCCh case   21:*/		regs.CTR = regs.R9;
		/* 820A8FCCh case   21:*/		return 0x820A8FD0;
		  /* 820A8FD0h */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 820A8FD0h case   22:*/		if ( 1 ) { regs.LR = 0x820A8FD4; return (uint32)regs.CTR; }
		/* 820A8FD0h case   22:*/		return 0x820A8FD4;
		  /* 820A8FD4h */ case   23:  		/* cmpwi CR0, R3, 0 */
		/* 820A8FD4h case   23:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A8FD4h case   23:*/		return 0x820A8FD8;
		  /* 820A8FD8h */ case   24:  		/* bc 4, CR0_LT, 16 */
		/* 820A8FD8h case   24:*/		if ( !regs.CR[0].lt ) { return 0x820A8FE8;  }
		/* 820A8FD8h case   24:*/		return 0x820A8FDC;
		  /* 820A8FDCh */ case   25:  		/* li R11, 1 */
		/* 820A8FDCh case   25:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A8FDCh case   25:*/		return 0x820A8FE0;
		  /* 820A8FE0h */ case   26:  		/* stw R11, <#[R31 + 84]> */
		/* 820A8FE0h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820A8FE0h case   26:*/		return 0x820A8FE4;
		  /* 820A8FE4h */ case   27:  		/* stw R11, <#[R31 + 88]> */
		/* 820A8FE4h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 820A8FE4h case   27:*/		return 0x820A8FE8;
	}
	return 0x820A8FE8;
} // Block from 820A8F78h-820A8FE8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820A8FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8FE8);
		  /* 820A8FE8h */ case    0:  		/* lwz R11, <#[R31 + 104]> */
		/* 820A8FE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820A8FE8h case    0:*/		return 0x820A8FEC;
		  /* 820A8FECh */ case    1:  		/* stw R11, <#[R31 + 112]> */
		/* 820A8FECh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820A8FECh case    1:*/		return 0x820A8FF0;
		  /* 820A8FF0h */ case    2:  		/* b 8 */
		/* 820A8FF0h case    2:*/		return 0x820A8FF8;
		/* 820A8FF0h case    2:*/		return 0x820A8FF4;
	}
	return 0x820A8FF4;
} // Block from 820A8FE8h-820A8FF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A8FF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8FF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8FF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8FF4);
		  /* 820A8FF4h */ case    0:  		/* li R3, 0 */
		/* 820A8FF4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A8FF4h case    0:*/		return 0x820A8FF8;
	}
	return 0x820A8FF8;
} // Block from 820A8FF4h-820A8FF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A8FF8h
// Function '?GetUsageAndIndex@D3DXShader@@YAJPBDPAE1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A8FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A8FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A8FF8);
		  /* 820A8FF8h */ case    0:  		/* addi R1, R1, 96 */
		/* 820A8FF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A8FF8h case    0:*/		return 0x820A8FFC;
		  /* 820A8FFCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A8FFCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A8FFCh case    1:*/		return 0x820A9000;
		  /* 820A9000h */ case    2:  		/* mtspr LR, R12 */
		/* 820A9000h case    2:*/		regs.LR = regs.R12;
		/* 820A9000h case    2:*/		return 0x820A9004;
		  /* 820A9004h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A9004h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A9004h case    3:*/		return 0x820A9008;
		  /* 820A9008h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A9008h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A9008h case    4:*/		return 0x820A900C;
	}
	return 0x820A900C;
} // Block from 820A8FF8h-820A900Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A900Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A900C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A900C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A900C);
		  /* 820A900Ch */ case    0:  		/* nop */
		/* 820A900Ch case    0:*/		cpu::op::nop();
		/* 820A900Ch case    0:*/		return 0x820A9010;
	}
	return 0x820A9010;
} // Block from 820A900Ch-820A9010h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A9010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9010);
		  /* 820A9010h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 820A9010h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A9010h case    0:*/		return 0x820A9014;
		  /* 820A9014h */ case    1:  		/* lwz R10, <#[R3]> */
		/* 820A9014h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820A9014h case    1:*/		return 0x820A9018;
		  /* 820A9018h */ case    2:  		/* lis R11, -32255 */
		/* 820A9018h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9018h case    2:*/		return 0x820A901C;
		  /* 820A901Ch */ case    3:  		/* lwz R3, <#[R4]> */
		/* 820A901Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000000) );
		/* 820A901Ch case    3:*/		return 0x820A9020;
		  /* 820A9020h */ case    4:  		/* addi R6, R11, 2488 */
		/* 820A9020h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x9B8);
		/* 820A9020h case    4:*/		return 0x820A9024;
		  /* 820A9024h */ case    5:  		/* mr R11, R6 */
		/* 820A9024h case    5:*/		regs.R11 = regs.R6;
		/* 820A9024h case    5:*/		return 0x820A9028;
		  /* 820A9028h */ case    6:  		/* lwz R31, <#[R10]> */
		/* 820A9028h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000000) );
		/* 820A9028h case    6:*/		return 0x820A902C;
		  /* 820A902Ch */ case    7:  		/* addi R9, R6, 2 */
		/* 820A902Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0x2);
		/* 820A902Ch case    7:*/		return 0x820A9030;
		  /* 820A9030h */ case    8:  		/* mr R10, R31 */
		/* 820A9030h case    8:*/		regs.R10 = regs.R31;
		/* 820A9030h case    8:*/		return 0x820A9034;
		  /* 820A9034h */ case    9:  		/* lbz R8, <#[R11]> */
		/* 820A9034h case    9:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9034h case    9:*/		return 0x820A9038;
		  /* 820A9038h */ case   10:  		/* lbz R7, <#[R10]> */
		/* 820A9038h case   10:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A9038h case   10:*/		return 0x820A903C;
		  /* 820A903Ch */ case   11:  		/* subf. R8, R7, R8 */
		/* 820A903Ch case   11:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A903Ch case   11:*/		return 0x820A9040;
		  /* 820A9040h */ case   12:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9040h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820A9054;  }
		/* 820A9040h case   12:*/		return 0x820A9044;
		  /* 820A9044h */ case   13:  		/* addi R11, R11, 1 */
		/* 820A9044h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9044h case   13:*/		return 0x820A9048;
		  /* 820A9048h */ case   14:  		/* addi R10, R10, 1 */
		/* 820A9048h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A9048h case   14:*/		return 0x820A904C;
		  /* 820A904Ch */ case   15:  		/* cmpw CR6, R11, R9 */
		/* 820A904Ch case   15:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 820A904Ch case   15:*/		return 0x820A9050;
		  /* 820A9050h */ case   16:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9050h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820A9034;  }
		/* 820A9050h case   16:*/		return 0x820A9054;
	}
	return 0x820A9054;
} // Block from 820A9010h-820A9054h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A9054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9054);
		  /* 820A9054h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A9054h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A9054h case    0:*/		return 0x820A9058;
		  /* 820A9058h */ case    1:  		/* bc 12, CR0_EQ, 388 */
		/* 820A9058h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A91DC;  }
		/* 820A9058h case    1:*/		return 0x820A905C;
		  /* 820A905Ch */ case    2:  		/* lis R11, -32255 */
		/* 820A905Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A905Ch case    2:*/		return 0x820A9060;
		  /* 820A9060h */ case    3:  		/* mr R10, R31 */
		/* 820A9060h case    3:*/		regs.R10 = regs.R31;
		/* 820A9060h case    3:*/		return 0x820A9064;
		  /* 820A9064h */ case    4:  		/* addi R4, R11, 2484 */
		/* 820A9064h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x9B4);
		/* 820A9064h case    4:*/		return 0x820A9068;
		  /* 820A9068h */ case    5:  		/* mr R11, R4 */
		/* 820A9068h case    5:*/		regs.R11 = regs.R4;
		/* 820A9068h case    5:*/		return 0x820A906C;
		  /* 820A906Ch */ case    6:  		/* addi R9, R4, 2 */
		/* 820A906Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x2);
		/* 820A906Ch case    6:*/		return 0x820A9070;
		  /* 820A9070h */ case    7:  		/* lbz R8, <#[R11]> */
		/* 820A9070h case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9070h case    7:*/		return 0x820A9074;
		  /* 820A9074h */ case    8:  		/* lbz R7, <#[R10]> */
		/* 820A9074h case    8:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A9074h case    8:*/		return 0x820A9078;
		  /* 820A9078h */ case    9:  		/* subf. R8, R7, R8 */
		/* 820A9078h case    9:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A9078h case    9:*/		return 0x820A907C;
		  /* 820A907Ch */ case   10:  		/* bc 4, CR0_EQ, 20 */
		/* 820A907Ch case   10:*/		if ( !regs.CR[0].eq ) { return 0x820A9090;  }
		/* 820A907Ch case   10:*/		return 0x820A9080;
		  /* 820A9080h */ case   11:  		/* addi R11, R11, 1 */
		/* 820A9080h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9080h case   11:*/		return 0x820A9084;
		  /* 820A9084h */ case   12:  		/* addi R10, R10, 1 */
		/* 820A9084h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A9084h case   12:*/		return 0x820A9088;
		  /* 820A9088h */ case   13:  		/* cmpw CR6, R11, R9 */
		/* 820A9088h case   13:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 820A9088h case   13:*/		return 0x820A908C;
		  /* 820A908Ch */ case   14:  		/* bc 4, CR6_EQ, -28 */
		/* 820A908Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x820A9070;  }
		/* 820A908Ch case   14:*/		return 0x820A9090;
	}
	return 0x820A9090;
} // Block from 820A9054h-820A9090h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A9090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9090);
		  /* 820A9090h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A9090h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A9090h case    0:*/		return 0x820A9094;
		  /* 820A9094h */ case    1:  		/* bc 12, CR0_EQ, 328 */
		/* 820A9094h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A91DC;  }
		/* 820A9094h case    1:*/		return 0x820A9098;
		  /* 820A9098h */ case    2:  		/* lis R11, -32255 */
		/* 820A9098h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9098h case    2:*/		return 0x820A909C;
		  /* 820A909Ch */ case    3:  		/* mr R10, R31 */
		/* 820A909Ch case    3:*/		regs.R10 = regs.R31;
		/* 820A909Ch case    3:*/		return 0x820A90A0;
		  /* 820A90A0h */ case    4:  		/* addi R5, R11, 2480 */
		/* 820A90A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x9B0);
		/* 820A90A0h case    4:*/		return 0x820A90A4;
		  /* 820A90A4h */ case    5:  		/* mr R11, R5 */
		/* 820A90A4h case    5:*/		regs.R11 = regs.R5;
		/* 820A90A4h case    5:*/		return 0x820A90A8;
		  /* 820A90A8h */ case    6:  		/* addi R9, R5, 2 */
		/* 820A90A8h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R5,0x2);
		/* 820A90A8h case    6:*/		return 0x820A90AC;
		  /* 820A90ACh */ case    7:  		/* lbz R8, <#[R11]> */
		/* 820A90ACh case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A90ACh case    7:*/		return 0x820A90B0;
		  /* 820A90B0h */ case    8:  		/* lbz R7, <#[R10]> */
		/* 820A90B0h case    8:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A90B0h case    8:*/		return 0x820A90B4;
		  /* 820A90B4h */ case    9:  		/* subf. R8, R7, R8 */
		/* 820A90B4h case    9:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A90B4h case    9:*/		return 0x820A90B8;
		  /* 820A90B8h */ case   10:  		/* bc 4, CR0_EQ, 20 */
		/* 820A90B8h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820A90CC;  }
		/* 820A90B8h case   10:*/		return 0x820A90BC;
		  /* 820A90BCh */ case   11:  		/* addi R11, R11, 1 */
		/* 820A90BCh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A90BCh case   11:*/		return 0x820A90C0;
		  /* 820A90C0h */ case   12:  		/* addi R10, R10, 1 */
		/* 820A90C0h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A90C0h case   12:*/		return 0x820A90C4;
		  /* 820A90C4h */ case   13:  		/* cmpw CR6, R11, R9 */
		/* 820A90C4h case   13:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 820A90C4h case   13:*/		return 0x820A90C8;
		  /* 820A90C8h */ case   14:  		/* bc 4, CR6_EQ, -28 */
		/* 820A90C8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820A90AC;  }
		/* 820A90C8h case   14:*/		return 0x820A90CC;
	}
	return 0x820A90CC;
} // Block from 820A9090h-820A90CCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A90CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A90CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A90CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A90CC);
		  /* 820A90CCh */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A90CCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A90CCh case    0:*/		return 0x820A90D0;
		  /* 820A90D0h */ case    1:  		/* bc 12, CR0_EQ, 268 */
		/* 820A90D0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A91DC;  }
		/* 820A90D0h case    1:*/		return 0x820A90D4;
		  /* 820A90D4h */ case    2:  		/* lwz R7, <#[R3]> */
		/* 820A90D4h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000000) );
		/* 820A90D4h case    2:*/		return 0x820A90D8;
		  /* 820A90D8h */ case    3:  		/* mr R11, R6 */
		/* 820A90D8h case    3:*/		regs.R11 = regs.R6;
		/* 820A90D8h case    3:*/		return 0x820A90DC;
		  /* 820A90DCh */ case    4:  		/* addi R9, R6, 2 */
		/* 820A90DCh case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0x2);
		/* 820A90DCh case    4:*/		return 0x820A90E0;
		  /* 820A90E0h */ case    5:  		/* mr R10, R7 */
		/* 820A90E0h case    5:*/		regs.R10 = regs.R7;
		/* 820A90E0h case    5:*/		return 0x820A90E4;
		  /* 820A90E4h */ case    6:  		/* lbz R8, <#[R11]> */
		/* 820A90E4h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A90E4h case    6:*/		return 0x820A90E8;
		  /* 820A90E8h */ case    7:  		/* lbz R6, <#[R10]> */
		/* 820A90E8h case    7:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820A90E8h case    7:*/		return 0x820A90EC;
		  /* 820A90ECh */ case    8:  		/* subf. R8, R6, R8 */
		/* 820A90ECh case    8:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R6,regs.R8);
		/* 820A90ECh case    8:*/		return 0x820A90F0;
		  /* 820A90F0h */ case    9:  		/* bc 4, CR0_EQ, 20 */
		/* 820A90F0h case    9:*/		if ( !regs.CR[0].eq ) { return 0x820A9104;  }
		/* 820A90F0h case    9:*/		return 0x820A90F4;
		  /* 820A90F4h */ case   10:  		/* addi R11, R11, 1 */
		/* 820A90F4h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A90F4h case   10:*/		return 0x820A90F8;
		  /* 820A90F8h */ case   11:  		/* addi R10, R10, 1 */
		/* 820A90F8h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A90F8h case   11:*/		return 0x820A90FC;
		  /* 820A90FCh */ case   12:  		/* cmpw CR6, R11, R9 */
		/* 820A90FCh case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 820A90FCh case   12:*/		return 0x820A9100;
		  /* 820A9100h */ case   13:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9100h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A90E4;  }
		/* 820A9100h case   13:*/		return 0x820A9104;
	}
	return 0x820A9104;
} // Block from 820A90CCh-820A9104h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A9104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9104);
		  /* 820A9104h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A9104h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A9104h case    0:*/		return 0x820A9108;
		  /* 820A9108h */ case    1:  		/* bc 12, CR0_EQ, 212 */
		/* 820A9108h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A91DC;  }
		/* 820A9108h case    1:*/		return 0x820A910C;
		  /* 820A910Ch */ case    2:  		/* mr R11, R4 */
		/* 820A910Ch case    2:*/		regs.R11 = regs.R4;
		/* 820A910Ch case    2:*/		return 0x820A9110;
		  /* 820A9110h */ case    3:  		/* mr R10, R7 */
		/* 820A9110h case    3:*/		regs.R10 = regs.R7;
		/* 820A9110h case    3:*/		return 0x820A9114;
		  /* 820A9114h */ case    4:  		/* addi R8, R4, 2 */
		/* 820A9114h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R4,0x2);
		/* 820A9114h case    4:*/		return 0x820A9118;
		  /* 820A9118h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820A9118h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9118h case    5:*/		return 0x820A911C;
		  /* 820A911Ch */ case    6:  		/* lbz R6, <#[R10]> */
		/* 820A911Ch case    6:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820A911Ch case    6:*/		return 0x820A9120;
		  /* 820A9120h */ case    7:  		/* subf. R9, R6, R9 */
		/* 820A9120h case    7:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820A9120h case    7:*/		return 0x820A9124;
		  /* 820A9124h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9124h case    8:*/		if ( !regs.CR[0].eq ) { return 0x820A9138;  }
		/* 820A9124h case    8:*/		return 0x820A9128;
		  /* 820A9128h */ case    9:  		/* addi R11, R11, 1 */
		/* 820A9128h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9128h case    9:*/		return 0x820A912C;
		  /* 820A912Ch */ case   10:  		/* addi R10, R10, 1 */
		/* 820A912Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A912Ch case   10:*/		return 0x820A9130;
		  /* 820A9130h */ case   11:  		/* cmpw CR6, R11, R8 */
		/* 820A9130h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820A9130h case   11:*/		return 0x820A9134;
		  /* 820A9134h */ case   12:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9134h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A9118;  }
		/* 820A9134h case   12:*/		return 0x820A9138;
	}
	return 0x820A9138;
} // Block from 820A9104h-820A9138h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A9138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9138);
		  /* 820A9138h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A9138h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A9138h case    0:*/		return 0x820A913C;
		  /* 820A913Ch */ case    1:  		/* bc 12, CR0_EQ, 160 */
		/* 820A913Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820A91DC;  }
		/* 820A913Ch case    1:*/		return 0x820A9140;
		  /* 820A9140h */ case    2:  		/* mr R11, R5 */
		/* 820A9140h case    2:*/		regs.R11 = regs.R5;
		/* 820A9140h case    2:*/		return 0x820A9144;
		  /* 820A9144h */ case    3:  		/* mr R10, R7 */
		/* 820A9144h case    3:*/		regs.R10 = regs.R7;
		/* 820A9144h case    3:*/		return 0x820A9148;
		  /* 820A9148h */ case    4:  		/* addi R8, R5, 2 */
		/* 820A9148h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R5,0x2);
		/* 820A9148h case    4:*/		return 0x820A914C;
		  /* 820A914Ch */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820A914Ch case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A914Ch case    5:*/		return 0x820A9150;
		  /* 820A9150h */ case    6:  		/* lbz R6, <#[R10]> */
		/* 820A9150h case    6:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820A9150h case    6:*/		return 0x820A9154;
		  /* 820A9154h */ case    7:  		/* subf. R9, R6, R9 */
		/* 820A9154h case    7:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820A9154h case    7:*/		return 0x820A9158;
		  /* 820A9158h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9158h case    8:*/		if ( !regs.CR[0].eq ) { return 0x820A916C;  }
		/* 820A9158h case    8:*/		return 0x820A915C;
		  /* 820A915Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 820A915Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A915Ch case    9:*/		return 0x820A9160;
		  /* 820A9160h */ case   10:  		/* addi R10, R10, 1 */
		/* 820A9160h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A9160h case   10:*/		return 0x820A9164;
		  /* 820A9164h */ case   11:  		/* cmpw CR6, R11, R8 */
		/* 820A9164h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820A9164h case   11:*/		return 0x820A9168;
		  /* 820A9168h */ case   12:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9168h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A914C;  }
		/* 820A9168h case   12:*/		return 0x820A916C;
	}
	return 0x820A916C;
} // Block from 820A9138h-820A916Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A916Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A916C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A916C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A916C);
		  /* 820A916Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A916Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A916Ch case    0:*/		return 0x820A9170;
		  /* 820A9170h */ case    1:  		/* bc 12, CR0_EQ, 108 */
		/* 820A9170h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A91DC;  }
		/* 820A9170h case    1:*/		return 0x820A9174;
		  /* 820A9174h */ case    2:  		/* addi R10, R7, 2 */
		/* 820A9174h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0x2);
		/* 820A9174h case    2:*/		return 0x820A9178;
		  /* 820A9178h */ case    3:  		/* addi R11, R31, 2 */
		/* 820A9178h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x2);
		/* 820A9178h case    3:*/		return 0x820A917C;
		  /* 820A917Ch */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820A917Ch case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A917Ch case    4:*/		return 0x820A9180;
		  /* 820A9180h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820A9180h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A9180h case    5:*/		return 0x820A9184;
		  /* 820A9184h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820A9184h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A9184h case    6:*/		return 0x820A9188;
		  /* 820A9188h */ case    7:  		/* subf R9, R8, R9 */
		/* 820A9188h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820A9188h case    7:*/		return 0x820A918C;
		  /* 820A918Ch */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820A918Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x820A91A0;  }
		/* 820A918Ch case    8:*/		return 0x820A9190;
		  /* 820A9190h */ case    9:  		/* addi R11, R11, 1 */
		/* 820A9190h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9190h case    9:*/		return 0x820A9194;
		  /* 820A9194h */ case   10:  		/* addi R10, R10, 1 */
		/* 820A9194h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A9194h case   10:*/		return 0x820A9198;
		  /* 820A9198h */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820A9198h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820A9198h case   11:*/		return 0x820A919C;
		  /* 820A919Ch */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820A919Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820A917C;  }
		/* 820A919Ch case   12:*/		return 0x820A91A0;
	}
	return 0x820A91A0;
} // Block from 820A916Ch-820A91A0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A91A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A91A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A91A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A91A0);
		  /* 820A91A0h */ case    0:  		/* mr R3, R9 */
		/* 820A91A0h case    0:*/		regs.R3 = regs.R9;
		/* 820A91A0h case    0:*/		return 0x820A91A4;
		  /* 820A91A4h */ case    1:  		/* cmplwi CR0, R9, 0 */
		/* 820A91A4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820A91A4h case    1:*/		return 0x820A91A8;
		  /* 820A91A8h */ case    2:  		/* bc 4, CR0_EQ, 96 */
		/* 820A91A8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A9208;  }
		/* 820A91A8h case    2:*/		return 0x820A91AC;
		  /* 820A91ACh */ case    3:  		/* mr R10, R7 */
		/* 820A91ACh case    3:*/		regs.R10 = regs.R7;
		/* 820A91ACh case    3:*/		return 0x820A91B0;
		  /* 820A91B0h */ case    4:  		/* mr R11, R31 */
		/* 820A91B0h case    4:*/		regs.R11 = regs.R31;
		/* 820A91B0h case    4:*/		return 0x820A91B4;
		  /* 820A91B4h */ case    5:  		/* addi R9, R31, 2 */
		/* 820A91B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x2);
		/* 820A91B4h case    5:*/		return 0x820A91B8;
		  /* 820A91B8h */ case    6:  		/* lbz R8, <#[R11]> */
		/* 820A91B8h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A91B8h case    6:*/		return 0x820A91BC;
		  /* 820A91BCh */ case    7:  		/* lbz R7, <#[R10]> */
		/* 820A91BCh case    7:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A91BCh case    7:*/		return 0x820A91C0;
		  /* 820A91C0h */ case    8:  		/* subf. R3, R7, R8 */
		/* 820A91C0h case    8:*/		cpu::op::subf<1>(regs,&regs.R3,regs.R7,regs.R8);
		/* 820A91C0h case    8:*/		return 0x820A91C4;
		  /* 820A91C4h */ case    9:  		/* bc 4, CR0_EQ, 68 */
		/* 820A91C4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x820A9208;  }
		/* 820A91C4h case    9:*/		return 0x820A91C8;
		  /* 820A91C8h */ case   10:  		/* addi R11, R11, 1 */
		/* 820A91C8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A91C8h case   10:*/		return 0x820A91CC;
		  /* 820A91CCh */ case   11:  		/* addi R10, R10, 1 */
		/* 820A91CCh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A91CCh case   11:*/		return 0x820A91D0;
		  /* 820A91D0h */ case   12:  		/* cmpw CR6, R11, R9 */
		/* 820A91D0h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 820A91D0h case   12:*/		return 0x820A91D4;
		  /* 820A91D4h */ case   13:  		/* bc 4, CR6_EQ, -28 */
		/* 820A91D4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820A91B8;  }
		/* 820A91D4h case   13:*/		return 0x820A91D8;
		  /* 820A91D8h */ case   14:  		/* b 48 */
		/* 820A91D8h case   14:*/		return 0x820A9208;
		/* 820A91D8h case   14:*/		return 0x820A91DC;
	}
	return 0x820A91DC;
} // Block from 820A91A0h-820A91DCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A91DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A91DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A91DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A91DC);
		  /* 820A91DCh */ case    0:  		/* lwz R10, <#[R3]> */
		/* 820A91DCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820A91DCh case    0:*/		return 0x820A91E0;
		  /* 820A91E0h */ case    1:  		/* mr R11, R31 */
		/* 820A91E0h case    1:*/		regs.R11 = regs.R31;
		/* 820A91E0h case    1:*/		return 0x820A91E4;
		  /* 820A91E4h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A91E4h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A91E4h case    2:*/		return 0x820A91E8;
		  /* 820A91E8h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820A91E8h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820A91E8h case    3:*/		return 0x820A91EC;
		  /* 820A91ECh */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820A91ECh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A91ECh case    4:*/		return 0x820A91F0;
		  /* 820A91F0h */ case    5:  		/* subf R3, R8, R9 */
		/* 820A91F0h case    5:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R8,regs.R9);
		/* 820A91F0h case    5:*/		return 0x820A91F4;
		  /* 820A91F4h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820A91F4h case    6:*/		if ( regs.CR[0].eq ) { return 0x820A9208;  }
		/* 820A91F4h case    6:*/		return 0x820A91F8;
		  /* 820A91F8h */ case    7:  		/* addi R11, R11, 1 */
		/* 820A91F8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A91F8h case    7:*/		return 0x820A91FC;
		  /* 820A91FCh */ case    8:  		/* addi R10, R10, 1 */
		/* 820A91FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A91FCh case    8:*/		return 0x820A9200;
		  /* 820A9200h */ case    9:  		/* cmpwi CR6, R3, 0 */
		/* 820A9200h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820A9200h case    9:*/		return 0x820A9204;
		  /* 820A9204h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820A9204h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A91E4;  }
		/* 820A9204h case   10:*/		return 0x820A9208;
	}
	return 0x820A9208;
} // Block from 820A91DCh-820A9208h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A9208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9208);
		  /* 820A9208h */ case    0:  		/* ld R31, <#[R1 - 8]> */
		/* 820A9208h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A9208h case    0:*/		return 0x820A920C;
		  /* 820A920Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820A920Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A920Ch case    1:*/		return 0x820A9210;
	}
	return 0x820A9210;
} // Block from 820A9208h-820A9210h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A9210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9210);
		  /* 820A9210h */ case    0:  		/* mfspr R12, LR */
		/* 820A9210h case    0:*/		regs.R12 = regs.LR;
		/* 820A9210h case    0:*/		return 0x820A9214;
		  /* 820A9214h */ case    1:  		/* bl -98232 */
		/* 820A9214h case    1:*/		regs.LR = 0x820A9218; return 0x8209125C;
		/* 820A9214h case    1:*/		return 0x820A9218;
		  /* 820A9218h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A9218h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A9218h case    2:*/		return 0x820A921C;
		  /* 820A921Ch */ case    3:  		/* mr R31, R3 */
		/* 820A921Ch case    3:*/		regs.R31 = regs.R3;
		/* 820A921Ch case    3:*/		return 0x820A9220;
		  /* 820A9220h */ case    4:  		/* mr R3, R4 */
		/* 820A9220h case    4:*/		regs.R3 = regs.R4;
		/* 820A9220h case    4:*/		return 0x820A9224;
		  /* 820A9224h */ case    5:  		/* mr R4, R31 */
		/* 820A9224h case    5:*/		regs.R4 = regs.R31;
		/* 820A9224h case    5:*/		return 0x820A9228;
		  /* 820A9228h */ case    6:  		/* mr R30, R5 */
		/* 820A9228h case    6:*/		regs.R30 = regs.R5;
		/* 820A9228h case    6:*/		return 0x820A922C;
		  /* 820A922Ch */ case    7:  		/* bl -14156 */
		/* 820A922Ch case    7:*/		regs.LR = 0x820A9230; return 0x820A5AE0;
		/* 820A922Ch case    7:*/		return 0x820A9230;
		  /* 820A9230h */ case    8:  		/* or. R29, R3, R3 */
		/* 820A9230h case    8:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820A9230h case    8:*/		return 0x820A9234;
		  /* 820A9234h */ case    9:  		/* bc 12, CR0_LT, 28 */
		/* 820A9234h case    9:*/		if ( regs.CR[0].lt ) { return 0x820A9250;  }
		/* 820A9234h case    9:*/		return 0x820A9238;
		  /* 820A9238h */ case   10:  		/* lwz R3, <#[R31]> */
		/* 820A9238h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820A9238h case   10:*/		return 0x820A923C;
		  /* 820A923Ch */ case   11:  		/* lwz R11, <#[R3]> */
		/* 820A923Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A923Ch case   11:*/		return 0x820A9240;
		  /* 820A9240h */ case   12:  		/* lwz R11, <#[R11 + 12]> */
		/* 820A9240h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A9240h case   12:*/		return 0x820A9244;
		  /* 820A9244h */ case   13:  		/* mtspr CTR, R11 */
		/* 820A9244h case   13:*/		regs.CTR = regs.R11;
		/* 820A9244h case   13:*/		return 0x820A9248;
		  /* 820A9248h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 820A9248h case   14:*/		if ( 1 ) { regs.LR = 0x820A924C; return (uint32)regs.CTR; }
		/* 820A9248h case   14:*/		return 0x820A924C;
		  /* 820A924Ch */ case   15:  		/* stw R3, <#[R30]> */
		/* 820A924Ch case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820A924Ch case   15:*/		return 0x820A9250;
	}
	return 0x820A9250;
} // Block from 820A9210h-820A9250h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A9250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9250);
		  /* 820A9250h */ case    0:  		/* mr R3, R29 */
		/* 820A9250h case    0:*/		regs.R3 = regs.R29;
		/* 820A9250h case    0:*/		return 0x820A9254;
		  /* 820A9254h */ case    1:  		/* addi R1, R1, 112 */
		/* 820A9254h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A9254h case    1:*/		return 0x820A9258;
		  /* 820A9258h */ case    2:  		/* b -98220 */
		/* 820A9258h case    2:*/		return 0x820912AC;
		/* 820A9258h case    2:*/		return 0x820A925C;
		  /* 820A925Ch */ case    3:  		/* nop */
		/* 820A925Ch case    3:*/		cpu::op::nop();
		/* 820A925Ch case    3:*/		return 0x820A9260;
	}
	return 0x820A9260;
} // Block from 820A9250h-820A9260h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A9260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9260);
		  /* 820A9260h */ case    0:  		/* mfspr R12, LR */
		/* 820A9260h case    0:*/		regs.R12 = regs.LR;
		/* 820A9260h case    0:*/		return 0x820A9264;
		  /* 820A9264h */ case    1:  		/* bl -98348 */
		/* 820A9264h case    1:*/		regs.LR = 0x820A9268; return 0x82091238;
		/* 820A9264h case    1:*/		return 0x820A9268;
		  /* 820A9268h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 820A9268h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 820A9268h case    2:*/		return 0x820A926C;
		  /* 820A926Ch */ case    3:  		/* mr R29, R4 */
		/* 820A926Ch case    3:*/		regs.R29 = regs.R4;
		/* 820A926Ch case    3:*/		return 0x820A9270;
		  /* 820A9270h */ case    4:  		/* mr R27, R5 */
		/* 820A9270h case    4:*/		regs.R27 = regs.R5;
		/* 820A9270h case    4:*/		return 0x820A9274;
		  /* 820A9274h */ case    5:  		/* mr R22, R6 */
		/* 820A9274h case    5:*/		regs.R22 = regs.R6;
		/* 820A9274h case    5:*/		return 0x820A9278;
		  /* 820A9278h */ case    6:  		/* mr R26, R7 */
		/* 820A9278h case    6:*/		regs.R26 = regs.R7;
		/* 820A9278h case    6:*/		return 0x820A927C;
		  /* 820A927Ch */ case    7:  		/* mr R25, R8 */
		/* 820A927Ch case    7:*/		regs.R25 = regs.R8;
		/* 820A927Ch case    7:*/		return 0x820A9280;
		  /* 820A9280h */ case    8:  		/* mr R24, R9 */
		/* 820A9280h case    8:*/		regs.R24 = regs.R9;
		/* 820A9280h case    8:*/		return 0x820A9284;
		  /* 820A9284h */ case    9:  		/* rlwinm. R11, R3, 0, 11, 11 */
		/* 820A9284h case    9:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R11,regs.R3);
		/* 820A9284h case    9:*/		return 0x820A9288;
		  /* 820A9288h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 820A9288h case   10:*/		if ( regs.CR[0].eq ) { return 0x820A9298;  }
		/* 820A9288h case   10:*/		return 0x820A928C;
		  /* 820A928Ch */ case   11:  		/* lis R3, -32768 */
		/* 820A928Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A928Ch case   11:*/		return 0x820A9290;
		  /* 820A9290h */ case   12:  		/* ori R3, R3, 16389 */
		/* 820A9290h case   12:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820A9290h case   12:*/		return 0x820A9294;
		  /* 820A9294h */ case   13:  		/* b 556 */
		/* 820A9294h case   13:*/		return 0x820A94C0;
		/* 820A9294h case   13:*/		return 0x820A9298;
	}
	return 0x820A9298;
} // Block from 820A9260h-820A9298h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A9298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9298);
		  /* 820A9298h */ case    0:  		/* li R23, 0 */
		/* 820A9298h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820A9298h case    0:*/		return 0x820A929C;
		  /* 820A929Ch */ case    1:  		/* rlwinm. R11, R3, 0, 14, 14 */
		/* 820A929Ch case    1:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R11,regs.R3);
		/* 820A929Ch case    1:*/		return 0x820A92A0;
		  /* 820A92A0h */ case    2:  		/* mr R28, R23 */
		/* 820A92A0h case    2:*/		regs.R28 = regs.R23;
		/* 820A92A0h case    2:*/		return 0x820A92A4;
		  /* 820A92A4h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 820A92A4h case    3:*/		if ( regs.CR[0].eq ) { return 0x820A92AC;  }
		/* 820A92A4h case    3:*/		return 0x820A92A8;
		  /* 820A92A8h */ case    4:  		/* li R28, 8 */
		/* 820A92A8h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x8);
		/* 820A92A8h case    4:*/		return 0x820A92AC;
	}
	return 0x820A92AC;
} // Block from 820A9298h-820A92ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A92ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A92AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A92AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A92AC);
		  /* 820A92ACh */ case    0:  		/* rlwinm. R11, R3, 0, 30, 30 */
		/* 820A92ACh case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R3);
		/* 820A92ACh case    0:*/		return 0x820A92B0;
		  /* 820A92B0h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 820A92B0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A92B8;  }
		/* 820A92B0h case    1:*/		return 0x820A92B4;
		  /* 820A92B4h */ case    2:  		/* ori R28, R28, 16 */
		/* 820A92B4h case    2:*/		cpu::op::ori<0>(regs,&regs.R28,regs.R28,0x10);
		/* 820A92B4h case    2:*/		return 0x820A92B8;
	}
	return 0x820A92B8;
} // Block from 820A92ACh-820A92B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A92B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A92B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A92B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A92B8);
		  /* 820A92B8h */ case    0:  		/* stw R23, <#[R1 + 112]> */
		/* 820A92B8h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000070) );
		/* 820A92B8h case    0:*/		return 0x820A92BC;
		  /* 820A92BCh */ case    1:  		/* addi R4, R1, 112 */
		/* 820A92BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820A92BCh case    1:*/		return 0x820A92C0;
		  /* 820A92C0h */ case    2:  		/* stw R23, <#[R1 + 116]> */
		/* 820A92C0h case    2:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000074) );
		/* 820A92C0h case    2:*/		return 0x820A92C4;
		  /* 820A92C4h */ case    3:  		/* lis R3, 1 */
		/* 820A92C4h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0x1);
		/* 820A92C4h case    3:*/		return 0x820A92C8;
		  /* 820A92C8h */ case    4:  		/* bl -14312 */
		/* 820A92C8h case    4:*/		regs.LR = 0x820A92CC; return 0x820A5AE0;
		/* 820A92C8h case    4:*/		return 0x820A92CC;
		  /* 820A92CCh */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820A92CCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A92CCh case    5:*/		return 0x820A92D0;
		  /* 820A92D0h */ case    6:  		/* bc 12, CR0_LT, 496 */
		/* 820A92D0h case    6:*/		if ( regs.CR[0].lt ) { return 0x820A94C0;  }
		/* 820A92D0h case    6:*/		return 0x820A92D4;
		  /* 820A92D4h */ case    7:  		/* lwz R3, <#[R1 + 112]> */
		/* 820A92D4h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 820A92D4h case    7:*/		return 0x820A92D8;
		  /* 820A92D8h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 820A92D8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A92D8h case    8:*/		return 0x820A92DC;
		  /* 820A92DCh */ case    9:  		/* lwz R11, <#[R11 + 16]> */
		/* 820A92DCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820A92DCh case    9:*/		return 0x820A92E0;
		  /* 820A92E0h */ case   10:  		/* mtspr CTR, R11 */
		/* 820A92E0h case   10:*/		regs.CTR = regs.R11;
		/* 820A92E0h case   10:*/		return 0x820A92E4;
		  /* 820A92E4h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820A92E4h case   11:*/		if ( 1 ) { regs.LR = 0x820A92E8; return (uint32)regs.CTR; }
		/* 820A92E4h case   11:*/		return 0x820A92E8;
		  /* 820A92E8h */ case   12:  		/* lwz R11, <#[R1 + 112]> */
		/* 820A92E8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820A92E8h case   12:*/		return 0x820A92EC;
		  /* 820A92ECh */ case   13:  		/* mr R31, R3 */
		/* 820A92ECh case   13:*/		regs.R31 = regs.R3;
		/* 820A92ECh case   13:*/		return 0x820A92F0;
		  /* 820A92F0h */ case   14:  		/* mr R3, R11 */
		/* 820A92F0h case   14:*/		regs.R3 = regs.R11;
		/* 820A92F0h case   14:*/		return 0x820A92F4;
		  /* 820A92F4h */ case   15:  		/* lwz R10, <#[R11]> */
		/* 820A92F4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A92F4h case   15:*/		return 0x820A92F8;
		  /* 820A92F8h */ case   16:  		/* lwz R11, <#[R10 + 12]> */
		/* 820A92F8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820A92F8h case   16:*/		return 0x820A92FC;
		  /* 820A92FCh */ case   17:  		/* mtspr CTR, R11 */
		/* 820A92FCh case   17:*/		regs.CTR = regs.R11;
		/* 820A92FCh case   17:*/		return 0x820A9300;
		  /* 820A9300h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820A9300h case   18:*/		if ( 1 ) { regs.LR = 0x820A9304; return (uint32)regs.CTR; }
		/* 820A9300h case   18:*/		return 0x820A9304;
		  /* 820A9304h */ case   19:  		/* li R4, 0 */
		/* 820A9304h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A9304h case   19:*/		return 0x820A9308;
		  /* 820A9308h */ case   20:  		/* mr R5, R31 */
		/* 820A9308h case   20:*/		regs.R5 = regs.R31;
		/* 820A9308h case   20:*/		return 0x820A930C;
		  /* 820A930Ch */ case   21:  		/* bl -98252 */
		/* 820A930Ch case   21:*/		regs.LR = 0x820A9310; return 0x82091340;
		/* 820A930Ch case   21:*/		return 0x820A9310;
		  /* 820A9310h */ case   22:  		/* stw R23, <#[R1 + 120]> */
		/* 820A9310h case   22:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000078) );
		/* 820A9310h case   22:*/		return 0x820A9314;
		  /* 820A9314h */ case   23:  		/* addi R4, R1, 120 */
		/* 820A9314h case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x78);
		/* 820A9314h case   23:*/		return 0x820A9318;
		  /* 820A9318h */ case   24:  		/* mr R3, R29 */
		/* 820A9318h case   24:*/		regs.R3 = regs.R29;
		/* 820A9318h case   24:*/		return 0x820A931C;
		  /* 820A931Ch */ case   25:  		/* bl -39028 */
		/* 820A931Ch case   25:*/		regs.LR = 0x820A9320; return 0x8209FAA8;
		/* 820A931Ch case   25:*/		return 0x820A9320;
		  /* 820A9320h */ case   26:  		/* or. R31, R3, R3 */
		/* 820A9320h case   26:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A9320h case   26:*/		return 0x820A9324;
		  /* 820A9324h */ case   27:  		/* bc 4, CR0_LT, 20 */
		/* 820A9324h case   27:*/		if ( !regs.CR[0].lt ) { return 0x820A9338;  }
		/* 820A9324h case   27:*/		return 0x820A9328;
		  /* 820A9328h */ case   28:  		/* lis R11, -30602 */
		/* 820A9328h case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8876);
		/* 820A9328h case   28:*/		return 0x820A932C;
		  /* 820A932Ch */ case   29:  		/* ori R11, R11, 2905 */
		/* 820A932Ch case   29:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xB59);
		/* 820A932Ch case   29:*/		return 0x820A9330;
		  /* 820A9330h */ case   30:  		/* cmpw CR6, R31, R11 */
		/* 820A9330h case   30:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 820A9330h case   30:*/		return 0x820A9334;
		  /* 820A9334h */ case   31:  		/* bc 4, CR6_EQ, 288 */
		/* 820A9334h case   31:*/		if ( !regs.CR[6].eq ) { return 0x820A9454;  }
		/* 820A9334h case   31:*/		return 0x820A9338;
	}
	return 0x820A9338;
} // Block from 820A92B8h-820A9338h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820A9338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9338);
		  /* 820A9338h */ case    0:  		/* mr R30, R23 */
		/* 820A9338h case    0:*/		regs.R30 = regs.R23;
		/* 820A9338h case    0:*/		return 0x820A933C;
		  /* 820A933Ch */ case    1:  		/* cmplwi CR6, R24, 0 */
		/* 820A933Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820A933Ch case    1:*/		return 0x820A9340;
		  /* 820A9340h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 820A9340h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A9380;  }
		/* 820A9340h case    2:*/		return 0x820A9344;
		  /* 820A9344h */ case    3:  		/* lwz R11, <#[R24]> */
		/* 820A9344h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 820A9344h case    3:*/		return 0x820A9348;
		  /* 820A9348h */ case    4:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820A9348h case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820A9348h case    4:*/		return 0x820A934C;
		  /* 820A934Ch */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 820A934Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820A9378;  }
		/* 820A934Ch case    5:*/		return 0x820A9350;
		  /* 820A9350h */ case    6:  		/* lwz R11, <#[R24 + 4]> */
		/* 820A9350h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 820A9350h case    6:*/		return 0x820A9354;
		  /* 820A9354h */ case    7:  		/* lis R10, -32245 */
		/* 820A9354h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF820B);
		/* 820A9354h case    7:*/		return 0x820A9358;
		  /* 820A9358h */ case    8:  		/* lwz R9, <#[R24 + 8]> */
		/* 820A9358h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 820A9358h case    8:*/		return 0x820A935C;
		  /* 820A935Ch */ case    9:  		/* addi R8, R24, 12 */
		/* 820A935Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R24,0xC);
		/* 820A935Ch case    9:*/		return 0x820A9360;
		  /* 820A9360h */ case   10:  		/* addi R10, R10, -28144 */
		/* 820A9360h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF9210);
		/* 820A9360h case   10:*/		return 0x820A9364;
		  /* 820A9364h */ case   11:  		/* addi R30, R1, 128 */
		/* 820A9364h case   11:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x80);
		/* 820A9364h case   11:*/		return 0x820A9368;
		  /* 820A9368h */ case   12:  		/* stw R8, <#[R1 + 136]> */
		/* 820A9368h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000088) );
		/* 820A9368h case   12:*/		return 0x820A936C;
		  /* 820A936Ch */ case   13:  		/* stw R10, <#[R1 + 140]> */
		/* 820A936Ch case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000008C) );
		/* 820A936Ch case   13:*/		return 0x820A9370;
		  /* 820A9370h */ case   14:  		/* stw R11, <#[R1 + 128]> */
		/* 820A9370h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820A9370h case   14:*/		return 0x820A9374;
		  /* 820A9374h */ case   15:  		/* stw R9, <#[R1 + 132]> */
		/* 820A9374h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000084) );
		/* 820A9374h case   15:*/		return 0x820A9378;
	}
	return 0x820A9378;
} // Block from 820A9338h-820A9378h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A9378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9378);
		  /* 820A9378h */ case    0:  		/* lwz R31, <#[R24 + 16]> */
		/* 820A9378h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + 0x00000010) );
		/* 820A9378h case    0:*/		return 0x820A937C;
		  /* 820A937Ch */ case    1:  		/* b 8 */
		/* 820A937Ch case    1:*/		return 0x820A9384;
		/* 820A937Ch case    1:*/		return 0x820A9380;
	}
	return 0x820A9380;
} // Block from 820A9378h-820A9380h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A9380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9380);
		  /* 820A9380h */ case    0:  		/* mr R31, R23 */
		/* 820A9380h case    0:*/		regs.R31 = regs.R23;
		/* 820A9380h case    0:*/		return 0x820A9384;
	}
	return 0x820A9384;
} // Block from 820A9380h-820A9384h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A9384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9384);
		  /* 820A9384h */ case    0:  		/* lwz R3, <#[R1 + 112]> */
		/* 820A9384h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 820A9384h case    0:*/		return 0x820A9388;
		  /* 820A9388h */ case    1:  		/* lwz R21, <#[R1 + 120]> */
		/* 820A9388h case    1:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000078) );
		/* 820A9388h case    1:*/		return 0x820A938C;
		  /* 820A938Ch */ case    2:  		/* lwz R11, <#[R3]> */
		/* 820A938Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A938Ch case    2:*/		return 0x820A9390;
		  /* 820A9390h */ case    3:  		/* lwz R11, <#[R11 + 16]> */
		/* 820A9390h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820A9390h case    3:*/		return 0x820A9394;
		  /* 820A9394h */ case    4:  		/* mtspr CTR, R11 */
		/* 820A9394h case    4:*/		regs.CTR = regs.R11;
		/* 820A9394h case    4:*/		return 0x820A9398;
		  /* 820A9398h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820A9398h case    5:*/		if ( 1 ) { regs.LR = 0x820A939C; return (uint32)regs.CTR; }
		/* 820A9398h case    5:*/		return 0x820A939C;
		  /* 820A939Ch */ case    6:  		/* lwz R11, <#[R1 + 112]> */
		/* 820A939Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820A939Ch case    6:*/		return 0x820A93A0;
		  /* 820A93A0h */ case    7:  		/* mr R20, R3 */
		/* 820A93A0h case    7:*/		regs.R20 = regs.R3;
		/* 820A93A0h case    7:*/		return 0x820A93A4;
		  /* 820A93A4h */ case    8:  		/* mr R3, R11 */
		/* 820A93A4h case    8:*/		regs.R3 = regs.R11;
		/* 820A93A4h case    8:*/		return 0x820A93A8;
		  /* 820A93A8h */ case    9:  		/* lwz R10, <#[R11]> */
		/* 820A93A8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A93A8h case    9:*/		return 0x820A93AC;
		  /* 820A93ACh */ case   10:  		/* lwz R11, <#[R10 + 12]> */
		/* 820A93ACh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820A93ACh case   10:*/		return 0x820A93B0;
		  /* 820A93B0h */ case   11:  		/* mtspr CTR, R11 */
		/* 820A93B0h case   11:*/		regs.CTR = regs.R11;
		/* 820A93B0h case   11:*/		return 0x820A93B4;
		  /* 820A93B4h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 820A93B4h case   12:*/		if ( 1 ) { regs.LR = 0x820A93B8; return (uint32)regs.CTR; }
		/* 820A93B4h case   12:*/		return 0x820A93B8;
		  /* 820A93B8h */ case   13:  		/* mr R5, R3 */
		/* 820A93B8h case   13:*/		regs.R5 = regs.R3;
		/* 820A93B8h case   13:*/		return 0x820A93BC;
		  /* 820A93BCh */ case   14:  		/* stw R21, <#[R1 + 84]> */
		/* 820A93BCh case   14:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000054) );
		/* 820A93BCh case   14:*/		return 0x820A93C0;
		  /* 820A93C0h */ case   15:  		/* mr R4, R27 */
		/* 820A93C0h case   15:*/		regs.R4 = regs.R27;
		/* 820A93C0h case   15:*/		return 0x820A93C4;
		  /* 820A93C4h */ case   16:  		/* stw R30, <#[R1 + 92]> */
		/* 820A93C4h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 820A93C4h case   16:*/		return 0x820A93C8;
		  /* 820A93C8h */ case   17:  		/* mr R3, R29 */
		/* 820A93C8h case   17:*/		regs.R3 = regs.R29;
		/* 820A93C8h case   17:*/		return 0x820A93CC;
		  /* 820A93CCh */ case   18:  		/* stw R31, <#[R1 + 100]> */
		/* 820A93CCh case   18:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000064) );
		/* 820A93CCh case   18:*/		return 0x820A93D0;
		  /* 820A93D0h */ case   19:  		/* mr R6, R20 */
		/* 820A93D0h case   19:*/		regs.R6 = regs.R20;
		/* 820A93D0h case   19:*/		return 0x820A93D4;
		  /* 820A93D4h */ case   20:  		/* addi R7, R1, 116 */
		/* 820A93D4h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x74);
		/* 820A93D4h case   20:*/		return 0x820A93D8;
		  /* 820A93D8h */ case   21:  		/* mr R8, R28 */
		/* 820A93D8h case   21:*/		regs.R8 = regs.R28;
		/* 820A93D8h case   21:*/		return 0x820A93DC;
		  /* 820A93DCh */ case   22:  		/* mr R9, R26 */
		/* 820A93DCh case   22:*/		regs.R9 = regs.R26;
		/* 820A93DCh case   22:*/		return 0x820A93E0;
		  /* 820A93E0h */ case   23:  		/* mr R10, R25 */
		/* 820A93E0h case   23:*/		regs.R10 = regs.R25;
		/* 820A93E0h case   23:*/		return 0x820A93E4;
		  /* 820A93E4h */ case   24:  		/* bl 683012 */
		/* 820A93E4h case   24:*/		regs.LR = 0x820A93E8; return 0x8214FFE8;
		/* 820A93E4h case   24:*/		return 0x820A93E8;
		  /* 820A93E8h */ case   25:  		/* or. R31, R3, R3 */
		/* 820A93E8h case   25:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A93E8h case   25:*/		return 0x820A93EC;
		  /* 820A93ECh */ case   26:  		/* mr R30, R31 */
		/* 820A93ECh case   26:*/		regs.R30 = regs.R31;
		/* 820A93ECh case   26:*/		return 0x820A93F0;
		  /* 820A93F0h */ case   27:  		/* bc 12, CR0_LT, 108 */
		/* 820A93F0h case   27:*/		if ( regs.CR[0].lt ) { return 0x820A945C;  }
		/* 820A93F0h case   27:*/		return 0x820A93F4;
		  /* 820A93F4h */ case   28:  		/* addi R4, R1, 124 */
		/* 820A93F4h case   28:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x7C);
		/* 820A93F4h case   28:*/		return 0x820A93F8;
		  /* 820A93F8h */ case   29:  		/* lwz R3, <#[R1 + 116]> */
		/* 820A93F8h case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000074) );
		/* 820A93F8h case   29:*/		return 0x820A93FC;
		  /* 820A93FCh */ case   30:  		/* bl -14620 */
		/* 820A93FCh case   30:*/		regs.LR = 0x820A9400; return 0x820A5AE0;
		/* 820A93FCh case   30:*/		return 0x820A9400;
		  /* 820A9400h */ case   31:  		/* or. R31, R3, R3 */
		/* 820A9400h case   31:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820A9400h case   31:*/		return 0x820A9404;
		  /* 820A9404h */ case   32:  		/* bc 12, CR0_LT, 88 */
		/* 820A9404h case   32:*/		if ( regs.CR[0].lt ) { return 0x820A945C;  }
		/* 820A9404h case   32:*/		return 0x820A9408;
		  /* 820A9408h */ case   33:  		/* lwz R3, <#[R1 + 112]> */
		/* 820A9408h case   33:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 820A9408h case   33:*/		return 0x820A940C;
		  /* 820A940Ch */ case   34:  		/* lwz R31, <#[R1 + 116]> */
		/* 820A940Ch case   34:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000074) );
		/* 820A940Ch case   34:*/		return 0x820A9410;
		  /* 820A9410h */ case   35:  		/* lwz R11, <#[R3]> */
		/* 820A9410h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A9410h case   35:*/		return 0x820A9414;
		  /* 820A9414h */ case   36:  		/* lwz R11, <#[R11 + 12]> */
		/* 820A9414h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820A9414h case   36:*/		return 0x820A9418;
		  /* 820A9418h */ case   37:  		/* mtspr CTR, R11 */
		/* 820A9418h case   37:*/		regs.CTR = regs.R11;
		/* 820A9418h case   37:*/		return 0x820A941C;
		  /* 820A941Ch */ case   38:  		/* bcctrl 20, CR0_LT */
		/* 820A941Ch case   38:*/		if ( 1 ) { regs.LR = 0x820A9420; return (uint32)regs.CTR; }
		/* 820A941Ch case   38:*/		return 0x820A9420;
		  /* 820A9420h */ case   39:  		/* lwz R11, <#[R1 + 124]> */
		/* 820A9420h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820A9420h case   39:*/		return 0x820A9424;
		  /* 820A9424h */ case   40:  		/* mr R29, R3 */
		/* 820A9424h case   40:*/		regs.R29 = regs.R3;
		/* 820A9424h case   40:*/		return 0x820A9428;
		  /* 820A9428h */ case   41:  		/* mr R3, R11 */
		/* 820A9428h case   41:*/		regs.R3 = regs.R11;
		/* 820A9428h case   41:*/		return 0x820A942C;
		  /* 820A942Ch */ case   42:  		/* lwz R10, <#[R11]> */
		/* 820A942Ch case   42:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A942Ch case   42:*/		return 0x820A9430;
		  /* 820A9430h */ case   43:  		/* lwz R11, <#[R10 + 12]> */
		/* 820A9430h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820A9430h case   43:*/		return 0x820A9434;
		  /* 820A9434h */ case   44:  		/* mtspr CTR, R11 */
		/* 820A9434h case   44:*/		regs.CTR = regs.R11;
		/* 820A9434h case   44:*/		return 0x820A9438;
		  /* 820A9438h */ case   45:  		/* bcctrl 20, CR0_LT */
		/* 820A9438h case   45:*/		if ( 1 ) { regs.LR = 0x820A943C; return (uint32)regs.CTR; }
		/* 820A9438h case   45:*/		return 0x820A943C;
		  /* 820A943Ch */ case   46:  		/* mr R4, R29 */
		/* 820A943Ch case   46:*/		regs.R4 = regs.R29;
		/* 820A943Ch case   46:*/		return 0x820A9440;
		  /* 820A9440h */ case   47:  		/* mr R5, R31 */
		/* 820A9440h case   47:*/		regs.R5 = regs.R31;
		/* 820A9440h case   47:*/		return 0x820A9444;
		  /* 820A9444h */ case   48:  		/* bl -96916 */
		/* 820A9444h case   48:*/		regs.LR = 0x820A9448; return 0x820919B0;
		/* 820A9444h case   48:*/		return 0x820A9448;
		  /* 820A9448h */ case   49:  		/* lwz R11, <#[R1 + 124]> */
		/* 820A9448h case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820A9448h case   49:*/		return 0x820A944C;
		  /* 820A944Ch */ case   50:  		/* mr R31, R30 */
		/* 820A944Ch case   50:*/		regs.R31 = regs.R30;
		/* 820A944Ch case   50:*/		return 0x820A9450;
		  /* 820A9450h */ case   51:  		/* stw R11, <#[R22]> */
		/* 820A9450h case   51:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 820A9450h case   51:*/		return 0x820A9454;
	}
	return 0x820A9454;
} // Block from 820A9384h-820A9454h (52 instructions)

//////////////////////////////////////////////////////
// Block at 820A9454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9454);
		  /* 820A9454h */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 820A9454h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 820A9454h case    0:*/		return 0x820A9458;
		  /* 820A9458h */ case    1:  		/* bc 4, CR6_LT, 44 */
		/* 820A9458h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820A9484;  }
		/* 820A9458h case    1:*/		return 0x820A945C;
	}
	return 0x820A945C;
} // Block from 820A9454h-820A945Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A945Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A945C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A945C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A945C);
		  /* 820A945Ch */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 820A945Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820A945Ch case    0:*/		return 0x820A9460;
		  /* 820A9460h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 820A9460h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A9484;  }
		/* 820A9460h case    1:*/		return 0x820A9464;
		  /* 820A9464h */ case    2:  		/* lwz R3, <#[R24 + 12]> */
		/* 820A9464h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x0000000C) );
		/* 820A9464h case    2:*/		return 0x820A9468;
		  /* 820A9468h */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 820A9468h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A9468h case    3:*/		return 0x820A946C;
		  /* 820A946Ch */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 820A946Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820A9484;  }
		/* 820A946Ch case    4:*/		return 0x820A9470;
		  /* 820A9470h */ case    5:  		/* lwz R11, <#[R3]> */
		/* 820A9470h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A9470h case    5:*/		return 0x820A9474;
		  /* 820A9474h */ case    6:  		/* lwz R11, <#[R11 + 8]> */
		/* 820A9474h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820A9474h case    6:*/		return 0x820A9478;
		  /* 820A9478h */ case    7:  		/* mtspr CTR, R11 */
		/* 820A9478h case    7:*/		regs.CTR = regs.R11;
		/* 820A9478h case    7:*/		return 0x820A947C;
		  /* 820A947Ch */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820A947Ch case    8:*/		if ( 1 ) { regs.LR = 0x820A9480; return (uint32)regs.CTR; }
		/* 820A947Ch case    8:*/		return 0x820A9480;
		  /* 820A9480h */ case    9:  		/* stw R23, <#[R24 + 12]> */
		/* 820A9480h case    9:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R24 + 0x0000000C) );
		/* 820A9480h case    9:*/		return 0x820A9484;
	}
	return 0x820A9484;
} // Block from 820A945Ch-820A9484h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A9484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9484);
		  /* 820A9484h */ case    0:  		/* lwz R3, <#[R1 + 120]> */
		/* 820A9484h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000078) );
		/* 820A9484h case    0:*/		return 0x820A9488;
		  /* 820A9488h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A9488h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A9488h case    1:*/		return 0x820A948C;
		  /* 820A948Ch */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820A948Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820A94A0;  }
		/* 820A948Ch case    2:*/		return 0x820A9490;
		  /* 820A9490h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820A9490h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A9490h case    3:*/		return 0x820A9494;
		  /* 820A9494h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 820A9494h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820A9494h case    4:*/		return 0x820A9498;
		  /* 820A9498h */ case    5:  		/* mtspr CTR, R11 */
		/* 820A9498h case    5:*/		regs.CTR = regs.R11;
		/* 820A9498h case    5:*/		return 0x820A949C;
		  /* 820A949Ch */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820A949Ch case    6:*/		if ( 1 ) { regs.LR = 0x820A94A0; return (uint32)regs.CTR; }
		/* 820A949Ch case    6:*/		return 0x820A94A0;
	}
	return 0x820A94A0;
} // Block from 820A9484h-820A94A0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A94A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A94A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A94A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A94A0);
		  /* 820A94A0h */ case    0:  		/* lwz R3, <#[R1 + 112]> */
		/* 820A94A0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 820A94A0h case    0:*/		return 0x820A94A4;
		  /* 820A94A4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820A94A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820A94A4h case    1:*/		return 0x820A94A8;
		  /* 820A94A8h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820A94A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820A94BC;  }
		/* 820A94A8h case    2:*/		return 0x820A94AC;
		  /* 820A94ACh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820A94ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820A94ACh case    3:*/		return 0x820A94B0;
		  /* 820A94B0h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 820A94B0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820A94B0h case    4:*/		return 0x820A94B4;
		  /* 820A94B4h */ case    5:  		/* mtspr CTR, R11 */
		/* 820A94B4h case    5:*/		regs.CTR = regs.R11;
		/* 820A94B4h case    5:*/		return 0x820A94B8;
		  /* 820A94B8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820A94B8h case    6:*/		if ( 1 ) { regs.LR = 0x820A94BC; return (uint32)regs.CTR; }
		/* 820A94B8h case    6:*/		return 0x820A94BC;
	}
	return 0x820A94BC;
} // Block from 820A94A0h-820A94BCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A94BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A94BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A94BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A94BC);
		  /* 820A94BCh */ case    0:  		/* mr R3, R31 */
		/* 820A94BCh case    0:*/		regs.R3 = regs.R31;
		/* 820A94BCh case    0:*/		return 0x820A94C0;
	}
	return 0x820A94C0;
} // Block from 820A94BCh-820A94C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A94C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A94C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A94C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A94C0);
		  /* 820A94C0h */ case    0:  		/* addi R1, R1, 256 */
		/* 820A94C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 820A94C0h case    0:*/		return 0x820A94C4;
		  /* 820A94C4h */ case    1:  		/* b -98876 */
		/* 820A94C4h case    1:*/		return 0x82091288;
		/* 820A94C4h case    1:*/		return 0x820A94C8;
	}
	return 0x820A94C8;
} // Block from 820A94C0h-820A94C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A94C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A94C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A94C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A94C8);
		  /* 820A94C8h */ case    0:  		/* mfspr R12, LR */
		/* 820A94C8h case    0:*/		regs.R12 = regs.LR;
		/* 820A94C8h case    0:*/		return 0x820A94CC;
		  /* 820A94CCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A94CCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A94CCh case    1:*/		return 0x820A94D0;
		  /* 820A94D0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A94D0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A94D0h case    2:*/		return 0x820A94D4;
		  /* 820A94D4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A94D4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A94D4h case    3:*/		return 0x820A94D8;
		  /* 820A94D8h */ case    4:  		/* lis R11, -32255 */
		/* 820A94D8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A94D8h case    4:*/		return 0x820A94DC;
		  /* 820A94DCh */ case    5:  		/* mr R31, R3 */
		/* 820A94DCh case    5:*/		regs.R31 = regs.R3;
		/* 820A94DCh case    5:*/		return 0x820A94E0;
		  /* 820A94E0h */ case    6:  		/* lwz R3, <#[R3]> */
		/* 820A94E0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820A94E0h case    6:*/		return 0x820A94E4;
		  /* 820A94E4h */ case    7:  		/* mr R7, R6 */
		/* 820A94E4h case    7:*/		regs.R7 = regs.R6;
		/* 820A94E4h case    7:*/		return 0x820A94E8;
		  /* 820A94E8h */ case    8:  		/* cmpwi CR6, R4, 0 */
		/* 820A94E8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 820A94E8h case    8:*/		return 0x820A94EC;
		  /* 820A94ECh */ case    9:  		/* addi R5, R5, 1100 */
		/* 820A94ECh case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x44C);
		/* 820A94ECh case    9:*/		return 0x820A94F0;
		  /* 820A94F0h */ case   10:  		/* li R4, 0 */
		/* 820A94F0h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A94F0h case   10:*/		return 0x820A94F4;
		  /* 820A94F4h */ case   11:  		/* addi R6, R11, 2492 */
		/* 820A94F4h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x9BC);
		/* 820A94F4h case   11:*/		return 0x820A94F8;
		  /* 820A94F8h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 820A94F8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820A950C;  }
		/* 820A94F8h case   12:*/		return 0x820A94FC;
		  /* 820A94FCh */ case   13:  		/* bl -9068 */
		/* 820A94FCh case   13:*/		regs.LR = 0x820A9500; return 0x820A7190;
		/* 820A94FCh case   13:*/		return 0x820A9500;
		  /* 820A9500h */ case   14:  		/* li R11, 1 */
		/* 820A9500h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A9500h case   14:*/		return 0x820A9504;
		  /* 820A9504h */ case   15:  		/* stw R11, <#[R31 + 84]> */
		/* 820A9504h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820A9504h case   15:*/		return 0x820A9508;
		  /* 820A9508h */ case   16:  		/* b 8 */
		/* 820A9508h case   16:*/		return 0x820A9510;
		/* 820A9508h case   16:*/		return 0x820A950C;
	}
	return 0x820A950C;
} // Block from 820A94C8h-820A950Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A950Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A950C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A950C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A950C);
		  /* 820A950Ch */ case    0:  		/* bl -8628 */
		/* 820A950Ch case    0:*/		regs.LR = 0x820A9510; return 0x820A7358;
		/* 820A950Ch case    0:*/		return 0x820A9510;
	}
	return 0x820A9510;
} // Block from 820A950Ch-820A9510h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A9510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9510);
		  /* 820A9510h */ case    0:  		/* addi R1, R1, 96 */
		/* 820A9510h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A9510h case    0:*/		return 0x820A9514;
		  /* 820A9514h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A9514h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A9514h case    1:*/		return 0x820A9518;
		  /* 820A9518h */ case    2:  		/* mtspr LR, R12 */
		/* 820A9518h case    2:*/		regs.LR = regs.R12;
		/* 820A9518h case    2:*/		return 0x820A951C;
		  /* 820A951Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A951Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A951Ch case    3:*/		return 0x820A9520;
		  /* 820A9520h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A9520h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A9520h case    4:*/		return 0x820A9524;
	}
	return 0x820A9524;
} // Block from 820A9510h-820A9524h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A9524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9524);
		  /* 820A9524h */ case    0:  		/* nop */
		/* 820A9524h case    0:*/		cpu::op::nop();
		/* 820A9524h case    0:*/		return 0x820A9528;
	}
	return 0x820A9528;
} // Block from 820A9524h-820A9528h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A9528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9528);
		  /* 820A9528h */ case    0:  		/* mfspr R12, LR */
		/* 820A9528h case    0:*/		regs.R12 = regs.LR;
		/* 820A9528h case    0:*/		return 0x820A952C;
		  /* 820A952Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A952Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A952Ch case    1:*/		return 0x820A9530;
		  /* 820A9530h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820A9530h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A9530h case    2:*/		return 0x820A9534;
		  /* 820A9534h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820A9534h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820A9534h case    3:*/		return 0x820A9538;
		  /* 820A9538h */ case    4:  		/* lis R4, 9345 */
		/* 820A9538h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A9538h case    4:*/		return 0x820A953C;
		  /* 820A953Ch */ case    5:  		/* mr R31, R3 */
		/* 820A953Ch case    5:*/		regs.R31 = regs.R3;
		/* 820A953Ch case    5:*/		return 0x820A9540;
		  /* 820A9540h */ case    6:  		/* lwz R3, <#[R3]> */
		/* 820A9540h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820A9540h case    6:*/		return 0x820A9544;
		  /* 820A9544h */ case    7:  		/* bl -135692 */
		/* 820A9544h case    7:*/		regs.LR = 0x820A9548; return 0x82088338;
		/* 820A9544h case    7:*/		return 0x820A9548;
		  /* 820A9548h */ case    8:  		/* lwz R31, <#[R31 + 32]> */
		/* 820A9548h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000020) );
		/* 820A9548h case    8:*/		return 0x820A954C;
		  /* 820A954Ch */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 820A954Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820A954Ch case    9:*/		return 0x820A9550;
		  /* 820A9550h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 820A9550h case   10:*/		if ( regs.CR[6].eq ) { return 0x820A9564;  }
		/* 820A9550h case   10:*/		return 0x820A9554;
		  /* 820A9554h */ case   11:  		/* mr R3, R31 */
		/* 820A9554h case   11:*/		regs.R3 = regs.R31;
		/* 820A9554h case   11:*/		return 0x820A9558;
		  /* 820A9558h */ case   12:  		/* bl -48 */
		/* 820A9558h case   12:*/		regs.LR = 0x820A955C; return 0x820A9528;
		/* 820A9558h case   12:*/		return 0x820A955C;
		  /* 820A955Ch */ case   13:  		/* mr R3, R31 */
		/* 820A955Ch case   13:*/		regs.R3 = regs.R31;
		/* 820A955Ch case   13:*/		return 0x820A9560;
		  /* 820A9560h */ case   14:  		/* bl -42496 */
		/* 820A9560h case   14:*/		regs.LR = 0x820A9564; return 0x8209EF60;
		/* 820A9560h case   14:*/		return 0x820A9564;
	}
	return 0x820A9564;
} // Block from 820A9528h-820A9564h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A9564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9564);
		  /* 820A9564h */ case    0:  		/* addi R1, R1, 96 */
		/* 820A9564h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820A9564h case    0:*/		return 0x820A9568;
		  /* 820A9568h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A9568h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A9568h case    1:*/		return 0x820A956C;
		  /* 820A956Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820A956Ch case    2:*/		regs.LR = regs.R12;
		/* 820A956Ch case    2:*/		return 0x820A9570;
		  /* 820A9570h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A9570h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A9570h case    3:*/		return 0x820A9574;
		  /* 820A9574h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A9574h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A9574h case    4:*/		return 0x820A9578;
	}
	return 0x820A9578;
} // Block from 820A9564h-820A9578h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A9578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9578);
		  /* 820A9578h */ case    0:  		/* mfspr R12, LR */
		/* 820A9578h case    0:*/		regs.R12 = regs.LR;
		/* 820A9578h case    0:*/		return 0x820A957C;
		  /* 820A957Ch */ case    1:  		/* bl -99120 */
		/* 820A957Ch case    1:*/		regs.LR = 0x820A9580; return 0x8209124C;
		/* 820A957Ch case    1:*/		return 0x820A9580;
		  /* 820A9580h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820A9580h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820A9580h case    2:*/		return 0x820A9584;
		  /* 820A9584h */ case    3:  		/* mr R28, R3 */
		/* 820A9584h case    3:*/		regs.R28 = regs.R3;
		/* 820A9584h case    3:*/		return 0x820A9588;
		  /* 820A9588h */ case    4:  		/* mr R3, R4 */
		/* 820A9588h case    4:*/		regs.R3 = regs.R4;
		/* 820A9588h case    4:*/		return 0x820A958C;
		  /* 820A958Ch */ case    5:  		/* mr R31, R4 */
		/* 820A958Ch case    5:*/		regs.R31 = regs.R4;
		/* 820A958Ch case    5:*/		return 0x820A9590;
		  /* 820A9590h */ case    6:  		/* mr R26, R5 */
		/* 820A9590h case    6:*/		regs.R26 = regs.R5;
		/* 820A9590h case    6:*/		return 0x820A9594;
		  /* 820A9594h */ case    7:  		/* mr R25, R6 */
		/* 820A9594h case    7:*/		regs.R25 = regs.R6;
		/* 820A9594h case    7:*/		return 0x820A9598;
	}
	return 0x820A9598;
} // Block from 820A9578h-820A9598h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A9598h
// Function '?RegisterHash@D3DXShader@@YAIPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9598);
		  /* 820A9598h */ case    0:  		/* bl -2600 */
		/* 820A9598h case    0:*/		regs.LR = 0x820A959C; return 0x820A8B70;
		/* 820A9598h case    0:*/		return 0x820A959C;
		  /* 820A959Ch */ case    1:  		/* mr R27, R3 */
		/* 820A959Ch case    1:*/		regs.R27 = regs.R3;
		/* 820A959Ch case    1:*/		return 0x820A95A0;
		  /* 820A95A0h */ case    2:  		/* mr R11, R31 */
		/* 820A95A0h case    2:*/		regs.R11 = regs.R31;
		/* 820A95A0h case    2:*/		return 0x820A95A4;
		  /* 820A95A4h */ case    3:  		/* lbz R10, <#[R11]> */
		/* 820A95A4h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A95A4h case    3:*/		return 0x820A95A8;
		  /* 820A95A8h */ case    4:  		/* addi R11, R11, 1 */
		/* 820A95A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A95A8h case    4:*/		return 0x820A95AC;
		  /* 820A95ACh */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 820A95ACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820A95ACh case    5:*/		return 0x820A95B0;
		  /* 820A95B0h */ case    6:  		/* bc 4, CR6_EQ, -12 */
		/* 820A95B0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820A95A4;  }
		/* 820A95B0h case    6:*/		return 0x820A95B4;
		  /* 820A95B4h */ case    7:  		/* subf R11, R31, R11 */
		/* 820A95B4h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820A95B4h case    7:*/		return 0x820A95B8;
		  /* 820A95B8h */ case    8:  		/* lis R4, 9345 */
		/* 820A95B8h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A95B8h case    8:*/		return 0x820A95BC;
		  /* 820A95BCh */ case    9:  		/* addi R11, R11, -1 */
		/* 820A95BCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A95BCh case    9:*/		return 0x820A95C0;
		  /* 820A95C0h */ case   10:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820A95C0h case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820A95C0h case   10:*/		return 0x820A95C4;
		  /* 820A95C4h */ case   11:  		/* addi R29, R11, 1 */
		/* 820A95C4h case   11:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1);
		/* 820A95C4h case   11:*/		return 0x820A95C8;
		  /* 820A95C8h */ case   12:  		/* mr R3, R29 */
		/* 820A95C8h case   12:*/		regs.R3 = regs.R29;
		/* 820A95C8h case   12:*/		return 0x820A95CC;
		  /* 820A95CCh */ case   13:  		/* bl -136140 */
		/* 820A95CCh case   13:*/		regs.LR = 0x820A95D0; return 0x82088200;
		/* 820A95CCh case   13:*/		return 0x820A95D0;
		  /* 820A95D0h */ case   14:  		/* or. R30, R3, R3 */
		/* 820A95D0h case   14:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820A95D0h case   14:*/		return 0x820A95D4;
		  /* 820A95D4h */ case   15:  		/* bc 4, CR0_EQ, 16 */
		/* 820A95D4h case   15:*/		if ( !regs.CR[0].eq ) { return 0x820A95E4;  }
		/* 820A95D4h case   15:*/		return 0x820A95D8;
		  /* 820A95D8h */ case   16:  		/* lis R3, -32761 */
		/* 820A95D8h case   16:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820A95D8h case   16:*/		return 0x820A95DC;
		  /* 820A95DCh */ case   17:  		/* ori R3, R3, 14 */
		/* 820A95DCh case   17:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820A95DCh case   17:*/		return 0x820A95E0;
		  /* 820A95E0h */ case   18:  		/* b 104 */
		/* 820A95E0h case   18:*/		return 0x820A9648;
		/* 820A95E0h case   18:*/		return 0x820A95E4;
	}
	return 0x820A95E4;
} // Block from 820A9598h-820A95E4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A95E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A95E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A95E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A95E4);
		  /* 820A95E4h */ case    0:  		/* mr R5, R29 */
		/* 820A95E4h case    0:*/		regs.R5 = regs.R29;
		/* 820A95E4h case    0:*/		return 0x820A95E8;
		  /* 820A95E8h */ case    1:  		/* mr R4, R31 */
		/* 820A95E8h case    1:*/		regs.R4 = regs.R31;
		/* 820A95E8h case    1:*/		return 0x820A95EC;
		  /* 820A95ECh */ case    2:  		/* mr R3, R30 */
		/* 820A95ECh case    2:*/		regs.R3 = regs.R30;
		/* 820A95ECh case    2:*/		return 0x820A95F0;
		  /* 820A95F0h */ case    3:  		/* bl -97344 */
		/* 820A95F0h case    3:*/		regs.LR = 0x820A95F4; return 0x820919B0;
		/* 820A95F0h case    3:*/		return 0x820A95F4;
		  /* 820A95F4h */ case    4:  		/* lis R4, 9345 */
		/* 820A95F4h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A95F4h case    4:*/		return 0x820A95F8;
		  /* 820A95F8h */ case    5:  		/* li R3, 36 */
		/* 820A95F8h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x24);
		/* 820A95F8h case    5:*/		return 0x820A95FC;
		  /* 820A95FCh */ case    6:  		/* bl -136188 */
		/* 820A95FCh case    6:*/		regs.LR = 0x820A9600; return 0x82088200;
		/* 820A95FCh case    6:*/		return 0x820A9600;
		  /* 820A9600h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 820A9600h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A9600h case    7:*/		return 0x820A9604;
		  /* 820A9604h */ case    8:  		/* bc 12, CR0_EQ, 44 */
		/* 820A9604h case    8:*/		if ( regs.CR[0].eq ) { return 0x820A9630;  }
		/* 820A9604h case    8:*/		return 0x820A9608;
		  /* 820A9608h */ case    9:  		/* rlwinm R10, R27, 2, 0, 29 */
		/* 820A9608h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R27);
		/* 820A9608h case    9:*/		return 0x820A960C;
		  /* 820A960Ch */ case   10:  		/* li R9, 0 */
		/* 820A960Ch case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820A960Ch case   10:*/		return 0x820A9610;
		  /* 820A9610h */ case   11:  		/* mr R11, R3 */
		/* 820A9610h case   11:*/		regs.R11 = regs.R3;
		/* 820A9610h case   11:*/		return 0x820A9614;
		  /* 820A9614h */ case   12:  		/* lwzx R10, <#[R10 + R28]> */
		/* 820A9614h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 820A9614h case   12:*/		return 0x820A9618;
	}
	return 0x820A9618;
} // Block from 820A95E4h-820A9618h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A9618h
// Function '?GetElement@CFragmentRegisterAllocator@D3DXShader@@QAAPAVCRegisterEntryNode@2@PBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9618);
		  /* 820A9618h */ case    0:  		/* stw R9, <#[R3 + 12]> */
		/* 820A9618h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 820A9618h case    0:*/		return 0x820A961C;
		  /* 820A961Ch */ case    1:  		/* stw R30, <#[R3]> */
		/* 820A961Ch case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 820A961Ch case    1:*/		return 0x820A9620;
		  /* 820A9620h */ case    2:  		/* stw R26, <#[R3 + 4]> */
		/* 820A9620h case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000004) );
		/* 820A9620h case    2:*/		return 0x820A9624;
		  /* 820A9624h */ case    3:  		/* stw R25, <#[R3 + 8]> */
		/* 820A9624h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000008) );
		/* 820A9624h case    3:*/		return 0x820A9628;
		  /* 820A9628h */ case    4:  		/* stw R10, <#[R3 + 32]> */
		/* 820A9628h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 820A9628h case    4:*/		return 0x820A962C;
		  /* 820A962Ch */ case    5:  		/* b 8 */
		/* 820A962Ch case    5:*/		return 0x820A9634;
		/* 820A962Ch case    5:*/		return 0x820A9630;
	}
	return 0x820A9630;
} // Block from 820A9618h-820A9630h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A9630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9630);
		  /* 820A9630h */ case    0:  		/* li R11, 0 */
		/* 820A9630h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A9630h case    0:*/		return 0x820A9634;
	}
	return 0x820A9634;
} // Block from 820A9630h-820A9634h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A9634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9634);
		  /* 820A9634h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820A9634h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820A9634h case    0:*/		return 0x820A9638;
		  /* 820A9638h */ case    1:  		/* bc 12, CR6_EQ, -96 */
		/* 820A9638h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A95D8;  }
		/* 820A9638h case    1:*/		return 0x820A963C;
		  /* 820A963Ch */ case    2:  		/* rlwinm R10, R27, 2, 0, 29 */
		/* 820A963Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R27);
		/* 820A963Ch case    2:*/		return 0x820A9640;
		  /* 820A9640h */ case    3:  		/* li R3, 0 */
		/* 820A9640h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A9640h case    3:*/		return 0x820A9644;
		  /* 820A9644h */ case    4:  		/* stwx R11, <#[R10 + R28]> */
		/* 820A9644h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 820A9644h case    4:*/		return 0x820A9648;
	}
	return 0x820A9648;
} // Block from 820A9634h-820A9648h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A9648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9648);
		  /* 820A9648h */ case    0:  		/* addi R1, R1, 144 */
		/* 820A9648h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820A9648h case    0:*/		return 0x820A964C;
		  /* 820A964Ch */ case    1:  		/* b -99248 */
		/* 820A964Ch case    1:*/		return 0x8209129C;
		/* 820A964Ch case    1:*/		return 0x820A9650;
	}
	return 0x820A9650;
} // Block from 820A9648h-820A9650h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A9650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9650);
		  /* 820A9650h */ case    0:  		/* mfspr R12, LR */
		/* 820A9650h case    0:*/		regs.R12 = regs.LR;
		/* 820A9650h case    0:*/		return 0x820A9654;
		  /* 820A9654h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820A9654h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A9654h case    1:*/		return 0x820A9658;
		  /* 820A9658h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820A9658h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A9658h case    2:*/		return 0x820A965C;
		  /* 820A965Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820A965Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A965Ch case    3:*/		return 0x820A9660;
		  /* 820A9660h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820A9660h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820A9660h case    4:*/		return 0x820A9664;
		  /* 820A9664h */ case    5:  		/* mr R30, R4 */
		/* 820A9664h case    5:*/		regs.R30 = regs.R4;
		/* 820A9664h case    5:*/		return 0x820A9668;
		  /* 820A9668h */ case    6:  		/* li R5, 28 */
		/* 820A9668h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 820A9668h case    6:*/		return 0x820A966C;
		  /* 820A966Ch */ case    7:  		/* li R4, 0 */
		/* 820A966Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A966Ch case    7:*/		return 0x820A9670;
		  /* 820A9670h */ case    8:  		/* mr R31, R3 */
		/* 820A9670h case    8:*/		regs.R31 = regs.R3;
		/* 820A9670h case    8:*/		return 0x820A9674;
		  /* 820A9674h */ case    9:  		/* bl -99124 */
		/* 820A9674h case    9:*/		regs.LR = 0x820A9678; return 0x82091340;
		/* 820A9674h case    9:*/		return 0x820A9678;
		  /* 820A9678h */ case   10:  		/* li R5, 28 */
		/* 820A9678h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 820A9678h case   10:*/		return 0x820A967C;
		  /* 820A967Ch */ case   11:  		/* li R4, 0 */
		/* 820A967Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A967Ch case   11:*/		return 0x820A9680;
		  /* 820A9680h */ case   12:  		/* addi R3, R31, 28 */
		/* 820A9680h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x1C);
		/* 820A9680h case   12:*/		return 0x820A9684;
		  /* 820A9684h */ case   13:  		/* bl -99140 */
		/* 820A9684h case   13:*/		regs.LR = 0x820A9688; return 0x82091340;
		/* 820A9684h case   13:*/		return 0x820A9688;
		  /* 820A9688h */ case   14:  		/* li R5, 28 */
		/* 820A9688h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 820A9688h case   14:*/		return 0x820A968C;
		  /* 820A968Ch */ case   15:  		/* li R4, 0 */
		/* 820A968Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A968Ch case   15:*/		return 0x820A9690;
	}
	return 0x820A9690;
} // Block from 820A9650h-820A9690h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A9690h
// Function '?GetElements@CFragmentRegisterAllocator@D3DXShader@@QAAXPAPAVCRegisterEntryNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9690);
		  /* 820A9690h */ case    0:  		/* addi R3, R31, 56 */
		/* 820A9690h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x38);
		/* 820A9690h case    0:*/		return 0x820A9694;
		  /* 820A9694h */ case    1:  		/* bl -99156 */
		/* 820A9694h case    1:*/		regs.LR = 0x820A9698; return 0x82091340;
		/* 820A9694h case    1:*/		return 0x820A9698;
		  /* 820A9698h */ case    2:  		/* li R5, 28 */
		/* 820A9698h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 820A9698h case    2:*/		return 0x820A969C;
		  /* 820A969Ch */ case    3:  		/* li R4, 0 */
		/* 820A969Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A969Ch case    3:*/		return 0x820A96A0;
		  /* 820A96A0h */ case    4:  		/* addi R3, R31, 84 */
		/* 820A96A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x54);
		/* 820A96A0h case    4:*/		return 0x820A96A4;
		  /* 820A96A4h */ case    5:  		/* bl -99172 */
		/* 820A96A4h case    5:*/		regs.LR = 0x820A96A8; return 0x82091340;
		/* 820A96A4h case    5:*/		return 0x820A96A8;
		  /* 820A96A8h */ case    6:  		/* li R5, 28 */
		/* 820A96A8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 820A96A8h case    6:*/		return 0x820A96AC;
		  /* 820A96ACh */ case    7:  		/* li R4, 0 */
		/* 820A96ACh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A96ACh case    7:*/		return 0x820A96B0;
		  /* 820A96B0h */ case    8:  		/* addi R3, R31, 112 */
		/* 820A96B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x70);
		/* 820A96B0h case    8:*/		return 0x820A96B4;
		  /* 820A96B4h */ case    9:  		/* bl -99188 */
		/* 820A96B4h case    9:*/		regs.LR = 0x820A96B8; return 0x82091340;
		/* 820A96B4h case    9:*/		return 0x820A96B8;
		  /* 820A96B8h */ case   10:  		/* li R11, 0 */
		/* 820A96B8h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A96B8h case   10:*/		return 0x820A96BC;
		  /* 820A96BCh */ case   11:  		/* stw R30, <#[R31 + 180]> */
		/* 820A96BCh case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000000B4) );
		/* 820A96BCh case   11:*/		return 0x820A96C0;
		  /* 820A96C0h */ case   12:  		/* cmpwi CR6, R30, 4 */
		/* 820A96C0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 820A96C0h case   12:*/		return 0x820A96C4;
		  /* 820A96C4h */ case   13:  		/* stw R11, <#[R31 + 140]> */
		/* 820A96C4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 820A96C4h case   13:*/		return 0x820A96C8;
		  /* 820A96C8h */ case   14:  		/* stw R11, <#[R31 + 144]> */
		/* 820A96C8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 820A96C8h case   14:*/		return 0x820A96CC;
		  /* 820A96CCh */ case   15:  		/* stw R11, <#[R31 + 148]> */
		/* 820A96CCh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000094) );
		/* 820A96CCh case   15:*/		return 0x820A96D0;
		  /* 820A96D0h */ case   16:  		/* stw R11, <#[R31 + 152]> */
		/* 820A96D0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000098) );
		/* 820A96D0h case   16:*/		return 0x820A96D4;
		  /* 820A96D4h */ case   17:  		/* stw R11, <#[R31 + 172]> */
		/* 820A96D4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000AC) );
		/* 820A96D4h case   17:*/		return 0x820A96D8;
	}
	return 0x820A96D8;
} // Block from 820A9690h-820A96D8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820A96D8h
// Function '??0CAssembler@D3DXShader@@QAA@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A96D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A96D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A96D8);
		  /* 820A96D8h */ case    0:  		/* stw R11, <#[R31 + 156]> */
		/* 820A96D8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000009C) );
		/* 820A96D8h case    0:*/		return 0x820A96DC;
		  /* 820A96DCh */ case    1:  		/* stw R11, <#[R31 + 160]> */
		/* 820A96DCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000A0) );
		/* 820A96DCh case    1:*/		return 0x820A96E0;
		  /* 820A96E0h */ case    2:  		/* stw R11, <#[R31 + 164]> */
		/* 820A96E0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000A4) );
		/* 820A96E0h case    2:*/		return 0x820A96E4;
		  /* 820A96E4h */ case    3:  		/* stw R11, <#[R31 + 168]> */
		/* 820A96E4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000A8) );
		/* 820A96E4h case    3:*/		return 0x820A96E8;
		  /* 820A96E8h */ case    4:  		/* stw R11, <#[R31 + 176]> */
		/* 820A96E8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000B0) );
		/* 820A96E8h case    4:*/		return 0x820A96EC;
		  /* 820A96ECh */ case    5:  		/* bc 12, CR6_LT, 20 */
		/* 820A96ECh case    5:*/		if ( regs.CR[6].lt ) { return 0x820A9700;  }
		/* 820A96ECh case    5:*/		return 0x820A96F0;
		  /* 820A96F0h */ case    6:  		/* cmpwi CR6, R30, 5 */
		/* 820A96F0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000005);
		/* 820A96F0h case    6:*/		return 0x820A96F4;
		  /* 820A96F4h */ case    7:  		/* bc 12, CR6_GT, 12 */
		/* 820A96F4h case    7:*/		if ( regs.CR[6].gt ) { return 0x820A9700;  }
		/* 820A96F4h case    7:*/		return 0x820A96F8;
		  /* 820A96F8h */ case    8:  		/* li R11, 1 */
		/* 820A96F8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A96F8h case    8:*/		return 0x820A96FC;
		  /* 820A96FCh */ case    9:  		/* stw R11, <#[R31 + 176]> */
		/* 820A96FCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000B0) );
		/* 820A96FCh case    9:*/		return 0x820A9700;
	}
	return 0x820A9700;
} // Block from 820A96D8h-820A9700h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A9700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9700);
		  /* 820A9700h */ case    0:  		/* mr R3, R31 */
		/* 820A9700h case    0:*/		regs.R3 = regs.R31;
		/* 820A9700h case    0:*/		return 0x820A9704;
		  /* 820A9704h */ case    1:  		/* addi R1, R1, 112 */
		/* 820A9704h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820A9704h case    1:*/		return 0x820A9708;
	}
	return 0x820A9708;
} // Block from 820A9700h-820A9708h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A9708h
// Function '?NonNull@CAssembler@D3DXShader@@IAAPAVCNode@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9708);
		  /* 820A9708h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 820A9708h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820A9708h case    0:*/		return 0x820A970C;
		  /* 820A970Ch */ case    1:  		/* mtspr LR, R12 */
		/* 820A970Ch case    1:*/		regs.LR = regs.R12;
		/* 820A970Ch case    1:*/		return 0x820A9710;
		  /* 820A9710h */ case    2:  		/* ld R30, <#[R1 - 24]> */
		/* 820A9710h case    2:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820A9710h case    2:*/		return 0x820A9714;
		  /* 820A9714h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820A9714h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820A9714h case    3:*/		return 0x820A9718;
		  /* 820A9718h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820A9718h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820A9718h case    4:*/		return 0x820A971C;
	}
	return 0x820A971C;
} // Block from 820A9708h-820A971Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A971Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A971C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A971C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A971C);
		  /* 820A971Ch */ case    0:  		/* nop */
		/* 820A971Ch case    0:*/		cpu::op::nop();
		/* 820A971Ch case    0:*/		return 0x820A9720;
	}
	return 0x820A9720;
} // Block from 820A971Ch-820A9720h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A9720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9720);
		  /* 820A9720h */ case    0:  		/* mfspr R12, LR */
		/* 820A9720h case    0:*/		regs.R12 = regs.LR;
		/* 820A9720h case    0:*/		return 0x820A9724;
		  /* 820A9724h */ case    1:  		/* bl -99532 */
		/* 820A9724h case    1:*/		regs.LR = 0x820A9728; return 0x82091258;
		/* 820A9724h case    1:*/		return 0x820A9728;
		  /* 820A9728h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820A9728h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820A9728h case    2:*/		return 0x820A972C;
		  /* 820A972Ch */ case    3:  		/* mr R31, R3 */
		/* 820A972Ch case    3:*/		regs.R31 = regs.R3;
		/* 820A972Ch case    3:*/		return 0x820A9730;
		  /* 820A9730h */ case    4:  		/* addi R30, R3, 112 */
		/* 820A9730h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x70);
		/* 820A9730h case    4:*/		return 0x820A9734;
		  /* 820A9734h */ case    5:  		/* li R29, 7 */
		/* 820A9734h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x7);
		/* 820A9734h case    5:*/		return 0x820A9738;
		  /* 820A9738h */ case    6:  		/* lwz R28, <#[R30]> */
		/* 820A9738h case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 820A9738h case    6:*/		return 0x820A973C;
		  /* 820A973Ch */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 820A973Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820A973Ch case    7:*/		return 0x820A9740;
		  /* 820A9740h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 820A9740h case    8:*/		if ( regs.CR[6].eq ) { return 0x820A9758;  }
		/* 820A9740h case    8:*/		return 0x820A9744;
		  /* 820A9744h */ case    9:  		/* mr R3, R28 */
		/* 820A9744h case    9:*/		regs.R3 = regs.R28;
		/* 820A9744h case    9:*/		return 0x820A9748;
		  /* 820A9748h */ case   10:  		/* bl -544 */
		/* 820A9748h case   10:*/		regs.LR = 0x820A974C; return 0x820A9528;
		/* 820A9748h case   10:*/		return 0x820A974C;
		  /* 820A974Ch */ case   11:  		/* lis R4, 9345 */
		/* 820A974Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A974Ch case   11:*/		return 0x820A9750;
		  /* 820A9750h */ case   12:  		/* mr R3, R28 */
		/* 820A9750h case   12:*/		regs.R3 = regs.R28;
		/* 820A9750h case   12:*/		return 0x820A9754;
		  /* 820A9754h */ case   13:  		/* bl -136220 */
		/* 820A9754h case   13:*/		regs.LR = 0x820A9758; return 0x82088338;
		/* 820A9754h case   13:*/		return 0x820A9758;
	}
	return 0x820A9758;
} // Block from 820A9720h-820A9758h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820A9758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9758);
		  /* 820A9758h */ case    0:  		/* addic. R29, R29, -1 */
		/* 820A9758h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820A9758h case    0:*/		return 0x820A975C;
		  /* 820A975Ch */ case    1:  		/* addi R30, R30, 4 */
		/* 820A975Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820A975Ch case    1:*/		return 0x820A9760;
		  /* 820A9760h */ case    2:  		/* bc 4, CR0_EQ, -40 */
		/* 820A9760h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A9738;  }
		/* 820A9760h case    2:*/		return 0x820A9764;
		  /* 820A9764h */ case    3:  		/* addi R30, R31, 84 */
		/* 820A9764h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x54);
		/* 820A9764h case    3:*/		return 0x820A9768;
		  /* 820A9768h */ case    4:  		/* li R29, 7 */
		/* 820A9768h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x7);
		/* 820A9768h case    4:*/		return 0x820A976C;
		  /* 820A976Ch */ case    5:  		/* lwz R28, <#[R30]> */
		/* 820A976Ch case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 820A976Ch case    5:*/		return 0x820A9770;
		  /* 820A9770h */ case    6:  		/* cmplwi CR6, R28, 0 */
		/* 820A9770h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820A9770h case    6:*/		return 0x820A9774;
		  /* 820A9774h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 820A9774h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A978C;  }
		/* 820A9774h case    7:*/		return 0x820A9778;
		  /* 820A9778h */ case    8:  		/* mr R3, R28 */
		/* 820A9778h case    8:*/		regs.R3 = regs.R28;
		/* 820A9778h case    8:*/		return 0x820A977C;
		  /* 820A977Ch */ case    9:  		/* bl -596 */
		/* 820A977Ch case    9:*/		regs.LR = 0x820A9780; return 0x820A9528;
		/* 820A977Ch case    9:*/		return 0x820A9780;
	}
	return 0x820A9780;
} // Block from 820A9758h-820A9780h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A9780h
// Function '?DecodeMask@CAssembler@D3DXShader@@IAAKPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9780);
		  /* 820A9780h */ case    0:  		/* lis R4, 9345 */
		/* 820A9780h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A9780h case    0:*/		return 0x820A9784;
		  /* 820A9784h */ case    1:  		/* mr R3, R28 */
		/* 820A9784h case    1:*/		regs.R3 = regs.R28;
		/* 820A9784h case    1:*/		return 0x820A9788;
		  /* 820A9788h */ case    2:  		/* bl -136272 */
		/* 820A9788h case    2:*/		regs.LR = 0x820A978C; return 0x82088338;
		/* 820A9788h case    2:*/		return 0x820A978C;
	}
	return 0x820A978C;
} // Block from 820A9780h-820A978Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A978Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A978C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A978C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A978C);
		  /* 820A978Ch */ case    0:  		/* addic. R29, R29, -1 */
		/* 820A978Ch case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820A978Ch case    0:*/		return 0x820A9790;
		  /* 820A9790h */ case    1:  		/* addi R30, R30, 4 */
		/* 820A9790h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820A9790h case    1:*/		return 0x820A9794;
		  /* 820A9794h */ case    2:  		/* bc 4, CR0_EQ, -40 */
		/* 820A9794h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A976C;  }
		/* 820A9794h case    2:*/		return 0x820A9798;
		  /* 820A9798h */ case    3:  		/* addi R30, R31, 56 */
		/* 820A9798h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x38);
		/* 820A9798h case    3:*/		return 0x820A979C;
		  /* 820A979Ch */ case    4:  		/* li R29, 7 */
		/* 820A979Ch case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x7);
		/* 820A979Ch case    4:*/		return 0x820A97A0;
		  /* 820A97A0h */ case    5:  		/* lwz R28, <#[R30]> */
		/* 820A97A0h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 820A97A0h case    5:*/		return 0x820A97A4;
		  /* 820A97A4h */ case    6:  		/* cmplwi CR6, R28, 0 */
		/* 820A97A4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820A97A4h case    6:*/		return 0x820A97A8;
		  /* 820A97A8h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 820A97A8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820A97C0;  }
		/* 820A97A8h case    7:*/		return 0x820A97AC;
		  /* 820A97ACh */ case    8:  		/* mr R3, R28 */
		/* 820A97ACh case    8:*/		regs.R3 = regs.R28;
		/* 820A97ACh case    8:*/		return 0x820A97B0;
		  /* 820A97B0h */ case    9:  		/* bl -648 */
		/* 820A97B0h case    9:*/		regs.LR = 0x820A97B4; return 0x820A9528;
		/* 820A97B0h case    9:*/		return 0x820A97B4;
		  /* 820A97B4h */ case   10:  		/* lis R4, 9345 */
		/* 820A97B4h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A97B4h case   10:*/		return 0x820A97B8;
		  /* 820A97B8h */ case   11:  		/* mr R3, R28 */
		/* 820A97B8h case   11:*/		regs.R3 = regs.R28;
		/* 820A97B8h case   11:*/		return 0x820A97BC;
		  /* 820A97BCh */ case   12:  		/* bl -136324 */
		/* 820A97BCh case   12:*/		regs.LR = 0x820A97C0; return 0x82088338;
		/* 820A97BCh case   12:*/		return 0x820A97C0;
	}
	return 0x820A97C0;
} // Block from 820A978Ch-820A97C0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A97C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A97C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A97C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A97C0);
		  /* 820A97C0h */ case    0:  		/* addic. R29, R29, -1 */
		/* 820A97C0h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820A97C0h case    0:*/		return 0x820A97C4;
		  /* 820A97C4h */ case    1:  		/* addi R30, R30, 4 */
		/* 820A97C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820A97C4h case    1:*/		return 0x820A97C8;
		  /* 820A97C8h */ case    2:  		/* bc 4, CR0_EQ, -40 */
		/* 820A97C8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A97A0;  }
		/* 820A97C8h case    2:*/		return 0x820A97CC;
		  /* 820A97CCh */ case    3:  		/* addi R30, R31, 28 */
		/* 820A97CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x1C);
		/* 820A97CCh case    3:*/		return 0x820A97D0;
		  /* 820A97D0h */ case    4:  		/* li R29, 7 */
		/* 820A97D0h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x7);
		/* 820A97D0h case    4:*/		return 0x820A97D4;
		  /* 820A97D4h */ case    5:  		/* lwz R28, <#[R30]> */
		/* 820A97D4h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 820A97D4h case    5:*/		return 0x820A97D8;
		  /* 820A97D8h */ case    6:  		/* cmplwi CR6, R28, 0 */
		/* 820A97D8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820A97D8h case    6:*/		return 0x820A97DC;
		  /* 820A97DCh */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 820A97DCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820A97F4;  }
		/* 820A97DCh case    7:*/		return 0x820A97E0;
		  /* 820A97E0h */ case    8:  		/* mr R3, R28 */
		/* 820A97E0h case    8:*/		regs.R3 = regs.R28;
		/* 820A97E0h case    8:*/		return 0x820A97E4;
		  /* 820A97E4h */ case    9:  		/* bl -700 */
		/* 820A97E4h case    9:*/		regs.LR = 0x820A97E8; return 0x820A9528;
		/* 820A97E4h case    9:*/		return 0x820A97E8;
		  /* 820A97E8h */ case   10:  		/* lis R4, 9345 */
		/* 820A97E8h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A97E8h case   10:*/		return 0x820A97EC;
		  /* 820A97ECh */ case   11:  		/* mr R3, R28 */
		/* 820A97ECh case   11:*/		regs.R3 = regs.R28;
		/* 820A97ECh case   11:*/		return 0x820A97F0;
		  /* 820A97F0h */ case   12:  		/* bl -136376 */
		/* 820A97F0h case   12:*/		regs.LR = 0x820A97F4; return 0x82088338;
		/* 820A97F0h case   12:*/		return 0x820A97F4;
	}
	return 0x820A97F4;
} // Block from 820A97C0h-820A97F4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A97F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A97F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A97F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A97F4);
		  /* 820A97F4h */ case    0:  		/* addic. R29, R29, -1 */
		/* 820A97F4h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 820A97F4h case    0:*/		return 0x820A97F8;
		  /* 820A97F8h */ case    1:  		/* addi R30, R30, 4 */
		/* 820A97F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820A97F8h case    1:*/		return 0x820A97FC;
		  /* 820A97FCh */ case    2:  		/* bc 4, CR0_EQ, -40 */
		/* 820A97FCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A97D4;  }
		/* 820A97FCh case    2:*/		return 0x820A9800;
		  /* 820A9800h */ case    3:  		/* li R30, 7 */
		/* 820A9800h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x7);
		/* 820A9800h case    3:*/		return 0x820A9804;
		  /* 820A9804h */ case    4:  		/* lwz R29, <#[R31]> */
		/* 820A9804h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 820A9804h case    4:*/		return 0x820A9808;
		  /* 820A9808h */ case    5:  		/* cmplwi CR6, R29, 0 */
		/* 820A9808h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820A9808h case    5:*/		return 0x820A980C;
		  /* 820A980Ch */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 820A980Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820A9824;  }
		/* 820A980Ch case    6:*/		return 0x820A9810;
		  /* 820A9810h */ case    7:  		/* mr R3, R29 */
		/* 820A9810h case    7:*/		regs.R3 = regs.R29;
		/* 820A9810h case    7:*/		return 0x820A9814;
		  /* 820A9814h */ case    8:  		/* bl -748 */
		/* 820A9814h case    8:*/		regs.LR = 0x820A9818; return 0x820A9528;
		/* 820A9814h case    8:*/		return 0x820A9818;
		  /* 820A9818h */ case    9:  		/* lis R4, 9345 */
		/* 820A9818h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820A9818h case    9:*/		return 0x820A981C;
		  /* 820A981Ch */ case   10:  		/* mr R3, R29 */
		/* 820A981Ch case   10:*/		regs.R3 = regs.R29;
		/* 820A981Ch case   10:*/		return 0x820A9820;
		  /* 820A9820h */ case   11:  		/* bl -136424 */
		/* 820A9820h case   11:*/		regs.LR = 0x820A9824; return 0x82088338;
		/* 820A9820h case   11:*/		return 0x820A9824;
	}
	return 0x820A9824;
} // Block from 820A97F4h-820A9824h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A9824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9824);
		  /* 820A9824h */ case    0:  		/* addic. R30, R30, -1 */
		/* 820A9824h case    0:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 820A9824h case    0:*/		return 0x820A9828;
		  /* 820A9828h */ case    1:  		/* addi R31, R31, 4 */
		/* 820A9828h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820A9828h case    1:*/		return 0x820A982C;
		  /* 820A982Ch */ case    2:  		/* bc 4, CR0_EQ, -40 */
		/* 820A982Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A9804;  }
		/* 820A982Ch case    2:*/		return 0x820A9830;
		  /* 820A9830h */ case    3:  		/* addi R1, R1, 128 */
		/* 820A9830h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820A9830h case    3:*/		return 0x820A9834;
		  /* 820A9834h */ case    4:  		/* b -99724 */
		/* 820A9834h case    4:*/		return 0x820912A8;
		/* 820A9834h case    4:*/		return 0x820A9838;
	}
	return 0x820A9838;
} // Block from 820A9824h-820A9838h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A9838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9838);
		  /* 820A9838h */ case    0:  		/* mfspr R12, LR */
		/* 820A9838h case    0:*/		regs.R12 = regs.LR;
		/* 820A9838h case    0:*/		return 0x820A983C;
		  /* 820A983Ch */ case    1:  		/* bl -99832 */
		/* 820A983Ch case    1:*/		regs.LR = 0x820A9840; return 0x82091244;
		/* 820A983Ch case    1:*/		return 0x820A9840;
		  /* 820A9840h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820A9840h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820A9840h case    2:*/		return 0x820A9844;
		  /* 820A9844h */ case    3:  		/* mr R29, R3 */
		/* 820A9844h case    3:*/		regs.R29 = regs.R3;
		/* 820A9844h case    3:*/		return 0x820A9848;
		  /* 820A9848h */ case    4:  		/* mr R24, R4 */
		/* 820A9848h case    4:*/		regs.R24 = regs.R4;
		/* 820A9848h case    4:*/		return 0x820A984C;
		  /* 820A984Ch */ case    5:  		/* mr R26, R5 */
		/* 820A984Ch case    5:*/		regs.R26 = regs.R5;
		/* 820A984Ch case    5:*/		return 0x820A9850;
		  /* 820A9850h */ case    6:  		/* mr R25, R6 */
		/* 820A9850h case    6:*/		regs.R25 = regs.R6;
		/* 820A9850h case    6:*/		return 0x820A9854;
		  /* 820A9854h */ case    7:  		/* mr R31, R7 */
		/* 820A9854h case    7:*/		regs.R31 = regs.R7;
		/* 820A9854h case    7:*/		return 0x820A9858;
		  /* 820A9858h */ case    8:  		/* mr R23, R8 */
		/* 820A9858h case    8:*/		regs.R23 = regs.R8;
		/* 820A9858h case    8:*/		return 0x820A985C;
		  /* 820A985Ch */ case    9:  		/* mr R28, R9 */
		/* 820A985Ch case    9:*/		regs.R28 = regs.R9;
		/* 820A985Ch case    9:*/		return 0x820A9860;
		  /* 820A9860h */ case   10:  		/* mr R11, R7 */
		/* 820A9860h case   10:*/		regs.R11 = regs.R7;
		/* 820A9860h case   10:*/		return 0x820A9864;
		  /* 820A9864h */ case   11:  		/* lbz R9, <#[R11]> */
		/* 820A9864h case   11:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9864h case   11:*/		return 0x820A9868;
		  /* 820A9868h */ case   12:  		/* addi R11, R11, 1 */
		/* 820A9868h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9868h case   12:*/		return 0x820A986C;
		  /* 820A986Ch */ case   13:  		/* cmplwi CR6, R9, 0 */
		/* 820A986Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820A986Ch case   13:*/		return 0x820A9870;
		  /* 820A9870h */ case   14:  		/* bc 4, CR6_EQ, -12 */
		/* 820A9870h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820A9864;  }
		/* 820A9870h case   14:*/		return 0x820A9874;
		  /* 820A9874h */ case   15:  		/* subf R11, R31, R11 */
		/* 820A9874h case   15:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820A9874h case   15:*/		return 0x820A9878;
		  /* 820A9878h */ case   16:  		/* addi R11, R11, -1 */
		/* 820A9878h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820A9878h case   16:*/		return 0x820A987C;
		  /* 820A987Ch */ case   17:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820A987Ch case   17:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820A987Ch case   17:*/		return 0x820A9880;
		  /* 820A9880h */ case   18:  		/* cmplwi CR6, R11, 2 */
		/* 820A9880h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820A9880h case   18:*/		return 0x820A9884;
		  /* 820A9884h */ case   19:  		/* bc 12, CR6_GT, 44 */
		/* 820A9884h case   19:*/		if ( regs.CR[6].gt ) { return 0x820A98B0;  }
		/* 820A9884h case   19:*/		return 0x820A9888;
		  /* 820A9888h */ case   20:  		/* lis R11, -32255 */
		/* 820A9888h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9888h case   20:*/		return 0x820A988C;
		  /* 820A988Ch */ case   21:  		/* addi R6, R11, 3144 */
		/* 820A988Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xC48);
		/* 820A988Ch case   21:*/		return 0x820A9890;
	}
	return 0x820A9890;
} // Block from 820A9838h-820A9890h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820A9890h
// Function '?DecodeSwizzle@CAssembler@D3DXShader@@IAAKPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9890);
		  /* 820A9890h */ case    0:  		/* mr R7, R31 */
		/* 820A9890h case    0:*/		regs.R7 = regs.R31;
		/* 820A9890h case    0:*/		return 0x820A9894;
		  /* 820A9894h */ case    1:  		/* li R5, 2005 */
		/* 820A9894h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x7D5);
		/* 820A9894h case    1:*/		return 0x820A9898;
		  /* 820A9898h */ case    2:  		/* mr R4, R25 */
		/* 820A9898h case    2:*/		regs.R4 = regs.R25;
		/* 820A9898h case    2:*/		return 0x820A989C;
		  /* 820A989Ch */ case    3:  		/* mr R3, R24 */
		/* 820A989Ch case    3:*/		regs.R3 = regs.R24;
		/* 820A989Ch case    3:*/		return 0x820A98A0;
		  /* 820A98A0h */ case    4:  		/* bl -10000 */
		/* 820A98A0h case    4:*/		regs.LR = 0x820A98A4; return 0x820A7190;
		/* 820A98A0h case    4:*/		return 0x820A98A4;
		  /* 820A98A4h */ case    5:  		/* lis R3, -32768 */
		/* 820A98A4h case    5:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820A98A4h case    5:*/		return 0x820A98A8;
		  /* 820A98A8h */ case    6:  		/* ori R3, R3, 16389 */
		/* 820A98A8h case    6:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820A98A8h case    6:*/		return 0x820A98AC;
		  /* 820A98ACh */ case    7:  		/* b 1368 */
		/* 820A98ACh case    7:*/		return 0x820A9E04;
		/* 820A98ACh case    7:*/		return 0x820A98B0;
	}
	return 0x820A98B0;
} // Block from 820A9890h-820A98B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A98B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A98B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A98B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A98B0);
		  /* 820A98B0h */ case    0:  		/* lwz R27, <#[R1 + 260]> */
		/* 820A98B0h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000104) );
		/* 820A98B0h case    0:*/		return 0x820A98B4;
		  /* 820A98B4h */ case    1:  		/* li R4, 0 */
		/* 820A98B4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820A98B4h case    1:*/		return 0x820A98B8;
		  /* 820A98B8h */ case    2:  		/* lis R9, -32255 */
		/* 820A98B8h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A98B8h case    2:*/		return 0x820A98BC;
		  /* 820A98BCh */ case    3:  		/* stw R4, <#[R28]> */
		/* 820A98BCh case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 820A98BCh case    3:*/		return 0x820A98C0;
		  /* 820A98C0h */ case    4:  		/* mr R11, R31 */
		/* 820A98C0h case    4:*/		regs.R11 = regs.R31;
		/* 820A98C0h case    4:*/		return 0x820A98C4;
		  /* 820A98C4h */ case    5:  		/* stw R4, <#[R10]> */
		/* 820A98C4h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R10 + 0x00000000) );
		/* 820A98C4h case    5:*/		return 0x820A98C8;
		  /* 820A98C8h */ case    6:  		/* addi R10, R9, 2488 */
		/* 820A98C8h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x9B8);
		/* 820A98C8h case    6:*/		return 0x820A98CC;
		  /* 820A98CCh */ case    7:  		/* addi R9, R31, 2 */
		/* 820A98CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x2);
		/* 820A98CCh case    7:*/		return 0x820A98D0;
		  /* 820A98D0h */ case    8:  		/* stw R4, <#[R27]> */
		/* 820A98D0h case    8:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R27 + 0x00000000) );
		/* 820A98D0h case    8:*/		return 0x820A98D4;
		  /* 820A98D4h */ case    9:  		/* lbz R8, <#[R11]> */
		/* 820A98D4h case    9:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A98D4h case    9:*/		return 0x820A98D8;
		  /* 820A98D8h */ case   10:  		/* lbz R7, <#[R10]> */
		/* 820A98D8h case   10:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A98D8h case   10:*/		return 0x820A98DC;
		  /* 820A98DCh */ case   11:  		/* subf. R8, R7, R8 */
		/* 820A98DCh case   11:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820A98DCh case   11:*/		return 0x820A98E0;
		  /* 820A98E0h */ case   12:  		/* bc 4, CR0_EQ, 20 */
		/* 820A98E0h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820A98F4;  }
		/* 820A98E0h case   12:*/		return 0x820A98E4;
		  /* 820A98E4h */ case   13:  		/* addi R11, R11, 1 */
		/* 820A98E4h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A98E4h case   13:*/		return 0x820A98E8;
		  /* 820A98E8h */ case   14:  		/* addi R10, R10, 1 */
		/* 820A98E8h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A98E8h case   14:*/		return 0x820A98EC;
		  /* 820A98ECh */ case   15:  		/* cmpw CR6, R11, R9 */
		/* 820A98ECh case   15:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 820A98ECh case   15:*/		return 0x820A98F0;
		  /* 820A98F0h */ case   16:  		/* bc 4, CR6_EQ, -28 */
		/* 820A98F0h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820A98D4;  }
		/* 820A98F0h case   16:*/		return 0x820A98F4;
	}
	return 0x820A98F4;
} // Block from 820A98B0h-820A98F4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A98F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A98F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A98F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A98F4);
		  /* 820A98F4h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A98F4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A98F4h case    0:*/		return 0x820A98F8;
		  /* 820A98F8h */ case    1:  		/* bc 4, CR0_EQ, 244 */
		/* 820A98F8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A99EC;  }
		/* 820A98F8h case    1:*/		return 0x820A98FC;
		  /* 820A98FCh */ case    2:  		/* lwz R11, <#[R29 + 180]> */
		/* 820A98FCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000B4) );
		/* 820A98FCh case    2:*/		return 0x820A9900;
		  /* 820A9900h */ case    3:  		/* cmpwi CR6, R11, 10 */
		/* 820A9900h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 820A9900h case    3:*/		return 0x820A9904;
		  /* 820A9904h */ case    4:  		/* bc 12, CR6_LT, 92 */
		/* 820A9904h case    4:*/		if ( regs.CR[6].lt ) { return 0x820A9960;  }
		/* 820A9904h case    4:*/		return 0x820A9908;
		  /* 820A9908h */ case    5:  		/* cmpwi CR6, R11, 13 */
		/* 820A9908h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000D);
		/* 820A9908h case    5:*/		return 0x820A990C;
		  /* 820A990Ch */ case    6:  		/* bc 12, CR6_GT, 84 */
		/* 820A990Ch case    6:*/		if ( regs.CR[6].gt ) { return 0x820A9960;  }
		/* 820A990Ch case    6:*/		return 0x820A9910;
		  /* 820A9910h */ case    7:  		/* addi R5, R1, 80 */
		/* 820A9910h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820A9910h case    7:*/		return 0x820A9914;
		  /* 820A9914h */ case    8:  		/* addi R4, R1, 81 */
		/* 820A9914h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x51);
		/* 820A9914h case    8:*/		return 0x820A9918;
		  /* 820A9918h */ case    9:  		/* addi R3, R31, 2 */
		/* 820A9918h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x2);
		/* 820A9918h case    9:*/		return 0x820A991C;
		  /* 820A991Ch */ case   10:  		/* bl -4940 */
		/* 820A991Ch case   10:*/		regs.LR = 0x820A9920; return 0x820A85D0;
		/* 820A991Ch case   10:*/		return 0x820A9920;
		  /* 820A9920h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820A9920h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A9920h case   11:*/		return 0x820A9924;
		  /* 820A9924h */ case   12:  		/* bc 12, CR0_LT, 128 */
		/* 820A9924h case   12:*/		if ( regs.CR[0].lt ) { return 0x820A99A4;  }
		/* 820A9924h case   12:*/		return 0x820A9928;
		  /* 820A9928h */ case   13:  		/* lbz R11, <#[R1 + 81]> */
		/* 820A9928h case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000051) );
		/* 820A9928h case   13:*/		return 0x820A992C;
		  /* 820A992Ch */ case   14:  		/* cmplwi CR6, R11, 5 */
		/* 820A992Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 820A992Ch case   14:*/		return 0x820A9930;
		  /* 820A9930h */ case   15:  		/* bc 4, CR6_EQ, 20 */
		/* 820A9930h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820A9944;  }
		/* 820A9930h case   15:*/		return 0x820A9934;
		  /* 820A9934h */ case   16:  		/* li R10, 3 */
		/* 820A9934h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820A9934h case   16:*/		return 0x820A9938;
		  /* 820A9938h */ case   17:  		/* lbz R11, <#[R1 + 80]> */
		/* 820A9938h case   17:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820A9938h case   17:*/		return 0x820A993C;
		  /* 820A993Ch */ case   18:  		/* stw R10, <#[R28]> */
		/* 820A993Ch case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 820A993Ch case   18:*/		return 0x820A9940;
		  /* 820A9940h */ case   19:  		/* b 1212 */
		/* 820A9940h case   19:*/		return 0x820A9DFC;
		/* 820A9940h case   19:*/		return 0x820A9944;
	}
	return 0x820A9944;
} // Block from 820A98F4h-820A9944h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820A9944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9944);
		  /* 820A9944h */ case    0:  		/* cmplwi CR6, R11, 10 */
		/* 820A9944h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 820A9944h case    0:*/		return 0x820A9948;
		  /* 820A9948h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820A9948h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820A9954;  }
		/* 820A9948h case    1:*/		return 0x820A994C;
		  /* 820A994Ch */ case    2:  		/* li R10, 1 */
		/* 820A994Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820A994Ch case    2:*/		return 0x820A9950;
		  /* 820A9950h */ case    3:  		/* b -24 */
		/* 820A9950h case    3:*/		return 0x820A9938;
		/* 820A9950h case    3:*/		return 0x820A9954;
	}
	return 0x820A9954;
} // Block from 820A9944h-820A9954h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A9954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9954);
		  /* 820A9954h */ case    0:  		/* lis R11, -32255 */
		/* 820A9954h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9954h case    0:*/		return 0x820A9958;
		  /* 820A9958h */ case    1:  		/* addi R6, R11, 3092 */
		/* 820A9958h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xC14);
		/* 820A9958h case    1:*/		return 0x820A995C;
		  /* 820A995Ch */ case    2:  		/* b -204 */
		/* 820A995Ch case    2:*/		return 0x820A9890;
		/* 820A995Ch case    2:*/		return 0x820A9960;
	}
	return 0x820A9960;
} // Block from 820A9954h-820A9960h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A9960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9960);
		  /* 820A9960h */ case    0:  		/* li R11, 1 */
		/* 820A9960h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820A9960h case    0:*/		return 0x820A9964;
		  /* 820A9964h */ case    1:  		/* addi R30, R29, 28 */
		/* 820A9964h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0x1C);
		/* 820A9964h case    1:*/		return 0x820A9968;
		  /* 820A9968h */ case    2:  		/* stw R11, <#[R28]> */
		/* 820A9968h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820A9968h case    2:*/		return 0x820A996C;
		  /* 820A996Ch */ case    3:  		/* mr R4, R31 */
		/* 820A996Ch case    3:*/		regs.R4 = regs.R31;
		/* 820A996Ch case    3:*/		return 0x820A9970;
		  /* 820A9970h */ case    4:  		/* mr R3, R30 */
		/* 820A9970h case    4:*/		regs.R3 = regs.R30;
		/* 820A9970h case    4:*/		return 0x820A9974;
		  /* 820A9974h */ case    5:  		/* bl -3460 */
		/* 820A9974h case    5:*/		regs.LR = 0x820A9978; return 0x820A8BF0;
		/* 820A9974h case    5:*/		return 0x820A9978;
		  /* 820A9978h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820A9978h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A9978h case    6:*/		return 0x820A997C;
		  /* 820A997Ch */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 820A997Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820A998C;  }
		/* 820A997Ch case    7:*/		return 0x820A9980;
		  /* 820A9980h */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 820A9980h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820A9980h case    8:*/		return 0x820A9984;
		  /* 820A9984h */ case    9:  		/* stw R11, <#[R27]> */
		/* 820A9984h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A9984h case    9:*/		return 0x820A9988;
		  /* 820A9988h */ case   10:  		/* b 80 */
		/* 820A9988h case   10:*/		return 0x820A99D8;
		/* 820A9988h case   10:*/		return 0x820A998C;
	}
	return 0x820A998C;
} // Block from 820A9960h-820A998Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A998Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A998C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A998C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A998C);
		  /* 820A998Ch */ case    0:  		/* addi R5, R1, 81 */
		/* 820A998Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x51);
		/* 820A998Ch case    0:*/		return 0x820A9990;
		  /* 820A9990h */ case    1:  		/* addi R4, R1, 80 */
		/* 820A9990h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820A9990h case    1:*/		return 0x820A9994;
		  /* 820A9994h */ case    2:  		/* addi R3, R31, 2 */
		/* 820A9994h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x2);
		/* 820A9994h case    2:*/		return 0x820A9998;
		  /* 820A9998h */ case    3:  		/* bl -5064 */
		/* 820A9998h case    3:*/		regs.LR = 0x820A999C; return 0x820A85D0;
		/* 820A9998h case    3:*/		return 0x820A999C;
		  /* 820A999Ch */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820A999Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A999Ch case    4:*/		return 0x820A99A0;
	}
	return 0x820A99A0;
} // Block from 820A998Ch-820A99A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A99A0h
// Function '?Validate@CAssembler@D3DXShader@@IAAJPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A99A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A99A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A99A0);
		  /* 820A99A0h */ case    0:  		/* bc 4, CR0_LT, 16 */
		/* 820A99A0h case    0:*/		if ( !regs.CR[0].lt ) { return 0x820A99B0;  }
		/* 820A99A0h case    0:*/		return 0x820A99A4;
	}
	return 0x820A99A4;
} // Block from 820A99A0h-820A99A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A99A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A99A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A99A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A99A4);
		  /* 820A99A4h */ case    0:  		/* lis R11, -32255 */
		/* 820A99A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A99A4h case    0:*/		return 0x820A99A8;
		  /* 820A99A8h */ case    1:  		/* addi R6, R11, 3052 */
		/* 820A99A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xBEC);
		/* 820A99A8h case    1:*/		return 0x820A99AC;
		  /* 820A99ACh */ case    2:  		/* b -284 */
		/* 820A99ACh case    2:*/		return 0x820A9890;
		/* 820A99ACh case    2:*/		return 0x820A99B0;
	}
	return 0x820A99B0;
} // Block from 820A99A4h-820A99B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A99B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A99B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A99B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A99B0);
		  /* 820A99B0h */ case    0:  		/* lwz R11, <#[R29 + 156]> */
		/* 820A99B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000009C) );
		/* 820A99B0h case    0:*/		return 0x820A99B4;
		  /* 820A99B4h */ case    1:  		/* li R6, 1 */
		/* 820A99B4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820A99B4h case    1:*/		return 0x820A99B8;
		  /* 820A99B8h */ case    2:  		/* mr R4, R31 */
		/* 820A99B8h case    2:*/		regs.R4 = regs.R31;
		/* 820A99B8h case    2:*/		return 0x820A99BC;
		  /* 820A99BCh */ case    3:  		/* mr R3, R30 */
		/* 820A99BCh case    3:*/		regs.R3 = regs.R30;
		/* 820A99BCh case    3:*/		return 0x820A99C0;
		  /* 820A99C0h */ case    4:  		/* stw R11, <#[R27]> */
		/* 820A99C0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A99C0h case    4:*/		return 0x820A99C4;
		  /* 820A99C4h */ case    5:  		/* lwz R5, <#[R29 + 156]> */
		/* 820A99C4h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000009C) );
		/* 820A99C4h case    5:*/		return 0x820A99C8;
		  /* 820A99C8h */ case    6:  		/* bl -1104 */
		/* 820A99C8h case    6:*/		regs.LR = 0x820A99CC; return 0x820A9578;
		/* 820A99C8h case    6:*/		return 0x820A99CC;
		  /* 820A99CCh */ case    7:  		/* lwz R11, <#[R29 + 156]> */
		/* 820A99CCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000009C) );
		/* 820A99CCh case    7:*/		return 0x820A99D0;
		  /* 820A99D0h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A99D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A99D0h case    8:*/		return 0x820A99D4;
		  /* 820A99D4h */ case    9:  		/* stw R11, <#[R29 + 156]> */
		/* 820A99D4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x0000009C) );
		/* 820A99D4h case    9:*/		return 0x820A99D8;
	}
	return 0x820A99D8;
} // Block from 820A99B0h-820A99D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A99D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A99D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A99D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A99D8);
		  /* 820A99D8h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 820A99D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820A99D8h case    0:*/		return 0x820A99DC;
		  /* 820A99DCh */ case    1:  		/* bc 12, CR6_EQ, 1060 */
		/* 820A99DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820A9E00;  }
		/* 820A99DCh case    1:*/		return 0x820A99E0;
		  /* 820A99E0h */ case    2:  		/* lis R11, -32255 */
		/* 820A99E0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A99E0h case    2:*/		return 0x820A99E4;
		  /* 820A99E4h */ case    3:  		/* addi R6, R11, 2988 */
		/* 820A99E4h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xBAC);
		/* 820A99E4h case    3:*/		return 0x820A99E8;
		  /* 820A99E8h */ case    4:  		/* b -344 */
		/* 820A99E8h case    4:*/		return 0x820A9890;
		/* 820A99E8h case    4:*/		return 0x820A99EC;
	}
	return 0x820A99EC;
} // Block from 820A99D8h-820A99ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A99ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A99EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A99EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A99EC);
		  /* 820A99ECh */ case    0:  		/* lis R10, -32255 */
		/* 820A99ECh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A99ECh case    0:*/		return 0x820A99F0;
		  /* 820A99F0h */ case    1:  		/* mr R11, R31 */
		/* 820A99F0h case    1:*/		regs.R11 = regs.R31;
		/* 820A99F0h case    1:*/		return 0x820A99F4;
		  /* 820A99F4h */ case    2:  		/* addi R10, R10, 2484 */
		/* 820A99F4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x9B4);
		/* 820A99F4h case    2:*/		return 0x820A99F8;
		  /* 820A99F8h */ case    3:  		/* addi R8, R31, 2 */
		/* 820A99F8h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x2);
		/* 820A99F8h case    3:*/		return 0x820A99FC;
		  /* 820A99FCh */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820A99FCh case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A99FCh case    4:*/		return 0x820A9A00;
		  /* 820A9A00h */ case    5:  		/* lbz R7, <#[R10]> */
		/* 820A9A00h case    5:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A9A00h case    5:*/		return 0x820A9A04;
		  /* 820A9A04h */ case    6:  		/* subf. R9, R7, R9 */
		/* 820A9A04h case    6:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A9A04h case    6:*/		return 0x820A9A08;
		  /* 820A9A08h */ case    7:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9A08h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820A9A1C;  }
		/* 820A9A08h case    7:*/		return 0x820A9A0C;
		  /* 820A9A0Ch */ case    8:  		/* addi R11, R11, 1 */
		/* 820A9A0Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9A0Ch case    8:*/		return 0x820A9A10;
		  /* 820A9A10h */ case    9:  		/* addi R10, R10, 1 */
		/* 820A9A10h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A9A10h case    9:*/		return 0x820A9A14;
		  /* 820A9A14h */ case   10:  		/* cmpw CR6, R11, R8 */
		/* 820A9A14h case   10:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820A9A14h case   10:*/		return 0x820A9A18;
		  /* 820A9A18h */ case   11:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9A18h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820A99FC;  }
		/* 820A9A18h case   11:*/		return 0x820A9A1C;
	}
	return 0x820A9A1C;
} // Block from 820A99ECh-820A9A1Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A9A1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9A1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9A1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9A1C);
		  /* 820A9A1Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A9A1Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A9A1Ch case    0:*/		return 0x820A9A20;
		  /* 820A9A20h */ case    1:  		/* bc 4, CR0_EQ, 104 */
		/* 820A9A20h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A9A88;  }
		/* 820A9A20h case    1:*/		return 0x820A9A24;
		  /* 820A9A24h */ case    2:  		/* stw R4, <#[R28]> */
		/* 820A9A24h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 820A9A24h case    2:*/		return 0x820A9A28;
		  /* 820A9A28h */ case    3:  		/* addi R30, R29, 84 */
		/* 820A9A28h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0x54);
		/* 820A9A28h case    3:*/		return 0x820A9A2C;
		  /* 820A9A2Ch */ case    4:  		/* mr R4, R31 */
		/* 820A9A2Ch case    4:*/		regs.R4 = regs.R31;
		/* 820A9A2Ch case    4:*/		return 0x820A9A30;
		  /* 820A9A30h */ case    5:  		/* mr R3, R30 */
		/* 820A9A30h case    5:*/		regs.R3 = regs.R30;
		/* 820A9A30h case    5:*/		return 0x820A9A34;
		  /* 820A9A34h */ case    6:  		/* bl -3652 */
		/* 820A9A34h case    6:*/		regs.LR = 0x820A9A38; return 0x820A8BF0;
		/* 820A9A34h case    6:*/		return 0x820A9A38;
	}
	return 0x820A9A38;
} // Block from 820A9A1Ch-820A9A38h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A9A38h
// Function '?compare@D3DXShader@@YAHPBX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9A38);
		  /* 820A9A38h */ case    0:  		/* cmplwi CR0, R3, 0 */
		/* 820A9A38h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A9A38h case    0:*/		return 0x820A9A3C;
		  /* 820A9A3Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820A9A3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820A9A4C;  }
		/* 820A9A3Ch case    1:*/		return 0x820A9A40;
		  /* 820A9A40h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 820A9A40h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820A9A40h case    2:*/		return 0x820A9A44;
		  /* 820A9A44h */ case    3:  		/* stw R11, <#[R27]> */
		/* 820A9A44h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A9A44h case    3:*/		return 0x820A9A48;
		  /* 820A9A48h */ case    4:  		/* b 44 */
		/* 820A9A48h case    4:*/		return 0x820A9A74;
		/* 820A9A48h case    4:*/		return 0x820A9A4C;
	}
	return 0x820A9A4C;
} // Block from 820A9A38h-820A9A4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A9A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9A4C);
		  /* 820A9A4Ch */ case    0:  		/* lwz R11, <#[R29 + 164]> */
		/* 820A9A4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000A4) );
		/* 820A9A4Ch case    0:*/		return 0x820A9A50;
		  /* 820A9A50h */ case    1:  		/* li R6, 1 */
		/* 820A9A50h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820A9A50h case    1:*/		return 0x820A9A54;
		  /* 820A9A54h */ case    2:  		/* mr R4, R31 */
		/* 820A9A54h case    2:*/		regs.R4 = regs.R31;
		/* 820A9A54h case    2:*/		return 0x820A9A58;
		  /* 820A9A58h */ case    3:  		/* mr R3, R30 */
		/* 820A9A58h case    3:*/		regs.R3 = regs.R30;
		/* 820A9A58h case    3:*/		return 0x820A9A5C;
		  /* 820A9A5Ch */ case    4:  		/* stw R11, <#[R27]> */
		/* 820A9A5Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A9A5Ch case    4:*/		return 0x820A9A60;
		  /* 820A9A60h */ case    5:  		/* lwz R5, <#[R29 + 164]> */
		/* 820A9A60h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x000000A4) );
		/* 820A9A60h case    5:*/		return 0x820A9A64;
		  /* 820A9A64h */ case    6:  		/* bl -1260 */
		/* 820A9A64h case    6:*/		regs.LR = 0x820A9A68; return 0x820A9578;
		/* 820A9A64h case    6:*/		return 0x820A9A68;
		  /* 820A9A68h */ case    7:  		/* lwz R11, <#[R29 + 164]> */
		/* 820A9A68h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000A4) );
		/* 820A9A68h case    7:*/		return 0x820A9A6C;
		  /* 820A9A6Ch */ case    8:  		/* addi R11, R11, 1 */
		/* 820A9A6Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9A6Ch case    8:*/		return 0x820A9A70;
		  /* 820A9A70h */ case    9:  		/* stw R11, <#[R29 + 164]> */
		/* 820A9A70h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x000000A4) );
		/* 820A9A70h case    9:*/		return 0x820A9A74;
	}
	return 0x820A9A74;
} // Block from 820A9A4Ch-820A9A74h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A9A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9A74);
		  /* 820A9A74h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 820A9A74h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820A9A74h case    0:*/		return 0x820A9A78;
		  /* 820A9A78h */ case    1:  		/* bc 12, CR6_EQ, 904 */
		/* 820A9A78h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A9E00;  }
		/* 820A9A78h case    1:*/		return 0x820A9A7C;
		  /* 820A9A7Ch */ case    2:  		/* lis R11, -32255 */
		/* 820A9A7Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9A7Ch case    2:*/		return 0x820A9A80;
		  /* 820A9A80h */ case    3:  		/* addi R6, R11, 2924 */
		/* 820A9A80h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xB6C);
		/* 820A9A80h case    3:*/		return 0x820A9A84;
		  /* 820A9A84h */ case    4:  		/* b -500 */
		/* 820A9A84h case    4:*/		return 0x820A9890;
		/* 820A9A84h case    4:*/		return 0x820A9A88;
	}
	return 0x820A9A88;
} // Block from 820A9A74h-820A9A88h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A9A88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9A88);
		  /* 820A9A88h */ case    0:  		/* lis R10, -32255 */
		/* 820A9A88h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A9A88h case    0:*/		return 0x820A9A8C;
		  /* 820A9A8Ch */ case    1:  		/* mr R11, R31 */
		/* 820A9A8Ch case    1:*/		regs.R11 = regs.R31;
		/* 820A9A8Ch case    1:*/		return 0x820A9A90;
		  /* 820A9A90h */ case    2:  		/* addi R9, R10, 2920 */
		/* 820A9A90h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xB68);
		/* 820A9A90h case    2:*/		return 0x820A9A94;
		  /* 820A9A94h */ case    3:  		/* addi R8, R31, 2 */
		/* 820A9A94h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x2);
		/* 820A9A94h case    3:*/		return 0x820A9A98;
		  /* 820A9A98h */ case    4:  		/* lbz R10, <#[R11]> */
		/* 820A9A98h case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9A98h case    4:*/		return 0x820A9A9C;
		  /* 820A9A9Ch */ case    5:  		/* lbz R7, <#[R9]> */
		/* 820A9A9Ch case    5:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820A9A9Ch case    5:*/		return 0x820A9AA0;
		  /* 820A9AA0h */ case    6:  		/* subf. R10, R7, R10 */
		/* 820A9AA0h case    6:*/		cpu::op::subf<1>(regs,&regs.R10,regs.R7,regs.R10);
		/* 820A9AA0h case    6:*/		return 0x820A9AA4;
		  /* 820A9AA4h */ case    7:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9AA4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820A9AB8;  }
		/* 820A9AA4h case    7:*/		return 0x820A9AA8;
		  /* 820A9AA8h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A9AA8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9AA8h case    8:*/		return 0x820A9AAC;
		  /* 820A9AACh */ case    9:  		/* addi R9, R9, 1 */
		/* 820A9AACh case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A9AACh case    9:*/		return 0x820A9AB0;
		  /* 820A9AB0h */ case   10:  		/* cmpw CR6, R11, R8 */
		/* 820A9AB0h case   10:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820A9AB0h case   10:*/		return 0x820A9AB4;
		  /* 820A9AB4h */ case   11:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9AB4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820A9A98;  }
		/* 820A9AB4h case   11:*/		return 0x820A9AB8;
	}
	return 0x820A9AB8;
} // Block from 820A9A88h-820A9AB8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A9AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9AB8);
		  /* 820A9AB8h */ case    0:  		/* lis R11, -32255 */
		/* 820A9AB8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9AB8h case    0:*/		return 0x820A9ABC;
		  /* 820A9ABCh */ case    1:  		/* lis R9, -32255 */
		/* 820A9ABCh case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A9ABCh case    1:*/		return 0x820A9AC0;
		  /* 820A9AC0h */ case    2:  		/* lis R8, -32255 */
		/* 820A9AC0h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 820A9AC0h case    2:*/		return 0x820A9AC4;
		  /* 820A9AC4h */ case    3:  		/* cmpwi CR0, R10, 0 */
		/* 820A9AC4h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 820A9AC4h case    3:*/		return 0x820A9AC8;
		  /* 820A9AC8h */ case    4:  		/* addi R10, R11, 2916 */
		/* 820A9AC8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xB64);
		/* 820A9AC8h case    4:*/		return 0x820A9ACC;
		  /* 820A9ACCh */ case    5:  		/* addi R9, R9, 2912 */
		/* 820A9ACCh case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xB60);
		/* 820A9ACCh case    5:*/		return 0x820A9AD0;
		  /* 820A9AD0h */ case    6:  		/* addi R8, R8, 2908 */
		/* 820A9AD0h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xB5C);
		/* 820A9AD0h case    6:*/		return 0x820A9AD4;
		  /* 820A9AD4h */ case    7:  		/* bc 12, CR0_EQ, 380 */
		/* 820A9AD4h case    7:*/		if ( regs.CR[0].eq ) { return 0x820A9C50;  }
		/* 820A9AD4h case    7:*/		return 0x820A9AD8;
		  /* 820A9AD8h */ case    8:  		/* mr R7, R8 */
		/* 820A9AD8h case    8:*/		regs.R7 = regs.R8;
		/* 820A9AD8h case    8:*/		return 0x820A9ADC;
		  /* 820A9ADCh */ case    9:  		/* mr R11, R31 */
		/* 820A9ADCh case    9:*/		regs.R11 = regs.R31;
		/* 820A9ADCh case    9:*/		return 0x820A9AE0;
		  /* 820A9AE0h */ case   10:  		/* addi R5, R31, 2 */
		/* 820A9AE0h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x2);
		/* 820A9AE0h case   10:*/		return 0x820A9AE4;
		  /* 820A9AE4h */ case   11:  		/* lbz R6, <#[R11]> */
		/* 820A9AE4h case   11:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9AE4h case   11:*/		return 0x820A9AE8;
		  /* 820A9AE8h */ case   12:  		/* lbz R3, <#[R7]> */
		/* 820A9AE8h case   12:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R7 + 0x00000000) );
		/* 820A9AE8h case   12:*/		return 0x820A9AEC;
		  /* 820A9AECh */ case   13:  		/* subf. R6, R3, R6 */
		/* 820A9AECh case   13:*/		cpu::op::subf<1>(regs,&regs.R6,regs.R3,regs.R6);
		/* 820A9AECh case   13:*/		return 0x820A9AF0;
		  /* 820A9AF0h */ case   14:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9AF0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x820A9B04;  }
		/* 820A9AF0h case   14:*/		return 0x820A9AF4;
		  /* 820A9AF4h */ case   15:  		/* addi R11, R11, 1 */
		/* 820A9AF4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9AF4h case   15:*/		return 0x820A9AF8;
		  /* 820A9AF8h */ case   16:  		/* addi R7, R7, 1 */
		/* 820A9AF8h case   16:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820A9AF8h case   16:*/		return 0x820A9AFC;
		  /* 820A9AFCh */ case   17:  		/* cmpw CR6, R11, R5 */
		/* 820A9AFCh case   17:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R5);
		/* 820A9AFCh case   17:*/		return 0x820A9B00;
		  /* 820A9B00h */ case   18:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9B00h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820A9AE4;  }
		/* 820A9B00h case   18:*/		return 0x820A9B04;
	}
	return 0x820A9B04;
} // Block from 820A9AB8h-820A9B04h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A9B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9B04);
		  /* 820A9B04h */ case    0:  		/* cmpwi CR0, R6, 0 */
		/* 820A9B04h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R6,0x00000000);
		/* 820A9B04h case    0:*/		return 0x820A9B08;
		  /* 820A9B08h */ case    1:  		/* bc 12, CR0_EQ, 328 */
		/* 820A9B08h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A9C50;  }
		/* 820A9B08h case    1:*/		return 0x820A9B0C;
		  /* 820A9B0Ch */ case    2:  		/* mr R7, R9 */
		/* 820A9B0Ch case    2:*/		regs.R7 = regs.R9;
		/* 820A9B0Ch case    2:*/		return 0x820A9B10;
		  /* 820A9B10h */ case    3:  		/* mr R11, R31 */
		/* 820A9B10h case    3:*/		regs.R11 = regs.R31;
		/* 820A9B10h case    3:*/		return 0x820A9B14;
		  /* 820A9B14h */ case    4:  		/* addi R5, R31, 2 */
		/* 820A9B14h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x2);
		/* 820A9B14h case    4:*/		return 0x820A9B18;
		  /* 820A9B18h */ case    5:  		/* lbz R6, <#[R11]> */
		/* 820A9B18h case    5:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9B18h case    5:*/		return 0x820A9B1C;
		  /* 820A9B1Ch */ case    6:  		/* lbz R3, <#[R7]> */
		/* 820A9B1Ch case    6:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R7 + 0x00000000) );
		/* 820A9B1Ch case    6:*/		return 0x820A9B20;
		  /* 820A9B20h */ case    7:  		/* subf. R6, R3, R6 */
		/* 820A9B20h case    7:*/		cpu::op::subf<1>(regs,&regs.R6,regs.R3,regs.R6);
		/* 820A9B20h case    7:*/		return 0x820A9B24;
		  /* 820A9B24h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9B24h case    8:*/		if ( !regs.CR[0].eq ) { return 0x820A9B38;  }
		/* 820A9B24h case    8:*/		return 0x820A9B28;
		  /* 820A9B28h */ case    9:  		/* addi R11, R11, 1 */
		/* 820A9B28h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9B28h case    9:*/		return 0x820A9B2C;
		  /* 820A9B2Ch */ case   10:  		/* addi R7, R7, 1 */
		/* 820A9B2Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820A9B2Ch case   10:*/		return 0x820A9B30;
		  /* 820A9B30h */ case   11:  		/* cmpw CR6, R11, R5 */
		/* 820A9B30h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R5);
		/* 820A9B30h case   11:*/		return 0x820A9B34;
		  /* 820A9B34h */ case   12:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9B34h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A9B18;  }
		/* 820A9B34h case   12:*/		return 0x820A9B38;
	}
	return 0x820A9B38;
} // Block from 820A9B04h-820A9B38h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A9B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9B38);
		  /* 820A9B38h */ case    0:  		/* cmpwi CR0, R6, 0 */
		/* 820A9B38h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R6,0x00000000);
		/* 820A9B38h case    0:*/		return 0x820A9B3C;
		  /* 820A9B3Ch */ case    1:  		/* bc 12, CR0_EQ, 276 */
		/* 820A9B3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820A9C50;  }
		/* 820A9B3Ch case    1:*/		return 0x820A9B40;
		  /* 820A9B40h */ case    2:  		/* mr R7, R10 */
		/* 820A9B40h case    2:*/		regs.R7 = regs.R10;
		/* 820A9B40h case    2:*/		return 0x820A9B44;
		  /* 820A9B44h */ case    3:  		/* mr R11, R31 */
		/* 820A9B44h case    3:*/		regs.R11 = regs.R31;
		/* 820A9B44h case    3:*/		return 0x820A9B48;
		  /* 820A9B48h */ case    4:  		/* addi R5, R31, 2 */
		/* 820A9B48h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x2);
		/* 820A9B48h case    4:*/		return 0x820A9B4C;
		  /* 820A9B4Ch */ case    5:  		/* lbz R6, <#[R11]> */
		/* 820A9B4Ch case    5:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9B4Ch case    5:*/		return 0x820A9B50;
		  /* 820A9B50h */ case    6:  		/* lbz R3, <#[R7]> */
		/* 820A9B50h case    6:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R7 + 0x00000000) );
		/* 820A9B50h case    6:*/		return 0x820A9B54;
		  /* 820A9B54h */ case    7:  		/* subf. R6, R3, R6 */
		/* 820A9B54h case    7:*/		cpu::op::subf<1>(regs,&regs.R6,regs.R3,regs.R6);
		/* 820A9B54h case    7:*/		return 0x820A9B58;
		  /* 820A9B58h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9B58h case    8:*/		if ( !regs.CR[0].eq ) { return 0x820A9B6C;  }
		/* 820A9B58h case    8:*/		return 0x820A9B5C;
		  /* 820A9B5Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 820A9B5Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9B5Ch case    9:*/		return 0x820A9B60;
		  /* 820A9B60h */ case   10:  		/* addi R7, R7, 1 */
		/* 820A9B60h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820A9B60h case   10:*/		return 0x820A9B64;
		  /* 820A9B64h */ case   11:  		/* cmpw CR6, R11, R5 */
		/* 820A9B64h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R5);
		/* 820A9B64h case   11:*/		return 0x820A9B68;
		  /* 820A9B68h */ case   12:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9B68h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820A9B4C;  }
		/* 820A9B68h case   12:*/		return 0x820A9B6C;
	}
	return 0x820A9B6C;
} // Block from 820A9B38h-820A9B6Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A9B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9B6C);
		  /* 820A9B6Ch */ case    0:  		/* cmpwi CR0, R6, 0 */
		/* 820A9B6Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R6,0x00000000);
		/* 820A9B6Ch case    0:*/		return 0x820A9B70;
		  /* 820A9B70h */ case    1:  		/* bc 12, CR0_EQ, 224 */
		/* 820A9B70h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A9C50;  }
		/* 820A9B70h case    1:*/		return 0x820A9B74;
		  /* 820A9B74h */ case    2:  		/* lwz R11, <#[R29 + 176]> */
		/* 820A9B74h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000B0) );
		/* 820A9B74h case    2:*/		return 0x820A9B78;
		  /* 820A9B78h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820A9B78h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820A9B78h case    3:*/		return 0x820A9B7C;
		  /* 820A9B7Ch */ case    4:  		/* bc 12, CR6_EQ, 200 */
		/* 820A9B7Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820A9C44;  }
		/* 820A9B7Ch case    4:*/		return 0x820A9B80;
		  /* 820A9B80h */ case    5:  		/* lis R10, -32255 */
		/* 820A9B80h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A9B80h case    5:*/		return 0x820A9B84;
		  /* 820A9B84h */ case    6:  		/* mr R11, R31 */
		/* 820A9B84h case    6:*/		regs.R11 = regs.R31;
		/* 820A9B84h case    6:*/		return 0x820A9B88;
		  /* 820A9B88h */ case    7:  		/* addi R10, R10, 2480 */
		/* 820A9B88h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x9B0);
		/* 820A9B88h case    7:*/		return 0x820A9B8C;
		  /* 820A9B8Ch */ case    8:  		/* addi R8, R31, 2 */
		/* 820A9B8Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x2);
		/* 820A9B8Ch case    8:*/		return 0x820A9B90;
		  /* 820A9B90h */ case    9:  		/* lbz R9, <#[R11]> */
		/* 820A9B90h case    9:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9B90h case    9:*/		return 0x820A9B94;
		  /* 820A9B94h */ case   10:  		/* lbz R7, <#[R10]> */
		/* 820A9B94h case   10:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A9B94h case   10:*/		return 0x820A9B98;
		  /* 820A9B98h */ case   11:  		/* subf. R9, R7, R9 */
		/* 820A9B98h case   11:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A9B98h case   11:*/		return 0x820A9B9C;
		  /* 820A9B9Ch */ case   12:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9B9Ch case   12:*/		if ( !regs.CR[0].eq ) { return 0x820A9BB0;  }
		/* 820A9B9Ch case   12:*/		return 0x820A9BA0;
		  /* 820A9BA0h */ case   13:  		/* addi R11, R11, 1 */
		/* 820A9BA0h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9BA0h case   13:*/		return 0x820A9BA4;
		  /* 820A9BA4h */ case   14:  		/* addi R10, R10, 1 */
		/* 820A9BA4h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A9BA4h case   14:*/		return 0x820A9BA8;
		  /* 820A9BA8h */ case   15:  		/* cmpw CR6, R11, R8 */
		/* 820A9BA8h case   15:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820A9BA8h case   15:*/		return 0x820A9BAC;
		  /* 820A9BACh */ case   16:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9BACh case   16:*/		if ( !regs.CR[6].eq ) { return 0x820A9B90;  }
		/* 820A9BACh case   16:*/		return 0x820A9BB0;
	}
	return 0x820A9BB0;
} // Block from 820A9B6Ch-820A9BB0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820A9BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9BB0);
		  /* 820A9BB0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A9BB0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A9BB0h case    0:*/		return 0x820A9BB4;
		  /* 820A9BB4h */ case    1:  		/* bc 4, CR0_EQ, 144 */
		/* 820A9BB4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A9C44;  }
		/* 820A9BB4h case    1:*/		return 0x820A9BB8;
		  /* 820A9BB8h */ case    2:  		/* li R11, 6 */
		/* 820A9BB8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820A9BB8h case    2:*/		return 0x820A9BBC;
		  /* 820A9BBCh */ case    3:  		/* addi R30, R29, 56 */
		/* 820A9BBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0x38);
		/* 820A9BBCh case    3:*/		return 0x820A9BC0;
		  /* 820A9BC0h */ case    4:  		/* stw R11, <#[R28]> */
		/* 820A9BC0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820A9BC0h case    4:*/		return 0x820A9BC4;
		  /* 820A9BC4h */ case    5:  		/* mr R4, R31 */
		/* 820A9BC4h case    5:*/		regs.R4 = regs.R31;
		/* 820A9BC4h case    5:*/		return 0x820A9BC8;
		  /* 820A9BC8h */ case    6:  		/* mr R3, R30 */
		/* 820A9BC8h case    6:*/		regs.R3 = regs.R30;
		/* 820A9BC8h case    6:*/		return 0x820A9BCC;
		  /* 820A9BCCh */ case    7:  		/* bl -4060 */
		/* 820A9BCCh case    7:*/		regs.LR = 0x820A9BD0; return 0x820A8BF0;
		/* 820A9BCCh case    7:*/		return 0x820A9BD0;
		  /* 820A9BD0h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 820A9BD0h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A9BD0h case    8:*/		return 0x820A9BD4;
		  /* 820A9BD4h */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 820A9BD4h case    9:*/		if ( regs.CR[0].eq ) { return 0x820A9BE4;  }
		/* 820A9BD4h case    9:*/		return 0x820A9BD8;
		  /* 820A9BD8h */ case   10:  		/* lwz R11, <#[R3 + 4]> */
		/* 820A9BD8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820A9BD8h case   10:*/		return 0x820A9BDC;
		  /* 820A9BDCh */ case   11:  		/* stw R11, <#[R27]> */
		/* 820A9BDCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A9BDCh case   11:*/		return 0x820A9BE0;
		  /* 820A9BE0h */ case   12:  		/* b 80 */
		/* 820A9BE0h case   12:*/		return 0x820A9C30;
		/* 820A9BE0h case   12:*/		return 0x820A9BE4;
	}
	return 0x820A9BE4;
} // Block from 820A9BB0h-820A9BE4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A9BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9BE4);
		  /* 820A9BE4h */ case    0:  		/* addi R5, R1, 81 */
		/* 820A9BE4h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x51);
		/* 820A9BE4h case    0:*/		return 0x820A9BE8;
		  /* 820A9BE8h */ case    1:  		/* addi R4, R1, 80 */
		/* 820A9BE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820A9BE8h case    1:*/		return 0x820A9BEC;
		  /* 820A9BECh */ case    2:  		/* addi R3, R31, 2 */
		/* 820A9BECh case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x2);
		/* 820A9BECh case    2:*/		return 0x820A9BF0;
		  /* 820A9BF0h */ case    3:  		/* bl -5664 */
		/* 820A9BF0h case    3:*/		regs.LR = 0x820A9BF4; return 0x820A85D0;
		/* 820A9BF0h case    3:*/		return 0x820A9BF4;
		  /* 820A9BF4h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820A9BF4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A9BF4h case    4:*/		return 0x820A9BF8;
		  /* 820A9BF8h */ case    5:  		/* bc 4, CR0_LT, 16 */
		/* 820A9BF8h case    5:*/		if ( !regs.CR[0].lt ) { return 0x820A9C08;  }
		/* 820A9BF8h case    5:*/		return 0x820A9BFC;
		  /* 820A9BFCh */ case    6:  		/* lis R11, -32255 */
		/* 820A9BFCh case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9BFCh case    6:*/		return 0x820A9C00;
		  /* 820A9C00h */ case    7:  		/* addi R6, R11, 2868 */
		/* 820A9C00h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xB34);
		/* 820A9C00h case    7:*/		return 0x820A9C04;
		  /* 820A9C04h */ case    8:  		/* b -884 */
		/* 820A9C04h case    8:*/		return 0x820A9890;
		/* 820A9C04h case    8:*/		return 0x820A9C08;
	}
	return 0x820A9C08;
} // Block from 820A9BE4h-820A9C08h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820A9C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9C08);
		  /* 820A9C08h */ case    0:  		/* lwz R11, <#[R29 + 160]> */
		/* 820A9C08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000A0) );
		/* 820A9C08h case    0:*/		return 0x820A9C0C;
		  /* 820A9C0Ch */ case    1:  		/* li R6, 1 */
		/* 820A9C0Ch case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820A9C0Ch case    1:*/		return 0x820A9C10;
		  /* 820A9C10h */ case    2:  		/* mr R4, R31 */
		/* 820A9C10h case    2:*/		regs.R4 = regs.R31;
		/* 820A9C10h case    2:*/		return 0x820A9C14;
		  /* 820A9C14h */ case    3:  		/* mr R3, R30 */
		/* 820A9C14h case    3:*/		regs.R3 = regs.R30;
		/* 820A9C14h case    3:*/		return 0x820A9C18;
		  /* 820A9C18h */ case    4:  		/* stw R11, <#[R27]> */
		/* 820A9C18h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A9C18h case    4:*/		return 0x820A9C1C;
		  /* 820A9C1Ch */ case    5:  		/* lwz R5, <#[R29 + 160]> */
		/* 820A9C1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x000000A0) );
		/* 820A9C1Ch case    5:*/		return 0x820A9C20;
		  /* 820A9C20h */ case    6:  		/* bl -1704 */
		/* 820A9C20h case    6:*/		regs.LR = 0x820A9C24; return 0x820A9578;
		/* 820A9C20h case    6:*/		return 0x820A9C24;
		  /* 820A9C24h */ case    7:  		/* lwz R11, <#[R29 + 160]> */
		/* 820A9C24h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000A0) );
		/* 820A9C24h case    7:*/		return 0x820A9C28;
		  /* 820A9C28h */ case    8:  		/* addi R11, R11, 1 */
		/* 820A9C28h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9C28h case    8:*/		return 0x820A9C2C;
		  /* 820A9C2Ch */ case    9:  		/* stw R11, <#[R29 + 160]> */
		/* 820A9C2Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x000000A0) );
		/* 820A9C2Ch case    9:*/		return 0x820A9C30;
	}
	return 0x820A9C30;
} // Block from 820A9C08h-820A9C30h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A9C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9C30);
		  /* 820A9C30h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 820A9C30h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820A9C30h case    0:*/		return 0x820A9C34;
		  /* 820A9C34h */ case    1:  		/* bc 12, CR6_EQ, 460 */
		/* 820A9C34h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A9E00;  }
		/* 820A9C34h case    1:*/		return 0x820A9C38;
	}
	return 0x820A9C38;
} // Block from 820A9C30h-820A9C38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A9C38h
// Function '?UCodeBufferAllocCallback@D3DXShader@@YAJPAXKPAPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9C38);
		  /* 820A9C38h */ case    0:  		/* lis R11, -32255 */
		/* 820A9C38h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9C38h case    0:*/		return 0x820A9C3C;
		  /* 820A9C3Ch */ case    1:  		/* addi R6, R11, 2804 */
		/* 820A9C3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xAF4);
		/* 820A9C3Ch case    1:*/		return 0x820A9C40;
		  /* 820A9C40h */ case    2:  		/* b -944 */
		/* 820A9C40h case    2:*/		return 0x820A9890;
		/* 820A9C40h case    2:*/		return 0x820A9C44;
	}
	return 0x820A9C44;
} // Block from 820A9C38h-820A9C44h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A9C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9C44);
		  /* 820A9C44h */ case    0:  		/* lis R11, -32255 */
		/* 820A9C44h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9C44h case    0:*/		return 0x820A9C48;
		  /* 820A9C48h */ case    1:  		/* addi R6, R11, 2664 */
		/* 820A9C48h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xA68);
		/* 820A9C48h case    1:*/		return 0x820A9C4C;
		  /* 820A9C4Ch */ case    2:  		/* b -956 */
		/* 820A9C4Ch case    2:*/		return 0x820A9890;
		/* 820A9C4Ch case    2:*/		return 0x820A9C50;
	}
	return 0x820A9C50;
} // Block from 820A9C44h-820A9C50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A9C50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9C50);
		  /* 820A9C50h */ case    0:  		/* mr R11, R31 */
		/* 820A9C50h case    0:*/		regs.R11 = regs.R31;
		/* 820A9C50h case    0:*/		return 0x820A9C54;
		  /* 820A9C54h */ case    1:  		/* addi R6, R31, 2 */
		/* 820A9C54h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2);
		/* 820A9C54h case    1:*/		return 0x820A9C58;
		  /* 820A9C58h */ case    2:  		/* lbz R7, <#[R11]> */
		/* 820A9C58h case    2:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9C58h case    2:*/		return 0x820A9C5C;
		  /* 820A9C5Ch */ case    3:  		/* lbz R5, <#[R8]> */
		/* 820A9C5Ch case    3:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000000) );
		/* 820A9C5Ch case    3:*/		return 0x820A9C60;
		  /* 820A9C60h */ case    4:  		/* subf. R7, R5, R7 */
		/* 820A9C60h case    4:*/		cpu::op::subf<1>(regs,&regs.R7,regs.R5,regs.R7);
		/* 820A9C60h case    4:*/		return 0x820A9C64;
		  /* 820A9C64h */ case    5:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9C64h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820A9C78;  }
		/* 820A9C64h case    5:*/		return 0x820A9C68;
		  /* 820A9C68h */ case    6:  		/* addi R11, R11, 1 */
		/* 820A9C68h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9C68h case    6:*/		return 0x820A9C6C;
		  /* 820A9C6Ch */ case    7:  		/* addi R8, R8, 1 */
		/* 820A9C6Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820A9C6Ch case    7:*/		return 0x820A9C70;
		  /* 820A9C70h */ case    8:  		/* cmpw CR6, R11, R6 */
		/* 820A9C70h case    8:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R6);
		/* 820A9C70h case    8:*/		return 0x820A9C74;
		  /* 820A9C74h */ case    9:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9C74h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A9C58;  }
		/* 820A9C74h case    9:*/		return 0x820A9C78;
	}
	return 0x820A9C78;
} // Block from 820A9C50h-820A9C78h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A9C78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9C78);
		  /* 820A9C78h */ case    0:  		/* cmpwi CR0, R7, 0 */
		/* 820A9C78h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R7,0x00000000);
		/* 820A9C78h case    0:*/		return 0x820A9C7C;
		  /* 820A9C7Ch */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A9C7Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A9C8C;  }
		/* 820A9C7Ch case    1:*/		return 0x820A9C80;
		  /* 820A9C80h */ case    2:  		/* li R11, 14 */
		/* 820A9C80h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xE);
		/* 820A9C80h case    2:*/		return 0x820A9C84;
		  /* 820A9C84h */ case    3:  		/* mr R30, R4 */
		/* 820A9C84h case    3:*/		regs.R30 = regs.R4;
		/* 820A9C84h case    3:*/		return 0x820A9C88;
	}
	return 0x820A9C88;
} // Block from 820A9C78h-820A9C88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A9C88h
// Function '?GetShaderMicrocode@D3DXShader@@YAJKPBKKPAPAUID3DXBuffer@@PAXP6AX2HKPBD@ZPAU_D3DXSHADER_COMPILE_PARAMETERSA@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9C88);
		  /* 820A9C88h */ case    0:  		/* b 132 */
		/* 820A9C88h case    0:*/		return 0x820A9D0C;
		/* 820A9C88h case    0:*/		return 0x820A9C8C;
	}
	return 0x820A9C8C;
} // Block from 820A9C88h-820A9C8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A9C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9C8C);
		  /* 820A9C8Ch */ case    0:  		/* mr R11, R31 */
		/* 820A9C8Ch case    0:*/		regs.R11 = regs.R31;
		/* 820A9C8Ch case    0:*/		return 0x820A9C90;
		  /* 820A9C90h */ case    1:  		/* addi R7, R31, 2 */
		/* 820A9C90h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R31,0x2);
		/* 820A9C90h case    1:*/		return 0x820A9C94;
		  /* 820A9C94h */ case    2:  		/* lbz R8, <#[R11]> */
		/* 820A9C94h case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9C94h case    2:*/		return 0x820A9C98;
		  /* 820A9C98h */ case    3:  		/* lbz R6, <#[R9]> */
		/* 820A9C98h case    3:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000000) );
		/* 820A9C98h case    3:*/		return 0x820A9C9C;
		  /* 820A9C9Ch */ case    4:  		/* subf. R8, R6, R8 */
		/* 820A9C9Ch case    4:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R6,regs.R8);
		/* 820A9C9Ch case    4:*/		return 0x820A9CA0;
		  /* 820A9CA0h */ case    5:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9CA0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820A9CB4;  }
		/* 820A9CA0h case    5:*/		return 0x820A9CA4;
		  /* 820A9CA4h */ case    6:  		/* addi R11, R11, 1 */
		/* 820A9CA4h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9CA4h case    6:*/		return 0x820A9CA8;
		  /* 820A9CA8h */ case    7:  		/* addi R9, R9, 1 */
		/* 820A9CA8h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820A9CA8h case    7:*/		return 0x820A9CAC;
		  /* 820A9CACh */ case    8:  		/* cmpw CR6, R11, R7 */
		/* 820A9CACh case    8:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R7);
		/* 820A9CACh case    8:*/		return 0x820A9CB0;
		  /* 820A9CB0h */ case    9:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9CB0h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A9C94;  }
		/* 820A9CB0h case    9:*/		return 0x820A9CB4;
	}
	return 0x820A9CB4;
} // Block from 820A9C8Ch-820A9CB4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A9CB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9CB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9CB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9CB4);
		  /* 820A9CB4h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A9CB4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A9CB4h case    0:*/		return 0x820A9CB8;
		  /* 820A9CB8h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A9CB8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A9CC8;  }
		/* 820A9CB8h case    1:*/		return 0x820A9CBC;
		  /* 820A9CBCh */ case    2:  		/* li R11, 7 */
		/* 820A9CBCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820A9CBCh case    2:*/		return 0x820A9CC0;
		  /* 820A9CC0h */ case    3:  		/* li R30, 1 */
		/* 820A9CC0h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820A9CC0h case    3:*/		return 0x820A9CC4;
		  /* 820A9CC4h */ case    4:  		/* b 72 */
		/* 820A9CC4h case    4:*/		return 0x820A9D0C;
		/* 820A9CC4h case    4:*/		return 0x820A9CC8;
	}
	return 0x820A9CC8;
} // Block from 820A9CB4h-820A9CC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A9CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9CC8);
		  /* 820A9CC8h */ case    0:  		/* mr R11, R31 */
		/* 820A9CC8h case    0:*/		regs.R11 = regs.R31;
		/* 820A9CC8h case    0:*/		return 0x820A9CCC;
		  /* 820A9CCCh */ case    1:  		/* addi R8, R31, 2 */
		/* 820A9CCCh case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x2);
		/* 820A9CCCh case    1:*/		return 0x820A9CD0;
		  /* 820A9CD0h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820A9CD0h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9CD0h case    2:*/		return 0x820A9CD4;
		  /* 820A9CD4h */ case    3:  		/* lbz R7, <#[R10]> */
		/* 820A9CD4h case    3:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820A9CD4h case    3:*/		return 0x820A9CD8;
		  /* 820A9CD8h */ case    4:  		/* subf. R9, R7, R9 */
		/* 820A9CD8h case    4:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820A9CD8h case    4:*/		return 0x820A9CDC;
		  /* 820A9CDCh */ case    5:  		/* bc 4, CR0_EQ, 20 */
		/* 820A9CDCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x820A9CF0;  }
		/* 820A9CDCh case    5:*/		return 0x820A9CE0;
		  /* 820A9CE0h */ case    6:  		/* addi R11, R11, 1 */
		/* 820A9CE0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9CE0h case    6:*/		return 0x820A9CE4;
		  /* 820A9CE4h */ case    7:  		/* addi R10, R10, 1 */
		/* 820A9CE4h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A9CE4h case    7:*/		return 0x820A9CE8;
		  /* 820A9CE8h */ case    8:  		/* cmpw CR6, R11, R8 */
		/* 820A9CE8h case    8:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820A9CE8h case    8:*/		return 0x820A9CEC;
		  /* 820A9CECh */ case    9:  		/* bc 4, CR6_EQ, -28 */
		/* 820A9CECh case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A9CD0;  }
		/* 820A9CECh case    9:*/		return 0x820A9CF0;
	}
	return 0x820A9CF0;
} // Block from 820A9CC8h-820A9CF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820A9CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9CF0);
		  /* 820A9CF0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820A9CF0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820A9CF0h case    0:*/		return 0x820A9CF4;
		  /* 820A9CF4h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820A9CF4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A9D04;  }
		/* 820A9CF4h case    1:*/		return 0x820A9CF8;
		  /* 820A9CF8h */ case    2:  		/* li R11, 10 */
		/* 820A9CF8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 820A9CF8h case    2:*/		return 0x820A9CFC;
		  /* 820A9CFCh */ case    3:  		/* li R30, 2 */
		/* 820A9CFCh case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 820A9CFCh case    3:*/		return 0x820A9D00;
		  /* 820A9D00h */ case    4:  		/* b 12 */
		/* 820A9D00h case    4:*/		return 0x820A9D0C;
		/* 820A9D00h case    4:*/		return 0x820A9D04;
	}
	return 0x820A9D04;
} // Block from 820A9CF0h-820A9D04h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820A9D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9D04);
		  /* 820A9D04h */ case    0:  		/* li R11, 2 */
		/* 820A9D04h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820A9D04h case    0:*/		return 0x820A9D08;
		  /* 820A9D08h */ case    1:  		/* li R30, 3 */
		/* 820A9D08h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x3);
		/* 820A9D08h case    1:*/		return 0x820A9D0C;
	}
	return 0x820A9D0C;
} // Block from 820A9D04h-820A9D0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A9D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9D0C);
		  /* 820A9D0Ch */ case    0:  		/* stw R11, <#[R28]> */
		/* 820A9D0Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820A9D0Ch case    0:*/		return 0x820A9D10;
		  /* 820A9D10h */ case    1:  		/* mr R4, R31 */
		/* 820A9D10h case    1:*/		regs.R4 = regs.R31;
		/* 820A9D10h case    1:*/		return 0x820A9D14;
		  /* 820A9D14h */ case    2:  		/* mr R3, R29 */
		/* 820A9D14h case    2:*/		regs.R3 = regs.R29;
		/* 820A9D14h case    2:*/		return 0x820A9D18;
		  /* 820A9D18h */ case    3:  		/* bl -4392 */
		/* 820A9D18h case    3:*/		regs.LR = 0x820A9D1C; return 0x820A8BF0;
		/* 820A9D18h case    3:*/		return 0x820A9D1C;
		  /* 820A9D1Ch */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820A9D1Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820A9D1Ch case    4:*/		return 0x820A9D20;
		  /* 820A9D20h */ case    5:  		/* bc 12, CR0_EQ, 24 */
		/* 820A9D20h case    5:*/		if ( regs.CR[0].eq ) { return 0x820A9D38;  }
		/* 820A9D20h case    5:*/		return 0x820A9D24;
		  /* 820A9D24h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 820A9D24h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820A9D24h case    6:*/		return 0x820A9D28;
		  /* 820A9D28h */ case    7:  		/* stw R11, <#[R27]> */
		/* 820A9D28h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A9D28h case    7:*/		return 0x820A9D2C;
		  /* 820A9D2Ch */ case    8:  		/* lwz R8, <#[R3 + 8]> */
		/* 820A9D2Ch case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 820A9D2Ch case    8:*/		return 0x820A9D30;
		  /* 820A9D30h */ case    9:  		/* stw R8, <#[R1 + 84]> */
		/* 820A9D30h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 820A9D30h case    9:*/		return 0x820A9D34;
		  /* 820A9D34h */ case   10:  		/* b 140 */
		/* 820A9D34h case   10:*/		return 0x820A9DC0;
		/* 820A9D34h case   10:*/		return 0x820A9D38;
	}
	return 0x820A9D38;
} // Block from 820A9D0Ch-820A9D38h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820A9D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9D38);
		  /* 820A9D38h */ case    0:  		/* addi R6, R1, 84 */
		/* 820A9D38h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820A9D38h case    0:*/		return 0x820A9D3C;
		  /* 820A9D3Ch */ case    1:  		/* mr R5, R31 */
		/* 820A9D3Ch case    1:*/		regs.R5 = regs.R31;
		/* 820A9D3Ch case    1:*/		return 0x820A9D40;
		  /* 820A9D40h */ case    2:  		/* mr R4, R25 */
		/* 820A9D40h case    2:*/		regs.R4 = regs.R25;
		/* 820A9D40h case    2:*/		return 0x820A9D44;
		  /* 820A9D44h */ case    3:  		/* mr R3, R26 */
		/* 820A9D44h case    3:*/		regs.R3 = regs.R26;
		/* 820A9D44h case    3:*/		return 0x820A9D48;
		  /* 820A9D48h */ case    4:  		/* bl 145320 */
		/* 820A9D48h case    4:*/		regs.LR = 0x820A9D4C; return 0x820CD4F0;
		/* 820A9D48h case    4:*/		return 0x820A9D4C;
		  /* 820A9D4Ch */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820A9D4Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A9D4Ch case    5:*/		return 0x820A9D50;
		  /* 820A9D50h */ case    6:  		/* bc 12, CR0_LT, 180 */
		/* 820A9D50h case    6:*/		if ( regs.CR[0].lt ) { return 0x820A9E04;  }
		/* 820A9D50h case    6:*/		return 0x820A9D54;
		  /* 820A9D54h */ case    7:  		/* lwz R6, <#[R1 + 84]> */
		/* 820A9D54h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820A9D54h case    7:*/		return 0x820A9D58;
		  /* 820A9D58h */ case    8:  		/* cmplwi CR6, R6, 0 */
		/* 820A9D58h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820A9D58h case    8:*/		return 0x820A9D5C;
		  /* 820A9D5Ch */ case    9:  		/* bc 4, CR6_EQ, 40 */
		/* 820A9D5Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820A9D84;  }
		/* 820A9D5Ch case    9:*/		return 0x820A9D60;
		  /* 820A9D60h */ case   10:  		/* lis R11, -32255 */
		/* 820A9D60h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9D60h case   10:*/		return 0x820A9D64;
		  /* 820A9D64h */ case   11:  		/* addi R8, R31, 2 */
		/* 820A9D64h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x2);
		/* 820A9D64h case   11:*/		return 0x820A9D68;
		  /* 820A9D68h */ case   12:  		/* addi R6, R11, 2600 */
		/* 820A9D68h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xA28);
		/* 820A9D68h case   12:*/		return 0x820A9D6C;
		  /* 820A9D6Ch */ case   13:  		/* mr R7, R31 */
		/* 820A9D6Ch case   13:*/		regs.R7 = regs.R31;
		/* 820A9D6Ch case   13:*/		return 0x820A9D70;
		  /* 820A9D70h */ case   14:  		/* li R5, 2005 */
		/* 820A9D70h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x7D5);
		/* 820A9D70h case   14:*/		return 0x820A9D74;
		  /* 820A9D74h */ case   15:  		/* mr R4, R25 */
		/* 820A9D74h case   15:*/		regs.R4 = regs.R25;
		/* 820A9D74h case   15:*/		return 0x820A9D78;
		  /* 820A9D78h */ case   16:  		/* mr R3, R24 */
		/* 820A9D78h case   16:*/		regs.R3 = regs.R24;
		/* 820A9D78h case   16:*/		return 0x820A9D7C;
		  /* 820A9D7Ch */ case   17:  		/* bl -11244 */
		/* 820A9D7Ch case   17:*/		regs.LR = 0x820A9D80; return 0x820A7190;
		/* 820A9D7Ch case   17:*/		return 0x820A9D80;
		  /* 820A9D80h */ case   18:  		/* b -1244 */
		/* 820A9D80h case   18:*/		return 0x820A98A4;
		/* 820A9D80h case   18:*/		return 0x820A9D84;
	}
	return 0x820A9D84;
} // Block from 820A9D38h-820A9D84h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820A9D84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9D84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9D84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9D84);
		  /* 820A9D84h */ case    0:  		/* addi R11, R30, 35 */
		/* 820A9D84h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x23);
		/* 820A9D84h case    0:*/		return 0x820A9D88;
		  /* 820A9D88h */ case    1:  		/* mr R4, R31 */
		/* 820A9D88h case    1:*/		regs.R4 = regs.R31;
		/* 820A9D88h case    1:*/		return 0x820A9D8C;
		  /* 820A9D8Ch */ case    2:  		/* rlwinm R30, R11, 2, 0, 29 */
		/* 820A9D8Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R11);
		/* 820A9D8Ch case    2:*/		return 0x820A9D90;
		  /* 820A9D90h */ case    3:  		/* mr R3, R29 */
		/* 820A9D90h case    3:*/		regs.R3 = regs.R29;
		/* 820A9D90h case    3:*/		return 0x820A9D94;
		  /* 820A9D94h */ case    4:  		/* lwzx R11, <#[R30 + R29]> */
		/* 820A9D94h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 820A9D94h case    4:*/		return 0x820A9D98;
		  /* 820A9D98h */ case    5:  		/* stw R11, <#[R27]> */
		/* 820A9D98h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A9D98h case    5:*/		return 0x820A9D9C;
		  /* 820A9D9Ch */ case    6:  		/* lwzx R5, <#[R30 + R29]> */
		/* 820A9D9Ch case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 820A9D9Ch case    6:*/		return 0x820A9DA0;
		  /* 820A9DA0h */ case    7:  		/* bl -2088 */
		/* 820A9DA0h case    7:*/		regs.LR = 0x820A9DA4; return 0x820A9578;
		/* 820A9DA0h case    7:*/		return 0x820A9DA4;
		  /* 820A9DA4h */ case    8:  		/* lwzx R11, <#[R30 + R29]> */
		/* 820A9DA4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 820A9DA4h case    8:*/		return 0x820A9DA8;
		  /* 820A9DA8h */ case    9:  		/* lwz R8, <#[R1 + 84]> */
		/* 820A9DA8h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 820A9DA8h case    9:*/		return 0x820A9DAC;
		  /* 820A9DACh */ case   10:  		/* add R11, R11, R8 */
		/* 820A9DACh case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820A9DACh case   10:*/		return 0x820A9DB0;
		  /* 820A9DB0h */ case   11:  		/* stwx R11, <#[R30 + R29]> */
		/* 820A9DB0h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 820A9DB0h case   11:*/		return 0x820A9DB4;
		  /* 820A9DB4h */ case   12:  		/* lwz R11, <#[R29 + 172]> */
		/* 820A9DB4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000AC) );
		/* 820A9DB4h case   12:*/		return 0x820A9DB8;
		  /* 820A9DB8h */ case   13:  		/* addi R11, R11, 1 */
		/* 820A9DB8h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9DB8h case   13:*/		return 0x820A9DBC;
		  /* 820A9DBCh */ case   14:  		/* stw R11, <#[R29 + 172]> */
		/* 820A9DBCh case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x000000AC) );
		/* 820A9DBCh case   14:*/		return 0x820A9DC0;
	}
	return 0x820A9DC0;
} // Block from 820A9D84h-820A9DC0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820A9DC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9DC0);
		  /* 820A9DC0h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 820A9DC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820A9DC0h case    0:*/		return 0x820A9DC4;
		  /* 820A9DC4h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 820A9DC4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820A9E00;  }
		/* 820A9DC4h case    1:*/		return 0x820A9DC8;
		  /* 820A9DC8h */ case    2:  		/* lwz R9, <#[R23 + 24]> */
		/* 820A9DC8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000018) );
		/* 820A9DC8h case    2:*/		return 0x820A9DCC;
		  /* 820A9DCCh */ case    3:  		/* cmplw CR6, R9, R8 */
		/* 820A9DCCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820A9DCCh case    3:*/		return 0x820A9DD0;
		  /* 820A9DD0h */ case    4:  		/* bc 4, CR6_GT, 36 */
		/* 820A9DD0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820A9DF4;  }
		/* 820A9DD0h case    4:*/		return 0x820A9DD4;
		  /* 820A9DD4h */ case    5:  		/* lis R11, -32255 */
		/* 820A9DD4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9DD4h case    5:*/		return 0x820A9DD8;
		  /* 820A9DD8h */ case    6:  		/* mr R7, R31 */
		/* 820A9DD8h case    6:*/		regs.R7 = regs.R31;
		/* 820A9DD8h case    6:*/		return 0x820A9DDC;
		  /* 820A9DDCh */ case    7:  		/* addi R6, R11, 2520 */
		/* 820A9DDCh case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x9D8);
		/* 820A9DDCh case    7:*/		return 0x820A9DE0;
		  /* 820A9DE0h */ case    8:  		/* li R5, 2005 */
		/* 820A9DE0h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x7D5);
		/* 820A9DE0h case    8:*/		return 0x820A9DE4;
		  /* 820A9DE4h */ case    9:  		/* mr R4, R25 */
		/* 820A9DE4h case    9:*/		regs.R4 = regs.R25;
		/* 820A9DE4h case    9:*/		return 0x820A9DE8;
		  /* 820A9DE8h */ case   10:  		/* mr R3, R24 */
		/* 820A9DE8h case   10:*/		regs.R3 = regs.R24;
		/* 820A9DE8h case   10:*/		return 0x820A9DEC;
		  /* 820A9DECh */ case   11:  		/* bl -11356 */
		/* 820A9DECh case   11:*/		regs.LR = 0x820A9DF0; return 0x820A7190;
		/* 820A9DECh case   11:*/		return 0x820A9DF0;
		  /* 820A9DF0h */ case   12:  		/* b -1356 */
		/* 820A9DF0h case   12:*/		return 0x820A98A4;
		/* 820A9DF0h case   12:*/		return 0x820A9DF4;
	}
	return 0x820A9DF4;
} // Block from 820A9DC0h-820A9DF4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820A9DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9DF4);
		  /* 820A9DF4h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 820A9DF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A9DF4h case    0:*/		return 0x820A9DF8;
		  /* 820A9DF8h */ case    1:  		/* add R11, R9, R11 */
		/* 820A9DF8h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820A9DF8h case    1:*/		return 0x820A9DFC;
	}
	return 0x820A9DFC;
} // Block from 820A9DF4h-820A9DFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A9DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9DFC);
		  /* 820A9DFCh */ case    0:  		/* stw R11, <#[R27]> */
		/* 820A9DFCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820A9DFCh case    0:*/		return 0x820A9E00;
	}
	return 0x820A9E00;
} // Block from 820A9DFCh-820A9E00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A9E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9E00);
		  /* 820A9E00h */ case    0:  		/* li R3, 0 */
		/* 820A9E00h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820A9E00h case    0:*/		return 0x820A9E04;
	}
	return 0x820A9E04;
} // Block from 820A9E00h-820A9E04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A9E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9E04);
		  /* 820A9E04h */ case    0:  		/* addi R1, R1, 176 */
		/* 820A9E04h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820A9E04h case    0:*/		return 0x820A9E08;
		  /* 820A9E08h */ case    1:  		/* b -101236 */
		/* 820A9E08h case    1:*/		return 0x82091294;
		/* 820A9E08h case    1:*/		return 0x820A9E0C;
		  /* 820A9E0Ch */ case    2:  		/* nop */
		/* 820A9E0Ch case    2:*/		cpu::op::nop();
		/* 820A9E0Ch case    2:*/		return 0x820A9E10;
	}
	return 0x820A9E10;
} // Block from 820A9E04h-820A9E10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A9E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9E10);
		  /* 820A9E10h */ case    0:  		/* mfspr R12, LR */
		/* 820A9E10h case    0:*/		regs.R12 = regs.LR;
		/* 820A9E10h case    0:*/		return 0x820A9E14;
		  /* 820A9E14h */ case    1:  		/* bl -101364 */
		/* 820A9E14h case    1:*/		regs.LR = 0x820A9E18; return 0x82091220;
		/* 820A9E14h case    1:*/		return 0x820A9E18;
		  /* 820A9E18h */ case    2:  		/* stwu R1, <#[R1 - 304]> */
		/* 820A9E18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFED0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFED0);
		/* 820A9E18h case    2:*/		return 0x820A9E1C;
		  /* 820A9E1Ch */ case    3:  		/* lwz R24, <#[R4 + 8]> */
		/* 820A9E1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R4 + 0x00000008) );
		/* 820A9E1Ch case    3:*/		return 0x820A9E20;
		  /* 820A9E20h */ case    4:  		/* li R14, 0 */
		/* 820A9E20h case    4:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 820A9E20h case    4:*/		return 0x820A9E24;
		  /* 820A9E24h */ case    5:  		/* stw R4, <#[R1 + 332]> */
		/* 820A9E24h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000014C) );
		/* 820A9E24h case    5:*/		return 0x820A9E28;
		  /* 820A9E28h */ case    6:  		/* mr R31, R5 */
		/* 820A9E28h case    6:*/		regs.R31 = regs.R5;
		/* 820A9E28h case    6:*/		return 0x820A9E2C;
		  /* 820A9E2Ch */ case    7:  		/* stw R5, <#[R1 + 340]> */
		/* 820A9E2Ch case    7:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000154) );
		/* 820A9E2Ch case    7:*/		return 0x820A9E30;
		  /* 820A9E30h */ case    8:  		/* li R28, 1 */
		/* 820A9E30h case    8:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820A9E30h case    8:*/		return 0x820A9E34;
		  /* 820A9E34h */ case    9:  		/* stw R3, <#[R1 + 324]> */
		/* 820A9E34h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000144) );
		/* 820A9E34h case    9:*/		return 0x820A9E38;
		  /* 820A9E38h */ case   10:  		/* mr R29, R14 */
		/* 820A9E38h case   10:*/		regs.R29 = regs.R14;
		/* 820A9E38h case   10:*/		return 0x820A9E3C;
		  /* 820A9E3Ch */ case   11:  		/* stw R14, <#[R1 + 116]> */
		/* 820A9E3Ch case   11:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000074) );
		/* 820A9E3Ch case   11:*/		return 0x820A9E40;
		  /* 820A9E40h */ case   12:  		/* mr R26, R14 */
		/* 820A9E40h case   12:*/		regs.R26 = regs.R14;
		/* 820A9E40h case   12:*/		return 0x820A9E44;
		  /* 820A9E44h */ case   13:  		/* lbz R11, <#[R24]> */
		/* 820A9E44h case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 820A9E44h case   13:*/		return 0x820A9E48;
		  /* 820A9E48h */ case   14:  		/* mr R27, R14 */
		/* 820A9E48h case   14:*/		regs.R27 = regs.R14;
		/* 820A9E48h case   14:*/		return 0x820A9E4C;
		  /* 820A9E4Ch */ case   15:  		/* stw R14, <#[R1 + 100]> */
		/* 820A9E4Ch case   15:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000064) );
		/* 820A9E4Ch case   15:*/		return 0x820A9E50;
		  /* 820A9E50h */ case   16:  		/* mr R15, R24 */
		/* 820A9E50h case   16:*/		regs.R15 = regs.R24;
		/* 820A9E50h case   16:*/		return 0x820A9E54;
		  /* 820A9E54h */ case   17:  		/* stw R24, <#[R1 + 108]> */
		/* 820A9E54h case   17:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x0000006C) );
		/* 820A9E54h case   17:*/		return 0x820A9E58;
		  /* 820A9E58h */ case   18:  		/* cmplwi CR0, R11, 0 */
		/* 820A9E58h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A9E58h case   18:*/		return 0x820A9E5C;
		  /* 820A9E5Ch */ case   19:  		/* stw R14, <#[R1 + 96]> */
		/* 820A9E5Ch case   19:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000060) );
		/* 820A9E5Ch case   19:*/		return 0x820A9E60;
		  /* 820A9E60h */ case   20:  		/* stw R14, <#[R1 + 104]> */
		/* 820A9E60h case   20:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000068) );
		/* 820A9E60h case   20:*/		return 0x820A9E64;
		  /* 820A9E64h */ case   21:  		/* stw R14, <#[R1 + 112]> */
		/* 820A9E64h case   21:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000070) );
		/* 820A9E64h case   21:*/		return 0x820A9E68;
		  /* 820A9E68h */ case   22:  		/* bc 12, CR0_EQ, 1380 */
		/* 820A9E68h case   22:*/		if ( regs.CR[0].eq ) { return 0x820AA3CC;  }
		/* 820A9E68h case   22:*/		return 0x820A9E6C;
		  /* 820A9E6Ch */ case   23:  		/* lis R11, -32255 */
		/* 820A9E6Ch case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820A9E6Ch case   23:*/		return 0x820A9E70;
		  /* 820A9E70h */ case   24:  		/* lis R10, -32255 */
		/* 820A9E70h case   24:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820A9E70h case   24:*/		return 0x820A9E74;
		  /* 820A9E74h */ case   25:  		/* lis R9, -32255 */
		/* 820A9E74h case   25:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820A9E74h case   25:*/		return 0x820A9E78;
		  /* 820A9E78h */ case   26:  		/* lis R8, -32255 */
		/* 820A9E78h case   26:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 820A9E78h case   26:*/		return 0x820A9E7C;
		  /* 820A9E7Ch */ case   27:  		/* lis R7, -32255 */
		/* 820A9E7Ch case   27:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8201);
		/* 820A9E7Ch case   27:*/		return 0x820A9E80;
		  /* 820A9E80h */ case   28:  		/* lis R6, -32255 */
		/* 820A9E80h case   28:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8201);
		/* 820A9E80h case   28:*/		return 0x820A9E84;
		  /* 820A9E84h */ case   29:  		/* lis R5, -32255 */
		/* 820A9E84h case   29:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8201);
		/* 820A9E84h case   29:*/		return 0x820A9E88;
		  /* 820A9E88h */ case   30:  		/* lis R4, -32255 */
		/* 820A9E88h case   30:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8201);
		/* 820A9E88h case   30:*/		return 0x820A9E8C;
		  /* 820A9E8Ch */ case   31:  		/* lis R3, -32255 */
		/* 820A9E8Ch case   31:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8201);
		/* 820A9E8Ch case   31:*/		return 0x820A9E90;
		  /* 820A9E90h */ case   32:  		/* addi R25, R11, 400 */
		/* 820A9E90h case   32:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0x190);
		/* 820A9E90h case   32:*/		return 0x820A9E94;
		  /* 820A9E94h */ case   33:  		/* addi R23, R10, -8328 */
		/* 820A9E94h case   33:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0xFFFFDF78);
		/* 820A9E94h case   33:*/		return 0x820A9E98;
		  /* 820A9E98h */ case   34:  		/* addi R22, R9, 3460 */
		/* 820A9E98h case   34:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R9,0xD84);
		/* 820A9E98h case   34:*/		return 0x820A9E9C;
		  /* 820A9E9Ch */ case   35:  		/* addi R21, R8, 3456 */
		/* 820A9E9Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R8,0xD80);
		/* 820A9E9Ch case   35:*/		return 0x820A9EA0;
		  /* 820A9EA0h */ case   36:  		/* addi R20, R7, 3452 */
		/* 820A9EA0h case   36:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R7,0xD7C);
		/* 820A9EA0h case   36:*/		return 0x820A9EA4;
		  /* 820A9EA4h */ case   37:  		/* addi R19, R6, 3448 */
		/* 820A9EA4h case   37:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R6,0xD78);
		/* 820A9EA4h case   37:*/		return 0x820A9EA8;
		  /* 820A9EA8h */ case   38:  		/* addi R18, R5, 3444 */
		/* 820A9EA8h case   38:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R5,0xD74);
		/* 820A9EA8h case   38:*/		return 0x820A9EAC;
		  /* 820A9EACh */ case   39:  		/* addi R17, R4, 3440 */
		/* 820A9EACh case   39:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R4,0xD70);
		/* 820A9EACh case   39:*/		return 0x820A9EB0;
		  /* 820A9EB0h */ case   40:  		/* addi R16, R3, 3432 */
		/* 820A9EB0h case   40:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R3,0xD68);
		/* 820A9EB0h case   40:*/		return 0x820A9EB4;
		  /* 820A9EB4h */ case   41:  		/* lbz R11, <#[R15]> */
		/* 820A9EB4h case   41:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 820A9EB4h case   41:*/		return 0x820A9EB8;
		  /* 820A9EB8h */ case   42:  		/* b 16 */
		/* 820A9EB8h case   42:*/		return 0x820A9EC8;
		/* 820A9EB8h case   42:*/		return 0x820A9EBC;
		  /* 820A9EBCh */ case   43:  		/* cmpwi CR6, R30, 95 */
		/* 820A9EBCh case   43:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x0000005F);
		/* 820A9EBCh case   43:*/		return 0x820A9EC0;
		  /* 820A9EC0h */ case   44:  		/* bc 12, CR6_EQ, 16 */
		/* 820A9EC0h case   44:*/		if ( regs.CR[6].eq ) { return 0x820A9ED0;  }
		/* 820A9EC0h case   44:*/		return 0x820A9EC4;
		  /* 820A9EC4h */ case   45:  		/* lbzu R11, <#[R15 + 1]> */
		/* 820A9EC4h case   45:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000001) );
		regs.R15 = (uint32)(regs.R15 + 0x00000001);
		/* 820A9EC4h case   45:*/		return 0x820A9EC8;
	}
	return 0x820A9EC8;
} // Block from 820A9E10h-820A9EC8h (46 instructions)

//////////////////////////////////////////////////////
// Block at 820A9EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9EC8);
		  /* 820A9EC8h */ case    0:  		/* extsb. R30, R11 */
		/* 820A9EC8h case    0:*/		cpu::op::extsb<1>(regs,&regs.R30,regs.R11);
		/* 820A9EC8h case    0:*/		return 0x820A9ECC;
		  /* 820A9ECCh */ case    1:  		/* bc 4, CR0_EQ, -16 */
		/* 820A9ECCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A9EBC;  }
		/* 820A9ECCh case    1:*/		return 0x820A9ED0;
	}
	return 0x820A9ED0;
} // Block from 820A9EC8h-820A9ED0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A9ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9ED0);
		  /* 820A9ED0h */ case    0:  		/* lwz R11, <#[R1 + 108]> */
		/* 820A9ED0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820A9ED0h case    0:*/		return 0x820A9ED4;
		  /* 820A9ED4h */ case    1:  		/* subf R31, R11, R15 */
		/* 820A9ED4h case    1:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R15);
		/* 820A9ED4h case    1:*/		return 0x820A9ED8;
		  /* 820A9ED8h */ case    2:  		/* cmplwi CR6, R31, 15 */
		/* 820A9ED8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x0000000F);
		/* 820A9ED8h case    2:*/		return 0x820A9EDC;
		  /* 820A9EDCh */ case    3:  		/* bc 12, CR6_GT, 1332 */
		/* 820A9EDCh case    3:*/		if ( regs.CR[6].gt ) { return 0x820AA410;  }
		/* 820A9EDCh case    3:*/		return 0x820A9EE0;
		  /* 820A9EE0h */ case    4:  		/* mr R5, R31 */
		/* 820A9EE0h case    4:*/		regs.R5 = regs.R31;
		/* 820A9EE0h case    4:*/		return 0x820A9EE4;
		  /* 820A9EE4h */ case    5:  		/* rlwinm R4, R11, 0, 0, 31 */
		/* 820A9EE4h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R4,regs.R11);
		/* 820A9EE4h case    5:*/		return 0x820A9EE8;
		  /* 820A9EE8h */ case    6:  		/* addi R3, R1, 128 */
		/* 820A9EE8h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 820A9EE8h case    6:*/		return 0x820A9EEC;
		  /* 820A9EECh */ case    7:  		/* bl -99644 */
		/* 820A9EECh case    7:*/		regs.LR = 0x820A9EF0; return 0x820919B0;
		/* 820A9EECh case    7:*/		return 0x820A9EF0;
	}
	return 0x820A9EF0;
} // Block from 820A9ED0h-820A9EF0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820A9EF0h
// Function '?MicrocodeErrorCallback@CAssembler@D3DXShader@@QAAXHKPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9EF0);
		  /* 820A9EF0h */ case    0:  		/* addi R11, R1, 128 */
		/* 820A9EF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820A9EF0h case    0:*/		return 0x820A9EF4;
		  /* 820A9EF4h */ case    1:  		/* li R10, 0 */
		/* 820A9EF4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820A9EF4h case    1:*/		return 0x820A9EF8;
		  /* 820A9EF8h */ case    2:  		/* cmpwi CR6, R30, 0 */
		/* 820A9EF8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820A9EF8h case    2:*/		return 0x820A9EFC;
		  /* 820A9EFCh */ case    3:  		/* stbx R10, <#[R31 + R11]> */
		/* 820A9EFCh case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820A9EFCh case    3:*/		return 0x820A9F00;
		  /* 820A9F00h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 820A9F00h case    4:*/		if ( regs.CR[6].eq ) { return 0x820A9F08;  }
		/* 820A9F00h case    4:*/		return 0x820A9F04;
		  /* 820A9F04h */ case    5:  		/* addi R15, R15, 1 */
		/* 820A9F04h case    5:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R15,0x1);
		/* 820A9F04h case    5:*/		return 0x820A9F08;
	}
	return 0x820A9F08;
} // Block from 820A9EF0h-820A9F08h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A9F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9F08);
		  /* 820A9F08h */ case    0:  		/* stw R15, <#[R1 + 108]> */
		/* 820A9F08h case    0:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x0000006C) );
		/* 820A9F08h case    0:*/		return 0x820A9F0C;
		  /* 820A9F0Ch */ case    1:  		/* cmpwi CR6, R28, 0 */
		/* 820A9F0Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820A9F0Ch case    1:*/		return 0x820A9F10;
		  /* 820A9F10h */ case    2:  		/* bc 12, CR6_EQ, 680 */
		/* 820A9F10h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA1B8;  }
		/* 820A9F10h case    2:*/		return 0x820A9F14;
		  /* 820A9F14h */ case    3:  		/* lbz R11, <#[R1 + 128]> */
		/* 820A9F14h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820A9F14h case    3:*/		return 0x820A9F18;
		  /* 820A9F18h */ case    4:  		/* addi R31, R1, 128 */
		/* 820A9F18h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x80);
		/* 820A9F18h case    4:*/		return 0x820A9F1C;
		  /* 820A9F1Ch */ case    5:  		/* b 28 */
		/* 820A9F1Ch case    5:*/		return 0x820A9F38;
		/* 820A9F1Ch case    5:*/		return 0x820A9F20;
		  /* 820A9F20h */ case    6:  		/* lbz R11, <#[R31]> */
		/* 820A9F20h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A9F20h case    6:*/		return 0x820A9F24;
		  /* 820A9F24h */ case    7:  		/* extsb R3, R11 */
		/* 820A9F24h case    7:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820A9F24h case    7:*/		return 0x820A9F28;
		  /* 820A9F28h */ case    8:  		/* bl -67640 */
		/* 820A9F28h case    8:*/		regs.LR = 0x820A9F2C; return 0x820996F0;
		/* 820A9F28h case    8:*/		return 0x820A9F2C;
		  /* 820A9F2Ch */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820A9F2Ch case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A9F2Ch case    9:*/		return 0x820A9F30;
		  /* 820A9F30h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 820A9F30h case   10:*/		if ( regs.CR[0].eq ) { return 0x820A9F40;  }
		/* 820A9F30h case   10:*/		return 0x820A9F34;
		  /* 820A9F34h */ case   11:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820A9F34h case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820A9F34h case   11:*/		return 0x820A9F38;
	}
	return 0x820A9F38;
} // Block from 820A9F08h-820A9F38h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820A9F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9F38);
		  /* 820A9F38h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 820A9F38h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A9F38h case    0:*/		return 0x820A9F3C;
		  /* 820A9F3Ch */ case    1:  		/* bc 4, CR0_EQ, -28 */
		/* 820A9F3Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A9F20;  }
		/* 820A9F3Ch case    1:*/		return 0x820A9F40;
	}
	return 0x820A9F40;
} // Block from 820A9F38h-820A9F40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A9F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9F40);
		  /* 820A9F40h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820A9F40h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A9F40h case    0:*/		return 0x820A9F44;
		  /* 820A9F44h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820A9F44h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A9F44h case    1:*/		return 0x820A9F48;
		  /* 820A9F48h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820A9F48h case    2:*/		if ( regs.CR[0].eq ) { return 0x820A9F5C;  }
		/* 820A9F48h case    2:*/		return 0x820A9F4C;
		  /* 820A9F4Ch */ case    3:  		/* mr R3, R31 */
		/* 820A9F4Ch case    3:*/		regs.R3 = regs.R31;
		/* 820A9F4Ch case    3:*/		return 0x820A9F50;
	}
	return 0x820A9F50;
} // Block from 820A9F40h-820A9F50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820A9F50h
// Function '??1CRegisterEntryNode@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9F50);
		  /* 820A9F50h */ case    0:  		/* bl -95208 */
		/* 820A9F50h case    0:*/		regs.LR = 0x820A9F54; return 0x82092B68;
		/* 820A9F50h case    0:*/		return 0x820A9F54;
		  /* 820A9F54h */ case    1:  		/* mr R26, R3 */
		/* 820A9F54h case    1:*/		regs.R26 = regs.R3;
		/* 820A9F54h case    1:*/		return 0x820A9F58;
		  /* 820A9F58h */ case    2:  		/* b 8 */
		/* 820A9F58h case    2:*/		return 0x820A9F60;
		/* 820A9F58h case    2:*/		return 0x820A9F5C;
	}
	return 0x820A9F5C;
} // Block from 820A9F50h-820A9F5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820A9F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9F5C);
		  /* 820A9F5Ch */ case    0:  		/* li R26, -1 */
		/* 820A9F5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R26,0xFFFFFFFF);
		/* 820A9F5Ch case    0:*/		return 0x820A9F60;
	}
	return 0x820A9F60;
} // Block from 820A9F5Ch-820A9F60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A9F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9F60);
		  /* 820A9F60h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820A9F60h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A9F60h case    0:*/		return 0x820A9F64;
		  /* 820A9F64h */ case    1:  		/* stw R26, <#[R1 + 96]> */
		/* 820A9F64h case    1:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000060) );
		/* 820A9F64h case    1:*/		return 0x820A9F68;
		  /* 820A9F68h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 820A9F68h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A9F68h case    2:*/		return 0x820A9F6C;
		  /* 820A9F6Ch */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820A9F6Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820A9F7C;  }
		/* 820A9F6Ch case    3:*/		return 0x820A9F70;
		  /* 820A9F70h */ case    4:  		/* li R11, 0 */
		/* 820A9F70h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820A9F70h case    4:*/		return 0x820A9F74;
		  /* 820A9F74h */ case    5:  		/* stb R11, <#[R31]> */
		/* 820A9F74h case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A9F74h case    5:*/		return 0x820A9F78;
		  /* 820A9F78h */ case    6:  		/* addi R31, R31, 1 */
		/* 820A9F78h case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820A9F78h case    6:*/		return 0x820A9F7C;
	}
	return 0x820A9F7C;
} // Block from 820A9F60h-820A9F7Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A9F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9F7C);
		  /* 820A9F7Ch */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820A9F7Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A9F7Ch case    0:*/		return 0x820A9F80;
		  /* 820A9F80h */ case    1:  		/* b 20 */
		/* 820A9F80h case    1:*/		return 0x820A9F94;
		/* 820A9F80h case    1:*/		return 0x820A9F84;
		  /* 820A9F84h */ case    2:  		/* bl -67700 */
		/* 820A9F84h case    2:*/		regs.LR = 0x820A9F88; return 0x82099710;
		/* 820A9F84h case    2:*/		return 0x820A9F88;
		  /* 820A9F88h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820A9F88h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820A9F88h case    3:*/		return 0x820A9F8C;
		  /* 820A9F8Ch */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820A9F8Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x820A9F9C;  }
		/* 820A9F8Ch case    4:*/		return 0x820A9F90;
		  /* 820A9F90h */ case    5:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820A9F90h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820A9F90h case    5:*/		return 0x820A9F94;
	}
	return 0x820A9F94;
} // Block from 820A9F7Ch-820A9F94h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820A9F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9F94);
		  /* 820A9F94h */ case    0:  		/* extsb. R3, R11 */
		/* 820A9F94h case    0:*/		cpu::op::extsb<1>(regs,&regs.R3,regs.R11);
		/* 820A9F94h case    0:*/		return 0x820A9F98;
		  /* 820A9F98h */ case    1:  		/* bc 4, CR0_EQ, -20 */
		/* 820A9F98h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820A9F84;  }
		/* 820A9F98h case    1:*/		return 0x820A9F9C;
	}
	return 0x820A9F9C;
} // Block from 820A9F94h-820A9F9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820A9F9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9F9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9F9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9F9C);
		  /* 820A9F9Ch */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820A9F9Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820A9F9Ch case    0:*/		return 0x820A9FA0;
	}
	return 0x820A9FA0;
} // Block from 820A9F9Ch-820A9FA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820A9FA0h
// Function '?AddElement@CFragmentRegisterAllocator@D3DXShader@@QAAJPBDII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9FA0);
		  /* 820A9FA0h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 820A9FA0h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820A9FA0h case    0:*/		return 0x820A9FA4;
		  /* 820A9FA4h */ case    1:  		/* bc 4, CR0_EQ, 1132 */
		/* 820A9FA4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AA410;  }
		/* 820A9FA4h case    1:*/		return 0x820A9FA8;
		  /* 820A9FA8h */ case    2:  		/* mr R9, R25 */
		/* 820A9FA8h case    2:*/		regs.R9 = regs.R25;
		/* 820A9FA8h case    2:*/		return 0x820A9FAC;
		  /* 820A9FACh */ case    3:  		/* li R6, 0 */
		/* 820A9FACh case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820A9FACh case    3:*/		return 0x820A9FB0;
		  /* 820A9FB0h */ case    4:  		/* li R7, 0 */
		/* 820A9FB0h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820A9FB0h case    4:*/		return 0x820A9FB4;
		  /* 820A9FB4h */ case    5:  		/* lwz R10, <#[R9]> */
		/* 820A9FB4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820A9FB4h case    5:*/		return 0x820A9FB8;
		  /* 820A9FB8h */ case    6:  		/* addi R11, R1, 128 */
		/* 820A9FB8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820A9FB8h case    6:*/		return 0x820A9FBC;
		  /* 820A9FBCh */ case    7:  		/* lbz R8, <#[R11]> */
		/* 820A9FBCh case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820A9FBCh case    7:*/		return 0x820A9FC0;
		  /* 820A9FC0h */ case    8:  		/* lbz R5, <#[R10]> */
		/* 820A9FC0h case    8:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 820A9FC0h case    8:*/		return 0x820A9FC4;
		  /* 820A9FC4h */ case    9:  		/* cmpwi CR0, R8, 0 */
		/* 820A9FC4h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A9FC4h case    9:*/		return 0x820A9FC8;
		  /* 820A9FC8h */ case   10:  		/* subf R8, R5, R8 */
		/* 820A9FC8h case   10:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 820A9FC8h case   10:*/		return 0x820A9FCC;
		  /* 820A9FCCh */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 820A9FCCh case   11:*/		if ( regs.CR[0].eq ) { return 0x820A9FE0;  }
		/* 820A9FCCh case   11:*/		return 0x820A9FD0;
		  /* 820A9FD0h */ case   12:  		/* addi R11, R11, 1 */
		/* 820A9FD0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820A9FD0h case   12:*/		return 0x820A9FD4;
		  /* 820A9FD4h */ case   13:  		/* addi R10, R10, 1 */
		/* 820A9FD4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820A9FD4h case   13:*/		return 0x820A9FD8;
		  /* 820A9FD8h */ case   14:  		/* cmpwi CR6, R8, 0 */
		/* 820A9FD8h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820A9FD8h case   14:*/		return 0x820A9FDC;
		  /* 820A9FDCh */ case   15:  		/* bc 12, CR6_EQ, -32 */
		/* 820A9FDCh case   15:*/		if ( regs.CR[6].eq ) { return 0x820A9FBC;  }
		/* 820A9FDCh case   15:*/		return 0x820A9FE0;
	}
	return 0x820A9FE0;
} // Block from 820A9FA0h-820A9FE0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820A9FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9FE0);
		  /* 820A9FE0h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820A9FE0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820A9FE0h case    0:*/		return 0x820A9FE4;
		  /* 820A9FE4h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820A9FE4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820A9FFC;  }
		/* 820A9FE4h case    1:*/		return 0x820A9FE8;
		  /* 820A9FE8h */ case    2:  		/* addi R7, R7, 76 */
		/* 820A9FE8h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4C);
		/* 820A9FE8h case    2:*/		return 0x820A9FEC;
		  /* 820A9FECh */ case    3:  		/* addi R6, R6, 1 */
		/* 820A9FECh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820A9FECh case    3:*/		return 0x820A9FF0;
		  /* 820A9FF0h */ case    4:  		/* addi R9, R9, 76 */
		/* 820A9FF0h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4C);
		/* 820A9FF0h case    4:*/		return 0x820A9FF4;
		  /* 820A9FF4h */ case    5:  		/* cmplwi CR6, R7, 1596 */
		/* 820A9FF4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x0000063C);
		/* 820A9FF4h case    5:*/		return 0x820A9FF8;
		  /* 820A9FF8h */ case    6:  		/* bc 12, CR6_LT, -68 */
		/* 820A9FF8h case    6:*/		if ( regs.CR[6].lt ) { return 0x820A9FB4;  }
		/* 820A9FF8h case    6:*/		return 0x820A9FFC;
	}
	return 0x820A9FFC;
} // Block from 820A9FE0h-820A9FFCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820A9FFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820A9FFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820A9FFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820A9FFC);
		  /* 820A9FFCh */ case    0:  		/* cmplwi CR6, R6, 21 */
		/* 820A9FFCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000015);
		/* 820A9FFCh case    0:*/		return 0x820AA000;
		  /* 820AA000h */ case    1:  		/* bc 12, CR6_EQ, 1040 */
		/* 820AA000h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AA410;  }
		/* 820AA000h case    1:*/		return 0x820AA004;
		  /* 820AA004h */ case    2:  		/* lwz R30, <#[R1 + 324]> */
		/* 820AA004h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000144) );
		/* 820AA004h case    2:*/		return 0x820AA008;
		  /* 820AA008h */ case    3:  		/* mulli R11, R6, 19 */
		/* 820AA008h case    3:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R6,0x13);
		/* 820AA008h case    3:*/		return 0x820AA00C;
		  /* 820AA00Ch */ case    4:  		/* lwz R9, <#[R30 + 64]> */
		/* 820AA00Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000040) );
		/* 820AA00Ch case    4:*/		return 0x820AA010;
		  /* 820AA010h */ case    5:  		/* add R11, R11, R9 */
		/* 820AA010h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820AA010h case    5:*/		return 0x820AA014;
		  /* 820AA014h */ case    6:  		/* addi R10, R25, 8 */
		/* 820AA014h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R25,0x8);
		/* 820AA014h case    6:*/		return 0x820AA018;
		  /* 820AA018h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AA018h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AA018h case    7:*/		return 0x820AA01C;
		  /* 820AA01Ch */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820AA01Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820AA01Ch case    8:*/		return 0x820AA020;
		  /* 820AA020h */ case    9:  		/* cmpwi CR6, R11, -1 */
		/* 820AA020h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820AA020h case    9:*/		return 0x820AA024;
		  /* 820AA024h */ case   10:  		/* bc 12, CR6_EQ, 1008 */
		/* 820AA024h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AA414;  }
		/* 820AA024h case   10:*/		return 0x820AA028;
		  /* 820AA028h */ case   11:  		/* lwz R31, <#[R1 + 340]> */
		/* 820AA028h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000154) );
		/* 820AA028h case   11:*/		return 0x820AA02C;
		  /* 820AA02Ch */ case   12:  		/* cmpwi CR6, R11, 0 */
		/* 820AA02Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AA02Ch case   12:*/		return 0x820AA030;
		  /* 820AA030h */ case   13:  		/* bc 4, CR6_LT, 56 */
		/* 820AA030h case   13:*/		if ( !regs.CR[6].lt ) { return 0x820AA068;  }
		/* 820AA030h case   13:*/		return 0x820AA034;
		  /* 820AA034h */ case   14:  		/* cmpwi CR6, R26, -1 */
		/* 820AA034h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R26,0xFFFFFFFF);
		/* 820AA034h case   14:*/		return 0x820AA038;
		  /* 820AA038h */ case   15:  		/* bc 4, CR6_EQ, 20 */
		/* 820AA038h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820AA04C;  }
		/* 820AA038h case   15:*/		return 0x820AA03C;
		  /* 820AA03Ch */ case   16:  		/* cmplwi CR6, R31, 0 */
		/* 820AA03Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820AA03Ch case   16:*/		return 0x820AA040;
		  /* 820AA040h */ case   17:  		/* bc 12, CR6_EQ, 984 */
		/* 820AA040h case   17:*/		if ( regs.CR[6].eq ) { return 0x820AA418;  }
		/* 820AA040h case   17:*/		return 0x820AA044;
		  /* 820AA044h */ case   18:  		/* lwz R26, <#[R31 + 24]> */
		/* 820AA044h case   18:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x00000018) );
		/* 820AA044h case   18:*/		return 0x820AA048;
		  /* 820AA048h */ case   19:  		/* b 20 */
		/* 820AA048h case   19:*/		return 0x820AA05C;
		/* 820AA048h case   19:*/		return 0x820AA04C;
	}
	return 0x820AA04C;
} // Block from 820A9FFCh-820AA04Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820AA04Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA04C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA04C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA04C);
		  /* 820AA04Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820AA04Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820AA04Ch case    0:*/		return 0x820AA050;
		  /* 820AA050h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820AA050h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AA060;  }
		/* 820AA050h case    1:*/		return 0x820AA054;
		  /* 820AA054h */ case    2:  		/* lwz R10, <#[R31 + 24]> */
		/* 820AA054h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820AA054h case    2:*/		return 0x820AA058;
		  /* 820AA058h */ case    3:  		/* add R26, R10, R26 */
		/* 820AA058h case    3:*/		cpu::op::add<0>(regs,&regs.R26,regs.R10,regs.R26);
		/* 820AA058h case    3:*/		return 0x820AA05C;
	}
	return 0x820AA05C;
} // Block from 820AA04Ch-820AA05Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA05Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA05C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA05C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA05C);
		  /* 820AA05Ch */ case    0:  		/* stw R26, <#[R1 + 96]> */
		/* 820AA05Ch case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000060) );
		/* 820AA05Ch case    0:*/		return 0x820AA060;
	}
	return 0x820AA060;
} // Block from 820AA05Ch-820AA060h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA060);
		  /* 820AA060h */ case    0:  		/* neg R11, R11 */
		/* 820AA060h case    0:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 820AA060h case    0:*/		return 0x820AA064;
		  /* 820AA064h */ case    1:  		/* b 12 */
		/* 820AA064h case    1:*/		return 0x820AA070;
		/* 820AA064h case    1:*/		return 0x820AA068;
	}
	return 0x820AA068;
} // Block from 820AA060h-820AA068h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA068);
		  /* 820AA068h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820AA068h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820AA068h case    0:*/		return 0x820AA06C;
		  /* 820AA06Ch */ case    1:  		/* bc 4, CR6_EQ, 940 */
		/* 820AA06Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AA418;  }
		/* 820AA06Ch case    1:*/		return 0x820AA070;
	}
	return 0x820AA070;
} // Block from 820AA068h-820AA070h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA070);
		  /* 820AA070h */ case    0:  		/* cmpwi CR6, R26, -1 */
		/* 820AA070h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0xFFFFFFFF);
		/* 820AA070h case    0:*/		return 0x820AA074;
		  /* 820AA074h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 820AA074h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AA08C;  }
		/* 820AA074h case    1:*/		return 0x820AA078;
	}
	return 0x820AA078;
} // Block from 820AA070h-820AA078h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA078h
// Function '??0CFragmentInfo@D3DXShader@@QAA@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA078);
		  /* 820AA078h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820AA078h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA078h case    0:*/		return 0x820AA07C;
		  /* 820AA07Ch */ case    1:  		/* bc 4, CR6_EQ, 924 */
		/* 820AA07Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AA418;  }
		/* 820AA07Ch case    1:*/		return 0x820AA080;
		  /* 820AA080h */ case    2:  		/* li R26, 0 */
		/* 820AA080h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820AA080h case    2:*/		return 0x820AA084;
		  /* 820AA084h */ case    3:  		/* stw R26, <#[R1 + 96]> */
		/* 820AA084h case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000060) );
		/* 820AA084h case    3:*/		return 0x820AA088;
		  /* 820AA088h */ case    4:  		/* b 32 */
		/* 820AA088h case    4:*/		return 0x820AA0A8;
		/* 820AA088h case    4:*/		return 0x820AA08C;
	}
	return 0x820AA08C;
} // Block from 820AA078h-820AA08Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AA08Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA08C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA08C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA08C);
		  /* 820AA08Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820AA08Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820AA08Ch case    0:*/		return 0x820AA090;
		  /* 820AA090h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820AA090h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AA0A0;  }
		/* 820AA090h case    1:*/		return 0x820AA094;
		  /* 820AA094h */ case    2:  		/* lwz R10, <#[R31 + 40]> */
		/* 820AA094h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 820AA094h case    2:*/		return 0x820AA098;
		  /* 820AA098h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 820AA098h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AA098h case    3:*/		return 0x820AA09C;
		  /* 820AA09Ch */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 820AA09Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820AA0A8;  }
		/* 820AA09Ch case    4:*/		return 0x820AA0A0;
	}
	return 0x820AA0A0;
} // Block from 820AA08Ch-820AA0A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AA0A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA0A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA0A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA0A0);
		  /* 820AA0A0h */ case    0:  		/* cmplw CR6, R26, R11 */
		/* 820AA0A0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 820AA0A0h case    0:*/		return 0x820AA0A4;
		  /* 820AA0A4h */ case    1:  		/* bc 4, CR6_LT, 884 */
		/* 820AA0A4h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820AA418;  }
		/* 820AA0A4h case    1:*/		return 0x820AA0A8;
	}
	return 0x820AA0A8;
} // Block from 820AA0A0h-820AA0A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA0A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA0A8);
		  /* 820AA0A8h */ case    0:  		/* mulli R11, R6, 76 */
		/* 820AA0A8h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R6,0x4C);
		/* 820AA0A8h case    0:*/		return 0x820AA0AC;
		  /* 820AA0ACh */ case    1:  		/* addi R10, R25, 4 */
		/* 820AA0ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R25,0x4);
		/* 820AA0ACh case    1:*/		return 0x820AA0B0;
		  /* 820AA0B0h */ case    2:  		/* addi R8, R25, 72 */
		/* 820AA0B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R25,0x48);
		/* 820AA0B0h case    2:*/		return 0x820AA0B4;
		  /* 820AA0B4h */ case    3:  		/* lwzx R29, <#[R11 + R10]> */
		/* 820AA0B4h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820AA0B4h case    3:*/		return 0x820AA0B8;
		  /* 820AA0B8h */ case    4:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820AA0B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820AA0B8h case    4:*/		return 0x820AA0BC;
		  /* 820AA0BCh */ case    5:  		/* cmplwi CR6, R29, 2 */
		/* 820AA0BCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000002);
		/* 820AA0BCh case    5:*/		return 0x820AA0C0;
		  /* 820AA0C0h */ case    6:  		/* stw R29, <#[R1 + 100]> */
		/* 820AA0C0h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000064) );
		/* 820AA0C0h case    6:*/		return 0x820AA0C4;
		  /* 820AA0C4h */ case    7:  		/* stw R11, <#[R1 + 116]> */
		/* 820AA0C4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820AA0C4h case    7:*/		return 0x820AA0C8;
		  /* 820AA0C8h */ case    8:  		/* bc 4, CR6_EQ, 80 */
		/* 820AA0C8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820AA118;  }
		/* 820AA0C8h case    8:*/		return 0x820AA0CC;
		  /* 820AA0CCh */ case    9:  		/* rlwinm R11, R26, 0, 19, 31 */
		/* 820AA0CCh case    9:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R26);
		/* 820AA0CCh case    9:*/		return 0x820AA0D0;
		  /* 820AA0D0h */ case   10:  		/* cmplwi CR6, R11, 2048 */
		/* 820AA0D0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000800);
		/* 820AA0D0h case   10:*/		return 0x820AA0D4;
		  /* 820AA0D4h */ case   11:  		/* bc 4, CR6_LT, 12 */
		/* 820AA0D4h case   11:*/		if ( !regs.CR[6].lt ) { return 0x820AA0E0;  }
		/* 820AA0D4h case   11:*/		return 0x820AA0D8;
		  /* 820AA0D8h */ case   12:  		/* li R29, 2 */
		/* 820AA0D8h case   12:*/		cpu::op::li<0>(regs,&regs.R29,0x2);
		/* 820AA0D8h case   12:*/		return 0x820AA0DC;
		  /* 820AA0DCh */ case   13:  		/* b 48 */
		/* 820AA0DCh case   13:*/		return 0x820AA10C;
		/* 820AA0DCh case   13:*/		return 0x820AA0E0;
	}
	return 0x820AA0E0;
} // Block from 820AA0A8h-820AA0E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820AA0E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA0E0);
		  /* 820AA0E0h */ case    0:  		/* cmplwi CR6, R11, 4096 */
		/* 820AA0E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001000);
		/* 820AA0E0h case    0:*/		return 0x820AA0E4;
		  /* 820AA0E4h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 820AA0E4h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820AA0F0;  }
		/* 820AA0E4h case    1:*/		return 0x820AA0E8;
		  /* 820AA0E8h */ case    2:  		/* li R29, 11 */
		/* 820AA0E8h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0xB);
		/* 820AA0E8h case    2:*/		return 0x820AA0EC;
		  /* 820AA0ECh */ case    3:  		/* b 32 */
		/* 820AA0ECh case    3:*/		return 0x820AA10C;
		/* 820AA0ECh case    3:*/		return 0x820AA0F0;
	}
	return 0x820AA0F0;
} // Block from 820AA0E0h-820AA0F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA0F0);
		  /* 820AA0F0h */ case    0:  		/* cmplwi CR6, R11, 6144 */
		/* 820AA0F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001800);
		/* 820AA0F0h case    0:*/		return 0x820AA0F4;
		  /* 820AA0F4h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 820AA0F4h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820AA100;  }
		/* 820AA0F4h case    1:*/		return 0x820AA0F8;
		  /* 820AA0F8h */ case    2:  		/* li R29, 12 */
		/* 820AA0F8h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0xC);
		/* 820AA0F8h case    2:*/		return 0x820AA0FC;
		  /* 820AA0FCh */ case    3:  		/* b 16 */
		/* 820AA0FCh case    3:*/		return 0x820AA10C;
		/* 820AA0FCh case    3:*/		return 0x820AA100;
	}
	return 0x820AA100;
} // Block from 820AA0F0h-820AA100h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA100);
		  /* 820AA100h */ case    0:  		/* cmplwi CR6, R11, 8192 */
		/* 820AA100h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002000);
		/* 820AA100h case    0:*/		return 0x820AA104;
		  /* 820AA104h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 820AA104h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820AA110;  }
		/* 820AA104h case    1:*/		return 0x820AA108;
		  /* 820AA108h */ case    2:  		/* li R29, 13 */
		/* 820AA108h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0xD);
		/* 820AA108h case    2:*/		return 0x820AA10C;
	}
	return 0x820AA10C;
} // Block from 820AA100h-820AA10Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AA10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA10C);
		  /* 820AA10Ch */ case    0:  		/* stw R29, <#[R1 + 100]> */
		/* 820AA10Ch case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000064) );
		/* 820AA10Ch case    0:*/		return 0x820AA110;
	}
	return 0x820AA110;
} // Block from 820AA10Ch-820AA110h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA110);
		  /* 820AA110h */ case    0:  		/* rlwinm R26, R11, 0, 21, 31 */
		/* 820AA110h case    0:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R26,regs.R11);
		/* 820AA110h case    0:*/		return 0x820AA114;
		  /* 820AA114h */ case    1:  		/* b 96 */
		/* 820AA114h case    1:*/		return 0x820AA174;
		/* 820AA114h case    1:*/		return 0x820AA118;
	}
	return 0x820AA118;
} // Block from 820AA110h-820AA118h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA118);
		  /* 820AA118h */ case    0:  		/* cmpwi CR6, R29, -3 */
		/* 820AA118h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFD);
		/* 820AA118h case    0:*/		return 0x820AA11C;
		  /* 820AA11Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820AA11Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AA12C;  }
		/* 820AA11Ch case    1:*/		return 0x820AA120;
		  /* 820AA120h */ case    2:  		/* li R29, 4 */
		/* 820AA120h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x4);
		/* 820AA120h case    2:*/		return 0x820AA124;
		  /* 820AA124h */ case    3:  		/* li R26, 0 */
		/* 820AA124h case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820AA124h case    3:*/		return 0x820AA128;
		  /* 820AA128h */ case    4:  		/* b 72 */
		/* 820AA128h case    4:*/		return 0x820AA170;
		/* 820AA128h case    4:*/		return 0x820AA12C;
	}
	return 0x820AA12C;
} // Block from 820AA118h-820AA12Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AA12Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA12C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA12C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA12C);
		  /* 820AA12Ch */ case    0:  		/* cmpwi CR6, R29, -4 */
		/* 820AA12Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFC);
		/* 820AA12Ch case    0:*/		return 0x820AA130;
		  /* 820AA130h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820AA130h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AA140;  }
		/* 820AA130h case    1:*/		return 0x820AA134;
		  /* 820AA134h */ case    2:  		/* li R29, 4 */
		/* 820AA134h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x4);
		/* 820AA134h case    2:*/		return 0x820AA138;
		  /* 820AA138h */ case    3:  		/* li R26, 2 */
		/* 820AA138h case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x2);
		/* 820AA138h case    3:*/		return 0x820AA13C;
		  /* 820AA13Ch */ case    4:  		/* b 52 */
		/* 820AA13Ch case    4:*/		return 0x820AA170;
		/* 820AA13Ch case    4:*/		return 0x820AA140;
	}
	return 0x820AA140;
} // Block from 820AA12Ch-820AA140h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AA140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA140);
		  /* 820AA140h */ case    0:  		/* cmpwi CR6, R29, -5 */
		/* 820AA140h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFB);
		/* 820AA140h case    0:*/		return 0x820AA144;
		  /* 820AA144h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820AA144h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AA150;  }
		/* 820AA144h case    1:*/		return 0x820AA148;
	}
	return 0x820AA148;
} // Block from 820AA140h-820AA148h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA148h
// Function '??1CFragmentInfo@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA148);
		  /* 820AA148h */ case    0:  		/* li R29, 4 */
		/* 820AA148h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x4);
		/* 820AA148h case    0:*/		return 0x820AA14C;
		  /* 820AA14Ch */ case    1:  		/* b 32 */
		/* 820AA14Ch case    1:*/		return 0x820AA16C;
		/* 820AA14Ch case    1:*/		return 0x820AA150;
	}
	return 0x820AA150;
} // Block from 820AA148h-820AA150h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA150);
		  /* 820AA150h */ case    0:  		/* cmpwi CR6, R29, -6 */
		/* 820AA150h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFA);
		/* 820AA150h case    0:*/		return 0x820AA154;
		  /* 820AA154h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820AA154h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AA160;  }
		/* 820AA154h case    1:*/		return 0x820AA158;
		  /* 820AA158h */ case    2:  		/* li R29, 17 */
		/* 820AA158h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x11);
		/* 820AA158h case    2:*/		return 0x820AA15C;
		  /* 820AA15Ch */ case    3:  		/* b -56 */
		/* 820AA15Ch case    3:*/		return 0x820AA124;
		/* 820AA15Ch case    3:*/		return 0x820AA160;
	}
	return 0x820AA160;
} // Block from 820AA150h-820AA160h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA160);
		  /* 820AA160h */ case    0:  		/* cmpwi CR6, R29, -7 */
		/* 820AA160h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFF9);
		/* 820AA160h case    0:*/		return 0x820AA164;
		  /* 820AA164h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 820AA164h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AA178;  }
		/* 820AA164h case    1:*/		return 0x820AA168;
		  /* 820AA168h */ case    2:  		/* li R29, 17 */
		/* 820AA168h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x11);
		/* 820AA168h case    2:*/		return 0x820AA16C;
	}
	return 0x820AA16C;
} // Block from 820AA160h-820AA16Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AA16Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA16C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA16C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA16C);
		  /* 820AA16Ch */ case    0:  		/* li R26, 1 */
		/* 820AA16Ch case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 820AA16Ch case    0:*/		return 0x820AA170;
	}
	return 0x820AA170;
} // Block from 820AA16Ch-820AA170h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA170);
		  /* 820AA170h */ case    0:  		/* stw R29, <#[R1 + 100]> */
		/* 820AA170h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000064) );
		/* 820AA170h case    0:*/		return 0x820AA174;
	}
	return 0x820AA174;
} // Block from 820AA170h-820AA174h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA174);
		  /* 820AA174h */ case    0:  		/* stw R26, <#[R1 + 96]> */
		/* 820AA174h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000060) );
		/* 820AA174h case    0:*/		return 0x820AA178;
	}
	return 0x820AA178;
} // Block from 820AA174h-820AA178h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA178);
		  /* 820AA178h */ case    0:  		/* li R28, 0 */
		/* 820AA178h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820AA178h case    0:*/		return 0x820AA17C;
		  /* 820AA17Ch */ case    1:  		/* cmpwi CR6, R9, 6 */
		/* 820AA17Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000006);
		/* 820AA17Ch case    1:*/		return 0x820AA180;
		  /* 820AA180h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 820AA180h case    2:*/		if ( regs.CR[6].lt ) { return 0x820AA190;  }
		/* 820AA180h case    2:*/		return 0x820AA184;
		  /* 820AA184h */ case    3:  		/* cmpwi CR6, R9, 9 */
		/* 820AA184h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000009);
		/* 820AA184h case    3:*/		return 0x820AA188;
		  /* 820AA188h */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 820AA188h case    4:*/		if ( regs.CR[6].gt ) { return 0x820AA190;  }
		/* 820AA188h case    4:*/		return 0x820AA18C;
		  /* 820AA18Ch */ case    5:  		/* li R14, 1 */
		/* 820AA18Ch case    5:*/		cpu::op::li<0>(regs,&regs.R14,0x1);
		/* 820AA18Ch case    5:*/		return 0x820AA190;
	}
	return 0x820AA190;
} // Block from 820AA178h-820AA190h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AA190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA190);
		  /* 820AA190h */ case    0:  		/* cmpwi CR6, R9, 4 */
		/* 820AA190h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000004);
		/* 820AA190h case    0:*/		return 0x820AA194;
		  /* 820AA194h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 820AA194h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AA1A0;  }
		/* 820AA194h case    1:*/		return 0x820AA198;
		  /* 820AA198h */ case    2:  		/* cmpwi CR6, R9, 5 */
		/* 820AA198h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000005);
		/* 820AA198h case    2:*/		return 0x820AA19C;
		  /* 820AA19Ch */ case    3:  		/* bc 4, CR6_GT, 20 */
		/* 820AA19Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x820AA1B0;  }
		/* 820AA19Ch case    3:*/		return 0x820AA1A0;
	}
	return 0x820AA1A0;
} // Block from 820AA190h-820AA1A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA1A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA1A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA1A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA1A0);
		  /* 820AA1A0h */ case    0:  		/* cmpwi CR6, R9, 14 */
		/* 820AA1A0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000E);
		/* 820AA1A0h case    0:*/		return 0x820AA1A4;
		  /* 820AA1A4h */ case    1:  		/* bc 12, CR6_LT, 524 */
		/* 820AA1A4h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AA3B0;  }
		/* 820AA1A4h case    1:*/		return 0x820AA1A8;
		  /* 820AA1A8h */ case    2:  		/* cmpwi CR6, R9, 15 */
		/* 820AA1A8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000F);
		/* 820AA1A8h case    2:*/		return 0x820AA1AC;
		  /* 820AA1ACh */ case    3:  		/* bc 12, CR6_GT, 516 */
		/* 820AA1ACh case    3:*/		if ( regs.CR[6].gt ) { return 0x820AA3B0;  }
		/* 820AA1ACh case    3:*/		return 0x820AA1B0;
	}
	return 0x820AA1B0;
} // Block from 820AA1A0h-820AA1B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA1B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA1B0);
		  /* 820AA1B0h */ case    0:  		/* li R11, 1 */
		/* 820AA1B0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820AA1B0h case    0:*/		return 0x820AA1B4;
		  /* 820AA1B4h */ case    1:  		/* b 504 */
		/* 820AA1B4h case    1:*/		return 0x820AA3AC;
		/* 820AA1B4h case    1:*/		return 0x820AA1B8;
	}
	return 0x820AA1B8;
} // Block from 820AA1B0h-820AA1B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA1B8);
		  /* 820AA1B8h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 820AA1B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 820AA1B8h case    0:*/		return 0x820AA1BC;
		  /* 820AA1BCh */ case    1:  		/* bc 12, CR6_EQ, 420 */
		/* 820AA1BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820AA360;  }
		/* 820AA1BCh case    1:*/		return 0x820AA1C0;
		  /* 820AA1C0h */ case    2:  		/* mr R10, R16 */
		/* 820AA1C0h case    2:*/		regs.R10 = regs.R16;
		/* 820AA1C0h case    2:*/		return 0x820AA1C4;
		  /* 820AA1C4h */ case    3:  		/* addi R11, R1, 128 */
		/* 820AA1C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820AA1C4h case    3:*/		return 0x820AA1C8;
		  /* 820AA1C8h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820AA1C8h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AA1C8h case    4:*/		return 0x820AA1CC;
		  /* 820AA1CCh */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820AA1CCh case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AA1CCh case    5:*/		return 0x820AA1D0;
		  /* 820AA1D0h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820AA1D0h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA1D0h case    6:*/		return 0x820AA1D4;
		  /* 820AA1D4h */ case    7:  		/* subf R9, R8, R9 */
		/* 820AA1D4h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AA1D4h case    7:*/		return 0x820AA1D8;
		  /* 820AA1D8h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820AA1D8h case    8:*/		if ( regs.CR[0].eq ) { return 0x820AA1EC;  }
		/* 820AA1D8h case    8:*/		return 0x820AA1DC;
		  /* 820AA1DCh */ case    9:  		/* addi R11, R11, 1 */
		/* 820AA1DCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AA1DCh case    9:*/		return 0x820AA1E0;
		  /* 820AA1E0h */ case   10:  		/* addi R10, R10, 1 */
		/* 820AA1E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AA1E0h case   10:*/		return 0x820AA1E4;
		  /* 820AA1E4h */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820AA1E4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AA1E4h case   11:*/		return 0x820AA1E8;
		  /* 820AA1E8h */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820AA1E8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820AA1C8;  }
		/* 820AA1E8h case   12:*/		return 0x820AA1EC;
	}
	return 0x820AA1EC;
} // Block from 820AA1B8h-820AA1ECh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AA1ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA1EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA1EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA1EC);
		  /* 820AA1ECh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AA1ECh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA1ECh case    0:*/		return 0x820AA1F0;
		  /* 820AA1F0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AA1F0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AA1FC;  }
		/* 820AA1F0h case    1:*/		return 0x820AA1F4;
		  /* 820AA1F4h */ case    2:  		/* lis R11, 512 */
		/* 820AA1F4h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x200);
		/* 820AA1F4h case    2:*/		return 0x820AA1F8;
		  /* 820AA1F8h */ case    3:  		/* b 344 */
		/* 820AA1F8h case    3:*/		return 0x820AA350;
		/* 820AA1F8h case    3:*/		return 0x820AA1FC;
	}
	return 0x820AA1FC;
} // Block from 820AA1ECh-820AA1FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA1FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA1FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA1FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA1FC);
		  /* 820AA1FCh */ case    0:  		/* mr R10, R17 */
		/* 820AA1FCh case    0:*/		regs.R10 = regs.R17;
		/* 820AA1FCh case    0:*/		return 0x820AA200;
		  /* 820AA200h */ case    1:  		/* addi R11, R1, 128 */
		/* 820AA200h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820AA200h case    1:*/		return 0x820AA204;
		  /* 820AA204h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AA204h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AA204h case    2:*/		return 0x820AA208;
		  /* 820AA208h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AA208h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AA208h case    3:*/		return 0x820AA20C;
		  /* 820AA20Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AA20Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA20Ch case    4:*/		return 0x820AA210;
		  /* 820AA210h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AA210h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AA210h case    5:*/		return 0x820AA214;
		  /* 820AA214h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AA214h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AA228;  }
		/* 820AA214h case    6:*/		return 0x820AA218;
		  /* 820AA218h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AA218h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AA218h case    7:*/		return 0x820AA21C;
		  /* 820AA21Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820AA21Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AA21Ch case    8:*/		return 0x820AA220;
		  /* 820AA220h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AA220h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AA220h case    9:*/		return 0x820AA224;
		  /* 820AA224h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AA224h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AA204;  }
		/* 820AA224h case   10:*/		return 0x820AA228;
	}
	return 0x820AA228;
} // Block from 820AA1FCh-820AA228h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AA228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA228);
		  /* 820AA228h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AA228h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA228h case    0:*/		return 0x820AA22C;
		  /* 820AA22Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AA22Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AA238;  }
		/* 820AA22Ch case    1:*/		return 0x820AA230;
		  /* 820AA230h */ case    2:  		/* lis R11, 1024 */
		/* 820AA230h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x400);
		/* 820AA230h case    2:*/		return 0x820AA234;
		  /* 820AA234h */ case    3:  		/* b 284 */
		/* 820AA234h case    3:*/		return 0x820AA350;
		/* 820AA234h case    3:*/		return 0x820AA238;
	}
	return 0x820AA238;
} // Block from 820AA228h-820AA238h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA238);
		  /* 820AA238h */ case    0:  		/* mr R10, R18 */
		/* 820AA238h case    0:*/		regs.R10 = regs.R18;
		/* 820AA238h case    0:*/		return 0x820AA23C;
		  /* 820AA23Ch */ case    1:  		/* addi R11, R1, 128 */
		/* 820AA23Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820AA23Ch case    1:*/		return 0x820AA240;
		  /* 820AA240h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AA240h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AA240h case    2:*/		return 0x820AA244;
		  /* 820AA244h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AA244h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AA244h case    3:*/		return 0x820AA248;
		  /* 820AA248h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AA248h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA248h case    4:*/		return 0x820AA24C;
		  /* 820AA24Ch */ case    5:  		/* subf R9, R8, R9 */
		/* 820AA24Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AA24Ch case    5:*/		return 0x820AA250;
		  /* 820AA250h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AA250h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AA264;  }
		/* 820AA250h case    6:*/		return 0x820AA254;
		  /* 820AA254h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AA254h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AA254h case    7:*/		return 0x820AA258;
		  /* 820AA258h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AA258h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AA258h case    8:*/		return 0x820AA25C;
		  /* 820AA25Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AA25Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AA25Ch case    9:*/		return 0x820AA260;
	}
	return 0x820AA260;
} // Block from 820AA238h-820AA260h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820AA260h
// Function '?GetRegisterInfo@CFragmentInfo@D3DXShader@@QAAJPAVCTErrors@2@PAVCFragmentConstants@2@PAUD3DXTOKEN@2@PBDPAVCNode@2@PAK55@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA260);
		  /* 820AA260h */ case    0:  		/* bc 12, CR6_EQ, -32 */
		/* 820AA260h case    0:*/		if ( regs.CR[6].eq ) { return 0x820AA240;  }
		/* 820AA260h case    0:*/		return 0x820AA264;
	}
	return 0x820AA264;
} // Block from 820AA260h-820AA264h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA264);
		  /* 820AA264h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AA264h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA264h case    0:*/		return 0x820AA268;
		  /* 820AA268h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AA268h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AA274;  }
		/* 820AA268h case    1:*/		return 0x820AA26C;
		  /* 820AA26Ch */ case    2:  		/* lis R11, 1792 */
		/* 820AA26Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x700);
		/* 820AA26Ch case    2:*/		return 0x820AA270;
		  /* 820AA270h */ case    3:  		/* b 224 */
		/* 820AA270h case    3:*/		return 0x820AA350;
		/* 820AA270h case    3:*/		return 0x820AA274;
	}
	return 0x820AA274;
} // Block from 820AA264h-820AA274h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA274);
		  /* 820AA274h */ case    0:  		/* mr R10, R19 */
		/* 820AA274h case    0:*/		regs.R10 = regs.R19;
		/* 820AA274h case    0:*/		return 0x820AA278;
		  /* 820AA278h */ case    1:  		/* addi R11, R1, 128 */
		/* 820AA278h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820AA278h case    1:*/		return 0x820AA27C;
		  /* 820AA27Ch */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AA27Ch case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AA27Ch case    2:*/		return 0x820AA280;
		  /* 820AA280h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AA280h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AA280h case    3:*/		return 0x820AA284;
		  /* 820AA284h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AA284h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA284h case    4:*/		return 0x820AA288;
		  /* 820AA288h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AA288h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AA288h case    5:*/		return 0x820AA28C;
		  /* 820AA28Ch */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AA28Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820AA2A0;  }
		/* 820AA28Ch case    6:*/		return 0x820AA290;
		  /* 820AA290h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AA290h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AA290h case    7:*/		return 0x820AA294;
		  /* 820AA294h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AA294h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AA294h case    8:*/		return 0x820AA298;
		  /* 820AA298h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AA298h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AA298h case    9:*/		return 0x820AA29C;
		  /* 820AA29Ch */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AA29Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820AA27C;  }
		/* 820AA29Ch case   10:*/		return 0x820AA2A0;
	}
	return 0x820AA2A0;
} // Block from 820AA274h-820AA2A0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AA2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA2A0);
		  /* 820AA2A0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AA2A0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA2A0h case    0:*/		return 0x820AA2A4;
		  /* 820AA2A4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AA2A4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AA2B0;  }
		/* 820AA2A4h case    1:*/		return 0x820AA2A8;
		  /* 820AA2A8h */ case    2:  		/* lis R11, 2304 */
		/* 820AA2A8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x900);
		/* 820AA2A8h case    2:*/		return 0x820AA2AC;
		  /* 820AA2ACh */ case    3:  		/* b 164 */
		/* 820AA2ACh case    3:*/		return 0x820AA350;
		/* 820AA2ACh case    3:*/		return 0x820AA2B0;
	}
	return 0x820AA2B0;
} // Block from 820AA2A0h-820AA2B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA2B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA2B0);
		  /* 820AA2B0h */ case    0:  		/* mr R10, R20 */
		/* 820AA2B0h case    0:*/		regs.R10 = regs.R20;
		/* 820AA2B0h case    0:*/		return 0x820AA2B4;
		  /* 820AA2B4h */ case    1:  		/* addi R11, R1, 128 */
		/* 820AA2B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820AA2B4h case    1:*/		return 0x820AA2B8;
		  /* 820AA2B8h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AA2B8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AA2B8h case    2:*/		return 0x820AA2BC;
		  /* 820AA2BCh */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AA2BCh case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AA2BCh case    3:*/		return 0x820AA2C0;
		  /* 820AA2C0h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AA2C0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA2C0h case    4:*/		return 0x820AA2C4;
		  /* 820AA2C4h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AA2C4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AA2C4h case    5:*/		return 0x820AA2C8;
		  /* 820AA2C8h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AA2C8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AA2DC;  }
		/* 820AA2C8h case    6:*/		return 0x820AA2CC;
		  /* 820AA2CCh */ case    7:  		/* addi R11, R11, 1 */
		/* 820AA2CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AA2CCh case    7:*/		return 0x820AA2D0;
		  /* 820AA2D0h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AA2D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AA2D0h case    8:*/		return 0x820AA2D4;
		  /* 820AA2D4h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AA2D4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AA2D4h case    9:*/		return 0x820AA2D8;
		  /* 820AA2D8h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AA2D8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AA2B8;  }
		/* 820AA2D8h case   10:*/		return 0x820AA2DC;
	}
	return 0x820AA2DC;
} // Block from 820AA2B0h-820AA2DCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AA2DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA2DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA2DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA2DC);
		  /* 820AA2DCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AA2DCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA2DCh case    0:*/		return 0x820AA2E0;
		  /* 820AA2E0h */ case    1:  		/* bc 12, CR0_EQ, -56 */
		/* 820AA2E0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820AA2A8;  }
		/* 820AA2E0h case    1:*/		return 0x820AA2E4;
		  /* 820AA2E4h */ case    2:  		/* mr R10, R21 */
		/* 820AA2E4h case    2:*/		regs.R10 = regs.R21;
		/* 820AA2E4h case    2:*/		return 0x820AA2E8;
		  /* 820AA2E8h */ case    3:  		/* addi R11, R1, 128 */
		/* 820AA2E8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820AA2E8h case    3:*/		return 0x820AA2EC;
		  /* 820AA2ECh */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820AA2ECh case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AA2ECh case    4:*/		return 0x820AA2F0;
		  /* 820AA2F0h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820AA2F0h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AA2F0h case    5:*/		return 0x820AA2F4;
		  /* 820AA2F4h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820AA2F4h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA2F4h case    6:*/		return 0x820AA2F8;
		  /* 820AA2F8h */ case    7:  		/* subf R9, R8, R9 */
		/* 820AA2F8h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AA2F8h case    7:*/		return 0x820AA2FC;
		  /* 820AA2FCh */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820AA2FCh case    8:*/		if ( regs.CR[0].eq ) { return 0x820AA310;  }
		/* 820AA2FCh case    8:*/		return 0x820AA300;
		  /* 820AA300h */ case    9:  		/* addi R11, R11, 1 */
		/* 820AA300h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AA300h case    9:*/		return 0x820AA304;
		  /* 820AA304h */ case   10:  		/* addi R10, R10, 1 */
		/* 820AA304h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AA304h case   10:*/		return 0x820AA308;
		  /* 820AA308h */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820AA308h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AA308h case   11:*/		return 0x820AA30C;
		  /* 820AA30Ch */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820AA30Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820AA2EC;  }
		/* 820AA30Ch case   12:*/		return 0x820AA310;
	}
	return 0x820AA310;
} // Block from 820AA2DCh-820AA310h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AA310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA310);
		  /* 820AA310h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AA310h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA310h case    0:*/		return 0x820AA314;
		  /* 820AA314h */ case    1:  		/* bc 12, CR0_EQ, 56 */
		/* 820AA314h case    1:*/		if ( regs.CR[0].eq ) { return 0x820AA34C;  }
		/* 820AA314h case    1:*/		return 0x820AA318;
		  /* 820AA318h */ case    2:  		/* mr R10, R22 */
		/* 820AA318h case    2:*/		regs.R10 = regs.R22;
		/* 820AA318h case    2:*/		return 0x820AA31C;
		  /* 820AA31Ch */ case    3:  		/* addi R11, R1, 128 */
		/* 820AA31Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820AA31Ch case    3:*/		return 0x820AA320;
		  /* 820AA320h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820AA320h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AA320h case    4:*/		return 0x820AA324;
		  /* 820AA324h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820AA324h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AA324h case    5:*/		return 0x820AA328;
		  /* 820AA328h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820AA328h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA328h case    6:*/		return 0x820AA32C;
		  /* 820AA32Ch */ case    7:  		/* subf R9, R8, R9 */
		/* 820AA32Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AA32Ch case    7:*/		return 0x820AA330;
		  /* 820AA330h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820AA330h case    8:*/		if ( regs.CR[0].eq ) { return 0x820AA344;  }
		/* 820AA330h case    8:*/		return 0x820AA334;
		  /* 820AA334h */ case    9:  		/* addi R11, R11, 1 */
		/* 820AA334h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AA334h case    9:*/		return 0x820AA338;
		  /* 820AA338h */ case   10:  		/* addi R10, R10, 1 */
		/* 820AA338h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AA338h case   10:*/		return 0x820AA33C;
		  /* 820AA33Ch */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820AA33Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AA33Ch case   11:*/		return 0x820AA340;
		  /* 820AA340h */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820AA340h case   12:*/		if ( regs.CR[6].eq ) { return 0x820AA320;  }
		/* 820AA340h case   12:*/		return 0x820AA344;
	}
	return 0x820AA344;
} // Block from 820AA310h-820AA344h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AA344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA344);
		  /* 820AA344h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AA344h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA344h case    0:*/		return 0x820AA348;
		  /* 820AA348h */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 820AA348h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AA360;  }
		/* 820AA348h case    1:*/		return 0x820AA34C;
	}
	return 0x820AA34C;
} // Block from 820AA344h-820AA34Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA34Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA34C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA34C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA34C);
		  /* 820AA34Ch */ case    0:  		/* lis R11, 2560 */
		/* 820AA34Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xA00);
		/* 820AA34Ch case    0:*/		return 0x820AA350;
	}
	return 0x820AA350;
} // Block from 820AA34Ch-820AA350h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA350);
		  /* 820AA350h */ case    0:  		/* mr R27, R11 */
		/* 820AA350h case    0:*/		regs.R27 = regs.R11;
		/* 820AA350h case    0:*/		return 0x820AA354;
		  /* 820AA354h */ case    1:  		/* stw R11, <#[R1 + 104]> */
		/* 820AA354h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820AA354h case    1:*/		return 0x820AA358;
		  /* 820AA358h */ case    2:  		/* li R14, 0 */
		/* 820AA358h case    2:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 820AA358h case    2:*/		return 0x820AA35C;
		  /* 820AA35Ch */ case    3:  		/* b 84 */
		/* 820AA35Ch case    3:*/		return 0x820AA3B0;
		/* 820AA35Ch case    3:*/		return 0x820AA360;
	}
	return 0x820AA360;
} // Block from 820AA350h-820AA360h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA360);
		  /* 820AA360h */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 820AA360h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820AA360h case    0:*/		return 0x820AA364;
		  /* 820AA364h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820AA364h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AA364h case    1:*/		return 0x820AA368;
		  /* 820AA368h */ case    2:  		/* bc 12, CR6_EQ, 168 */
		/* 820AA368h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA410;  }
		/* 820AA368h case    2:*/		return 0x820AA36C;
		  /* 820AA36Ch */ case    3:  		/* mr R10, R23 */
		/* 820AA36Ch case    3:*/		regs.R10 = regs.R23;
		/* 820AA36Ch case    3:*/		return 0x820AA370;
		  /* 820AA370h */ case    4:  		/* addi R11, R1, 128 */
		/* 820AA370h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820AA370h case    4:*/		return 0x820AA374;
		  /* 820AA374h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820AA374h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AA374h case    5:*/		return 0x820AA378;
		  /* 820AA378h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820AA378h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AA378h case    6:*/		return 0x820AA37C;
		  /* 820AA37Ch */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820AA37Ch case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA37Ch case    7:*/		return 0x820AA380;
		  /* 820AA380h */ case    8:  		/* subf R9, R8, R9 */
		/* 820AA380h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AA380h case    8:*/		return 0x820AA384;
		  /* 820AA384h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820AA384h case    9:*/		if ( regs.CR[0].eq ) { return 0x820AA398;  }
		/* 820AA384h case    9:*/		return 0x820AA388;
		  /* 820AA388h */ case   10:  		/* addi R11, R11, 1 */
		/* 820AA388h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AA388h case   10:*/		return 0x820AA38C;
		  /* 820AA38Ch */ case   11:  		/* addi R10, R10, 1 */
		/* 820AA38Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AA38Ch case   11:*/		return 0x820AA390;
		  /* 820AA390h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820AA390h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AA390h case   12:*/		return 0x820AA394;
		  /* 820AA394h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820AA394h case   13:*/		if ( regs.CR[6].eq ) { return 0x820AA374;  }
		/* 820AA394h case   13:*/		return 0x820AA398;
	}
	return 0x820AA398;
} // Block from 820AA360h-820AA398h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820AA398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA398);
		  /* 820AA398h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AA398h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AA398h case    0:*/		return 0x820AA39C;
		  /* 820AA39Ch */ case    1:  		/* bc 4, CR0_EQ, 116 */
		/* 820AA39Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AA410;  }
		/* 820AA39Ch case    1:*/		return 0x820AA3A0;
		  /* 820AA3A0h */ case    2:  		/* lis R27, 2816 */
		/* 820AA3A0h case    2:*/		cpu::op::lis<0>(regs,&regs.R27,0xB00);
		/* 820AA3A0h case    2:*/		return 0x820AA3A4;
		  /* 820AA3A4h */ case    3:  		/* li R11, 0 */
		/* 820AA3A4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820AA3A4h case    3:*/		return 0x820AA3A8;
		  /* 820AA3A8h */ case    4:  		/* stw R27, <#[R1 + 104]> */
		/* 820AA3A8h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000068) );
		/* 820AA3A8h case    4:*/		return 0x820AA3AC;
	}
	return 0x820AA3AC;
} // Block from 820AA398h-820AA3ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AA3ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA3AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA3AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA3AC);
		  /* 820AA3ACh */ case    0:  		/* stw R11, <#[R1 + 112]> */
		/* 820AA3ACh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820AA3ACh case    0:*/		return 0x820AA3B0;
	}
	return 0x820AA3B0;
} // Block from 820AA3ACh-820AA3B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA3B0);
		  /* 820AA3B0h */ case    0:  		/* lbz R11, <#[R15]> */
		/* 820AA3B0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 820AA3B0h case    0:*/		return 0x820AA3B4;
		  /* 820AA3B4h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820AA3B4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820AA3B4h case    1:*/		return 0x820AA3B8;
		  /* 820AA3B8h */ case    2:  		/* bc 4, CR0_EQ, -1284 */
		/* 820AA3B8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820A9EB4;  }
		/* 820AA3B8h case    2:*/		return 0x820AA3BC;
		  /* 820AA3BCh */ case    3:  		/* lwz R4, <#[R1 + 332]> */
		/* 820AA3BCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000014C) );
		/* 820AA3BCh case    3:*/		return 0x820AA3C0;
		  /* 820AA3C0h */ case    4:  		/* li R14, 0 */
		/* 820AA3C0h case    4:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 820AA3C0h case    4:*/		return 0x820AA3C4;
		  /* 820AA3C4h */ case    5:  		/* lwz R31, <#[R1 + 340]> */
		/* 820AA3C4h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000154) );
		/* 820AA3C4h case    5:*/		return 0x820AA3C8;
		  /* 820AA3C8h */ case    6:  		/* lwz R3, <#[R1 + 324]> */
		/* 820AA3C8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000144) );
		/* 820AA3C8h case    6:*/		return 0x820AA3CC;
	}
	return 0x820AA3CC;
} // Block from 820AA3B0h-820AA3CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AA3CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA3CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA3CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA3CC);
		  /* 820AA3CCh */ case    0:  		/* lwz R11, <#[R3 + 132]> */
		/* 820AA3CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000084) );
		/* 820AA3CCh case    0:*/		return 0x820AA3D0;
		  /* 820AA3D0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AA3D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA3D0h case    1:*/		return 0x820AA3D4;
		  /* 820AA3D4h */ case    2:  		/* bc 12, CR6_EQ, 472 */
		/* 820AA3D4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA3D4h case    2:*/		return 0x820AA3D8;
		  /* 820AA3D8h */ case    3:  		/* lwz R11, <#[R11 + 176]> */
		/* 820AA3D8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000B0) );
		/* 820AA3D8h case    3:*/		return 0x820AA3DC;
		  /* 820AA3DCh */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820AA3DCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AA3DCh case    4:*/		return 0x820AA3E0;
		  /* 820AA3E0h */ case    5:  		/* bc 12, CR6_EQ, 312 */
		/* 820AA3E0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820AA518;  }
		/* 820AA3E0h case    5:*/		return 0x820AA3E4;
		  /* 820AA3E4h */ case    6:  		/* cmplwi CR6, R29, 3 */
		/* 820AA3E4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000003);
		/* 820AA3E4h case    6:*/		return 0x820AA3E8;
		  /* 820AA3E8h */ case    7:  		/* bc 12, CR6_EQ, 452 */
		/* 820AA3E8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA3E8h case    7:*/		return 0x820AA3EC;
		  /* 820AA3ECh */ case    8:  		/* cmplwi CR6, R29, 15 */
		/* 820AA3ECh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000000F);
		/* 820AA3ECh case    8:*/		return 0x820AA3F0;
		  /* 820AA3F0h */ case    9:  		/* bc 12, CR6_EQ, 444 */
		/* 820AA3F0h case    9:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA3F0h case    9:*/		return 0x820AA3F4;
		  /* 820AA3F4h */ case   10:  		/* cmplwi CR6, R29, 18 */
		/* 820AA3F4h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000012);
		/* 820AA3F4h case   10:*/		return 0x820AA3F8;
		  /* 820AA3F8h */ case   11:  		/* bc 12, CR6_EQ, 436 */
		/* 820AA3F8h case   11:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA3F8h case   11:*/		return 0x820AA3FC;
		  /* 820AA3FCh */ case   12:  		/* cmplwi CR6, R29, 19 */
		/* 820AA3FCh case   12:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000013);
		/* 820AA3FCh case   12:*/		return 0x820AA400;
		  /* 820AA400h */ case   13:  		/* bc 12, CR6_EQ, 428 */
		/* 820AA400h case   13:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA400h case   13:*/		return 0x820AA404;
		  /* 820AA404h */ case   14:  		/* lis R11, -32255 */
		/* 820AA404h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA404h case   14:*/		return 0x820AA408;
		  /* 820AA408h */ case   15:  		/* addi R6, R11, 3344 */
		/* 820AA408h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xD10);
		/* 820AA408h case   15:*/		return 0x820AA40C;
		  /* 820AA40Ch */ case   16:  		/* b 348 */
		/* 820AA40Ch case   16:*/		return 0x820AA568;
		/* 820AA40Ch case   16:*/		return 0x820AA410;
	}
	return 0x820AA410;
} // Block from 820AA3CCh-820AA410h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820AA410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA410);
		  /* 820AA410h */ case    0:  		/* lwz R30, <#[R1 + 324]> */
		/* 820AA410h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000144) );
		/* 820AA410h case    0:*/		return 0x820AA414;
	}
	return 0x820AA414;
} // Block from 820AA410h-820AA414h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA414);
		  /* 820AA414h */ case    0:  		/* lwz R31, <#[R1 + 340]> */
		/* 820AA414h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000154) );
		/* 820AA414h case    0:*/		return 0x820AA418;
	}
	return 0x820AA418;
} // Block from 820AA414h-820AA418h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA418);
		  /* 820AA418h */ case    0:  		/* lwz R3, <#[R30 + 132]> */
		/* 820AA418h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000084) );
		/* 820AA418h case    0:*/		return 0x820AA41C;
		  /* 820AA41Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820AA41Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820AA41Ch case    1:*/		return 0x820AA420;
		  /* 820AA420h */ case    2:  		/* bc 12, CR6_EQ, 136 */
		/* 820AA420h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA4A8;  }
		/* 820AA420h case    2:*/		return 0x820AA424;
		  /* 820AA424h */ case    3:  		/* addi R11, R1, 96 */
		/* 820AA424h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820AA424h case    3:*/		return 0x820AA428;
		  /* 820AA428h */ case    4:  		/* lwz R5, <#[R30 + 136]> */
		/* 820AA428h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000088) );
		/* 820AA428h case    4:*/		return 0x820AA42C;
		  /* 820AA42Ch */ case    5:  		/* addi R10, R1, 104 */
		/* 820AA42Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x68);
		/* 820AA42Ch case    5:*/		return 0x820AA430;
		  /* 820AA430h */ case    6:  		/* lwz R4, <#[R30]> */
		/* 820AA430h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 820AA430h case    6:*/		return 0x820AA434;
		  /* 820AA434h */ case    7:  		/* addi R9, R1, 100 */
		/* 820AA434h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x64);
		/* 820AA434h case    7:*/		return 0x820AA438;
		  /* 820AA438h */ case    8:  		/* lwz R6, <#[R1 + 332]> */
		/* 820AA438h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000014C) );
		/* 820AA438h case    8:*/		return 0x820AA43C;
		  /* 820AA43Ch */ case    9:  		/* mr R8, R31 */
		/* 820AA43Ch case    9:*/		regs.R8 = regs.R31;
		/* 820AA43Ch case    9:*/		return 0x820AA440;
		  /* 820AA440h */ case   10:  		/* stw R11, <#[R1 + 84]> */
		/* 820AA440h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820AA440h case   10:*/		return 0x820AA444;
		  /* 820AA444h */ case   11:  		/* mr R7, R24 */
		/* 820AA444h case   11:*/		regs.R7 = regs.R24;
		/* 820AA444h case   11:*/		return 0x820AA448;
		  /* 820AA448h */ case   12:  		/* bl -3088 */
		/* 820AA448h case   12:*/		regs.LR = 0x820AA44C; return 0x820A9838;
		/* 820AA448h case   12:*/		return 0x820AA44C;
		  /* 820AA44Ch */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820AA44Ch case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AA44Ch case   13:*/		return 0x820AA450;
		  /* 820AA450h */ case   14:  		/* bc 12, CR0_LT, 296 */
		/* 820AA450h case   14:*/		if ( regs.CR[0].lt ) { return 0x820AA578;  }
		/* 820AA450h case   14:*/		return 0x820AA454;
		  /* 820AA454h */ case   15:  		/* li R3, 44 */
		/* 820AA454h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x2C);
		/* 820AA454h case   15:*/		return 0x820AA458;
		  /* 820AA458h */ case   16:  		/* bl 126416 */
		/* 820AA458h case   16:*/		regs.LR = 0x820AA45C; return 0x820C9228;
		/* 820AA458h case   16:*/		return 0x820AA45C;
		  /* 820AA45Ch */ case   17:  		/* cmplwi CR0, R3, 0 */
		/* 820AA45Ch case   17:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820AA45Ch case   17:*/		return 0x820AA460;
		  /* 820AA460h */ case   18:  		/* bc 12, CR0_EQ, 32 */
		/* 820AA460h case   18:*/		if ( regs.CR[0].eq ) { return 0x820AA480;  }
		/* 820AA460h case   18:*/		return 0x820AA464;
		  /* 820AA464h */ case   19:  		/* li R8, 0 */
		/* 820AA464h case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820AA464h case   19:*/		return 0x820AA468;
		  /* 820AA468h */ case   20:  		/* lwz R6, <#[R1 + 96]> */
		/* 820AA468h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 820AA468h case   20:*/		return 0x820AA46C;
		  /* 820AA46Ch */ case   21:  		/* lwz R7, <#[R1 + 116]> */
		/* 820AA46Ch case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000074) );
		/* 820AA46Ch case   21:*/		return 0x820AA470;
		  /* 820AA470h */ case   22:  		/* lwz R5, <#[R1 + 104]> */
		/* 820AA470h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 820AA470h case   22:*/		return 0x820AA474;
		  /* 820AA474h */ case   23:  		/* lwz R4, <#[R1 + 100]> */
		/* 820AA474h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 820AA474h case   23:*/		return 0x820AA478;
		  /* 820AA478h */ case   24:  		/* bl 146456 */
		/* 820AA478h case   24:*/		regs.LR = 0x820AA47C; return 0x820CE090;
		/* 820AA478h case   24:*/		return 0x820AA47C;
		  /* 820AA47Ch */ case   25:  		/* b 8 */
		/* 820AA47Ch case   25:*/		return 0x820AA484;
		/* 820AA47Ch case   25:*/		return 0x820AA480;
	}
	return 0x820AA480;
} // Block from 820AA418h-820AA480h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820AA480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA480);
		  /* 820AA480h */ case    0:  		/* li R3, 0 */
		/* 820AA480h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AA480h case    0:*/		return 0x820AA484;
	}
	return 0x820AA484;
} // Block from 820AA480h-820AA484h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA484);
		  /* 820AA484h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820AA484h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820AA484h case    0:*/		return 0x820AA488;
		  /* 820AA488h */ case    1:  		/* bc 12, CR6_EQ, 348 */
		/* 820AA488h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AA5E4;  }
		/* 820AA488h case    1:*/		return 0x820AA48C;
		  /* 820AA48Ch */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 820AA48Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820AA48Ch case    2:*/		return 0x820AA490;
		  /* 820AA490h */ case    3:  		/* bc 12, CR6_EQ, 368 */
		/* 820AA490h case    3:*/		if ( regs.CR[6].eq ) { return 0x820AA600;  }
		/* 820AA490h case    3:*/		return 0x820AA494;
		  /* 820AA494h */ case    4:  		/* lwz R11, <#[R31 + 40]> */
		/* 820AA494h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820AA494h case    4:*/		return 0x820AA498;
		  /* 820AA498h */ case    5:  		/* li R10, 0 */
		/* 820AA498h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820AA498h case    5:*/		return 0x820AA49C;
		  /* 820AA49Ch */ case    6:  		/* stw R11, <#[R3 + 40]> */
		/* 820AA49Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820AA49Ch case    6:*/		return 0x820AA4A0;
		  /* 820AA4A0h */ case    7:  		/* stw R10, <#[R31 + 40]> */
		/* 820AA4A0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 820AA4A0h case    7:*/		return 0x820AA4A4;
		  /* 820AA4A4h */ case    8:  		/* b 348 */
		/* 820AA4A4h case    8:*/		return 0x820AA600;
		/* 820AA4A4h case    8:*/		return 0x820AA4A8;
	}
	return 0x820AA4A8;
} // Block from 820AA484h-820AA4A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AA4A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA4A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA4A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA4A8);
		  /* 820AA4A8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820AA4A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820AA4A8h case    0:*/		return 0x820AA4AC;
		  /* 820AA4ACh */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 820AA4ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x820AA4F8;  }
		/* 820AA4ACh case    1:*/		return 0x820AA4B0;
		  /* 820AA4B0h */ case    2:  		/* lwz R11, <#[R31 + 40]> */
		/* 820AA4B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820AA4B0h case    2:*/		return 0x820AA4B4;
		  /* 820AA4B4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820AA4B4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA4B4h case    3:*/		return 0x820AA4B8;
		  /* 820AA4B8h */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 820AA4B8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820AA4E0;  }
		/* 820AA4B8h case    4:*/		return 0x820AA4BC;
		  /* 820AA4BCh */ case    5:  		/* lis R11, -32255 */
		/* 820AA4BCh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA4BCh case    5:*/		return 0x820AA4C0;
		  /* 820AA4C0h */ case    6:  		/* lwz R8, <#[R31 + 24]> */
		/* 820AA4C0h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 820AA4C0h case    6:*/		return 0x820AA4C4;
		  /* 820AA4C4h */ case    7:  		/* mr R7, R24 */
		/* 820AA4C4h case    7:*/		regs.R7 = regs.R24;
		/* 820AA4C4h case    7:*/		return 0x820AA4C8;
		  /* 820AA4C8h */ case    8:  		/* lwz R3, <#[R30]> */
		/* 820AA4C8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820AA4C8h case    8:*/		return 0x820AA4CC;
		  /* 820AA4CCh */ case    9:  		/* addi R6, R11, 3316 */
		/* 820AA4CCh case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xCF4);
		/* 820AA4CCh case    9:*/		return 0x820AA4D0;
		  /* 820AA4D0h */ case   10:  		/* lwz R4, <#[R1 + 332]> */
		/* 820AA4D0h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000014C) );
		/* 820AA4D0h case   10:*/		return 0x820AA4D4;
		  /* 820AA4D4h */ case   11:  		/* li R5, 2005 */
		/* 820AA4D4h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x7D5);
		/* 820AA4D4h case   11:*/		return 0x820AA4D8;
		  /* 820AA4D8h */ case   12:  		/* bl -13128 */
		/* 820AA4D8h case   12:*/		regs.LR = 0x820AA4DC; return 0x820A7190;
		/* 820AA4D8h case   12:*/		return 0x820AA4DC;
		  /* 820AA4DCh */ case   13:  		/* b 156 */
		/* 820AA4DCh case   13:*/		return 0x820AA578;
		/* 820AA4DCh case   13:*/		return 0x820AA4E0;
	}
	return 0x820AA4E0;
} // Block from 820AA4A8h-820AA4E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820AA4E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA4E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA4E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA4E0);
		  /* 820AA4E0h */ case    0:  		/* lwz R11, <#[R11 + 16]> */
		/* 820AA4E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820AA4E0h case    0:*/		return 0x820AA4E4;
		  /* 820AA4E4h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820AA4E4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820AA4E4h case    1:*/		return 0x820AA4E8;
		  /* 820AA4E8h */ case    2:  		/* bc 12, CR6_EQ, 144 */
		/* 820AA4E8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA578;  }
		/* 820AA4E8h case    2:*/		return 0x820AA4EC;
		  /* 820AA4ECh */ case    3:  		/* lis R11, -32255 */
		/* 820AA4ECh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA4ECh case    3:*/		return 0x820AA4F0;
		  /* 820AA4F0h */ case    4:  		/* addi R6, R11, 3288 */
		/* 820AA4F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xCD8);
		/* 820AA4F0h case    4:*/		return 0x820AA4F4;
		  /* 820AA4F4h */ case    5:  		/* b 12 */
		/* 820AA4F4h case    5:*/		return 0x820AA500;
		/* 820AA4F4h case    5:*/		return 0x820AA4F8;
	}
	return 0x820AA4F8;
} // Block from 820AA4E0h-820AA4F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AA4F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA4F8);
		  /* 820AA4F8h */ case    0:  		/* lis R11, -32255 */
		/* 820AA4F8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA4F8h case    0:*/		return 0x820AA4FC;
		  /* 820AA4FCh */ case    1:  		/* addi R6, R11, 3264 */
		/* 820AA4FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xCC0);
		/* 820AA4FCh case    1:*/		return 0x820AA500;
	}
	return 0x820AA500;
} // Block from 820AA4F8h-820AA500h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA500);
		  /* 820AA500h */ case    0:  		/* mr R7, R24 */
		/* 820AA500h case    0:*/		regs.R7 = regs.R24;
		/* 820AA500h case    0:*/		return 0x820AA504;
		  /* 820AA504h */ case    1:  		/* lwz R4, <#[R1 + 332]> */
		/* 820AA504h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000014C) );
		/* 820AA504h case    1:*/		return 0x820AA508;
		  /* 820AA508h */ case    2:  		/* li R5, 2005 */
		/* 820AA508h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7D5);
		/* 820AA508h case    2:*/		return 0x820AA50C;
		  /* 820AA50Ch */ case    3:  		/* lwz R3, <#[R30]> */
		/* 820AA50Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820AA50Ch case    3:*/		return 0x820AA510;
		  /* 820AA510h */ case    4:  		/* bl -13184 */
		/* 820AA510h case    4:*/		regs.LR = 0x820AA514; return 0x820A7190;
		/* 820AA510h case    4:*/		return 0x820AA514;
		  /* 820AA514h */ case    5:  		/* b 100 */
		/* 820AA514h case    5:*/		return 0x820AA578;
		/* 820AA514h case    5:*/		return 0x820AA518;
	}
	return 0x820AA518;
} // Block from 820AA500h-820AA518h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AA518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA518);
		  /* 820AA518h */ case    0:  		/* cmplwi CR6, R29, 3 */
		/* 820AA518h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000003);
		/* 820AA518h case    0:*/		return 0x820AA51C;
		  /* 820AA51Ch */ case    1:  		/* bc 12, CR6_EQ, 144 */
		/* 820AA51Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA51Ch case    1:*/		return 0x820AA520;
		  /* 820AA520h */ case    2:  		/* cmplwi CR6, R29, 5 */
		/* 820AA520h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000005);
		/* 820AA520h case    2:*/		return 0x820AA524;
		  /* 820AA524h */ case    3:  		/* bc 12, CR6_EQ, 136 */
		/* 820AA524h case    3:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA524h case    3:*/		return 0x820AA528;
		  /* 820AA528h */ case    4:  		/* cmplwi CR6, R29, 6 */
		/* 820AA528h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000006);
		/* 820AA528h case    4:*/		return 0x820AA52C;
		  /* 820AA52Ch */ case    5:  		/* bc 12, CR6_EQ, 128 */
		/* 820AA52Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA52Ch case    5:*/		return 0x820AA530;
		  /* 820AA530h */ case    6:  		/* cmplwi CR6, R29, 8 */
		/* 820AA530h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000008);
		/* 820AA530h case    6:*/		return 0x820AA534;
		  /* 820AA534h */ case    7:  		/* bc 12, CR6_EQ, 120 */
		/* 820AA534h case    7:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA534h case    7:*/		return 0x820AA538;
		  /* 820AA538h */ case    8:  		/* cmplwi CR6, R29, 9 */
		/* 820AA538h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000009);
		/* 820AA538h case    8:*/		return 0x820AA53C;
		  /* 820AA53Ch */ case    9:  		/* bc 12, CR6_EQ, 112 */
		/* 820AA53Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA53Ch case    9:*/		return 0x820AA540;
		  /* 820AA540h */ case   10:  		/* cmplwi CR6, R29, 4 */
		/* 820AA540h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000004);
		/* 820AA540h case   10:*/		return 0x820AA544;
		  /* 820AA544h */ case   11:  		/* bc 12, CR6_EQ, 104 */
		/* 820AA544h case   11:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA544h case   11:*/		return 0x820AA548;
		  /* 820AA548h */ case   12:  		/* cmplwi CR6, R29, 15 */
		/* 820AA548h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000000F);
		/* 820AA548h case   12:*/		return 0x820AA54C;
		  /* 820AA54Ch */ case   13:  		/* bc 12, CR6_EQ, 96 */
		/* 820AA54Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA54Ch case   13:*/		return 0x820AA550;
		  /* 820AA550h */ case   14:  		/* cmplwi CR6, R29, 18 */
		/* 820AA550h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000012);
		/* 820AA550h case   14:*/		return 0x820AA554;
		  /* 820AA554h */ case   15:  		/* bc 12, CR6_EQ, 88 */
		/* 820AA554h case   15:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA554h case   15:*/		return 0x820AA558;
		  /* 820AA558h */ case   16:  		/* cmplwi CR6, R29, 19 */
		/* 820AA558h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000013);
		/* 820AA558h case   16:*/		return 0x820AA55C;
		  /* 820AA55Ch */ case   17:  		/* bc 12, CR6_EQ, 80 */
		/* 820AA55Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x820AA5AC;  }
		/* 820AA55Ch case   17:*/		return 0x820AA560;
		  /* 820AA560h */ case   18:  		/* lis R11, -32255 */
		/* 820AA560h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA560h case   18:*/		return 0x820AA564;
		  /* 820AA564h */ case   19:  		/* addi R6, R11, 3192 */
		/* 820AA564h case   19:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xC78);
		/* 820AA564h case   19:*/		return 0x820AA568;
	}
	return 0x820AA568;
} // Block from 820AA518h-820AA568h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820AA568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA568);
		  /* 820AA568h */ case    0:  		/* li R5, 2005 */
		/* 820AA568h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x7D5);
		/* 820AA568h case    0:*/		return 0x820AA56C;
		  /* 820AA56Ch */ case    1:  		/* lwz R3, <#[R3]> */
		/* 820AA56Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820AA56Ch case    1:*/		return 0x820AA570;
		  /* 820AA570h */ case    2:  		/* bl -13280 */
		/* 820AA570h case    2:*/		regs.LR = 0x820AA574; return 0x820A7190;
		/* 820AA570h case    2:*/		return 0x820AA574;
		  /* 820AA574h */ case    3:  		/* lwz R30, <#[R1 + 324]> */
		/* 820AA574h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000144) );
		/* 820AA574h case    3:*/		return 0x820AA578;
	}
	return 0x820AA578;
} // Block from 820AA568h-820AA578h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA578);
		  /* 820AA578h */ case    0:  		/* li R11, 1 */
		/* 820AA578h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820AA578h case    0:*/		return 0x820AA57C;
		  /* 820AA57Ch */ case    1:  		/* li R3, 44 */
		/* 820AA57Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x2C);
		/* 820AA57Ch case    1:*/		return 0x820AA580;
		  /* 820AA580h */ case    2:  		/* stw R11, <#[R30 + 84]> */
		/* 820AA580h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000054) );
		/* 820AA580h case    2:*/		return 0x820AA584;
		  /* 820AA584h */ case    3:  		/* bl 126116 */
		/* 820AA584h case    3:*/		regs.LR = 0x820AA588; return 0x820C9228;
		/* 820AA584h case    3:*/		return 0x820AA588;
		  /* 820AA588h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820AA588h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820AA588h case    4:*/		return 0x820AA58C;
		  /* 820AA58Ch */ case    5:  		/* bc 12, CR0_EQ, 88 */
		/* 820AA58Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820AA5E4;  }
		/* 820AA58Ch case    5:*/		return 0x820AA590;
		  /* 820AA590h */ case    6:  		/* li R8, 0 */
		/* 820AA590h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820AA590h case    6:*/		return 0x820AA594;
		  /* 820AA594h */ case    7:  		/* li R7, 0 */
		/* 820AA594h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820AA594h case    7:*/		return 0x820AA598;
		  /* 820AA598h */ case    8:  		/* li R6, 0 */
		/* 820AA598h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820AA598h case    8:*/		return 0x820AA59C;
		  /* 820AA59Ch */ case    9:  		/* li R5, 0 */
		/* 820AA59Ch case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820AA59Ch case    9:*/		return 0x820AA5A0;
		  /* 820AA5A0h */ case   10:  		/* li R4, -1 */
		/* 820AA5A0h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 820AA5A0h case   10:*/		return 0x820AA5A4;
		  /* 820AA5A4h */ case   11:  		/* bl 146156 */
		/* 820AA5A4h case   11:*/		regs.LR = 0x820AA5A8; return 0x820CE090;
		/* 820AA5A4h case   11:*/		return 0x820AA5A8;
		  /* 820AA5A8h */ case   12:  		/* b 88 */
		/* 820AA5A8h case   12:*/		return 0x820AA600;
		/* 820AA5A8h case   12:*/		return 0x820AA5AC;
	}
	return 0x820AA5AC;
} // Block from 820AA578h-820AA5ACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AA5ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA5AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA5AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA5AC);
		  /* 820AA5ACh */ case    0:  		/* li R3, 44 */
		/* 820AA5ACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2C);
		/* 820AA5ACh case    0:*/		return 0x820AA5B0;
		  /* 820AA5B0h */ case    1:  		/* bl 126072 */
		/* 820AA5B0h case    1:*/		regs.LR = 0x820AA5B4; return 0x820C9228;
		/* 820AA5B0h case    1:*/		return 0x820AA5B4;
		  /* 820AA5B4h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820AA5B4h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820AA5B4h case    2:*/		return 0x820AA5B8;
		  /* 820AA5B8h */ case    3:  		/* bc 12, CR0_EQ, 32 */
		/* 820AA5B8h case    3:*/		if ( regs.CR[0].eq ) { return 0x820AA5D8;  }
		/* 820AA5B8h case    3:*/		return 0x820AA5BC;
		  /* 820AA5BCh */ case    4:  		/* li R8, 0 */
		/* 820AA5BCh case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820AA5BCh case    4:*/		return 0x820AA5C0;
		  /* 820AA5C0h */ case    5:  		/* lwz R7, <#[R1 + 116]> */
		/* 820AA5C0h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000074) );
		/* 820AA5C0h case    5:*/		return 0x820AA5C4;
		  /* 820AA5C4h */ case    6:  		/* mr R6, R26 */
		/* 820AA5C4h case    6:*/		regs.R6 = regs.R26;
		/* 820AA5C4h case    6:*/		return 0x820AA5C8;
		  /* 820AA5C8h */ case    7:  		/* mr R5, R27 */
		/* 820AA5C8h case    7:*/		regs.R5 = regs.R27;
		/* 820AA5C8h case    7:*/		return 0x820AA5CC;
		  /* 820AA5CCh */ case    8:  		/* mr R4, R29 */
		/* 820AA5CCh case    8:*/		regs.R4 = regs.R29;
		/* 820AA5CCh case    8:*/		return 0x820AA5D0;
		  /* 820AA5D0h */ case    9:  		/* bl 146112 */
		/* 820AA5D0h case    9:*/		regs.LR = 0x820AA5D4; return 0x820CE090;
		/* 820AA5D0h case    9:*/		return 0x820AA5D4;
		  /* 820AA5D4h */ case   10:  		/* b 8 */
		/* 820AA5D4h case   10:*/		return 0x820AA5DC;
		/* 820AA5D4h case   10:*/		return 0x820AA5D8;
	}
	return 0x820AA5D8;
} // Block from 820AA5ACh-820AA5D8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AA5D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA5D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA5D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA5D8);
		  /* 820AA5D8h */ case    0:  		/* mr R3, R14 */
		/* 820AA5D8h case    0:*/		regs.R3 = regs.R14;
		/* 820AA5D8h case    0:*/		return 0x820AA5DC;
	}
	return 0x820AA5DC;
} // Block from 820AA5D8h-820AA5DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA5DC);
		  /* 820AA5DCh */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820AA5DCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820AA5DCh case    0:*/		return 0x820AA5E0;
		  /* 820AA5E0h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820AA5E0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AA5EC;  }
		/* 820AA5E0h case    1:*/		return 0x820AA5E4;
	}
	return 0x820AA5E4;
} // Block from 820AA5DCh-820AA5E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA5E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA5E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA5E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA5E4);
		  /* 820AA5E4h */ case    0:  		/* li R3, 0 */
		/* 820AA5E4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AA5E4h case    0:*/		return 0x820AA5E8;
		  /* 820AA5E8h */ case    1:  		/* b 24 */
		/* 820AA5E8h case    1:*/		return 0x820AA600;
		/* 820AA5E8h case    1:*/		return 0x820AA5EC;
	}
	return 0x820AA5EC;
} // Block from 820AA5E4h-820AA5ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA5ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA5EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA5EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA5EC);
		  /* 820AA5ECh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820AA5ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820AA5ECh case    0:*/		return 0x820AA5F0;
		  /* 820AA5F0h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820AA5F0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AA600;  }
		/* 820AA5F0h case    1:*/		return 0x820AA5F4;
		  /* 820AA5F4h */ case    2:  		/* lwz R11, <#[R31 + 40]> */
		/* 820AA5F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820AA5F4h case    2:*/		return 0x820AA5F8;
		  /* 820AA5F8h */ case    3:  		/* stw R11, <#[R3 + 40]> */
		/* 820AA5F8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820AA5F8h case    3:*/		return 0x820AA5FC;
		  /* 820AA5FCh */ case    4:  		/* stw R14, <#[R31 + 40]> */
		/* 820AA5FCh case    4:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R31 + 0x00000028) );
		/* 820AA5FCh case    4:*/		return 0x820AA600;
	}
	return 0x820AA600;
} // Block from 820AA5ECh-820AA600h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AA600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA600);
		  /* 820AA600h */ case    0:  		/* addi R1, R1, 304 */
		/* 820AA600h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x130);
		/* 820AA600h case    0:*/		return 0x820AA604;
		  /* 820AA604h */ case    1:  		/* b -103316 */
		/* 820AA604h case    1:*/		return 0x82091270;
		/* 820AA604h case    1:*/		return 0x820AA608;
	}
	return 0x820AA608;
} // Block from 820AA600h-820AA608h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA608);
		  /* 820AA608h */ case    0:  		/* mfspr R12, LR */
		/* 820AA608h case    0:*/		regs.R12 = regs.LR;
		/* 820AA608h case    0:*/		return 0x820AA60C;
		  /* 820AA60Ch */ case    1:  		/* bl -103344 */
		/* 820AA60Ch case    1:*/		regs.LR = 0x820AA610; return 0x8209125C;
		/* 820AA60Ch case    1:*/		return 0x820AA610;
		  /* 820AA610h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820AA610h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820AA610h case    2:*/		return 0x820AA614;
		  /* 820AA614h */ case    3:  		/* lwz R10, <#[R3 + 104]> */
		/* 820AA614h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000068) );
		/* 820AA614h case    3:*/		return 0x820AA618;
		  /* 820AA618h */ case    4:  		/* mr R31, R3 */
		/* 820AA618h case    4:*/		regs.R31 = regs.R3;
		/* 820AA618h case    4:*/		return 0x820AA61C;
		  /* 820AA61Ch */ case    5:  		/* lwz R11, <#[R3 + 108]> */
		/* 820AA61Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 820AA61Ch case    5:*/		return 0x820AA620;
		  /* 820AA620h */ case    6:  		/* add R10, R4, R10 */
		/* 820AA620h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R4,regs.R10);
		/* 820AA620h case    6:*/		return 0x820AA624;
		  /* 820AA624h */ case    7:  		/* cmplw CR6, R10, R11 */
		/* 820AA624h case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820AA624h case    7:*/		return 0x820AA628;
		  /* 820AA628h */ case    8:  		/* bc 4, CR6_GT, 120 */
		/* 820AA628h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820AA6A0;  }
		/* 820AA628h case    8:*/		return 0x820AA62C;
		  /* 820AA62Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820AA62Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA62Ch case    9:*/		return 0x820AA630;
		  /* 820AA630h */ case   10:  		/* mr R30, R11 */
		/* 820AA630h case   10:*/		regs.R30 = regs.R11;
		/* 820AA630h case   10:*/		return 0x820AA634;
		  /* 820AA634h */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 820AA634h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820AA63C;  }
		/* 820AA634h case   11:*/		return 0x820AA638;
		  /* 820AA638h */ case   12:  		/* li R30, 256 */
		/* 820AA638h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x100);
		/* 820AA638h case   12:*/		return 0x820AA63C;
	}
	return 0x820AA63C;
} // Block from 820AA608h-820AA63Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AA63Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA63C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA63C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA63C);
		  /* 820AA63Ch */ case    0:  		/* cmplw CR6, R10, R30 */
		/* 820AA63Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 820AA63Ch case    0:*/		return 0x820AA640;
		  /* 820AA640h */ case    1:  		/* bc 4, CR6_GT, 24 */
		/* 820AA640h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820AA658;  }
		/* 820AA640h case    1:*/		return 0x820AA644;
		  /* 820AA644h */ case    2:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AA644h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AA644h case    2:*/		return 0x820AA648;
		  /* 820AA648h */ case    3:  		/* add R11, R4, R11 */
		/* 820AA648h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 820AA648h case    3:*/		return 0x820AA64C;
		  /* 820AA64Ch */ case    4:  		/* rlwinm R30, R30, 1, 0, 30 */
		/* 820AA64Ch case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R30,regs.R30);
		/* 820AA64Ch case    4:*/		return 0x820AA650;
		  /* 820AA650h */ case    5:  		/* cmplw CR6, R11, R30 */
		/* 820AA650h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820AA650h case    5:*/		return 0x820AA654;
		  /* 820AA654h */ case    6:  		/* bc 12, CR6_GT, -8 */
		/* 820AA654h case    6:*/		if ( regs.CR[6].gt ) { return 0x820AA64C;  }
		/* 820AA654h case    6:*/		return 0x820AA658;
	}
	return 0x820AA658;
} // Block from 820AA63Ch-820AA658h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AA658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA658);
		  /* 820AA658h */ case    0:  		/* lis R4, 9345 */
		/* 820AA658h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820AA658h case    0:*/		return 0x820AA65C;
		  /* 820AA65Ch */ case    1:  		/* rlwinm R3, R30, 2, 0, 29 */
		/* 820AA65Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R30);
		/* 820AA65Ch case    1:*/		return 0x820AA660;
		  /* 820AA660h */ case    2:  		/* bl -140384 */
		/* 820AA660h case    2:*/		regs.LR = 0x820AA664; return 0x82088200;
		/* 820AA660h case    2:*/		return 0x820AA664;
		  /* 820AA664h */ case    3:  		/* or. R29, R3, R3 */
		/* 820AA664h case    3:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820AA664h case    3:*/		return 0x820AA668;
		  /* 820AA668h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 820AA668h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820AA678;  }
		/* 820AA668h case    4:*/		return 0x820AA66C;
		  /* 820AA66Ch */ case    5:  		/* lis R3, -32761 */
		/* 820AA66Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820AA66Ch case    5:*/		return 0x820AA670;
		  /* 820AA670h */ case    6:  		/* ori R3, R3, 14 */
		/* 820AA670h case    6:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820AA670h case    6:*/		return 0x820AA674;
		  /* 820AA674h */ case    7:  		/* b 48 */
		/* 820AA674h case    7:*/		return 0x820AA6A4;
		/* 820AA674h case    7:*/		return 0x820AA678;
	}
	return 0x820AA678;
} // Block from 820AA658h-820AA678h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AA678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA678);
		  /* 820AA678h */ case    0:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AA678h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AA678h case    0:*/		return 0x820AA67C;
		  /* 820AA67Ch */ case    1:  		/* mr R3, R29 */
		/* 820AA67Ch case    1:*/		regs.R3 = regs.R29;
		/* 820AA67Ch case    1:*/		return 0x820AA680;
		  /* 820AA680h */ case    2:  		/* lwz R4, <#[R31 + 100]> */
		/* 820AA680h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000064) );
		/* 820AA680h case    2:*/		return 0x820AA684;
		  /* 820AA684h */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820AA684h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820AA684h case    3:*/		return 0x820AA688;
		  /* 820AA688h */ case    4:  		/* bl -101592 */
		/* 820AA688h case    4:*/		regs.LR = 0x820AA68C; return 0x820919B0;
		/* 820AA688h case    4:*/		return 0x820AA68C;
		  /* 820AA68Ch */ case    5:  		/* lis R4, 9345 */
		/* 820AA68Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820AA68Ch case    5:*/		return 0x820AA690;
		  /* 820AA690h */ case    6:  		/* lwz R3, <#[R31 + 100]> */
		/* 820AA690h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000064) );
		/* 820AA690h case    6:*/		return 0x820AA694;
		  /* 820AA694h */ case    7:  		/* bl -140124 */
		/* 820AA694h case    7:*/		regs.LR = 0x820AA698; return 0x82088338;
		/* 820AA694h case    7:*/		return 0x820AA698;
		  /* 820AA698h */ case    8:  		/* stw R29, <#[R31 + 100]> */
		/* 820AA698h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000064) );
		/* 820AA698h case    8:*/		return 0x820AA69C;
		  /* 820AA69Ch */ case    9:  		/* stw R30, <#[R31 + 108]> */
		/* 820AA69Ch case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000006C) );
		/* 820AA69Ch case    9:*/		return 0x820AA6A0;
	}
	return 0x820AA6A0;
} // Block from 820AA678h-820AA6A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820AA6A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA6A0);
		  /* 820AA6A0h */ case    0:  		/* li R3, 0 */
		/* 820AA6A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AA6A0h case    0:*/		return 0x820AA6A4;
	}
	return 0x820AA6A4;
} // Block from 820AA6A0h-820AA6A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA6A4);
		  /* 820AA6A4h */ case    0:  		/* addi R1, R1, 112 */
		/* 820AA6A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820AA6A4h case    0:*/		return 0x820AA6A8;
		  /* 820AA6A8h */ case    1:  		/* b -103420 */
		/* 820AA6A8h case    1:*/		return 0x820912AC;
		/* 820AA6A8h case    1:*/		return 0x820AA6AC;
		  /* 820AA6ACh */ case    2:  		/* nop */
		/* 820AA6ACh case    2:*/		cpu::op::nop();
		/* 820AA6ACh case    2:*/		return 0x820AA6B0;
	}
	return 0x820AA6B0;
} // Block from 820AA6A4h-820AA6B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AA6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA6B0);
		  /* 820AA6B0h */ case    0:  		/* mfspr R12, LR */
		/* 820AA6B0h case    0:*/		regs.R12 = regs.LR;
		/* 820AA6B0h case    0:*/		return 0x820AA6B4;
		  /* 820AA6B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820AA6B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AA6B4h case    1:*/		return 0x820AA6B8;
		  /* 820AA6B8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820AA6B8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AA6B8h case    2:*/		return 0x820AA6BC;
		  /* 820AA6BCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820AA6BCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AA6BCh case    3:*/		return 0x820AA6C0;
		  /* 820AA6C0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820AA6C0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820AA6C0h case    4:*/		return 0x820AA6C4;
		  /* 820AA6C4h */ case    5:  		/* mr R30, R4 */
		/* 820AA6C4h case    5:*/		regs.R30 = regs.R4;
		/* 820AA6C4h case    5:*/		return 0x820AA6C8;
		  /* 820AA6C8h */ case    6:  		/* li R4, 1 */
		/* 820AA6C8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820AA6C8h case    6:*/		return 0x820AA6CC;
		  /* 820AA6CCh */ case    7:  		/* mr R31, R3 */
		/* 820AA6CCh case    7:*/		regs.R31 = regs.R3;
		/* 820AA6CCh case    7:*/		return 0x820AA6D0;
		  /* 820AA6D0h */ case    8:  		/* bl -200 */
		/* 820AA6D0h case    8:*/		regs.LR = 0x820AA6D4; return 0x820AA608;
		/* 820AA6D0h case    8:*/		return 0x820AA6D4;
		  /* 820AA6D4h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820AA6D4h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AA6D4h case    9:*/		return 0x820AA6D8;
		  /* 820AA6D8h */ case   10:  		/* bc 12, CR0_LT, 36 */
		/* 820AA6D8h case   10:*/		if ( regs.CR[0].lt ) { return 0x820AA6FC;  }
		/* 820AA6D8h case   10:*/		return 0x820AA6DC;
		  /* 820AA6DCh */ case   11:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AA6DCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AA6DCh case   11:*/		return 0x820AA6E0;
		  /* 820AA6E0h */ case   12:  		/* li R3, 0 */
		/* 820AA6E0h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AA6E0h case   12:*/		return 0x820AA6E4;
		  /* 820AA6E4h */ case   13:  		/* lwz R10, <#[R31 + 100]> */
		/* 820AA6E4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000064) );
		/* 820AA6E4h case   13:*/		return 0x820AA6E8;
		  /* 820AA6E8h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AA6E8h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AA6E8h case   14:*/		return 0x820AA6EC;
		  /* 820AA6ECh */ case   15:  		/* stwx R30, <#[R11 + R10]> */
		/* 820AA6ECh case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820AA6ECh case   15:*/		return 0x820AA6F0;
		  /* 820AA6F0h */ case   16:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AA6F0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AA6F0h case   16:*/		return 0x820AA6F4;
		  /* 820AA6F4h */ case   17:  		/* addi R11, R11, 1 */
		/* 820AA6F4h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AA6F4h case   17:*/		return 0x820AA6F8;
		  /* 820AA6F8h */ case   18:  		/* stw R11, <#[R31 + 104]> */
		/* 820AA6F8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AA6F8h case   18:*/		return 0x820AA6FC;
	}
	return 0x820AA6FC;
} // Block from 820AA6B0h-820AA6FCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820AA6FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA6FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA6FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA6FC);
		  /* 820AA6FCh */ case    0:  		/* addi R1, R1, 112 */
		/* 820AA6FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820AA6FCh case    0:*/		return 0x820AA700;
		  /* 820AA700h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820AA700h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AA700h case    1:*/		return 0x820AA704;
		  /* 820AA704h */ case    2:  		/* mtspr LR, R12 */
		/* 820AA704h case    2:*/		regs.LR = regs.R12;
		/* 820AA704h case    2:*/		return 0x820AA708;
		  /* 820AA708h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820AA708h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AA708h case    3:*/		return 0x820AA70C;
		  /* 820AA70Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820AA70Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AA70Ch case    4:*/		return 0x820AA710;
		  /* 820AA710h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820AA710h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AA710h case    5:*/		return 0x820AA714;
	}
	return 0x820AA714;
} // Block from 820AA6FCh-820AA714h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AA714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA714);
		  /* 820AA714h */ case    0:  		/* nop */
		/* 820AA714h case    0:*/		cpu::op::nop();
		/* 820AA714h case    0:*/		return 0x820AA718;
	}
	return 0x820AA718;
} // Block from 820AA714h-820AA718h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AA718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA718);
		  /* 820AA718h */ case    0:  		/* mfspr R12, LR */
		/* 820AA718h case    0:*/		regs.R12 = regs.LR;
		/* 820AA718h case    0:*/		return 0x820AA71C;
		  /* 820AA71Ch */ case    1:  		/* bl -103648 */
		/* 820AA71Ch case    1:*/		regs.LR = 0x820AA720; return 0x8209123C;
		/* 820AA71Ch case    1:*/		return 0x820AA720;
		  /* 820AA720h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820AA720h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820AA720h case    2:*/		return 0x820AA724;
		  /* 820AA724h */ case    3:  		/* lwz R10, <#[R3 + 104]> */
		/* 820AA724h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000068) );
		/* 820AA724h case    3:*/		return 0x820AA728;
		  /* 820AA728h */ case    4:  		/* li R22, 1 */
		/* 820AA728h case    4:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820AA728h case    4:*/		return 0x820AA72C;
		  /* 820AA72Ch */ case    5:  		/* lwz R11, <#[R4 + 56]> */
		/* 820AA72Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000038) );
		/* 820AA72Ch case    5:*/		return 0x820AA730;
		  /* 820AA730h */ case    6:  		/* mr R31, R3 */
		/* 820AA730h case    6:*/		regs.R31 = regs.R3;
		/* 820AA730h case    6:*/		return 0x820AA734;
		  /* 820AA734h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AA734h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AA734h case    7:*/		return 0x820AA738;
		  /* 820AA738h */ case    8:  		/* mr R26, R4 */
		/* 820AA738h case    8:*/		regs.R26 = regs.R4;
		/* 820AA738h case    8:*/		return 0x820AA73C;
		  /* 820AA73Ch */ case    9:  		/* li R21, 0 */
		/* 820AA73Ch case    9:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 820AA73Ch case    9:*/		return 0x820AA740;
		  /* 820AA740h */ case   10:  		/* stw R10, <#[R4 + 96]> */
		/* 820AA740h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000060) );
		/* 820AA740h case   10:*/		return 0x820AA744;
		  /* 820AA744h */ case   11:  		/* mr R25, R22 */
		/* 820AA744h case   11:*/		regs.R25 = regs.R22;
		/* 820AA744h case   11:*/		return 0x820AA748;
		  /* 820AA748h */ case   12:  		/* cmplwi CR6, R11, 31 */
		/* 820AA748h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 820AA748h case   12:*/		return 0x820AA74C;
		  /* 820AA74Ch */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 820AA74Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x820AA754;  }
		/* 820AA74Ch case   13:*/		return 0x820AA750;
		  /* 820AA750h */ case   14:  		/* li R25, 2 */
		/* 820AA750h case   14:*/		cpu::op::li<0>(regs,&regs.R25,0x2);
		/* 820AA750h case   14:*/		return 0x820AA754;
	}
	return 0x820AA754;
} // Block from 820AA718h-820AA754h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820AA754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA754);
		  /* 820AA754h */ case    0:  		/* lwz R10, <#[R31 + 132]> */
		/* 820AA754h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 820AA754h case    0:*/		return 0x820AA758;
		  /* 820AA758h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820AA758h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AA758h case    1:*/		return 0x820AA75C;
		  /* 820AA75Ch */ case    2:  		/* bc 12, CR6_EQ, 152 */
		/* 820AA75Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA7F4;  }
		/* 820AA75Ch case    2:*/		return 0x820AA760;
		  /* 820AA760h */ case    3:  		/* cmplwi CR6, R11, 26 */
		/* 820AA760h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001A);
		/* 820AA760h case    3:*/		return 0x820AA764;
		  /* 820AA764h */ case    4:  		/* bc 12, CR6_EQ, 108 */
		/* 820AA764h case    4:*/		if ( regs.CR[6].eq ) { return 0x820AA7D0;  }
		/* 820AA764h case    4:*/		return 0x820AA768;
		  /* 820AA768h */ case    5:  		/* cmplwi CR6, R11, 25 */
		/* 820AA768h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000019);
		/* 820AA768h case    5:*/		return 0x820AA76C;
		  /* 820AA76Ch */ case    6:  		/* bc 12, CR6_EQ, 100 */
		/* 820AA76Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820AA7D0;  }
		/* 820AA76Ch case    6:*/		return 0x820AA770;
		  /* 820AA770h */ case    7:  		/* cmplwi CR6, R11, 28 */
		/* 820AA770h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001C);
		/* 820AA770h case    7:*/		return 0x820AA774;
		  /* 820AA774h */ case    8:  		/* bc 12, CR6_EQ, 92 */
		/* 820AA774h case    8:*/		if ( regs.CR[6].eq ) { return 0x820AA7D0;  }
		/* 820AA774h case    8:*/		return 0x820AA778;
		  /* 820AA778h */ case    9:  		/* cmplwi CR6, R11, 30 */
		/* 820AA778h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001E);
		/* 820AA778h case    9:*/		return 0x820AA77C;
		  /* 820AA77Ch */ case   10:  		/* bc 12, CR6_EQ, 84 */
		/* 820AA77Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820AA7D0;  }
		/* 820AA77Ch case   10:*/		return 0x820AA780;
		  /* 820AA780h */ case   11:  		/* cmplwi CR6, R11, 20 */
		/* 820AA780h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000014);
		/* 820AA780h case   11:*/		return 0x820AA784;
		  /* 820AA784h */ case   12:  		/* bc 12, CR6_EQ, 36 */
		/* 820AA784h case   12:*/		if ( regs.CR[6].eq ) { return 0x820AA7A8;  }
		/* 820AA784h case   12:*/		return 0x820AA788;
		  /* 820AA788h */ case   13:  		/* cmplwi CR6, R11, 21 */
		/* 820AA788h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 820AA788h case   13:*/		return 0x820AA78C;
		  /* 820AA78Ch */ case   14:  		/* bc 12, CR6_EQ, 28 */
		/* 820AA78Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x820AA7A8;  }
		/* 820AA78Ch case   14:*/		return 0x820AA790;
		  /* 820AA790h */ case   15:  		/* cmplwi CR6, R11, 22 */
		/* 820AA790h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000016);
		/* 820AA790h case   15:*/		return 0x820AA794;
		  /* 820AA794h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 820AA794h case   16:*/		if ( regs.CR[6].eq ) { return 0x820AA7A8;  }
		/* 820AA794h case   16:*/		return 0x820AA798;
		  /* 820AA798h */ case   17:  		/* cmplwi CR6, R11, 23 */
		/* 820AA798h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000017);
		/* 820AA798h case   17:*/		return 0x820AA79C;
		  /* 820AA79Ch */ case   18:  		/* bc 12, CR6_EQ, 12 */
		/* 820AA79Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x820AA7A8;  }
		/* 820AA79Ch case   18:*/		return 0x820AA7A0;
		  /* 820AA7A0h */ case   19:  		/* cmplwi CR6, R11, 24 */
		/* 820AA7A0h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 820AA7A0h case   19:*/		return 0x820AA7A4;
		  /* 820AA7A4h */ case   20:  		/* bc 4, CR6_EQ, 80 */
		/* 820AA7A4h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820AA7F4;  }
		/* 820AA7A4h case   20:*/		return 0x820AA7A8;
	}
	return 0x820AA7A8;
} // Block from 820AA754h-820AA7A8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820AA7A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA7A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA7A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA7A8);
		  /* 820AA7A8h */ case    0:  		/* lwz R11, <#[R26 + 80]> */
		/* 820AA7A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000050) );
		/* 820AA7A8h case    0:*/		return 0x820AA7AC;
		  /* 820AA7ACh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AA7ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA7ACh case    1:*/		return 0x820AA7B0;
		  /* 820AA7B0h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 820AA7B0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA7F4;  }
		/* 820AA7B0h case    2:*/		return 0x820AA7B4;
		  /* 820AA7B4h */ case    3:  		/* lwz R11, <#[R11 + 16]> */
		/* 820AA7B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820AA7B4h case    3:*/		return 0x820AA7B8;
		  /* 820AA7B8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820AA7B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA7B8h case    4:*/		return 0x820AA7BC;
		  /* 820AA7BCh */ case    5:  		/* bc 4, CR6_EQ, 56 */
		/* 820AA7BCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820AA7F4;  }
		/* 820AA7BCh case    5:*/		return 0x820AA7C0;
		  /* 820AA7C0h */ case    6:  		/* lis R11, -32255 */
		/* 820AA7C0h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA7C0h case    6:*/		return 0x820AA7C4;
		  /* 820AA7C4h */ case    7:  		/* li R5, 2026 */
		/* 820AA7C4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x7EA);
		/* 820AA7C4h case    7:*/		return 0x820AA7C8;
		  /* 820AA7C8h */ case    8:  		/* addi R6, R11, 4112 */
		/* 820AA7C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1010);
		/* 820AA7C8h case    8:*/		return 0x820AA7CC;
		  /* 820AA7CCh */ case    9:  		/* b 16 */
		/* 820AA7CCh case    9:*/		return 0x820AA7DC;
		/* 820AA7CCh case    9:*/		return 0x820AA7D0;
	}
	return 0x820AA7D0;
} // Block from 820AA7A8h-820AA7D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820AA7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA7D0);
		  /* 820AA7D0h */ case    0:  		/* lis R11, -32255 */
		/* 820AA7D0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA7D0h case    0:*/		return 0x820AA7D4;
		  /* 820AA7D4h */ case    1:  		/* li R5, 2025 */
		/* 820AA7D4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x7E9);
		/* 820AA7D4h case    1:*/		return 0x820AA7D8;
		  /* 820AA7D8h */ case    2:  		/* addi R6, R11, 4032 */
		/* 820AA7D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFC0);
		/* 820AA7D8h case    2:*/		return 0x820AA7DC;
	}
	return 0x820AA7DC;
} // Block from 820AA7D0h-820AA7DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AA7DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA7DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA7DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA7DC);
		  /* 820AA7DCh */ case    0:  		/* addi R4, R26, 16 */
		/* 820AA7DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AA7DCh case    0:*/		return 0x820AA7E0;
		  /* 820AA7E0h */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820AA7E0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AA7E0h case    1:*/		return 0x820AA7E4;
		  /* 820AA7E4h */ case    2:  		/* bl -13908 */
		/* 820AA7E4h case    2:*/		regs.LR = 0x820AA7E8; return 0x820A7190;
		/* 820AA7E4h case    2:*/		return 0x820AA7E8;
		  /* 820AA7E8h */ case    3:  		/* lis R3, -32768 */
		/* 820AA7E8h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820AA7E8h case    3:*/		return 0x820AA7EC;
		  /* 820AA7ECh */ case    4:  		/* ori R3, R3, 16389 */
		/* 820AA7ECh case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820AA7ECh case    4:*/		return 0x820AA7F0;
		  /* 820AA7F0h */ case    5:  		/* b 2292 */
		/* 820AA7F0h case    5:*/		return 0x820AB0E4;
		/* 820AA7F0h case    5:*/		return 0x820AA7F4;
	}
	return 0x820AA7F4;
} // Block from 820AA7DCh-820AA7F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AA7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA7F4);
		  /* 820AA7F4h */ case    0:  		/* lwz R30, <#[R26 + 68]> */
		/* 820AA7F4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000044) );
		/* 820AA7F4h case    0:*/		return 0x820AA7F8;
		  /* 820AA7F8h */ case    1:  		/* lis R11, -32255 */
		/* 820AA7F8h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA7F8h case    1:*/		return 0x820AA7FC;
		  /* 820AA7FCh */ case    2:  		/* addi R28, R11, 3952 */
		/* 820AA7FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xF70);
		/* 820AA7FCh case    2:*/		return 0x820AA800;
		  /* 820AA800h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 820AA800h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820AA800h case    3:*/		return 0x820AA804;
		  /* 820AA804h */ case    4:  		/* bc 12, CR6_EQ, 196 */
		/* 820AA804h case    4:*/		if ( regs.CR[6].eq ) { return 0x820AA8C8;  }
		/* 820AA804h case    4:*/		return 0x820AA808;
		  /* 820AA808h */ case    5:  		/* lwz R11, <#[R30 + 4]> */
		/* 820AA808h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820AA808h case    5:*/		return 0x820AA80C;
		  /* 820AA80Ch */ case    6:  		/* cmpwi CR6, R11, 25 */
		/* 820AA80Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000019);
		/* 820AA80Ch case    6:*/		return 0x820AA810;
		  /* 820AA810h */ case    7:  		/* bc 4, CR6_EQ, 184 */
		/* 820AA810h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820AA8C8;  }
		/* 820AA810h case    7:*/		return 0x820AA814;
		  /* 820AA814h */ case    8:  		/* lwz R11, <#[R30 + 16]> */
		/* 820AA814h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820AA814h case    8:*/		return 0x820AA818;
		  /* 820AA818h */ case    9:  		/* addi R25, R25, 1 */
		/* 820AA818h case    9:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 820AA818h case    9:*/		return 0x820AA81C;
		  /* 820AA81Ch */ case   10:  		/* cmpwi CR6, R11, -1 */
		/* 820AA81Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820AA81Ch case   10:*/		return 0x820AA820;
		  /* 820AA820h */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 820AA820h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820AA828;  }
		/* 820AA820h case   11:*/		return 0x820AA824;
		  /* 820AA824h */ case   12:  		/* mr R21, R22 */
		/* 820AA824h case   12:*/		regs.R21 = regs.R22;
		/* 820AA824h case   12:*/		return 0x820AA828;
	}
	return 0x820AA828;
} // Block from 820AA7F4h-820AA828h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AA828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA828);
		  /* 820AA828h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820AA828h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820AA828h case    0:*/		return 0x820AA82C;
		  /* 820AA82Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AA82Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA82Ch case    1:*/		return 0x820AA830;
		  /* 820AA830h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820AA830h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA850;  }
		/* 820AA830h case    2:*/		return 0x820AA834;
		  /* 820AA834h */ case    3:  		/* lis R11, -32255 */
		/* 820AA834h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA834h case    3:*/		return 0x820AA838;
	}
	return 0x820AA838;
} // Block from 820AA828h-820AA838h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA838h
// Function '?DecodeRegister@CAssembler@D3DXShader@@IAAPAVCNode@2@PAUD3DXTOKEN@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA838);
		  /* 820AA838h */ case    0:  		/* lwz R3, <#[R31]> */
		/* 820AA838h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AA838h case    0:*/		return 0x820AA83C;
		  /* 820AA83Ch */ case    1:  		/* li R5, 2014 */
		/* 820AA83Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x7DE);
		/* 820AA83Ch case    1:*/		return 0x820AA840;
		  /* 820AA840h */ case    2:  		/* addi R6, R11, 3888 */
		/* 820AA840h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xF30);
		/* 820AA840h case    2:*/		return 0x820AA844;
		  /* 820AA844h */ case    3:  		/* addi R4, R26, 16 */
		/* 820AA844h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AA844h case    3:*/		return 0x820AA848;
		  /* 820AA848h */ case    4:  		/* bl -14008 */
		/* 820AA848h case    4:*/		regs.LR = 0x820AA84C; return 0x820A7190;
		/* 820AA848h case    4:*/		return 0x820AA84C;
		  /* 820AA84Ch */ case    5:  		/* stw R22, <#[R31 + 84]> */
		/* 820AA84Ch case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000054) );
		/* 820AA84Ch case    5:*/		return 0x820AA850;
	}
	return 0x820AA850;
} // Block from 820AA838h-820AA850h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AA850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA850);
		  /* 820AA850h */ case    0:  		/* lwz R10, <#[R30 + 40]> */
		/* 820AA850h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000028) );
		/* 820AA850h case    0:*/		return 0x820AA854;
		  /* 820AA854h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820AA854h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AA854h case    1:*/		return 0x820AA858;
		  /* 820AA858h */ case    2:  		/* bc 12, CR6_EQ, 112 */
		/* 820AA858h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA8C8;  }
		/* 820AA858h case    2:*/		return 0x820AA85C;
		  /* 820AA85Ch */ case    3:  		/* lwz R11, <#[R31 + 64]> */
		/* 820AA85Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820AA85Ch case    3:*/		return 0x820AA860;
		  /* 820AA860h */ case    4:  		/* cmpwi CR6, R11, 4 */
		/* 820AA860h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 820AA860h case    4:*/		return 0x820AA864;
		  /* 820AA864h */ case    5:  		/* bc 12, CR6_LT, 72 */
		/* 820AA864h case    5:*/		if ( regs.CR[6].lt ) { return 0x820AA8AC;  }
		/* 820AA864h case    5:*/		return 0x820AA868;
		  /* 820AA868h */ case    6:  		/* cmpwi CR6, R11, 5 */
		/* 820AA868h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 820AA868h case    6:*/		return 0x820AA86C;
		  /* 820AA86Ch */ case    7:  		/* bc 12, CR6_GT, 64 */
		/* 820AA86Ch case    7:*/		if ( regs.CR[6].gt ) { return 0x820AA8AC;  }
		/* 820AA86Ch case    7:*/		return 0x820AA870;
		  /* 820AA870h */ case    8:  		/* lwz R11, <#[R10 + 16]> */
		/* 820AA870h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820AA870h case    8:*/		return 0x820AA874;
		  /* 820AA874h */ case    9:  		/* cmpwi CR6, R11, -1 */
		/* 820AA874h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820AA874h case    9:*/		return 0x820AA878;
		  /* 820AA878h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 820AA878h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820AA880;  }
		/* 820AA878h case   10:*/		return 0x820AA87C;
		  /* 820AA87Ch */ case   11:  		/* mr R21, R22 */
		/* 820AA87Ch case   11:*/		regs.R21 = regs.R22;
		/* 820AA87Ch case   11:*/		return 0x820AA880;
	}
	return 0x820AA880;
} // Block from 820AA850h-820AA880h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AA880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA880);
		  /* 820AA880h */ case    0:  		/* lwz R11, <#[R10 + 40]> */
		/* 820AA880h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000028) );
		/* 820AA880h case    0:*/		return 0x820AA884;
		  /* 820AA884h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AA884h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA884h case    1:*/		return 0x820AA888;
		  /* 820AA888h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 820AA888h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA8A4;  }
		/* 820AA888h case    2:*/		return 0x820AA88C;
		  /* 820AA88Ch */ case    3:  		/* mr R6, R28 */
		/* 820AA88Ch case    3:*/		regs.R6 = regs.R28;
		/* 820AA88Ch case    3:*/		return 0x820AA890;
		  /* 820AA890h */ case    4:  		/* lwz R3, <#[R31]> */
		/* 820AA890h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AA890h case    4:*/		return 0x820AA894;
		  /* 820AA894h */ case    5:  		/* li R5, 2009 */
		/* 820AA894h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x7D9);
		/* 820AA894h case    5:*/		return 0x820AA898;
		  /* 820AA898h */ case    6:  		/* addi R4, R26, 16 */
		/* 820AA898h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AA898h case    6:*/		return 0x820AA89C;
		  /* 820AA89Ch */ case    7:  		/* bl -14092 */
		/* 820AA89Ch case    7:*/		regs.LR = 0x820AA8A0; return 0x820A7190;
		/* 820AA89Ch case    7:*/		return 0x820AA8A0;
		  /* 820AA8A0h */ case    8:  		/* stw R22, <#[R31 + 84]> */
		/* 820AA8A0h case    8:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000054) );
		/* 820AA8A0h case    8:*/		return 0x820AA8A4;
	}
	return 0x820AA8A4;
} // Block from 820AA880h-820AA8A4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AA8A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA8A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA8A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA8A4);
		  /* 820AA8A4h */ case    0:  		/* addi R25, R25, 1 */
		/* 820AA8A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 820AA8A4h case    0:*/		return 0x820AA8A8;
		  /* 820AA8A8h */ case    1:  		/* b 32 */
		/* 820AA8A8h case    1:*/		return 0x820AA8C8;
		/* 820AA8A8h case    1:*/		return 0x820AA8AC;
	}
	return 0x820AA8AC;
} // Block from 820AA8A4h-820AA8ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AA8ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA8AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA8AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA8AC);
		  /* 820AA8ACh */ case    0:  		/* lis R11, -32255 */
		/* 820AA8ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA8ACh case    0:*/		return 0x820AA8B0;
		  /* 820AA8B0h */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820AA8B0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AA8B0h case    1:*/		return 0x820AA8B4;
		  /* 820AA8B4h */ case    2:  		/* li R5, 2008 */
		/* 820AA8B4h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7D8);
		/* 820AA8B4h case    2:*/		return 0x820AA8B8;
		  /* 820AA8B8h */ case    3:  		/* addi R6, R11, 3800 */
		/* 820AA8B8h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xED8);
		/* 820AA8B8h case    3:*/		return 0x820AA8BC;
		  /* 820AA8BCh */ case    4:  		/* addi R4, R26, 16 */
		/* 820AA8BCh case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AA8BCh case    4:*/		return 0x820AA8C0;
		  /* 820AA8C0h */ case    5:  		/* bl -14128 */
		/* 820AA8C0h case    5:*/		regs.LR = 0x820AA8C4; return 0x820A7190;
		/* 820AA8C0h case    5:*/		return 0x820AA8C4;
		  /* 820AA8C4h */ case    6:  		/* stw R22, <#[R31 + 84]> */
		/* 820AA8C4h case    6:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000054) );
		/* 820AA8C4h case    6:*/		return 0x820AA8C8;
	}
	return 0x820AA8C8;
} // Block from 820AA8ACh-820AA8C8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AA8C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA8C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA8C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA8C8);
		  /* 820AA8C8h */ case    0:  		/* lwz R11, <#[R26 + 72]> */
		/* 820AA8C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000048) );
		/* 820AA8C8h case    0:*/		return 0x820AA8CC;
		  /* 820AA8CCh */ case    1:  		/* lis R27, 3328 */
		/* 820AA8CCh case    1:*/		cpu::op::lis<0>(regs,&regs.R27,0xD00);
		/* 820AA8CCh case    1:*/		return 0x820AA8D0;
		  /* 820AA8D0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820AA8D0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA8D0h case    2:*/		return 0x820AA8D4;
		  /* 820AA8D4h */ case    3:  		/* bc 12, CR6_EQ, 192 */
		/* 820AA8D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820AA994;  }
		/* 820AA8D4h case    3:*/		return 0x820AA8D8;
		  /* 820AA8D8h */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 820AA8D8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820AA8D8h case    4:*/		return 0x820AA8DC;
		  /* 820AA8DCh */ case    5:  		/* cmpwi CR6, R11, 25 */
		/* 820AA8DCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000019);
		/* 820AA8DCh case    5:*/		return 0x820AA8E0;
		  /* 820AA8E0h */ case    6:  		/* bc 4, CR6_EQ, 180 */
		/* 820AA8E0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820AA994;  }
		/* 820AA8E0h case    6:*/		return 0x820AA8E4;
		  /* 820AA8E4h */ case    7:  		/* lwz R11, <#[R31 + 64]> */
		/* 820AA8E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820AA8E4h case    7:*/		return 0x820AA8E8;
		  /* 820AA8E8h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 820AA8E8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AA8E8h case    8:*/		return 0x820AA8EC;
		  /* 820AA8ECh */ case    9:  		/* bc 12, CR6_LT, 12 */
		/* 820AA8ECh case    9:*/		if ( regs.CR[6].lt ) { return 0x820AA8F8;  }
		/* 820AA8ECh case    9:*/		return 0x820AA8F0;
		  /* 820AA8F0h */ case   10:  		/* cmpwi CR6, R11, 1 */
		/* 820AA8F0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820AA8F0h case   10:*/		return 0x820AA8F4;
		  /* 820AA8F4h */ case   11:  		/* bc 4, CR6_GT, 20 */
		/* 820AA8F4h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820AA908;  }
		/* 820AA8F4h case   11:*/		return 0x820AA8F8;
	}
	return 0x820AA8F8;
} // Block from 820AA8C8h-820AA8F8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AA8F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA8F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA8F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA8F8);
		  /* 820AA8F8h */ case    0:  		/* cmpwi CR6, R11, 6 */
		/* 820AA8F8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820AA8F8h case    0:*/		return 0x820AA8FC;
		  /* 820AA8FCh */ case    1:  		/* bc 12, CR6_LT, 40 */
		/* 820AA8FCh case    1:*/		if ( regs.CR[6].lt ) { return 0x820AA924;  }
		/* 820AA8FCh case    1:*/		return 0x820AA900;
		  /* 820AA900h */ case    2:  		/* cmpwi CR6, R11, 10 */
		/* 820AA900h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 820AA900h case    2:*/		return 0x820AA904;
		  /* 820AA904h */ case    3:  		/* bc 12, CR6_GT, 32 */
		/* 820AA904h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AA924;  }
		/* 820AA904h case    3:*/		return 0x820AA908;
	}
	return 0x820AA908;
} // Block from 820AA8F8h-820AA908h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AA908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA908);
		  /* 820AA908h */ case    0:  		/* lis R11, -32255 */
		/* 820AA908h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA908h case    0:*/		return 0x820AA90C;
		  /* 820AA90Ch */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820AA90Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AA90Ch case    1:*/		return 0x820AA910;
		  /* 820AA910h */ case    2:  		/* li R5, 2021 */
		/* 820AA910h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7E5);
		/* 820AA910h case    2:*/		return 0x820AA914;
		  /* 820AA914h */ case    3:  		/* addi R6, R11, 3748 */
		/* 820AA914h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xEA4);
		/* 820AA914h case    3:*/		return 0x820AA918;
		  /* 820AA918h */ case    4:  		/* addi R4, R26, 16 */
		/* 820AA918h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AA918h case    4:*/		return 0x820AA91C;
		  /* 820AA91Ch */ case    5:  		/* bl -14220 */
		/* 820AA91Ch case    5:*/		regs.LR = 0x820AA920; return 0x820A7190;
		/* 820AA91Ch case    5:*/		return 0x820AA920;
		  /* 820AA920h */ case    6:  		/* stw R22, <#[R31 + 84]> */
		/* 820AA920h case    6:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000054) );
		/* 820AA920h case    6:*/		return 0x820AA924;
	}
	return 0x820AA924;
} // Block from 820AA908h-820AA924h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AA924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA924);
		  /* 820AA924h */ case    0:  		/* lwz R30, <#[R26 + 72]> */
		/* 820AA924h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000048) );
		/* 820AA924h case    0:*/		return 0x820AA928;
		  /* 820AA928h */ case    1:  		/* addi R25, R25, 1 */
		/* 820AA928h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 820AA928h case    1:*/		return 0x820AA92C;
		  /* 820AA92Ch */ case    2:  		/* lwz R11, <#[R30 + 16]> */
		/* 820AA92Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820AA92Ch case    2:*/		return 0x820AA930;
		  /* 820AA930h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 820AA930h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820AA930h case    3:*/		return 0x820AA934;
		  /* 820AA934h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 820AA934h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820AA93C;  }
		/* 820AA934h case    4:*/		return 0x820AA938;
		  /* 820AA938h */ case    5:  		/* mr R21, R22 */
		/* 820AA938h case    5:*/		regs.R21 = regs.R22;
		/* 820AA938h case    5:*/		return 0x820AA93C;
	}
	return 0x820AA93C;
} // Block from 820AA924h-820AA93Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AA93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA93C);
		  /* 820AA93Ch */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820AA93Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820AA93Ch case    0:*/		return 0x820AA940;
		  /* 820AA940h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AA940h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA940h case    1:*/		return 0x820AA944;
		  /* 820AA944h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820AA944h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA96C;  }
		/* 820AA944h case    2:*/		return 0x820AA948;
		  /* 820AA948h */ case    3:  		/* cmplw CR6, R11, R27 */
		/* 820AA948h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820AA948h case    3:*/		return 0x820AA94C;
		  /* 820AA94Ch */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 820AA94Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820AA96C;  }
		/* 820AA94Ch case    4:*/		return 0x820AA950;
		  /* 820AA950h */ case    5:  		/* lis R11, -32255 */
		/* 820AA950h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA950h case    5:*/		return 0x820AA954;
		  /* 820AA954h */ case    6:  		/* lwz R3, <#[R31]> */
		/* 820AA954h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AA954h case    6:*/		return 0x820AA958;
		  /* 820AA958h */ case    7:  		/* li R5, 2019 */
		/* 820AA958h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x7E3);
		/* 820AA958h case    7:*/		return 0x820AA95C;
		  /* 820AA95Ch */ case    8:  		/* addi R6, R11, 3700 */
		/* 820AA95Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xE74);
		/* 820AA95Ch case    8:*/		return 0x820AA960;
		  /* 820AA960h */ case    9:  		/* addi R4, R26, 16 */
		/* 820AA960h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AA960h case    9:*/		return 0x820AA964;
		  /* 820AA964h */ case   10:  		/* bl -14292 */
		/* 820AA964h case   10:*/		regs.LR = 0x820AA968; return 0x820A7190;
		/* 820AA964h case   10:*/		return 0x820AA968;
		  /* 820AA968h */ case   11:  		/* stw R22, <#[R31 + 84]> */
		/* 820AA968h case   11:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000054) );
		/* 820AA968h case   11:*/		return 0x820AA96C;
	}
	return 0x820AA96C;
} // Block from 820AA93Ch-820AA96Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AA96Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA96C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA96C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA96C);
		  /* 820AA96Ch */ case    0:  		/* lwz R11, <#[R30 + 40]> */
		/* 820AA96Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 820AA96Ch case    0:*/		return 0x820AA970;
		  /* 820AA970h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AA970h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA970h case    1:*/		return 0x820AA974;
		  /* 820AA974h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820AA974h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AA994;  }
		/* 820AA974h case    2:*/		return 0x820AA978;
		  /* 820AA978h */ case    3:  		/* lis R11, -32255 */
		/* 820AA978h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AA978h case    3:*/		return 0x820AA97C;
		  /* 820AA97Ch */ case    4:  		/* lwz R3, <#[R31]> */
		/* 820AA97Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AA97Ch case    4:*/		return 0x820AA980;
		  /* 820AA980h */ case    5:  		/* li R5, 2020 */
		/* 820AA980h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x7E4);
		/* 820AA980h case    5:*/		return 0x820AA984;
		  /* 820AA984h */ case    6:  		/* addi R6, R11, 3624 */
		/* 820AA984h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xE28);
		/* 820AA984h case    6:*/		return 0x820AA988;
		  /* 820AA988h */ case    7:  		/* addi R4, R26, 16 */
		/* 820AA988h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AA988h case    7:*/		return 0x820AA98C;
		  /* 820AA98Ch */ case    8:  		/* bl -14332 */
		/* 820AA98Ch case    8:*/		regs.LR = 0x820AA990; return 0x820A7190;
		/* 820AA98Ch case    8:*/		return 0x820AA990;
		  /* 820AA990h */ case    9:  		/* stw R22, <#[R31 + 84]> */
		/* 820AA990h case    9:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000054) );
		/* 820AA990h case    9:*/		return 0x820AA994;
	}
	return 0x820AA994;
} // Block from 820AA96Ch-820AA994h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820AA994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA994);
		  /* 820AA994h */ case    0:  		/* addi R24, R26, 76 */
		/* 820AA994h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R26,0x4C);
		/* 820AA994h case    0:*/		return 0x820AA998;
		  /* 820AA998h */ case    1:  		/* li R29, 0 */
		/* 820AA998h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820AA998h case    1:*/		return 0x820AA99C;
		  /* 820AA99Ch */ case    2:  		/* mr R30, R24 */
		/* 820AA99Ch case    2:*/		regs.R30 = regs.R24;
		/* 820AA99Ch case    2:*/		return 0x820AA9A0;
		  /* 820AA9A0h */ case    3:  		/* lwz R10, <#[R30]> */
		/* 820AA9A0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820AA9A0h case    3:*/		return 0x820AA9A4;
		  /* 820AA9A4h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 820AA9A4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AA9A4h case    4:*/		return 0x820AA9A8;
		  /* 820AA9A8h */ case    5:  		/* bc 12, CR6_EQ, 148 */
		/* 820AA9A8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820AAA3C;  }
		/* 820AA9A8h case    5:*/		return 0x820AA9AC;
		  /* 820AA9ACh */ case    6:  		/* lwz R11, <#[R26 + 56]> */
		/* 820AA9ACh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000038) );
		/* 820AA9ACh case    6:*/		return 0x820AA9B0;
		  /* 820AA9B0h */ case    7:  		/* addi R25, R25, 1 */
		/* 820AA9B0h case    7:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 820AA9B0h case    7:*/		return 0x820AA9B4;
		  /* 820AA9B4h */ case    8:  		/* cmplwi CR6, R11, 81 */
		/* 820AA9B4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000051);
		/* 820AA9B4h case    8:*/		return 0x820AA9B8;
		  /* 820AA9B8h */ case    9:  		/* bc 12, CR6_EQ, 116 */
		/* 820AA9B8h case    9:*/		if ( regs.CR[6].eq ) { return 0x820AAA2C;  }
		/* 820AA9B8h case    9:*/		return 0x820AA9BC;
		  /* 820AA9BCh */ case   10:  		/* cmplwi CR6, R11, 48 */
		/* 820AA9BCh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 820AA9BCh case   10:*/		return 0x820AA9C0;
		  /* 820AA9C0h */ case   11:  		/* bc 12, CR6_EQ, 108 */
		/* 820AA9C0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820AAA2C;  }
		/* 820AA9C0h case   11:*/		return 0x820AA9C4;
		  /* 820AA9C4h */ case   12:  		/* cmplwi CR6, R11, 47 */
		/* 820AA9C4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002F);
		/* 820AA9C4h case   12:*/		return 0x820AA9C8;
		  /* 820AA9C8h */ case   13:  		/* bc 12, CR6_EQ, 100 */
		/* 820AA9C8h case   13:*/		if ( regs.CR[6].eq ) { return 0x820AAA2C;  }
		/* 820AA9C8h case   13:*/		return 0x820AA9CC;
		  /* 820AA9CCh */ case   14:  		/* lwz R11, <#[R10 + 16]> */
		/* 820AA9CCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820AA9CCh case   14:*/		return 0x820AA9D0;
		  /* 820AA9D0h */ case   15:  		/* cmpwi CR6, R11, -1 */
		/* 820AA9D0h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820AA9D0h case   15:*/		return 0x820AA9D4;
		  /* 820AA9D4h */ case   16:  		/* bc 4, CR6_EQ, 8 */
		/* 820AA9D4h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820AA9DC;  }
		/* 820AA9D4h case   16:*/		return 0x820AA9D8;
		  /* 820AA9D8h */ case   17:  		/* mr R21, R22 */
		/* 820AA9D8h case   17:*/		regs.R21 = regs.R22;
		/* 820AA9D8h case   17:*/		return 0x820AA9DC;
	}
	return 0x820AA9DC;
} // Block from 820AA994h-820AA9DCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 820AA9DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA9DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA9DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA9DC);
		  /* 820AA9DCh */ case    0:  		/* lwz R11, <#[R10 + 40]> */
		/* 820AA9DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000028) );
		/* 820AA9DCh case    0:*/		return 0x820AA9E0;
		  /* 820AA9E0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AA9E0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA9E0h case    1:*/		return 0x820AA9E4;
		  /* 820AA9E4h */ case    2:  		/* bc 12, CR6_EQ, 72 */
		/* 820AA9E4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AAA2C;  }
		/* 820AA9E4h case    2:*/		return 0x820AA9E8;
		  /* 820AA9E8h */ case    3:  		/* lwz R10, <#[R11 + 16]> */
		/* 820AA9E8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820AA9E8h case    3:*/		return 0x820AA9EC;
		  /* 820AA9ECh */ case    4:  		/* cmpwi CR6, R10, -1 */
		/* 820AA9ECh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820AA9ECh case    4:*/		return 0x820AA9F0;
		  /* 820AA9F0h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820AA9F0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820AA9F8;  }
		/* 820AA9F0h case    5:*/		return 0x820AA9F4;
		  /* 820AA9F4h */ case    6:  		/* mr R21, R22 */
		/* 820AA9F4h case    6:*/		regs.R21 = regs.R22;
		/* 820AA9F4h case    6:*/		return 0x820AA9F8;
	}
	return 0x820AA9F8;
} // Block from 820AA9DCh-820AA9F8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AA9F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AA9F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AA9F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AA9F8);
		  /* 820AA9F8h */ case    0:  		/* lwz R11, <#[R11 + 40]> */
		/* 820AA9F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 820AA9F8h case    0:*/		return 0x820AA9FC;
		  /* 820AA9FCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AA9FCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AA9FCh case    1:*/		return 0x820AAA00;
		  /* 820AAA00h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 820AAA00h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AAA1C;  }
		/* 820AAA00h case    2:*/		return 0x820AAA04;
		  /* 820AAA04h */ case    3:  		/* mr R6, R28 */
		/* 820AAA04h case    3:*/		regs.R6 = regs.R28;
		/* 820AAA04h case    3:*/		return 0x820AAA08;
		  /* 820AAA08h */ case    4:  		/* lwz R3, <#[R31]> */
		/* 820AAA08h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AAA08h case    4:*/		return 0x820AAA0C;
		  /* 820AAA0Ch */ case    5:  		/* li R5, 2009 */
		/* 820AAA0Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x7D9);
		/* 820AAA0Ch case    5:*/		return 0x820AAA10;
		  /* 820AAA10h */ case    6:  		/* addi R4, R26, 16 */
		/* 820AAA10h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AAA10h case    6:*/		return 0x820AAA14;
		  /* 820AAA14h */ case    7:  		/* bl -14468 */
		/* 820AAA14h case    7:*/		regs.LR = 0x820AAA18; return 0x820A7190;
		/* 820AAA14h case    7:*/		return 0x820AAA18;
		  /* 820AAA18h */ case    8:  		/* stw R22, <#[R31 + 84]> */
		/* 820AAA18h case    8:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000054) );
		/* 820AAA18h case    8:*/		return 0x820AAA1C;
	}
	return 0x820AAA1C;
} // Block from 820AA9F8h-820AAA1Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AAA1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAA1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAA1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAA1C);
		  /* 820AAA1Ch */ case    0:  		/* lwz R11, <#[R31 + 64]> */
		/* 820AAA1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820AAA1Ch case    0:*/		return 0x820AAA20;
		  /* 820AAA20h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820AAA20h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AAA20h case    1:*/		return 0x820AAA24;
		  /* 820AAA24h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820AAA24h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AAA2C;  }
		/* 820AAA24h case    2:*/		return 0x820AAA28;
		  /* 820AAA28h */ case    3:  		/* addi R25, R25, 1 */
		/* 820AAA28h case    3:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 820AAA28h case    3:*/		return 0x820AAA2C;
	}
	return 0x820AAA2C;
} // Block from 820AAA1Ch-820AAA2Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AAA2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAA2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAA2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAA2C);
		  /* 820AAA2Ch */ case    0:  		/* addi R29, R29, 1 */
		/* 820AAA2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820AAA2Ch case    0:*/		return 0x820AAA30;
		  /* 820AAA30h */ case    1:  		/* addi R30, R30, 4 */
		/* 820AAA30h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820AAA30h case    1:*/		return 0x820AAA34;
		  /* 820AAA34h */ case    2:  		/* cmplwi CR6, R29, 4 */
		/* 820AAA34h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000004);
		/* 820AAA34h case    2:*/		return 0x820AAA38;
		  /* 820AAA38h */ case    3:  		/* bc 12, CR6_LT, -152 */
		/* 820AAA38h case    3:*/		if ( regs.CR[6].lt ) { return 0x820AA9A0;  }
		/* 820AAA38h case    3:*/		return 0x820AAA3C;
	}
	return 0x820AAA3C;
} // Block from 820AAA2Ch-820AAA3Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AAA3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAA3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAA3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAA3C);
		  /* 820AAA3Ch */ case    0:  		/* mr R4, R25 */
		/* 820AAA3Ch case    0:*/		regs.R4 = regs.R25;
		/* 820AAA3Ch case    0:*/		return 0x820AAA40;
		  /* 820AAA40h */ case    1:  		/* mr R3, R31 */
		/* 820AAA40h case    1:*/		regs.R3 = regs.R31;
		/* 820AAA40h case    1:*/		return 0x820AAA44;
		  /* 820AAA44h */ case    2:  		/* bl -1084 */
		/* 820AAA44h case    2:*/		regs.LR = 0x820AAA48; return 0x820AA608;
		/* 820AAA44h case    2:*/		return 0x820AAA48;
		  /* 820AAA48h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820AAA48h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AAA48h case    3:*/		return 0x820AAA4C;
		  /* 820AAA4Ch */ case    4:  		/* bc 12, CR0_LT, 1688 */
		/* 820AAA4Ch case    4:*/		if ( regs.CR[0].lt ) { return 0x820AB0E4;  }
		/* 820AAA4Ch case    4:*/		return 0x820AAA50;
		  /* 820AAA50h */ case    5:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AAA50h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAA50h case    5:*/		return 0x820AAA54;
		  /* 820AAA54h */ case    6:  		/* lwz R30, <#[R26 + 56]> */
		/* 820AAA54h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000038) );
		/* 820AAA54h case    6:*/		return 0x820AAA58;
		  /* 820AAA58h */ case    7:  		/* add R23, R25, R11 */
		/* 820AAA58h case    7:*/		cpu::op::add<0>(regs,&regs.R23,regs.R25,regs.R11);
		/* 820AAA58h case    7:*/		return 0x820AAA5C;
		  /* 820AAA5Ch */ case    8:  		/* cmplwi CR6, R30, 3 */
		/* 820AAA5Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000003);
		/* 820AAA5Ch case    8:*/		return 0x820AAA60;
		  /* 820AAA60h */ case    9:  		/* bc 4, CR6_EQ, 304 */
		/* 820AAA60h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820AAB90;  }
		/* 820AAA60h case    9:*/		return 0x820AAA64;
		  /* 820AAA64h */ case   10:  		/* lwz R11, <#[R31 + 64]> */
		/* 820AAA64h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820AAA64h case   10:*/		return 0x820AAA68;
		  /* 820AAA68h */ case   11:  		/* cmpwi CR6, R11, 0 */
		/* 820AAA68h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AAA68h case   11:*/		return 0x820AAA6C;
		  /* 820AAA6Ch */ case   12:  		/* bc 12, CR6_LT, 12 */
		/* 820AAA6Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x820AAA78;  }
		/* 820AAA6Ch case   12:*/		return 0x820AAA70;
		  /* 820AAA70h */ case   13:  		/* cmpwi CR6, R11, 5 */
		/* 820AAA70h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 820AAA70h case   13:*/		return 0x820AAA74;
		  /* 820AAA74h */ case   14:  		/* bc 4, CR6_GT, 20 */
		/* 820AAA74h case   14:*/		if ( !regs.CR[6].gt ) { return 0x820AAA88;  }
		/* 820AAA74h case   14:*/		return 0x820AAA78;
	}
	return 0x820AAA78;
} // Block from 820AAA3Ch-820AAA78h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820AAA78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAA78);
		  /* 820AAA78h */ case    0:  		/* cmpwi CR6, R11, 10 */
		/* 820AAA78h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 820AAA78h case    0:*/		return 0x820AAA7C;
		  /* 820AAA7Ch */ case    1:  		/* bc 12, CR6_LT, 276 */
		/* 820AAA7Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x820AAB90;  }
		/* 820AAA7Ch case    1:*/		return 0x820AAA80;
		  /* 820AAA80h */ case    2:  		/* cmpwi CR6, R11, 15 */
		/* 820AAA80h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 820AAA80h case    2:*/		return 0x820AAA84;
		  /* 820AAA84h */ case    3:  		/* bc 12, CR6_GT, 268 */
		/* 820AAA84h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AAB90;  }
		/* 820AAA84h case    3:*/		return 0x820AAA88;
	}
	return 0x820AAA88;
} // Block from 820AAA78h-820AAA88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AAA88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAA88);
		  /* 820AAA88h */ case    0:  		/* lwz R10, <#[R26 + 80]> */
		/* 820AAA88h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000050) );
		/* 820AAA88h case    0:*/		return 0x820AAA8C;
		  /* 820AAA8Ch */ case    1:  		/* lis R9, 1792 */
		/* 820AAA8Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0x700);
		/* 820AAA8Ch case    1:*/		return 0x820AAA90;
		  /* 820AAA90h */ case    2:  		/* li R30, 2 */
		/* 820AAA90h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 820AAA90h case    2:*/		return 0x820AAA94;
		  /* 820AAA94h */ case    3:  		/* lwz R11, <#[R10 + 20]> */
		/* 820AAA94h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 820AAA94h case    3:*/		return 0x820AAA98;
		  /* 820AAA98h */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 820AAA98h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820AAA98h case    4:*/		return 0x820AAA9C;
		  /* 820AAA9Ch */ case    5:  		/* bc 12, CR6_GT, 164 */
		/* 820AAA9Ch case    5:*/		if ( regs.CR[6].gt ) { return 0x820AAB40;  }
		/* 820AAA9Ch case    5:*/		return 0x820AAAA0;
		  /* 820AAAA0h */ case    6:  		/* bc 12, CR6_EQ, 152 */
		/* 820AAAA0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820AAB38;  }
		/* 820AAAA0h case    6:*/		return 0x820AAAA4;
		  /* 820AAAA4h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820AAAA4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AAAA4h case    7:*/		return 0x820AAAA8;
		  /* 820AAAA8h */ case    8:  		/* bc 12, CR6_EQ, 132 */
		/* 820AAAA8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820AAB2C;  }
		/* 820AAAA8h case    8:*/		return 0x820AAAAC;
		  /* 820AAAACh */ case    9:  		/* lis R9, 256 */
		/* 820AAAACh case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x100);
		/* 820AAAACh case    9:*/		return 0x820AAAB0;
		  /* 820AAAB0h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 820AAAB0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820AAAB0h case   10:*/		return 0x820AAAB4;
		  /* 820AAAB4h */ case   11:  		/* bc 12, CR6_EQ, 112 */
		/* 820AAAB4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820AAB24;  }
		/* 820AAAB4h case   11:*/		return 0x820AAAB8;
		  /* 820AAAB8h */ case   12:  		/* lis R9, 512 */
		/* 820AAAB8h case   12:*/		cpu::op::lis<0>(regs,&regs.R9,0x200);
		/* 820AAAB8h case   12:*/		return 0x820AAABC;
		  /* 820AAABCh */ case   13:  		/* cmplw CR6, R11, R9 */
		/* 820AAABCh case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820AAABCh case   13:*/		return 0x820AAAC0;
		  /* 820AAAC0h */ case   14:  		/* bc 12, CR6_EQ, 92 */
		/* 820AAAC0h case   14:*/		if ( regs.CR[6].eq ) { return 0x820AAB1C;  }
		/* 820AAAC0h case   14:*/		return 0x820AAAC4;
		  /* 820AAAC4h */ case   15:  		/* lis R8, 768 */
		/* 820AAAC4h case   15:*/		cpu::op::lis<0>(regs,&regs.R8,0x300);
		/* 820AAAC4h case   15:*/		return 0x820AAAC8;
		  /* 820AAAC8h */ case   16:  		/* cmplw CR6, R11, R8 */
		/* 820AAAC8h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820AAAC8h case   16:*/		return 0x820AAACC;
		  /* 820AAACCh */ case   17:  		/* bc 12, CR6_EQ, 192 */
		/* 820AAACCh case   17:*/		if ( regs.CR[6].eq ) { return 0x820AAB8C;  }
		/* 820AAACCh case   17:*/		return 0x820AAAD0;
		  /* 820AAAD0h */ case   18:  		/* lis R9, 1024 */
		/* 820AAAD0h case   18:*/		cpu::op::lis<0>(regs,&regs.R9,0x400);
		/* 820AAAD0h case   18:*/		return 0x820AAAD4;
		  /* 820AAAD4h */ case   19:  		/* cmplw CR6, R11, R9 */
		/* 820AAAD4h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820AAAD4h case   19:*/		return 0x820AAAD8;
		  /* 820AAAD8h */ case   20:  		/* bc 12, CR6_EQ, 60 */
		/* 820AAAD8h case   20:*/		if ( regs.CR[6].eq ) { return 0x820AAB14;  }
		/* 820AAAD8h case   20:*/		return 0x820AAADC;
		  /* 820AAADCh */ case   21:  		/* lis R8, 1280 */
		/* 820AAADCh case   21:*/		cpu::op::lis<0>(regs,&regs.R8,0x500);
		/* 820AAADCh case   21:*/		return 0x820AAAE0;
		  /* 820AAAE0h */ case   22:  		/* cmplw CR6, R11, R8 */
		/* 820AAAE0h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820AAAE0h case   22:*/		return 0x820AAAE4;
		  /* 820AAAE4h */ case   23:  		/* bc 12, CR6_EQ, 168 */
		/* 820AAAE4h case   23:*/		if ( regs.CR[6].eq ) { return 0x820AAB8C;  }
		/* 820AAAE4h case   23:*/		return 0x820AAAE8;
		  /* 820AAAE8h */ case   24:  		/* lis R10, 1536 */
		/* 820AAAE8h case   24:*/		cpu::op::lis<0>(regs,&regs.R10,0x600);
		/* 820AAAE8h case   24:*/		return 0x820AAAEC;
		  /* 820AAAECh */ case   25:  		/* cmplw CR6, R11, R10 */
		/* 820AAAECh case   25:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AAAECh case   25:*/		return 0x820AAAF0;
		  /* 820AAAF0h */ case   26:  		/* bc 4, CR6_EQ, 160 */
		/* 820AAAF0h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820AAB90;  }
		/* 820AAAF0h case   26:*/		return 0x820AAAF4;
		  /* 820AAAF4h */ case   27:  		/* lis R11, -32255 */
		/* 820AAAF4h case   27:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AAAF4h case   27:*/		return 0x820AAAF8;
		  /* 820AAAF8h */ case   28:  		/* lwz R3, <#[R31]> */
		/* 820AAAF8h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AAAF8h case   28:*/		return 0x820AAAFC;
		  /* 820AAAFCh */ case   29:  		/* li R5, 2013 */
		/* 820AAAFCh case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x7DD);
		/* 820AAAFCh case   29:*/		return 0x820AAB00;
		  /* 820AAB00h */ case   30:  		/* addi R6, R11, 3572 */
		/* 820AAB00h case   30:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xDF4);
		/* 820AAB00h case   30:*/		return 0x820AAB04;
		  /* 820AAB04h */ case   31:  		/* addi R4, R26, 16 */
		/* 820AAB04h case   31:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AAB04h case   31:*/		return 0x820AAB08;
		  /* 820AAB08h */ case   32:  		/* bl -14712 */
		/* 820AAB08h case   32:*/		regs.LR = 0x820AAB0C; return 0x820A7190;
		/* 820AAB08h case   32:*/		return 0x820AAB0C;
		  /* 820AAB0Ch */ case   33:  		/* stw R22, <#[R31 + 84]> */
		/* 820AAB0Ch case   33:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000054) );
		/* 820AAB0Ch case   33:*/		return 0x820AAB10;
		  /* 820AAB10h */ case   34:  		/* b 128 */
		/* 820AAB10h case   34:*/		return 0x820AAB90;
		/* 820AAB10h case   34:*/		return 0x820AAB14;
	}
	return 0x820AAB14;
} // Block from 820AAA88h-820AAB14h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820AAB14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAB14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAB14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAB14);
		  /* 820AAB14h */ case    0:  		/* lis R11, 1280 */
		/* 820AAB14h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x500);
		/* 820AAB14h case    0:*/		return 0x820AAB18;
		  /* 820AAB18h */ case    1:  		/* b 24 */
		/* 820AAB18h case    1:*/		return 0x820AAB30;
		/* 820AAB18h case    1:*/		return 0x820AAB1C;
	}
	return 0x820AAB1C;
} // Block from 820AAB14h-820AAB1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AAB1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAB1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAB1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAB1C);
		  /* 820AAB1Ch */ case    0:  		/* lis R11, 768 */
		/* 820AAB1Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x300);
		/* 820AAB1Ch case    0:*/		return 0x820AAB20;
		  /* 820AAB20h */ case    1:  		/* b 16 */
		/* 820AAB20h case    1:*/		return 0x820AAB30;
		/* 820AAB20h case    1:*/		return 0x820AAB24;
	}
	return 0x820AAB24;
} // Block from 820AAB1Ch-820AAB24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AAB24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAB24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAB24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAB24);
		  /* 820AAB24h */ case    0:  		/* li R11, 0 */
		/* 820AAB24h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820AAB24h case    0:*/		return 0x820AAB28;
		  /* 820AAB28h */ case    1:  		/* b 8 */
		/* 820AAB28h case    1:*/		return 0x820AAB30;
		/* 820AAB28h case    1:*/		return 0x820AAB2C;
	}
	return 0x820AAB2C;
} // Block from 820AAB24h-820AAB2Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AAB2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAB2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAB2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAB2C);
		  /* 820AAB2Ch */ case    0:  		/* lis R11, 256 */
		/* 820AAB2Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x100);
		/* 820AAB2Ch case    0:*/		return 0x820AAB30;
	}
	return 0x820AAB30;
} // Block from 820AAB2Ch-820AAB30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AAB30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAB30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAB30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAB30);
		  /* 820AAB30h */ case    0:  		/* stw R11, <#[R10 + 20]> */
		/* 820AAB30h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 820AAB30h case    0:*/		return 0x820AAB34;
		  /* 820AAB34h */ case    1:  		/* b 92 */
		/* 820AAB34h case    1:*/		return 0x820AAB90;
		/* 820AAB34h case    1:*/		return 0x820AAB38;
	}
	return 0x820AAB38;
} // Block from 820AAB30h-820AAB38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AAB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAB38);
		  /* 820AAB38h */ case    0:  		/* lis R11, 2048 */
		/* 820AAB38h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x800);
		/* 820AAB38h case    0:*/		return 0x820AAB3C;
		  /* 820AAB3Ch */ case    1:  		/* b -12 */
		/* 820AAB3Ch case    1:*/		return 0x820AAB30;
		/* 820AAB3Ch case    1:*/		return 0x820AAB40;
	}
	return 0x820AAB40;
} // Block from 820AAB38h-820AAB40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AAB40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAB40);
		  /* 820AAB40h */ case    0:  		/* lis R8, 2048 */
		/* 820AAB40h case    0:*/		cpu::op::lis<0>(regs,&regs.R8,0x800);
		/* 820AAB40h case    0:*/		return 0x820AAB44;
		  /* 820AAB44h */ case    1:  		/* cmplw CR6, R11, R8 */
		/* 820AAB44h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820AAB44h case    1:*/		return 0x820AAB48;
		  /* 820AAB48h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 820AAB48h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AAB8C;  }
		/* 820AAB48h case    2:*/		return 0x820AAB4C;
		  /* 820AAB4Ch */ case    3:  		/* lis R9, 2304 */
		/* 820AAB4Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x900);
		/* 820AAB4Ch case    3:*/		return 0x820AAB50;
		  /* 820AAB50h */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 820AAB50h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820AAB50h case    4:*/		return 0x820AAB54;
		  /* 820AAB54h */ case    5:  		/* bc 12, CR6_EQ, -96 */
		/* 820AAB54h case    5:*/		if ( regs.CR[6].eq ) { return 0x820AAAF4;  }
		/* 820AAB54h case    5:*/		return 0x820AAB58;
		  /* 820AAB58h */ case    6:  		/* lis R9, 2560 */
		/* 820AAB58h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xA00);
		/* 820AAB58h case    6:*/		return 0x820AAB5C;
		  /* 820AAB5Ch */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 820AAB5Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820AAB5Ch case    7:*/		return 0x820AAB60;
		  /* 820AAB60h */ case    8:  		/* bc 12, CR6_EQ, -108 */
		/* 820AAB60h case    8:*/		if ( regs.CR[6].eq ) { return 0x820AAAF4;  }
		/* 820AAB60h case    8:*/		return 0x820AAB64;
		  /* 820AAB64h */ case    9:  		/* lis R9, 2816 */
		/* 820AAB64h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xB00);
		/* 820AAB64h case    9:*/		return 0x820AAB68;
		  /* 820AAB68h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 820AAB68h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820AAB68h case   10:*/		return 0x820AAB6C;
		  /* 820AAB6Ch */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 820AAB6Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820AAB84;  }
		/* 820AAB6Ch case   11:*/		return 0x820AAB70;
		  /* 820AAB70h */ case   12:  		/* lis R8, 3072 */
		/* 820AAB70h case   12:*/		cpu::op::lis<0>(regs,&regs.R8,0xC00);
		/* 820AAB70h case   12:*/		return 0x820AAB74;
		  /* 820AAB74h */ case   13:  		/* cmplw CR6, R11, R8 */
		/* 820AAB74h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820AAB74h case   13:*/		return 0x820AAB78;
		  /* 820AAB78h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 820AAB78h case   14:*/		if ( regs.CR[6].eq ) { return 0x820AAB8C;  }
		/* 820AAB78h case   14:*/		return 0x820AAB7C;
		  /* 820AAB7Ch */ case   15:  		/* cmplw CR6, R11, R27 */
		/* 820AAB7Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820AAB7Ch case   15:*/		return 0x820AAB80;
		  /* 820AAB80h */ case   16:  		/* b -144 */
		/* 820AAB80h case   16:*/		return 0x820AAAF0;
		/* 820AAB80h case   16:*/		return 0x820AAB84;
	}
	return 0x820AAB84;
} // Block from 820AAB40h-820AAB84h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820AAB84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAB84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAB84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAB84);
		  /* 820AAB84h */ case    0:  		/* lis R11, 3072 */
		/* 820AAB84h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xC00);
		/* 820AAB84h case    0:*/		return 0x820AAB88;
		  /* 820AAB88h */ case    1:  		/* b -88 */
		/* 820AAB88h case    1:*/		return 0x820AAB30;
		/* 820AAB88h case    1:*/		return 0x820AAB8C;
	}
	return 0x820AAB8C;
} // Block from 820AAB84h-820AAB8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AAB8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAB8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAB8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAB8C);
		  /* 820AAB8Ch */ case    0:  		/* stw R9, <#[R10 + 20]> */
		/* 820AAB8Ch case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 820AAB8Ch case    0:*/		return 0x820AAB90;
	}
	return 0x820AAB90;
} // Block from 820AAB8Ch-820AAB90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AAB90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAB90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAB90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAB90);
		  /* 820AAB90h */ case    0:  		/* lwz R11, <#[R26 + 92]> */
		/* 820AAB90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000005C) );
		/* 820AAB90h case    0:*/		return 0x820AAB94;
		  /* 820AAB94h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820AAB94h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AAB94h case    1:*/		return 0x820AAB98;
		  /* 820AAB98h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820AAB98h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AABA0;  }
		/* 820AAB98h case    2:*/		return 0x820AAB9C;
		  /* 820AAB9Ch */ case    3:  		/* oris R30, R30, 16384 */
		/* 820AAB9Ch case    3:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R30,0x4000);
		/* 820AAB9Ch case    3:*/		return 0x820AABA0;
	}
	return 0x820AABA0;
} // Block from 820AAB90h-820AABA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AABA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AABA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AABA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AABA0);
		  /* 820AABA0h */ case    0:  		/* lwz R11, <#[R26 + 72]> */
		/* 820AABA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000048) );
		/* 820AABA0h case    0:*/		return 0x820AABA4;
		  /* 820AABA4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AABA4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AABA4h case    1:*/		return 0x820AABA8;
		  /* 820AABA8h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820AABA8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AABB0;  }
		/* 820AABA8h case    2:*/		return 0x820AABAC;
		  /* 820AABACh */ case    3:  		/* oris R30, R30, 4096 */
		/* 820AABACh case    3:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R30,0x1000);
		/* 820AABACh case    3:*/		return 0x820AABB0;
	}
	return 0x820AABB0;
} // Block from 820AABA0h-820AABB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AABB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AABB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AABB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AABB0);
		  /* 820AABB0h */ case    0:  		/* lwz R11, <#[R31 + 64]> */
		/* 820AABB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820AABB0h case    0:*/		return 0x820AABB4;
		  /* 820AABB4h */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 820AABB4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820AABB4h case    1:*/		return 0x820AABB8;
		  /* 820AABB8h */ case    2:  		/* bc 12, CR6_LT, 12 */
		/* 820AABB8h case    2:*/		if ( regs.CR[6].lt ) { return 0x820AABC4;  }
		/* 820AABB8h case    2:*/		return 0x820AABBC;
		  /* 820AABBCh */ case    3:  		/* cmpwi CR6, R11, 5 */
		/* 820AABBCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 820AABBCh case    3:*/		return 0x820AABC0;
		  /* 820AABC0h */ case    4:  		/* bc 4, CR6_GT, 20 */
		/* 820AABC0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820AABD4;  }
		/* 820AABC0h case    4:*/		return 0x820AABC4;
	}
	return 0x820AABC4;
} // Block from 820AABB0h-820AABC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AABC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AABC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AABC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AABC4);
		  /* 820AABC4h */ case    0:  		/* cmpwi CR6, R11, 10 */
		/* 820AABC4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 820AABC4h case    0:*/		return 0x820AABC8;
		  /* 820AABC8h */ case    1:  		/* bc 12, CR6_LT, 24 */
		/* 820AABC8h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AABE0;  }
		/* 820AABC8h case    1:*/		return 0x820AABCC;
		  /* 820AABCCh */ case    2:  		/* cmpwi CR6, R11, 15 */
		/* 820AABCCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 820AABCCh case    2:*/		return 0x820AABD0;
		  /* 820AABD0h */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 820AABD0h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AABE0;  }
		/* 820AABD0h case    3:*/		return 0x820AABD4;
	}
	return 0x820AABD4;
} // Block from 820AABC4h-820AABD4h (4 instructions)

