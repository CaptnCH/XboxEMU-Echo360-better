#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 82240EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240EB8);
		  /* 82240EB8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82240EB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82240EB8h case    0:*/		return 0x82240EBC;
		  /* 82240EBCh */ case    1:  		/* rlwimi R11, R28, 0, 26, 31 */
		/* 82240EBCh case    1:*/		cpu::op::rlwimi<0,0,26,31>(regs,&regs.R11,regs.R28);
		/* 82240EBCh case    1:*/		return 0x82240EC0;
		  /* 82240EC0h */ case    2:  		/* b 24 */
		/* 82240EC0h case    2:*/		return 0x82240ED8;
		/* 82240EC0h case    2:*/		return 0x82240EC4;
	}
	return 0x82240EC4;
} // Block from 82240EB8h-82240EC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82240EC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240EC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240EC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240EC4);
		  /* 82240EC4h */ case    0:  		/* cmpwi CR6, R3, 1 */
		/* 82240EC4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82240EC4h case    0:*/		return 0x82240EC8;
		  /* 82240EC8h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82240EC8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82240EE0;  }
		/* 82240EC8h case    1:*/		return 0x82240ECC;
	}
	return 0x82240ECC;
} // Block from 82240EC4h-82240ECCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82240ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240ECC);
		  /* 82240ECCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82240ECCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82240ECCh case    0:*/		return 0x82240ED0;
		  /* 82240ED0h */ case    1:  		/* rlwimi R11, R27, 0, 26, 31 */
		/* 82240ED0h case    1:*/		cpu::op::rlwimi<0,0,26,31>(regs,&regs.R11,regs.R27);
		/* 82240ED0h case    1:*/		return 0x82240ED4;
		  /* 82240ED4h */ case    2:  		/* ori R11, R11, 64 */
		/* 82240ED4h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82240ED4h case    2:*/		return 0x82240ED8;
	}
	return 0x82240ED8;
} // Block from 82240ECCh-82240ED8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82240ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240ED8);
		  /* 82240ED8h */ case    0:  		/* stw R11, <#[R31]> */
		/* 82240ED8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82240ED8h case    0:*/		return 0x82240EDC;
		  /* 82240EDCh */ case    1:  		/* b 28 */
		/* 82240EDCh case    1:*/		return 0x82240EF8;
		/* 82240EDCh case    1:*/		return 0x82240EE0;
	}
	return 0x82240EE0;
} // Block from 82240ED8h-82240EE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82240EE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240EE0);
		  /* 82240EE0h */ case    0:  		/* li R7, 2451 */
		/* 82240EE0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x993);
		/* 82240EE0h case    0:*/		return 0x82240EE4;
	}
	return 0x82240EE4;
} // Block from 82240EE0h-82240EE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82240EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240EE4);
		  /* 82240EE4h */ case    0:  		/* mr R6, R21 */
		/* 82240EE4h case    0:*/		regs.R6 = regs.R21;
		/* 82240EE4h case    0:*/		return 0x82240EE8;
		  /* 82240EE8h */ case    1:  		/* mr R5, R19 */
		/* 82240EE8h case    1:*/		regs.R5 = regs.R19;
		/* 82240EE8h case    1:*/		return 0x82240EEC;
		  /* 82240EECh */ case    2:  		/* mr R4, R22 */
		/* 82240EECh case    2:*/		regs.R4 = regs.R22;
		/* 82240EECh case    2:*/		return 0x82240EF0;
		  /* 82240EF0h */ case    3:  		/* li R3, 0 */
		/* 82240EF0h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82240EF0h case    3:*/		return 0x82240EF4;
		  /* 82240EF4h */ case    4:  		/* bl -955116 */
		/* 82240EF4h case    4:*/		regs.LR = 0x82240EF8; return 0x82157C08;
		/* 82240EF4h case    4:*/		return 0x82240EF8;
	}
	return 0x82240EF8;
} // Block from 82240EE4h-82240EF8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82240EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240EF8);
		  /* 82240EF8h */ case    0:  		/* addi R1, R1, 208 */
		/* 82240EF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 82240EF8h case    0:*/		return 0x82240EFC;
		  /* 82240EFCh */ case    1:  		/* b -1768568 */
		/* 82240EFCh case    1:*/		return 0x82091284;
		/* 82240EFCh case    1:*/		return 0x82240F00;
	}
	return 0x82240F00;
} // Block from 82240EF8h-82240F00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82240F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240F00);
		  /* 82240F00h */ case    0:  		/* mfspr R12, LR */
		/* 82240F00h case    0:*/		regs.R12 = regs.LR;
		/* 82240F00h case    0:*/		return 0x82240F04;
		  /* 82240F04h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82240F04h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82240F04h case    1:*/		return 0x82240F08;
		  /* 82240F08h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82240F08h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82240F08h case    2:*/		return 0x82240F0C;
		  /* 82240F0Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82240F0Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82240F0Ch case    3:*/		return 0x82240F10;
		  /* 82240F10h */ case    4:  		/* mr R31, R4 */
		/* 82240F10h case    4:*/		regs.R31 = regs.R4;
		/* 82240F10h case    4:*/		return 0x82240F14;
		  /* 82240F14h */ case    5:  		/* lwz R4, <#[R3 + 952]> */
		/* 82240F14h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x000003B8) );
		/* 82240F14h case    5:*/		return 0x82240F18;
		  /* 82240F18h */ case    6:  		/* lwz R3, <#[R3 + 80]> */
		/* 82240F18h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000050) );
		/* 82240F18h case    6:*/		return 0x82240F1C;
		  /* 82240F1Ch */ case    7:  		/* bl 88596 */
		/* 82240F1Ch case    7:*/		regs.LR = 0x82240F20; return 0x82256930;
		/* 82240F1Ch case    7:*/		return 0x82240F20;
		  /* 82240F20h */ case    8:  		/* cmpwi CR6, R3, 4 */
		/* 82240F20h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 82240F20h case    8:*/		return 0x82240F24;
		  /* 82240F24h */ case    9:  		/* bc 12, CR6_EQ, 64 */
		/* 82240F24h case    9:*/		if ( regs.CR[6].eq ) { return 0x82240F64;  }
		/* 82240F24h case    9:*/		return 0x82240F28;
		  /* 82240F28h */ case   10:  		/* bc 4, CR6_GT, 52 */
		/* 82240F28h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82240F5C;  }
		/* 82240F28h case   10:*/		return 0x82240F2C;
		  /* 82240F2Ch */ case   11:  		/* cmpwi CR6, R3, 6 */
		/* 82240F2Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000006);
		/* 82240F2Ch case   11:*/		return 0x82240F30;
		  /* 82240F30h */ case   12:  		/* bc 4, CR6_GT, 36 */
		/* 82240F30h case   12:*/		if ( !regs.CR[6].gt ) { return 0x82240F54;  }
		/* 82240F30h case   12:*/		return 0x82240F34;
		  /* 82240F34h */ case   13:  		/* cmpwi CR6, R3, 8 */
		/* 82240F34h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000008);
		/* 82240F34h case   13:*/		return 0x82240F38;
		  /* 82240F38h */ case   14:  		/* bc 12, CR6_GT, 36 */
		/* 82240F38h case   14:*/		if ( regs.CR[6].gt ) { return 0x82240F5C;  }
		/* 82240F38h case   14:*/		return 0x82240F3C;
		  /* 82240F3Ch */ case   15:  		/* lwz R10, <#[R31 + 112]> */
		/* 82240F3Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000070) );
		/* 82240F3Ch case   15:*/		return 0x82240F40;
		  /* 82240F40h */ case   16:  		/* lwz R11, <#[R31 + 2096]> */
		/* 82240F40h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000830) );
		/* 82240F40h case   16:*/		return 0x82240F44;
		  /* 82240F44h */ case   17:  		/* addic R9, R10, -1 */
		/* 82240F44h case   17:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 82240F44h case   17:*/		return 0x82240F48;
		  /* 82240F48h */ case   18:  		/* subfe R10, R9, R10 */
		/* 82240F48h case   18:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82240F48h case   18:*/		return 0x82240F4C;
		  /* 82240F4Ch */ case   19:  		/* add R3, R10, R11 */
		/* 82240F4Ch case   19:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82240F4Ch case   19:*/		return 0x82240F50;
		  /* 82240F50h */ case   20:  		/* b 28 */
		/* 82240F50h case   20:*/		return 0x82240F6C;
		/* 82240F50h case   20:*/		return 0x82240F54;
	}
	return 0x82240F54;
} // Block from 82240F00h-82240F54h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82240F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240F54);
		  /* 82240F54h */ case    0:  		/* lwz R11, <#[R31 + 2088]> */
		/* 82240F54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000828) );
		/* 82240F54h case    0:*/		return 0x82240F58;
		  /* 82240F58h */ case    1:  		/* b 16 */
		/* 82240F58h case    1:*/		return 0x82240F68;
		/* 82240F58h case    1:*/		return 0x82240F5C;
	}
	return 0x82240F5C;
} // Block from 82240F54h-82240F5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82240F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240F5C);
		  /* 82240F5Ch */ case    0:  		/* li R3, 0 */
		/* 82240F5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82240F5Ch case    0:*/		return 0x82240F60;
		  /* 82240F60h */ case    1:  		/* b 12 */
		/* 82240F60h case    1:*/		return 0x82240F6C;
		/* 82240F60h case    1:*/		return 0x82240F64;
	}
	return 0x82240F64;
} // Block from 82240F5Ch-82240F64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82240F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240F64);
		  /* 82240F64h */ case    0:  		/* lwz R11, <#[R31 + 2084]> */
		/* 82240F64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000824) );
		/* 82240F64h case    0:*/		return 0x82240F68;
	}
	return 0x82240F68;
} // Block from 82240F64h-82240F68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82240F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240F68);
		  /* 82240F68h */ case    0:  		/* addi R3, R11, -1 */
		/* 82240F68h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 82240F68h case    0:*/		return 0x82240F6C;
	}
	return 0x82240F6C;
} // Block from 82240F68h-82240F6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82240F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240F6C);
		  /* 82240F6Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 82240F6Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82240F6Ch case    0:*/		return 0x82240F70;
		  /* 82240F70h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82240F70h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82240F70h case    1:*/		return 0x82240F74;
		  /* 82240F74h */ case    2:  		/* mtspr LR, R12 */
		/* 82240F74h case    2:*/		regs.LR = regs.R12;
		/* 82240F74h case    2:*/		return 0x82240F78;
		  /* 82240F78h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82240F78h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82240F78h case    3:*/		return 0x82240F7C;
		  /* 82240F7Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 82240F7Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82240F7Ch case    4:*/		return 0x82240F80;
	}
	return 0x82240F80;
} // Block from 82240F6Ch-82240F80h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82240F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240F80);
		  /* 82240F80h */ case    0:  		/* mfspr R12, LR */
		/* 82240F80h case    0:*/		regs.R12 = regs.LR;
		/* 82240F80h case    0:*/		return 0x82240F84;
		  /* 82240F84h */ case    1:  		/* bl -1768752 */
		/* 82240F84h case    1:*/		regs.LR = 0x82240F88; return 0x82091254;
		/* 82240F84h case    1:*/		return 0x82240F88;
		  /* 82240F88h */ case    2:  		/* stfd FR29, <#[R1 - 72]> */
		/* 82240F88h case    2:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 82240F88h case    2:*/		return 0x82240F8C;
		  /* 82240F8Ch */ case    3:  		/* stfd FR30, <#[R1 - 64]> */
		/* 82240F8Ch case    3:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 82240F8Ch case    3:*/		return 0x82240F90;
		  /* 82240F90h */ case    4:  		/* stfd FR31, <#[R1 - 56]> */
		/* 82240F90h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 82240F90h case    4:*/		return 0x82240F94;
		  /* 82240F94h */ case    5:  		/* stwu R1, <#[R1 - 208]> */
		/* 82240F94h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 82240F94h case    5:*/		return 0x82240F98;
		  /* 82240F98h */ case    6:  		/* lwz R10, <#[R4 + 4]> */
		/* 82240F98h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 82240F98h case    6:*/		return 0x82240F9C;
		  /* 82240F9Ch */ case    7:  		/* li R9, 12 */
		/* 82240F9Ch case    7:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 82240F9Ch case    7:*/		return 0x82240FA0;
		  /* 82240FA0h */ case    8:  		/* lwz R11, <#[R4 + 52]> */
		/* 82240FA0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000034) );
		/* 82240FA0h case    8:*/		return 0x82240FA4;
		  /* 82240FA4h */ case    9:  		/* mr R29, R3 */
		/* 82240FA4h case    9:*/		regs.R29 = regs.R3;
		/* 82240FA4h case    9:*/		return 0x82240FA8;
		  /* 82240FA8h */ case   10:  		/* subf R10, R10, R5 */
		/* 82240FA8h case   10:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 82240FA8h case   10:*/		return 0x82240FAC;
		  /* 82240FACh */ case   11:  		/* lwz R30, <#[R3 + 184]> */
		/* 82240FACh case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x000000B8) );
		/* 82240FACh case   11:*/		return 0x82240FB0;
		  /* 82240FB0h */ case   12:  		/* mr R31, R5 */
		/* 82240FB0h case   12:*/		regs.R31 = regs.R5;
		/* 82240FB0h case   12:*/		return 0x82240FB4;
		  /* 82240FB4h */ case   13:  		/* divw R10, R10, R9 */
		/* 82240FB4h case   13:*/		cpu::op::divw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82240FB4h case   13:*/		return 0x82240FB8;
		  /* 82240FB8h */ case   14:  		/* mr R28, R6 */
		/* 82240FB8h case   14:*/		regs.R28 = regs.R6;
		/* 82240FB8h case   14:*/		return 0x82240FBC;
		  /* 82240FBCh */ case   15:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82240FBCh case   15:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82240FBCh case   15:*/		return 0x82240FC0;
		  /* 82240FC0h */ case   16:  		/* add R11, R10, R11 */
		/* 82240FC0h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82240FC0h case   16:*/		return 0x82240FC4;
		  /* 82240FC4h */ case   17:  		/* lwz R10, <#[R11]> */
		/* 82240FC4h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82240FC4h case   17:*/		return 0x82240FC8;
		  /* 82240FC8h */ case   18:  		/* cmplwi CR6, R10, 0 */
		/* 82240FC8h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82240FC8h case   18:*/		return 0x82240FCC;
		  /* 82240FCCh */ case   19:  		/* bc 4, CR6_EQ, 12 */
		/* 82240FCCh case   19:*/		if ( !regs.CR[6].eq ) { return 0x82240FD8;  }
		/* 82240FCCh case   19:*/		return 0x82240FD0;
		  /* 82240FD0h */ case   20:  		/* stw R3, <#[R11]> */
		/* 82240FD0h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 82240FD0h case   20:*/		return 0x82240FD4;
		  /* 82240FD4h */ case   21:  		/* b 8 */
		/* 82240FD4h case   21:*/		return 0x82240FDC;
		/* 82240FD4h case   21:*/		return 0x82240FD8;
	}
	return 0x82240FD8;
} // Block from 82240F80h-82240FD8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82240FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240FD8);
		  /* 82240FD8h */ case    0:  		/* stw R29, <#[R11 + 4]> */
		/* 82240FD8h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 82240FD8h case    0:*/		return 0x82240FDC;
	}
	return 0x82240FDC;
} // Block from 82240FD8h-82240FDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82240FDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82240FDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82240FDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82240FDC);
		  /* 82240FDCh */ case    0:  		/* lis R11, -32222 */
		/* 82240FDCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 82240FDCh case    0:*/		return 0x82240FE0;
		  /* 82240FE0h */ case    1:  		/* lwz R4, <#[R29 + 176]> */
		/* 82240FE0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000000B0) );
		/* 82240FE0h case    1:*/		return 0x82240FE4;
		  /* 82240FE4h */ case    2:  		/* mr R7, R28 */
		/* 82240FE4h case    2:*/		regs.R7 = regs.R28;
		/* 82240FE4h case    2:*/		return 0x82240FE8;
		  /* 82240FE8h */ case    3:  		/* lwz R3, <#[R28 + 1536]> */
		/* 82240FE8h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000600) );
		/* 82240FE8h case    3:*/		return 0x82240FEC;
		  /* 82240FECh */ case    4:  		/* addi R6, R11, -12392 */
		/* 82240FECh case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 82240FECh case    4:*/		return 0x82240FF0;
		  /* 82240FF0h */ case    5:  		/* addi R5, R1, 96 */
		/* 82240FF0h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82240FF0h case    5:*/		return 0x82240FF4;
		  /* 82240FF4h */ case    6:  		/* bl -59388 */
		/* 82240FF4h case    6:*/		regs.LR = 0x82240FF8; return 0x822327F8;
		/* 82240FF4h case    6:*/		return 0x82240FF8;
		  /* 82240FF8h */ case    7:  		/* lwz R10, <#[R29 + 24]> */
		/* 82240FF8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 82240FF8h case    7:*/		return 0x82240FFC;
		  /* 82240FFCh */ case    8:  		/* lis R11, -32252 */
		/* 82240FFCh case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82240FFCh case    8:*/		return 0x82241000;
		  /* 82241000h */ case    9:  		/* lwz R9, <#[R31]> */
		/* 82241000h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82241000h case    9:*/		return 0x82241004;
		  /* 82241004h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82241004h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82241004h case   10:*/		return 0x82241008;
		  /* 82241008h */ case   11:  		/* addi R11, R11, 25976 */
		/* 82241008h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6578);
		/* 82241008h case   11:*/		return 0x8224100C;
		  /* 8224100Ch */ case   12:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8224100Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224100Ch case   12:*/		return 0x82241010;
		  /* 82241010h */ case   13:  		/* rlwimi R11, R9, 0, 0, 26 */
		/* 82241010h case   13:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R11,regs.R9);
		/* 82241010h case   13:*/		return 0x82241014;
		  /* 82241014h */ case   14:  		/* stw R11, <#[R31]> */
		/* 82241014h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82241014h case   14:*/		return 0x82241018;
		  /* 82241018h */ case   15:  		/* lwz R3, <#[R28 + 2736]> */
		/* 82241018h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000AB0) );
		/* 82241018h case   15:*/		return 0x8224101C;
		  /* 8224101Ch */ case   16:  		/* lwz R4, <#[R29 + 236]> */
		/* 8224101Ch case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000000EC) );
		/* 8224101Ch case   16:*/		return 0x82241020;
		  /* 82241020h */ case   17:  		/* bl 144328 */
		/* 82241020h case   17:*/		regs.LR = 0x82241024; return 0x822643E8;
		/* 82241020h case   17:*/		return 0x82241024;
		  /* 82241024h */ case   18:  		/* lwz R11, <#[R31]> */
		/* 82241024h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82241024h case   18:*/		return 0x82241028;
		  /* 82241028h */ case   19:  		/* rlwimi R11, R3, 5, 21, 26 */
		/* 82241028h case   19:*/		cpu::op::rlwimi<0,5,21,26>(regs,&regs.R11,regs.R3);
		/* 82241028h case   19:*/		return 0x8224102C;
		  /* 8224102Ch */ case   20:  		/* mr R4, R29 */
		/* 8224102Ch case   20:*/		regs.R4 = regs.R29;
		/* 8224102Ch case   20:*/		return 0x82241030;
		  /* 82241030h */ case   21:  		/* mr R10, R11 */
		/* 82241030h case   21:*/		regs.R10 = regs.R11;
		/* 82241030h case   21:*/		return 0x82241034;
		  /* 82241034h */ case   22:  		/* stw R11, <#[R31]> */
		/* 82241034h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82241034h case   22:*/		return 0x82241038;
		  /* 82241038h */ case   23:  		/* lwz R11, <#[R29 + 108]> */
		/* 82241038h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000006C) );
		/* 82241038h case   23:*/		return 0x8224103C;
		  /* 8224103Ch */ case   24:  		/* rlwimi R10, R11, 11, 20, 20 */
		/* 8224103Ch case   24:*/		cpu::op::rlwimi<0,11,20,20>(regs,&regs.R10,regs.R11);
		/* 8224103Ch case   24:*/		return 0x82241040;
		  /* 82241040h */ case   25:  		/* stw R10, <#[R31]> */
		/* 82241040h case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82241040h case   25:*/		return 0x82241044;
		  /* 82241044h */ case   26:  		/* lwz R3, <#[R28 + 2736]> */
		/* 82241044h case   26:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000AB0) );
		/* 82241044h case   26:*/		return 0x82241048;
		  /* 82241048h */ case   27:  		/* bl 144288 */
		/* 82241048h case   27:*/		regs.LR = 0x8224104C; return 0x822643E8;
		/* 82241048h case   27:*/		return 0x8224104C;
		  /* 8224104Ch */ case   28:  		/* lwz R11, <#[R31]> */
		/* 8224104Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224104Ch case   28:*/		return 0x82241050;
		  /* 82241050h */ case   29:  		/* rlwimi R11, R3, 12, 14, 19 */
		/* 82241050h case   29:*/		cpu::op::rlwimi<0,12,14,19>(regs,&regs.R11,regs.R3);
		/* 82241050h case   29:*/		return 0x82241054;
		  /* 82241054h */ case   30:  		/* lwz R10, <#[R1 + 96]> */
		/* 82241054h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82241054h case   30:*/		return 0x82241058;
		  /* 82241058h */ case   31:  		/* stw R11, <#[R31]> */
		/* 82241058h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82241058h case   31:*/		return 0x8224105C;
		  /* 8224105Ch */ case   32:  		/* lwz R9, <#[R29 + 104]> */
		/* 8224105Ch case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000068) );
		/* 8224105Ch case   32:*/		return 0x82241060;
		  /* 82241060h */ case   33:  		/* rlwimi R9, R10, 1, 30, 30 */
		/* 82241060h case   33:*/		cpu::op::rlwimi<0,1,30,30>(regs,&regs.R9,regs.R10);
		/* 82241060h case   33:*/		return 0x82241064;
		  /* 82241064h */ case   34:  		/* rlwimi R11, R9, 18, 12, 13 */
		/* 82241064h case   34:*/		cpu::op::rlwimi<0,18,12,13>(regs,&regs.R11,regs.R9);
		/* 82241064h case   34:*/		return 0x82241068;
		  /* 82241068h */ case   35:  		/* stw R11, <#[R31]> */
		/* 82241068h case   35:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82241068h case   35:*/		return 0x8224106C;
		  /* 8224106Ch */ case   36:  		/* mr R10, R11 */
		/* 8224106Ch case   36:*/		regs.R10 = regs.R11;
		/* 8224106Ch case   36:*/		return 0x82241070;
		  /* 82241070h */ case   37:  		/* lwz R10, <#[R29 + 172]> */
		/* 82241070h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x000000AC) );
		/* 82241070h case   37:*/		return 0x82241074;
		  /* 82241074h */ case   38:  		/* rlwimi R11, R10, 20, 7, 11 */
		/* 82241074h case   38:*/		cpu::op::rlwimi<0,20,7,11>(regs,&regs.R11,regs.R10);
		/* 82241074h case   38:*/		return 0x82241078;
		  /* 82241078h */ case   39:  		/* stw R11, <#[R31]> */
		/* 82241078h case   39:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82241078h case   39:*/		return 0x8224107C;
		  /* 8224107Ch */ case   40:  		/* lwz R10, <#[R29 + 180]> */
		/* 8224107Ch case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x000000B4) );
		/* 8224107Ch case   40:*/		return 0x82241080;
		  /* 82241080h */ case   41:  		/* cmpwi CR6, R10, 0 */
		/* 82241080h case   41:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82241080h case   41:*/		return 0x82241084;
		  /* 82241084h */ case   42:  		/* bc 4, CR6_EQ, 12 */
		/* 82241084h case   42:*/		if ( !regs.CR[6].eq ) { return 0x82241090;  }
		/* 82241084h case   42:*/		return 0x82241088;
		  /* 82241088h */ case   43:  		/* rlwinm R11, R11, 0, 7, 5 */
		/* 82241088h case   43:*/		cpu::op::rlwinm<0,0,7,5>(regs,&regs.R11,regs.R11);
		/* 82241088h case   43:*/		return 0x8224108C;
		  /* 8224108Ch */ case   44:  		/* b 28 */
		/* 8224108Ch case   44:*/		return 0x822410A8;
		/* 8224108Ch case   44:*/		return 0x82241090;
	}
	return 0x82241090;
} // Block from 82240FDCh-82241090h (45 instructions)

//////////////////////////////////////////////////////
// Block at 82241090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241090);
		  /* 82241090h */ case    0:  		/* cmpwi CR6, R10, 1 */
		/* 82241090h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 82241090h case    0:*/		return 0x82241094;
		  /* 82241094h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82241094h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822410A0;  }
		/* 82241094h case    1:*/		return 0x82241098;
		  /* 82241098h */ case    2:  		/* oris R11, R11, 512 */
		/* 82241098h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82241098h case    2:*/		return 0x8224109C;
		  /* 8224109Ch */ case    3:  		/* b 12 */
		/* 8224109Ch case    3:*/		return 0x822410A8;
		/* 8224109Ch case    3:*/		return 0x822410A0;
	}
	return 0x822410A0;
} // Block from 82241090h-822410A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822410A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822410A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822410A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822410A0);
		  /* 822410A0h */ case    0:  		/* lwz R10, <#[R1 + 100]> */
		/* 822410A0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 822410A0h case    0:*/		return 0x822410A4;
		  /* 822410A4h */ case    1:  		/* rlwimi R11, R10, 25, 6, 6 */
		/* 822410A4h case    1:*/		cpu::op::rlwimi<0,25,6,6>(regs,&regs.R11,regs.R10);
		/* 822410A4h case    1:*/		return 0x822410A8;
	}
	return 0x822410A8;
} // Block from 822410A0h-822410A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822410A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822410A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822410A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822410A8);
		  /* 822410A8h */ case    0:  		/* stw R11, <#[R31]> */
		/* 822410A8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822410A8h case    0:*/		return 0x822410AC;
		  /* 822410ACh */ case    1:  		/* lbz R11, <#[R29 + 132]> */
		/* 822410ACh case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000084) );
		/* 822410ACh case    1:*/		return 0x822410B0;
	}
	return 0x822410B0;
} // Block from 822410A8h-822410B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822410B0h
// Function '?KorrectSwizzle@XGRAPHICS@@YAXPAVIRInst@1@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822410B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822410B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822410B0);
		  /* 822410B0h */ case    0:  		/* lwz R10, <#[R31]> */
		/* 822410B0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822410B0h case    0:*/		return 0x822410B4;
		  /* 822410B4h */ case    1:  		/* rlwimi R10, R11, 26, 4, 5 */
		/* 822410B4h case    1:*/		cpu::op::rlwimi<0,26,4,5>(regs,&regs.R10,regs.R11);
		/* 822410B4h case    1:*/		return 0x822410B8;
		  /* 822410B8h */ case    2:  		/* mr R11, R10 */
		/* 822410B8h case    2:*/		regs.R11 = regs.R10;
		/* 822410B8h case    2:*/		return 0x822410BC;
		  /* 822410BCh */ case    3:  		/* stw R10, <#[R31]> */
		/* 822410BCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822410BCh case    3:*/		return 0x822410C0;
		  /* 822410C0h */ case    4:  		/* lbz R10, <#[R29 + 133]> */
		/* 822410C0h case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000085) );
		/* 822410C0h case    4:*/		return 0x822410C4;
		  /* 822410C4h */ case    5:  		/* rlwimi R11, R10, 28, 2, 3 */
		/* 822410C4h case    5:*/		cpu::op::rlwimi<0,28,2,3>(regs,&regs.R11,regs.R10);
		/* 822410C4h case    5:*/		return 0x822410C8;
		  /* 822410C8h */ case    6:  		/* stw R11, <#[R31]> */
		/* 822410C8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822410C8h case    6:*/		return 0x822410CC;
		  /* 822410CCh */ case    7:  		/* mr R10, R11 */
		/* 822410CCh case    7:*/		regs.R10 = regs.R11;
		/* 822410CCh case    7:*/		return 0x822410D0;
		  /* 822410D0h */ case    8:  		/* lbz R11, <#[R29 + 134]> */
		/* 822410D0h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000086) );
		/* 822410D0h case    8:*/		return 0x822410D4;
		  /* 822410D4h */ case    9:  		/* rlwimi R10, R11, 30, 0, 1 */
		/* 822410D4h case    9:*/		cpu::op::rlwimi<0,30,0,1>(regs,&regs.R10,regs.R11);
		/* 822410D4h case    9:*/		return 0x822410D8;
		  /* 822410D8h */ case   10:  		/* stw R10, <#[R31]> */
		/* 822410D8h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822410D8h case   10:*/		return 0x822410DC;
		  /* 822410DCh */ case   11:  		/* lwz R11, <#[R29 + 24]> */
		/* 822410DCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 822410DCh case   11:*/		return 0x822410E0;
		  /* 822410E0h */ case   12:  		/* cmpwi CR6, R11, 113 */
		/* 822410E0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000071);
		/* 822410E0h case   12:*/		return 0x822410E4;
		  /* 822410E4h */ case   13:  		/* bc 12, CR6_EQ, 136 */
		/* 822410E4h case   13:*/		if ( regs.CR[6].eq ) { return 0x8224116C;  }
		/* 822410E4h case   13:*/		return 0x822410E8;
		  /* 822410E8h */ case   14:  		/* cmpwi CR6, R11, 114 */
		/* 822410E8h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000072);
		/* 822410E8h case   14:*/		return 0x822410EC;
		  /* 822410ECh */ case   15:  		/* bc 12, CR6_EQ, 128 */
		/* 822410ECh case   15:*/		if ( regs.CR[6].eq ) { return 0x8224116C;  }
		/* 822410ECh case   15:*/		return 0x822410F0;
		  /* 822410F0h */ case   16:  		/* cmpwi CR6, R11, 115 */
		/* 822410F0h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000073);
		/* 822410F0h case   16:*/		return 0x822410F4;
		  /* 822410F4h */ case   17:  		/* bc 12, CR6_EQ, 120 */
		/* 822410F4h case   17:*/		if ( regs.CR[6].eq ) { return 0x8224116C;  }
		/* 822410F4h case   17:*/		return 0x822410F8;
		  /* 822410F8h */ case   18:  		/* cmpwi CR6, R11, 116 */
		/* 822410F8h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000074);
		/* 822410F8h case   18:*/		return 0x822410FC;
		  /* 822410FCh */ case   19:  		/* bc 12, CR6_EQ, 112 */
		/* 822410FCh case   19:*/		if ( regs.CR[6].eq ) { return 0x8224116C;  }
		/* 822410FCh case   19:*/		return 0x82241100;
		  /* 82241100h */ case   20:  		/* li R3, 0 */
		/* 82241100h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82241100h case   20:*/		return 0x82241104;
		  /* 82241104h */ case   21:  		/* lbz R4, <#[R29 + 128]> */
		/* 82241104h case   21:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000080) );
		/* 82241104h case   21:*/		return 0x82241108;
		  /* 82241108h */ case   22:  		/* bl -10344 */
		/* 82241108h case   22:*/		regs.LR = 0x8224110C; return 0x8223E8A0;
		/* 82241108h case   22:*/		return 0x8224110C;
		  /* 8224110Ch */ case   23:  		/* lwz R11, <#[R31 + 4]> */
		/* 8224110Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224110Ch case   23:*/		return 0x82241110;
		  /* 82241110h */ case   24:  		/* mr R10, R3 */
		/* 82241110h case   24:*/		regs.R10 = regs.R3;
		/* 82241110h case   24:*/		return 0x82241114;
		  /* 82241114h */ case   25:  		/* li R3, 1 */
		/* 82241114h case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82241114h case   25:*/		return 0x82241118;
		  /* 82241118h */ case   26:  		/* rlwimi R11, R10, 0, 29, 31 */
		/* 82241118h case   26:*/		cpu::op::rlwimi<0,0,29,31>(regs,&regs.R11,regs.R10);
		/* 82241118h case   26:*/		return 0x8224111C;
		  /* 8224111Ch */ case   27:  		/* stw R11, <#[R31 + 4]> */
		/* 8224111Ch case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224111Ch case   27:*/		return 0x82241120;
		  /* 82241120h */ case   28:  		/* lbz R4, <#[R29 + 129]> */
		/* 82241120h case   28:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000081) );
		/* 82241120h case   28:*/		return 0x82241124;
		  /* 82241124h */ case   29:  		/* bl -10372 */
		/* 82241124h case   29:*/		regs.LR = 0x82241128; return 0x8223E8A0;
		/* 82241124h case   29:*/		return 0x82241128;
		  /* 82241128h */ case   30:  		/* lwz R11, <#[R31 + 4]> */
		/* 82241128h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82241128h case   30:*/		return 0x8224112C;
		  /* 8224112Ch */ case   31:  		/* mr R10, R3 */
		/* 8224112Ch case   31:*/		regs.R10 = regs.R3;
		/* 8224112Ch case   31:*/		return 0x82241130;
		  /* 82241130h */ case   32:  		/* li R3, 2 */
		/* 82241130h case   32:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82241130h case   32:*/		return 0x82241134;
		  /* 82241134h */ case   33:  		/* rlwimi R11, R10, 3, 26, 28 */
		/* 82241134h case   33:*/		cpu::op::rlwimi<0,3,26,28>(regs,&regs.R11,regs.R10);
		/* 82241134h case   33:*/		return 0x82241138;
		  /* 82241138h */ case   34:  		/* stw R11, <#[R31 + 4]> */
		/* 82241138h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82241138h case   34:*/		return 0x8224113C;
		  /* 8224113Ch */ case   35:  		/* lbz R4, <#[R29 + 130]> */
		/* 8224113Ch case   35:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000082) );
		/* 8224113Ch case   35:*/		return 0x82241140;
		  /* 82241140h */ case   36:  		/* bl -10400 */
		/* 82241140h case   36:*/		regs.LR = 0x82241144; return 0x8223E8A0;
		/* 82241140h case   36:*/		return 0x82241144;
		  /* 82241144h */ case   37:  		/* lwz R11, <#[R31 + 4]> */
		/* 82241144h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82241144h case   37:*/		return 0x82241148;
		  /* 82241148h */ case   38:  		/* mr R10, R3 */
		/* 82241148h case   38:*/		regs.R10 = regs.R3;
		/* 82241148h case   38:*/		return 0x8224114C;
		  /* 8224114Ch */ case   39:  		/* li R3, 3 */
		/* 8224114Ch case   39:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 8224114Ch case   39:*/		return 0x82241150;
		  /* 82241150h */ case   40:  		/* rlwimi R11, R10, 6, 23, 25 */
		/* 82241150h case   40:*/		cpu::op::rlwimi<0,6,23,25>(regs,&regs.R11,regs.R10);
		/* 82241150h case   40:*/		return 0x82241154;
		  /* 82241154h */ case   41:  		/* stw R11, <#[R31 + 4]> */
		/* 82241154h case   41:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82241154h case   41:*/		return 0x82241158;
		  /* 82241158h */ case   42:  		/* lbz R4, <#[R29 + 131]> */
		/* 82241158h case   42:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000083) );
		/* 82241158h case   42:*/		return 0x8224115C;
		  /* 8224115Ch */ case   43:  		/* bl -10428 */
		/* 8224115Ch case   43:*/		regs.LR = 0x82241160; return 0x8223E8A0;
		/* 8224115Ch case   43:*/		return 0x82241160;
		  /* 82241160h */ case   44:  		/* lwz R11, <#[R31 + 4]> */
		/* 82241160h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82241160h case   44:*/		return 0x82241164;
		  /* 82241164h */ case   45:  		/* rlwimi R11, R3, 9, 20, 22 */
		/* 82241164h case   45:*/		cpu::op::rlwimi<0,9,20,22>(regs,&regs.R11,regs.R3);
		/* 82241164h case   45:*/		return 0x82241168;
		  /* 82241168h */ case   46:  		/* b 12 */
		/* 82241168h case   46:*/		return 0x82241174;
		/* 82241168h case   46:*/		return 0x8224116C;
	}
	return 0x8224116C;
} // Block from 822410B0h-8224116Ch (47 instructions)

//////////////////////////////////////////////////////
// Block at 8224116Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224116C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224116C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224116C);
		  /* 8224116Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8224116Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224116Ch case    0:*/		return 0x82241170;
		  /* 82241170h */ case    1:  		/* ori R11, R11, 4095 */
		/* 82241170h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFF);
		/* 82241170h case    1:*/		return 0x82241174;
	}
	return 0x82241174;
} // Block from 8224116Ch-82241174h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82241174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241174);
		  /* 82241174h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 82241174h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82241174h case    0:*/		return 0x82241178;
	}
	return 0x82241178;
} // Block from 82241174h-82241178h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82241178h
// Function '?AssembleSrcRegConst@IRAlu@XGRAPHICS@@IAAXPADHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241178);
		  /* 82241178h */ case    0:  		/* lis R8, -32254 */
		/* 82241178h case    0:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8202);
		/* 82241178h case    0:*/		return 0x8224117C;
		  /* 8224117Ch */ case    1:  		/* lis R10, -32256 */
		/* 8224117Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8224117Ch case    1:*/		return 0x82241180;
		  /* 82241180h */ case    2:  		/* lwz R7, <#[R31 + 8]> */
		/* 82241180h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 82241180h case    2:*/		return 0x82241184;
		  /* 82241184h */ case    3:  		/* lis R6, -32256 */
		/* 82241184h case    3:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8200);
		/* 82241184h case    3:*/		return 0x82241188;
		  /* 82241188h */ case    4:  		/* lfs FR29, <#[R8 - 16100]> */
		/* 82241188h case    4:*/		cpu::mem::load32f( regs, &regs.FR29, (uint32)(regs.R8 + 0xFFFFC11C) );
		/* 82241188h case    4:*/		return 0x8224118C;
		  /* 8224118Ch */ case    5:  		/* lfs FR31, <#[R10 + 1816]> */
		/* 8224118Ch case    5:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000718) );
		/* 8224118Ch case    5:*/		return 0x82241190;
		  /* 82241190h */ case    6:  		/* lis R10, -32252 */
		/* 82241190h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82241190h case    6:*/		return 0x82241194;
		  /* 82241194h */ case    7:  		/* lfs FR30, <#[R6 + 1820]> */
		/* 82241194h case    7:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R6 + 0x0000071C) );
		/* 82241194h case    7:*/		return 0x82241198;
		  /* 82241198h */ case    8:  		/* addi R27, R10, 10344 */
		/* 82241198h case    8:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R10,0x2868);
		/* 82241198h case    8:*/		return 0x8224119C;
		  /* 8224119Ch */ case    9:  		/* lhz R11, <#[R30]> */
		/* 8224119Ch case    9:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8224119Ch case    9:*/		return 0x822411A0;
		  /* 822411A0h */ case   10:  		/* lwz R9, <#[R31 + 4]> */
		/* 822411A0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 822411A0h case   10:*/		return 0x822411A4;
		  /* 822411A4h */ case   11:  		/* rlwimi R9, R11, 12, 18, 19 */
		/* 822411A4h case   11:*/		cpu::op::rlwimi<0,12,18,19>(regs,&regs.R9,regs.R11);
		/* 822411A4h case   11:*/		return 0x822411A8;
		  /* 822411A8h */ case   12:  		/* lis R11, -32253 */
		/* 822411A8h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 822411A8h case   12:*/		return 0x822411AC;
		  /* 822411ACh */ case   13:  		/* mr R8, R9 */
		/* 822411ACh case   13:*/		regs.R8 = regs.R9;
		/* 822411ACh case   13:*/		return 0x822411B0;
		  /* 822411B0h */ case   14:  		/* stw R9, <#[R31 + 4]> */
		/* 822411B0h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 822411B0h case   14:*/		return 0x822411B4;
		  /* 822411B4h */ case   15:  		/* lhz R9, <#[R30 + 2]> */
		/* 822411B4h case   15:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000002) );
		/* 822411B4h case   15:*/		return 0x822411B8;
		  /* 822411B8h */ case   16:  		/* addi R28, R11, 27460 */
		/* 822411B8h case   16:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x6B44);
		/* 822411B8h case   16:*/		return 0x822411BC;
		  /* 822411BCh */ case   17:  		/* rlwimi R8, R9, 14, 16, 17 */
		/* 822411BCh case   17:*/		cpu::op::rlwimi<0,14,16,17>(regs,&regs.R8,regs.R9);
		/* 822411BCh case   17:*/		return 0x822411C0;
		  /* 822411C0h */ case   18:  		/* stw R8, <#[R31 + 4]> */
		/* 822411C0h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 822411C0h case   18:*/		return 0x822411C4;
		  /* 822411C4h */ case   19:  		/* lhz R11, <#[R30 + 4]> */
		/* 822411C4h case   19:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 822411C4h case   19:*/		return 0x822411C8;
		  /* 822411C8h */ case   20:  		/* rlwimi R8, R11, 16, 14, 15 */
		/* 822411C8h case   20:*/		cpu::op::rlwimi<0,16,14,15>(regs,&regs.R8,regs.R11);
		/* 822411C8h case   20:*/		return 0x822411CC;
		  /* 822411CCh */ case   21:  		/* mr R11, R8 */
		/* 822411CCh case   21:*/		regs.R11 = regs.R8;
		/* 822411CCh case   21:*/		return 0x822411D0;
		  /* 822411D0h */ case   22:  		/* stw R8, <#[R31 + 4]> */
		/* 822411D0h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 822411D0h case   22:*/		return 0x822411D4;
		  /* 822411D4h */ case   23:  		/* lhz R10, <#[R30 + 6]> */
		/* 822411D4h case   23:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000006) );
		/* 822411D4h case   23:*/		return 0x822411D8;
		  /* 822411D8h */ case   24:  		/* rlwimi R11, R10, 18, 11, 13 */
		/* 822411D8h case   24:*/		cpu::op::rlwimi<0,18,11,13>(regs,&regs.R11,regs.R10);
		/* 822411D8h case   24:*/		return 0x822411DC;
		  /* 822411DCh */ case   25:  		/* mr R10, R11 */
		/* 822411DCh case   25:*/		regs.R10 = regs.R11;
		/* 822411DCh case   25:*/		return 0x822411E0;
		  /* 822411E0h */ case   26:  		/* stw R11, <#[R31 + 4]> */
		/* 822411E0h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822411E0h case   26:*/		return 0x822411E4;
		  /* 822411E4h */ case   27:  		/* lhz R11, <#[R30 + 8]> */
		/* 822411E4h case   27:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 822411E4h case   27:*/		return 0x822411E8;
		  /* 822411E8h */ case   28:  		/* rlwimi R10, R11, 21, 8, 10 */
		/* 822411E8h case   28:*/		cpu::op::rlwimi<0,21,8,10>(regs,&regs.R10,regs.R11);
		/* 822411E8h case   28:*/		return 0x822411EC;
		  /* 822411ECh */ case   29:  		/* stw R10, <#[R31 + 4]> */
		/* 822411ECh case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 822411ECh case   29:*/		return 0x822411F0;
		  /* 822411F0h */ case   30:  		/* mr R11, R10 */
		/* 822411F0h case   30:*/		regs.R11 = regs.R10;
		/* 822411F0h case   30:*/		return 0x822411F4;
		  /* 822411F4h */ case   31:  		/* lhz R10, <#[R30 + 10]> */
		/* 822411F4h case   31:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000000A) );
		/* 822411F4h case   31:*/		return 0x822411F8;
		  /* 822411F8h */ case   32:  		/* rlwimi R11, R10, 24, 6, 7 */
		/* 822411F8h case   32:*/		cpu::op::rlwimi<0,24,6,7>(regs,&regs.R11,regs.R10);
		/* 822411F8h case   32:*/		return 0x822411FC;
		  /* 822411FCh */ case   33:  		/* stw R11, <#[R31 + 4]> */
		/* 822411FCh case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822411FCh case   33:*/		return 0x82241200;
		  /* 82241200h */ case   34:  		/* mr R10, R11 */
		/* 82241200h case   34:*/		regs.R10 = regs.R11;
		/* 82241200h case   34:*/		return 0x82241204;
		  /* 82241204h */ case   35:  		/* lhz R11, <#[R30 + 12]> */
		/* 82241204h case   35:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82241204h case   35:*/		return 0x82241208;
		  /* 82241208h */ case   36:  		/* rlwimi R10, R11, 26, 4, 5 */
		/* 82241208h case   36:*/		cpu::op::rlwimi<0,26,4,5>(regs,&regs.R10,regs.R11);
		/* 82241208h case   36:*/		return 0x8224120C;
		  /* 8224120Ch */ case   37:  		/* stw R10, <#[R31 + 4]> */
		/* 8224120Ch case   37:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8224120Ch case   37:*/		return 0x82241210;
		  /* 82241210h */ case   38:  		/* mr R11, R10 */
		/* 82241210h case   38:*/		regs.R11 = regs.R10;
		/* 82241210h case   38:*/		return 0x82241214;
		  /* 82241214h */ case   39:  		/* lhz R10, <#[R30 + 14]> */
		/* 82241214h case   39:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000000E) );
		/* 82241214h case   39:*/		return 0x82241218;
		  /* 82241218h */ case   40:  		/* rlwimi R11, R10, 28, 3, 3 */
		/* 82241218h case   40:*/		cpu::op::rlwimi<0,28,3,3>(regs,&regs.R11,regs.R10);
		/* 82241218h case   40:*/		return 0x8224121C;
		  /* 8224121Ch */ case   41:  		/* stw R11, <#[R31 + 4]> */
		/* 8224121Ch case   41:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224121Ch case   41:*/		return 0x82241220;
		  /* 82241220h */ case   42:  		/* mr R10, R11 */
		/* 82241220h case   42:*/		regs.R10 = regs.R11;
		/* 82241220h case   42:*/		return 0x82241224;
		  /* 82241224h */ case   43:  		/* lhz R11, <#[R30 + 16]> */
		/* 82241224h case   43:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82241224h case   43:*/		return 0x82241228;
		  /* 82241228h */ case   44:  		/* rlwimi R10, R11, 29, 1, 2 */
		/* 82241228h case   44:*/		cpu::op::rlwimi<0,29,1,2>(regs,&regs.R10,regs.R11);
		/* 82241228h case   44:*/		return 0x8224122C;
		  /* 8224122Ch */ case   45:  		/* stw R10, <#[R31 + 4]> */
		/* 8224122Ch case   45:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8224122Ch case   45:*/		return 0x82241230;
		  /* 82241230h */ case   46:  		/* lhz R11, <#[R30 + 20]> */
		/* 82241230h case   46:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82241230h case   46:*/		return 0x82241234;
		  /* 82241234h */ case   47:  		/* rlwimi R11, R7, 0, 0, 30 */
		/* 82241234h case   47:*/		cpu::op::rlwimi<0,0,0,30>(regs,&regs.R11,regs.R7);
		/* 82241234h case   47:*/		return 0x82241238;
		  /* 82241238h */ case   48:  		/* mr R10, R11 */
		/* 82241238h case   48:*/		regs.R10 = regs.R11;
		/* 82241238h case   48:*/		return 0x8224123C;
		  /* 8224123Ch */ case   49:  		/* stw R11, <#[R31 + 8]> */
		/* 8224123Ch case   49:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224123Ch case   49:*/		return 0x82241240;
		  /* 82241240h */ case   50:  		/* lhz R11, <#[R30 + 18]> */
		/* 82241240h case   50:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000012) );
		/* 82241240h case   50:*/		return 0x82241244;
		  /* 82241244h */ case   51:  		/* rlwimi R10, R11, 1, 30, 30 */
		/* 82241244h case   51:*/		cpu::op::rlwimi<0,1,30,30>(regs,&regs.R10,regs.R11);
		/* 82241244h case   51:*/		return 0x82241248;
		  /* 82241248h */ case   52:  		/* rlwinm R11, R10, 0, 30, 15 */
		/* 82241248h case   52:*/		cpu::op::rlwinm<0,0,30,15>(regs,&regs.R11,regs.R10);
		/* 82241248h case   52:*/		return 0x8224124C;
		  /* 8224124Ch */ case   53:  		/* stw R11, <#[R31 + 8]> */
		/* 8224124Ch case   53:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224124Ch case   53:*/		return 0x82241250;
		  /* 82241250h */ case   54:  		/* lhz R11, <#[R30 + 24]> */
		/* 82241250h case   54:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82241250h case   54:*/		return 0x82241254;
		  /* 82241254h */ case   55:  		/* extsw R11, R11 */
		/* 82241254h case   55:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 82241254h case   55:*/		return 0x82241258;
		  /* 82241258h */ case   56:  		/* std R11, <#[R1 + 80]> */
		/* 82241258h case   56:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82241258h case   56:*/		return 0x8224125C;
		  /* 8224125Ch */ case   57:  		/* lfd FR0, <#[R1 + 80]> */
		/* 8224125Ch case   57:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8224125Ch case   57:*/		return 0x82241260;
		  /* 82241260h */ case   58:  		/* fcfid FR0, FR0 */
		/* 82241260h case   58:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82241260h case   58:*/		return 0x82241264;
		  /* 82241264h */ case   59:  		/* frsp FR0, FR0 */
		/* 82241264h case   59:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82241264h case   59:*/		return 0x82241268;
		  /* 82241268h */ case   60:  		/* fcmpu CR6, FR0, FR31 */
		/* 82241268h case   60:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82241268h case   60:*/		return 0x8224126C;
		  /* 8224126Ch */ case   61:  		/* bc 12, CR6_EQ, 48 */
		/* 8224126Ch case   61:*/		if ( regs.CR[6].eq ) { return 0x8224129C;  }
		/* 8224126Ch case   61:*/		return 0x82241270;
		  /* 82241270h */ case   62:  		/* fcmpu CR6, FR0, FR30 */
		/* 82241270h case   62:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82241270h case   62:*/		return 0x82241274;
		  /* 82241274h */ case   63:  		/* bc 12, CR6_EQ, 40 */
		/* 82241274h case   63:*/		if ( regs.CR[6].eq ) { return 0x8224129C;  }
		/* 82241274h case   63:*/		return 0x82241278;
		  /* 82241278h */ case   64:  		/* fcmpu CR6, FR0, FR29 */
		/* 82241278h case   64:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 82241278h case   64:*/		return 0x8224127C;
		  /* 8224127Ch */ case   65:  		/* bc 12, CR6_EQ, 32 */
		/* 8224127Ch case   65:*/		if ( regs.CR[6].eq ) { return 0x8224129C;  }
		/* 8224127Ch case   65:*/		return 0x82241280;
		  /* 82241280h */ case   66:  		/* lis R11, -32252 */
		/* 82241280h case   66:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82241280h case   66:*/		return 0x82241284;
		  /* 82241284h */ case   67:  		/* mr R6, R27 */
		/* 82241284h case   67:*/		regs.R6 = regs.R27;
		/* 82241284h case   67:*/		return 0x82241288;
		  /* 82241288h */ case   68:  		/* addi R5, R11, 11328 */
		/* 82241288h case   68:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2C40);
		/* 82241288h case   68:*/		return 0x8224128C;
		  /* 8224128Ch */ case   69:  		/* mr R4, R28 */
		/* 8224128Ch case   69:*/		regs.R4 = regs.R28;
		/* 8224128Ch case   69:*/		return 0x82241290;
		  /* 82241290h */ case   70:  		/* li R7, 3057 */
		/* 82241290h case   70:*/		cpu::op::li<0>(regs,&regs.R7,0xBF1);
		/* 82241290h case   70:*/		return 0x82241294;
		  /* 82241294h */ case   71:  		/* li R3, 0 */
		/* 82241294h case   71:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82241294h case   71:*/		return 0x82241298;
		  /* 82241298h */ case   72:  		/* bl -956048 */
		/* 82241298h case   72:*/		regs.LR = 0x8224129C; return 0x82157C08;
		/* 82241298h case   72:*/		return 0x8224129C;
	}
	return 0x8224129C;
} // Block from 82241178h-8224129Ch (73 instructions)

//////////////////////////////////////////////////////
// Block at 8224129Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224129C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224129C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224129C);
		  /* 8224129Ch */ case    0:  		/* lhz R11, <#[R30 + 26]> */
		/* 8224129Ch case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001A) );
		/* 8224129Ch case    0:*/		return 0x822412A0;
		  /* 822412A0h */ case    1:  		/* extsw R11, R11 */
		/* 822412A0h case    1:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 822412A0h case    1:*/		return 0x822412A4;
		  /* 822412A4h */ case    2:  		/* std R11, <#[R1 + 80]> */
		/* 822412A4h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822412A4h case    2:*/		return 0x822412A8;
		  /* 822412A8h */ case    3:  		/* lfd FR0, <#[R1 + 80]> */
		/* 822412A8h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822412A8h case    3:*/		return 0x822412AC;
		  /* 822412ACh */ case    4:  		/* fcfid FR0, FR0 */
		/* 822412ACh case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 822412ACh case    4:*/		return 0x822412B0;
		  /* 822412B0h */ case    5:  		/* frsp FR0, FR0 */
		/* 822412B0h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 822412B0h case    5:*/		return 0x822412B4;
		  /* 822412B4h */ case    6:  		/* fcmpu CR6, FR0, FR31 */
		/* 822412B4h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 822412B4h case    6:*/		return 0x822412B8;
		  /* 822412B8h */ case    7:  		/* bc 12, CR6_EQ, 48 */
		/* 822412B8h case    7:*/		if ( regs.CR[6].eq ) { return 0x822412E8;  }
		/* 822412B8h case    7:*/		return 0x822412BC;
		  /* 822412BCh */ case    8:  		/* fcmpu CR6, FR0, FR30 */
		/* 822412BCh case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 822412BCh case    8:*/		return 0x822412C0;
		  /* 822412C0h */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 822412C0h case    9:*/		if ( regs.CR[6].eq ) { return 0x822412E8;  }
		/* 822412C0h case    9:*/		return 0x822412C4;
		  /* 822412C4h */ case   10:  		/* fcmpu CR6, FR0, FR29 */
		/* 822412C4h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 822412C4h case   10:*/		return 0x822412C8;
		  /* 822412C8h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 822412C8h case   11:*/		if ( regs.CR[6].eq ) { return 0x822412E8;  }
		/* 822412C8h case   11:*/		return 0x822412CC;
		  /* 822412CCh */ case   12:  		/* lis R11, -32252 */
		/* 822412CCh case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822412CCh case   12:*/		return 0x822412D0;
		  /* 822412D0h */ case   13:  		/* mr R6, R27 */
		/* 822412D0h case   13:*/		regs.R6 = regs.R27;
		/* 822412D0h case   13:*/		return 0x822412D4;
		  /* 822412D4h */ case   14:  		/* addi R5, R11, 11240 */
		/* 822412D4h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2BE8);
		/* 822412D4h case   14:*/		return 0x822412D8;
		  /* 822412D8h */ case   15:  		/* mr R4, R28 */
		/* 822412D8h case   15:*/		regs.R4 = regs.R28;
		/* 822412D8h case   15:*/		return 0x822412DC;
		  /* 822412DCh */ case   16:  		/* li R7, 3059 */
		/* 822412DCh case   16:*/		cpu::op::li<0>(regs,&regs.R7,0xBF3);
		/* 822412DCh case   16:*/		return 0x822412E0;
		  /* 822412E0h */ case   17:  		/* li R3, 0 */
		/* 822412E0h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822412E0h case   17:*/		return 0x822412E4;
		  /* 822412E4h */ case   18:  		/* bl -956124 */
		/* 822412E4h case   18:*/		regs.LR = 0x822412E8; return 0x82157C08;
		/* 822412E4h case   18:*/		return 0x822412E8;
	}
	return 0x822412E8;
} // Block from 8224129Ch-822412E8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 822412E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822412E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822412E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822412E8);
		  /* 822412E8h */ case    0:  		/* lhz R11, <#[R30 + 28]> */
		/* 822412E8h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 822412E8h case    0:*/		return 0x822412EC;
		  /* 822412ECh */ case    1:  		/* extsw R11, R11 */
		/* 822412ECh case    1:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 822412ECh case    1:*/		return 0x822412F0;
		  /* 822412F0h */ case    2:  		/* std R11, <#[R1 + 80]> */
		/* 822412F0h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822412F0h case    2:*/		return 0x822412F4;
		  /* 822412F4h */ case    3:  		/* lfd FR0, <#[R1 + 80]> */
		/* 822412F4h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822412F4h case    3:*/		return 0x822412F8;
		  /* 822412F8h */ case    4:  		/* fcfid FR0, FR0 */
		/* 822412F8h case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 822412F8h case    4:*/		return 0x822412FC;
		  /* 822412FCh */ case    5:  		/* frsp FR0, FR0 */
		/* 822412FCh case    5:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 822412FCh case    5:*/		return 0x82241300;
		  /* 82241300h */ case    6:  		/* fcmpu CR6, FR0, FR31 */
		/* 82241300h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82241300h case    6:*/		return 0x82241304;
		  /* 82241304h */ case    7:  		/* bc 12, CR6_EQ, 48 */
		/* 82241304h case    7:*/		if ( regs.CR[6].eq ) { return 0x82241334;  }
		/* 82241304h case    7:*/		return 0x82241308;
		  /* 82241308h */ case    8:  		/* fcmpu CR6, FR0, FR30 */
		/* 82241308h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82241308h case    8:*/		return 0x8224130C;
		  /* 8224130Ch */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 8224130Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82241334;  }
		/* 8224130Ch case    9:*/		return 0x82241310;
		  /* 82241310h */ case   10:  		/* fcmpu CR6, FR0, FR29 */
		/* 82241310h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 82241310h case   10:*/		return 0x82241314;
		  /* 82241314h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 82241314h case   11:*/		if ( regs.CR[6].eq ) { return 0x82241334;  }
		/* 82241314h case   11:*/		return 0x82241318;
		  /* 82241318h */ case   12:  		/* lis R11, -32252 */
		/* 82241318h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82241318h case   12:*/		return 0x8224131C;
		  /* 8224131Ch */ case   13:  		/* mr R6, R27 */
		/* 8224131Ch case   13:*/		regs.R6 = regs.R27;
		/* 8224131Ch case   13:*/		return 0x82241320;
		  /* 82241320h */ case   14:  		/* addi R5, R11, 11152 */
		/* 82241320h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2B90);
		/* 82241320h case   14:*/		return 0x82241324;
		  /* 82241324h */ case   15:  		/* mr R4, R28 */
		/* 82241324h case   15:*/		regs.R4 = regs.R28;
		/* 82241324h case   15:*/		return 0x82241328;
		  /* 82241328h */ case   16:  		/* li R7, 3061 */
		/* 82241328h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0xBF5);
		/* 82241328h case   16:*/		return 0x8224132C;
		  /* 8224132Ch */ case   17:  		/* li R3, 0 */
		/* 8224132Ch case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224132Ch case   17:*/		return 0x82241330;
		  /* 82241330h */ case   18:  		/* bl -956200 */
		/* 82241330h case   18:*/		regs.LR = 0x82241334; return 0x82157C08;
		/* 82241330h case   18:*/		return 0x82241334;
	}
	return 0x82241334;
} // Block from 822412E8h-82241334h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82241334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241334);
		  /* 82241334h */ case    0:  		/* lhz R9, <#[R30 + 24]> */
		/* 82241334h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000018) );
		/* 82241334h case    0:*/		return 0x82241338;
		  /* 82241338h */ case    1:  		/* li R10, 1 */
		/* 82241338h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82241338h case    1:*/		return 0x8224133C;
		  /* 8224133Ch */ case    2:  		/* li R11, 17 */
		/* 8224133Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x11);
		/* 8224133Ch case    2:*/		return 0x82241340;
		  /* 82241340h */ case    3:  		/* extsw R9, R9 */
		/* 82241340h case    3:*/		cpu::op::extsw<0>(regs,&regs.R9,regs.R9);
		/* 82241340h case    3:*/		return 0x82241344;
		  /* 82241344h */ case    4:  		/* std R9, <#[R1 + 80]> */
		/* 82241344h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82241344h case    4:*/		return 0x82241348;
		  /* 82241348h */ case    5:  		/* lfd FR0, <#[R1 + 80]> */
		/* 82241348h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82241348h case    5:*/		return 0x8224134C;
		  /* 8224134Ch */ case    6:  		/* fcfid FR0, FR0 */
		/* 8224134Ch case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8224134Ch case    6:*/		return 0x82241350;
		  /* 82241350h */ case    7:  		/* frsp FR0, FR0 */
		/* 82241350h case    7:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82241350h case    7:*/		return 0x82241354;
		  /* 82241354h */ case    8:  		/* fcmpu CR6, FR0, FR31 */
		/* 82241354h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82241354h case    8:*/		return 0x82241358;
		  /* 82241358h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 82241358h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82241368;  }
		/* 82241358h case    9:*/		return 0x8224135C;
		  /* 8224135Ch */ case   10:  		/* lwz R9, <#[R31 + 8]> */
		/* 8224135Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8224135Ch case   10:*/		return 0x82241360;
		  /* 82241360h */ case   11:  		/* rlwinm R9, R9, 0, 16, 10 */
		/* 82241360h case   11:*/		cpu::op::rlwinm<0,0,16,10>(regs,&regs.R9,regs.R9);
		/* 82241360h case   11:*/		return 0x82241364;
		  /* 82241364h */ case   12:  		/* b 40 */
		/* 82241364h case   12:*/		return 0x8224138C;
		/* 82241364h case   12:*/		return 0x82241368;
	}
	return 0x82241368;
} // Block from 82241334h-82241368h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82241368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241368);
		  /* 82241368h */ case    0:  		/* fcmpu CR6, FR0, FR30 */
		/* 82241368h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82241368h case    0:*/		return 0x8224136C;
		  /* 8224136Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8224136Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224137C;  }
		/* 8224136Ch case    1:*/		return 0x82241370;
		  /* 82241370h */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 82241370h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82241370h case    2:*/		return 0x82241374;
		  /* 82241374h */ case    3:  		/* rlwimi R9, R10, 16, 11, 15 */
		/* 82241374h case    3:*/		cpu::op::rlwimi<0,16,11,15>(regs,&regs.R9,regs.R10);
		/* 82241374h case    3:*/		return 0x82241378;
		  /* 82241378h */ case    4:  		/* b 20 */
		/* 82241378h case    4:*/		return 0x8224138C;
		/* 82241378h case    4:*/		return 0x8224137C;
	}
	return 0x8224137C;
} // Block from 82241368h-8224137Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224137Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224137C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224137C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224137C);
		  /* 8224137Ch */ case    0:  		/* fcmpu CR6, FR0, FR29 */
		/* 8224137Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 8224137Ch case    0:*/		return 0x82241380;
		  /* 82241380h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82241380h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82241390;  }
		/* 82241380h case    1:*/		return 0x82241384;
		  /* 82241384h */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 82241384h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82241384h case    2:*/		return 0x82241388;
		  /* 82241388h */ case    3:  		/* rlwimi R9, R11, 16, 11, 15 */
		/* 82241388h case    3:*/		cpu::op::rlwimi<0,16,11,15>(regs,&regs.R9,regs.R11);
		/* 82241388h case    3:*/		return 0x8224138C;
	}
	return 0x8224138C;
} // Block from 8224137Ch-8224138Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224138Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224138C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224138C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224138C);
		  /* 8224138Ch */ case    0:  		/* stw R9, <#[R31 + 8]> */
		/* 8224138Ch case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8224138Ch case    0:*/		return 0x82241390;
	}
	return 0x82241390;
} // Block from 8224138Ch-82241390h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82241390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241390);
		  /* 82241390h */ case    0:  		/* lhz R9, <#[R30 + 26]> */
		/* 82241390h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000001A) );
		/* 82241390h case    0:*/		return 0x82241394;
		  /* 82241394h */ case    1:  		/* extsw R9, R9 */
		/* 82241394h case    1:*/		cpu::op::extsw<0>(regs,&regs.R9,regs.R9);
		/* 82241394h case    1:*/		return 0x82241398;
		  /* 82241398h */ case    2:  		/* std R9, <#[R1 + 80]> */
		/* 82241398h case    2:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82241398h case    2:*/		return 0x8224139C;
		  /* 8224139Ch */ case    3:  		/* lfd FR0, <#[R1 + 80]> */
		/* 8224139Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8224139Ch case    3:*/		return 0x822413A0;
		  /* 822413A0h */ case    4:  		/* fcfid FR0, FR0 */
		/* 822413A0h case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 822413A0h case    4:*/		return 0x822413A4;
		  /* 822413A4h */ case    5:  		/* frsp FR0, FR0 */
		/* 822413A4h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 822413A4h case    5:*/		return 0x822413A8;
		  /* 822413A8h */ case    6:  		/* fcmpu CR6, FR0, FR31 */
		/* 822413A8h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 822413A8h case    6:*/		return 0x822413AC;
		  /* 822413ACh */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 822413ACh case    7:*/		if ( !regs.CR[6].eq ) { return 0x822413BC;  }
		/* 822413ACh case    7:*/		return 0x822413B0;
		  /* 822413B0h */ case    8:  		/* lwz R9, <#[R31 + 8]> */
		/* 822413B0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 822413B0h case    8:*/		return 0x822413B4;
		  /* 822413B4h */ case    9:  		/* rlwinm R9, R9, 0, 11, 5 */
		/* 822413B4h case    9:*/		cpu::op::rlwinm<0,0,11,5>(regs,&regs.R9,regs.R9);
		/* 822413B4h case    9:*/		return 0x822413B8;
		  /* 822413B8h */ case   10:  		/* b 40 */
		/* 822413B8h case   10:*/		return 0x822413E0;
		/* 822413B8h case   10:*/		return 0x822413BC;
	}
	return 0x822413BC;
} // Block from 82241390h-822413BCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 822413BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822413BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822413BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822413BC);
		  /* 822413BCh */ case    0:  		/* fcmpu CR6, FR0, FR30 */
		/* 822413BCh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 822413BCh case    0:*/		return 0x822413C0;
		  /* 822413C0h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 822413C0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822413D0;  }
		/* 822413C0h case    1:*/		return 0x822413C4;
		  /* 822413C4h */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 822413C4h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 822413C4h case    2:*/		return 0x822413C8;
		  /* 822413C8h */ case    3:  		/* rlwimi R9, R10, 21, 6, 10 */
		/* 822413C8h case    3:*/		cpu::op::rlwimi<0,21,6,10>(regs,&regs.R9,regs.R10);
		/* 822413C8h case    3:*/		return 0x822413CC;
		  /* 822413CCh */ case    4:  		/* b 20 */
		/* 822413CCh case    4:*/		return 0x822413E0;
		/* 822413CCh case    4:*/		return 0x822413D0;
	}
	return 0x822413D0;
} // Block from 822413BCh-822413D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822413D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822413D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822413D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822413D0);
		  /* 822413D0h */ case    0:  		/* fcmpu CR6, FR0, FR29 */
		/* 822413D0h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 822413D0h case    0:*/		return 0x822413D4;
		  /* 822413D4h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 822413D4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822413E4;  }
		/* 822413D4h case    1:*/		return 0x822413D8;
		  /* 822413D8h */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 822413D8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 822413D8h case    2:*/		return 0x822413DC;
		  /* 822413DCh */ case    3:  		/* rlwimi R9, R11, 21, 6, 10 */
		/* 822413DCh case    3:*/		cpu::op::rlwimi<0,21,6,10>(regs,&regs.R9,regs.R11);
		/* 822413DCh case    3:*/		return 0x822413E0;
	}
	return 0x822413E0;
} // Block from 822413D0h-822413E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822413E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822413E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822413E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822413E0);
		  /* 822413E0h */ case    0:  		/* stw R9, <#[R31 + 8]> */
		/* 822413E0h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 822413E0h case    0:*/		return 0x822413E4;
	}
	return 0x822413E4;
} // Block from 822413E0h-822413E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822413E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822413E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822413E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822413E4);
		  /* 822413E4h */ case    0:  		/* lhz R9, <#[R30 + 28]> */
		/* 822413E4h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000001C) );
		/* 822413E4h case    0:*/		return 0x822413E8;
		  /* 822413E8h */ case    1:  		/* extsw R9, R9 */
		/* 822413E8h case    1:*/		cpu::op::extsw<0>(regs,&regs.R9,regs.R9);
		/* 822413E8h case    1:*/		return 0x822413EC;
		  /* 822413ECh */ case    2:  		/* std R9, <#[R1 + 80]> */
		/* 822413ECh case    2:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 822413ECh case    2:*/		return 0x822413F0;
		  /* 822413F0h */ case    3:  		/* lfd FR0, <#[R1 + 80]> */
		/* 822413F0h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822413F0h case    3:*/		return 0x822413F4;
		  /* 822413F4h */ case    4:  		/* fcfid FR0, FR0 */
		/* 822413F4h case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 822413F4h case    4:*/		return 0x822413F8;
		  /* 822413F8h */ case    5:  		/* frsp FR0, FR0 */
		/* 822413F8h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 822413F8h case    5:*/		return 0x822413FC;
		  /* 822413FCh */ case    6:  		/* fcmpu CR6, FR0, FR31 */
		/* 822413FCh case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 822413FCh case    6:*/		return 0x82241400;
		  /* 82241400h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 82241400h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82241410;  }
		/* 82241400h case    7:*/		return 0x82241404;
		  /* 82241404h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 82241404h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82241404h case    8:*/		return 0x82241408;
		  /* 82241408h */ case    9:  		/* rlwinm R11, R11, 0, 6, 0 */
		/* 82241408h case    9:*/		cpu::op::rlwinm<0,0,6,0>(regs,&regs.R11,regs.R11);
		/* 82241408h case    9:*/		return 0x8224140C;
		  /* 8224140Ch */ case   10:  		/* b 20 */
		/* 8224140Ch case   10:*/		return 0x82241420;
		/* 8224140Ch case   10:*/		return 0x82241410;
	}
	return 0x82241410;
} // Block from 822413E4h-82241410h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82241410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241410);
		  /* 82241410h */ case    0:  		/* fcmpu CR6, FR0, FR30 */
		/* 82241410h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82241410h case    0:*/		return 0x82241414;
		  /* 82241414h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 82241414h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82241428;  }
		/* 82241414h case    1:*/		return 0x82241418;
		  /* 82241418h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 82241418h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82241418h case    2:*/		return 0x8224141C;
		  /* 8224141Ch */ case    3:  		/* rlwimi R11, R10, 26, 1, 5 */
		/* 8224141Ch case    3:*/		cpu::op::rlwimi<0,26,1,5>(regs,&regs.R11,regs.R10);
		/* 8224141Ch case    3:*/		return 0x82241420;
	}
	return 0x82241420;
} // Block from 82241410h-82241420h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82241420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241420);
		  /* 82241420h */ case    0:  		/* stw R11, <#[R31 + 8]> */
		/* 82241420h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82241420h case    0:*/		return 0x82241424;
		  /* 82241424h */ case    1:  		/* b 24 */
		/* 82241424h case    1:*/		return 0x8224143C;
		/* 82241424h case    1:*/		return 0x82241428;
	}
	return 0x82241428;
} // Block from 82241420h-82241428h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82241428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241428);
		  /* 82241428h */ case    0:  		/* fcmpu CR6, FR0, FR29 */
		/* 82241428h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 82241428h case    0:*/		return 0x8224142C;
		  /* 8224142Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8224142Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224143C;  }
		/* 8224142Ch case    1:*/		return 0x82241430;
		  /* 82241430h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82241430h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82241430h case    2:*/		return 0x82241434;
		  /* 82241434h */ case    3:  		/* rlwimi R10, R11, 26, 1, 5 */
		/* 82241434h case    3:*/		cpu::op::rlwimi<0,26,1,5>(regs,&regs.R10,regs.R11);
		/* 82241434h case    3:*/		return 0x82241438;
		  /* 82241438h */ case    4:  		/* stw R10, <#[R31 + 8]> */
		/* 82241438h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82241438h case    4:*/		return 0x8224143C;
	}
	return 0x8224143C;
} // Block from 82241428h-8224143Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224143Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224143C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224143C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224143C);
		  /* 8224143Ch */ case    0:  		/* lwz R11, <#[R29 + 52]> */
		/* 8224143Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000034) );
		/* 8224143Ch case    0:*/		return 0x82241440;
		  /* 82241440h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82241440h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82241440h case    1:*/		return 0x82241444;
		  /* 82241444h */ case    2:  		/* bc 12, CR6_EQ, 84 */
		/* 82241444h case    2:*/		if ( regs.CR[6].eq ) { return 0x82241498;  }
		/* 82241444h case    2:*/		return 0x82241448;
		  /* 82241448h */ case    3:  		/* cmpwi CR6, R11, 2 */
		/* 82241448h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 82241448h case    3:*/		return 0x8224144C;
		  /* 8224144Ch */ case    4:  		/* bc 12, CR6_EQ, 64 */
		/* 8224144Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8224148C;  }
		/* 8224144Ch case    4:*/		return 0x82241450;
		  /* 82241450h */ case    5:  		/* cmpwi CR6, R11, 3 */
		/* 82241450h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 82241450h case    5:*/		return 0x82241454;
		  /* 82241454h */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 82241454h case    6:*/		if ( regs.CR[6].eq ) { return 0x82241478;  }
		/* 82241454h case    6:*/		return 0x82241458;
		  /* 82241458h */ case    7:  		/* lis R11, -32255 */
		/* 82241458h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82241458h case    7:*/		return 0x8224145C;
		  /* 8224145Ch */ case    8:  		/* mr R6, R27 */
		/* 8224145Ch case    8:*/		regs.R6 = regs.R27;
		/* 8224145Ch case    8:*/		return 0x82241460;
		  /* 82241460h */ case    9:  		/* addi R5, R11, 5216 */
		/* 82241460h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1460);
		/* 82241460h case    9:*/		return 0x82241464;
		  /* 82241464h */ case   10:  		/* mr R4, R28 */
		/* 82241464h case   10:*/		regs.R4 = regs.R28;
		/* 82241464h case   10:*/		return 0x82241468;
		  /* 82241468h */ case   11:  		/* li R7, 3099 */
		/* 82241468h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0xC1B);
		/* 82241468h case   11:*/		return 0x8224146C;
		  /* 8224146Ch */ case   12:  		/* li R3, 0 */
		/* 8224146Ch case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224146Ch case   12:*/		return 0x82241470;
		  /* 82241470h */ case   13:  		/* bl -956520 */
		/* 82241470h case   13:*/		regs.LR = 0x82241474; return 0x82157C08;
		/* 82241470h case   13:*/		return 0x82241474;
		  /* 82241474h */ case   14:  		/* b 60 */
		/* 82241474h case   14:*/		return 0x822414B0;
		/* 82241474h case   14:*/		return 0x82241478;
	}
	return 0x82241478;
} // Block from 8224143Ch-82241478h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82241478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241478);
		  /* 82241478h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82241478h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82241478h case    0:*/		return 0x8224147C;
		  /* 8224147Ch */ case    1:  		/* lwz R10, <#[R31 + 8]> */
		/* 8224147Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8224147Ch case    1:*/		return 0x82241480;
		  /* 82241480h */ case    2:  		/* oris R11, R11, 32768 */
		/* 82241480h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82241480h case    2:*/		return 0x82241484;
		  /* 82241484h */ case    3:  		/* oris R10, R10, 32768 */
		/* 82241484h case    3:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 82241484h case    3:*/		return 0x82241488;
		  /* 82241488h */ case    4:  		/* b 32 */
		/* 82241488h case    4:*/		return 0x822414A8;
		/* 82241488h case    4:*/		return 0x8224148C;
	}
	return 0x8224148C;
} // Block from 82241478h-8224148Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224148Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224148C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224148C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224148C);
		  /* 8224148Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8224148Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224148Ch case    0:*/		return 0x82241490;
		  /* 82241490h */ case    1:  		/* oris R11, R11, 32768 */
		/* 82241490h case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82241490h case    1:*/		return 0x82241494;
		  /* 82241494h */ case    2:  		/* b 12 */
		/* 82241494h case    2:*/		return 0x822414A0;
		/* 82241494h case    2:*/		return 0x82241498;
	}
	return 0x82241498;
} // Block from 8224148Ch-82241498h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82241498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241498);
		  /* 82241498h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82241498h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82241498h case    0:*/		return 0x8224149C;
		  /* 8224149Ch */ case    1:  		/* rlwinm R11, R11, 0, 1, 31 */
		/* 8224149Ch case    1:*/		cpu::op::rlwinm<0,0,1,31>(regs,&regs.R11,regs.R11);
		/* 8224149Ch case    1:*/		return 0x822414A0;
	}
	return 0x822414A0;
} // Block from 82241498h-822414A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822414A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822414A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822414A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822414A0);
		  /* 822414A0h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 822414A0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 822414A0h case    0:*/		return 0x822414A4;
		  /* 822414A4h */ case    1:  		/* rlwinm R10, R10, 0, 1, 31 */
		/* 822414A4h case    1:*/		cpu::op::rlwinm<0,0,1,31>(regs,&regs.R10,regs.R10);
		/* 822414A4h case    1:*/		return 0x822414A8;
	}
	return 0x822414A8;
} // Block from 822414A0h-822414A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822414A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822414A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822414A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822414A8);
		  /* 822414A8h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 822414A8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822414A8h case    0:*/		return 0x822414AC;
		  /* 822414ACh */ case    1:  		/* stw R10, <#[R31 + 8]> */
		/* 822414ACh case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 822414ACh case    1:*/		return 0x822414B0;
	}
	return 0x822414B0;
} // Block from 822414A8h-822414B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822414B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822414B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822414B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822414B0);
		  /* 822414B0h */ case    0:  		/* addi R1, R1, 208 */
		/* 822414B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 822414B0h case    0:*/		return 0x822414B4;
		  /* 822414B4h */ case    1:  		/* lfd FR29, <#[R1 - 72]> */
		/* 822414B4h case    1:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 822414B4h case    1:*/		return 0x822414B8;
		  /* 822414B8h */ case    2:  		/* lfd FR30, <#[R1 - 64]> */
		/* 822414B8h case    2:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 822414B8h case    2:*/		return 0x822414BC;
		  /* 822414BCh */ case    3:  		/* lfd FR31, <#[R1 - 56]> */
		/* 822414BCh case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 822414BCh case    3:*/		return 0x822414C0;
		  /* 822414C0h */ case    4:  		/* b -1770012 */
		/* 822414C0h case    4:*/		return 0x820912A4;
		/* 822414C0h case    4:*/		return 0x822414C4;
		  /* 822414C4h */ case    5:  		/* nop */
		/* 822414C4h case    5:*/		cpu::op::nop();
		/* 822414C4h case    5:*/		return 0x822414C8;
	}
	return 0x822414C8;
} // Block from 822414B0h-822414C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822414C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822414C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822414C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822414C8);
		  /* 822414C8h */ case    0:  		/* mfspr R12, LR */
		/* 822414C8h case    0:*/		regs.R12 = regs.LR;
		/* 822414C8h case    0:*/		return 0x822414CC;
		  /* 822414CCh */ case    1:  		/* bl -1770096 */
		/* 822414CCh case    1:*/		regs.LR = 0x822414D0; return 0x8209125C;
		/* 822414CCh case    1:*/		return 0x822414D0;
		  /* 822414D0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 822414D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822414D0h case    2:*/		return 0x822414D4;
		  /* 822414D4h */ case    3:  		/* lwz R11, <#[R6 + 2736]> */
		/* 822414D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000AB0) );
		/* 822414D4h case    3:*/		return 0x822414D8;
		  /* 822414D8h */ case    4:  		/* mr R30, R3 */
		/* 822414D8h case    4:*/		regs.R30 = regs.R3;
		/* 822414D8h case    4:*/		return 0x822414DC;
		  /* 822414DCh */ case    5:  		/* lwz R10, <#[R3 + 168]> */
		/* 822414DCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000000A8) );
		/* 822414DCh case    5:*/		return 0x822414E0;
		  /* 822414E0h */ case    6:  		/* mr R31, R4 */
		/* 822414E0h case    6:*/		regs.R31 = regs.R4;
		/* 822414E0h case    6:*/		return 0x822414E4;
		  /* 822414E4h */ case    7:  		/* lwz R9, <#[R4 + 16]> */
		/* 822414E4h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000010) );
		/* 822414E4h case    7:*/		return 0x822414E8;
		  /* 822414E8h */ case    8:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 822414E8h case    8:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 822414E8h case    8:*/		return 0x822414EC;
		  /* 822414ECh */ case    9:  		/* lwz R29, <#[R11 + 8]> */
		/* 822414ECh case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000008) );
		/* 822414ECh case    9:*/		return 0x822414F0;
		  /* 822414F0h */ case   10:  		/* stwx R9, <#[R10 + R29]> */
		/* 822414F0h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 822414F0h case   10:*/		return 0x822414F4;
		  /* 822414F4h */ case   11:  		/* lwz R11, <#[R3 + 172]> */
		/* 822414F4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000AC) );
		/* 822414F4h case   11:*/		return 0x822414F8;
		  /* 822414F8h */ case   12:  		/* cmpwi CR6, R11, 6 */
		/* 822414F8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 822414F8h case   12:*/		return 0x822414FC;
		  /* 822414FCh */ case   13:  		/* bc 12, CR6_LT, 68 */
		/* 822414FCh case   13:*/		if ( regs.CR[6].lt ) { return 0x82241540;  }
		/* 822414FCh case   13:*/		return 0x82241500;
		  /* 82241500h */ case   14:  		/* lwz R11, <#[R4 + 24]> */
		/* 82241500h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 82241500h case   14:*/		return 0x82241504;
		  /* 82241504h */ case   15:  		/* mr R3, R4 */
		/* 82241504h case   15:*/		regs.R3 = regs.R4;
		/* 82241504h case   15:*/		return 0x82241508;
		  /* 82241508h */ case   16:  		/* lwz R10, <#[R4 + 20]> */
		/* 82241508h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 82241508h case   16:*/		return 0x8224150C;
		  /* 8224150Ch */ case   17:  		/* subf R4, R10, R11 */
		/* 8224150Ch case   17:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8224150Ch case   17:*/		return 0x82241510;
		  /* 82241510h */ case   18:  		/* bl -11144 */
		/* 82241510h case   18:*/		regs.LR = 0x82241514; return 0x8223E988;
		/* 82241510h case   18:*/		return 0x82241514;
		  /* 82241514h */ case   19:  		/* lwz R11, <#[R30 + 168]> */
		/* 82241514h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000A8) );
		/* 82241514h case   19:*/		return 0x82241518;
		  /* 82241518h */ case   20:  		/* lwz R9, <#[R31 + 24]> */
		/* 82241518h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 82241518h case   20:*/		return 0x8224151C;
		  /* 8224151Ch */ case   21:  		/* li R10, 1 */
		/* 8224151Ch case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8224151Ch case   21:*/		return 0x82241520;
		  /* 82241520h */ case   22:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82241520h case   22:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82241520h case   22:*/		return 0x82241524;
		  /* 82241524h */ case   23:  		/* add R11, R11, R29 */
		/* 82241524h case   23:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82241524h case   23:*/		return 0x82241528;
		  /* 82241528h */ case   24:  		/* stw R9, <#[R11 + 4]> */
		/* 82241528h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82241528h case   24:*/		return 0x8224152C;
		  /* 8224152Ch */ case   25:  		/* stb R10, <#[R31 + 48]> */
		/* 8224152Ch case   25:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 8224152Ch case   25:*/		return 0x82241530;
		  /* 82241530h */ case   26:  		/* lwz R11, <#[R31 + 24]> */
		/* 82241530h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82241530h case   26:*/		return 0x82241534;
		  /* 82241534h */ case   27:  		/* lwz R9, <#[R31 + 12]> */
		/* 82241534h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 82241534h case   27:*/		return 0x82241538;
		  /* 82241538h */ case   28:  		/* stw R9, <#[R31 + 36]> */
		/* 82241538h case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000024) );
		/* 82241538h case   28:*/		return 0x8224153C;
		  /* 8224153Ch */ case   29:  		/* stw R11, <#[R31 + 12]> */
		/* 8224153Ch case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224153Ch case   29:*/		return 0x82241540;
	}
	return 0x82241540;
} // Block from 822414C8h-82241540h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82241540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241540);
		  /* 82241540h */ case    0:  		/* addi R1, R1, 112 */
		/* 82241540h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82241540h case    0:*/		return 0x82241544;
		  /* 82241544h */ case    1:  		/* b -1770136 */
		/* 82241544h case    1:*/		return 0x820912AC;
		/* 82241544h case    1:*/		return 0x82241548;
	}
	return 0x82241548;
} // Block from 82241540h-82241548h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82241548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241548);
		  /* 82241548h */ case    0:  		/* mfspr R12, LR */
		/* 82241548h case    0:*/		regs.R12 = regs.LR;
		/* 82241548h case    0:*/		return 0x8224154C;
		  /* 8224154Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224154Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224154Ch case    1:*/		return 0x82241550;
		  /* 82241550h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82241550h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82241550h case    2:*/		return 0x82241554;
		  /* 82241554h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82241554h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82241554h case    3:*/		return 0x82241558;
		  /* 82241558h */ case    4:  		/* lbz R11, <#[R4 + 48]> */
		/* 82241558h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000030) );
		/* 82241558h case    4:*/		return 0x8224155C;
		  /* 8224155Ch */ case    5:  		/* mr R31, R4 */
		/* 8224155Ch case    5:*/		regs.R31 = regs.R4;
		/* 8224155Ch case    5:*/		return 0x82241560;
		  /* 82241560h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 82241560h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82241560h case    6:*/		return 0x82241564;
		  /* 82241564h */ case    7:  		/* bc 12, CR0_EQ, 36 */
		/* 82241564h case    7:*/		if ( regs.CR[0].eq ) { return 0x82241588;  }
		/* 82241564h case    7:*/		return 0x82241568;
		  /* 82241568h */ case    8:  		/* mr R3, R4 */
		/* 82241568h case    8:*/		regs.R3 = regs.R4;
		/* 82241568h case    8:*/		return 0x8224156C;
		  /* 8224156Ch */ case    9:  		/* bl -11084 */
		/* 8224156Ch case    9:*/		regs.LR = 0x82241570; return 0x8223EA20;
		/* 8224156Ch case    9:*/		return 0x82241570;
		  /* 82241570h */ case   10:  		/* li R11, 0 */
		/* 82241570h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82241570h case   10:*/		return 0x82241574;
		  /* 82241574h */ case   11:  		/* lwz R10, <#[R31 + 36]> */
		/* 82241574h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000024) );
		/* 82241574h case   11:*/		return 0x82241578;
		  /* 82241578h */ case   12:  		/* stb R11, <#[R31 + 48]> */
		/* 82241578h case   12:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82241578h case   12:*/		return 0x8224157C;
		  /* 8224157Ch */ case   13:  		/* lwz R11, <#[R31 + 12]> */
		/* 8224157Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224157Ch case   13:*/		return 0x82241580;
		  /* 82241580h */ case   14:  		/* stw R10, <#[R31 + 12]> */
		/* 82241580h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82241580h case   14:*/		return 0x82241584;
		  /* 82241584h */ case   15:  		/* stw R11, <#[R31 + 24]> */
		/* 82241584h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82241584h case   15:*/		return 0x82241588;
	}
	return 0x82241588;
} // Block from 82241548h-82241588h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82241588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241588);
		  /* 82241588h */ case    0:  		/* addi R1, R1, 96 */
		/* 82241588h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82241588h case    0:*/		return 0x8224158C;
		  /* 8224158Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224158Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224158Ch case    1:*/		return 0x82241590;
		  /* 82241590h */ case    2:  		/* mtspr LR, R12 */
		/* 82241590h case    2:*/		regs.LR = regs.R12;
		/* 82241590h case    2:*/		return 0x82241594;
		  /* 82241594h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82241594h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82241594h case    3:*/		return 0x82241598;
		  /* 82241598h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82241598h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82241598h case    4:*/		return 0x8224159C;
	}
	return 0x8224159C;
} // Block from 82241588h-8224159Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224159Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224159C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224159C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224159C);
		  /* 8224159Ch */ case    0:  		/* nop */
		/* 8224159Ch case    0:*/		cpu::op::nop();
		/* 8224159Ch case    0:*/		return 0x822415A0;
	}
	return 0x822415A0;
} // Block from 8224159Ch-822415A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822415A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822415A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822415A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822415A0);
		  /* 822415A0h */ case    0:  		/* mfspr R12, LR */
		/* 822415A0h case    0:*/		regs.R12 = regs.LR;
		/* 822415A0h case    0:*/		return 0x822415A4;
		  /* 822415A4h */ case    1:  		/* bl -1770312 */
		/* 822415A4h case    1:*/		regs.LR = 0x822415A8; return 0x8209125C;
		/* 822415A4h case    1:*/		return 0x822415A8;
		  /* 822415A8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 822415A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822415A8h case    2:*/		return 0x822415AC;
		  /* 822415ACh */ case    3:  		/* lwz R11, <#[R6 + 2736]> */
		/* 822415ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000AB0) );
		/* 822415ACh case    3:*/		return 0x822415B0;
		  /* 822415B0h */ case    4:  		/* mr R30, R3 */
		/* 822415B0h case    4:*/		regs.R30 = regs.R3;
		/* 822415B0h case    4:*/		return 0x822415B4;
		  /* 822415B4h */ case    5:  		/* lwz R10, <#[R4 + 16]> */
		/* 822415B4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 822415B4h case    5:*/		return 0x822415B8;
		  /* 822415B8h */ case    6:  		/* mr R31, R4 */
		/* 822415B8h case    6:*/		regs.R31 = regs.R4;
		/* 822415B8h case    6:*/		return 0x822415BC;
		  /* 822415BCh */ case    7:  		/* lwz R9, <#[R4 + 60]> */
		/* 822415BCh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x0000003C) );
		/* 822415BCh case    7:*/		return 0x822415C0;
		  /* 822415C0h */ case    8:  		/* lwz R29, <#[R11 + 8]> */
		/* 822415C0h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000008) );
		/* 822415C0h case    8:*/		return 0x822415C4;
		  /* 822415C4h */ case    9:  		/* stw R10, <#[R4 + 28]> */
		/* 822415C4h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x0000001C) );
		/* 822415C4h case    9:*/		return 0x822415C8;
		  /* 822415C8h */ case   10:  		/* stw R9, <#[R4 + 40]> */
		/* 822415C8h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x00000028) );
		/* 822415C8h case   10:*/		return 0x822415CC;
		  /* 822415CCh */ case   11:  		/* lwz R11, <#[R3 + 168]> */
		/* 822415CCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000A8) );
		/* 822415CCh case   11:*/		return 0x822415D0;
		  /* 822415D0h */ case   12:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 822415D0h case   12:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 822415D0h case   12:*/		return 0x822415D4;
		  /* 822415D4h */ case   13:  		/* lwzx R11, <#[R11 + R29]> */
		/* 822415D4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 822415D4h case   13:*/		return 0x822415D8;
		  /* 822415D8h */ case   14:  		/* stw R11, <#[R4 + 16]> */
		/* 822415D8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 822415D8h case   14:*/		return 0x822415DC;
		  /* 822415DCh */ case   15:  		/* lwz R11, <#[R3 + 172]> */
		/* 822415DCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000AC) );
		/* 822415DCh case   15:*/		return 0x822415E0;
		  /* 822415E0h */ case   16:  		/* cmpwi CR6, R11, 6 */
		/* 822415E0h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 822415E0h case   16:*/		return 0x822415E4;
		  /* 822415E4h */ case   17:  		/* bc 12, CR6_LT, 88 */
		/* 822415E4h case   17:*/		if ( regs.CR[6].lt ) { return 0x8224163C;  }
		/* 822415E4h case   17:*/		return 0x822415E8;
		  /* 822415E8h */ case   18:  		/* lwz R11, <#[R3 + 168]> */
		/* 822415E8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000A8) );
		/* 822415E8h case   18:*/		return 0x822415EC;
		  /* 822415ECh */ case   19:  		/* mr R3, R4 */
		/* 822415ECh case   19:*/		regs.R3 = regs.R4;
		/* 822415ECh case   19:*/		return 0x822415F0;
		  /* 822415F0h */ case   20:  		/* lwz R10, <#[R4 + 20]> */
		/* 822415F0h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 822415F0h case   20:*/		return 0x822415F4;
		  /* 822415F4h */ case   21:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 822415F4h case   21:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 822415F4h case   21:*/		return 0x822415F8;
		  /* 822415F8h */ case   22:  		/* add R11, R11, R29 */
		/* 822415F8h case   22:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 822415F8h case   22:*/		return 0x822415FC;
		  /* 822415FCh */ case   23:  		/* lwz R11, <#[R11 + 4]> */
		/* 822415FCh case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822415FCh case   23:*/		return 0x82241600;
		  /* 82241600h */ case   24:  		/* subf R4, R10, R11 */
		/* 82241600h case   24:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 82241600h case   24:*/		return 0x82241604;
		  /* 82241604h */ case   25:  		/* bl -11388 */
		/* 82241604h case   25:*/		regs.LR = 0x82241608; return 0x8223E988;
		/* 82241604h case   25:*/		return 0x82241608;
		  /* 82241608h */ case   26:  		/* lwz R10, <#[R31 + 24]> */
		/* 82241608h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82241608h case   26:*/		return 0x8224160C;
		  /* 8224160Ch */ case   27:  		/* lwz R9, <#[R31 + 56]> */
		/* 8224160Ch case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000038) );
		/* 8224160Ch case   27:*/		return 0x82241610;
		  /* 82241610h */ case   28:  		/* li R11, 1 */
		/* 82241610h case   28:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82241610h case   28:*/		return 0x82241614;
		  /* 82241614h */ case   29:  		/* stb R11, <#[R31 + 48]> */
		/* 82241614h case   29:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82241614h case   29:*/		return 0x82241618;
		  /* 82241618h */ case   30:  		/* stw R10, <#[R31 + 32]> */
		/* 82241618h case   30:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 82241618h case   30:*/		return 0x8224161C;
		  /* 8224161Ch */ case   31:  		/* stw R9, <#[R31 + 44]> */
		/* 8224161Ch case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000002C) );
		/* 8224161Ch case   31:*/		return 0x82241620;
		  /* 82241620h */ case   32:  		/* lwz R11, <#[R31 + 12]> */
		/* 82241620h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82241620h case   32:*/		return 0x82241624;
		  /* 82241624h */ case   33:  		/* stw R11, <#[R31 + 36]> */
		/* 82241624h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 82241624h case   33:*/		return 0x82241628;
		  /* 82241628h */ case   34:  		/* lwz R11, <#[R30 + 168]> */
		/* 82241628h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000A8) );
		/* 82241628h case   34:*/		return 0x8224162C;
		  /* 8224162Ch */ case   35:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8224162Ch case   35:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8224162Ch case   35:*/		return 0x82241630;
		  /* 82241630h */ case   36:  		/* add R11, R11, R29 */
		/* 82241630h case   36:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82241630h case   36:*/		return 0x82241634;
		  /* 82241634h */ case   37:  		/* lwz R11, <#[R11 + 4]> */
		/* 82241634h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82241634h case   37:*/		return 0x82241638;
		  /* 82241638h */ case   38:  		/* stw R11, <#[R31 + 12]> */
		/* 82241638h case   38:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82241638h case   38:*/		return 0x8224163C;
	}
	return 0x8224163C;
} // Block from 822415A0h-8224163Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 8224163Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224163C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224163C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224163C);
		  /* 8224163Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8224163Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224163Ch case    0:*/		return 0x82241640;
		  /* 82241640h */ case    1:  		/* b -1770388 */
		/* 82241640h case    1:*/		return 0x820912AC;
		/* 82241640h case    1:*/		return 0x82241644;
		  /* 82241644h */ case    2:  		/* nop */
		/* 82241644h case    2:*/		cpu::op::nop();
		/* 82241644h case    2:*/		return 0x82241648;
	}
	return 0x82241648;
} // Block from 8224163Ch-82241648h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82241648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241648);
		  /* 82241648h */ case    0:  		/* mfspr R12, LR */
		/* 82241648h case    0:*/		regs.R12 = regs.LR;
		/* 82241648h case    0:*/		return 0x8224164C;
		  /* 8224164Ch */ case    1:  		/* bl -1770480 */
		/* 8224164Ch case    1:*/		regs.LR = 0x82241650; return 0x8209125C;
		/* 8224164Ch case    1:*/		return 0x82241650;
		  /* 82241650h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82241650h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82241650h case    2:*/		return 0x82241654;
		  /* 82241654h */ case    3:  		/* lwz R11, <#[R3 + 20]> */
		/* 82241654h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82241654h case    3:*/		return 0x82241658;
		  /* 82241658h */ case    4:  		/* mr R31, R3 */
		/* 82241658h case    4:*/		regs.R31 = regs.R3;
		/* 82241658h case    4:*/		return 0x8224165C;
		  /* 8224165Ch */ case    5:  		/* li R30, 1 */
		/* 8224165Ch case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8224165Ch case    5:*/		return 0x82241660;
		  /* 82241660h */ case    6:  		/* cmpwi CR6, R11, 1 */
		/* 82241660h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82241660h case    6:*/		return 0x82241664;
		  /* 82241664h */ case    7:  		/* bc 12, CR6_LT, 72 */
		/* 82241664h case    7:*/		if ( regs.CR[6].lt ) { return 0x822416AC;  }
		/* 82241664h case    7:*/		return 0x82241668;
		  /* 82241668h */ case    8:  		/* addi R29, R3, 152 */
		/* 82241668h case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R3,0x98);
		/* 82241668h case    8:*/		return 0x8224166C;
		  /* 8224166Ch */ case    9:  		/* lbzx R11, <#[R29 + R30]> */
		/* 8224166Ch case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8224166Ch case    9:*/		return 0x82241670;
		  /* 82241670h */ case   10:  		/* cmplwi CR6, R11, 1 */
		/* 82241670h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82241670h case   10:*/		return 0x82241674;
		  /* 82241674h */ case   11:  		/* bc 12, CR6_EQ, 120 */
		/* 82241674h case   11:*/		if ( regs.CR[6].eq ) { return 0x822416EC;  }
		/* 82241674h case   11:*/		return 0x82241678;
		  /* 82241678h */ case   12:  		/* add R11, R30, R31 */
		/* 82241678h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R31);
		/* 82241678h case   12:*/		return 0x8224167C;
		  /* 8224167Ch */ case   13:  		/* lbz R11, <#[R11 + 158]> */
		/* 8224167Ch case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000009E) );
		/* 8224167Ch case   13:*/		return 0x82241680;
		  /* 82241680h */ case   14:  		/* cmplwi CR6, R11, 1 */
		/* 82241680h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82241680h case   14:*/		return 0x82241684;
		  /* 82241684h */ case   15:  		/* bc 12, CR6_EQ, 104 */
		/* 82241684h case   15:*/		if ( regs.CR[6].eq ) { return 0x822416EC;  }
		/* 82241684h case   15:*/		return 0x82241688;
		  /* 82241688h */ case   16:  		/* mr R4, R30 */
		/* 82241688h case   16:*/		regs.R4 = regs.R30;
		/* 82241688h case   16:*/		return 0x8224168C;
		  /* 8224168Ch */ case   17:  		/* mr R3, R31 */
		/* 8224168Ch case   17:*/		regs.R3 = regs.R31;
		/* 8224168Ch case   17:*/		return 0x82241690;
		  /* 82241690h */ case   18:  		/* bl 86624 */
		/* 82241690h case   18:*/		regs.LR = 0x82241694; return 0x822568F0;
		/* 82241690h case   18:*/		return 0x82241694;
		  /* 82241694h */ case   19:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82241694h case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82241694h case   19:*/		return 0x82241698;
		  /* 82241698h */ case   20:  		/* bc 4, CR0_EQ, 84 */
		/* 82241698h case   20:*/		if ( !regs.CR[0].eq ) { return 0x822416EC;  }
		/* 82241698h case   20:*/		return 0x8224169C;
		  /* 8224169Ch */ case   21:  		/* lwz R11, <#[R31 + 20]> */
		/* 8224169Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8224169Ch case   21:*/		return 0x822416A0;
		  /* 822416A0h */ case   22:  		/* addi R30, R30, 1 */
		/* 822416A0h case   22:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822416A0h case   22:*/		return 0x822416A4;
		  /* 822416A4h */ case   23:  		/* cmpw CR6, R30, R11 */
		/* 822416A4h case   23:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 822416A4h case   23:*/		return 0x822416A8;
		  /* 822416A8h */ case   24:  		/* bc 4, CR6_GT, -60 */
		/* 822416A8h case   24:*/		if ( !regs.CR[6].gt ) { return 0x8224166C;  }
		/* 822416A8h case   24:*/		return 0x822416AC;
	}
	return 0x822416AC;
} // Block from 82241648h-822416ACh (25 instructions)

//////////////////////////////////////////////////////
// Block at 822416ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822416AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822416AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822416AC);
		  /* 822416ACh */ case    0:  		/* lbz R11, <#[R31 + 164]> */
		/* 822416ACh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000A4) );
		/* 822416ACh case    0:*/		return 0x822416B0;
		  /* 822416B0h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 822416B0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 822416B0h case    1:*/		return 0x822416B4;
		  /* 822416B4h */ case    2:  		/* bc 12, CR6_EQ, 56 */
		/* 822416B4h case    2:*/		if ( regs.CR[6].eq ) { return 0x822416EC;  }
		/* 822416B4h case    2:*/		return 0x822416B8;
		  /* 822416B8h */ case    3:  		/* lwz R11, <#[R31 + 228]> */
		/* 822416B8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 822416B8h case    3:*/		return 0x822416BC;
		  /* 822416BCh */ case    4:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 822416BCh case    4:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 822416BCh case    4:*/		return 0x822416C0;
		  /* 822416C0h */ case    5:  		/* bc 4, CR0_EQ, 44 */
		/* 822416C0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x822416EC;  }
		/* 822416C0h case    5:*/		return 0x822416C4;
		  /* 822416C4h */ case    6:  		/* mr R3, R31 */
		/* 822416C4h case    6:*/		regs.R3 = regs.R31;
		/* 822416C4h case    6:*/		return 0x822416C8;
		  /* 822416C8h */ case    7:  		/* bl -11056 */
		/* 822416C8h case    7:*/		regs.LR = 0x822416CC; return 0x8223EB98;
		/* 822416C8h case    7:*/		return 0x822416CC;
		  /* 822416CCh */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822416CCh case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822416CCh case    8:*/		return 0x822416D0;
		  /* 822416D0h */ case    9:  		/* bc 4, CR0_EQ, 28 */
		/* 822416D0h case    9:*/		if ( !regs.CR[0].eq ) { return 0x822416EC;  }
		/* 822416D0h case    9:*/		return 0x822416D4;
		  /* 822416D4h */ case   10:  		/* li R4, 0 */
		/* 822416D4h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822416D4h case   10:*/		return 0x822416D8;
		  /* 822416D8h */ case   11:  		/* mr R3, R31 */
		/* 822416D8h case   11:*/		regs.R3 = regs.R31;
		/* 822416D8h case   11:*/		return 0x822416DC;
		  /* 822416DCh */ case   12:  		/* bl 84740 */
		/* 822416DCh case   12:*/		regs.LR = 0x822416E0; return 0x822561E0;
		/* 822416DCh case   12:*/		return 0x822416E0;
		  /* 822416E0h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 822416E0h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822416E0h case   13:*/		return 0x822416E4;
		  /* 822416E4h */ case   14:  		/* li R3, 1 */
		/* 822416E4h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822416E4h case   14:*/		return 0x822416E8;
		  /* 822416E8h */ case   15:  		/* bc 12, CR0_EQ, 8 */
		/* 822416E8h case   15:*/		if ( regs.CR[0].eq ) { return 0x822416F0;  }
		/* 822416E8h case   15:*/		return 0x822416EC;
	}
	return 0x822416EC;
} // Block from 822416ACh-822416ECh (16 instructions)

//////////////////////////////////////////////////////
// Block at 822416ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822416EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822416EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822416EC);
		  /* 822416ECh */ case    0:  		/* li R3, 0 */
		/* 822416ECh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822416ECh case    0:*/		return 0x822416F0;
	}
	return 0x822416F0;
} // Block from 822416ECh-822416F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822416F0h
// Function '?AssembleDest@IRAlu@XGRAPHICS@@IAAXPAD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822416F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822416F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822416F0);
		  /* 822416F0h */ case    0:  		/* addi R1, R1, 112 */
		/* 822416F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822416F0h case    0:*/		return 0x822416F4;
		  /* 822416F4h */ case    1:  		/* b -1770568 */
		/* 822416F4h case    1:*/		return 0x820912AC;
		/* 822416F4h case    1:*/		return 0x822416F8;
	}
	return 0x822416F8;
} // Block from 822416F0h-822416F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822416F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822416F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822416F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822416F8);
		  /* 822416F8h */ case    0:  		/* mfspr R12, LR */
		/* 822416F8h case    0:*/		regs.R12 = regs.LR;
		/* 822416F8h case    0:*/		return 0x822416FC;
		  /* 822416FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822416FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822416FCh case    1:*/		return 0x82241700;
		  /* 82241700h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82241700h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82241700h case    2:*/		return 0x82241704;
		  /* 82241704h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82241704h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82241704h case    3:*/		return 0x82241708;
		  /* 82241708h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 82241708h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82241708h case    4:*/		return 0x8224170C;
		  /* 8224170Ch */ case    5:  		/* mr R31, R3 */
		/* 8224170Ch case    5:*/		regs.R31 = regs.R3;
		/* 8224170Ch case    5:*/		return 0x82241710;
		  /* 82241710h */ case    6:  		/* lwz R11, <#[R11 + 76]> */
		/* 82241710h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 82241710h case    6:*/		return 0x82241714;
		  /* 82241714h */ case    7:  		/* mtspr CTR, R11 */
		/* 82241714h case    7:*/		regs.CTR = regs.R11;
		/* 82241714h case    7:*/		return 0x82241718;
		  /* 82241718h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 82241718h case    8:*/		if ( 1 ) { regs.LR = 0x8224171C; return (uint32)regs.CTR; }
		/* 82241718h case    8:*/		return 0x8224171C;
		  /* 8224171Ch */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224171Ch case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224171Ch case    9:*/		return 0x82241720;
		  /* 82241720h */ case   10:  		/* bc 12, CR0_EQ, 36 */
		/* 82241720h case   10:*/		if ( regs.CR[0].eq ) { return 0x82241744;  }
		/* 82241720h case   10:*/		return 0x82241724;
		  /* 82241724h */ case   11:  		/* mr R3, R31 */
		/* 82241724h case   11:*/		regs.R3 = regs.R31;
		/* 82241724h case   11:*/		return 0x82241728;
		  /* 82241728h */ case   12:  		/* bl -224 */
		/* 82241728h case   12:*/		regs.LR = 0x8224172C; return 0x82241648;
		/* 82241728h case   12:*/		return 0x8224172C;
		  /* 8224172Ch */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224172Ch case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224172Ch case   13:*/		return 0x82241730;
		  /* 82241730h */ case   14:  		/* bc 12, CR0_EQ, 20 */
		/* 82241730h case   14:*/		if ( regs.CR[0].eq ) { return 0x82241744;  }
		/* 82241730h case   14:*/		return 0x82241734;
		  /* 82241734h */ case   15:  		/* lwz R11, <#[R31 + 228]> */
		/* 82241734h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82241734h case   15:*/		return 0x82241738;
		  /* 82241738h */ case   16:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82241738h case   16:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82241738h case   16:*/		return 0x8224173C;
		  /* 8224173Ch */ case   17:  		/* li R11, 1 */
		/* 8224173Ch case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224173Ch case   17:*/		return 0x82241740;
		  /* 82241740h */ case   18:  		/* bc 12, CR0_EQ, 8 */
		/* 82241740h case   18:*/		if ( regs.CR[0].eq ) { return 0x82241748;  }
		/* 82241740h case   18:*/		return 0x82241744;
	}
	return 0x82241744;
} // Block from 822416F8h-82241744h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82241744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241744);
		  /* 82241744h */ case    0:  		/* li R11, 0 */
		/* 82241744h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82241744h case    0:*/		return 0x82241748;
	}
	return 0x82241748;
} // Block from 82241744h-82241748h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82241748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241748);
		  /* 82241748h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82241748h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82241748h case    0:*/		return 0x8224174C;
		  /* 8224174Ch */ case    1:  		/* addi R1, R1, 96 */
		/* 8224174Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8224174Ch case    1:*/		return 0x82241750;
		  /* 82241750h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82241750h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82241750h case    2:*/		return 0x82241754;
		  /* 82241754h */ case    3:  		/* mtspr LR, R12 */
		/* 82241754h case    3:*/		regs.LR = regs.R12;
		/* 82241754h case    3:*/		return 0x82241758;
		  /* 82241758h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82241758h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82241758h case    4:*/		return 0x8224175C;
		  /* 8224175Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8224175Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224175Ch case    5:*/		return 0x82241760;
	}
	return 0x82241760;
} // Block from 82241748h-82241760h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82241760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241760);
		  /* 82241760h */ case    0:  		/* mfspr R12, LR */
		/* 82241760h case    0:*/		regs.R12 = regs.LR;
		/* 82241760h case    0:*/		return 0x82241764;
		  /* 82241764h */ case    1:  		/* bl -1770760 */
		/* 82241764h case    1:*/		regs.LR = 0x82241768; return 0x8209125C;
		/* 82241764h case    1:*/		return 0x82241768;
		  /* 82241768h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82241768h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82241768h case    2:*/		return 0x8224176C;
		  /* 8224176Ch */ case    3:  		/* mr R31, R3 */
		/* 8224176Ch case    3:*/		regs.R31 = regs.R3;
		/* 8224176Ch case    3:*/		return 0x82241770;
		  /* 82241770h */ case    4:  		/* bl -120 */
		/* 82241770h case    4:*/		regs.LR = 0x82241774; return 0x822416F8;
		/* 82241770h case    4:*/		return 0x82241774;
		  /* 82241774h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82241774h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82241774h case    5:*/		return 0x82241778;
		  /* 82241778h */ case    6:  		/* bc 12, CR0_EQ, 188 */
		/* 82241778h case    6:*/		if ( regs.CR[0].eq ) { return 0x82241834;  }
		/* 82241778h case    6:*/		return 0x8224177C;
		  /* 8224177Ch */ case    7:  		/* lwz R10, <#[R31 + 16]> */
		/* 8224177Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 8224177Ch case    7:*/		return 0x82241780;
		  /* 82241780h */ case    8:  		/* lis R11, -32251 */
		/* 82241780h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82241780h case    8:*/		return 0x82241784;
		  /* 82241784h */ case    9:  		/* cmpwi CR6, R10, 0 */
		/* 82241784h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82241784h case    9:*/		return 0x82241788;
		  /* 82241788h */ case   10:  		/* addi R10, R11, -19064 */
		/* 82241788h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFB588);
		/* 82241788h case   10:*/		return 0x8224178C;
		  /* 8224178Ch */ case   11:  		/* bc 12, CR6_EQ, 44 */
		/* 8224178Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x822417B8;  }
		/* 8224178Ch case   11:*/		return 0x82241790;
		  /* 82241790h */ case   12:  		/* lwz R11, <#[R31 + 228]> */
		/* 82241790h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82241790h case   12:*/		return 0x82241794;
		  /* 82241794h */ case   13:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82241794h case   13:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82241794h case   13:*/		return 0x82241798;
		  /* 82241798h */ case   14:  		/* bc 4, CR0_EQ, 32 */
		/* 82241798h case   14:*/		if ( !regs.CR[0].eq ) { return 0x822417B8;  }
		/* 82241798h case   14:*/		return 0x8224179C;
		  /* 8224179Ch */ case   15:  		/* lwz R11, <#[R31 + 80]> */
		/* 8224179Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8224179Ch case   15:*/		return 0x822417A0;
		  /* 822417A0h */ case   16:  		/* addi R9, R10, 4 */
		/* 822417A0h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 822417A0h case   16:*/		return 0x822417A4;
		  /* 822417A4h */ case   17:  		/* mulli R11, R11, 12 */
		/* 822417A4h case   17:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 822417A4h case   17:*/		return 0x822417A8;
		  /* 822417A8h */ case   18:  		/* lbzx R11, <#[R11 + R9]> */
		/* 822417A8h case   18:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 822417A8h case   18:*/		return 0x822417AC;
		  /* 822417ACh */ case   19:  		/* cmplwi CR0, R11, 0 */
		/* 822417ACh case   19:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822417ACh case   19:*/		return 0x822417B0;
		  /* 822417B0h */ case   20:  		/* li R11, 1 */
		/* 822417B0h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822417B0h case   20:*/		return 0x822417B4;
		  /* 822417B4h */ case   21:  		/* bc 4, CR0_EQ, 8 */
		/* 822417B4h case   21:*/		if ( !regs.CR[0].eq ) { return 0x822417BC;  }
		/* 822417B4h case   21:*/		return 0x822417B8;
	}
	return 0x822417B8;
} // Block from 82241760h-822417B8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 822417B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822417B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822417B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822417B8);
		  /* 822417B8h */ case    0:  		/* li R11, 0 */
		/* 822417B8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822417B8h case    0:*/		return 0x822417BC;
	}
	return 0x822417BC;
} // Block from 822417B8h-822417BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822417BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822417BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822417BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822417BC);
		  /* 822417BCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822417BCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822417BCh case    0:*/		return 0x822417C0;
		  /* 822417C0h */ case    1:  		/* bc 12, CR0_EQ, 116 */
		/* 822417C0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82241834;  }
		/* 822417C0h case    1:*/		return 0x822417C4;
		  /* 822417C4h */ case    2:  		/* lwz R4, <#[R31 + 236]> */
		/* 822417C4h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000000EC) );
		/* 822417C4h case    2:*/		return 0x822417C8;
		  /* 822417C8h */ case    3:  		/* lwz R11, <#[R4 + 16]> */
		/* 822417C8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 822417C8h case    3:*/		return 0x822417CC;
		  /* 822417CCh */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 822417CCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822417CCh case    4:*/		return 0x822417D0;
		  /* 822417D0h */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 822417D0h case    5:*/		if ( regs.CR[6].eq ) { return 0x822417FC;  }
		/* 822417D0h case    5:*/		return 0x822417D4;
		  /* 822417D4h */ case    6:  		/* lwz R11, <#[R4 + 228]> */
		/* 822417D4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x000000E4) );
		/* 822417D4h case    6:*/		return 0x822417D8;
		  /* 822417D8h */ case    7:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 822417D8h case    7:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 822417D8h case    7:*/		return 0x822417DC;
		  /* 822417DCh */ case    8:  		/* bc 4, CR0_EQ, 32 */
		/* 822417DCh case    8:*/		if ( !regs.CR[0].eq ) { return 0x822417FC;  }
		/* 822417DCh case    8:*/		return 0x822417E0;
		  /* 822417E0h */ case    9:  		/* lwz R11, <#[R4 + 80]> */
		/* 822417E0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000050) );
		/* 822417E0h case    9:*/		return 0x822417E4;
		  /* 822417E4h */ case   10:  		/* addi R10, R10, 4 */
		/* 822417E4h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 822417E4h case   10:*/		return 0x822417E8;
		  /* 822417E8h */ case   11:  		/* mulli R11, R11, 12 */
		/* 822417E8h case   11:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 822417E8h case   11:*/		return 0x822417EC;
		  /* 822417ECh */ case   12:  		/* lbzx R11, <#[R11 + R10]> */
		/* 822417ECh case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822417ECh case   12:*/		return 0x822417F0;
		  /* 822417F0h */ case   13:  		/* cmplwi CR0, R11, 0 */
		/* 822417F0h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822417F0h case   13:*/		return 0x822417F4;
		  /* 822417F4h */ case   14:  		/* li R11, 1 */
		/* 822417F4h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822417F4h case   14:*/		return 0x822417F8;
		  /* 822417F8h */ case   15:  		/* bc 4, CR0_EQ, 8 */
		/* 822417F8h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82241800;  }
		/* 822417F8h case   15:*/		return 0x822417FC;
	}
	return 0x822417FC;
} // Block from 822417BCh-822417FCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 822417FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822417FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822417FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822417FC);
		  /* 822417FCh */ case    0:  		/* li R11, 0 */
		/* 822417FCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822417FCh case    0:*/		return 0x82241800;
	}
	return 0x82241800;
} // Block from 822417FCh-82241800h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82241800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241800);
		  /* 82241800h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82241800h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82241800h case    0:*/		return 0x82241804;
		  /* 82241804h */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 82241804h case    1:*/		if ( regs.CR[0].eq ) { return 0x82241834;  }
		/* 82241804h case    1:*/		return 0x82241808;
		  /* 82241808h */ case    2:  		/* lwz R11, <#[R31 + 952]> */
		/* 82241808h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000003B8) );
		/* 82241808h case    2:*/		return 0x8224180C;
		  /* 8224180Ch */ case    3:  		/* lwz R30, <#[R11 + 2736]> */
		/* 8224180Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000AB0) );
		/* 8224180Ch case    3:*/		return 0x82241810;
		  /* 82241810h */ case    4:  		/* mr R3, R30 */
		/* 82241810h case    4:*/		regs.R3 = regs.R30;
		/* 82241810h case    4:*/		return 0x82241814;
		  /* 82241814h */ case    5:  		/* bl 142292 */
		/* 82241814h case    5:*/		regs.LR = 0x82241818; return 0x822643E8;
		/* 82241814h case    5:*/		return 0x82241818;
		  /* 82241818h */ case    6:  		/* mr R29, R3 */
		/* 82241818h case    6:*/		regs.R29 = regs.R3;
		/* 82241818h case    6:*/		return 0x8224181C;
		  /* 8224181Ch */ case    7:  		/* mr R4, R31 */
		/* 8224181Ch case    7:*/		regs.R4 = regs.R31;
		/* 8224181Ch case    7:*/		return 0x82241820;
		  /* 82241820h */ case    8:  		/* mr R3, R30 */
		/* 82241820h case    8:*/		regs.R3 = regs.R30;
		/* 82241820h case    8:*/		return 0x82241824;
		  /* 82241824h */ case    9:  		/* bl 142276 */
		/* 82241824h case    9:*/		regs.LR = 0x82241828; return 0x822643E8;
		/* 82241824h case    9:*/		return 0x82241828;
		  /* 82241828h */ case   10:  		/* cmpw CR6, R3, R29 */
		/* 82241828h case   10:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R29);
		/* 82241828h case   10:*/		return 0x8224182C;
		  /* 8224182Ch */ case   11:  		/* li R11, 1 */
		/* 8224182Ch case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224182Ch case   11:*/		return 0x82241830;
		  /* 82241830h */ case   12:  		/* bc 12, CR6_EQ, 8 */
		/* 82241830h case   12:*/		if ( regs.CR[6].eq ) { return 0x82241838;  }
		/* 82241830h case   12:*/		return 0x82241834;
	}
	return 0x82241834;
} // Block from 82241800h-82241834h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82241834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241834);
		  /* 82241834h */ case    0:  		/* li R11, 0 */
		/* 82241834h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82241834h case    0:*/		return 0x82241838;
	}
	return 0x82241838;
} // Block from 82241834h-82241838h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82241838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241838);
		  /* 82241838h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82241838h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82241838h case    0:*/		return 0x8224183C;
		  /* 8224183Ch */ case    1:  		/* addi R1, R1, 112 */
		/* 8224183Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224183Ch case    1:*/		return 0x82241840;
		  /* 82241840h */ case    2:  		/* b -1770900 */
		/* 82241840h case    2:*/		return 0x820912AC;
		/* 82241840h case    2:*/		return 0x82241844;
		  /* 82241844h */ case    3:  		/* nop */
		/* 82241844h case    3:*/		cpu::op::nop();
		/* 82241844h case    3:*/		return 0x82241848;
	}
	return 0x82241848;
} // Block from 82241838h-82241848h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82241848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241848);
		  /* 82241848h */ case    0:  		/* mfspr R12, LR */
		/* 82241848h case    0:*/		regs.R12 = regs.LR;
		/* 82241848h case    0:*/		return 0x8224184C;
		  /* 8224184Ch */ case    1:  		/* bl -1770992 */
		/* 8224184Ch case    1:*/		regs.LR = 0x82241850; return 0x8209125C;
		/* 8224184Ch case    1:*/		return 0x82241850;
		  /* 82241850h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82241850h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82241850h case    2:*/		return 0x82241854;
		  /* 82241854h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 82241854h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82241854h case    3:*/		return 0x82241858;
		  /* 82241858h */ case    4:  		/* mr R30, R3 */
		/* 82241858h case    4:*/		regs.R30 = regs.R3;
		/* 82241858h case    4:*/		return 0x8224185C;
		  /* 8224185Ch */ case    5:  		/* lis R10, -32252 */
		/* 8224185Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224185Ch case    5:*/		return 0x82241860;
		  /* 82241860h */ case    6:  		/* add R31, R11, R4 */
		/* 82241860h case    6:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R4);
		/* 82241860h case    6:*/		return 0x82241864;
		  /* 82241864h */ case    7:  		/* mr R3, R5 */
		/* 82241864h case    7:*/		regs.R3 = regs.R5;
		/* 82241864h case    7:*/		return 0x82241868;
		  /* 82241868h */ case    8:  		/* addi R4, R10, 11416 */
		/* 82241868h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x2C98);
		/* 82241868h case    8:*/		return 0x8224186C;
		  /* 8224186Ch */ case    9:  		/* mr R6, R31 */
		/* 8224186Ch case    9:*/		regs.R6 = regs.R31;
		/* 8224186Ch case    9:*/		return 0x82241870;
		  /* 82241870h */ case   10:  		/* lwz R7, <#[R30 + 12]> */
		/* 82241870h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x0000000C) );
		/* 82241870h case   10:*/		return 0x82241874;
		  /* 82241874h */ case   11:  		/* mr R29, R5 */
		/* 82241874h case   11:*/		regs.R29 = regs.R5;
		/* 82241874h case   11:*/		return 0x82241878;
		  /* 82241878h */ case   12:  		/* lwz R5, <#[R30 + 4]> */
		/* 82241878h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000004) );
		/* 82241878h case   12:*/		return 0x8224187C;
		  /* 8224187Ch */ case   13:  		/* bl -148668 */
		/* 8224187Ch case   13:*/		regs.LR = 0x82241880; return 0x8221D3C0;
		/* 8224187Ch case   13:*/		return 0x82241880;
		  /* 82241880h */ case   14:  		/* lwz R3, <#[R29 + 1488]> */
		/* 82241880h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x000005D0) );
		/* 82241880h case   14:*/		return 0x82241884;
		  /* 82241884h */ case   15:  		/* mr R5, R31 */
		/* 82241884h case   15:*/		regs.R5 = regs.R31;
		/* 82241884h case   15:*/		return 0x82241888;
		  /* 82241888h */ case   16:  		/* lwz R7, <#[R30 + 12]> */
		/* 82241888h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x0000000C) );
		/* 82241888h case   16:*/		return 0x8224188C;
		  /* 8224188Ch */ case   17:  		/* mr R6, R29 */
		/* 8224188Ch case   17:*/		regs.R6 = regs.R29;
		/* 8224188Ch case   17:*/		return 0x82241890;
		  /* 82241890h */ case   18:  		/* lwz R4, <#[R30 + 4]> */
		/* 82241890h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000004) );
		/* 82241890h case   18:*/		return 0x82241894;
		  /* 82241894h */ case   19:  		/* lwz R11, <#[R3]> */
		/* 82241894h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82241894h case   19:*/		return 0x82241898;
		  /* 82241898h */ case   20:  		/* lwz R11, <#[R11 + 24]> */
		/* 82241898h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82241898h case   20:*/		return 0x8224189C;
		  /* 8224189Ch */ case   21:  		/* mtspr CTR, R11 */
		/* 8224189Ch case   21:*/		regs.CTR = regs.R11;
		/* 8224189Ch case   21:*/		return 0x822418A0;
		  /* 822418A0h */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 822418A0h case   22:*/		if ( 1 ) { regs.LR = 0x822418A4; return (uint32)regs.CTR; }
		/* 822418A0h case   22:*/		return 0x822418A4;
		  /* 822418A4h */ case   23:  		/* addi R1, R1, 112 */
		/* 822418A4h case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822418A4h case   23:*/		return 0x822418A8;
		  /* 822418A8h */ case   24:  		/* b -1771004 */
		/* 822418A8h case   24:*/		return 0x820912AC;
		/* 822418A8h case   24:*/		return 0x822418AC;
		  /* 822418ACh */ case   25:  		/* nop */
		/* 822418ACh case   25:*/		cpu::op::nop();
		/* 822418ACh case   25:*/		return 0x822418B0;
	}
	return 0x822418B0;
} // Block from 82241848h-822418B0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 822418B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822418B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822418B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822418B0);
		  /* 822418B0h */ case    0:  		/* mfspr R12, LR */
		/* 822418B0h case    0:*/		regs.R12 = regs.LR;
		/* 822418B0h case    0:*/		return 0x822418B4;
		  /* 822418B4h */ case    1:  		/* bl -1771156 */
		/* 822418B4h case    1:*/		regs.LR = 0x822418B8; return 0x82091220;
		/* 822418B4h case    1:*/		return 0x822418B8;
		  /* 822418B8h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 822418B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 822418B8h case    2:*/		return 0x822418BC;
		  /* 822418BCh */ case    3:  		/* lwz R28, <#[R4 + 8]> */
		/* 822418BCh case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R4 + 0x00000008) );
		/* 822418BCh case    3:*/		return 0x822418C0;
		  /* 822418C0h */ case    4:  		/* mr R31, R3 */
		/* 822418C0h case    4:*/		regs.R31 = regs.R3;
		/* 822418C0h case    4:*/		return 0x822418C4;
		  /* 822418C4h */ case    5:  		/* mr R30, R4 */
		/* 822418C4h case    5:*/		regs.R30 = regs.R4;
		/* 822418C4h case    5:*/		return 0x822418C8;
		  /* 822418C8h */ case    6:  		/* stw R4, <#[R1 + 284]> */
		/* 822418C8h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000011C) );
		/* 822418C8h case    6:*/		return 0x822418CC;
		  /* 822418CCh */ case    7:  		/* stb R5, <#[R1 + 295]> */
		/* 822418CCh case    7:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R1 + 0x00000127) );
		/* 822418CCh case    7:*/		return 0x822418D0;
		  /* 822418D0h */ case    8:  		/* li R26, 0 */
		/* 822418D0h case    8:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 822418D0h case    8:*/		return 0x822418D4;
		  /* 822418D4h */ case    9:  		/* li R24, 0 */
		/* 822418D4h case    9:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 822418D4h case    9:*/		return 0x822418D8;
		  /* 822418D8h */ case   10:  		/* li R19, 0 */
		/* 822418D8h case   10:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 822418D8h case   10:*/		return 0x822418DC;
		  /* 822418DCh */ case   11:  		/* lwz R11, <#[R28 + 8]> */
		/* 822418DCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 822418DCh case   11:*/		return 0x822418E0;
		  /* 822418E0h */ case   12:  		/* li R27, 0 */
		/* 822418E0h case   12:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 822418E0h case   12:*/		return 0x822418E4;
		  /* 822418E4h */ case   13:  		/* li R23, 0 */
		/* 822418E4h case   13:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 822418E4h case   13:*/		return 0x822418E8;
		  /* 822418E8h */ case   14:  		/* stw R28, <#[R1 + 80]> */
		/* 822418E8h case   14:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 822418E8h case   14:*/		return 0x822418EC;
		  /* 822418ECh */ case   15:  		/* li R18, 0 */
		/* 822418ECh case   15:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 822418ECh case   15:*/		return 0x822418F0;
		  /* 822418F0h */ case   16:  		/* cmpwi CR6, R11, 0 */
		/* 822418F0h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822418F0h case   16:*/		return 0x822418F4;
		  /* 822418F4h */ case   17:  		/* bc 12, CR6_EQ, 1572 */
		/* 822418F4h case   17:*/		if ( regs.CR[6].eq ) { return 0x82241F18;  }
		/* 822418F4h case   17:*/		return 0x822418F8;
		  /* 822418F8h */ case   18:  		/* lis R8, -32252 */
		/* 822418F8h case   18:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 822418F8h case   18:*/		return 0x822418FC;
		  /* 822418FCh */ case   19:  		/* lis R10, -32252 */
		/* 822418FCh case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822418FCh case   19:*/		return 0x82241900;
		  /* 82241900h */ case   20:  		/* lis R7, -32252 */
		/* 82241900h case   20:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8204);
		/* 82241900h case   20:*/		return 0x82241904;
		  /* 82241904h */ case   21:  		/* lis R6, -32216 */
		/* 82241904h case   21:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8228);
		/* 82241904h case   21:*/		return 0x82241908;
		  /* 82241908h */ case   22:  		/* lis R5, -32252 */
		/* 82241908h case   22:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8204);
		/* 82241908h case   22:*/		return 0x8224190C;
		  /* 8224190Ch */ case   23:  		/* lis R4, -32252 */
		/* 8224190Ch case   23:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8204);
		/* 8224190Ch case   23:*/		return 0x82241910;
		  /* 82241910h */ case   24:  		/* lis R3, -32252 */
		/* 82241910h case   24:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8204);
		/* 82241910h case   24:*/		return 0x82241914;
		  /* 82241914h */ case   25:  		/* lis R9, -32253 */
		/* 82241914h case   25:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82241914h case   25:*/		return 0x82241918;
		  /* 82241918h */ case   26:  		/* lis R11, -32252 */
		/* 82241918h case   26:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82241918h case   26:*/		return 0x8224191C;
		  /* 8224191Ch */ case   27:  		/* addi R8, R8, 11572 */
		/* 8224191Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x2D34);
		/* 8224191Ch case   27:*/		return 0x82241920;
		  /* 82241920h */ case   28:  		/* addi R10, R10, 11528 */
		/* 82241920h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2D08);
		/* 82241920h case   28:*/		return 0x82241924;
		  /* 82241924h */ case   29:  		/* li R25, 1 */
		/* 82241924h case   29:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 82241924h case   29:*/		return 0x82241928;
		  /* 82241928h */ case   30:  		/* stw R8, <#[R1 + 88]> */
		/* 82241928h case   30:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000058) );
		/* 82241928h case   30:*/		return 0x8224192C;
		  /* 8224192Ch */ case   31:  		/* addi R17, R7, 25976 */
		/* 8224192Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R7,0x6578);
		/* 8224192Ch case   31:*/		return 0x82241930;
		  /* 82241930h */ case   32:  		/* stw R10, <#[R1 + 84]> */
		/* 82241930h case   32:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82241930h case   32:*/		return 0x82241934;
		  /* 82241934h */ case   33:  		/* addi R20, R6, 17992 */
		/* 82241934h case   33:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R6,0x4648);
		/* 82241934h case   33:*/		return 0x82241938;
		  /* 82241938h */ case   34:  		/* addi R16, R5, 10532 */
		/* 82241938h case   34:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R5,0x2924);
		/* 82241938h case   34:*/		return 0x8224193C;
		  /* 8224193Ch */ case   35:  		/* addi R15, R4, 11504 */
		/* 8224193Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R4,0x2CF0);
		/* 8224193Ch case   35:*/		return 0x82241940;
		  /* 82241940h */ case   36:  		/* addi R14, R3, 11480 */
		/* 82241940h case   36:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R3,0x2CD8);
		/* 82241940h case   36:*/		return 0x82241944;
		  /* 82241944h */ case   37:  		/* addi R22, R9, 27460 */
		/* 82241944h case   37:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R9,0x6B44);
		/* 82241944h case   37:*/		return 0x82241948;
		  /* 82241948h */ case   38:  		/* addi R21, R11, 10344 */
		/* 82241948h case   38:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R11,0x2868);
		/* 82241948h case   38:*/		return 0x8224194C;
		  /* 8224194Ch */ case   39:  		/* lwz R11, <#[R28 + 228]> */
		/* 8224194Ch case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 8224194Ch case   39:*/		return 0x82241950;
		  /* 82241950h */ case   40:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82241950h case   40:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82241950h case   40:*/		return 0x82241954;
		  /* 82241954h */ case   41:  		/* bc 12, CR0_EQ, 1456 */
		/* 82241954h case   41:*/		if ( regs.CR[0].eq ) { return 0x82241F04;  }
		/* 82241954h case   41:*/		return 0x82241958;
		  /* 82241958h */ case   42:  		/* lwz R11, <#[R28 + 24]> */
		/* 82241958h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 82241958h case   42:*/		return 0x8224195C;
		  /* 8224195Ch */ case   43:  		/* cmpwi CR6, R11, 50 */
		/* 8224195Ch case   43:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000032);
		/* 8224195Ch case   43:*/		return 0x82241960;
		  /* 82241960h */ case   44:  		/* bc 4, CR6_EQ, 24 */
		/* 82241960h case   44:*/		if ( !regs.CR[6].eq ) { return 0x82241978;  }
		/* 82241960h case   44:*/		return 0x82241964;
		  /* 82241964h */ case   45:  		/* mr R4, R28 */
		/* 82241964h case   45:*/		regs.R4 = regs.R28;
		/* 82241964h case   45:*/		return 0x82241968;
		  /* 82241968h */ case   46:  		/* mr R3, R31 */
		/* 82241968h case   46:*/		regs.R3 = regs.R31;
		/* 82241968h case   46:*/		return 0x8224196C;
		  /* 8224196Ch */ case   47:  		/* bl -7372 */
		/* 8224196Ch case   47:*/		regs.LR = 0x82241970; return 0x8223FCA0;
		/* 8224196Ch case   47:*/		return 0x82241970;
		  /* 82241970h */ case   48:  		/* mr R28, R3 */
		/* 82241970h case   48:*/		regs.R28 = regs.R3;
		/* 82241970h case   48:*/		return 0x82241974;
		  /* 82241974h */ case   49:  		/* stw R3, <#[R1 + 80]> */
		/* 82241974h case   49:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 82241974h case   49:*/		return 0x82241978;
	}
	return 0x82241978;
} // Block from 822418B0h-82241978h (50 instructions)

//////////////////////////////////////////////////////
// Block at 82241978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241978);
		  /* 82241978h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 82241978h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82241978h case    0:*/		return 0x8224197C;
		  /* 8224197Ch */ case    1:  		/* mr R3, R28 */
		/* 8224197Ch case    1:*/		regs.R3 = regs.R28;
		/* 8224197Ch case    1:*/		return 0x82241980;
		  /* 82241980h */ case    2:  		/* lwz R11, <#[R11 + 52]> */
		/* 82241980h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 82241980h case    2:*/		return 0x82241984;
		  /* 82241984h */ case    3:  		/* mtspr CTR, R11 */
		/* 82241984h case    3:*/		regs.CTR = regs.R11;
		/* 82241984h case    3:*/		return 0x82241988;
		  /* 82241988h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82241988h case    4:*/		if ( 1 ) { regs.LR = 0x8224198C; return (uint32)regs.CTR; }
		/* 82241988h case    4:*/		return 0x8224198C;
		  /* 8224198Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224198Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224198Ch case    5:*/		return 0x82241990;
		  /* 82241990h */ case    6:  		/* bc 12, CR0_EQ, 340 */
		/* 82241990h case    6:*/		if ( regs.CR[0].eq ) { return 0x82241AE4;  }
		/* 82241990h case    6:*/		return 0x82241994;
		  /* 82241994h */ case    7:  		/* lwz R11, <#[R28]> */
		/* 82241994h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82241994h case    7:*/		return 0x82241998;
		  /* 82241998h */ case    8:  		/* mr R3, R28 */
		/* 82241998h case    8:*/		regs.R3 = regs.R28;
		/* 82241998h case    8:*/		return 0x8224199C;
		  /* 8224199Ch */ case    9:  		/* lwz R11, <#[R11 + 56]> */
		/* 8224199Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000038) );
		/* 8224199Ch case    9:*/		return 0x822419A0;
		  /* 822419A0h */ case   10:  		/* mtspr CTR, R11 */
		/* 822419A0h case   10:*/		regs.CTR = regs.R11;
		/* 822419A0h case   10:*/		return 0x822419A4;
		  /* 822419A4h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 822419A4h case   11:*/		if ( 1 ) { regs.LR = 0x822419A8; return (uint32)regs.CTR; }
		/* 822419A4h case   11:*/		return 0x822419A8;
		  /* 822419A8h */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822419A8h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822419A8h case   12:*/		return 0x822419AC;
		  /* 822419ACh */ case   13:  		/* bc 12, CR0_EQ, 272 */
		/* 822419ACh case   13:*/		if ( regs.CR[0].eq ) { return 0x82241ABC;  }
		/* 822419ACh case   13:*/		return 0x822419B0;
		  /* 822419B0h */ case   14:  		/* li R10, 0 */
		/* 822419B0h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822419B0h case   14:*/		return 0x822419B4;
		  /* 822419B4h */ case   15:  		/* rlwinm. R11, R19, 0, 24, 31 */
		/* 822419B4h case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R19);
		/* 822419B4h case   15:*/		return 0x822419B8;
		  /* 822419B8h */ case   16:  		/* stb R10, <#[R1 + 295]> */
		/* 822419B8h case   16:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000127) );
		/* 822419B8h case   16:*/		return 0x822419BC;
		  /* 822419BCh */ case   17:  		/* bc 12, CR0_EQ, 64 */
		/* 822419BCh case   17:*/		if ( regs.CR[0].eq ) { return 0x822419FC;  }
		/* 822419BCh case   17:*/		return 0x822419C0;
		  /* 822419C0h */ case   18:  		/* lwz R11, <#[R31 + 16]> */
		/* 822419C0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 822419C0h case   18:*/		return 0x822419C4;
		  /* 822419C4h */ case   19:  		/* li R10, 12 */
		/* 822419C4h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0xC);
		/* 822419C4h case   19:*/		return 0x822419C8;
		  /* 822419C8h */ case   20:  		/* lwz R9, <#[R31 + 4]> */
		/* 822419C8h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 822419C8h case   20:*/		return 0x822419CC;
		  /* 822419CCh */ case   21:  		/* mr R7, R27 */
		/* 822419CCh case   21:*/		regs.R7 = regs.R27;
		/* 822419CCh case   21:*/		return 0x822419D0;
		  /* 822419D0h */ case   22:  		/* mr R5, R24 */
		/* 822419D0h case   22:*/		regs.R5 = regs.R24;
		/* 822419D0h case   22:*/		return 0x822419D4;
		  /* 822419D4h */ case   23:  		/* subf R11, R9, R11 */
		/* 822419D4h case   23:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 822419D4h case   23:*/		return 0x822419D8;
		  /* 822419D8h */ case   24:  		/* mr R4, R26 */
		/* 822419D8h case   24:*/		regs.R4 = regs.R26;
		/* 822419D8h case   24:*/		return 0x822419DC;
		  /* 822419DCh */ case   25:  		/* divw R11, R11, R10 */
		/* 822419DCh case   25:*/		cpu::op::divw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822419DCh case   25:*/		return 0x822419E0;
		  /* 822419E0h */ case   26:  		/* mr R3, R31 */
		/* 822419E0h case   26:*/		regs.R3 = regs.R31;
		/* 822419E0h case   26:*/		return 0x822419E4;
		  /* 822419E4h */ case   27:  		/* subf R6, R27, R11 */
		/* 822419E4h case   27:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R27,regs.R11);
		/* 822419E4h case   27:*/		return 0x822419E8;
		  /* 822419E8h */ case   28:  		/* bl -13472 */
		/* 822419E8h case   28:*/		regs.LR = 0x822419EC; return 0x8223E548;
		/* 822419E8h case   28:*/		return 0x822419EC;
		  /* 822419ECh */ case   29:  		/* li R27, 0 */
		/* 822419ECh case   29:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 822419ECh case   29:*/		return 0x822419F0;
		  /* 822419F0h */ case   30:  		/* li R26, 0 */
		/* 822419F0h case   30:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 822419F0h case   30:*/		return 0x822419F4;
		  /* 822419F4h */ case   31:  		/* li R24, 0 */
		/* 822419F4h case   31:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 822419F4h case   31:*/		return 0x822419F8;
		  /* 822419F8h */ case   32:  		/* li R19, 0 */
		/* 822419F8h case   32:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 822419F8h case   32:*/		return 0x822419FC;
	}
	return 0x822419FC;
} // Block from 82241978h-822419FCh (33 instructions)

//////////////////////////////////////////////////////
// Block at 822419FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822419FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822419FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822419FC);
		  /* 822419FCh */ case    0:  		/* lwz R11, <#[R28 + 24]> */
		/* 822419FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 822419FCh case    0:*/		return 0x82241A00;
		  /* 82241A00h */ case    1:  		/* cmpwi CR6, R11, 142 */
		/* 82241A00h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000008E);
		/* 82241A00h case    1:*/		return 0x82241A04;
		  /* 82241A04h */ case    2:  		/* bc 4, CR6_EQ, 64 */
		/* 82241A04h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82241A44;  }
		/* 82241A04h case    2:*/		return 0x82241A08;
		  /* 82241A08h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 82241A08h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82241A08h case    3:*/		return 0x82241A0C;
		  /* 82241A0Ch */ case    4:  		/* lwz R11, <#[R11 + 2736]> */
		/* 82241A0Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000AB0) );
		/* 82241A0Ch case    4:*/		return 0x82241A10;
		  /* 82241A10h */ case    5:  		/* lwz R11, <#[R11 + 2084]> */
		/* 82241A10h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000824) );
		/* 82241A10h case    5:*/		return 0x82241A14;
		  /* 82241A14h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82241A14h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82241A14h case    6:*/		return 0x82241A18;
		  /* 82241A18h */ case    7:  		/* bc 4, CR6_EQ, 36 */
		/* 82241A18h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82241A3C;  }
		/* 82241A18h case    7:*/		return 0x82241A1C;
		  /* 82241A1Ch */ case    8:  		/* lbz R11, <#[R31 + 124]> */
		/* 82241A1Ch case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000007C) );
		/* 82241A1Ch case    8:*/		return 0x82241A20;
		  /* 82241A20h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 82241A20h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82241A20h case    9:*/		return 0x82241A24;
		  /* 82241A24h */ case   10:  		/* bc 4, CR0_EQ, 24 */
		/* 82241A24h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82241A3C;  }
		/* 82241A24h case   10:*/		return 0x82241A28;
		  /* 82241A28h */ case   11:  		/* li R5, 2 */
		/* 82241A28h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82241A28h case   11:*/		return 0x82241A2C;
		  /* 82241A2Ch */ case   12:  		/* li R4, 0 */
		/* 82241A2Ch case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82241A2Ch case   12:*/		return 0x82241A30;
		  /* 82241A30h */ case   13:  		/* mr R3, R31 */
		/* 82241A30h case   13:*/		regs.R3 = regs.R31;
		/* 82241A30h case   13:*/		return 0x82241A34;
		  /* 82241A34h */ case   14:  		/* bl -13332 */
		/* 82241A34h case   14:*/		regs.LR = 0x82241A38; return 0x8223E620;
		/* 82241A34h case   14:*/		return 0x82241A38;
		  /* 82241A38h */ case   15:  		/* stb R25, <#[R31 + 124]> */
		/* 82241A38h case   15:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R31 + 0x0000007C) );
		/* 82241A38h case   15:*/		return 0x82241A3C;
	}
	return 0x82241A3C;
} // Block from 822419FCh-82241A3Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 82241A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241A3C);
		  /* 82241A3Ch */ case    0:  		/* li R5, 1 */
		/* 82241A3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82241A3Ch case    0:*/		return 0x82241A40;
		  /* 82241A40h */ case    1:  		/* b 68 */
		/* 82241A40h case    1:*/		return 0x82241A84;
		/* 82241A40h case    1:*/		return 0x82241A44;
	}
	return 0x82241A44;
} // Block from 82241A3Ch-82241A44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82241A44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241A44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241A44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241A44);
		  /* 82241A44h */ case    0:  		/* cmpwi CR6, R11, 143 */
		/* 82241A44h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000008F);
		/* 82241A44h case    0:*/		return 0x82241A48;
		  /* 82241A48h */ case    1:  		/* bc 4, CR6_EQ, 80 */
		/* 82241A48h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82241A98;  }
		/* 82241A48h case    1:*/		return 0x82241A4C;
		  /* 82241A4Ch */ case    2:  		/* lwz R11, <#[R31]> */
		/* 82241A4Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82241A4Ch case    2:*/		return 0x82241A50;
		  /* 82241A50h */ case    3:  		/* lwz R11, <#[R11 + 2736]> */
		/* 82241A50h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000AB0) );
		/* 82241A50h case    3:*/		return 0x82241A54;
		  /* 82241A54h */ case    4:  		/* lwz R11, <#[R11 + 2084]> */
		/* 82241A54h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000824) );
		/* 82241A54h case    4:*/		return 0x82241A58;
		  /* 82241A58h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 82241A58h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82241A58h case    5:*/		return 0x82241A5C;
		  /* 82241A5Ch */ case    6:  		/* bc 4, CR6_EQ, 36 */
		/* 82241A5Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82241A80;  }
		/* 82241A5Ch case    6:*/		return 0x82241A60;
		  /* 82241A60h */ case    7:  		/* lbz R11, <#[R31 + 124]> */
		/* 82241A60h case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000007C) );
		/* 82241A60h case    7:*/		return 0x82241A64;
		  /* 82241A64h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 82241A64h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82241A64h case    8:*/		return 0x82241A68;
	}
	return 0x82241A68;
} // Block from 82241A44h-82241A68h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82241A68h
// Function '?ExportSize@IRExport@XGRAPHICS@@QBAHPAVCFG@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241A68);
		  /* 82241A68h */ case    0:  		/* bc 4, CR0_EQ, 24 */
		/* 82241A68h case    0:*/		if ( !regs.CR[0].eq ) { return 0x82241A80;  }
		/* 82241A68h case    0:*/		return 0x82241A6C;
		  /* 82241A6Ch */ case    1:  		/* li R5, 2 */
		/* 82241A6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82241A6Ch case    1:*/		return 0x82241A70;
		  /* 82241A70h */ case    2:  		/* li R4, 0 */
		/* 82241A70h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82241A70h case    2:*/		return 0x82241A74;
		  /* 82241A74h */ case    3:  		/* mr R3, R31 */
		/* 82241A74h case    3:*/		regs.R3 = regs.R31;
		/* 82241A74h case    3:*/		return 0x82241A78;
		  /* 82241A78h */ case    4:  		/* bl -13400 */
		/* 82241A78h case    4:*/		regs.LR = 0x82241A7C; return 0x8223E620;
		/* 82241A78h case    4:*/		return 0x82241A7C;
		  /* 82241A7Ch */ case    5:  		/* stb R25, <#[R31 + 124]> */
		/* 82241A7Ch case    5:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R31 + 0x0000007C) );
		/* 82241A7Ch case    5:*/		return 0x82241A80;
	}
	return 0x82241A80;
} // Block from 82241A68h-82241A80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82241A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241A80);
		  /* 82241A80h */ case    0:  		/* li R5, 3 */
		/* 82241A80h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82241A80h case    0:*/		return 0x82241A84;
	}
	return 0x82241A84;
} // Block from 82241A80h-82241A84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82241A84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241A84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241A84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241A84);
		  /* 82241A84h */ case    0:  		/* mr R3, R31 */
		/* 82241A84h case    0:*/		regs.R3 = regs.R31;
		/* 82241A84h case    0:*/		return 0x82241A88;
		  /* 82241A88h */ case    1:  		/* lwz R4, <#[R28 + 168]> */
		/* 82241A88h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x000000A8) );
		/* 82241A88h case    1:*/		return 0x82241A8C;
		  /* 82241A8Ch */ case    2:  		/* bl -13420 */
		/* 82241A8Ch case    2:*/		regs.LR = 0x82241A90; return 0x8223E620;
		/* 82241A8Ch case    2:*/		return 0x82241A90;
		  /* 82241A90h */ case    3:  		/* stb R25, <#[R31 + 125]> */
		/* 82241A90h case    3:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R31 + 0x0000007D) );
		/* 82241A90h case    3:*/		return 0x82241A94;
		  /* 82241A94h */ case    4:  		/* b 40 */
		/* 82241A94h case    4:*/		return 0x82241ABC;
		/* 82241A94h case    4:*/		return 0x82241A98;
	}
	return 0x82241A98;
} // Block from 82241A84h-82241A98h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82241A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241A98);
		  /* 82241A98h */ case    0:  		/* cmpwi CR6, R11, 144 */
		/* 82241A98h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000090);
		/* 82241A98h case    0:*/		return 0x82241A9C;
		  /* 82241A9Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82241A9Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82241AA8;  }
		/* 82241A9Ch case    1:*/		return 0x82241AA0;
		  /* 82241AA0h */ case    2:  		/* cmpwi CR6, R11, 145 */
		/* 82241AA0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000091);
		/* 82241AA0h case    2:*/		return 0x82241AA4;
		  /* 82241AA4h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82241AA4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82241ABC;  }
		/* 82241AA4h case    3:*/		return 0x82241AA8;
	}
	return 0x82241AA8;
} // Block from 82241A98h-82241AA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82241AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241AA8);
		  /* 82241AA8h */ case    0:  		/* li R5, 2 */
		/* 82241AA8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82241AA8h case    0:*/		return 0x82241AAC;
		  /* 82241AACh */ case    1:  		/* lwz R4, <#[R28 + 168]> */
		/* 82241AACh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x000000A8) );
		/* 82241AACh case    1:*/		return 0x82241AB0;
		  /* 82241AB0h */ case    2:  		/* mr R3, R31 */
		/* 82241AB0h case    2:*/		regs.R3 = regs.R31;
		/* 82241AB0h case    2:*/		return 0x82241AB4;
		  /* 82241AB4h */ case    3:  		/* bl -13460 */
		/* 82241AB4h case    3:*/		regs.LR = 0x82241AB8; return 0x8223E620;
		/* 82241AB4h case    3:*/		return 0x82241AB8;
		  /* 82241AB8h */ case    4:  		/* stb R25, <#[R31 + 124]> */
		/* 82241AB8h case    4:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R31 + 0x0000007C) );
		/* 82241AB8h case    4:*/		return 0x82241ABC;
	}
	return 0x82241ABC;
} // Block from 82241AA8h-82241ABCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82241ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241ABC);
		  /* 82241ABCh */ case    0:  		/* lwz R11, <#[R28 + 228]> */
		/* 82241ABCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82241ABCh case    0:*/		return 0x82241AC0;
		  /* 82241AC0h */ case    1:  		/* rlwinm. R11, R11, 20, 31, 31 */
		/* 82241AC0h case    1:*/		cpu::op::rlwinm<1,20,31,31>(regs,&regs.R11,regs.R11);
		/* 82241AC0h case    1:*/		return 0x82241AC4;
		  /* 82241AC4h */ case    2:  		/* bc 12, CR0_EQ, 784 */
		/* 82241AC4h case    2:*/		if ( regs.CR[0].eq ) { return 0x82241DD4;  }
		/* 82241AC4h case    2:*/		return 0x82241AC8;
		  /* 82241AC8h */ case    3:  		/* mr R6, R21 */
		/* 82241AC8h case    3:*/		regs.R6 = regs.R21;
		/* 82241AC8h case    3:*/		return 0x82241ACC;
		  /* 82241ACCh */ case    4:  		/* lwz R5, <#[R1 + 84]> */
		/* 82241ACCh case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 82241ACCh case    4:*/		return 0x82241AD0;
		  /* 82241AD0h */ case    5:  		/* mr R4, R22 */
		/* 82241AD0h case    5:*/		regs.R4 = regs.R22;
		/* 82241AD0h case    5:*/		return 0x82241AD4;
		  /* 82241AD4h */ case    6:  		/* li R7, 1466 */
		/* 82241AD4h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x5BA);
		/* 82241AD4h case    6:*/		return 0x82241AD8;
		  /* 82241AD8h */ case    7:  		/* li R3, 0 */
		/* 82241AD8h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82241AD8h case    7:*/		return 0x82241ADC;
		  /* 82241ADCh */ case    8:  		/* bl -958164 */
		/* 82241ADCh case    8:*/		regs.LR = 0x82241AE0; return 0x82157C08;
		/* 82241ADCh case    8:*/		return 0x82241AE0;
		  /* 82241AE0h */ case    9:  		/* b 756 */
		/* 82241AE0h case    9:*/		return 0x82241DD4;
		/* 82241AE0h case    9:*/		return 0x82241AE4;
	}
	return 0x82241AE4;
} // Block from 82241ABCh-82241AE4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82241AE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241AE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241AE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241AE4);
		  /* 82241AE4h */ case    0:  		/* mr R3, R28 */
		/* 82241AE4h case    0:*/		regs.R3 = regs.R28;
		/* 82241AE4h case    0:*/		return 0x82241AE8;
	}
	return 0x82241AE8;
} // Block from 82241AE4h-82241AE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82241AE8h
// Function '?Assemble@IRTextureFetch@XGRAPHICS@@UAAXPAVAssembler@2@PADPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241AE8);
		  /* 82241AE8h */ case    0:  		/* bl -904 */
		/* 82241AE8h case    0:*/		regs.LR = 0x82241AEC; return 0x82241760;
		/* 82241AE8h case    0:*/		return 0x82241AEC;
		  /* 82241AECh */ case    1:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82241AECh case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82241AECh case    1:*/		return 0x82241AF0;
		  /* 82241AF0h */ case    2:  		/* bc 12, CR0_EQ, 68 */
		/* 82241AF0h case    2:*/		if ( regs.CR[0].eq ) { return 0x82241B34;  }
		/* 82241AF0h case    2:*/		return 0x82241AF4;
		  /* 82241AF4h */ case    3:  		/* lwz R11, <#[R31 + 84]> */
		/* 82241AF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 82241AF4h case    3:*/		return 0x82241AF8;
		  /* 82241AF8h */ case    4:  		/* addi R11, R11, 1 */
		/* 82241AF8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82241AF8h case    4:*/		return 0x82241AFC;
		  /* 82241AFCh */ case    5:  		/* stw R11, <#[R31 + 84]> */
		/* 82241AFCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 82241AFCh case    5:*/		return 0x82241B00;
		  /* 82241B00h */ case    6:  		/* lwz R11, <#[R28 + 24]> */
		/* 82241B00h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 82241B00h case    6:*/		return 0x82241B04;
		  /* 82241B04h */ case    7:  		/* mulli R11, R11, 52 */
		/* 82241B04h case    7:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 82241B04h case    7:*/		return 0x82241B08;
		  /* 82241B08h */ case    8:  		/* lwzx R11, <#[R11 + R20]> */
		/* 82241B08h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 82241B08h case    8:*/		return 0x82241B0C;
		  /* 82241B0Ch */ case    9:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 82241B0Ch case    9:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82241B0Ch case    9:*/		return 0x82241B10;
		  /* 82241B10h */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 82241B10h case   10:*/		if ( regs.CR[0].eq ) { return 0x82241B1C;  }
		/* 82241B10h case   10:*/		return 0x82241B14;
		  /* 82241B14h */ case   11:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 82241B14h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 82241B14h case   11:*/		return 0x82241B18;
		  /* 82241B18h */ case   12:  		/* bc 4, CR0_EQ, 28 */
		/* 82241B18h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82241B34;  }
		/* 82241B18h case   12:*/		return 0x82241B1C;
	}
	return 0x82241B1C;
} // Block from 82241AE8h-82241B1Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82241B1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241B1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241B1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241B1C);
		  /* 82241B1Ch */ case    0:  		/* lwz R11, <#[R28]> */
		/* 82241B1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82241B1Ch case    0:*/		return 0x82241B20;
		  /* 82241B20h */ case    1:  		/* mr R3, R28 */
		/* 82241B20h case    1:*/		regs.R3 = regs.R28;
		/* 82241B20h case    1:*/		return 0x82241B24;
		  /* 82241B24h */ case    2:  		/* lwz R11, <#[R11 + 96]> */
		/* 82241B24h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 82241B24h case    2:*/		return 0x82241B28;
		  /* 82241B28h */ case    3:  		/* mtspr CTR, R11 */
		/* 82241B28h case    3:*/		regs.CTR = regs.R11;
		/* 82241B28h case    3:*/		return 0x82241B2C;
		  /* 82241B2Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82241B2Ch case    4:*/		if ( 1 ) { regs.LR = 0x82241B30; return (uint32)regs.CTR; }
		/* 82241B2Ch case    4:*/		return 0x82241B30;
		  /* 82241B30h */ case    5:  		/* b 980 */
		/* 82241B30h case    5:*/		return 0x82241F04;
		/* 82241B30h case    5:*/		return 0x82241B34;
	}
	return 0x82241B34;
} // Block from 82241B1Ch-82241B34h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82241B34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241B34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241B34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241B34);
		  /* 82241B34h */ case    0:  		/* mr R3, R28 */
		/* 82241B34h case    0:*/		regs.R3 = regs.R28;
		/* 82241B34h case    0:*/		return 0x82241B38;
		  /* 82241B38h */ case    1:  		/* bl -12472 */
		/* 82241B38h case    1:*/		regs.LR = 0x82241B3C; return 0x8223EA80;
		/* 82241B38h case    1:*/		return 0x82241B3C;
		  /* 82241B3Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82241B3Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82241B3Ch case    2:*/		return 0x82241B40;
		  /* 82241B40h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 82241B40h case    3:*/		if ( regs.CR[0].eq ) { return 0x82241B50;  }
		/* 82241B40h case    3:*/		return 0x82241B44;
		  /* 82241B44h */ case    4:  		/* lwz R11, <#[R31 + 88]> */
		/* 82241B44h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 82241B44h case    4:*/		return 0x82241B48;
		  /* 82241B48h */ case    5:  		/* addi R11, R11, 1 */
		/* 82241B48h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82241B48h case    5:*/		return 0x82241B4C;
		  /* 82241B4Ch */ case    6:  		/* stw R11, <#[R31 + 88]> */
		/* 82241B4Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 82241B4Ch case    6:*/		return 0x82241B50;
	}
	return 0x82241B50;
} // Block from 82241B34h-82241B50h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82241B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241B50);
		  /* 82241B50h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 82241B50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 82241B50h case    0:*/		return 0x82241B54;
		  /* 82241B54h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82241B54h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82241B54h case    1:*/		return 0x82241B58;
		  /* 82241B58h */ case    2:  		/* bc 4, CR6_EQ, 40 */
		/* 82241B58h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82241B80;  }
		/* 82241B58h case    2:*/		return 0x82241B5C;
		  /* 82241B5Ch */ case    3:  		/* lwz R11, <#[R28]> */
		/* 82241B5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82241B5Ch case    3:*/		return 0x82241B60;
		  /* 82241B60h */ case    4:  		/* mr R3, R28 */
		/* 82241B60h case    4:*/		regs.R3 = regs.R28;
		/* 82241B60h case    4:*/		return 0x82241B64;
		  /* 82241B64h */ case    5:  		/* lwz R11, <#[R11 + 24]> */
		/* 82241B64h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82241B64h case    5:*/		return 0x82241B68;
		  /* 82241B68h */ case    6:  		/* mtspr CTR, R11 */
		/* 82241B68h case    6:*/		regs.CTR = regs.R11;
		/* 82241B68h case    6:*/		return 0x82241B6C;
		  /* 82241B6Ch */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82241B6Ch case    7:*/		if ( 1 ) { regs.LR = 0x82241B70; return (uint32)regs.CTR; }
		/* 82241B6Ch case    7:*/		return 0x82241B70;
		  /* 82241B70h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82241B70h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82241B70h case    8:*/		return 0x82241B74;
		  /* 82241B74h */ case    9:  		/* bc 12, CR0_EQ, 12 */
		/* 82241B74h case    9:*/		if ( regs.CR[0].eq ) { return 0x82241B80;  }
		/* 82241B74h case    9:*/		return 0x82241B78;
		  /* 82241B78h */ case   10:  		/* lwz R11, <#[R31 + 140]> */
		/* 82241B78h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 82241B78h case   10:*/		return 0x82241B7C;
		  /* 82241B7Ch */ case   11:  		/* stw R25, <#[R11 + 2092]> */
		/* 82241B7Ch case   11:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x0000082C) );
		/* 82241B7Ch case   11:*/		return 0x82241B80;
	}
	return 0x82241B80;
} // Block from 82241B50h-82241B80h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82241B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241B80);
		  /* 82241B80h */ case    0:  		/* lwz R11, <#[R28 + 228]> */
		/* 82241B80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82241B80h case    0:*/		return 0x82241B84;
		  /* 82241B84h */ case    1:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82241B84h case    1:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82241B84h case    1:*/		return 0x82241B88;
		  /* 82241B88h */ case    2:  		/* bc 12, CR0_EQ, 128 */
		/* 82241B88h case    2:*/		if ( regs.CR[0].eq ) { return 0x82241C08;  }
		/* 82241B88h case    2:*/		return 0x82241B8C;
		  /* 82241B8Ch */ case    3:  		/* mr R3, R31 */
		/* 82241B8Ch case    3:*/		regs.R3 = regs.R31;
		/* 82241B8Ch case    3:*/		return 0x82241B90;
		  /* 82241B90h */ case    4:  		/* lwz R4, <#[R28 + 80]> */
		/* 82241B90h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000050) );
		/* 82241B90h case    4:*/		return 0x82241B94;
		  /* 82241B94h */ case    5:  		/* bl -8100 */
		/* 82241B94h case    5:*/		regs.LR = 0x82241B98; return 0x8223FBF0;
		/* 82241B94h case    5:*/		return 0x82241B98;
		  /* 82241B98h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82241B98h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82241B98h case    6:*/		return 0x82241B9C;
		  /* 82241B9Ch */ case    7:  		/* bc 12, CR0_EQ, 108 */
		/* 82241B9Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82241C08;  }
		/* 82241B9Ch case    7:*/		return 0x82241BA0;
		  /* 82241BA0h */ case    8:  		/* rlwinm. R11, R19, 0, 24, 31 */
		/* 82241BA0h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R19);
		/* 82241BA0h case    8:*/		return 0x82241BA4;
		  /* 82241BA4h */ case    9:  		/* bc 12, CR0_EQ, 60 */
		/* 82241BA4h case    9:*/		if ( regs.CR[0].eq ) { return 0x82241BE0;  }
		/* 82241BA4h case    9:*/		return 0x82241BA8;
		  /* 82241BA8h */ case   10:  		/* lwz R11, <#[R31 + 16]> */
		/* 82241BA8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82241BA8h case   10:*/		return 0x82241BAC;
		  /* 82241BACh */ case   11:  		/* li R10, 12 */
		/* 82241BACh case   11:*/		cpu::op::li<0>(regs,&regs.R10,0xC);
		/* 82241BACh case   11:*/		return 0x82241BB0;
		  /* 82241BB0h */ case   12:  		/* lwz R9, <#[R31 + 4]> */
		/* 82241BB0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82241BB0h case   12:*/		return 0x82241BB4;
		  /* 82241BB4h */ case   13:  		/* mr R7, R27 */
		/* 82241BB4h case   13:*/		regs.R7 = regs.R27;
		/* 82241BB4h case   13:*/		return 0x82241BB8;
		  /* 82241BB8h */ case   14:  		/* mr R5, R24 */
		/* 82241BB8h case   14:*/		regs.R5 = regs.R24;
		/* 82241BB8h case   14:*/		return 0x82241BBC;
		  /* 82241BBCh */ case   15:  		/* subf R11, R9, R11 */
		/* 82241BBCh case   15:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82241BBCh case   15:*/		return 0x82241BC0;
		  /* 82241BC0h */ case   16:  		/* mr R4, R26 */
		/* 82241BC0h case   16:*/		regs.R4 = regs.R26;
		/* 82241BC0h case   16:*/		return 0x82241BC4;
		  /* 82241BC4h */ case   17:  		/* divw R11, R11, R10 */
		/* 82241BC4h case   17:*/		cpu::op::divw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82241BC4h case   17:*/		return 0x82241BC8;
		  /* 82241BC8h */ case   18:  		/* mr R3, R31 */
		/* 82241BC8h case   18:*/		regs.R3 = regs.R31;
		/* 82241BC8h case   18:*/		return 0x82241BCC;
		  /* 82241BCCh */ case   19:  		/* subf R6, R27, R11 */
		/* 82241BCCh case   19:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R27,regs.R11);
		/* 82241BCCh case   19:*/		return 0x82241BD0;
		  /* 82241BD0h */ case   20:  		/* bl -13960 */
		/* 82241BD0h case   20:*/		regs.LR = 0x82241BD4; return 0x8223E548;
		/* 82241BD0h case   20:*/		return 0x82241BD4;
		  /* 82241BD4h */ case   21:  		/* li R27, 0 */
		/* 82241BD4h case   21:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82241BD4h case   21:*/		return 0x82241BD8;
		  /* 82241BD8h */ case   22:  		/* li R26, 0 */
		/* 82241BD8h case   22:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82241BD8h case   22:*/		return 0x82241BDC;
		  /* 82241BDCh */ case   23:  		/* li R24, 0 */
		/* 82241BDCh case   23:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82241BDCh case   23:*/		return 0x82241BE0;
	}
	return 0x82241BE0;
} // Block from 82241B80h-82241BE0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82241BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241BE0);
		  /* 82241BE0h */ case    0:  		/* mr R3, R28 */
		/* 82241BE0h case    0:*/		regs.R3 = regs.R28;
		/* 82241BE0h case    0:*/		return 0x82241BE4;
		  /* 82241BE4h */ case    1:  		/* bl -13412 */
		/* 82241BE4h case    1:*/		regs.LR = 0x82241BE8; return 0x8223E780;
		/* 82241BE4h case    1:*/		return 0x82241BE8;
		  /* 82241BE8h */ case    2:  		/* mr R29, R3 */
		/* 82241BE8h case    2:*/		regs.R29 = regs.R3;
		/* 82241BE8h case    2:*/		return 0x82241BEC;
		  /* 82241BECh */ case    3:  		/* mr R3, R28 */
		/* 82241BECh case    3:*/		regs.R3 = regs.R28;
		/* 82241BECh case    3:*/		return 0x82241BF0;
		  /* 82241BF0h */ case    4:  		/* lwz R4, <#[R31 + 140]> */
		/* 82241BF0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000008C) );
		/* 82241BF0h case    4:*/		return 0x82241BF4;
		  /* 82241BF4h */ case    5:  		/* bl -3316 */
		/* 82241BF4h case    5:*/		regs.LR = 0x82241BF8; return 0x82240F00;
		/* 82241BF4h case    5:*/		return 0x82241BF8;
		  /* 82241BF8h */ case    6:  		/* mr R4, R3 */
		/* 82241BF8h case    6:*/		regs.R4 = regs.R3;
		/* 82241BF8h case    6:*/		return 0x82241BFC;
		  /* 82241BFCh */ case    7:  		/* mr R3, R31 */
		/* 82241BFCh case    7:*/		regs.R3 = regs.R31;
		/* 82241BFCh case    7:*/		return 0x82241C00;
		  /* 82241C00h */ case    8:  		/* mr R5, R29 */
		/* 82241C00h case    8:*/		regs.R5 = regs.R29;
		/* 82241C00h case    8:*/		return 0x82241C04;
		  /* 82241C04h */ case    9:  		/* bl -13796 */
		/* 82241C04h case    9:*/		regs.LR = 0x82241C08; return 0x8223E620;
		/* 82241C04h case    9:*/		return 0x82241C08;
	}
	return 0x82241C08;
} // Block from 82241BE0h-82241C08h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82241C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241C08);
		  /* 82241C08h */ case    0:  		/* rlwinm. R29, R23, 0, 24, 31 */
		/* 82241C08h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R29,regs.R23);
		/* 82241C08h case    0:*/		return 0x82241C0C;
		  /* 82241C0Ch */ case    1:  		/* mr R19, R25 */
		/* 82241C0Ch case    1:*/		regs.R19 = regs.R25;
		/* 82241C0Ch case    1:*/		return 0x82241C10;
		  /* 82241C10h */ case    2:  		/* bc 4, CR0_EQ, 80 */
		/* 82241C10h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82241C60;  }
		/* 82241C10h case    2:*/		return 0x82241C14;
		  /* 82241C14h */ case    3:  		/* rlwinm. R11, R18, 0, 24, 31 */
		/* 82241C14h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R18);
		/* 82241C14h case    3:*/		return 0x82241C18;
		  /* 82241C18h */ case    4:  		/* bc 4, CR0_EQ, 72 */
		/* 82241C18h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82241C60;  }
		/* 82241C18h case    4:*/		return 0x82241C1C;
		  /* 82241C1Ch */ case    5:  		/* lwz R10, <#[R31 + 16]> */
		/* 82241C1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82241C1Ch case    5:*/		return 0x82241C20;
		  /* 82241C20h */ case    6:  		/* lis R12, 783 */
		/* 82241C20h case    6:*/		cpu::op::lis<0>(regs,&regs.R12,0x30F);
		/* 82241C20h case    6:*/		return 0x82241C24;
		  /* 82241C24h */ case    7:  		/* ori R12, R12, 49279 */
		/* 82241C24h case    7:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xC07F);
		/* 82241C24h case    7:*/		return 0x82241C28;
		  /* 82241C28h */ case    8:  		/* lwz R11, <#[R10]> */
		/* 82241C28h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82241C28h case    8:*/		return 0x82241C2C;
		  /* 82241C2Ch */ case    9:  		/* lwz R9, <#[R10 + 8]> */
		/* 82241C2Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 82241C2Ch case    9:*/		return 0x82241C30;
		  /* 82241C30h */ case   10:  		/* and R11, R11, R12 */
		/* 82241C30h case   10:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82241C30h case   10:*/		return 0x82241C34;
		  /* 82241C34h */ case   11:  		/* oris R9, R9, 57344 */
		/* 82241C34h case   11:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0xE000);
		/* 82241C34h case   11:*/		return 0x82241C38;
		  /* 82241C38h */ case   12:  		/* oris R11, R11, 51200 */
		/* 82241C38h case   12:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0xC800);
		/* 82241C38h case   12:*/		return 0x82241C3C;
		  /* 82241C3Ch */ case   13:  		/* stw R9, <#[R10 + 8]> */
		/* 82241C3Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 82241C3Ch case   13:*/		return 0x82241C40;
		  /* 82241C40h */ case   14:  		/* mr R8, R9 */
		/* 82241C40h case   14:*/		regs.R8 = regs.R9;
		/* 82241C40h case   14:*/		return 0x82241C44;
		  /* 82241C44h */ case   15:  		/* rlwinm R9, R11, 0, 0, 25 */
		/* 82241C44h case   15:*/		cpu::op::rlwinm<0,0,0,25>(regs,&regs.R9,regs.R11);
		/* 82241C44h case   15:*/		return 0x82241C48;
		  /* 82241C48h */ case   16:  		/* stw R11, <#[R10]> */
		/* 82241C48h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82241C48h case   16:*/		return 0x82241C4C;
		  /* 82241C4Ch */ case   17:  		/* lwz R11, <#[R17 + 92]> */
		/* 82241C4Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000005C) );
		/* 82241C4Ch case   17:*/		return 0x82241C50;
		  /* 82241C50h */ case   18:  		/* rlwimi R8, R11, 24, 3, 7 */
		/* 82241C50h case   18:*/		cpu::op::rlwimi<0,24,3,7>(regs,&regs.R8,regs.R11);
		/* 82241C50h case   18:*/		return 0x82241C54;
		  /* 82241C54h */ case   19:  		/* rlwinm R9, R9, 0, 17, 11 */
		/* 82241C54h case   19:*/		cpu::op::rlwinm<0,0,17,11>(regs,&regs.R9,regs.R9);
		/* 82241C54h case   19:*/		return 0x82241C58;
		  /* 82241C58h */ case   20:  		/* stw R8, <#[R10 + 8]> */
		/* 82241C58h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 82241C58h case   20:*/		return 0x82241C5C;
		  /* 82241C5Ch */ case   21:  		/* stw R9, <#[R10]> */
		/* 82241C5Ch case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82241C5Ch case   21:*/		return 0x82241C60;
	}
	return 0x82241C60;
} // Block from 82241C08h-82241C60h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82241C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241C60);
		  /* 82241C60h */ case    0:  		/* lwz R11, <#[R31 + 140]> */
		/* 82241C60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 82241C60h case    0:*/		return 0x82241C64;
		  /* 82241C64h */ case    1:  		/* lbz R11, <#[R11]> */
		/* 82241C64h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82241C64h case    1:*/		return 0x82241C68;
		  /* 82241C68h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82241C68h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82241C68h case    2:*/		return 0x82241C6C;
		  /* 82241C6Ch */ case    3:  		/* bc 4, CR0_EQ, 24 */
		/* 82241C6Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82241C84;  }
		/* 82241C6Ch case    3:*/		return 0x82241C70;
		  /* 82241C70h */ case    4:  		/* addi R5, R1, 80 */
		/* 82241C70h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82241C70h case    4:*/		return 0x82241C74;
		  /* 82241C74h */ case    5:  		/* mr R4, R30 */
		/* 82241C74h case    5:*/		regs.R4 = regs.R30;
		/* 82241C74h case    5:*/		return 0x82241C78;
		  /* 82241C78h */ case    6:  		/* mr R3, R31 */
		/* 82241C78h case    6:*/		regs.R3 = regs.R31;
		/* 82241C78h case    6:*/		return 0x82241C7C;
		  /* 82241C7Ch */ case    7:  		/* bl -10804 */
		/* 82241C7Ch case    7:*/		regs.LR = 0x82241C80; return 0x8223F248;
		/* 82241C7Ch case    7:*/		return 0x82241C80;
		  /* 82241C80h */ case    8:  		/* lwz R28, <#[R1 + 80]> */
		/* 82241C80h case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 82241C80h case    8:*/		return 0x82241C84;
	}
	return 0x82241C84;
} // Block from 82241C60h-82241C84h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82241C84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241C84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241C84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241C84);
		  /* 82241C84h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 82241C84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82241C84h case    0:*/		return 0x82241C88;
		  /* 82241C88h */ case    1:  		/* mr R4, R31 */
		/* 82241C88h case    1:*/		regs.R4 = regs.R31;
		/* 82241C88h case    1:*/		return 0x82241C8C;
		  /* 82241C8Ch */ case    2:  		/* mr R3, R28 */
		/* 82241C8Ch case    2:*/		regs.R3 = regs.R28;
		/* 82241C8Ch case    2:*/		return 0x82241C90;
		  /* 82241C90h */ case    3:  		/* lwz R6, <#[R31]> */
		/* 82241C90h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 82241C90h case    3:*/		return 0x82241C94;
		  /* 82241C94h */ case    4:  		/* lwz R5, <#[R31 + 16]> */
		/* 82241C94h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 82241C94h case    4:*/		return 0x82241C98;
		  /* 82241C98h */ case    5:  		/* lwz R11, <#[R11 + 12]> */
		/* 82241C98h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82241C98h case    5:*/		return 0x82241C9C;
		  /* 82241C9Ch */ case    6:  		/* mtspr CTR, R11 */
		/* 82241C9Ch case    6:*/		regs.CTR = regs.R11;
		/* 82241C9Ch case    6:*/		return 0x82241CA0;
		  /* 82241CA0h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82241CA0h case    7:*/		if ( 1 ) { regs.LR = 0x82241CA4; return (uint32)regs.CTR; }
		/* 82241CA0h case    7:*/		return 0x82241CA4;
		  /* 82241CA4h */ case    8:  		/* lwz R11, <#[R28]> */
		/* 82241CA4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82241CA4h case    8:*/		return 0x82241CA8;
		  /* 82241CA8h */ case    9:  		/* mr R3, R28 */
		/* 82241CA8h case    9:*/		regs.R3 = regs.R28;
		/* 82241CA8h case    9:*/		return 0x82241CAC;
		  /* 82241CACh */ case   10:  		/* lwz R11, <#[R11 + 24]> */
		/* 82241CACh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82241CACh case   10:*/		return 0x82241CB0;
		  /* 82241CB0h */ case   11:  		/* mtspr CTR, R11 */
		/* 82241CB0h case   11:*/		regs.CTR = regs.R11;
		/* 82241CB0h case   11:*/		return 0x82241CB4;
		  /* 82241CB4h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 82241CB4h case   12:*/		if ( 1 ) { regs.LR = 0x82241CB8; return (uint32)regs.CTR; }
		/* 82241CB4h case   12:*/		return 0x82241CB8;
		  /* 82241CB8h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82241CB8h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82241CB8h case   13:*/		return 0x82241CBC;
		  /* 82241CBCh */ case   14:  		/* bc 12, CR0_EQ, 120 */
		/* 82241CBCh case   14:*/		if ( regs.CR[0].eq ) { return 0x82241D34;  }
		/* 82241CBCh case   14:*/		return 0x82241CC0;
		  /* 82241CC0h */ case   15:  		/* lwz R11, <#[R28]> */
		/* 82241CC0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82241CC0h case   15:*/		return 0x82241CC4;
		  /* 82241CC4h */ case   16:  		/* rlwinm R30, R27, 1, 0, 30 */
		/* 82241CC4h case   16:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R30,regs.R27);
		/* 82241CC4h case   16:*/		return 0x82241CC8;
		  /* 82241CC8h */ case   17:  		/* mr R3, R28 */
		/* 82241CC8h case   17:*/		regs.R3 = regs.R28;
		/* 82241CC8h case   17:*/		return 0x82241CCC;
		  /* 82241CCCh */ case   18:  		/* slw R10, R25, R30 */
		/* 82241CCCh case   18:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R25,regs.R30);
		/* 82241CCCh case   18:*/		return 0x82241CD0;
		  /* 82241CD0h */ case   19:  		/* lwz R11, <#[R11 + 28]> */
		/* 82241CD0h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82241CD0h case   19:*/		return 0x82241CD4;
		  /* 82241CD4h */ case   20:  		/* or R26, R10, R26 */
		/* 82241CD4h case   20:*/		cpu::op::or<0>(regs,&regs.R26,regs.R10,regs.R26);
		/* 82241CD4h case   20:*/		return 0x82241CD8;
		  /* 82241CD8h */ case   21:  		/* mtspr CTR, R11 */
		/* 82241CD8h case   21:*/		regs.CTR = regs.R11;
		/* 82241CD8h case   21:*/		return 0x82241CDC;
		  /* 82241CDCh */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 82241CDCh case   22:*/		if ( 1 ) { regs.LR = 0x82241CE0; return (uint32)regs.CTR; }
		/* 82241CDCh case   22:*/		return 0x82241CE0;
		  /* 82241CE0h */ case   23:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82241CE0h case   23:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82241CE0h case   23:*/		return 0x82241CE4;
		  /* 82241CE4h */ case   24:  		/* bc 12, CR0_EQ, 16 */
		/* 82241CE4h case   24:*/		if ( regs.CR[0].eq ) { return 0x82241CF4;  }
		/* 82241CE4h case   24:*/		return 0x82241CE8;
		  /* 82241CE8h */ case   25:  		/* lbz R11, <#[R28 + 176]> */
		/* 82241CE8h case   25:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000B0) );
		/* 82241CE8h case   25:*/		return 0x82241CEC;
		  /* 82241CECh */ case   26:  		/* slw R11, R11, R27 */
		/* 82241CECh case   26:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 82241CECh case   26:*/		return 0x82241CF0;
		  /* 82241CF0h */ case   27:  		/* or R24, R11, R24 */
		/* 82241CF0h case   27:*/		cpu::op::or<0>(regs,&regs.R24,regs.R11,regs.R24);
		/* 82241CF0h case   27:*/		return 0x82241CF4;
	}
	return 0x82241CF4;
} // Block from 82241C84h-82241CF4h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82241CF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241CF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241CF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241CF4);
		  /* 82241CF4h */ case    0:  		/* rlwinm. R11, R18, 0, 24, 31 */
		/* 82241CF4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R18);
		/* 82241CF4h case    0:*/		return 0x82241CF8;
		  /* 82241CF8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82241CF8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82241D04;  }
		/* 82241CF8h case    1:*/		return 0x82241CFC;
		  /* 82241CFCh */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 82241CFCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82241CFCh case    2:*/		return 0x82241D00;
		  /* 82241D00h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 82241D00h case    3:*/		if ( regs.CR[6].eq ) { return 0x82241D1C;  }
		/* 82241D00h case    3:*/		return 0x82241D04;
	}
	return 0x82241D04;
} // Block from 82241CF4h-82241D04h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82241D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241D04);
		  /* 82241D04h */ case    0:  		/* mr R6, R21 */
		/* 82241D04h case    0:*/		regs.R6 = regs.R21;
		/* 82241D04h case    0:*/		return 0x82241D08;
		  /* 82241D08h */ case    1:  		/* lwz R5, <#[R1 + 88]> */
		/* 82241D08h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 82241D08h case    1:*/		return 0x82241D0C;
		  /* 82241D0Ch */ case    2:  		/* mr R4, R22 */
		/* 82241D0Ch case    2:*/		regs.R4 = regs.R22;
		/* 82241D0Ch case    2:*/		return 0x82241D10;
		  /* 82241D10h */ case    3:  		/* li R7, 1551 */
		/* 82241D10h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x60F);
		/* 82241D10h case    3:*/		return 0x82241D14;
		  /* 82241D14h */ case    4:  		/* li R3, 0 */
		/* 82241D14h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82241D14h case    4:*/		return 0x82241D18;
		  /* 82241D18h */ case    5:  		/* bl -958736 */
		/* 82241D18h case    5:*/		regs.LR = 0x82241D1C; return 0x82157C08;
		/* 82241D18h case    5:*/		return 0x82241D1C;
	}
	return 0x82241D1C;
} // Block from 82241D04h-82241D1Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82241D1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241D1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241D1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241D1C);
		  /* 82241D1Ch */ case    0:  		/* lwz R11, <#[R31 + 64]> */
		/* 82241D1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 82241D1Ch case    0:*/		return 0x82241D20;
		  /* 82241D20h */ case    1:  		/* mr R23, R25 */
		/* 82241D20h case    1:*/		regs.R23 = regs.R25;
		/* 82241D20h case    1:*/		return 0x82241D24;
		  /* 82241D24h */ case    2:  		/* mr R18, R25 */
		/* 82241D24h case    2:*/		regs.R18 = regs.R25;
		/* 82241D24h case    2:*/		return 0x82241D28;
		  /* 82241D28h */ case    3:  		/* addi R11, R11, 1 */
		/* 82241D28h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82241D28h case    3:*/		return 0x82241D2C;
		  /* 82241D2Ch */ case    4:  		/* stw R11, <#[R31 + 64]> */
		/* 82241D2Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 82241D2Ch case    4:*/		return 0x82241D30;
		  /* 82241D30h */ case    5:  		/* b 116 */
		/* 82241D30h case    5:*/		return 0x82241DA4;
		/* 82241D30h case    5:*/		return 0x82241D34;
	}
	return 0x82241D34;
} // Block from 82241D1Ch-82241D34h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82241D34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241D34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241D34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241D34);
		  /* 82241D34h */ case    0:  		/* lwz R11, <#[R28 + 24]> */
		/* 82241D34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 82241D34h case    0:*/		return 0x82241D38;
		  /* 82241D38h */ case    1:  		/* mulli R11, R11, 52 */
		/* 82241D38h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 82241D38h case    1:*/		return 0x82241D3C;
		  /* 82241D3Ch */ case    2:  		/* lwzx R11, <#[R11 + R20]> */
		/* 82241D3Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 82241D3Ch case    2:*/		return 0x82241D40;
		  /* 82241D40h */ case    3:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 82241D40h case    3:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82241D40h case    3:*/		return 0x82241D44;
		  /* 82241D44h */ case    4:  		/* bc 12, CR0_EQ, 44 */
		/* 82241D44h case    4:*/		if ( regs.CR[0].eq ) { return 0x82241D70;  }
		/* 82241D44h case    4:*/		return 0x82241D48;
		  /* 82241D48h */ case    5:  		/* rlwinm. R11, R18, 0, 24, 31 */
		/* 82241D48h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R18);
		/* 82241D48h case    5:*/		return 0x82241D4C;
		  /* 82241D4Ch */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 82241D4Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82241D68;  }
		/* 82241D4Ch case    6:*/		return 0x82241D50;
		  /* 82241D50h */ case    7:  		/* mr R6, R21 */
		/* 82241D50h case    7:*/		regs.R6 = regs.R21;
		/* 82241D50h case    7:*/		return 0x82241D54;
		  /* 82241D54h */ case    8:  		/* mr R5, R14 */
		/* 82241D54h case    8:*/		regs.R5 = regs.R14;
		/* 82241D54h case    8:*/		return 0x82241D58;
		  /* 82241D58h */ case    9:  		/* mr R4, R22 */
		/* 82241D58h case    9:*/		regs.R4 = regs.R22;
		/* 82241D58h case    9:*/		return 0x82241D5C;
		  /* 82241D5Ch */ case   10:  		/* li R7, 1558 */
		/* 82241D5Ch case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x616);
		/* 82241D5Ch case   10:*/		return 0x82241D60;
		  /* 82241D60h */ case   11:  		/* li R3, 0 */
		/* 82241D60h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82241D60h case   11:*/		return 0x82241D64;
		  /* 82241D64h */ case   12:  		/* bl -958812 */
		/* 82241D64h case   12:*/		regs.LR = 0x82241D68; return 0x82157C08;
		/* 82241D64h case   12:*/		return 0x82241D68;
	}
	return 0x82241D68;
} // Block from 82241D34h-82241D68h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82241D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241D68);
		  /* 82241D68h */ case    0:  		/* mr R18, R25 */
		/* 82241D68h case    0:*/		regs.R18 = regs.R25;
		/* 82241D68h case    0:*/		return 0x82241D6C;
		  /* 82241D6Ch */ case    1:  		/* b 40 */
		/* 82241D6Ch case    1:*/		return 0x82241D94;
		/* 82241D6Ch case    1:*/		return 0x82241D70;
	}
	return 0x82241D70;
} // Block from 82241D68h-82241D70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82241D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241D70);
		  /* 82241D70h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82241D70h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82241D70h case    0:*/		return 0x82241D74;
		  /* 82241D74h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82241D74h case    1:*/		if ( regs.CR[6].eq ) { return 0x82241D90;  }
		/* 82241D74h case    1:*/		return 0x82241D78;
		  /* 82241D78h */ case    2:  		/* mr R6, R21 */
		/* 82241D78h case    2:*/		regs.R6 = regs.R21;
		/* 82241D78h case    2:*/		return 0x82241D7C;
		  /* 82241D7Ch */ case    3:  		/* mr R5, R15 */
		/* 82241D7Ch case    3:*/		regs.R5 = regs.R15;
		/* 82241D7Ch case    3:*/		return 0x82241D80;
		  /* 82241D80h */ case    4:  		/* mr R4, R22 */
		/* 82241D80h case    4:*/		regs.R4 = regs.R22;
		/* 82241D80h case    4:*/		return 0x82241D84;
		  /* 82241D84h */ case    5:  		/* li R7, 1561 */
		/* 82241D84h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x619);
		/* 82241D84h case    5:*/		return 0x82241D88;
		  /* 82241D88h */ case    6:  		/* li R3, 0 */
		/* 82241D88h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82241D88h case    6:*/		return 0x82241D8C;
		  /* 82241D8Ch */ case    7:  		/* bl -958852 */
		/* 82241D8Ch case    7:*/		regs.LR = 0x82241D90; return 0x82157C08;
		/* 82241D8Ch case    7:*/		return 0x82241D90;
	}
	return 0x82241D90;
} // Block from 82241D70h-82241D90h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82241D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241D90);
		  /* 82241D90h */ case    0:  		/* mr R23, R25 */
		/* 82241D90h case    0:*/		regs.R23 = regs.R25;
		/* 82241D90h case    0:*/		return 0x82241D94;
	}
	return 0x82241D94;
} // Block from 82241D90h-82241D94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82241D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241D94);
		  /* 82241D94h */ case    0:  		/* rlwinm R30, R27, 1, 0, 30 */
		/* 82241D94h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R30,regs.R27);
		/* 82241D94h case    0:*/		return 0x82241D98;
		  /* 82241D98h */ case    1:  		/* li R11, 0 */
		/* 82241D98h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82241D98h case    1:*/		return 0x82241D9C;
		  /* 82241D9Ch */ case    2:  		/* slw R11, R11, R30 */
		/* 82241D9Ch case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82241D9Ch case    2:*/		return 0x82241DA0;
		  /* 82241DA0h */ case    3:  		/* or R26, R11, R26 */
		/* 82241DA0h case    3:*/		cpu::op::or<0>(regs,&regs.R26,regs.R11,regs.R26);
		/* 82241DA0h case    3:*/		return 0x82241DA4;
	}
	return 0x82241DA4;
} // Block from 82241D94h-82241DA4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82241DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241DA4);
		  /* 82241DA4h */ case    0:  		/* lwz R11, <#[R28 + 228]> */
		/* 82241DA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82241DA4h case    0:*/		return 0x82241DA8;
		  /* 82241DA8h */ case    1:  		/* rlwinm. R11, R11, 20, 31, 31 */
		/* 82241DA8h case    1:*/		cpu::op::rlwinm<1,20,31,31>(regs,&regs.R11,regs.R11);
		/* 82241DA8h case    1:*/		return 0x82241DAC;
		  /* 82241DACh */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 82241DACh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82241DBC;  }
		/* 82241DACh case    2:*/		return 0x82241DB0;
		  /* 82241DB0h */ case    3:  		/* lbz R11, <#[R1 + 295]> */
		/* 82241DB0h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000127) );
		/* 82241DB0h case    3:*/		return 0x82241DB4;
		  /* 82241DB4h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 82241DB4h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82241DB4h case    4:*/		return 0x82241DB8;
		  /* 82241DB8h */ case    5:  		/* bc 12, CR0_EQ, 24 */
		/* 82241DB8h case    5:*/		if ( regs.CR[0].eq ) { return 0x82241DD0;  }
		/* 82241DB8h case    5:*/		return 0x82241DBC;
	}
	return 0x82241DBC;
} // Block from 82241DA4h-82241DBCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82241DBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241DBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241DBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241DBC);
		  /* 82241DBCh */ case    0:  		/* addi R11, R30, 1 */
		/* 82241DBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 82241DBCh case    0:*/		return 0x82241DC0;
		  /* 82241DC0h */ case    1:  		/* li R10, 0 */
		/* 82241DC0h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82241DC0h case    1:*/		return 0x82241DC4;
		  /* 82241DC4h */ case    2:  		/* slw R11, R25, R11 */
		/* 82241DC4h case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R25,regs.R11);
		/* 82241DC4h case    2:*/		return 0x82241DC8;
		  /* 82241DC8h */ case    3:  		/* stb R10, <#[R1 + 295]> */
		/* 82241DC8h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000127) );
		/* 82241DC8h case    3:*/		return 0x82241DCC;
		  /* 82241DCCh */ case    4:  		/* or R26, R11, R26 */
		/* 82241DCCh case    4:*/		cpu::op::or<0>(regs,&regs.R26,regs.R11,regs.R26);
		/* 82241DCCh case    4:*/		return 0x82241DD0;
	}
	return 0x82241DD0;
} // Block from 82241DBCh-82241DD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82241DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241DD0);
		  /* 82241DD0h */ case    0:  		/* lwz R30, <#[R1 + 284]> */
		/* 82241DD0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000011C) );
		/* 82241DD0h case    0:*/		return 0x82241DD4;
	}
	return 0x82241DD4;
} // Block from 82241DD0h-82241DD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82241DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241DD4);
		  /* 82241DD4h */ case    0:  		/* lwz R11, <#[R28 + 228]> */
		/* 82241DD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82241DD4h case    0:*/		return 0x82241DD8;
		  /* 82241DD8h */ case    1:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 82241DD8h case    1:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82241DD8h case    1:*/		return 0x82241DDC;
		  /* 82241DDCh */ case    2:  		/* bc 4, CR0_EQ, 176 */
		/* 82241DDCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82241E8C;  }
		/* 82241DDCh case    2:*/		return 0x82241DE0;
		  /* 82241DE0h */ case    3:  		/* rlwinm. R8, R23, 0, 24, 31 */
		/* 82241DE0h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R8,regs.R23);
		/* 82241DE0h case    3:*/		return 0x82241DE4;
		  /* 82241DE4h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 82241DE4h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82241DF0;  }
		/* 82241DE4h case    4:*/		return 0x82241DE8;
		  /* 82241DE8h */ case    5:  		/* rlwinm. R11, R18, 0, 24, 31 */
		/* 82241DE8h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R18);
		/* 82241DE8h case    5:*/		return 0x82241DEC;
		  /* 82241DECh */ case    6:  		/* bc 12, CR0_EQ, 160 */
		/* 82241DECh case    6:*/		if ( regs.CR[0].eq ) { return 0x82241E8C;  }
		/* 82241DECh case    6:*/		return 0x82241DF0;
	}
	return 0x82241DF0;
} // Block from 82241DD4h-82241DF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82241DF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241DF0);
		  /* 82241DF0h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 82241DF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 82241DF0h case    0:*/		return 0x82241DF4;
		  /* 82241DF4h */ case    1:  		/* addi R27, R27, 1 */
		/* 82241DF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82241DF4h case    1:*/		return 0x82241DF8;
		  /* 82241DF8h */ case    2:  		/* lwz R10, <#[R31 + 16]> */
		/* 82241DF8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82241DF8h case    2:*/		return 0x82241DFC;
		  /* 82241DFCh */ case    3:  		/* addi R9, R11, 1 */
		/* 82241DFCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82241DFCh case    3:*/		return 0x82241E00;
		  /* 82241E00h */ case    4:  		/* addi R10, R10, 12 */
		/* 82241E00h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82241E00h case    4:*/		return 0x82241E04;
		  /* 82241E04h */ case    5:  		/* stw R9, <#[R31 + 60]> */
		/* 82241E04h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000003C) );
		/* 82241E04h case    5:*/		return 0x82241E08;
		  /* 82241E08h */ case    6:  		/* stw R10, <#[R31 + 16]> */
		/* 82241E08h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82241E08h case    6:*/		return 0x82241E0C;
		  /* 82241E0Ch */ case    7:  		/* lwz R11, <#[R28 + 24]> */
		/* 82241E0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 82241E0Ch case    7:*/		return 0x82241E10;
		  /* 82241E10h */ case    8:  		/* mulli R11, R11, 52 */
		/* 82241E10h case    8:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 82241E10h case    8:*/		return 0x82241E14;
		  /* 82241E14h */ case    9:  		/* lwzx R11, <#[R11 + R20]> */
		/* 82241E14h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 82241E14h case    9:*/		return 0x82241E18;
		  /* 82241E18h */ case   10:  		/* rlwinm. R10, R11, 29, 31, 31 */
		/* 82241E18h case   10:*/		cpu::op::rlwinm<1,29,31,31>(regs,&regs.R10,regs.R11);
		/* 82241E18h case   10:*/		return 0x82241E1C;
		  /* 82241E1Ch */ case   11:  		/* bc 12, CR0_EQ, 60 */
		/* 82241E1Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82241E58;  }
		/* 82241E1Ch case   11:*/		return 0x82241E20;
		  /* 82241E20h */ case   12:  		/* rlwinm. R10, R11, 31, 31, 31 */
		/* 82241E20h case   12:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R10,regs.R11);
		/* 82241E20h case   12:*/		return 0x82241E24;
		  /* 82241E24h */ case   13:  		/* bc 4, CR0_EQ, 12 */
		/* 82241E24h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82241E30;  }
		/* 82241E24h case   13:*/		return 0x82241E28;
		  /* 82241E28h */ case   14:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 82241E28h case   14:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82241E28h case   14:*/		return 0x82241E2C;
		  /* 82241E2Ch */ case   15:  		/* bc 12, CR0_EQ, 44 */
		/* 82241E2Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x82241E58;  }
		/* 82241E2Ch case   15:*/		return 0x82241E30;
	}
	return 0x82241E30;
} // Block from 82241DF0h-82241E30h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82241E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241E30);
		  /* 82241E30h */ case    0:  		/* lwz R11, <#[R31 + 72]> */
		/* 82241E30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 82241E30h case    0:*/		return 0x82241E34;
		  /* 82241E34h */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 82241E34h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82241E34h case    1:*/		return 0x82241E38;
		  /* 82241E38h */ case    2:  		/* addi R11, R11, 1 */
		/* 82241E38h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82241E38h case    2:*/		return 0x82241E3C;
		  /* 82241E3Ch */ case    3:  		/* stw R11, <#[R31 + 72]> */
		/* 82241E3Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 82241E3Ch case    3:*/		return 0x82241E40;
		  /* 82241E40h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82241E40h case    4:*/		if ( regs.CR[6].eq ) { return 0x82241E58;  }
		/* 82241E40h case    4:*/		return 0x82241E44;
		  /* 82241E44h */ case    5:  		/* rlwinm. R11, R18, 0, 24, 31 */
		/* 82241E44h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R18);
		/* 82241E44h case    5:*/		return 0x82241E48;
		  /* 82241E48h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82241E48h case    6:*/		if ( regs.CR[0].eq ) { return 0x82241E58;  }
		/* 82241E48h case    6:*/		return 0x82241E4C;
		  /* 82241E4Ch */ case    7:  		/* lwz R11, <#[R31 + 68]> */
		/* 82241E4Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 82241E4Ch case    7:*/		return 0x82241E50;
		  /* 82241E50h */ case    8:  		/* addi R11, R11, 1 */
		/* 82241E50h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82241E50h case    8:*/		return 0x82241E54;
		  /* 82241E54h */ case    9:  		/* stw R11, <#[R31 + 68]> */
		/* 82241E54h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 82241E54h case    9:*/		return 0x82241E58;
	}
	return 0x82241E58;
} // Block from 82241E30h-82241E58h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82241E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241E58);
		  /* 82241E58h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82241E58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82241E58h case    0:*/		return 0x82241E5C;
		  /* 82241E5Ch */ case    1:  		/* lwz R11, <#[R11 + 1376]> */
		/* 82241E5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000560) );
		/* 82241E5Ch case    1:*/		return 0x82241E60;
		  /* 82241E60h */ case    2:  		/* mulli R11, R11, 3 */
		/* 82241E60h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x3);
		/* 82241E60h case    2:*/		return 0x82241E64;
		  /* 82241E64h */ case    3:  		/* cmpw CR6, R9, R11 */
		/* 82241E64h case    3:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R11);
		/* 82241E64h case    3:*/		return 0x82241E68;
		  /* 82241E68h */ case    4:  		/* bc 4, CR6_GT, 28 */
		/* 82241E68h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82241E84;  }
		/* 82241E68h case    4:*/		return 0x82241E6C;
		  /* 82241E6Ch */ case    5:  		/* mr R6, R21 */
		/* 82241E6Ch case    5:*/		regs.R6 = regs.R21;
		/* 82241E6Ch case    5:*/		return 0x82241E70;
		  /* 82241E70h */ case    6:  		/* mr R5, R16 */
		/* 82241E70h case    6:*/		regs.R5 = regs.R16;
		/* 82241E70h case    6:*/		return 0x82241E74;
		  /* 82241E74h */ case    7:  		/* mr R4, R22 */
		/* 82241E74h case    7:*/		regs.R4 = regs.R22;
		/* 82241E74h case    7:*/		return 0x82241E78;
		  /* 82241E78h */ case    8:  		/* li R7, 1586 */
		/* 82241E78h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x632);
		/* 82241E78h case    8:*/		return 0x82241E7C;
		  /* 82241E7Ch */ case    9:  		/* li R3, 0 */
		/* 82241E7Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82241E7Ch case    9:*/		return 0x82241E80;
		  /* 82241E80h */ case   10:  		/* bl -959096 */
		/* 82241E80h case   10:*/		regs.LR = 0x82241E84; return 0x82157C08;
		/* 82241E80h case   10:*/		return 0x82241E84;
	}
	return 0x82241E84;
} // Block from 82241E58h-82241E84h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82241E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241E84);
		  /* 82241E84h */ case    0:  		/* li R23, 0 */
		/* 82241E84h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82241E84h case    0:*/		return 0x82241E88;
		  /* 82241E88h */ case    1:  		/* li R18, 0 */
		/* 82241E88h case    1:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 82241E88h case    1:*/		return 0x82241E8C;
	}
	return 0x82241E8C;
} // Block from 82241E84h-82241E8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82241E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241E8C);
		  /* 82241E8Ch */ case    0:  		/* lwz R11, <#[R28 + 228]> */
		/* 82241E8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82241E8Ch case    0:*/		return 0x82241E90;
		  /* 82241E90h */ case    1:  		/* rlwinm. R11, R11, 24, 31, 31 */
		/* 82241E90h case    1:*/		cpu::op::rlwinm<1,24,31,31>(regs,&regs.R11,regs.R11);
		/* 82241E90h case    1:*/		return 0x82241E94;
		  /* 82241E94h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82241E94h case    2:*/		if ( regs.CR[0].eq ) { return 0x82241EA0;  }
		/* 82241E94h case    2:*/		return 0x82241E98;
		  /* 82241E98h */ case    3:  		/* cmpwi CR6, R27, 0 */
		/* 82241E98h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82241E98h case    3:*/		return 0x82241E9C;
		  /* 82241E9Ch */ case    4:  		/* bc 12, CR6_GT, 12 */
		/* 82241E9Ch case    4:*/		if ( regs.CR[6].gt ) { return 0x82241EA8;  }
		/* 82241E9Ch case    4:*/		return 0x82241EA0;
	}
	return 0x82241EA0;
} // Block from 82241E8Ch-82241EA0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82241EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241EA0);
		  /* 82241EA0h */ case    0:  		/* cmpwi CR6, R27, 6 */
		/* 82241EA0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000006);
		/* 82241EA0h case    0:*/		return 0x82241EA4;
		  /* 82241EA4h */ case    1:  		/* bc 4, CR6_EQ, 64 */
		/* 82241EA4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82241EE4;  }
		/* 82241EA4h case    1:*/		return 0x82241EA8;
	}
	return 0x82241EA8;
} // Block from 82241EA0h-82241EA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82241EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241EA8);
		  /* 82241EA8h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82241EA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82241EA8h case    0:*/		return 0x82241EAC;
		  /* 82241EACh */ case    1:  		/* li R10, 12 */
		/* 82241EACh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xC);
		/* 82241EACh case    1:*/		return 0x82241EB0;
		  /* 82241EB0h */ case    2:  		/* lwz R9, <#[R31 + 4]> */
		/* 82241EB0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82241EB0h case    2:*/		return 0x82241EB4;
		  /* 82241EB4h */ case    3:  		/* mr R7, R27 */
		/* 82241EB4h case    3:*/		regs.R7 = regs.R27;
		/* 82241EB4h case    3:*/		return 0x82241EB8;
		  /* 82241EB8h */ case    4:  		/* mr R5, R24 */
		/* 82241EB8h case    4:*/		regs.R5 = regs.R24;
		/* 82241EB8h case    4:*/		return 0x82241EBC;
		  /* 82241EBCh */ case    5:  		/* subf R11, R9, R11 */
		/* 82241EBCh case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82241EBCh case    5:*/		return 0x82241EC0;
		  /* 82241EC0h */ case    6:  		/* mr R4, R26 */
		/* 82241EC0h case    6:*/		regs.R4 = regs.R26;
		/* 82241EC0h case    6:*/		return 0x82241EC4;
		  /* 82241EC4h */ case    7:  		/* divw R11, R11, R10 */
		/* 82241EC4h case    7:*/		cpu::op::divw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82241EC4h case    7:*/		return 0x82241EC8;
		  /* 82241EC8h */ case    8:  		/* mr R3, R31 */
		/* 82241EC8h case    8:*/		regs.R3 = regs.R31;
		/* 82241EC8h case    8:*/		return 0x82241ECC;
		  /* 82241ECCh */ case    9:  		/* subf R6, R27, R11 */
		/* 82241ECCh case    9:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R27,regs.R11);
		/* 82241ECCh case    9:*/		return 0x82241ED0;
		  /* 82241ED0h */ case   10:  		/* bl -14728 */
		/* 82241ED0h case   10:*/		regs.LR = 0x82241ED4; return 0x8223E548;
		/* 82241ED0h case   10:*/		return 0x82241ED4;
		  /* 82241ED4h */ case   11:  		/* li R27, 0 */
		/* 82241ED4h case   11:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82241ED4h case   11:*/		return 0x82241ED8;
		  /* 82241ED8h */ case   12:  		/* li R26, 0 */
		/* 82241ED8h case   12:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82241ED8h case   12:*/		return 0x82241EDC;
		  /* 82241EDCh */ case   13:  		/* li R24, 0 */
		/* 82241EDCh case   13:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82241EDCh case   13:*/		return 0x82241EE0;
		  /* 82241EE0h */ case   14:  		/* li R19, 0 */
		/* 82241EE0h case   14:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 82241EE0h case   14:*/		return 0x82241EE4;
	}
	return 0x82241EE4;
} // Block from 82241EA8h-82241EE4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82241EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241EE4);
		  /* 82241EE4h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 82241EE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82241EE4h case    0:*/		return 0x82241EE8;
		  /* 82241EE8h */ case    1:  		/* mr R4, R31 */
		/* 82241EE8h case    1:*/		regs.R4 = regs.R31;
		/* 82241EE8h case    1:*/		return 0x82241EEC;
		  /* 82241EECh */ case    2:  		/* mr R3, R28 */
		/* 82241EECh case    2:*/		regs.R3 = regs.R28;
		/* 82241EECh case    2:*/		return 0x82241EF0;
		  /* 82241EF0h */ case    3:  		/* lwz R6, <#[R31]> */
		/* 82241EF0h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 82241EF0h case    3:*/		return 0x82241EF4;
		  /* 82241EF4h */ case    4:  		/* lwz R5, <#[R31 + 16]> */
		/* 82241EF4h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 82241EF4h case    4:*/		return 0x82241EF8;
		  /* 82241EF8h */ case    5:  		/* lwz R11, <#[R11 + 16]> */
		/* 82241EF8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82241EF8h case    5:*/		return 0x82241EFC;
		  /* 82241EFCh */ case    6:  		/* mtspr CTR, R11 */
		/* 82241EFCh case    6:*/		regs.CTR = regs.R11;
		/* 82241EFCh case    6:*/		return 0x82241F00;
		  /* 82241F00h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82241F00h case    7:*/		if ( 1 ) { regs.LR = 0x82241F04; return (uint32)regs.CTR; }
		/* 82241F00h case    7:*/		return 0x82241F04;
	}
	return 0x82241F04;
} // Block from 82241EE4h-82241F04h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82241F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241F04);
		  /* 82241F04h */ case    0:  		/* lwz R28, <#[R28 + 8]> */
		/* 82241F04h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000008) );
		/* 82241F04h case    0:*/		return 0x82241F08;
		  /* 82241F08h */ case    1:  		/* lwz R11, <#[R28 + 8]> */
		/* 82241F08h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82241F08h case    1:*/		return 0x82241F0C;
		  /* 82241F0Ch */ case    2:  		/* stw R28, <#[R1 + 80]> */
		/* 82241F0Ch case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 82241F0Ch case    2:*/		return 0x82241F10;
		  /* 82241F10h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 82241F10h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82241F10h case    3:*/		return 0x82241F14;
		  /* 82241F14h */ case    4:  		/* bc 4, CR6_EQ, -1480 */
		/* 82241F14h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8224194C;  }
		/* 82241F14h case    4:*/		return 0x82241F18;
	}
	return 0x82241F18;
} // Block from 82241F04h-82241F18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82241F18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241F18);
		  /* 82241F18h */ case    0:  		/* rlwinm. R11, R19, 0, 24, 31 */
		/* 82241F18h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R19);
		/* 82241F18h case    0:*/		return 0x82241F1C;
		  /* 82241F1Ch */ case    1:  		/* bc 12, CR0_EQ, 56 */
		/* 82241F1Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82241F54;  }
		/* 82241F1Ch case    1:*/		return 0x82241F20;
		  /* 82241F20h */ case    2:  		/* cmpwi CR6, R27, 0 */
		/* 82241F20h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82241F20h case    2:*/		return 0x82241F24;
		  /* 82241F24h */ case    3:  		/* bc 4, CR6_GT, 48 */
		/* 82241F24h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82241F54;  }
		/* 82241F24h case    3:*/		return 0x82241F28;
		  /* 82241F28h */ case    4:  		/* lwz R11, <#[R31 + 16]> */
		/* 82241F28h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82241F28h case    4:*/		return 0x82241F2C;
		  /* 82241F2Ch */ case    5:  		/* li R10, 12 */
		/* 82241F2Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0xC);
		/* 82241F2Ch case    5:*/		return 0x82241F30;
		  /* 82241F30h */ case    6:  		/* lwz R9, <#[R31 + 4]> */
		/* 82241F30h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82241F30h case    6:*/		return 0x82241F34;
		  /* 82241F34h */ case    7:  		/* mr R7, R27 */
		/* 82241F34h case    7:*/		regs.R7 = regs.R27;
		/* 82241F34h case    7:*/		return 0x82241F38;
		  /* 82241F38h */ case    8:  		/* mr R5, R24 */
		/* 82241F38h case    8:*/		regs.R5 = regs.R24;
		/* 82241F38h case    8:*/		return 0x82241F3C;
		  /* 82241F3Ch */ case    9:  		/* subf R11, R9, R11 */
		/* 82241F3Ch case    9:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82241F3Ch case    9:*/		return 0x82241F40;
		  /* 82241F40h */ case   10:  		/* mr R4, R26 */
		/* 82241F40h case   10:*/		regs.R4 = regs.R26;
		/* 82241F40h case   10:*/		return 0x82241F44;
		  /* 82241F44h */ case   11:  		/* divw R11, R11, R10 */
		/* 82241F44h case   11:*/		cpu::op::divw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82241F44h case   11:*/		return 0x82241F48;
		  /* 82241F48h */ case   12:  		/* mr R3, R31 */
		/* 82241F48h case   12:*/		regs.R3 = regs.R31;
		/* 82241F48h case   12:*/		return 0x82241F4C;
		  /* 82241F4Ch */ case   13:  		/* subf R6, R27, R11 */
		/* 82241F4Ch case   13:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R27,regs.R11);
		/* 82241F4Ch case   13:*/		return 0x82241F50;
		  /* 82241F50h */ case   14:  		/* bl -14856 */
		/* 82241F50h case   14:*/		regs.LR = 0x82241F54; return 0x8223E548;
		/* 82241F50h case   14:*/		return 0x82241F54;
	}
	return 0x82241F54;
} // Block from 82241F18h-82241F54h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82241F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241F54);
		  /* 82241F54h */ case    0:  		/* addi R1, R1, 256 */
		/* 82241F54h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 82241F54h case    0:*/		return 0x82241F58;
		  /* 82241F58h */ case    1:  		/* b -1772776 */
		/* 82241F58h case    1:*/		return 0x82091270;
		/* 82241F58h case    1:*/		return 0x82241F5C;
		  /* 82241F5Ch */ case    2:  		/* nop */
		/* 82241F5Ch case    2:*/		cpu::op::nop();
		/* 82241F5Ch case    2:*/		return 0x82241F60;
	}
	return 0x82241F60;
} // Block from 82241F54h-82241F60h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82241F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241F60);
		  /* 82241F60h */ case    0:  		/* mfspr R12, LR */
		/* 82241F60h case    0:*/		regs.R12 = regs.LR;
		/* 82241F60h case    0:*/		return 0x82241F64;
		  /* 82241F64h */ case    1:  		/* bl -1772808 */
		/* 82241F64h case    1:*/		regs.LR = 0x82241F68; return 0x8209125C;
		/* 82241F64h case    1:*/		return 0x82241F68;
		  /* 82241F68h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82241F68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82241F68h case    2:*/		return 0x82241F6C;
		  /* 82241F6Ch */ case    3:  		/* mr R30, R3 */
		/* 82241F6Ch case    3:*/		regs.R30 = regs.R3;
		/* 82241F6Ch case    3:*/		return 0x82241F70;
		  /* 82241F70h */ case    4:  		/* lwz R3, <#[R3 + 120]> */
		/* 82241F70h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000078) );
		/* 82241F70h case    4:*/		return 0x82241F74;
		  /* 82241F74h */ case    5:  		/* mr R29, R4 */
		/* 82241F74h case    5:*/		regs.R29 = regs.R4;
		/* 82241F74h case    5:*/		return 0x82241F78;
		  /* 82241F78h */ case    6:  		/* bl 101848 */
		/* 82241F78h case    6:*/		regs.LR = 0x82241F7C; return 0x8225AD50;
		/* 82241F78h case    6:*/		return 0x82241F7C;
		  /* 82241F7Ch */ case    7:  		/* li R5, 1 */
		/* 82241F7Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82241F7Ch case    7:*/		return 0x82241F80;
		  /* 82241F80h */ case    8:  		/* li R4, 34 */
		/* 82241F80h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x22);
		/* 82241F80h case    8:*/		return 0x82241F84;
		  /* 82241F84h */ case    9:  		/* mr R31, R3 */
		/* 82241F84h case    9:*/		regs.R31 = regs.R3;
		/* 82241F84h case    9:*/		return 0x82241F88;
		  /* 82241F88h */ case   10:  		/* bl -959608 */
		/* 82241F88h case   10:*/		regs.LR = 0x82241F8C; return 0x82157B10;
		/* 82241F88h case   10:*/		return 0x82241F8C;
		  /* 82241F8Ch */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 82241F8Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82241F8Ch case   11:*/		return 0x82241F90;
		  /* 82241F90h */ case   12:  		/* bc 12, CR0_EQ, 64 */
		/* 82241F90h case   12:*/		if ( regs.CR[0].eq ) { return 0x82241FD0;  }
		/* 82241F90h case   12:*/		return 0x82241F94;
		  /* 82241F94h */ case   13:  		/* lwz R11, <#[R30 + 8]> */
		/* 82241F94h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82241F94h case   13:*/		return 0x82241F98;
		  /* 82241F98h */ case   14:  		/* li R10, 6 */
		/* 82241F98h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x6);
		/* 82241F98h case   14:*/		return 0x82241F9C;
		  /* 82241F9Ch */ case   15:  		/* subf R11, R11, R31 */
		/* 82241F9Ch case   15:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82241F9Ch case   15:*/		return 0x82241FA0;
		  /* 82241FA0h */ case   16:  		/* divw R11, R11, R10 */
		/* 82241FA0h case   16:*/		cpu::op::divw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82241FA0h case   16:*/		return 0x82241FA4;
		  /* 82241FA4h */ case   17:  		/* cmpw CR6, R29, R11 */
		/* 82241FA4h case   17:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 82241FA4h case   17:*/		return 0x82241FA8;
		  /* 82241FA8h */ case   18:  		/* bc 12, CR6_GT, 40 */
		/* 82241FA8h case   18:*/		if ( regs.CR[6].gt ) { return 0x82241FD0;  }
		/* 82241FA8h case   18:*/		return 0x82241FAC;
		  /* 82241FACh */ case   19:  		/* lis R11, -32252 */
		/* 82241FACh case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82241FACh case   19:*/		return 0x82241FB0;
		  /* 82241FB0h */ case   20:  		/* lis R10, -32252 */
		/* 82241FB0h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82241FB0h case   20:*/		return 0x82241FB4;
		  /* 82241FB4h */ case   21:  		/* lis R9, -32253 */
		/* 82241FB4h case   21:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82241FB4h case   21:*/		return 0x82241FB8;
		  /* 82241FB8h */ case   22:  		/* addi R6, R11, 10344 */
		/* 82241FB8h case   22:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2868);
		/* 82241FB8h case   22:*/		return 0x82241FBC;
		  /* 82241FBCh */ case   23:  		/* addi R5, R10, 11624 */
		/* 82241FBCh case   23:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x2D68);
		/* 82241FBCh case   23:*/		return 0x82241FC0;
		  /* 82241FC0h */ case   24:  		/* addi R4, R9, 27460 */
		/* 82241FC0h case   24:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82241FC0h case   24:*/		return 0x82241FC4;
		  /* 82241FC4h */ case   25:  		/* li R7, 1677 */
		/* 82241FC4h case   25:*/		cpu::op::li<0>(regs,&regs.R7,0x68D);
		/* 82241FC4h case   25:*/		return 0x82241FC8;
		  /* 82241FC8h */ case   26:  		/* li R3, 0 */
		/* 82241FC8h case   26:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82241FC8h case   26:*/		return 0x82241FCC;
		  /* 82241FCCh */ case   27:  		/* bl -959428 */
		/* 82241FCCh case   27:*/		regs.LR = 0x82241FD0; return 0x82157C08;
		/* 82241FCCh case   27:*/		return 0x82241FD0;
	}
	return 0x82241FD0;
} // Block from 82241F60h-82241FD0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82241FD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241FD0);
		  /* 82241FD0h */ case    0:  		/* mr R6, R29 */
		/* 82241FD0h case    0:*/		regs.R6 = regs.R29;
		/* 82241FD0h case    0:*/		return 0x82241FD4;
		  /* 82241FD4h */ case    1:  		/* li R5, 13 */
		/* 82241FD4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0xD);
		/* 82241FD4h case    1:*/		return 0x82241FD8;
		  /* 82241FD8h */ case    2:  		/* li R4, 1 */
		/* 82241FD8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82241FD8h case    2:*/		return 0x82241FDC;
		  /* 82241FDCh */ case    3:  		/* mr R3, R31 */
		/* 82241FDCh case    3:*/		regs.R3 = regs.R31;
		/* 82241FDCh case    3:*/		return 0x82241FE0;
		  /* 82241FE0h */ case    4:  		/* bl -959608 */
		/* 82241FE0h case    4:*/		regs.LR = 0x82241FE4; return 0x82157B68;
		/* 82241FE0h case    4:*/		return 0x82241FE4;
		  /* 82241FE4h */ case    5:  		/* addi R1, R1, 112 */
		/* 82241FE4h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82241FE4h case    5:*/		return 0x82241FE8;
		  /* 82241FE8h */ case    6:  		/* b -1772860 */
		/* 82241FE8h case    6:*/		return 0x820912AC;
		/* 82241FE8h case    6:*/		return 0x82241FEC;
		  /* 82241FECh */ case    7:  		/* nop */
		/* 82241FECh case    7:*/		cpu::op::nop();
		/* 82241FECh case    7:*/		return 0x82241FF0;
	}
	return 0x82241FF0;
} // Block from 82241FD0h-82241FF0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82241FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82241FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82241FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82241FF0);
		  /* 82241FF0h */ case    0:  		/* mfspr R12, LR */
		/* 82241FF0h case    0:*/		regs.R12 = regs.LR;
		/* 82241FF0h case    0:*/		return 0x82241FF4;
		  /* 82241FF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82241FF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82241FF4h case    1:*/		return 0x82241FF8;
		  /* 82241FF8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82241FF8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82241FF8h case    2:*/		return 0x82241FFC;
		  /* 82241FFCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82241FFCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82241FFCh case    3:*/		return 0x82242000;
		  /* 82242000h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82242000h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82242000h case    4:*/		return 0x82242004;
		  /* 82242004h */ case    5:  		/* mr R31, R3 */
		/* 82242004h case    5:*/		regs.R31 = regs.R3;
		/* 82242004h case    5:*/		return 0x82242008;
		  /* 82242008h */ case    6:  		/* lwz R3, <#[R3 + 112]> */
		/* 82242008h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000070) );
		/* 82242008h case    6:*/		return 0x8224200C;
		  /* 8224200Ch */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 8224200Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224200Ch case    7:*/		return 0x82242010;
		  /* 82242010h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82242010h case    8:*/		if ( regs.CR[6].eq ) { return 0x8224201C;  }
		/* 82242010h case    8:*/		return 0x82242014;
		  /* 82242014h */ case    9:  		/* li R4, 1 */
		/* 82242014h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82242014h case    9:*/		return 0x82242018;
		  /* 82242018h */ case   10:  		/* bl -9344 */
		/* 82242018h case   10:*/		regs.LR = 0x8224201C; return 0x8223FB98;
		/* 82242018h case   10:*/		return 0x8224201C;
	}
	return 0x8224201C;
} // Block from 82241FF0h-8224201Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224201Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224201C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224201C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224201C);
		  /* 8224201Ch */ case    0:  		/* lwz R3, <#[R31 + 116]> */
		/* 8224201Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000074) );
		/* 8224201Ch case    0:*/		return 0x82242020;
		  /* 82242020h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82242020h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82242020h case    1:*/		return 0x82242024;
		  /* 82242024h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82242024h case    2:*/		if ( regs.CR[6].eq ) { return 0x82242030;  }
		/* 82242024h case    2:*/		return 0x82242028;
		  /* 82242028h */ case    3:  		/* li R4, 1 */
		/* 82242028h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82242028h case    3:*/		return 0x8224202C;
		  /* 8224202Ch */ case    4:  		/* bl -9364 */
		/* 8224202Ch case    4:*/		regs.LR = 0x82242030; return 0x8223FB98;
		/* 8224202Ch case    4:*/		return 0x82242030;
	}
	return 0x82242030;
} // Block from 8224201Ch-82242030h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82242030h
// Function '?PostAssemble@IRStartCallRoutine@XGRAPHICS@@UAAXPAVAssembler@2@PADPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242030);
		  /* 82242030h */ case    0:  		/* lwz R3, <#[R31 + 120]> */
		/* 82242030h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000078) );
		/* 82242030h case    0:*/		return 0x82242034;
		  /* 82242034h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82242034h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82242034h case    1:*/		return 0x82242038;
		  /* 82242038h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82242038h case    2:*/		if ( regs.CR[6].eq ) { return 0x82242044;  }
		/* 82242038h case    2:*/		return 0x8224203C;
		  /* 8224203Ch */ case    3:  		/* li R4, 1 */
		/* 8224203Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224203Ch case    3:*/		return 0x82242040;
		  /* 82242040h */ case    4:  		/* bl -9384 */
		/* 82242040h case    4:*/		regs.LR = 0x82242044; return 0x8223FB98;
		/* 82242040h case    4:*/		return 0x82242044;
	}
	return 0x82242044;
} // Block from 82242030h-82242044h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82242044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242044);
		  /* 82242044h */ case    0:  		/* lwz R3, <#[R31 + 104]> */
		/* 82242044h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000068) );
		/* 82242044h case    0:*/		return 0x82242048;
		  /* 82242048h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82242048h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82242048h case    1:*/		return 0x8224204C;
		  /* 8224204Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8224204Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82242058;  }
		/* 8224204Ch case    2:*/		return 0x82242050;
		  /* 82242050h */ case    3:  		/* li R4, 1 */
		/* 82242050h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82242050h case    3:*/		return 0x82242054;
		  /* 82242054h */ case    4:  		/* bl -9404 */
		/* 82242054h case    4:*/		regs.LR = 0x82242058; return 0x8223FB98;
		/* 82242054h case    4:*/		return 0x82242058;
	}
	return 0x82242058;
} // Block from 82242044h-82242058h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82242058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242058);
		  /* 82242058h */ case    0:  		/* lwz R3, <#[R31 + 100]> */
		/* 82242058h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000064) );
		/* 82242058h case    0:*/		return 0x8224205C;
		  /* 8224205Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8224205Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224205Ch case    1:*/		return 0x82242060;
		  /* 82242060h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82242060h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224206C;  }
		/* 82242060h case    2:*/		return 0x82242064;
		  /* 82242064h */ case    3:  		/* li R4, 1 */
		/* 82242064h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82242064h case    3:*/		return 0x82242068;
		  /* 82242068h */ case    4:  		/* bl -9424 */
		/* 82242068h case    4:*/		regs.LR = 0x8224206C; return 0x8223FB98;
		/* 82242068h case    4:*/		return 0x8224206C;
	}
	return 0x8224206C;
} // Block from 82242058h-8224206Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224206Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224206C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224206C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224206C);
		  /* 8224206Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8224206Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224206Ch case    0:*/		return 0x82242070;
		  /* 82242070h */ case    1:  		/* lwz R4, <#[R31 + 52]> */
		/* 82242070h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000034) );
		/* 82242070h case    1:*/		return 0x82242074;
		  /* 82242074h */ case    2:  		/* lwz R10, <#[R11 + 1436]> */
		/* 82242074h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000059C) );
		/* 82242074h case    2:*/		return 0x82242078;
		  /* 82242078h */ case    3:  		/* lwz R3, <#[R11 + 1444]> */
		/* 82242078h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005A4) );
		/* 82242078h case    3:*/		return 0x8224207C;
		  /* 8224207Ch */ case    4:  		/* mtspr CTR, R10 */
		/* 8224207Ch case    4:*/		regs.CTR = regs.R10;
		/* 8224207Ch case    4:*/		return 0x82242080;
		  /* 82242080h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 82242080h case    5:*/		if ( 1 ) { regs.LR = 0x82242084; return (uint32)regs.CTR; }
		/* 82242080h case    5:*/		return 0x82242084;
		  /* 82242084h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 82242084h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82242084h case    6:*/		return 0x82242088;
		  /* 82242088h */ case    7:  		/* lwz R4, <#[R31 + 4]> */
		/* 82242088h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 82242088h case    7:*/		return 0x8224208C;
		  /* 8224208Ch */ case    8:  		/* lwz R10, <#[R11 + 1436]> */
		/* 8224208Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000059C) );
		/* 8224208Ch case    8:*/		return 0x82242090;
		  /* 82242090h */ case    9:  		/* lwz R3, <#[R11 + 1444]> */
		/* 82242090h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005A4) );
		/* 82242090h case    9:*/		return 0x82242094;
		  /* 82242094h */ case   10:  		/* mtspr CTR, R10 */
		/* 82242094h case   10:*/		regs.CTR = regs.R10;
		/* 82242094h case   10:*/		return 0x82242098;
		  /* 82242098h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 82242098h case   11:*/		if ( 1 ) { regs.LR = 0x8224209C; return (uint32)regs.CTR; }
		/* 82242098h case   11:*/		return 0x8224209C;
		  /* 8224209Ch */ case   12:  		/* lwz R11, <#[R31]> */
		/* 8224209Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224209Ch case   12:*/		return 0x822420A0;
		  /* 822420A0h */ case   13:  		/* lwz R4, <#[R31 + 8]> */
		/* 822420A0h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 822420A0h case   13:*/		return 0x822420A4;
		  /* 822420A4h */ case   14:  		/* lwz R10, <#[R11 + 1436]> */
		/* 822420A4h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000059C) );
		/* 822420A4h case   14:*/		return 0x822420A8;
		  /* 822420A8h */ case   15:  		/* lwz R3, <#[R11 + 1444]> */
		/* 822420A8h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005A4) );
		/* 822420A8h case   15:*/		return 0x822420AC;
		  /* 822420ACh */ case   16:  		/* mtspr CTR, R10 */
		/* 822420ACh case   16:*/		regs.CTR = regs.R10;
		/* 822420ACh case   16:*/		return 0x822420B0;
	}
	return 0x822420B0;
} // Block from 8224206Ch-822420B0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822420B0h
// Function '?PostAssemble@IREndCallRoutine@XGRAPHICS@@UAAXPAVAssembler@2@PADPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822420B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822420B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822420B0);
		  /* 822420B0h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 822420B0h case    0:*/		if ( 1 ) { regs.LR = 0x822420B4; return (uint32)regs.CTR; }
		/* 822420B0h case    0:*/		return 0x822420B4;
		  /* 822420B4h */ case    1:  		/* lwz R4, <#[R31 + 20]> */
		/* 822420B4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 822420B4h case    1:*/		return 0x822420B8;
		  /* 822420B8h */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 822420B8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 822420B8h case    2:*/		return 0x822420BC;
		  /* 822420BCh */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 822420BCh case    3:*/		if ( regs.CR[6].eq ) { return 0x822420D4;  }
		/* 822420BCh case    3:*/		return 0x822420C0;
		  /* 822420C0h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 822420C0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822420C0h case    4:*/		return 0x822420C4;
		  /* 822420C4h */ case    5:  		/* lwz R10, <#[R11 + 1436]> */
		/* 822420C4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000059C) );
		/* 822420C4h case    5:*/		return 0x822420C8;
		  /* 822420C8h */ case    6:  		/* lwz R3, <#[R11 + 1444]> */
		/* 822420C8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005A4) );
		/* 822420C8h case    6:*/		return 0x822420CC;
		  /* 822420CCh */ case    7:  		/* mtspr CTR, R10 */
		/* 822420CCh case    7:*/		regs.CTR = regs.R10;
		/* 822420CCh case    7:*/		return 0x822420D0;
		  /* 822420D0h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 822420D0h case    8:*/		if ( 1 ) { regs.LR = 0x822420D4; return (uint32)regs.CTR; }
		/* 822420D0h case    8:*/		return 0x822420D4;
	}
	return 0x822420D4;
} // Block from 822420B0h-822420D4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822420D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822420D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822420D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822420D4);
		  /* 822420D4h */ case    0:  		/* lis R30, -32215 */
		/* 822420D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8229);
		/* 822420D4h case    0:*/		return 0x822420D8;
		  /* 822420D8h */ case    1:  		/* lwz R4, <#[R30 - 25560]> */
		/* 822420D8h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0xFFFF9C28) );
		/* 822420D8h case    1:*/		return 0x822420DC;
		  /* 822420DCh */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 822420DCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 822420DCh case    2:*/		return 0x822420E0;
		  /* 822420E0h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 822420E0h case    3:*/		if ( regs.CR[6].eq ) { return 0x822420F8;  }
		/* 822420E0h case    3:*/		return 0x822420E4;
		  /* 822420E4h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 822420E4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822420E4h case    4:*/		return 0x822420E8;
		  /* 822420E8h */ case    5:  		/* lwz R3, <#[R11 + 1452]> */
		/* 822420E8h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005AC) );
		/* 822420E8h case    5:*/		return 0x822420EC;
		  /* 822420ECh */ case    6:  		/* bl -154284 */
		/* 822420ECh case    6:*/		regs.LR = 0x822420F0; return 0x8221C640;
		/* 822420ECh case    6:*/		return 0x822420F0;
		  /* 822420F0h */ case    7:  		/* li R11, 0 */
		/* 822420F0h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822420F0h case    7:*/		return 0x822420F4;
		  /* 822420F4h */ case    8:  		/* stw R11, <#[R30 - 25560]> */
		/* 822420F4h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0xFFFF9C28) );
		/* 822420F4h case    8:*/		return 0x822420F8;
	}
	return 0x822420F8;
} // Block from 822420D4h-822420F8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822420F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822420F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822420F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822420F8);
		  /* 822420F8h */ case    0:  		/* addi R1, R1, 112 */
		/* 822420F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822420F8h case    0:*/		return 0x822420FC;
		  /* 822420FCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822420FCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822420FCh case    1:*/		return 0x82242100;
		  /* 82242100h */ case    2:  		/* mtspr LR, R12 */
		/* 82242100h case    2:*/		regs.LR = regs.R12;
		/* 82242100h case    2:*/		return 0x82242104;
		  /* 82242104h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82242104h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82242104h case    3:*/		return 0x82242108;
	}
	return 0x82242108;
} // Block from 822420F8h-82242108h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82242108h
// Function '?PostAssemble@IRStartMakeCall@XGRAPHICS@@UAAXPAVAssembler@2@PADPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242108);
		  /* 82242108h */ case    0:  		/* ld R31, <#[R1 - 16]> */
		/* 82242108h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82242108h case    0:*/		return 0x8224210C;
		  /* 8224210Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224210Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224210Ch case    1:*/		return 0x82242110;
	}
	return 0x82242110;
} // Block from 82242108h-82242110h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82242110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242110);
		  /* 82242110h */ case    0:  		/* mfspr R12, LR */
		/* 82242110h case    0:*/		regs.R12 = regs.LR;
		/* 82242110h case    0:*/		return 0x82242114;
		  /* 82242114h */ case    1:  		/* bl -1773248 */
		/* 82242114h case    1:*/		regs.LR = 0x82242118; return 0x82091254;
		/* 82242114h case    1:*/		return 0x82242118;
		  /* 82242118h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82242118h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82242118h case    2:*/		return 0x8224211C;
		  /* 8224211Ch */ case    3:  		/* lwz R30, <#[R3 + 12]> */
		/* 8224211Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 8224211Ch case    3:*/		return 0x82242120;
		  /* 82242120h */ case    4:  		/* mr R31, R3 */
		/* 82242120h case    4:*/		regs.R31 = regs.R3;
		/* 82242120h case    4:*/		return 0x82242124;
		  /* 82242124h */ case    5:  		/* mr R29, R4 */
		/* 82242124h case    5:*/		regs.R29 = regs.R4;
		/* 82242124h case    5:*/		return 0x82242128;
		  /* 82242128h */ case    6:  		/* mr R28, R5 */
		/* 82242128h case    6:*/		regs.R28 = regs.R5;
		/* 82242128h case    6:*/		return 0x8224212C;
		  /* 8224212Ch */ case    7:  		/* mr R27, R6 */
		/* 8224212Ch case    7:*/		regs.R27 = regs.R6;
		/* 8224212Ch case    7:*/		return 0x82242130;
		  /* 82242130h */ case    8:  		/* li R6, 1 */
		/* 82242130h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82242130h case    8:*/		return 0x82242134;
		  /* 82242134h */ case    9:  		/* li R5, 1 */
		/* 82242134h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242134h case    9:*/		return 0x82242138;
		  /* 82242138h */ case   10:  		/* li R4, 34 */
		/* 82242138h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x22);
		/* 82242138h case   10:*/		return 0x8224213C;
		  /* 8224213Ch */ case   11:  		/* mr R3, R30 */
		/* 8224213Ch case   11:*/		regs.R3 = regs.R30;
		/* 8224213Ch case   11:*/		return 0x82242140;
		  /* 82242140h */ case   12:  		/* bl -959960 */
		/* 82242140h case   12:*/		regs.LR = 0x82242144; return 0x82157B68;
		/* 82242140h case   12:*/		return 0x82242144;
		  /* 82242144h */ case   13:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 82242144h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 82242144h case   13:*/		return 0x82242148;
		  /* 82242148h */ case   14:  		/* li R5, 1 */
		/* 82242148h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242148h case   14:*/		return 0x8224214C;
		  /* 8224214Ch */ case   15:  		/* mr R3, R30 */
		/* 8224214Ch case   15:*/		regs.R3 = regs.R30;
		/* 8224214Ch case   15:*/		return 0x82242150;
		  /* 82242150h */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 82242150h case   16:*/		if ( regs.CR[0].eq ) { return 0x82242160;  }
		/* 82242150h case   16:*/		return 0x82242154;
		  /* 82242154h */ case   17:  		/* li R6, 1 */
		/* 82242154h case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82242154h case   17:*/		return 0x82242158;
		  /* 82242158h */ case   18:  		/* li R4, 14 */
		/* 82242158h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0xE);
		/* 82242158h case   18:*/		return 0x8224215C;
		  /* 8224215Ch */ case   19:  		/* b 24 */
		/* 8224215Ch case   19:*/		return 0x82242174;
		/* 8224215Ch case   19:*/		return 0x82242160;
	}
	return 0x82242160;
} // Block from 82242110h-82242160h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82242160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242160);
		  /* 82242160h */ case    0:  		/* rlwinm R11, R29, 0, 24, 31 */
		/* 82242160h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R29);
		/* 82242160h case    0:*/		return 0x82242164;
		  /* 82242164h */ case    1:  		/* li R4, 43 */
		/* 82242164h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x2B);
		/* 82242164h case    1:*/		return 0x82242168;
		  /* 82242168h */ case    2:  		/* addi R11, R11, -1 */
		/* 82242168h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82242168h case    2:*/		return 0x8224216C;
		  /* 8224216Ch */ case    3:  		/* cntlzw R11, R11 */
		/* 8224216Ch case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8224216Ch case    3:*/		return 0x82242170;
		  /* 82242170h */ case    4:  		/* rlwinm R6, R11, 27, 31, 31 */
		/* 82242170h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R6,regs.R11);
		/* 82242170h case    4:*/		return 0x82242174;
	}
	return 0x82242174;
} // Block from 82242160h-82242174h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82242174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242174);
		  /* 82242174h */ case    0:  		/* bl -960012 */
		/* 82242174h case    0:*/		regs.LR = 0x82242178; return 0x82157B68;
		/* 82242174h case    0:*/		return 0x82242178;
		  /* 82242178h */ case    1:  		/* mr R6, R28 */
		/* 82242178h case    1:*/		regs.R6 = regs.R28;
		/* 82242178h case    1:*/		return 0x8224217C;
		  /* 8224217Ch */ case    2:  		/* li R5, 8 */
		/* 8224217Ch case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x8);
		/* 8224217Ch case    2:*/		return 0x82242180;
		  /* 82242180h */ case    3:  		/* li R4, 35 */
		/* 82242180h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x23);
		/* 82242180h case    3:*/		return 0x82242184;
		  /* 82242184h */ case    4:  		/* mr R3, R30 */
		/* 82242184h case    4:*/		regs.R3 = regs.R30;
		/* 82242184h case    4:*/		return 0x82242188;
		  /* 82242188h */ case    5:  		/* bl -960032 */
		/* 82242188h case    5:*/		regs.LR = 0x8224218C; return 0x82157B68;
		/* 82242188h case    5:*/		return 0x8224218C;
		  /* 8224218Ch */ case    6:  		/* lis R11, -32252 */
		/* 8224218Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224218Ch case    6:*/		return 0x82242190;
		  /* 82242190h */ case    7:  		/* li R5, 4 */
		/* 82242190h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 82242190h case    7:*/		return 0x82242194;
		  /* 82242194h */ case    8:  		/* addi R11, R11, 25976 */
		/* 82242194h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6578);
		/* 82242194h case    8:*/		return 0x82242198;
		  /* 82242198h */ case    9:  		/* li R4, 45 */
		/* 82242198h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x2D);
		/* 82242198h case    9:*/		return 0x8224219C;
		  /* 8224219Ch */ case   10:  		/* mr R3, R30 */
		/* 8224219Ch case   10:*/		regs.R3 = regs.R30;
		/* 8224219Ch case   10:*/		return 0x822421A0;
		  /* 822421A0h */ case   11:  		/* lwz R6, <#[R11 + 64]> */
		/* 822421A0h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000040) );
		/* 822421A0h case   11:*/		return 0x822421A4;
		  /* 822421A4h */ case   12:  		/* bl -960060 */
		/* 822421A4h case   12:*/		regs.LR = 0x822421A8; return 0x82157B68;
		/* 822421A4h case   12:*/		return 0x822421A8;
		  /* 822421A8h */ case   13:  		/* lwz R3, <#[R31 + 120]> */
		/* 822421A8h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000078) );
		/* 822421A8h case   13:*/		return 0x822421AC;
		  /* 822421ACh */ case   14:  		/* lwz R4, <#[R3 + 4]> */
		/* 822421ACh case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 822421ACh case   14:*/		return 0x822421B0;
	}
	return 0x822421B0;
} // Block from 82242174h-822421B0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822421B0h
// Function '?IsSimple@IRInst@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822421B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822421B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822421B0);
		  /* 822421B0h */ case    0:  		/* bl 71952 */
		/* 822421B0h case    0:*/		regs.LR = 0x822421B4; return 0x82253AC0;
		/* 822421B0h case    0:*/		return 0x822421B4;
		  /* 822421B4h */ case    1:  		/* stw R30, <#[R3]> */
		/* 822421B4h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 822421B4h case    1:*/		return 0x822421B8;
		  /* 822421B8h */ case    2:  		/* lwz R10, <#[R31 + 56]> */
		/* 822421B8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 822421B8h case    2:*/		return 0x822421BC;
		  /* 822421BCh */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 822421BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822421BCh case    3:*/		return 0x822421C0;
		  /* 822421C0h */ case    4:  		/* addi R11, R11, 6 */
		/* 822421C0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6);
		/* 822421C0h case    4:*/		return 0x822421C4;
		  /* 822421C4h */ case    5:  		/* addi R10, R10, 1 */
		/* 822421C4h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822421C4h case    5:*/		return 0x822421C8;
		  /* 822421C8h */ case    6:  		/* stw R11, <#[R31 + 12]> */
		/* 822421C8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822421C8h case    6:*/		return 0x822421CC;
		  /* 822421CCh */ case    7:  		/* stw R10, <#[R31 + 56]> */
		/* 822421CCh case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 822421CCh case    7:*/		return 0x822421D0;
		  /* 822421D0h */ case    8:  		/* addi R1, R1, 128 */
		/* 822421D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822421D0h case    8:*/		return 0x822421D4;
		  /* 822421D4h */ case    9:  		/* b -1773360 */
		/* 822421D4h case    9:*/		return 0x820912A4;
		/* 822421D4h case    9:*/		return 0x822421D8;
	}
	return 0x822421D8;
} // Block from 822421B0h-822421D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822421D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822421D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822421D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822421D8);
		  /* 822421D8h */ case    0:  		/* mfspr R12, LR */
		/* 822421D8h case    0:*/		regs.R12 = regs.LR;
		/* 822421D8h case    0:*/		return 0x822421DC;
		  /* 822421DCh */ case    1:  		/* bl -1773440 */
		/* 822421DCh case    1:*/		regs.LR = 0x822421E0; return 0x8209125C;
		/* 822421DCh case    1:*/		return 0x822421E0;
		  /* 822421E0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 822421E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822421E0h case    2:*/		return 0x822421E4;
		  /* 822421E4h */ case    3:  		/* lwz R29, <#[R3 + 12]> */
		/* 822421E4h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x0000000C) );
		/* 822421E4h case    3:*/		return 0x822421E8;
		  /* 822421E8h */ case    4:  		/* mr R30, R3 */
		/* 822421E8h case    4:*/		regs.R30 = regs.R3;
		/* 822421E8h case    4:*/		return 0x822421EC;
		  /* 822421ECh */ case    5:  		/* mr R31, R4 */
		/* 822421ECh case    5:*/		regs.R31 = regs.R4;
		/* 822421ECh case    5:*/		return 0x822421F0;
		  /* 822421F0h */ case    6:  		/* li R6, 0 */
		/* 822421F0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822421F0h case    6:*/		return 0x822421F4;
		  /* 822421F4h */ case    7:  		/* li R5, 13 */
		/* 822421F4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0xD);
		/* 822421F4h case    7:*/		return 0x822421F8;
		  /* 822421F8h */ case    8:  		/* li R4, 1 */
		/* 822421F8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822421F8h case    8:*/		return 0x822421FC;
		  /* 822421FCh */ case    9:  		/* mr R3, R29 */
		/* 822421FCh case    9:*/		regs.R3 = regs.R29;
		/* 822421FCh case    9:*/		return 0x82242200;
		  /* 82242200h */ case   10:  		/* bl -960152 */
		/* 82242200h case   10:*/		regs.LR = 0x82242204; return 0x82157B68;
		/* 82242200h case   10:*/		return 0x82242204;
		  /* 82242204h */ case   11:  		/* li R6, 0 */
		/* 82242204h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82242204h case   11:*/		return 0x82242208;
		  /* 82242208h */ case   12:  		/* li R5, 3 */
		/* 82242208h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82242208h case   12:*/		return 0x8224220C;
		  /* 8224220Ch */ case   13:  		/* li R4, 14 */
		/* 8224220Ch case   13:*/		cpu::op::li<0>(regs,&regs.R4,0xE);
		/* 8224220Ch case   13:*/		return 0x82242210;
		  /* 82242210h */ case   14:  		/* mr R3, R29 */
		/* 82242210h case   14:*/		regs.R3 = regs.R29;
		/* 82242210h case   14:*/		return 0x82242214;
		  /* 82242214h */ case   15:  		/* bl -960172 */
		/* 82242214h case   15:*/		regs.LR = 0x82242218; return 0x82157B68;
		/* 82242214h case   15:*/		return 0x82242218;
		  /* 82242218h */ case   16:  		/* mr R6, R31 */
		/* 82242218h case   16:*/		regs.R6 = regs.R31;
		/* 82242218h case   16:*/		return 0x8224221C;
		  /* 8224221Ch */ case   17:  		/* li R5, 5 */
		/* 8224221Ch case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x5);
		/* 8224221Ch case   17:*/		return 0x82242220;
		  /* 82242220h */ case   18:  		/* li R4, 17 */
		/* 82242220h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x11);
		/* 82242220h case   18:*/		return 0x82242224;
		  /* 82242224h */ case   19:  		/* mr R3, R29 */
		/* 82242224h case   19:*/		regs.R3 = regs.R29;
		/* 82242224h case   19:*/		return 0x82242228;
		  /* 82242228h */ case   20:  		/* bl -960192 */
		/* 82242228h case   20:*/		regs.LR = 0x8224222C; return 0x82157B68;
		/* 82242228h case   20:*/		return 0x8224222C;
		  /* 8224222Ch */ case   21:  		/* li R6, 0 */
		/* 8224222Ch case   21:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224222Ch case   21:*/		return 0x82242230;
		  /* 82242230h */ case   22:  		/* li R5, 22 */
		/* 82242230h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x16);
		/* 82242230h case   22:*/		return 0x82242234;
		  /* 82242234h */ case   23:  		/* li R4, 22 */
		/* 82242234h case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x16);
		/* 82242234h case   23:*/		return 0x82242238;
		  /* 82242238h */ case   24:  		/* mr R3, R29 */
		/* 82242238h case   24:*/		regs.R3 = regs.R29;
		/* 82242238h case   24:*/		return 0x8224223C;
		  /* 8224223Ch */ case   25:  		/* bl -960212 */
		/* 8224223Ch case   25:*/		regs.LR = 0x82242240; return 0x82157B68;
		/* 8224223Ch case   25:*/		return 0x82242240;
		  /* 82242240h */ case   26:  		/* li R6, 0 */
		/* 82242240h case   26:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82242240h case   26:*/		return 0x82242244;
		  /* 82242244h */ case   27:  		/* li R5, 1 */
		/* 82242244h case   27:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242244h case   27:*/		return 0x82242248;
		  /* 82242248h */ case   28:  		/* li R4, 44 */
		/* 82242248h case   28:*/		cpu::op::li<0>(regs,&regs.R4,0x2C);
		/* 82242248h case   28:*/		return 0x8224224C;
		  /* 8224224Ch */ case   29:  		/* mr R3, R29 */
		/* 8224224Ch case   29:*/		regs.R3 = regs.R29;
		/* 8224224Ch case   29:*/		return 0x82242250;
		  /* 82242250h */ case   30:  		/* bl -960232 */
		/* 82242250h case   30:*/		regs.LR = 0x82242254; return 0x82157B68;
		/* 82242250h case   30:*/		return 0x82242254;
		  /* 82242254h */ case   31:  		/* lis R11, -32252 */
		/* 82242254h case   31:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242254h case   31:*/		return 0x82242258;
		  /* 82242258h */ case   32:  		/* li R5, 4 */
		/* 82242258h case   32:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 82242258h case   32:*/		return 0x8224225C;
		  /* 8224225Ch */ case   33:  		/* addi R11, R11, 25976 */
		/* 8224225Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6578);
		/* 8224225Ch case   33:*/		return 0x82242260;
	}
	return 0x82242260;
} // Block from 822421D8h-82242260h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82242260h
// Function '?IsSimpleMov@IRInst@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242260);
		  /* 82242260h */ case    0:  		/* li R4, 45 */
		/* 82242260h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x2D);
		/* 82242260h case    0:*/		return 0x82242264;
		  /* 82242264h */ case    1:  		/* mr R3, R29 */
		/* 82242264h case    1:*/		regs.R3 = regs.R29;
		/* 82242264h case    1:*/		return 0x82242268;
		  /* 82242268h */ case    2:  		/* lwz R6, <#[R11 + 48]> */
		/* 82242268h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000030) );
		/* 82242268h case    2:*/		return 0x8224226C;
		  /* 8224226Ch */ case    3:  		/* bl -960260 */
		/* 8224226Ch case    3:*/		regs.LR = 0x82242270; return 0x82157B68;
		/* 8224226Ch case    3:*/		return 0x82242270;
		  /* 82242270h */ case    4:  		/* lwz R3, <#[R30 + 112]> */
		/* 82242270h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000070) );
		/* 82242270h case    4:*/		return 0x82242274;
		  /* 82242274h */ case    5:  		/* lwz R4, <#[R3 + 4]> */
		/* 82242274h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82242274h case    5:*/		return 0x82242278;
		  /* 82242278h */ case    6:  		/* bl 71752 */
		/* 82242278h case    6:*/		regs.LR = 0x8224227C; return 0x82253AC0;
		/* 82242278h case    6:*/		return 0x8224227C;
		  /* 8224227Ch */ case    7:  		/* stw R29, <#[R3]> */
		/* 8224227Ch case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8224227Ch case    7:*/		return 0x82242280;
		  /* 82242280h */ case    8:  		/* lwz R3, <#[R30 + 116]> */
		/* 82242280h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000074) );
		/* 82242280h case    8:*/		return 0x82242284;
		  /* 82242284h */ case    9:  		/* lwz R11, <#[R30 + 56]> */
		/* 82242284h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 82242284h case    9:*/		return 0x82242288;
		  /* 82242288h */ case   10:  		/* addi R31, R11, 1 */
		/* 82242288h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x1);
		/* 82242288h case   10:*/		return 0x8224228C;
		  /* 8224228Ch */ case   11:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224228Ch case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224228Ch case   11:*/		return 0x82242290;
		  /* 82242290h */ case   12:  		/* bl 71728 */
		/* 82242290h case   12:*/		regs.LR = 0x82242294; return 0x82253AC0;
		/* 82242290h case   12:*/		return 0x82242294;
		  /* 82242294h */ case   13:  		/* stw R31, <#[R3]> */
		/* 82242294h case   13:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82242294h case   13:*/		return 0x82242298;
		  /* 82242298h */ case   14:  		/* lwz R10, <#[R30 + 56]> */
		/* 82242298h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000038) );
		/* 82242298h case   14:*/		return 0x8224229C;
		  /* 8224229Ch */ case   15:  		/* lwz R11, <#[R30 + 12]> */
		/* 8224229Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224229Ch case   15:*/		return 0x822422A0;
		  /* 822422A0h */ case   16:  		/* addi R11, R11, 6 */
		/* 822422A0h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6);
		/* 822422A0h case   16:*/		return 0x822422A4;
		  /* 822422A4h */ case   17:  		/* addi R10, R10, 1 */
		/* 822422A4h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822422A4h case   17:*/		return 0x822422A8;
		  /* 822422A8h */ case   18:  		/* stw R11, <#[R30 + 12]> */
		/* 822422A8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 822422A8h case   18:*/		return 0x822422AC;
		  /* 822422ACh */ case   19:  		/* stw R10, <#[R30 + 56]> */
		/* 822422ACh case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000038) );
		/* 822422ACh case   19:*/		return 0x822422B0;
		  /* 822422B0h */ case   20:  		/* addi R1, R1, 112 */
		/* 822422B0h case   20:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822422B0h case   20:*/		return 0x822422B4;
		  /* 822422B4h */ case   21:  		/* b -1773576 */
		/* 822422B4h case   21:*/		return 0x820912AC;
		/* 822422B4h case   21:*/		return 0x822422B8;
	}
	return 0x822422B8;
} // Block from 82242260h-822422B8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 822422B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822422B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822422B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822422B8);
		  /* 822422B8h */ case    0:  		/* mfspr R12, LR */
		/* 822422B8h case    0:*/		regs.R12 = regs.LR;
		/* 822422B8h case    0:*/		return 0x822422BC;
		  /* 822422BCh */ case    1:  		/* bl -1773668 */
		/* 822422BCh case    1:*/		regs.LR = 0x822422C0; return 0x82091258;
		/* 822422BCh case    1:*/		return 0x822422C0;
		  /* 822422C0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822422C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822422C0h case    2:*/		return 0x822422C4;
		  /* 822422C4h */ case    3:  		/* mr R31, R3 */
		/* 822422C4h case    3:*/		regs.R31 = regs.R3;
		/* 822422C4h case    3:*/		return 0x822422C8;
	}
	return 0x822422C8;
} // Block from 822422B8h-822422C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822422C8h
// Function '?IsRedundantCopy@IRInst@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822422C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822422C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822422C8);
		  /* 822422C8h */ case    0:  		/* lwz R3, <#[R3 + 112]> */
		/* 822422C8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000070) );
		/* 822422C8h case    0:*/		return 0x822422CC;
		  /* 822422CCh */ case    1:  		/* mr R30, R4 */
		/* 822422CCh case    1:*/		regs.R30 = regs.R4;
		/* 822422CCh case    1:*/		return 0x822422D0;
		  /* 822422D0h */ case    2:  		/* bl 100992 */
		/* 822422D0h case    2:*/		regs.LR = 0x822422D4; return 0x8225AD50;
		/* 822422D0h case    2:*/		return 0x822422D4;
		  /* 822422D4h */ case    3:  		/* mr R29, R3 */
		/* 822422D4h case    3:*/		regs.R29 = regs.R3;
		/* 822422D4h case    3:*/		return 0x822422D8;
		  /* 822422D8h */ case    4:  		/* lwz R3, <#[R31 + 116]> */
		/* 822422D8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000074) );
		/* 822422D8h case    4:*/		return 0x822422DC;
		  /* 822422DCh */ case    5:  		/* bl 100980 */
		/* 822422DCh case    5:*/		regs.LR = 0x822422E0; return 0x8225AD50;
		/* 822422DCh case    5:*/		return 0x822422E0;
		  /* 822422E0h */ case    6:  		/* lwz R11, <#[R31 + 56]> */
		/* 822422E0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 822422E0h case    6:*/		return 0x822422E4;
		  /* 822422E4h */ case    7:  		/* mr R28, R3 */
		/* 822422E4h case    7:*/		regs.R28 = regs.R3;
		/* 822422E4h case    7:*/		return 0x822422E8;
		  /* 822422E8h */ case    8:  		/* addi R6, R11, 1 */
		/* 822422E8h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1);
		/* 822422E8h case    8:*/		return 0x822422EC;
		  /* 822422ECh */ case    9:  		/* li R5, 13 */
		/* 822422ECh case    9:*/		cpu::op::li<0>(regs,&regs.R5,0xD);
		/* 822422ECh case    9:*/		return 0x822422F0;
		  /* 822422F0h */ case   10:  		/* li R4, 1 */
		/* 822422F0h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822422F0h case   10:*/		return 0x822422F4;
		  /* 822422F4h */ case   11:  		/* mr R3, R29 */
		/* 822422F4h case   11:*/		regs.R3 = regs.R29;
		/* 822422F4h case   11:*/		return 0x822422F8;
		  /* 822422F8h */ case   12:  		/* bl -960400 */
		/* 822422F8h case   12:*/		regs.LR = 0x822422FC; return 0x82157B68;
		/* 822422F8h case   12:*/		return 0x822422FC;
		  /* 822422FCh */ case   13:  		/* mr R6, R28 */
		/* 822422FCh case   13:*/		regs.R6 = regs.R28;
		/* 822422FCh case   13:*/		return 0x82242300;
		  /* 82242300h */ case   14:  		/* li R5, 13 */
		/* 82242300h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0xD);
		/* 82242300h case   14:*/		return 0x82242304;
		  /* 82242304h */ case   15:  		/* li R4, 1 */
		/* 82242304h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82242304h case   15:*/		return 0x82242308;
		  /* 82242308h */ case   16:  		/* lwz R29, <#[R31 + 12]> */
		/* 82242308h case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 82242308h case   16:*/		return 0x8224230C;
		  /* 8224230Ch */ case   17:  		/* mr R3, R29 */
		/* 8224230Ch case   17:*/		regs.R3 = regs.R29;
		/* 8224230Ch case   17:*/		return 0x82242310;
		  /* 82242310h */ case   18:  		/* bl -960424 */
		/* 82242310h case   18:*/		regs.LR = 0x82242314; return 0x82157B68;
		/* 82242310h case   18:*/		return 0x82242314;
		  /* 82242314h */ case   19:  		/* mr R3, R29 */
		/* 82242314h case   19:*/		regs.R3 = regs.R29;
		/* 82242314h case   19:*/		return 0x82242318;
		  /* 82242318h */ case   20:  		/* li R6, 0 */
		/* 82242318h case   20:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82242318h case   20:*/		return 0x8224231C;
		  /* 8224231Ch */ case   21:  		/* li R5, 3 */
		/* 8224231Ch case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8224231Ch case   21:*/		return 0x82242320;
		  /* 82242320h */ case   22:  		/* li R4, 14 */
		/* 82242320h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0xE);
		/* 82242320h case   22:*/		return 0x82242324;
		  /* 82242324h */ case   23:  		/* bl -960444 */
		/* 82242324h case   23:*/		regs.LR = 0x82242328; return 0x82157B68;
		/* 82242324h case   23:*/		return 0x82242328;
		  /* 82242328h */ case   24:  		/* mr R3, R29 */
		/* 82242328h case   24:*/		regs.R3 = regs.R29;
		/* 82242328h case   24:*/		return 0x8224232C;
		  /* 8224232Ch */ case   25:  		/* mr R6, R30 */
		/* 8224232Ch case   25:*/		regs.R6 = regs.R30;
		/* 8224232Ch case   25:*/		return 0x82242330;
		  /* 82242330h */ case   26:  		/* li R5, 5 */
		/* 82242330h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x5);
		/* 82242330h case   26:*/		return 0x82242334;
		  /* 82242334h */ case   27:  		/* li R4, 17 */
		/* 82242334h case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x11);
		/* 82242334h case   27:*/		return 0x82242338;
		  /* 82242338h */ case   28:  		/* bl -960464 */
		/* 82242338h case   28:*/		regs.LR = 0x8224233C; return 0x82157B68;
		/* 82242338h case   28:*/		return 0x8224233C;
		  /* 8224233Ch */ case   29:  		/* mr R3, R29 */
		/* 8224233Ch case   29:*/		regs.R3 = regs.R29;
		/* 8224233Ch case   29:*/		return 0x82242340;
		  /* 82242340h */ case   30:  		/* li R6, 0 */
		/* 82242340h case   30:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82242340h case   30:*/		return 0x82242344;
		  /* 82242344h */ case   31:  		/* li R5, 1 */
		/* 82242344h case   31:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242344h case   31:*/		return 0x82242348;
		  /* 82242348h */ case   32:  		/* li R4, 22 */
		/* 82242348h case   32:*/		cpu::op::li<0>(regs,&regs.R4,0x16);
		/* 82242348h case   32:*/		return 0x8224234C;
		  /* 8224234Ch */ case   33:  		/* bl -960484 */
		/* 8224234Ch case   33:*/		regs.LR = 0x82242350; return 0x82157B68;
		/* 8224234Ch case   33:*/		return 0x82242350;
		  /* 82242350h */ case   34:  		/* mr R3, R29 */
		/* 82242350h case   34:*/		regs.R3 = regs.R29;
		/* 82242350h case   34:*/		return 0x82242354;
		  /* 82242354h */ case   35:  		/* li R6, 0 */
		/* 82242354h case   35:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82242354h case   35:*/		return 0x82242358;
		  /* 82242358h */ case   36:  		/* li R5, 12 */
		/* 82242358h case   36:*/		cpu::op::li<0>(regs,&regs.R5,0xC);
		/* 82242358h case   36:*/		return 0x8224235C;
		  /* 8224235Ch */ case   37:  		/* li R4, 23 */
		/* 8224235Ch case   37:*/		cpu::op::li<0>(regs,&regs.R4,0x17);
		/* 8224235Ch case   37:*/		return 0x82242360;
		  /* 82242360h */ case   38:  		/* bl -960504 */
		/* 82242360h case   38:*/		regs.LR = 0x82242364; return 0x82157B68;
		/* 82242360h case   38:*/		return 0x82242364;
		  /* 82242364h */ case   39:  		/* mr R3, R29 */
		/* 82242364h case   39:*/		regs.R3 = regs.R29;
		/* 82242364h case   39:*/		return 0x82242368;
		  /* 82242368h */ case   40:  		/* li R6, 0 */
		/* 82242368h case   40:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82242368h case   40:*/		return 0x8224236C;
		  /* 8224236Ch */ case   41:  		/* li R5, 2 */
		/* 8224236Ch case   41:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8224236Ch case   41:*/		return 0x82242370;
		  /* 82242370h */ case   42:  		/* li R4, 35 */
		/* 82242370h case   42:*/		cpu::op::li<0>(regs,&regs.R4,0x23);
		/* 82242370h case   42:*/		return 0x82242374;
		  /* 82242374h */ case   43:  		/* bl -960524 */
		/* 82242374h case   43:*/		regs.LR = 0x82242378; return 0x82157B68;
		/* 82242374h case   43:*/		return 0x82242378;
		  /* 82242378h */ case   44:  		/* mr R3, R29 */
		/* 82242378h case   44:*/		regs.R3 = regs.R29;
		/* 82242378h case   44:*/		return 0x8224237C;
		  /* 8224237Ch */ case   45:  		/* li R6, 0 */
		/* 8224237Ch case   45:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224237Ch case   45:*/		return 0x82242380;
		  /* 82242380h */ case   46:  		/* li R5, 6 */
		/* 82242380h case   46:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 82242380h case   46:*/		return 0x82242384;
		  /* 82242384h */ case   47:  		/* li R4, 37 */
		/* 82242384h case   47:*/		cpu::op::li<0>(regs,&regs.R4,0x25);
		/* 82242384h case   47:*/		return 0x82242388;
		  /* 82242388h */ case   48:  		/* bl -960544 */
		/* 82242388h case   48:*/		regs.LR = 0x8224238C; return 0x82157B68;
		/* 82242388h case   48:*/		return 0x8224238C;
		  /* 8224238Ch */ case   49:  		/* mr R3, R29 */
		/* 8224238Ch case   49:*/		regs.R3 = regs.R29;
		/* 8224238Ch case   49:*/		return 0x82242390;
		  /* 82242390h */ case   50:  		/* li R6, 0 */
		/* 82242390h case   50:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82242390h case   50:*/		return 0x82242394;
		  /* 82242394h */ case   51:  		/* li R5, 1 */
		/* 82242394h case   51:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242394h case   51:*/		return 0x82242398;
		  /* 82242398h */ case   52:  		/* li R4, 43 */
		/* 82242398h case   52:*/		cpu::op::li<0>(regs,&regs.R4,0x2B);
		/* 82242398h case   52:*/		return 0x8224239C;
		  /* 8224239Ch */ case   53:  		/* bl -960564 */
		/* 8224239Ch case   53:*/		regs.LR = 0x822423A0; return 0x82157B68;
		/* 8224239Ch case   53:*/		return 0x822423A0;
		  /* 822423A0h */ case   54:  		/* mr R3, R29 */
		/* 822423A0h case   54:*/		regs.R3 = regs.R29;
		/* 822423A0h case   54:*/		return 0x822423A4;
		  /* 822423A4h */ case   55:  		/* li R6, 0 */
		/* 822423A4h case   55:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822423A4h case   55:*/		return 0x822423A8;
		  /* 822423A8h */ case   56:  		/* li R5, 1 */
		/* 822423A8h case   56:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 822423A8h case   56:*/		return 0x822423AC;
		  /* 822423ACh */ case   57:  		/* li R4, 44 */
		/* 822423ACh case   57:*/		cpu::op::li<0>(regs,&regs.R4,0x2C);
		/* 822423ACh case   57:*/		return 0x822423B0;
	}
	return 0x822423B0;
} // Block from 822422C8h-822423B0h (58 instructions)

//////////////////////////////////////////////////////
// Block at 822423B0h
// Function '?OutputPatch@VertexPatch@XGRAPHICS@@UAAXHPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822423B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822423B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822423B0);
		  /* 822423B0h */ case    0:  		/* bl -960584 */
		/* 822423B0h case    0:*/		regs.LR = 0x822423B4; return 0x82157B68;
		/* 822423B0h case    0:*/		return 0x822423B4;
		  /* 822423B4h */ case    1:  		/* lis R11, -32252 */
		/* 822423B4h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822423B4h case    1:*/		return 0x822423B8;
		  /* 822423B8h */ case    2:  		/* li R5, 4 */
		/* 822423B8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 822423B8h case    2:*/		return 0x822423BC;
		  /* 822423BCh */ case    3:  		/* addi R11, R11, 25976 */
		/* 822423BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6578);
		/* 822423BCh case    3:*/		return 0x822423C0;
		  /* 822423C0h */ case    4:  		/* li R4, 45 */
		/* 822423C0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x2D);
		/* 822423C0h case    4:*/		return 0x822423C4;
		  /* 822423C4h */ case    5:  		/* mr R3, R29 */
		/* 822423C4h case    5:*/		regs.R3 = regs.R29;
		/* 822423C4h case    5:*/		return 0x822423C8;
		  /* 822423C8h */ case    6:  		/* lwz R6, <#[R11 + 52]> */
		/* 822423C8h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000034) );
		/* 822423C8h case    6:*/		return 0x822423CC;
		  /* 822423CCh */ case    7:  		/* bl -960612 */
		/* 822423CCh case    7:*/		regs.LR = 0x822423D0; return 0x82157B68;
		/* 822423CCh case    7:*/		return 0x822423D0;
		  /* 822423D0h */ case    8:  		/* lwz R11, <#[R31 + 12]> */
		/* 822423D0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822423D0h case    8:*/		return 0x822423D4;
		  /* 822423D4h */ case    9:  		/* lwz R10, <#[R31 + 56]> */
		/* 822423D4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 822423D4h case    9:*/		return 0x822423D8;
		  /* 822423D8h */ case   10:  		/* addi R11, R11, 6 */
		/* 822423D8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6);
		/* 822423D8h case   10:*/		return 0x822423DC;
		  /* 822423DCh */ case   11:  		/* addi R10, R10, 1 */
		/* 822423DCh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822423DCh case   11:*/		return 0x822423E0;
		  /* 822423E0h */ case   12:  		/* stw R11, <#[R31 + 12]> */
		/* 822423E0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822423E0h case   12:*/		return 0x822423E4;
		  /* 822423E4h */ case   13:  		/* stw R10, <#[R31 + 56]> */
		/* 822423E4h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 822423E4h case   13:*/		return 0x822423E8;
		  /* 822423E8h */ case   14:  		/* addi R1, R1, 128 */
		/* 822423E8h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822423E8h case   14:*/		return 0x822423EC;
		  /* 822423ECh */ case   15:  		/* b -1773892 */
		/* 822423ECh case   15:*/		return 0x820912A8;
		/* 822423ECh case   15:*/		return 0x822423F0;
	}
	return 0x822423F0;
} // Block from 822423B0h-822423F0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822423F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822423F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822423F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822423F0);
		  /* 822423F0h */ case    0:  		/* mfspr R12, LR */
		/* 822423F0h case    0:*/		regs.R12 = regs.LR;
		/* 822423F0h case    0:*/		return 0x822423F4;
		  /* 822423F4h */ case    1:  		/* bl -1773988 */
		/* 822423F4h case    1:*/		regs.LR = 0x822423F8; return 0x82091250;
		/* 822423F4h case    1:*/		return 0x822423F8;
		  /* 822423F8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 822423F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822423F8h case    2:*/		return 0x822423FC;
		  /* 822423FCh */ case    3:  		/* lwz R10, <#[R4 + 4]> */
		/* 822423FCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 822423FCh case    3:*/		return 0x82242400;
		  /* 82242400h */ case    4:  		/* li R9, 12 */
		/* 82242400h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 82242400h case    4:*/		return 0x82242404;
		  /* 82242404h */ case    5:  		/* lwz R11, <#[R4 + 52]> */
		/* 82242404h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000034) );
		/* 82242404h case    5:*/		return 0x82242408;
		  /* 82242408h */ case    6:  		/* mr R31, R3 */
		/* 82242408h case    6:*/		regs.R31 = regs.R3;
		/* 82242408h case    6:*/		return 0x8224240C;
		  /* 8224240Ch */ case    7:  		/* subf R10, R10, R5 */
		/* 8224240Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 8224240Ch case    7:*/		return 0x82242410;
		  /* 82242410h */ case    8:  		/* mr R30, R5 */
		/* 82242410h case    8:*/		regs.R30 = regs.R5;
		/* 82242410h case    8:*/		return 0x82242414;
		  /* 82242414h */ case    9:  		/* divw R10, R10, R9 */
		/* 82242414h case    9:*/		cpu::op::divw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242414h case    9:*/		return 0x82242418;
	}
	return 0x82242418;
} // Block from 822423F0h-82242418h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82242418h
// Function '?AssembleIRList@Assembler@XGRAPHICS@@QAAXAAVDList@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242418);
		  /* 82242418h */ case    0:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82242418h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82242418h case    0:*/		return 0x8224241C;
		  /* 8224241Ch */ case    1:  		/* add R11, R10, R11 */
		/* 8224241Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8224241Ch case    1:*/		return 0x82242420;
		  /* 82242420h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 82242420h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82242420h case    2:*/		return 0x82242424;
		  /* 82242424h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82242424h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82242424h case    3:*/		return 0x82242428;
		  /* 82242428h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 82242428h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82242434;  }
		/* 82242428h case    4:*/		return 0x8224242C;
		  /* 8224242Ch */ case    5:  		/* stw R3, <#[R11]> */
		/* 8224242Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 8224242Ch case    5:*/		return 0x82242430;
		  /* 82242430h */ case    6:  		/* b 8 */
		/* 82242430h case    6:*/		return 0x82242438;
		/* 82242430h case    6:*/		return 0x82242434;
	}
	return 0x82242434;
} // Block from 82242418h-82242434h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82242434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242434);
		  /* 82242434h */ case    0:  		/* stw R31, <#[R11 + 4]> */
		/* 82242434h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 82242434h case    0:*/		return 0x82242438;
	}
	return 0x82242438;
} // Block from 82242434h-82242438h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82242438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242438);
		  /* 82242438h */ case    0:  		/* lis R11, -32253 */
		/* 82242438h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82242438h case    0:*/		return 0x8224243C;
		  /* 8224243Ch */ case    1:  		/* lwz R10, <#[R31 + 24]> */
		/* 8224243Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8224243Ch case    1:*/		return 0x82242440;
		  /* 82242440h */ case    2:  		/* lis R9, -32216 */
		/* 82242440h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8228);
		/* 82242440h case    2:*/		return 0x82242444;
		  /* 82242444h */ case    3:  		/* addi R27, R11, 27460 */
		/* 82242444h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x6B44);
		/* 82242444h case    3:*/		return 0x82242448;
		  /* 82242448h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 82242448h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82242448h case    4:*/		return 0x8224244C;
		  /* 8224244Ch */ case    5:  		/* addi R9, R9, 17992 */
		/* 8224244Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4648);
		/* 8224244Ch case    5:*/		return 0x82242450;
		  /* 82242450h */ case    6:  		/* mulli R10, R10, 52 */
		/* 82242450h case    6:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x34);
		/* 82242450h case    6:*/		return 0x82242454;
		  /* 82242454h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 82242454h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82242454h case    7:*/		return 0x82242458;
		  /* 82242458h */ case    8:  		/* lwzx R9, <#[R10 + R9]> */
		/* 82242458h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82242458h case    8:*/		return 0x8224245C;
		  /* 8224245Ch */ case    9:  		/* lis R10, -32252 */
		/* 8224245Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224245Ch case    9:*/		return 0x82242460;
		  /* 82242460h */ case   10:  		/* mtspr CTR, R11 */
		/* 82242460h case   10:*/		regs.CTR = regs.R11;
		/* 82242460h case   10:*/		return 0x82242464;
		  /* 82242464h */ case   11:  		/* rlwinm. R9, R9, 30, 31, 31 */
		/* 82242464h case   11:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R9,regs.R9);
		/* 82242464h case   11:*/		return 0x82242468;
		  /* 82242468h */ case   12:  		/* addi R26, R10, 10344 */
		/* 82242468h case   12:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R10,0x2868);
		/* 82242468h case   12:*/		return 0x8224246C;
		  /* 8224246Ch */ case   13:  		/* mr R3, R31 */
		/* 8224246Ch case   13:*/		regs.R3 = regs.R31;
		/* 8224246Ch case   13:*/		return 0x82242470;
		  /* 82242470h */ case   14:  		/* bc 12, CR0_EQ, 412 */
		/* 82242470h case   14:*/		if ( regs.CR[0].eq ) { return 0x8224260C;  }
		/* 82242470h case   14:*/		return 0x82242474;
		  /* 82242474h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 82242474h case   15:*/		if ( 1 ) { regs.LR = 0x82242478; return (uint32)regs.CTR; }
		/* 82242474h case   15:*/		return 0x82242478;
		  /* 82242478h */ case   16:  		/* cmpwi CR6, R3, 1 */
		/* 82242478h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82242478h case   16:*/		return 0x8224247C;
		  /* 8224247Ch */ case   17:  		/* bc 4, CR6_GT, 48 */
		/* 8224247Ch case   17:*/		if ( !regs.CR[6].gt ) { return 0x822424AC;  }
		/* 8224247Ch case   17:*/		return 0x82242480;
		  /* 82242480h */ case   18:  		/* lwz R11, <#[R31 + 236]> */
		/* 82242480h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000EC) );
		/* 82242480h case   18:*/		return 0x82242484;
		  /* 82242484h */ case   19:  		/* lwz R10, <#[R31 + 240]> */
		/* 82242484h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000F0) );
		/* 82242484h case   19:*/		return 0x82242488;
		  /* 82242488h */ case   20:  		/* cmplw CR6, R11, R10 */
		/* 82242488h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82242488h case   20:*/		return 0x8224248C;
		  /* 8224248Ch */ case   21:  		/* bc 12, CR6_EQ, 32 */
		/* 8224248Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x822424AC;  }
		/* 8224248Ch case   21:*/		return 0x82242490;
		  /* 82242490h */ case   22:  		/* lis R11, -32252 */
		/* 82242490h case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242490h case   22:*/		return 0x82242494;
		  /* 82242494h */ case   23:  		/* mr R6, R26 */
		/* 82242494h case   23:*/		regs.R6 = regs.R26;
		/* 82242494h case   23:*/		return 0x82242498;
		  /* 82242498h */ case   24:  		/* addi R5, R11, 11980 */
		/* 82242498h case   24:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2ECC);
		/* 82242498h case   24:*/		return 0x8224249C;
		  /* 8224249Ch */ case   25:  		/* mr R4, R27 */
		/* 8224249Ch case   25:*/		regs.R4 = regs.R27;
		/* 8224249Ch case   25:*/		return 0x822424A0;
		  /* 822424A0h */ case   26:  		/* li R7, 2470 */
		/* 822424A0h case   26:*/		cpu::op::li<0>(regs,&regs.R7,0x9A6);
		/* 822424A0h case   26:*/		return 0x822424A4;
		  /* 822424A4h */ case   27:  		/* li R3, 0 */
		/* 822424A4h case   27:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822424A4h case   27:*/		return 0x822424A8;
		  /* 822424A8h */ case   28:  		/* bl -960672 */
		/* 822424A8h case   28:*/		regs.LR = 0x822424AC; return 0x82157C08;
		/* 822424A8h case   28:*/		return 0x822424AC;
	}
	return 0x822424AC;
} // Block from 82242438h-822424ACh (29 instructions)

//////////////////////////////////////////////////////
// Block at 822424ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822424AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822424AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822424AC);
		  /* 822424ACh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 822424ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822424ACh case    0:*/		return 0x822424B0;
		  /* 822424B0h */ case    1:  		/* mr R3, R31 */
		/* 822424B0h case    1:*/		regs.R3 = regs.R31;
		/* 822424B0h case    1:*/		return 0x822424B4;
		  /* 822424B4h */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 822424B4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822424B4h case    2:*/		return 0x822424B8;
		  /* 822424B8h */ case    3:  		/* mtspr CTR, R11 */
		/* 822424B8h case    3:*/		regs.CTR = regs.R11;
		/* 822424B8h case    3:*/		return 0x822424BC;
		  /* 822424BCh */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 822424BCh case    4:*/		if ( 1 ) { regs.LR = 0x822424C0; return (uint32)regs.CTR; }
		/* 822424BCh case    4:*/		return 0x822424C0;
		  /* 822424C0h */ case    5:  		/* cmpwi CR6, R3, 1 */
		/* 822424C0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 822424C0h case    5:*/		return 0x822424C4;
		  /* 822424C4h */ case    6:  		/* bc 12, CR6_LT, 292 */
		/* 822424C4h case    6:*/		if ( regs.CR[6].lt ) { return 0x822425E8;  }
		/* 822424C4h case    6:*/		return 0x822424C8;
		  /* 822424C8h */ case    7:  		/* li R6, 3 */
		/* 822424C8h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 822424C8h case    7:*/		return 0x822424CC;
		  /* 822424CCh */ case    8:  		/* li R5, 1 */
		/* 822424CCh case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 822424CCh case    8:*/		return 0x822424D0;
		  /* 822424D0h */ case    9:  		/* mr R4, R30 */
		/* 822424D0h case    9:*/		regs.R4 = regs.R30;
		/* 822424D0h case    9:*/		return 0x822424D4;
		  /* 822424D4h */ case   10:  		/* mr R3, R31 */
		/* 822424D4h case   10:*/		regs.R3 = regs.R31;
		/* 822424D4h case   10:*/		return 0x822424D8;
		  /* 822424D8h */ case   11:  		/* bl -7880 */
		/* 822424D8h case   11:*/		regs.LR = 0x822424DC; return 0x82240610;
		/* 822424D8h case   11:*/		return 0x822424DC;
		  /* 822424DCh */ case   12:  		/* lbz R11, <#[R31 + 132]> */
		/* 822424DCh case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 822424DCh case   12:*/		return 0x822424E0;
		  /* 822424E0h */ case   13:  		/* lbz R10, <#[R31 + 133]> */
		/* 822424E0h case   13:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000085) );
		/* 822424E0h case   13:*/		return 0x822424E4;
		  /* 822424E4h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 822424E4h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822424E4h case   14:*/		return 0x822424E8;
		  /* 822424E8h */ case   15:  		/* bc 4, CR6_EQ, 28 */
		/* 822424E8h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82242504;  }
		/* 822424E8h case   15:*/		return 0x822424EC;
		  /* 822424ECh */ case   16:  		/* lbz R10, <#[R31 + 134]> */
		/* 822424ECh case   16:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000086) );
		/* 822424ECh case   16:*/		return 0x822424F0;
		  /* 822424F0h */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 822424F0h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822424F0h case   17:*/		return 0x822424F4;
		  /* 822424F4h */ case   18:  		/* bc 4, CR6_EQ, 16 */
		/* 822424F4h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82242504;  }
		/* 822424F4h case   18:*/		return 0x822424F8;
		  /* 822424F8h */ case   19:  		/* lbz R10, <#[R31 + 135]> */
		/* 822424F8h case   19:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000087) );
		/* 822424F8h case   19:*/		return 0x822424FC;
		  /* 822424FCh */ case   20:  		/* cmplw CR6, R11, R10 */
		/* 822424FCh case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822424FCh case   20:*/		return 0x82242500;
		  /* 82242500h */ case   21:  		/* bc 12, CR6_EQ, 32 */
		/* 82242500h case   21:*/		if ( regs.CR[6].eq ) { return 0x82242520;  }
		/* 82242500h case   21:*/		return 0x82242504;
	}
	return 0x82242504;
} // Block from 822424ACh-82242504h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82242504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242504);
		  /* 82242504h */ case    0:  		/* lis R11, -32252 */
		/* 82242504h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242504h case    0:*/		return 0x82242508;
		  /* 82242508h */ case    1:  		/* mr R6, R26 */
		/* 82242508h case    1:*/		regs.R6 = regs.R26;
		/* 82242508h case    1:*/		return 0x8224250C;
		  /* 8224250Ch */ case    2:  		/* addi R5, R11, 11832 */
		/* 8224250Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2E38);
		/* 8224250Ch case    2:*/		return 0x82242510;
		  /* 82242510h */ case    3:  		/* mr R4, R27 */
		/* 82242510h case    3:*/		regs.R4 = regs.R27;
		/* 82242510h case    3:*/		return 0x82242514;
		  /* 82242514h */ case    4:  		/* li R7, 2475 */
		/* 82242514h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x9AB);
		/* 82242514h case    4:*/		return 0x82242518;
		  /* 82242518h */ case    5:  		/* li R3, 0 */
		/* 82242518h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82242518h case    5:*/		return 0x8224251C;
		  /* 8224251Ch */ case    6:  		/* bl -960788 */
		/* 8224251Ch case    6:*/		regs.LR = 0x82242520; return 0x82157C08;
		/* 8224251Ch case    6:*/		return 0x82242520;
	}
	return 0x82242520;
} // Block from 82242504h-82242520h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82242520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242520);
		  /* 82242520h */ case    0:  		/* lbz R11, <#[R31 + 132]> */
		/* 82242520h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 82242520h case    0:*/		return 0x82242524;
		  /* 82242524h */ case    1:  		/* addic. R11, R11, -3 */
		/* 82242524h case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFD);
		/* 82242524h case    1:*/		return 0x82242528;
		  /* 82242528h */ case    2:  		/* bc 4, CR0_LT, 8 */
		/* 82242528h case    2:*/		if ( !regs.CR[0].lt ) { return 0x82242530;  }
		/* 82242528h case    2:*/		return 0x8224252C;
		  /* 8224252Ch */ case    3:  		/* addi R11, R11, 4 */
		/* 8224252Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8224252Ch case    3:*/		return 0x82242530;
	}
	return 0x82242530;
} // Block from 82242520h-82242530h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82242530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242530);
		  /* 82242530h */ case    0:  		/* rlwinm R11, R11, 6, 24, 25 */
		/* 82242530h case    0:*/		cpu::op::rlwinm<0,6,24,25>(regs,&regs.R11,regs.R11);
		/* 82242530h case    0:*/		return 0x82242534;
		  /* 82242534h */ case    1:  		/* mr R3, R31 */
		/* 82242534h case    1:*/		regs.R3 = regs.R31;
		/* 82242534h case    1:*/		return 0x82242538;
		  /* 82242538h */ case    2:  		/* stb R11, <#[R30 + 7]> */
		/* 82242538h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000007) );
		/* 82242538h case    2:*/		return 0x8224253C;
		  /* 8224253Ch */ case    3:  		/* lwz R11, <#[R31]> */
		/* 8224253Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224253Ch case    3:*/		return 0x82242540;
		  /* 82242540h */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 82242540h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82242540h case    4:*/		return 0x82242544;
		  /* 82242544h */ case    5:  		/* mtspr CTR, R11 */
		/* 82242544h case    5:*/		regs.CTR = regs.R11;
		/* 82242544h case    5:*/		return 0x82242548;
		  /* 82242548h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82242548h case    6:*/		if ( 1 ) { regs.LR = 0x8224254C; return (uint32)regs.CTR; }
		/* 82242548h case    6:*/		return 0x8224254C;
		  /* 8224254Ch */ case    7:  		/* cmpwi CR6, R3, 1 */
		/* 8224254Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8224254Ch case    7:*/		return 0x82242550;
		  /* 82242550h */ case    8:  		/* bc 4, CR6_GT, 104 */
		/* 82242550h case    8:*/		if ( !regs.CR[6].gt ) { return 0x822425B8;  }
		/* 82242550h case    8:*/		return 0x82242554;
		  /* 82242554h */ case    9:  		/* lbz R11, <#[R31 + 136]> */
		/* 82242554h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 82242554h case    9:*/		return 0x82242558;
		  /* 82242558h */ case   10:  		/* cmpwi CR0, R11, 0 */
		/* 82242558h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 82242558h case   10:*/		return 0x8224255C;
		  /* 8224255Ch */ case   11:  		/* bc 4, CR0_LT, 8 */
		/* 8224255Ch case   11:*/		if ( !regs.CR[0].lt ) { return 0x82242564;  }
		/* 8224255Ch case   11:*/		return 0x82242560;
		  /* 82242560h */ case   12:  		/* addi R11, R11, 4 */
		/* 82242560h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82242560h case   12:*/		return 0x82242564;
	}
	return 0x82242564;
} // Block from 82242530h-82242564h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82242564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242564);
		  /* 82242564h */ case    0:  		/* lwz R10, <#[R30 + 4]> */
		/* 82242564h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82242564h case    0:*/		return 0x82242568;
		  /* 82242568h */ case    1:  		/* or R11, R10, R11 */
		/* 82242568h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82242568h case    1:*/		return 0x8224256C;
		  /* 8224256Ch */ case    2:  		/* stb R11, <#[R30 + 7]> */
		/* 8224256Ch case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000007) );
		/* 8224256Ch case    2:*/		return 0x82242570;
		  /* 82242570h */ case    3:  		/* lbz R11, <#[R31 + 136]> */
		/* 82242570h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 82242570h case    3:*/		return 0x82242574;
		  /* 82242574h */ case    4:  		/* lbz R10, <#[R31 + 137]> */
		/* 82242574h case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000089) );
		/* 82242574h case    4:*/		return 0x82242578;
		  /* 82242578h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 82242578h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82242578h case    5:*/		return 0x8224257C;
		  /* 8224257Ch */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 8224257Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82242598;  }
		/* 8224257Ch case    6:*/		return 0x82242580;
		  /* 82242580h */ case    7:  		/* lbz R10, <#[R31 + 138]> */
		/* 82242580h case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000008A) );
		/* 82242580h case    7:*/		return 0x82242584;
		  /* 82242584h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 82242584h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82242584h case    8:*/		return 0x82242588;
		  /* 82242588h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 82242588h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82242598;  }
		/* 82242588h case    9:*/		return 0x8224258C;
		  /* 8224258Ch */ case   10:  		/* lbz R10, <#[R31 + 139]> */
		/* 8224258Ch case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000008B) );
		/* 8224258Ch case   10:*/		return 0x82242590;
		  /* 82242590h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 82242590h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82242590h case   11:*/		return 0x82242594;
		  /* 82242594h */ case   12:  		/* bc 12, CR6_EQ, 84 */
		/* 82242594h case   12:*/		if ( regs.CR[6].eq ) { return 0x822425E8;  }
		/* 82242594h case   12:*/		return 0x82242598;
	}
	return 0x82242598;
} // Block from 82242564h-82242598h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82242598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242598);
		  /* 82242598h */ case    0:  		/* lis R11, -32252 */
		/* 82242598h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242598h case    0:*/		return 0x8224259C;
		  /* 8224259Ch */ case    1:  		/* mr R6, R26 */
		/* 8224259Ch case    1:*/		regs.R6 = regs.R26;
		/* 8224259Ch case    1:*/		return 0x822425A0;
		  /* 822425A0h */ case    2:  		/* addi R5, R11, 11680 */
		/* 822425A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2DA0);
		/* 822425A0h case    2:*/		return 0x822425A4;
		  /* 822425A4h */ case    3:  		/* mr R4, R27 */
		/* 822425A4h case    3:*/		regs.R4 = regs.R27;
		/* 822425A4h case    3:*/		return 0x822425A8;
		  /* 822425A8h */ case    4:  		/* li R7, 2480 */
		/* 822425A8h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x9B0);
		/* 822425A8h case    4:*/		return 0x822425AC;
		  /* 822425ACh */ case    5:  		/* li R3, 0 */
		/* 822425ACh case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822425ACh case    5:*/		return 0x822425B0;
		  /* 822425B0h */ case    6:  		/* bl -960936 */
		/* 822425B0h case    6:*/		regs.LR = 0x822425B4; return 0x82157C08;
		/* 822425B0h case    6:*/		return 0x822425B4;
		  /* 822425B4h */ case    7:  		/* b 52 */
		/* 822425B4h case    7:*/		return 0x822425E8;
		/* 822425B4h case    7:*/		return 0x822425B8;
	}
	return 0x822425B8;
} // Block from 82242598h-822425B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822425B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822425B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822425B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822425B8);
		  /* 822425B8h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 822425B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 822425B8h case    0:*/		return 0x822425BC;
		  /* 822425BCh */ case    1:  		/* cmpwi CR6, R11, 99 */
		/* 822425BCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000063);
		/* 822425BCh case    1:*/		return 0x822425C0;
		  /* 822425C0h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 822425C0h case    2:*/		if ( regs.CR[6].eq ) { return 0x822425CC;  }
		/* 822425C0h case    2:*/		return 0x822425C4;
		  /* 822425C4h */ case    3:  		/* cmpwi CR6, R11, 100 */
		/* 822425C4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000064);
		/* 822425C4h case    3:*/		return 0x822425C8;
		  /* 822425C8h */ case    4:  		/* bc 4, CR6_EQ, 32 */
		/* 822425C8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x822425E8;  }
		/* 822425C8h case    4:*/		return 0x822425CC;
	}
	return 0x822425CC;
} // Block from 822425B8h-822425CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822425CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822425CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822425CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822425CC);
		  /* 822425CCh */ case    0:  		/* lbz R11, <#[R31 + 132]> */
		/* 822425CCh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 822425CCh case    0:*/		return 0x822425D0;
		  /* 822425D0h */ case    1:  		/* cmpwi CR0, R11, 0 */
		/* 822425D0h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 822425D0h case    1:*/		return 0x822425D4;
		  /* 822425D4h */ case    2:  		/* bc 4, CR0_LT, 8 */
		/* 822425D4h case    2:*/		if ( !regs.CR[0].lt ) { return 0x822425DC;  }
		/* 822425D4h case    2:*/		return 0x822425D8;
		  /* 822425D8h */ case    3:  		/* addi R11, R11, 4 */
		/* 822425D8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822425D8h case    3:*/		return 0x822425DC;
	}
	return 0x822425DC;
} // Block from 822425CCh-822425DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822425DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822425DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822425DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822425DC);
		  /* 822425DCh */ case    0:  		/* lwz R10, <#[R30 + 4]> */
		/* 822425DCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 822425DCh case    0:*/		return 0x822425E0;
		  /* 822425E0h */ case    1:  		/* or R11, R10, R11 */
		/* 822425E0h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822425E0h case    1:*/		return 0x822425E4;
		  /* 822425E4h */ case    2:  		/* stb R11, <#[R30 + 7]> */
		/* 822425E4h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000007) );
		/* 822425E4h case    2:*/		return 0x822425E8;
	}
	return 0x822425E8;
} // Block from 822425DCh-822425E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822425E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822425E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822425E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822425E8);
		  /* 822425E8h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 822425E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 822425E8h case    0:*/		return 0x822425EC;
		  /* 822425ECh */ case    1:  		/* lis R10, -32252 */
		/* 822425ECh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822425ECh case    1:*/		return 0x822425F0;
		  /* 822425F0h */ case    2:  		/* lwz R9, <#[R30]> */
		/* 822425F0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 822425F0h case    2:*/		return 0x822425F4;
		  /* 822425F4h */ case    3:  		/* addi R10, R10, 25976 */
		/* 822425F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6578);
		/* 822425F4h case    3:*/		return 0x822425F8;
		  /* 822425F8h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822425F8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822425F8h case    4:*/		return 0x822425FC;
		  /* 822425FCh */ case    5:  		/* lwzx R11, <#[R11 + R10]> */
		/* 822425FCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822425FCh case    5:*/		return 0x82242600;
		  /* 82242600h */ case    6:  		/* rlwimi R9, R11, 26, 0, 5 */
		/* 82242600h case    6:*/		cpu::op::rlwimi<0,26,0,5>(regs,&regs.R9,regs.R11);
		/* 82242600h case    6:*/		return 0x82242604;
		  /* 82242604h */ case    7:  		/* stw R9, <#[R30]> */
		/* 82242604h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82242604h case    7:*/		return 0x82242608;
		  /* 82242608h */ case    8:  		/* b 364 */
		/* 82242608h case    8:*/		return 0x82242774;
		/* 82242608h case    8:*/		return 0x8224260C;
	}
	return 0x8224260C;
} // Block from 822425E8h-8224260Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224260Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224260C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224260C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224260C);
		  /* 8224260Ch */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 8224260Ch case    0:*/		if ( 1 ) { regs.LR = 0x82242610; return (uint32)regs.CTR; }
		/* 8224260Ch case    0:*/		return 0x82242610;
		  /* 82242610h */ case    1:  		/* lis R28, 256 */
		/* 82242610h case    1:*/		cpu::op::lis<0>(regs,&regs.R28,0x100);
		/* 82242610h case    1:*/		return 0x82242614;
		  /* 82242614h */ case    2:  		/* lis R29, 2 */
		/* 82242614h case    2:*/		cpu::op::lis<0>(regs,&regs.R29,0x2);
		/* 82242614h case    2:*/		return 0x82242618;
		  /* 82242618h */ case    3:  		/* cmpwi CR6, R3, 1 */
		/* 82242618h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82242618h case    3:*/		return 0x8224261C;
		  /* 8224261Ch */ case    4:  		/* bc 12, CR6_LT, 88 */
		/* 8224261Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82242674;  }
		/* 8224261Ch case    4:*/		return 0x82242620;
		  /* 82242620h */ case    5:  		/* li R6, 1 */
		/* 82242620h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82242620h case    5:*/		return 0x82242624;
		  /* 82242624h */ case    6:  		/* li R5, 1 */
		/* 82242624h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242624h case    6:*/		return 0x82242628;
		  /* 82242628h */ case    7:  		/* mr R4, R30 */
		/* 82242628h case    7:*/		regs.R4 = regs.R30;
		/* 82242628h case    7:*/		return 0x8224262C;
		  /* 8224262Ch */ case    8:  		/* mr R3, R31 */
		/* 8224262Ch case    8:*/		regs.R3 = regs.R31;
		/* 8224262Ch case    8:*/		return 0x82242630;
		  /* 82242630h */ case    9:  		/* bl -8224 */
		/* 82242630h case    9:*/		regs.LR = 0x82242634; return 0x82240610;
		/* 82242630h case    9:*/		return 0x82242634;
		  /* 82242634h */ case   10:  		/* lwz R10, <#[R31 + 132]> */
		/* 82242634h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 82242634h case   10:*/		return 0x82242638;
		  /* 82242638h */ case   11:  		/* rlwinm R11, R10, 8, 24, 31 */
		/* 82242638h case   11:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R11,regs.R10);
		/* 82242638h case   11:*/		return 0x8224263C;
		  /* 8224263Ch */ case   12:  		/* rlwimi R11, R10, 24, 16, 23 */
		/* 8224263Ch case   12:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R11,regs.R10);
		/* 8224263Ch case   12:*/		return 0x82242640;
		  /* 82242640h */ case   13:  		/* rlwimi R11, R10, 8, 8, 15 */
		/* 82242640h case   13:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R11,regs.R10);
		/* 82242640h case   13:*/		return 0x82242644;
		  /* 82242644h */ case   14:  		/* rlwimi R11, R10, 24, 0, 7 */
		/* 82242644h case   14:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R11,regs.R10);
		/* 82242644h case   14:*/		return 0x82242648;
		  /* 82242648h */ case   15:  		/* add R10, R11, R28 */
		/* 82242648h case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R28);
		/* 82242648h case   15:*/		return 0x8224264C;
		  /* 8224264Ch */ case   16:  		/* addi R9, R11, -256 */
		/* 8224264Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFF00);
		/* 8224264Ch case   16:*/		return 0x82242650;
		  /* 82242650h */ case   17:  		/* rlwinm R10, R10, 14, 24, 25 */
		/* 82242650h case   17:*/		cpu::op::rlwinm<0,14,24,25>(regs,&regs.R10,regs.R10);
		/* 82242650h case   17:*/		return 0x82242654;
		  /* 82242654h */ case   18:  		/* rlwinm R9, R9, 26, 28, 29 */
		/* 82242654h case   18:*/		cpu::op::rlwinm<0,26,28,29>(regs,&regs.R9,regs.R9);
		/* 82242654h case   18:*/		return 0x82242658;
		  /* 82242658h */ case   19:  		/* subf R8, R29, R11 */
		/* 82242658h case   19:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R29,regs.R11);
		/* 82242658h case   19:*/		return 0x8224265C;
		  /* 8224265Ch */ case   20:  		/* or R10, R10, R9 */
		/* 8224265Ch case   20:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8224265Ch case   20:*/		return 0x82242660;
		  /* 82242660h */ case   21:  		/* rlwinm R9, R8, 20, 26, 27 */
		/* 82242660h case   21:*/		cpu::op::rlwinm<0,20,26,27>(regs,&regs.R9,regs.R8);
		/* 82242660h case   21:*/		return 0x82242664;
		  /* 82242664h */ case   22:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82242664h case   22:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82242664h case   22:*/		return 0x82242668;
		  /* 82242668h */ case   23:  		/* or R10, R10, R9 */
		/* 82242668h case   23:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242668h case   23:*/		return 0x8224266C;
		  /* 8224266Ch */ case   24:  		/* or R11, R10, R11 */
		/* 8224266Ch case   24:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8224266Ch case   24:*/		return 0x82242670;
		  /* 82242670h */ case   25:  		/* stb R11, <#[R30 + 5]> */
		/* 82242670h case   25:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 82242670h case   25:*/		return 0x82242674;
	}
	return 0x82242674;
} // Block from 8224260Ch-82242674h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82242674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242674);
		  /* 82242674h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82242674h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82242674h case    0:*/		return 0x82242678;
		  /* 82242678h */ case    1:  		/* mr R3, R31 */
		/* 82242678h case    1:*/		regs.R3 = regs.R31;
		/* 82242678h case    1:*/		return 0x8224267C;
		  /* 8224267Ch */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224267Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224267Ch case    2:*/		return 0x82242680;
		  /* 82242680h */ case    3:  		/* mtspr CTR, R11 */
		/* 82242680h case    3:*/		regs.CTR = regs.R11;
		/* 82242680h case    3:*/		return 0x82242684;
		  /* 82242684h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82242684h case    4:*/		if ( 1 ) { regs.LR = 0x82242688; return (uint32)regs.CTR; }
		/* 82242684h case    4:*/		return 0x82242688;
		  /* 82242688h */ case    5:  		/* cmpwi CR6, R3, 2 */
		/* 82242688h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82242688h case    5:*/		return 0x8224268C;
		  /* 8224268Ch */ case    6:  		/* bc 12, CR6_LT, 88 */
		/* 8224268Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x822426E4;  }
		/* 8224268Ch case    6:*/		return 0x82242690;
		  /* 82242690h */ case    7:  		/* li R6, 2 */
		/* 82242690h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 82242690h case    7:*/		return 0x82242694;
		  /* 82242694h */ case    8:  		/* li R5, 2 */
		/* 82242694h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82242694h case    8:*/		return 0x82242698;
		  /* 82242698h */ case    9:  		/* mr R4, R30 */
		/* 82242698h case    9:*/		regs.R4 = regs.R30;
		/* 82242698h case    9:*/		return 0x8224269C;
		  /* 8224269Ch */ case   10:  		/* mr R3, R31 */
		/* 8224269Ch case   10:*/		regs.R3 = regs.R31;
		/* 8224269Ch case   10:*/		return 0x822426A0;
		  /* 822426A0h */ case   11:  		/* bl -8336 */
		/* 822426A0h case   11:*/		regs.LR = 0x822426A4; return 0x82240610;
		/* 822426A0h case   11:*/		return 0x822426A4;
		  /* 822426A4h */ case   12:  		/* lwz R10, <#[R31 + 136]> */
		/* 822426A4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000088) );
		/* 822426A4h case   12:*/		return 0x822426A8;
		  /* 822426A8h */ case   13:  		/* rlwinm R11, R10, 8, 24, 31 */
		/* 822426A8h case   13:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R11,regs.R10);
		/* 822426A8h case   13:*/		return 0x822426AC;
		  /* 822426ACh */ case   14:  		/* rlwimi R11, R10, 24, 16, 23 */
		/* 822426ACh case   14:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R11,regs.R10);
		/* 822426ACh case   14:*/		return 0x822426B0;
		  /* 822426B0h */ case   15:  		/* rlwimi R11, R10, 8, 8, 15 */
		/* 822426B0h case   15:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R11,regs.R10);
		/* 822426B0h case   15:*/		return 0x822426B4;
		  /* 822426B4h */ case   16:  		/* rlwimi R11, R10, 24, 0, 7 */
		/* 822426B4h case   16:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R11,regs.R10);
		/* 822426B4h case   16:*/		return 0x822426B8;
		  /* 822426B8h */ case   17:  		/* add R10, R11, R28 */
		/* 822426B8h case   17:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R28);
		/* 822426B8h case   17:*/		return 0x822426BC;
		  /* 822426BCh */ case   18:  		/* addi R9, R11, -256 */
		/* 822426BCh case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFF00);
		/* 822426BCh case   18:*/		return 0x822426C0;
		  /* 822426C0h */ case   19:  		/* rlwinm R10, R10, 14, 24, 25 */
		/* 822426C0h case   19:*/		cpu::op::rlwinm<0,14,24,25>(regs,&regs.R10,regs.R10);
		/* 822426C0h case   19:*/		return 0x822426C4;
		  /* 822426C4h */ case   20:  		/* rlwinm R9, R9, 26, 28, 29 */
		/* 822426C4h case   20:*/		cpu::op::rlwinm<0,26,28,29>(regs,&regs.R9,regs.R9);
		/* 822426C4h case   20:*/		return 0x822426C8;
		  /* 822426C8h */ case   21:  		/* subf R8, R29, R11 */
		/* 822426C8h case   21:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R29,regs.R11);
		/* 822426C8h case   21:*/		return 0x822426CC;
		  /* 822426CCh */ case   22:  		/* or R10, R10, R9 */
		/* 822426CCh case   22:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 822426CCh case   22:*/		return 0x822426D0;
		  /* 822426D0h */ case   23:  		/* rlwinm R9, R8, 20, 26, 27 */
		/* 822426D0h case   23:*/		cpu::op::rlwinm<0,20,26,27>(regs,&regs.R9,regs.R8);
		/* 822426D0h case   23:*/		return 0x822426D4;
		  /* 822426D4h */ case   24:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 822426D4h case   24:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 822426D4h case   24:*/		return 0x822426D8;
		  /* 822426D8h */ case   25:  		/* or R10, R10, R9 */
		/* 822426D8h case   25:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 822426D8h case   25:*/		return 0x822426DC;
		  /* 822426DCh */ case   26:  		/* or R11, R10, R11 */
		/* 822426DCh case   26:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822426DCh case   26:*/		return 0x822426E0;
		  /* 822426E0h */ case   27:  		/* stb R11, <#[R30 + 6]> */
		/* 822426E0h case   27:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000006) );
		/* 822426E0h case   27:*/		return 0x822426E4;
	}
	return 0x822426E4;
} // Block from 82242674h-822426E4h (28 instructions)

//////////////////////////////////////////////////////
// Block at 822426E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822426E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822426E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822426E4);
		  /* 822426E4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 822426E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822426E4h case    0:*/		return 0x822426E8;
		  /* 822426E8h */ case    1:  		/* mr R3, R31 */
		/* 822426E8h case    1:*/		regs.R3 = regs.R31;
		/* 822426E8h case    1:*/		return 0x822426EC;
		  /* 822426ECh */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 822426ECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822426ECh case    2:*/		return 0x822426F0;
		  /* 822426F0h */ case    3:  		/* mtspr CTR, R11 */
		/* 822426F0h case    3:*/		regs.CTR = regs.R11;
		/* 822426F0h case    3:*/		return 0x822426F4;
		  /* 822426F4h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 822426F4h case    4:*/		if ( 1 ) { regs.LR = 0x822426F8; return (uint32)regs.CTR; }
		/* 822426F4h case    4:*/		return 0x822426F8;
		  /* 822426F8h */ case    5:  		/* cmpwi CR6, R3, 3 */
		/* 822426F8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 822426F8h case    5:*/		return 0x822426FC;
		  /* 822426FCh */ case    6:  		/* bc 12, CR6_LT, 88 */
		/* 822426FCh case    6:*/		if ( regs.CR[6].lt ) { return 0x82242754;  }
		/* 822426FCh case    6:*/		return 0x82242700;
		  /* 82242700h */ case    7:  		/* li R6, 3 */
		/* 82242700h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 82242700h case    7:*/		return 0x82242704;
		  /* 82242704h */ case    8:  		/* li R5, 3 */
		/* 82242704h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82242704h case    8:*/		return 0x82242708;
		  /* 82242708h */ case    9:  		/* mr R4, R30 */
		/* 82242708h case    9:*/		regs.R4 = regs.R30;
		/* 82242708h case    9:*/		return 0x8224270C;
		  /* 8224270Ch */ case   10:  		/* mr R3, R31 */
		/* 8224270Ch case   10:*/		regs.R3 = regs.R31;
		/* 8224270Ch case   10:*/		return 0x82242710;
		  /* 82242710h */ case   11:  		/* bl -8448 */
		/* 82242710h case   11:*/		regs.LR = 0x82242714; return 0x82240610;
		/* 82242710h case   11:*/		return 0x82242714;
		  /* 82242714h */ case   12:  		/* lwz R10, <#[R31 + 140]> */
		/* 82242714h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000008C) );
		/* 82242714h case   12:*/		return 0x82242718;
		  /* 82242718h */ case   13:  		/* rlwinm R11, R10, 8, 24, 31 */
		/* 82242718h case   13:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R11,regs.R10);
		/* 82242718h case   13:*/		return 0x8224271C;
		  /* 8224271Ch */ case   14:  		/* rlwimi R11, R10, 24, 16, 23 */
		/* 8224271Ch case   14:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R11,regs.R10);
		/* 8224271Ch case   14:*/		return 0x82242720;
		  /* 82242720h */ case   15:  		/* rlwimi R11, R10, 8, 8, 15 */
		/* 82242720h case   15:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R11,regs.R10);
		/* 82242720h case   15:*/		return 0x82242724;
		  /* 82242724h */ case   16:  		/* rlwimi R11, R10, 24, 0, 7 */
		/* 82242724h case   16:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R11,regs.R10);
		/* 82242724h case   16:*/		return 0x82242728;
		  /* 82242728h */ case   17:  		/* add R10, R11, R28 */
		/* 82242728h case   17:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R28);
		/* 82242728h case   17:*/		return 0x8224272C;
		  /* 8224272Ch */ case   18:  		/* addi R9, R11, -256 */
		/* 8224272Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFF00);
		/* 8224272Ch case   18:*/		return 0x82242730;
		  /* 82242730h */ case   19:  		/* rlwinm R10, R10, 14, 24, 25 */
		/* 82242730h case   19:*/		cpu::op::rlwinm<0,14,24,25>(regs,&regs.R10,regs.R10);
		/* 82242730h case   19:*/		return 0x82242734;
		  /* 82242734h */ case   20:  		/* rlwinm R9, R9, 26, 28, 29 */
		/* 82242734h case   20:*/		cpu::op::rlwinm<0,26,28,29>(regs,&regs.R9,regs.R9);
		/* 82242734h case   20:*/		return 0x82242738;
		  /* 82242738h */ case   21:  		/* subf R8, R29, R11 */
		/* 82242738h case   21:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R29,regs.R11);
		/* 82242738h case   21:*/		return 0x8224273C;
		  /* 8224273Ch */ case   22:  		/* or R10, R10, R9 */
		/* 8224273Ch case   22:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8224273Ch case   22:*/		return 0x82242740;
		  /* 82242740h */ case   23:  		/* rlwinm R9, R8, 20, 26, 27 */
		/* 82242740h case   23:*/		cpu::op::rlwinm<0,20,26,27>(regs,&regs.R9,regs.R8);
		/* 82242740h case   23:*/		return 0x82242744;
		  /* 82242744h */ case   24:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82242744h case   24:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82242744h case   24:*/		return 0x82242748;
		  /* 82242748h */ case   25:  		/* or R10, R10, R9 */
		/* 82242748h case   25:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242748h case   25:*/		return 0x8224274C;
		  /* 8224274Ch */ case   26:  		/* or R11, R10, R11 */
		/* 8224274Ch case   26:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8224274Ch case   26:*/		return 0x82242750;
		  /* 82242750h */ case   27:  		/* stb R11, <#[R30 + 7]> */
		/* 82242750h case   27:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000007) );
		/* 82242750h case   27:*/		return 0x82242754;
	}
	return 0x82242754;
} // Block from 822426E4h-82242754h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82242754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242754);
		  /* 82242754h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 82242754h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82242754h case    0:*/		return 0x82242758;
		  /* 82242758h */ case    1:  		/* lis R10, -32252 */
		/* 82242758h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82242758h case    1:*/		return 0x8224275C;
		  /* 8224275Ch */ case    2:  		/* lwz R9, <#[R30 + 8]> */
		/* 8224275Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 8224275Ch case    2:*/		return 0x82242760;
		  /* 82242760h */ case    3:  		/* addi R10, R10, 25976 */
		/* 82242760h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6578);
		/* 82242760h case    3:*/		return 0x82242764;
		  /* 82242764h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82242764h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82242764h case    4:*/		return 0x82242768;
		  /* 82242768h */ case    5:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82242768h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82242768h case    5:*/		return 0x8224276C;
		  /* 8224276Ch */ case    6:  		/* rlwimi R9, R11, 24, 3, 7 */
		/* 8224276Ch case    6:*/		cpu::op::rlwimi<0,24,3,7>(regs,&regs.R9,regs.R11);
		/* 8224276Ch case    6:*/		return 0x82242770;
		  /* 82242770h */ case    7:  		/* stw R9, <#[R30 + 8]> */
		/* 82242770h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 82242770h case    7:*/		return 0x82242774;
	}
	return 0x82242774;
} // Block from 82242754h-82242774h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82242774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242774);
		  /* 82242774h */ case    0:  		/* mr R4, R30 */
		/* 82242774h case    0:*/		regs.R4 = regs.R30;
		/* 82242774h case    0:*/		return 0x82242778;
		  /* 82242778h */ case    1:  		/* mr R3, R31 */
		/* 82242778h case    1:*/		regs.R3 = regs.R31;
		/* 82242778h case    1:*/		return 0x8224277C;
		  /* 8224277Ch */ case    2:  		/* bl -7156 */
		/* 8224277Ch case    2:*/		regs.LR = 0x82242780; return 0x82240B88;
		/* 8224277Ch case    2:*/		return 0x82242780;
		  /* 82242780h */ case    3:  		/* lwz R11, <#[R30 + 4]> */
		/* 82242780h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82242780h case    3:*/		return 0x82242784;
		  /* 82242784h */ case    4:  		/* rlwinm. R11, R11, 5, 30, 31 */
		/* 82242784h case    4:*/		cpu::op::rlwinm<1,5,30,31>(regs,&regs.R11,regs.R11);
		/* 82242784h case    4:*/		return 0x82242788;
		  /* 82242788h */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 82242788h case    5:*/		if ( regs.CR[0].eq ) { return 0x822427B4;  }
		/* 82242788h case    5:*/		return 0x8224278C;
		  /* 8224278Ch */ case    6:  		/* lwz R10, <#[R31 + 52]> */
		/* 8224278Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000034) );
		/* 8224278Ch case    6:*/		return 0x82242790;
		  /* 82242790h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82242790h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82242790h case    7:*/		return 0x82242794;
		  /* 82242794h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 82242794h case    8:*/		if ( regs.CR[6].eq ) { return 0x822427B4;  }
		/* 82242794h case    8:*/		return 0x82242798;
		  /* 82242798h */ case    9:  		/* lis R11, -32252 */
		/* 82242798h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242798h case    9:*/		return 0x8224279C;
		  /* 8224279Ch */ case   10:  		/* mr R6, R26 */
		/* 8224279Ch case   10:*/		regs.R6 = regs.R26;
		/* 8224279Ch case   10:*/		return 0x822427A0;
		  /* 822427A0h */ case   11:  		/* addi R5, R11, 11652 */
		/* 822427A0h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2D84);
		/* 822427A0h case   11:*/		return 0x822427A4;
		  /* 822427A4h */ case   12:  		/* mr R4, R27 */
		/* 822427A4h case   12:*/		regs.R4 = regs.R27;
		/* 822427A4h case   12:*/		return 0x822427A8;
		  /* 822427A8h */ case   13:  		/* li R7, 2519 */
		/* 822427A8h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x9D7);
		/* 822427A8h case   13:*/		return 0x822427AC;
		  /* 822427ACh */ case   14:  		/* li R3, 0 */
		/* 822427ACh case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822427ACh case   14:*/		return 0x822427B0;
		  /* 822427B0h */ case   15:  		/* bl -961448 */
		/* 822427B0h case   15:*/		regs.LR = 0x822427B4; return 0x82157C08;
		/* 822427B0h case   15:*/		return 0x822427B4;
	}
	return 0x822427B4;
} // Block from 82242774h-822427B4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822427B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822427B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822427B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822427B4);
		  /* 822427B4h */ case    0:  		/* lwz R11, <#[R31 + 52]> */
		/* 822427B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 822427B4h case    0:*/		return 0x822427B8;
		  /* 822427B8h */ case    1:  		/* lwz R10, <#[R30 + 4]> */
		/* 822427B8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 822427B8h case    1:*/		return 0x822427BC;
		  /* 822427BCh */ case    2:  		/* rlwimi R10, R11, 27, 3, 4 */
		/* 822427BCh case    2:*/		cpu::op::rlwimi<0,27,3,4>(regs,&regs.R10,regs.R11);
		/* 822427BCh case    2:*/		return 0x822427C0;
		  /* 822427C0h */ case    3:  		/* stw R10, <#[R30 + 4]> */
		/* 822427C0h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 822427C0h case    3:*/		return 0x822427C4;
		  /* 822427C4h */ case    4:  		/* addi R1, R1, 144 */
		/* 822427C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 822427C4h case    4:*/		return 0x822427C8;
		  /* 822427C8h */ case    5:  		/* b -1774888 */
		/* 822427C8h case    5:*/		return 0x820912A0;
		/* 822427C8h case    5:*/		return 0x822427CC;
		  /* 822427CCh */ case    6:  		/* nop */
		/* 822427CCh case    6:*/		cpu::op::nop();
		/* 822427CCh case    6:*/		return 0x822427D0;
	}
	return 0x822427D0;
} // Block from 822427B4h-822427D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822427D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822427D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822427D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822427D0);
		  /* 822427D0h */ case    0:  		/* mfspr R12, LR */
		/* 822427D0h case    0:*/		regs.R12 = regs.LR;
		/* 822427D0h case    0:*/		return 0x822427D4;
		  /* 822427D4h */ case    1:  		/* bl -1774972 */
		/* 822427D4h case    1:*/		regs.LR = 0x822427D8; return 0x82091258;
		/* 822427D4h case    1:*/		return 0x822427D8;
		  /* 822427D8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822427D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822427D8h case    2:*/		return 0x822427DC;
		  /* 822427DCh */ case    3:  		/* lwz R10, <#[R4 + 4]> */
		/* 822427DCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 822427DCh case    3:*/		return 0x822427E0;
		  /* 822427E0h */ case    4:  		/* li R9, 12 */
		/* 822427E0h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 822427E0h case    4:*/		return 0x822427E4;
		  /* 822427E4h */ case    5:  		/* lwz R11, <#[R4 + 52]> */
		/* 822427E4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000034) );
		/* 822427E4h case    5:*/		return 0x822427E8;
		  /* 822427E8h */ case    6:  		/* mr R31, R3 */
		/* 822427E8h case    6:*/		regs.R31 = regs.R3;
		/* 822427E8h case    6:*/		return 0x822427EC;
		  /* 822427ECh */ case    7:  		/* subf R10, R10, R5 */
		/* 822427ECh case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 822427ECh case    7:*/		return 0x822427F0;
		  /* 822427F0h */ case    8:  		/* mr R30, R5 */
		/* 822427F0h case    8:*/		regs.R30 = regs.R5;
		/* 822427F0h case    8:*/		return 0x822427F4;
		  /* 822427F4h */ case    9:  		/* divw R10, R10, R9 */
		/* 822427F4h case    9:*/		cpu::op::divw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 822427F4h case    9:*/		return 0x822427F8;
		  /* 822427F8h */ case   10:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 822427F8h case   10:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 822427F8h case   10:*/		return 0x822427FC;
		  /* 822427FCh */ case   11:  		/* add R11, R10, R11 */
		/* 822427FCh case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822427FCh case   11:*/		return 0x82242800;
		  /* 82242800h */ case   12:  		/* lwz R10, <#[R11]> */
		/* 82242800h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82242800h case   12:*/		return 0x82242804;
		  /* 82242804h */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 82242804h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82242804h case   13:*/		return 0x82242808;
		  /* 82242808h */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 82242808h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82242814;  }
		/* 82242808h case   14:*/		return 0x8224280C;
		  /* 8224280Ch */ case   15:  		/* stw R3, <#[R11]> */
		/* 8224280Ch case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 8224280Ch case   15:*/		return 0x82242810;
		  /* 82242810h */ case   16:  		/* b 8 */
		/* 82242810h case   16:*/		return 0x82242818;
		/* 82242810h case   16:*/		return 0x82242814;
	}
	return 0x82242814;
} // Block from 822427D0h-82242814h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82242814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242814);
		  /* 82242814h */ case    0:  		/* stw R31, <#[R11 + 4]> */
		/* 82242814h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 82242814h case    0:*/		return 0x82242818;
	}
	return 0x82242818;
} // Block from 82242814h-82242818h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82242818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242818);
		  /* 82242818h */ case    0:  		/* lwz R10, <#[R31 + 24]> */
		/* 82242818h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82242818h case    0:*/		return 0x8224281C;
		  /* 8224281Ch */ case    1:  		/* lis R9, -32216 */
		/* 8224281Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8228);
		/* 8224281Ch case    1:*/		return 0x82242820;
		  /* 82242820h */ case    2:  		/* lis R11, -32253 */
		/* 82242820h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82242820h case    2:*/		return 0x82242824;
		  /* 82242824h */ case    3:  		/* addi R9, R9, 17992 */
		/* 82242824h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4648);
		/* 82242824h case    3:*/		return 0x82242828;
		  /* 82242828h */ case    4:  		/* mulli R10, R10, 52 */
		/* 82242828h case    4:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x34);
		/* 82242828h case    4:*/		return 0x8224282C;
		  /* 8224282Ch */ case    5:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8224282Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8224282Ch case    5:*/		return 0x82242830;
		  /* 82242830h */ case    6:  		/* addi R29, R11, 27460 */
		/* 82242830h case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x6B44);
		/* 82242830h case    6:*/		return 0x82242834;
		  /* 82242834h */ case    7:  		/* rlwinm. R9, R10, 30, 31, 31 */
		/* 82242834h case    7:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R9,regs.R10);
		/* 82242834h case    7:*/		return 0x82242838;
		  /* 82242838h */ case    8:  		/* lis R10, -32252 */
		/* 82242838h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82242838h case    8:*/		return 0x8224283C;
		  /* 8224283Ch */ case    9:  		/* lis R11, -32252 */
		/* 8224283Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224283Ch case    9:*/		return 0x82242840;
		  /* 82242840h */ case   10:  		/* addi R28, R10, 10344 */
		/* 82242840h case   10:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0x2868);
		/* 82242840h case   10:*/		return 0x82242844;
		  /* 82242844h */ case   11:  		/* mr R3, R31 */
		/* 82242844h case   11:*/		regs.R3 = regs.R31;
		/* 82242844h case   11:*/		return 0x82242848;
		  /* 82242848h */ case   12:  		/* addi R11, R11, 25976 */
		/* 82242848h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6578);
		/* 82242848h case   12:*/		return 0x8224284C;
		  /* 8224284Ch */ case   13:  		/* bc 12, CR0_EQ, 204 */
		/* 8224284Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82242918;  }
		/* 8224284Ch case   13:*/		return 0x82242850;
		  /* 82242850h */ case   14:  		/* lwz R11, <#[R11 + 240]> */
		/* 82242850h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000F0) );
		/* 82242850h case   14:*/		return 0x82242854;
		  /* 82242854h */ case   15:  		/* lwz R10, <#[R30]> */
		/* 82242854h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82242854h case   15:*/		return 0x82242858;
		  /* 82242858h */ case   16:  		/* rlwimi R10, R11, 26, 0, 5 */
		/* 82242858h case   16:*/		cpu::op::rlwimi<0,26,0,5>(regs,&regs.R10,regs.R11);
		/* 82242858h case   16:*/		return 0x8224285C;
		  /* 8224285Ch */ case   17:  		/* stw R10, <#[R30]> */
		/* 8224285Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8224285Ch case   17:*/		return 0x82242860;
		  /* 82242860h */ case   18:  		/* lwz R11, <#[R31]> */
		/* 82242860h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82242860h case   18:*/		return 0x82242864;
		  /* 82242864h */ case   19:  		/* lwz R11, <#[R11 + 4]> */
		/* 82242864h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82242864h case   19:*/		return 0x82242868;
		  /* 82242868h */ case   20:  		/* mtspr CTR, R11 */
		/* 82242868h case   20:*/		regs.CTR = regs.R11;
		/* 82242868h case   20:*/		return 0x8224286C;
		  /* 8224286Ch */ case   21:  		/* bcctrl 20, CR0_LT */
		/* 8224286Ch case   21:*/		if ( 1 ) { regs.LR = 0x82242870; return (uint32)regs.CTR; }
		/* 8224286Ch case   21:*/		return 0x82242870;
		  /* 82242870h */ case   22:  		/* cmpwi CR6, R3, 1 */
		/* 82242870h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82242870h case   22:*/		return 0x82242874;
		  /* 82242874h */ case   23:  		/* bc 12, CR6_LT, 316 */
		/* 82242874h case   23:*/		if ( regs.CR[6].lt ) { return 0x822429B0;  }
		/* 82242874h case   23:*/		return 0x82242878;
		  /* 82242878h */ case   24:  		/* li R6, 3 */
		/* 82242878h case   24:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 82242878h case   24:*/		return 0x8224287C;
		  /* 8224287Ch */ case   25:  		/* li R5, 1 */
		/* 8224287Ch case   25:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8224287Ch case   25:*/		return 0x82242880;
		  /* 82242880h */ case   26:  		/* mr R4, R30 */
		/* 82242880h case   26:*/		regs.R4 = regs.R30;
		/* 82242880h case   26:*/		return 0x82242884;
		  /* 82242884h */ case   27:  		/* mr R3, R31 */
		/* 82242884h case   27:*/		regs.R3 = regs.R31;
		/* 82242884h case   27:*/		return 0x82242888;
		  /* 82242888h */ case   28:  		/* bl -8824 */
		/* 82242888h case   28:*/		regs.LR = 0x8224288C; return 0x82240610;
		/* 82242888h case   28:*/		return 0x8224288C;
		  /* 8224288Ch */ case   29:  		/* li R11, 0 */
		/* 8224288Ch case   29:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224288Ch case   29:*/		return 0x82242890;
		  /* 82242890h */ case   30:  		/* stb R11, <#[R30 + 7]> */
		/* 82242890h case   30:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000007) );
		/* 82242890h case   30:*/		return 0x82242894;
		  /* 82242894h */ case   31:  		/* lbz R10, <#[R31 + 133]> */
		/* 82242894h case   31:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000085) );
		/* 82242894h case   31:*/		return 0x82242898;
		  /* 82242898h */ case   32:  		/* lbz R11, <#[R31 + 132]> */
		/* 82242898h case   32:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 82242898h case   32:*/		return 0x8224289C;
		  /* 8224289Ch */ case   33:  		/* cmplw CR6, R11, R10 */
		/* 8224289Ch case   33:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8224289Ch case   33:*/		return 0x822428A0;
		  /* 822428A0h */ case   34:  		/* bc 4, CR6_EQ, 28 */
		/* 822428A0h case   34:*/		if ( !regs.CR[6].eq ) { return 0x822428BC;  }
		/* 822428A0h case   34:*/		return 0x822428A4;
		  /* 822428A4h */ case   35:  		/* lbz R10, <#[R31 + 134]> */
		/* 822428A4h case   35:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000086) );
		/* 822428A4h case   35:*/		return 0x822428A8;
		  /* 822428A8h */ case   36:  		/* cmplw CR6, R11, R10 */
		/* 822428A8h case   36:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822428A8h case   36:*/		return 0x822428AC;
		  /* 822428ACh */ case   37:  		/* bc 4, CR6_EQ, 16 */
		/* 822428ACh case   37:*/		if ( !regs.CR[6].eq ) { return 0x822428BC;  }
		/* 822428ACh case   37:*/		return 0x822428B0;
		  /* 822428B0h */ case   38:  		/* lbz R10, <#[R31 + 135]> */
		/* 822428B0h case   38:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000087) );
		/* 822428B0h case   38:*/		return 0x822428B4;
		  /* 822428B4h */ case   39:  		/* cmplw CR6, R11, R10 */
		/* 822428B4h case   39:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822428B4h case   39:*/		return 0x822428B8;
		  /* 822428B8h */ case   40:  		/* bc 12, CR6_EQ, 32 */
		/* 822428B8h case   40:*/		if ( regs.CR[6].eq ) { return 0x822428D8;  }
		/* 822428B8h case   40:*/		return 0x822428BC;
	}
	return 0x822428BC;
} // Block from 82242818h-822428BCh (41 instructions)

//////////////////////////////////////////////////////
// Block at 822428BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822428BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822428BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822428BC);
		  /* 822428BCh */ case    0:  		/* lis R11, -32252 */
		/* 822428BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822428BCh case    0:*/		return 0x822428C0;
		  /* 822428C0h */ case    1:  		/* mr R6, R28 */
		/* 822428C0h case    1:*/		regs.R6 = regs.R28;
		/* 822428C0h case    1:*/		return 0x822428C4;
		  /* 822428C4h */ case    2:  		/* addi R5, R11, 11832 */
		/* 822428C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2E38);
		/* 822428C4h case    2:*/		return 0x822428C8;
		  /* 822428C8h */ case    3:  		/* mr R4, R29 */
		/* 822428C8h case    3:*/		regs.R4 = regs.R29;
		/* 822428C8h case    3:*/		return 0x822428CC;
		  /* 822428CCh */ case    4:  		/* li R7, 2621 */
		/* 822428CCh case    4:*/		cpu::op::li<0>(regs,&regs.R7,0xA3D);
		/* 822428CCh case    4:*/		return 0x822428D0;
		  /* 822428D0h */ case    5:  		/* li R3, 0 */
		/* 822428D0h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822428D0h case    5:*/		return 0x822428D4;
		  /* 822428D4h */ case    6:  		/* bl -961740 */
		/* 822428D4h case    6:*/		regs.LR = 0x822428D8; return 0x82157C08;
		/* 822428D4h case    6:*/		return 0x822428D8;
	}
	return 0x822428D8;
} // Block from 822428BCh-822428D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822428D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822428D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822428D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822428D8);
		  /* 822428D8h */ case    0:  		/* lbz R11, <#[R31 + 132]> */
		/* 822428D8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 822428D8h case    0:*/		return 0x822428DC;
		  /* 822428DCh */ case    1:  		/* addic. R11, R11, -3 */
		/* 822428DCh case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFD);
		/* 822428DCh case    1:*/		return 0x822428E0;
		  /* 822428E0h */ case    2:  		/* bc 4, CR0_LT, 8 */
		/* 822428E0h case    2:*/		if ( !regs.CR[0].lt ) { return 0x822428E8;  }
		/* 822428E0h case    2:*/		return 0x822428E4;
		  /* 822428E4h */ case    3:  		/* addi R11, R11, 4 */
		/* 822428E4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822428E4h case    3:*/		return 0x822428E8;
	}
	return 0x822428E8;
} // Block from 822428D8h-822428E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822428E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822428E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822428E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822428E8);
		  /* 822428E8h */ case    0:  		/* lwz R10, <#[R30 + 4]> */
		/* 822428E8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 822428E8h case    0:*/		return 0x822428EC;
		  /* 822428ECh */ case    1:  		/* rlwinm R11, R11, 6, 0, 25 */
		/* 822428ECh case    1:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R11);
		/* 822428ECh case    1:*/		return 0x822428F0;
		  /* 822428F0h */ case    2:  		/* or R11, R11, R10 */
		/* 822428F0h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822428F0h case    2:*/		return 0x822428F4;
		  /* 822428F4h */ case    3:  		/* stb R11, <#[R30 + 7]> */
		/* 822428F4h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000007) );
		/* 822428F4h case    3:*/		return 0x822428F8;
		  /* 822428F8h */ case    4:  		/* lbz R11, <#[R31 + 132]> */
		/* 822428F8h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 822428F8h case    4:*/		return 0x822428FC;
		  /* 822428FCh */ case    5:  		/* cmpwi CR0, R11, 0 */
		/* 822428FCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 822428FCh case    5:*/		return 0x82242900;
		  /* 82242900h */ case    6:  		/* bc 4, CR0_LT, 8 */
		/* 82242900h case    6:*/		if ( !regs.CR[0].lt ) { return 0x82242908;  }
		/* 82242900h case    6:*/		return 0x82242904;
		  /* 82242904h */ case    7:  		/* addi R11, R11, 4 */
		/* 82242904h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82242904h case    7:*/		return 0x82242908;
	}
	return 0x82242908;
} // Block from 822428E8h-82242908h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82242908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242908);
		  /* 82242908h */ case    0:  		/* lwz R10, <#[R30 + 4]> */
		/* 82242908h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82242908h case    0:*/		return 0x8224290C;
		  /* 8224290Ch */ case    1:  		/* or R11, R10, R11 */
		/* 8224290Ch case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8224290Ch case    1:*/		return 0x82242910;
		  /* 82242910h */ case    2:  		/* stb R11, <#[R30 + 7]> */
		/* 82242910h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000007) );
		/* 82242910h case    2:*/		return 0x82242914;
		  /* 82242914h */ case    3:  		/* b 156 */
		/* 82242914h case    3:*/		return 0x822429B0;
		/* 82242914h case    3:*/		return 0x82242918;
	}
	return 0x82242918;
} // Block from 82242908h-82242918h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82242918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242918);
		  /* 82242918h */ case    0:  		/* lwz R11, <#[R11 + 92]> */
		/* 82242918h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000005C) );
		/* 82242918h case    0:*/		return 0x8224291C;
		  /* 8224291Ch */ case    1:  		/* lwz R10, <#[R30 + 8]> */
		/* 8224291Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8224291Ch case    1:*/		return 0x82242920;
		  /* 82242920h */ case    2:  		/* rlwimi R10, R11, 24, 3, 7 */
		/* 82242920h case    2:*/		cpu::op::rlwimi<0,24,3,7>(regs,&regs.R10,regs.R11);
		/* 82242920h case    2:*/		return 0x82242924;
		  /* 82242924h */ case    3:  		/* stw R10, <#[R30 + 8]> */
		/* 82242924h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82242924h case    3:*/		return 0x82242928;
		  /* 82242928h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 82242928h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82242928h case    4:*/		return 0x8224292C;
		  /* 8224292Ch */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224292Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224292Ch case    5:*/		return 0x82242930;
		  /* 82242930h */ case    6:  		/* mtspr CTR, R11 */
		/* 82242930h case    6:*/		regs.CTR = regs.R11;
		/* 82242930h case    6:*/		return 0x82242934;
		  /* 82242934h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82242934h case    7:*/		if ( 1 ) { regs.LR = 0x82242938; return (uint32)regs.CTR; }
		/* 82242934h case    7:*/		return 0x82242938;
		  /* 82242938h */ case    8:  		/* cmpwi CR6, R3, 1 */
		/* 82242938h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82242938h case    8:*/		return 0x8224293C;
		  /* 8224293Ch */ case    9:  		/* bc 12, CR6_LT, 116 */
		/* 8224293Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x822429B0;  }
		/* 8224293Ch case    9:*/		return 0x82242940;
		  /* 82242940h */ case   10:  		/* li R6, 1 */
		/* 82242940h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82242940h case   10:*/		return 0x82242944;
		  /* 82242944h */ case   11:  		/* li R5, 1 */
		/* 82242944h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242944h case   11:*/		return 0x82242948;
		  /* 82242948h */ case   12:  		/* mr R4, R30 */
		/* 82242948h case   12:*/		regs.R4 = regs.R30;
		/* 82242948h case   12:*/		return 0x8224294C;
		  /* 8224294Ch */ case   13:  		/* mr R3, R31 */
		/* 8224294Ch case   13:*/		regs.R3 = regs.R31;
		/* 8224294Ch case   13:*/		return 0x82242950;
		  /* 82242950h */ case   14:  		/* bl -9024 */
		/* 82242950h case   14:*/		regs.LR = 0x82242954; return 0x82240610;
		/* 82242950h case   14:*/		return 0x82242954;
		  /* 82242954h */ case   15:  		/* li R6, 2 */
		/* 82242954h case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 82242954h case   15:*/		return 0x82242958;
		  /* 82242958h */ case   16:  		/* li R5, 1 */
		/* 82242958h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242958h case   16:*/		return 0x8224295C;
		  /* 8224295Ch */ case   17:  		/* mr R4, R30 */
		/* 8224295Ch case   17:*/		regs.R4 = regs.R30;
		/* 8224295Ch case   17:*/		return 0x82242960;
		  /* 82242960h */ case   18:  		/* mr R3, R31 */
		/* 82242960h case   18:*/		regs.R3 = regs.R31;
		/* 82242960h case   18:*/		return 0x82242964;
		  /* 82242964h */ case   19:  		/* bl -9044 */
		/* 82242964h case   19:*/		regs.LR = 0x82242968; return 0x82240610;
		/* 82242964h case   19:*/		return 0x82242968;
		  /* 82242968h */ case   20:  		/* lwz R10, <#[R31 + 132]> */
		/* 82242968h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 82242968h case   20:*/		return 0x8224296C;
		  /* 8224296Ch */ case   21:  		/* rlwinm R11, R10, 8, 24, 31 */
		/* 8224296Ch case   21:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R11,regs.R10);
		/* 8224296Ch case   21:*/		return 0x82242970;
		  /* 82242970h */ case   22:  		/* rlwimi R11, R10, 24, 16, 23 */
		/* 82242970h case   22:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R11,regs.R10);
		/* 82242970h case   22:*/		return 0x82242974;
		  /* 82242974h */ case   23:  		/* rlwimi R11, R10, 8, 8, 15 */
		/* 82242974h case   23:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R11,regs.R10);
		/* 82242974h case   23:*/		return 0x82242978;
		  /* 82242978h */ case   24:  		/* rlwimi R11, R10, 24, 0, 7 */
		/* 82242978h case   24:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R11,regs.R10);
		/* 82242978h case   24:*/		return 0x8224297C;
		  /* 8224297Ch */ case   25:  		/* addis R10, R11, 256 */
		/* 8224297Ch case   25:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R11,0x100);
		/* 8224297Ch case   25:*/		return 0x82242980;
		  /* 82242980h */ case   26:  		/* addi R9, R11, -256 */
		/* 82242980h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFF00);
		/* 82242980h case   26:*/		return 0x82242984;
		  /* 82242984h */ case   27:  		/* rlwinm R10, R10, 14, 24, 25 */
		/* 82242984h case   27:*/		cpu::op::rlwinm<0,14,24,25>(regs,&regs.R10,regs.R10);
		/* 82242984h case   27:*/		return 0x82242988;
		  /* 82242988h */ case   28:  		/* rlwinm R9, R9, 26, 28, 29 */
		/* 82242988h case   28:*/		cpu::op::rlwinm<0,26,28,29>(regs,&regs.R9,regs.R9);
		/* 82242988h case   28:*/		return 0x8224298C;
		  /* 8224298Ch */ case   29:  		/* addis R8, R11, -2 */
		/* 8224298Ch case   29:*/		cpu::op::addis<0>(regs,&regs.R8,regs.R11,0xFFFFFFFE);
		/* 8224298Ch case   29:*/		return 0x82242990;
		  /* 82242990h */ case   30:  		/* or R10, R10, R9 */
		/* 82242990h case   30:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242990h case   30:*/		return 0x82242994;
		  /* 82242994h */ case   31:  		/* rlwinm R9, R8, 20, 26, 27 */
		/* 82242994h case   31:*/		cpu::op::rlwinm<0,20,26,27>(regs,&regs.R9,regs.R8);
		/* 82242994h case   31:*/		return 0x82242998;
		  /* 82242998h */ case   32:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82242998h case   32:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82242998h case   32:*/		return 0x8224299C;
		  /* 8224299Ch */ case   33:  		/* or R10, R10, R9 */
		/* 8224299Ch case   33:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8224299Ch case   33:*/		return 0x822429A0;
		  /* 822429A0h */ case   34:  		/* or R11, R10, R11 */
		/* 822429A0h case   34:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822429A0h case   34:*/		return 0x822429A4;
		  /* 822429A4h */ case   35:  		/* stb R11, <#[R30 + 5]> */
		/* 822429A4h case   35:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 822429A4h case   35:*/		return 0x822429A8;
		  /* 822429A8h */ case   36:  		/* lhz R11, <#[R30 + 4]> */
		/* 822429A8h case   36:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 822429A8h case   36:*/		return 0x822429AC;
		  /* 822429ACh */ case   37:  		/* stb R11, <#[R30 + 6]> */
		/* 822429ACh case   37:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000006) );
		/* 822429ACh case   37:*/		return 0x822429B0;
	}
	return 0x822429B0;
} // Block from 82242918h-822429B0h (38 instructions)

//////////////////////////////////////////////////////
// Block at 822429B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822429B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822429B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822429B0);
		  /* 822429B0h */ case    0:  		/* mr R4, R30 */
		/* 822429B0h case    0:*/		regs.R4 = regs.R30;
		/* 822429B0h case    0:*/		return 0x822429B4;
		  /* 822429B4h */ case    1:  		/* mr R3, R31 */
		/* 822429B4h case    1:*/		regs.R3 = regs.R31;
		/* 822429B4h case    1:*/		return 0x822429B8;
		  /* 822429B8h */ case    2:  		/* bl -7728 */
		/* 822429B8h case    2:*/		regs.LR = 0x822429BC; return 0x82240B88;
		/* 822429B8h case    2:*/		return 0x822429BC;
		  /* 822429BCh */ case    3:  		/* lwz R11, <#[R30 + 4]> */
		/* 822429BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 822429BCh case    3:*/		return 0x822429C0;
		  /* 822429C0h */ case    4:  		/* rlwinm. R11, R11, 5, 30, 31 */
		/* 822429C0h case    4:*/		cpu::op::rlwinm<1,5,30,31>(regs,&regs.R11,regs.R11);
		/* 822429C0h case    4:*/		return 0x822429C4;
		  /* 822429C4h */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 822429C4h case    5:*/		if ( regs.CR[0].eq ) { return 0x822429F0;  }
		/* 822429C4h case    5:*/		return 0x822429C8;
		  /* 822429C8h */ case    6:  		/* lwz R10, <#[R31 + 52]> */
		/* 822429C8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000034) );
		/* 822429C8h case    6:*/		return 0x822429CC;
		  /* 822429CCh */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 822429CCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822429CCh case    7:*/		return 0x822429D0;
		  /* 822429D0h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 822429D0h case    8:*/		if ( regs.CR[6].eq ) { return 0x822429F0;  }
		/* 822429D0h case    8:*/		return 0x822429D4;
		  /* 822429D4h */ case    9:  		/* lis R11, -32252 */
		/* 822429D4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822429D4h case    9:*/		return 0x822429D8;
		  /* 822429D8h */ case   10:  		/* mr R6, R28 */
		/* 822429D8h case   10:*/		regs.R6 = regs.R28;
		/* 822429D8h case   10:*/		return 0x822429DC;
		  /* 822429DCh */ case   11:  		/* addi R5, R11, 11652 */
		/* 822429DCh case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2D84);
		/* 822429DCh case   11:*/		return 0x822429E0;
		  /* 822429E0h */ case   12:  		/* mr R4, R29 */
		/* 822429E0h case   12:*/		regs.R4 = regs.R29;
		/* 822429E0h case   12:*/		return 0x822429E4;
		  /* 822429E4h */ case   13:  		/* li R7, 2648 */
		/* 822429E4h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0xA58);
		/* 822429E4h case   13:*/		return 0x822429E8;
		  /* 822429E8h */ case   14:  		/* li R3, 0 */
		/* 822429E8h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822429E8h case   14:*/		return 0x822429EC;
		  /* 822429ECh */ case   15:  		/* bl -962020 */
		/* 822429ECh case   15:*/		regs.LR = 0x822429F0; return 0x82157C08;
		/* 822429ECh case   15:*/		return 0x822429F0;
	}
	return 0x822429F0;
} // Block from 822429B0h-822429F0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822429F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822429F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822429F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822429F0);
		  /* 822429F0h */ case    0:  		/* lwz R11, <#[R31 + 52]> */
		/* 822429F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 822429F0h case    0:*/		return 0x822429F4;
		  /* 822429F4h */ case    1:  		/* lwz R10, <#[R30 + 4]> */
		/* 822429F4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 822429F4h case    1:*/		return 0x822429F8;
		  /* 822429F8h */ case    2:  		/* lwz R9, <#[R30]> */
		/* 822429F8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 822429F8h case    2:*/		return 0x822429FC;
		  /* 822429FCh */ case    3:  		/* rlwimi R10, R11, 27, 3, 4 */
		/* 822429FCh case    3:*/		cpu::op::rlwimi<0,27,3,4>(regs,&regs.R10,regs.R11);
		/* 822429FCh case    3:*/		return 0x82242A00;
		  /* 82242A00h */ case    4:  		/* ori R11, R9, 32768 */
		/* 82242A00h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R9,0x8000);
		/* 82242A00h case    4:*/		return 0x82242A04;
		  /* 82242A04h */ case    5:  		/* stw R10, <#[R30 + 4]> */
		/* 82242A04h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82242A04h case    5:*/		return 0x82242A08;
		  /* 82242A08h */ case    6:  		/* stw R11, <#[R30]> */
		/* 82242A08h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82242A08h case    6:*/		return 0x82242A0C;
		  /* 82242A0Ch */ case    7:  		/* addi R1, R1, 128 */
		/* 82242A0Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82242A0Ch case    7:*/		return 0x82242A10;
		  /* 82242A10h */ case    8:  		/* b -1775464 */
		/* 82242A10h case    8:*/		return 0x820912A8;
		/* 82242A10h case    8:*/		return 0x82242A14;
		  /* 82242A14h */ case    9:  		/* nop */
		/* 82242A14h case    9:*/		cpu::op::nop();
		/* 82242A14h case    9:*/		return 0x82242A18;
	}
	return 0x82242A18;
} // Block from 822429F0h-82242A18h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82242A18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242A18);
		  /* 82242A18h */ case    0:  		/* mfspr R12, LR */
		/* 82242A18h case    0:*/		regs.R12 = regs.LR;
		/* 82242A18h case    0:*/		return 0x82242A1C;
		  /* 82242A1Ch */ case    1:  		/* bl -1775568 */
		/* 82242A1Ch case    1:*/		regs.LR = 0x82242A20; return 0x8209124C;
		/* 82242A1Ch case    1:*/		return 0x82242A20;
		  /* 82242A20h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82242A20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82242A20h case    2:*/		return 0x82242A24;
		  /* 82242A24h */ case    3:  		/* lwz R10, <#[R4 + 4]> */
		/* 82242A24h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 82242A24h case    3:*/		return 0x82242A28;
		  /* 82242A28h */ case    4:  		/* li R9, 12 */
		/* 82242A28h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 82242A28h case    4:*/		return 0x82242A2C;
		  /* 82242A2Ch */ case    5:  		/* lwz R11, <#[R4 + 52]> */
		/* 82242A2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000034) );
		/* 82242A2Ch case    5:*/		return 0x82242A30;
		  /* 82242A30h */ case    6:  		/* mr R30, R3 */
		/* 82242A30h case    6:*/		regs.R30 = regs.R3;
		/* 82242A30h case    6:*/		return 0x82242A34;
		  /* 82242A34h */ case    7:  		/* subf R10, R10, R5 */
		/* 82242A34h case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 82242A34h case    7:*/		return 0x82242A38;
		  /* 82242A38h */ case    8:  		/* mr R31, R5 */
		/* 82242A38h case    8:*/		regs.R31 = regs.R5;
		/* 82242A38h case    8:*/		return 0x82242A3C;
		  /* 82242A3Ch */ case    9:  		/* divw R10, R10, R9 */
		/* 82242A3Ch case    9:*/		cpu::op::divw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242A3Ch case    9:*/		return 0x82242A40;
		  /* 82242A40h */ case   10:  		/* mr R26, R6 */
		/* 82242A40h case   10:*/		regs.R26 = regs.R6;
		/* 82242A40h case   10:*/		return 0x82242A44;
		  /* 82242A44h */ case   11:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82242A44h case   11:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82242A44h case   11:*/		return 0x82242A48;
		  /* 82242A48h */ case   12:  		/* add R11, R10, R11 */
		/* 82242A48h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82242A48h case   12:*/		return 0x82242A4C;
		  /* 82242A4Ch */ case   13:  		/* lwz R10, <#[R11]> */
		/* 82242A4Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82242A4Ch case   13:*/		return 0x82242A50;
		  /* 82242A50h */ case   14:  		/* cmplwi CR6, R10, 0 */
		/* 82242A50h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82242A50h case   14:*/		return 0x82242A54;
		  /* 82242A54h */ case   15:  		/* bc 4, CR6_EQ, 12 */
		/* 82242A54h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82242A60;  }
		/* 82242A54h case   15:*/		return 0x82242A58;
		  /* 82242A58h */ case   16:  		/* stw R3, <#[R11]> */
		/* 82242A58h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 82242A58h case   16:*/		return 0x82242A5C;
		  /* 82242A5Ch */ case   17:  		/* b 8 */
		/* 82242A5Ch case   17:*/		return 0x82242A64;
		/* 82242A5Ch case   17:*/		return 0x82242A60;
	}
	return 0x82242A60;
} // Block from 82242A18h-82242A60h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82242A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242A60);
		  /* 82242A60h */ case    0:  		/* stw R30, <#[R11 + 4]> */
		/* 82242A60h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 82242A60h case    0:*/		return 0x82242A64;
	}
	return 0x82242A64;
} // Block from 82242A60h-82242A64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82242A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242A64);
		  /* 82242A64h */ case    0:  		/* li R6, 1 */
		/* 82242A64h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82242A64h case    0:*/		return 0x82242A68;
		  /* 82242A68h */ case    1:  		/* li R5, 1 */
		/* 82242A68h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242A68h case    1:*/		return 0x82242A6C;
		  /* 82242A6Ch */ case    2:  		/* mr R4, R31 */
		/* 82242A6Ch case    2:*/		regs.R4 = regs.R31;
		/* 82242A6Ch case    2:*/		return 0x82242A70;
		  /* 82242A70h */ case    3:  		/* mr R3, R30 */
		/* 82242A70h case    3:*/		regs.R3 = regs.R30;
		/* 82242A70h case    3:*/		return 0x82242A74;
		  /* 82242A74h */ case    4:  		/* bl -9316 */
		/* 82242A74h case    4:*/		regs.LR = 0x82242A78; return 0x82240610;
		/* 82242A74h case    4:*/		return 0x82242A78;
		  /* 82242A78h */ case    5:  		/* li R6, 2 */
		/* 82242A78h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 82242A78h case    5:*/		return 0x82242A7C;
		  /* 82242A7Ch */ case    6:  		/* li R5, 1 */
		/* 82242A7Ch case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242A7Ch case    6:*/		return 0x82242A80;
		  /* 82242A80h */ case    7:  		/* mr R4, R31 */
		/* 82242A80h case    7:*/		regs.R4 = regs.R31;
		/* 82242A80h case    7:*/		return 0x82242A84;
		  /* 82242A84h */ case    8:  		/* mr R3, R30 */
		/* 82242A84h case    8:*/		regs.R3 = regs.R30;
		/* 82242A84h case    8:*/		return 0x82242A88;
		  /* 82242A88h */ case    9:  		/* bl -9336 */
		/* 82242A88h case    9:*/		regs.LR = 0x82242A8C; return 0x82240610;
		/* 82242A88h case    9:*/		return 0x82242A8C;
		  /* 82242A8Ch */ case   10:  		/* lis R11, -32252 */
		/* 82242A8Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242A8Ch case   10:*/		return 0x82242A90;
		  /* 82242A90h */ case   11:  		/* li R10, 4 */
		/* 82242A90h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82242A90h case   11:*/		return 0x82242A94;
		  /* 82242A94h */ case   12:  		/* lwz R8, <#[R31 + 8]> */
		/* 82242A94h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82242A94h case   12:*/		return 0x82242A98;
		  /* 82242A98h */ case   13:  		/* addi R29, R11, 25976 */
		/* 82242A98h case   13:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x6578);
		/* 82242A98h case   13:*/		return 0x82242A9C;
		  /* 82242A9Ch */ case   14:  		/* lwz R7, <#[R31]> */
		/* 82242A9Ch case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 82242A9Ch case   14:*/		return 0x82242AA0;
		  /* 82242AA0h */ case   15:  		/* li R9, 0 */
		/* 82242AA0h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82242AA0h case   15:*/		return 0x82242AA4;
		  /* 82242AA4h */ case   16:  		/* li R25, 1 */
		/* 82242AA4h case   16:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 82242AA4h case   16:*/		return 0x82242AA8;
		  /* 82242AA8h */ case   17:  		/* mr R11, R9 */
		/* 82242AA8h case   17:*/		regs.R11 = regs.R9;
		/* 82242AA8h case   17:*/		return 0x82242AAC;
		  /* 82242AACh */ case   18:  		/* mtspr CTR, R10 */
		/* 82242AACh case   18:*/		regs.CTR = regs.R10;
		/* 82242AACh case   18:*/		return 0x82242AB0;
		  /* 82242AB0h */ case   19:  		/* lwz R10, <#[R29 + 92]> */
		/* 82242AB0h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000005C) );
		/* 82242AB0h case   19:*/		return 0x82242AB4;
		  /* 82242AB4h */ case   20:  		/* rlwimi R8, R10, 24, 3, 7 */
		/* 82242AB4h case   20:*/		cpu::op::rlwimi<0,24,3,7>(regs,&regs.R8,regs.R10);
		/* 82242AB4h case   20:*/		return 0x82242AB8;
		  /* 82242AB8h */ case   21:  		/* rlwinm R10, R7, 0, 16, 11 */
		/* 82242AB8h case   21:*/		cpu::op::rlwinm<0,0,16,11>(regs,&regs.R10,regs.R7);
		/* 82242AB8h case   21:*/		return 0x82242ABC;
		  /* 82242ABCh */ case   22:  		/* stw R8, <#[R31 + 8]> */
		/* 82242ABCh case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82242ABCh case   22:*/		return 0x82242AC0;
		  /* 82242AC0h */ case   23:  		/* stw R10, <#[R31]> */
		/* 82242AC0h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82242AC0h case   23:*/		return 0x82242AC4;
		  /* 82242AC4h */ case   24:  		/* slw R10, R25, R11 */
		/* 82242AC4h case   24:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R25,regs.R11);
		/* 82242AC4h case   24:*/		return 0x82242AC8;
	}
	return 0x82242AC8;
} // Block from 82242A64h-82242AC8h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82242AC8h
// Function '?FulfillCurrentCfJmp@Assembler@XGRAPHICS@@QAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242AC8);
		  /* 82242AC8h */ case    0:  		/* lwz R8, <#[R31]> */
		/* 82242AC8h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 82242AC8h case    0:*/		return 0x82242ACC;
		  /* 82242ACCh */ case    1:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 82242ACCh case    1:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 82242ACCh case    1:*/		return 0x82242AD0;
		  /* 82242AD0h */ case    2:  		/* addi R11, R11, 1 */
		/* 82242AD0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82242AD0h case    2:*/		return 0x82242AD4;
		  /* 82242AD4h */ case    3:  		/* or R10, R10, R8 */
		/* 82242AD4h case    3:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82242AD4h case    3:*/		return 0x82242AD8;
		  /* 82242AD8h */ case    4:  		/* rlwimi R10, R8, 0, 16, 11 */
		/* 82242AD8h case    4:*/		cpu::op::rlwimi<0,0,16,11>(regs,&regs.R10,regs.R8);
		/* 82242AD8h case    4:*/		return 0x82242ADC;
		  /* 82242ADCh */ case    5:  		/* stw R10, <#[R31]> */
		/* 82242ADCh case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82242ADCh case    5:*/		return 0x82242AE0;
		  /* 82242AE0h */ case    6:  		/* bc 16, CR0_LT, -28 */
		/* 82242AE0h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82242AC4;  }
		/* 82242AE0h case    6:*/		return 0x82242AE4;
		  /* 82242AE4h */ case    7:  		/* stb R9, <#[R31 + 5]> */
		/* 82242AE4h case    7:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R31 + 0x00000005) );
		/* 82242AE4h case    7:*/		return 0x82242AE8;
		  /* 82242AE8h */ case    8:  		/* lis R27, 256 */
		/* 82242AE8h case    8:*/		cpu::op::lis<0>(regs,&regs.R27,0x100);
		/* 82242AE8h case    8:*/		return 0x82242AEC;
		  /* 82242AECh */ case    9:  		/* stb R9, <#[R31 + 6]> */
		/* 82242AECh case    9:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R31 + 0x00000006) );
		/* 82242AECh case    9:*/		return 0x82242AF0;
		  /* 82242AF0h */ case   10:  		/* lis R28, 2 */
		/* 82242AF0h case   10:*/		cpu::op::lis<0>(regs,&regs.R28,0x2);
		/* 82242AF0h case   10:*/		return 0x82242AF4;
		  /* 82242AF4h */ case   11:  		/* lwz R4, <#[R30 + 236]> */
		/* 82242AF4h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000000EC) );
		/* 82242AF4h case   11:*/		return 0x82242AF8;
		  /* 82242AF8h */ case   12:  		/* cmplwi CR6, R4, 0 */
		/* 82242AF8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82242AF8h case   12:*/		return 0x82242AFC;
		  /* 82242AFCh */ case   13:  		/* bc 12, CR6_EQ, 92 */
		/* 82242AFCh case   13:*/		if ( regs.CR[6].eq ) { return 0x82242B58;  }
		/* 82242AFCh case   13:*/		return 0x82242B00;
		  /* 82242B00h */ case   14:  		/* lwz R3, <#[R26 + 2736]> */
		/* 82242B00h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000AB0) );
		/* 82242B00h case   14:*/		return 0x82242B04;
		  /* 82242B04h */ case   15:  		/* bl 137444 */
		/* 82242B04h case   15:*/		regs.LR = 0x82242B08; return 0x822643E8;
		/* 82242B04h case   15:*/		return 0x82242B08;
		  /* 82242B08h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 82242B08h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82242B08h case   16:*/		return 0x82242B0C;
		  /* 82242B0Ch */ case   17:  		/* bc 12, CR0_LT, 76 */
		/* 82242B0Ch case   17:*/		if ( regs.CR[0].lt ) { return 0x82242B58;  }
		/* 82242B0Ch case   17:*/		return 0x82242B10;
		  /* 82242B10h */ case   18:  		/* lwz R10, <#[R30 + 132]> */
		/* 82242B10h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000084) );
		/* 82242B10h case   18:*/		return 0x82242B14;
		  /* 82242B14h */ case   19:  		/* rlwinm R11, R10, 8, 24, 31 */
		/* 82242B14h case   19:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R11,regs.R10);
		/* 82242B14h case   19:*/		return 0x82242B18;
		  /* 82242B18h */ case   20:  		/* rlwimi R11, R10, 24, 16, 23 */
		/* 82242B18h case   20:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R11,regs.R10);
		/* 82242B18h case   20:*/		return 0x82242B1C;
		  /* 82242B1Ch */ case   21:  		/* rlwimi R11, R10, 8, 8, 15 */
		/* 82242B1Ch case   21:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R11,regs.R10);
		/* 82242B1Ch case   21:*/		return 0x82242B20;
		  /* 82242B20h */ case   22:  		/* rlwimi R11, R10, 24, 0, 7 */
		/* 82242B20h case   22:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R11,regs.R10);
		/* 82242B20h case   22:*/		return 0x82242B24;
		  /* 82242B24h */ case   23:  		/* add R10, R11, R27 */
		/* 82242B24h case   23:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R27);
		/* 82242B24h case   23:*/		return 0x82242B28;
		  /* 82242B28h */ case   24:  		/* addi R9, R11, -256 */
		/* 82242B28h case   24:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFF00);
		/* 82242B28h case   24:*/		return 0x82242B2C;
		  /* 82242B2Ch */ case   25:  		/* rlwinm R10, R10, 14, 24, 25 */
		/* 82242B2Ch case   25:*/		cpu::op::rlwinm<0,14,24,25>(regs,&regs.R10,regs.R10);
		/* 82242B2Ch case   25:*/		return 0x82242B30;
		  /* 82242B30h */ case   26:  		/* rlwinm R9, R9, 26, 28, 29 */
		/* 82242B30h case   26:*/		cpu::op::rlwinm<0,26,28,29>(regs,&regs.R9,regs.R9);
		/* 82242B30h case   26:*/		return 0x82242B34;
		  /* 82242B34h */ case   27:  		/* subf R8, R28, R11 */
		/* 82242B34h case   27:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R28,regs.R11);
		/* 82242B34h case   27:*/		return 0x82242B38;
		  /* 82242B38h */ case   28:  		/* or R10, R10, R9 */
		/* 82242B38h case   28:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242B38h case   28:*/		return 0x82242B3C;
		  /* 82242B3Ch */ case   29:  		/* rlwinm R9, R8, 20, 26, 27 */
		/* 82242B3Ch case   29:*/		cpu::op::rlwinm<0,20,26,27>(regs,&regs.R9,regs.R8);
		/* 82242B3Ch case   29:*/		return 0x82242B40;
		  /* 82242B40h */ case   30:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82242B40h case   30:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82242B40h case   30:*/		return 0x82242B44;
		  /* 82242B44h */ case   31:  		/* or R10, R10, R9 */
		/* 82242B44h case   31:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242B44h case   31:*/		return 0x82242B48;
		  /* 82242B48h */ case   32:  		/* or R11, R10, R11 */
		/* 82242B48h case   32:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82242B48h case   32:*/		return 0x82242B4C;
		  /* 82242B4Ch */ case   33:  		/* stb R11, <#[R31 + 5]> */
		/* 82242B4Ch case   33:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 82242B4Ch case   33:*/		return 0x82242B50;
		  /* 82242B50h */ case   34:  		/* lhz R11, <#[R31 + 4]> */
		/* 82242B50h case   34:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82242B50h case   34:*/		return 0x82242B54;
		  /* 82242B54h */ case   35:  		/* stb R11, <#[R31 + 6]> */
		/* 82242B54h case   35:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000006) );
		/* 82242B54h case   35:*/		return 0x82242B58;
	}
	return 0x82242B58;
} // Block from 82242AC8h-82242B58h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82242B58h
// Function '??1Assembler@XGRAPHICS@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242B58);
		  /* 82242B58h */ case    0:  		/* lwz R11, <#[R30 + 128]> */
		/* 82242B58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 82242B58h case    0:*/		return 0x82242B5C;
		  /* 82242B5Ch */ case    1:  		/* mr R4, R30 */
		/* 82242B5Ch case    1:*/		regs.R4 = regs.R30;
		/* 82242B5Ch case    1:*/		return 0x82242B60;
		  /* 82242B60h */ case    2:  		/* lwz R10, <#[R31]> */
		/* 82242B60h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82242B60h case    2:*/		return 0x82242B64;
		  /* 82242B64h */ case    3:  		/* rlwinm R9, R11, 8, 24, 31 */
		/* 82242B64h case    3:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R9,regs.R11);
		/* 82242B64h case    3:*/		return 0x82242B68;
		  /* 82242B68h */ case    4:  		/* rlwimi R9, R11, 24, 16, 23 */
		/* 82242B68h case    4:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R9,regs.R11);
		/* 82242B68h case    4:*/		return 0x82242B6C;
		  /* 82242B6Ch */ case    5:  		/* rlwimi R9, R11, 8, 8, 15 */
		/* 82242B6Ch case    5:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R9,regs.R11);
		/* 82242B6Ch case    5:*/		return 0x82242B70;
		  /* 82242B70h */ case    6:  		/* rlwimi R9, R11, 24, 0, 7 */
		/* 82242B70h case    6:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R9,regs.R11);
		/* 82242B70h case    6:*/		return 0x82242B74;
		  /* 82242B74h */ case    7:  		/* rlwinm R11, R9, 25, 7, 31 */
		/* 82242B74h case    7:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R11,regs.R9);
		/* 82242B74h case    7:*/		return 0x82242B78;
		  /* 82242B78h */ case    8:  		/* rlwinm R8, R9, 0, 15, 15 */
		/* 82242B78h case    8:*/		cpu::op::rlwinm<0,0,15,15>(regs,&regs.R8,regs.R9);
		/* 82242B78h case    8:*/		return 0x82242B7C;
		  /* 82242B7Ch */ case    9:  		/* rlwinm R11, R11, 0, 18, 14 */
		/* 82242B7Ch case    9:*/		cpu::op::rlwinm<0,0,18,14>(regs,&regs.R11,regs.R11);
		/* 82242B7Ch case    9:*/		return 0x82242B80;
		  /* 82242B80h */ case   10:  		/* rlwinm R7, R9, 0, 23, 23 */
		/* 82242B80h case   10:*/		cpu::op::rlwinm<0,0,23,23>(regs,&regs.R7,regs.R9);
		/* 82242B80h case   10:*/		return 0x82242B84;
		  /* 82242B84h */ case   11:  		/* or R11, R11, R8 */
		/* 82242B84h case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82242B84h case   11:*/		return 0x82242B88;
		  /* 82242B88h */ case   12:  		/* rlwinm R9, R9, 0, 31, 31 */
		/* 82242B88h case   12:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82242B88h case   12:*/		return 0x82242B8C;
		  /* 82242B8Ch */ case   13:  		/* rlwinm R11, R11, 25, 7, 31 */
		/* 82242B8Ch case   13:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R11,regs.R11);
		/* 82242B8Ch case   13:*/		return 0x82242B90;
		  /* 82242B90h */ case   14:  		/* or R11, R11, R7 */
		/* 82242B90h case   14:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82242B90h case   14:*/		return 0x82242B94;
		  /* 82242B94h */ case   15:  		/* rlwinm R11, R11, 25, 7, 31 */
		/* 82242B94h case   15:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R11,regs.R11);
		/* 82242B94h case   15:*/		return 0x82242B98;
		  /* 82242B98h */ case   16:  		/* nor R11, R11, R9 */
		/* 82242B98h case   16:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82242B98h case   16:*/		return 0x82242B9C;
		  /* 82242B9Ch */ case   17:  		/* rlwimi R10, R11, 16, 12, 15 */
		/* 82242B9Ch case   17:*/		cpu::op::rlwimi<0,16,12,15>(regs,&regs.R10,regs.R11);
		/* 82242B9Ch case   17:*/		return 0x82242BA0;
		  /* 82242BA0h */ case   18:  		/* stw R10, <#[R31]> */
		/* 82242BA0h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82242BA0h case   18:*/		return 0x82242BA4;
		  /* 82242BA4h */ case   19:  		/* lwz R3, <#[R26 + 2736]> */
		/* 82242BA4h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000AB0) );
		/* 82242BA4h case   19:*/		return 0x82242BA8;
		  /* 82242BA8h */ case   20:  		/* bl 137280 */
		/* 82242BA8h case   20:*/		regs.LR = 0x82242BAC; return 0x822643E8;
		/* 82242BA8h case   20:*/		return 0x82242BAC;
		  /* 82242BACh */ case   21:  		/* lwz R11, <#[R31]> */
		/* 82242BACh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82242BACh case   21:*/		return 0x82242BB0;
		  /* 82242BB0h */ case   22:  		/* addi R10, R3, 16 */
		/* 82242BB0h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x10);
		/* 82242BB0h case   22:*/		return 0x82242BB4;
		  /* 82242BB4h */ case   23:  		/* li R6, 3 */
		/* 82242BB4h case   23:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 82242BB4h case   23:*/		return 0x82242BB8;
		  /* 82242BB8h */ case   24:  		/* rlwimi R10, R11, 0, 0, 25 */
		/* 82242BB8h case   24:*/		cpu::op::rlwimi<0,0,0,25>(regs,&regs.R10,regs.R11);
		/* 82242BB8h case   24:*/		return 0x82242BBC;
		  /* 82242BBCh */ case   25:  		/* li R5, 2 */
		/* 82242BBCh case   25:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82242BBCh case   25:*/		return 0x82242BC0;
		  /* 82242BC0h */ case   26:  		/* stw R10, <#[R31]> */
		/* 82242BC0h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82242BC0h case   26:*/		return 0x82242BC4;
		  /* 82242BC4h */ case   27:  		/* mr R4, R31 */
		/* 82242BC4h case   27:*/		regs.R4 = regs.R31;
		/* 82242BC4h case   27:*/		return 0x82242BC8;
		  /* 82242BC8h */ case   28:  		/* mr R3, R30 */
		/* 82242BC8h case   28:*/		regs.R3 = regs.R30;
		/* 82242BC8h case   28:*/		return 0x82242BCC;
		  /* 82242BCCh */ case   29:  		/* bl -9660 */
		/* 82242BCCh case   29:*/		regs.LR = 0x82242BD0; return 0x82240610;
		/* 82242BCCh case   29:*/		return 0x82242BD0;
		  /* 82242BD0h */ case   30:  		/* lwz R11, <#[R29 + 240]> */
		/* 82242BD0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000F0) );
		/* 82242BD0h case   30:*/		return 0x82242BD4;
		  /* 82242BD4h */ case   31:  		/* lwz R10, <#[R31]> */
		/* 82242BD4h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82242BD4h case   31:*/		return 0x82242BD8;
		  /* 82242BD8h */ case   32:  		/* rlwimi R10, R11, 26, 0, 5 */
		/* 82242BD8h case   32:*/		cpu::op::rlwimi<0,26,0,5>(regs,&regs.R10,regs.R11);
		/* 82242BD8h case   32:*/		return 0x82242BDC;
		  /* 82242BDCh */ case   33:  		/* stw R10, <#[R31]> */
		/* 82242BDCh case   33:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82242BDCh case   33:*/		return 0x82242BE0;
		  /* 82242BE0h */ case   34:  		/* lwz R3, <#[R26 + 2736]> */
		/* 82242BE0h case   34:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000AB0) );
		/* 82242BE0h case   34:*/		return 0x82242BE4;
		  /* 82242BE4h */ case   35:  		/* lwz R4, <#[R30 + 240]> */
		/* 82242BE4h case   35:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000000F0) );
		/* 82242BE4h case   35:*/		return 0x82242BE8;
		  /* 82242BE8h */ case   36:  		/* bl 137216 */
		/* 82242BE8h case   36:*/		regs.LR = 0x82242BEC; return 0x822643E8;
		/* 82242BE8h case   36:*/		return 0x82242BEC;
		  /* 82242BECh */ case   37:  		/* cmpwi CR0, R3, 0 */
		/* 82242BECh case   37:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82242BECh case   37:*/		return 0x82242BF0;
		  /* 82242BF0h */ case   38:  		/* bc 12, CR0_LT, 68 */
		/* 82242BF0h case   38:*/		if ( regs.CR[0].lt ) { return 0x82242C34;  }
		/* 82242BF0h case   38:*/		return 0x82242BF4;
		  /* 82242BF4h */ case   39:  		/* lwz R10, <#[R30 + 136]> */
		/* 82242BF4h case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000088) );
		/* 82242BF4h case   39:*/		return 0x82242BF8;
		  /* 82242BF8h */ case   40:  		/* rlwinm R11, R10, 8, 24, 31 */
		/* 82242BF8h case   40:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R11,regs.R10);
		/* 82242BF8h case   40:*/		return 0x82242BFC;
		  /* 82242BFCh */ case   41:  		/* rlwimi R11, R10, 24, 16, 23 */
		/* 82242BFCh case   41:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R11,regs.R10);
		/* 82242BFCh case   41:*/		return 0x82242C00;
		  /* 82242C00h */ case   42:  		/* rlwimi R11, R10, 8, 8, 15 */
		/* 82242C00h case   42:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R11,regs.R10);
		/* 82242C00h case   42:*/		return 0x82242C04;
		  /* 82242C04h */ case   43:  		/* rlwimi R11, R10, 24, 0, 7 */
		/* 82242C04h case   43:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R11,regs.R10);
		/* 82242C04h case   43:*/		return 0x82242C08;
		  /* 82242C08h */ case   44:  		/* add R10, R11, R27 */
		/* 82242C08h case   44:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R27);
		/* 82242C08h case   44:*/		return 0x82242C0C;
		  /* 82242C0Ch */ case   45:  		/* addi R9, R11, -256 */
		/* 82242C0Ch case   45:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFF00);
		/* 82242C0Ch case   45:*/		return 0x82242C10;
		  /* 82242C10h */ case   46:  		/* rlwinm R10, R10, 14, 24, 25 */
		/* 82242C10h case   46:*/		cpu::op::rlwinm<0,14,24,25>(regs,&regs.R10,regs.R10);
		/* 82242C10h case   46:*/		return 0x82242C14;
		  /* 82242C14h */ case   47:  		/* rlwinm R9, R9, 26, 28, 29 */
		/* 82242C14h case   47:*/		cpu::op::rlwinm<0,26,28,29>(regs,&regs.R9,regs.R9);
		/* 82242C14h case   47:*/		return 0x82242C18;
		  /* 82242C18h */ case   48:  		/* subf R8, R28, R11 */
		/* 82242C18h case   48:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R28,regs.R11);
		/* 82242C18h case   48:*/		return 0x82242C1C;
		  /* 82242C1Ch */ case   49:  		/* or R10, R10, R9 */
		/* 82242C1Ch case   49:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242C1Ch case   49:*/		return 0x82242C20;
		  /* 82242C20h */ case   50:  		/* rlwinm R9, R8, 20, 26, 27 */
		/* 82242C20h case   50:*/		cpu::op::rlwinm<0,20,26,27>(regs,&regs.R9,regs.R8);
		/* 82242C20h case   50:*/		return 0x82242C24;
		  /* 82242C24h */ case   51:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82242C24h case   51:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82242C24h case   51:*/		return 0x82242C28;
		  /* 82242C28h */ case   52:  		/* or R10, R10, R9 */
		/* 82242C28h case   52:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242C28h case   52:*/		return 0x82242C2C;
		  /* 82242C2Ch */ case   53:  		/* or R11, R10, R11 */
		/* 82242C2Ch case   53:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82242C2Ch case   53:*/		return 0x82242C30;
		  /* 82242C30h */ case   54:  		/* stb R11, <#[R31 + 7]> */
		/* 82242C30h case   54:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000007) );
		/* 82242C30h case   54:*/		return 0x82242C34;
	}
	return 0x82242C34;
} // Block from 82242B58h-82242C34h (55 instructions)

//////////////////////////////////////////////////////
// Block at 82242C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242C34);
		  /* 82242C34h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82242C34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82242C34h case    0:*/		return 0x82242C38;
		  /* 82242C38h */ case    1:  		/* li R10, 8193 */
		/* 82242C38h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x2001);
		/* 82242C38h case    1:*/		return 0x82242C3C;
		  /* 82242C3Ch */ case    2:  		/* rlwimi R11, R10, 12, 18, 23 */
		/* 82242C3Ch case    2:*/		cpu::op::rlwimi<0,12,18,23>(regs,&regs.R11,regs.R10);
		/* 82242C3Ch case    2:*/		return 0x82242C40;
		  /* 82242C40h */ case    3:  		/* rlwimi R11, R10, 12, 8, 11 */
		/* 82242C40h case    3:*/		cpu::op::rlwimi<0,12,8,11>(regs,&regs.R11,regs.R10);
		/* 82242C40h case    3:*/		return 0x82242C44;
		  /* 82242C44h */ case    4:  		/* rlwimi R11, R10, 12, 6, 6 */
		/* 82242C44h case    4:*/		cpu::op::rlwimi<0,12,6,6>(regs,&regs.R11,regs.R10);
		/* 82242C44h case    4:*/		return 0x82242C48;
		  /* 82242C48h */ case    5:  		/* stw R11, <#[R31]> */
		/* 82242C48h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82242C48h case    5:*/		return 0x82242C4C;
		  /* 82242C4Ch */ case    6:  		/* lwz R11, <#[R30 + 52]> */
		/* 82242C4Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000034) );
		/* 82242C4Ch case    6:*/		return 0x82242C50;
		  /* 82242C50h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 82242C50h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82242C50h case    7:*/		return 0x82242C54;
		  /* 82242C54h */ case    8:  		/* bc 12, CR6_EQ, 196 */
		/* 82242C54h case    8:*/		if ( regs.CR[6].eq ) { return 0x82242D18;  }
		/* 82242C54h case    8:*/		return 0x82242C58;
		  /* 82242C58h */ case    9:  		/* cmpwi CR6, R11, 2 */
		/* 82242C58h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 82242C58h case    9:*/		return 0x82242C5C;
		  /* 82242C5Ch */ case   10:  		/* bc 12, CR6_EQ, 120 */
		/* 82242C5Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82242CD4;  }
		/* 82242C5Ch case   10:*/		return 0x82242C60;
		  /* 82242C60h */ case   11:  		/* cmpwi CR6, R11, 3 */
		/* 82242C60h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 82242C60h case   11:*/		return 0x82242C64;
		  /* 82242C64h */ case   12:  		/* bc 12, CR6_EQ, 44 */
		/* 82242C64h case   12:*/		if ( regs.CR[6].eq ) { return 0x82242C90;  }
		/* 82242C64h case   12:*/		return 0x82242C68;
		  /* 82242C68h */ case   13:  		/* lis R11, -32252 */
		/* 82242C68h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242C68h case   13:*/		return 0x82242C6C;
		  /* 82242C6Ch */ case   14:  		/* lis R10, -32255 */
		/* 82242C6Ch case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82242C6Ch case   14:*/		return 0x82242C70;
		  /* 82242C70h */ case   15:  		/* lis R9, -32253 */
		/* 82242C70h case   15:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82242C70h case   15:*/		return 0x82242C74;
		  /* 82242C74h */ case   16:  		/* addi R6, R11, 10344 */
		/* 82242C74h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2868);
		/* 82242C74h case   16:*/		return 0x82242C78;
	}
	return 0x82242C78;
} // Block from 82242C34h-82242C78h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82242C78h
// Function '?EmitCJmp@Assembler@XGRAPHICS@@QAAX_NH0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242C78);
		  /* 82242C78h */ case    0:  		/* addi R5, R10, 5216 */
		/* 82242C78h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 82242C78h case    0:*/		return 0x82242C7C;
		  /* 82242C7Ch */ case    1:  		/* addi R4, R9, 27460 */
		/* 82242C7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82242C7Ch case    1:*/		return 0x82242C80;
		  /* 82242C80h */ case    2:  		/* li R7, 2722 */
		/* 82242C80h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0xAA2);
		/* 82242C80h case    2:*/		return 0x82242C84;
		  /* 82242C84h */ case    3:  		/* li R3, 0 */
		/* 82242C84h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82242C84h case    3:*/		return 0x82242C88;
		  /* 82242C88h */ case    4:  		/* bl -962688 */
		/* 82242C88h case    4:*/		regs.LR = 0x82242C8C; return 0x82157C08;
		/* 82242C88h case    4:*/		return 0x82242C8C;
		  /* 82242C8Ch */ case    5:  		/* b 200 */
		/* 82242C8Ch case    5:*/		return 0x82242D54;
		/* 82242C8Ch case    5:*/		return 0x82242C90;
	}
	return 0x82242C90;
} // Block from 82242C78h-82242C90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82242C90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242C90);
		  /* 82242C90h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82242C90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82242C90h case    0:*/		return 0x82242C94;
		  /* 82242C94h */ case    1:  		/* rlwinm. R11, R11, 5, 30, 31 */
		/* 82242C94h case    1:*/		cpu::op::rlwinm<1,5,30,31>(regs,&regs.R11,regs.R11);
		/* 82242C94h case    1:*/		return 0x82242C98;
		  /* 82242C98h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 82242C98h case    2:*/		if ( regs.CR[0].eq ) { return 0x82242CC8;  }
		/* 82242C98h case    2:*/		return 0x82242C9C;
		  /* 82242C9Ch */ case    3:  		/* cmplwi CR6, R11, 3 */
		/* 82242C9Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82242C9Ch case    3:*/		return 0x82242CA0;
		  /* 82242CA0h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 82242CA0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82242CC8;  }
		/* 82242CA0h case    4:*/		return 0x82242CA4;
		  /* 82242CA4h */ case    5:  		/* lis R11, -32252 */
		/* 82242CA4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242CA4h case    5:*/		return 0x82242CA8;
		  /* 82242CA8h */ case    6:  		/* lis R10, -32252 */
		/* 82242CA8h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82242CA8h case    6:*/		return 0x82242CAC;
		  /* 82242CACh */ case    7:  		/* lis R9, -32253 */
		/* 82242CACh case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82242CACh case    7:*/		return 0x82242CB0;
		  /* 82242CB0h */ case    8:  		/* addi R6, R11, 10344 */
		/* 82242CB0h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2868);
		/* 82242CB0h case    8:*/		return 0x82242CB4;
		  /* 82242CB4h */ case    9:  		/* addi R5, R10, 12088 */
		/* 82242CB4h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x2F38);
		/* 82242CB4h case    9:*/		return 0x82242CB8;
		  /* 82242CB8h */ case   10:  		/* addi R4, R9, 27460 */
		/* 82242CB8h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82242CB8h case   10:*/		return 0x82242CBC;
		  /* 82242CBCh */ case   11:  		/* li R7, 2718 */
		/* 82242CBCh case   11:*/		cpu::op::li<0>(regs,&regs.R7,0xA9E);
		/* 82242CBCh case   11:*/		return 0x82242CC0;
		  /* 82242CC0h */ case   12:  		/* li R3, 0 */
		/* 82242CC0h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82242CC0h case   12:*/		return 0x82242CC4;
		  /* 82242CC4h */ case   13:  		/* bl -962748 */
		/* 82242CC4h case   13:*/		regs.LR = 0x82242CC8; return 0x82157C08;
		/* 82242CC4h case   13:*/		return 0x82242CC8;
	}
	return 0x82242CC8;
} // Block from 82242C90h-82242CC8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82242CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242CC8);
		  /* 82242CC8h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82242CC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82242CC8h case    0:*/		return 0x82242CCC;
		  /* 82242CCCh */ case    1:  		/* oris R11, R11, 6144 */
		/* 82242CCCh case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1800);
		/* 82242CCCh case    1:*/		return 0x82242CD0;
		  /* 82242CD0h */ case    2:  		/* b 128 */
		/* 82242CD0h case    2:*/		return 0x82242D50;
		/* 82242CD0h case    2:*/		return 0x82242CD4;
	}
	return 0x82242CD4;
} // Block from 82242CC8h-82242CD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82242CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242CD4);
		  /* 82242CD4h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82242CD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82242CD4h case    0:*/		return 0x82242CD8;
		  /* 82242CD8h */ case    1:  		/* rlwinm. R11, R11, 5, 30, 31 */
		/* 82242CD8h case    1:*/		cpu::op::rlwinm<1,5,30,31>(regs,&regs.R11,regs.R11);
		/* 82242CD8h case    1:*/		return 0x82242CDC;
		  /* 82242CDCh */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 82242CDCh case    2:*/		if ( regs.CR[0].eq ) { return 0x82242D0C;  }
		/* 82242CDCh case    2:*/		return 0x82242CE0;
		  /* 82242CE0h */ case    3:  		/* cmplwi CR6, R11, 2 */
		/* 82242CE0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82242CE0h case    3:*/		return 0x82242CE4;
		  /* 82242CE4h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 82242CE4h case    4:*/		if ( regs.CR[6].eq ) { return 0x82242D0C;  }
		/* 82242CE4h case    4:*/		return 0x82242CE8;
		  /* 82242CE8h */ case    5:  		/* lis R11, -32252 */
		/* 82242CE8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242CE8h case    5:*/		return 0x82242CEC;
		  /* 82242CECh */ case    6:  		/* lis R10, -32252 */
		/* 82242CECh case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82242CECh case    6:*/		return 0x82242CF0;
		  /* 82242CF0h */ case    7:  		/* lis R9, -32253 */
		/* 82242CF0h case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82242CF0h case    7:*/		return 0x82242CF4;
		  /* 82242CF4h */ case    8:  		/* addi R6, R11, 10344 */
		/* 82242CF4h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2868);
		/* 82242CF4h case    8:*/		return 0x82242CF8;
		  /* 82242CF8h */ case    9:  		/* addi R5, R10, 12048 */
		/* 82242CF8h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x2F10);
		/* 82242CF8h case    9:*/		return 0x82242CFC;
		  /* 82242CFCh */ case   10:  		/* addi R4, R9, 27460 */
		/* 82242CFCh case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82242CFCh case   10:*/		return 0x82242D00;
		  /* 82242D00h */ case   11:  		/* li R7, 2714 */
		/* 82242D00h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0xA9A);
		/* 82242D00h case   11:*/		return 0x82242D04;
		  /* 82242D04h */ case   12:  		/* li R3, 0 */
		/* 82242D04h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82242D04h case   12:*/		return 0x82242D08;
		  /* 82242D08h */ case   13:  		/* bl -962816 */
		/* 82242D08h case   13:*/		regs.LR = 0x82242D0C; return 0x82157C08;
		/* 82242D08h case   13:*/		return 0x82242D0C;
	}
	return 0x82242D0C;
} // Block from 82242CD4h-82242D0Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 82242D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242D0C);
		  /* 82242D0Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82242D0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82242D0Ch case    0:*/		return 0x82242D10;
		  /* 82242D10h */ case    1:  		/* rlwimi R11, R25, 28, 3, 4 */
		/* 82242D10h case    1:*/		cpu::op::rlwimi<0,28,3,4>(regs,&regs.R11,regs.R25);
		/* 82242D10h case    1:*/		return 0x82242D14;
		  /* 82242D14h */ case    2:  		/* b 60 */
		/* 82242D14h case    2:*/		return 0x82242D50;
		/* 82242D14h case    2:*/		return 0x82242D18;
	}
	return 0x82242D18;
} // Block from 82242D0Ch-82242D18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82242D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242D18);
		  /* 82242D18h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82242D18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82242D18h case    0:*/		return 0x82242D1C;
		  /* 82242D1Ch */ case    1:  		/* rlwinm. R11, R11, 0, 3, 4 */
		/* 82242D1Ch case    1:*/		cpu::op::rlwinm<1,0,3,4>(regs,&regs.R11,regs.R11);
		/* 82242D1Ch case    1:*/		return 0x82242D20;
		  /* 82242D20h */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 82242D20h case    2:*/		if ( regs.CR[0].eq ) { return 0x82242D48;  }
		/* 82242D20h case    2:*/		return 0x82242D24;
		  /* 82242D24h */ case    3:  		/* lis R11, -32252 */
		/* 82242D24h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242D24h case    3:*/		return 0x82242D28;
		  /* 82242D28h */ case    4:  		/* lis R10, -32252 */
		/* 82242D28h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82242D28h case    4:*/		return 0x82242D2C;
		  /* 82242D2Ch */ case    5:  		/* lis R9, -32253 */
		/* 82242D2Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82242D2Ch case    5:*/		return 0x82242D30;
		  /* 82242D30h */ case    6:  		/* addi R6, R11, 10344 */
		/* 82242D30h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2868);
		/* 82242D30h case    6:*/		return 0x82242D34;
		  /* 82242D34h */ case    7:  		/* addi R5, R10, 12028 */
		/* 82242D34h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x2EFC);
		/* 82242D34h case    7:*/		return 0x82242D38;
		  /* 82242D38h */ case    8:  		/* addi R4, R9, 27460 */
		/* 82242D38h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82242D38h case    8:*/		return 0x82242D3C;
		  /* 82242D3Ch */ case    9:  		/* li R7, 2710 */
		/* 82242D3Ch case    9:*/		cpu::op::li<0>(regs,&regs.R7,0xA96);
		/* 82242D3Ch case    9:*/		return 0x82242D40;
	}
	return 0x82242D40;
} // Block from 82242D18h-82242D40h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82242D40h
// Function '?EmitLoopStart@Assembler@XGRAPHICS@@QAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242D40);
		  /* 82242D40h */ case    0:  		/* li R3, 0 */
		/* 82242D40h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82242D40h case    0:*/		return 0x82242D44;
		  /* 82242D44h */ case    1:  		/* bl -962876 */
		/* 82242D44h case    1:*/		regs.LR = 0x82242D48; return 0x82157C08;
		/* 82242D44h case    1:*/		return 0x82242D48;
	}
	return 0x82242D48;
} // Block from 82242D40h-82242D48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82242D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242D48);
		  /* 82242D48h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82242D48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82242D48h case    0:*/		return 0x82242D4C;
		  /* 82242D4Ch */ case    1:  		/* rlwinm R11, R11, 0, 5, 2 */
		/* 82242D4Ch case    1:*/		cpu::op::rlwinm<0,0,5,2>(regs,&regs.R11,regs.R11);
		/* 82242D4Ch case    1:*/		return 0x82242D50;
	}
	return 0x82242D50;
} // Block from 82242D48h-82242D50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82242D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242D50);
		  /* 82242D50h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 82242D50h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82242D50h case    0:*/		return 0x82242D54;
	}
	return 0x82242D54;
} // Block from 82242D50h-82242D54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82242D54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242D54);
		  /* 82242D54h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82242D54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82242D54h case    0:*/		return 0x82242D58;
		  /* 82242D58h */ case    1:  		/* ori R11, R11, 32768 */
		/* 82242D58h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82242D58h case    1:*/		return 0x82242D5C;
		  /* 82242D5Ch */ case    2:  		/* stw R11, <#[R31]> */
		/* 82242D5Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82242D5Ch case    2:*/		return 0x82242D60;
		  /* 82242D60h */ case    3:  		/* addi R1, R1, 144 */
		/* 82242D60h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82242D60h case    3:*/		return 0x82242D64;
		  /* 82242D64h */ case    4:  		/* b -1776328 */
		/* 82242D64h case    4:*/		return 0x8209129C;
		/* 82242D64h case    4:*/		return 0x82242D68;
	}
	return 0x82242D68;
} // Block from 82242D54h-82242D68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82242D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242D68);
		  /* 82242D68h */ case    0:  		/* mfspr R12, LR */
		/* 82242D68h case    0:*/		regs.R12 = regs.LR;
		/* 82242D68h case    0:*/		return 0x82242D6C;
		  /* 82242D6Ch */ case    1:  		/* bl -1776408 */
		/* 82242D6Ch case    1:*/		regs.LR = 0x82242D70; return 0x82091254;
		/* 82242D6Ch case    1:*/		return 0x82242D70;
		  /* 82242D70h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82242D70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82242D70h case    2:*/		return 0x82242D74;
		  /* 82242D74h */ case    3:  		/* lwz R10, <#[R4 + 4]> */
		/* 82242D74h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 82242D74h case    3:*/		return 0x82242D78;
		  /* 82242D78h */ case    4:  		/* li R9, 12 */
		/* 82242D78h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 82242D78h case    4:*/		return 0x82242D7C;
		  /* 82242D7Ch */ case    5:  		/* lwz R11, <#[R4 + 52]> */
		/* 82242D7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000034) );
		/* 82242D7Ch case    5:*/		return 0x82242D80;
		  /* 82242D80h */ case    6:  		/* mr R31, R3 */
		/* 82242D80h case    6:*/		regs.R31 = regs.R3;
		/* 82242D80h case    6:*/		return 0x82242D84;
		  /* 82242D84h */ case    7:  		/* subf R10, R10, R5 */
		/* 82242D84h case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 82242D84h case    7:*/		return 0x82242D88;
		  /* 82242D88h */ case    8:  		/* mr R30, R5 */
		/* 82242D88h case    8:*/		regs.R30 = regs.R5;
		/* 82242D88h case    8:*/		return 0x82242D8C;
		  /* 82242D8Ch */ case    9:  		/* divw R10, R10, R9 */
		/* 82242D8Ch case    9:*/		cpu::op::divw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242D8Ch case    9:*/		return 0x82242D90;
		  /* 82242D90h */ case   10:  		/* mr R29, R6 */
		/* 82242D90h case   10:*/		regs.R29 = regs.R6;
		/* 82242D90h case   10:*/		return 0x82242D94;
		  /* 82242D94h */ case   11:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82242D94h case   11:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82242D94h case   11:*/		return 0x82242D98;
		  /* 82242D98h */ case   12:  		/* add R11, R10, R11 */
		/* 82242D98h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82242D98h case   12:*/		return 0x82242D9C;
		  /* 82242D9Ch */ case   13:  		/* lwz R10, <#[R11]> */
		/* 82242D9Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82242D9Ch case   13:*/		return 0x82242DA0;
		  /* 82242DA0h */ case   14:  		/* cmplwi CR6, R10, 0 */
		/* 82242DA0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82242DA0h case   14:*/		return 0x82242DA4;
		  /* 82242DA4h */ case   15:  		/* bc 4, CR6_EQ, 12 */
		/* 82242DA4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82242DB0;  }
		/* 82242DA4h case   15:*/		return 0x82242DA8;
		  /* 82242DA8h */ case   16:  		/* stw R3, <#[R11]> */
		/* 82242DA8h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 82242DA8h case   16:*/		return 0x82242DAC;
		  /* 82242DACh */ case   17:  		/* b 8 */
		/* 82242DACh case   17:*/		return 0x82242DB4;
		/* 82242DACh case   17:*/		return 0x82242DB0;
	}
	return 0x82242DB0;
} // Block from 82242D68h-82242DB0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82242DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242DB0);
		  /* 82242DB0h */ case    0:  		/* stw R31, <#[R11 + 4]> */
		/* 82242DB0h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 82242DB0h case    0:*/		return 0x82242DB4;
	}
	return 0x82242DB4;
} // Block from 82242DB0h-82242DB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82242DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242DB4);
		  /* 82242DB4h */ case    0:  		/* lwz R10, <#[R31 + 24]> */
		/* 82242DB4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82242DB4h case    0:*/		return 0x82242DB8;
		  /* 82242DB8h */ case    1:  		/* lis R9, -32216 */
		/* 82242DB8h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8228);
		/* 82242DB8h case    1:*/		return 0x82242DBC;
		  /* 82242DBCh */ case    2:  		/* lis R11, -32253 */
		/* 82242DBCh case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82242DBCh case    2:*/		return 0x82242DC0;
		  /* 82242DC0h */ case    3:  		/* addi R9, R9, 17992 */
		/* 82242DC0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4648);
		/* 82242DC0h case    3:*/		return 0x82242DC4;
		  /* 82242DC4h */ case    4:  		/* mulli R10, R10, 52 */
		/* 82242DC4h case    4:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x34);
		/* 82242DC4h case    4:*/		return 0x82242DC8;
		  /* 82242DC8h */ case    5:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82242DC8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82242DC8h case    5:*/		return 0x82242DCC;
		  /* 82242DCCh */ case    6:  		/* rlwinm. R9, R10, 30, 31, 31 */
		/* 82242DCCh case    6:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R9,regs.R10);
		/* 82242DCCh case    6:*/		return 0x82242DD0;
		  /* 82242DD0h */ case    7:  		/* lis R10, -32252 */
		/* 82242DD0h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82242DD0h case    7:*/		return 0x82242DD4;
		  /* 82242DD4h */ case    8:  		/* addi R28, R11, 27460 */
		/* 82242DD4h case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x6B44);
		/* 82242DD4h case    8:*/		return 0x82242DD8;
		  /* 82242DD8h */ case    9:  		/* addi R27, R10, 10344 */
		/* 82242DD8h case    9:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R10,0x2868);
		/* 82242DD8h case    9:*/		return 0x82242DDC;
		  /* 82242DDCh */ case   10:  		/* li R6, 1 */
		/* 82242DDCh case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82242DDCh case   10:*/		return 0x82242DE0;
		  /* 82242DE0h */ case   11:  		/* li R5, 1 */
		/* 82242DE0h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242DE0h case   11:*/		return 0x82242DE4;
		  /* 82242DE4h */ case   12:  		/* mr R4, R30 */
		/* 82242DE4h case   12:*/		regs.R4 = regs.R30;
		/* 82242DE4h case   12:*/		return 0x82242DE8;
		  /* 82242DE8h */ case   13:  		/* mr R3, R31 */
		/* 82242DE8h case   13:*/		regs.R3 = regs.R31;
		/* 82242DE8h case   13:*/		return 0x82242DEC;
		  /* 82242DECh */ case   14:  		/* bc 12, CR0_EQ, 168 */
		/* 82242DECh case   14:*/		if ( regs.CR[0].eq ) { return 0x82242E94;  }
		/* 82242DECh case   14:*/		return 0x82242DF0;
		  /* 82242DF0h */ case   15:  		/* bl -10208 */
		/* 82242DF0h case   15:*/		regs.LR = 0x82242DF4; return 0x82240610;
		/* 82242DF0h case   15:*/		return 0x82242DF4;
		  /* 82242DF4h */ case   16:  		/* lis R11, -32252 */
		/* 82242DF4h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242DF4h case   16:*/		return 0x82242DF8;
		  /* 82242DF8h */ case   17:  		/* lwz R10, <#[R30]> */
		/* 82242DF8h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82242DF8h case   17:*/		return 0x82242DFC;
		  /* 82242DFCh */ case   18:  		/* addi R11, R11, 25976 */
		/* 82242DFCh case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6578);
		/* 82242DFCh case   18:*/		return 0x82242E00;
		  /* 82242E00h */ case   19:  		/* lwz R11, <#[R11 + 240]> */
		/* 82242E00h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000F0) );
		/* 82242E00h case   19:*/		return 0x82242E04;
		  /* 82242E04h */ case   20:  		/* rlwimi R10, R11, 26, 0, 5 */
		/* 82242E04h case   20:*/		cpu::op::rlwimi<0,26,0,5>(regs,&regs.R10,regs.R11);
		/* 82242E04h case   20:*/		return 0x82242E08;
		  /* 82242E08h */ case   21:  		/* stw R10, <#[R30]> */
		/* 82242E08h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82242E08h case   21:*/		return 0x82242E0C;
		  /* 82242E0Ch */ case   22:  		/* lbz R11, <#[R31 + 132]> */
		/* 82242E0Ch case   22:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 82242E0Ch case   22:*/		return 0x82242E10;
		  /* 82242E10h */ case   23:  		/* lbz R10, <#[R31 + 133]> */
		/* 82242E10h case   23:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000085) );
		/* 82242E10h case   23:*/		return 0x82242E14;
		  /* 82242E14h */ case   24:  		/* cmplw CR6, R11, R10 */
		/* 82242E14h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82242E14h case   24:*/		return 0x82242E18;
		  /* 82242E18h */ case   25:  		/* bc 4, CR6_EQ, 28 */
		/* 82242E18h case   25:*/		if ( !regs.CR[6].eq ) { return 0x82242E34;  }
		/* 82242E18h case   25:*/		return 0x82242E1C;
		  /* 82242E1Ch */ case   26:  		/* lbz R10, <#[R31 + 134]> */
		/* 82242E1Ch case   26:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000086) );
		/* 82242E1Ch case   26:*/		return 0x82242E20;
	}
	return 0x82242E20;
} // Block from 82242DB4h-82242E20h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82242E20h
// Function '?EmitLoopEnd@Assembler@XGRAPHICS@@QAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242E20);
		  /* 82242E20h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 82242E20h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82242E20h case    0:*/		return 0x82242E24;
		  /* 82242E24h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82242E24h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82242E34;  }
		/* 82242E24h case    1:*/		return 0x82242E28;
		  /* 82242E28h */ case    2:  		/* lbz R10, <#[R31 + 135]> */
		/* 82242E28h case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000087) );
		/* 82242E28h case    2:*/		return 0x82242E2C;
		  /* 82242E2Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82242E2Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82242E2Ch case    3:*/		return 0x82242E30;
		  /* 82242E30h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 82242E30h case    4:*/		if ( regs.CR[6].eq ) { return 0x82242E50;  }
		/* 82242E30h case    4:*/		return 0x82242E34;
	}
	return 0x82242E34;
} // Block from 82242E20h-82242E34h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82242E34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242E34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242E34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242E34);
		  /* 82242E34h */ case    0:  		/* lis R11, -32252 */
		/* 82242E34h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242E34h case    0:*/		return 0x82242E38;
		  /* 82242E38h */ case    1:  		/* mr R6, R27 */
		/* 82242E38h case    1:*/		regs.R6 = regs.R27;
		/* 82242E38h case    1:*/		return 0x82242E3C;
		  /* 82242E3Ch */ case    2:  		/* addi R5, R11, 11832 */
		/* 82242E3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2E38);
		/* 82242E3Ch case    2:*/		return 0x82242E40;
		  /* 82242E40h */ case    3:  		/* mr R4, R28 */
		/* 82242E40h case    3:*/		regs.R4 = regs.R28;
		/* 82242E40h case    3:*/		return 0x82242E44;
		  /* 82242E44h */ case    4:  		/* li R7, 2755 */
		/* 82242E44h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0xAC3);
		/* 82242E44h case    4:*/		return 0x82242E48;
		  /* 82242E48h */ case    5:  		/* li R3, 0 */
		/* 82242E48h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82242E48h case    5:*/		return 0x82242E4C;
		  /* 82242E4Ch */ case    6:  		/* bl -963140 */
		/* 82242E4Ch case    6:*/		regs.LR = 0x82242E50; return 0x82157C08;
		/* 82242E4Ch case    6:*/		return 0x82242E50;
	}
	return 0x82242E50;
} // Block from 82242E34h-82242E50h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82242E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242E50);
		  /* 82242E50h */ case    0:  		/* lwz R10, <#[R31 + 132]> */
		/* 82242E50h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 82242E50h case    0:*/		return 0x82242E54;
		  /* 82242E54h */ case    1:  		/* rlwinm R11, R10, 8, 24, 31 */
		/* 82242E54h case    1:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R11,regs.R10);
		/* 82242E54h case    1:*/		return 0x82242E58;
		  /* 82242E58h */ case    2:  		/* rlwimi R11, R10, 24, 16, 23 */
		/* 82242E58h case    2:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R11,regs.R10);
		/* 82242E58h case    2:*/		return 0x82242E5C;
		  /* 82242E5Ch */ case    3:  		/* rlwimi R11, R10, 8, 8, 15 */
		/* 82242E5Ch case    3:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R11,regs.R10);
		/* 82242E5Ch case    3:*/		return 0x82242E60;
		  /* 82242E60h */ case    4:  		/* rlwimi R11, R10, 24, 0, 7 */
		/* 82242E60h case    4:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R11,regs.R10);
		/* 82242E60h case    4:*/		return 0x82242E64;
		  /* 82242E64h */ case    5:  		/* addis R10, R11, 256 */
		/* 82242E64h case    5:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R11,0x100);
		/* 82242E64h case    5:*/		return 0x82242E68;
		  /* 82242E68h */ case    6:  		/* addi R9, R11, -256 */
		/* 82242E68h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFF00);
		/* 82242E68h case    6:*/		return 0x82242E6C;
		  /* 82242E6Ch */ case    7:  		/* rlwinm R10, R10, 14, 24, 25 */
		/* 82242E6Ch case    7:*/		cpu::op::rlwinm<0,14,24,25>(regs,&regs.R10,regs.R10);
		/* 82242E6Ch case    7:*/		return 0x82242E70;
		  /* 82242E70h */ case    8:  		/* rlwinm R9, R9, 26, 28, 29 */
		/* 82242E70h case    8:*/		cpu::op::rlwinm<0,26,28,29>(regs,&regs.R9,regs.R9);
		/* 82242E70h case    8:*/		return 0x82242E74;
		  /* 82242E74h */ case    9:  		/* addis R8, R11, -2 */
		/* 82242E74h case    9:*/		cpu::op::addis<0>(regs,&regs.R8,regs.R11,0xFFFFFFFE);
		/* 82242E74h case    9:*/		return 0x82242E78;
		  /* 82242E78h */ case   10:  		/* or R10, R10, R9 */
		/* 82242E78h case   10:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242E78h case   10:*/		return 0x82242E7C;
		  /* 82242E7Ch */ case   11:  		/* rlwinm R9, R8, 20, 26, 27 */
		/* 82242E7Ch case   11:*/		cpu::op::rlwinm<0,20,26,27>(regs,&regs.R9,regs.R8);
		/* 82242E7Ch case   11:*/		return 0x82242E80;
		  /* 82242E80h */ case   12:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82242E80h case   12:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82242E80h case   12:*/		return 0x82242E84;
		  /* 82242E84h */ case   13:  		/* or R10, R10, R9 */
		/* 82242E84h case   13:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242E84h case   13:*/		return 0x82242E88;
		  /* 82242E88h */ case   14:  		/* or R11, R10, R11 */
		/* 82242E88h case   14:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82242E88h case   14:*/		return 0x82242E8C;
		  /* 82242E8Ch */ case   15:  		/* stb R11, <#[R30 + 7]> */
		/* 82242E8Ch case   15:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000007) );
		/* 82242E8Ch case   15:*/		return 0x82242E90;
		  /* 82242E90h */ case   16:  		/* b 144 */
		/* 82242E90h case   16:*/		return 0x82242F20;
		/* 82242E90h case   16:*/		return 0x82242E94;
	}
	return 0x82242E94;
} // Block from 82242E50h-82242E94h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82242E94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242E94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242E94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242E94);
		  /* 82242E94h */ case    0:  		/* bl -10372 */
		/* 82242E94h case    0:*/		regs.LR = 0x82242E98; return 0x82240610;
		/* 82242E94h case    0:*/		return 0x82242E98;
		  /* 82242E98h */ case    1:  		/* li R6, 2 */
		/* 82242E98h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 82242E98h case    1:*/		return 0x82242E9C;
		  /* 82242E9Ch */ case    2:  		/* li R5, 1 */
		/* 82242E9Ch case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82242E9Ch case    2:*/		return 0x82242EA0;
		  /* 82242EA0h */ case    3:  		/* mr R4, R30 */
		/* 82242EA0h case    3:*/		regs.R4 = regs.R30;
		/* 82242EA0h case    3:*/		return 0x82242EA4;
		  /* 82242EA4h */ case    4:  		/* mr R3, R31 */
		/* 82242EA4h case    4:*/		regs.R3 = regs.R31;
		/* 82242EA4h case    4:*/		return 0x82242EA8;
		  /* 82242EA8h */ case    5:  		/* bl -10392 */
		/* 82242EA8h case    5:*/		regs.LR = 0x82242EAC; return 0x82240610;
		/* 82242EA8h case    5:*/		return 0x82242EAC;
		  /* 82242EACh */ case    6:  		/* lis R11, -32252 */
		/* 82242EACh case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242EACh case    6:*/		return 0x82242EB0;
		  /* 82242EB0h */ case    7:  		/* lwz R10, <#[R30 + 8]> */
		/* 82242EB0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82242EB0h case    7:*/		return 0x82242EB4;
		  /* 82242EB4h */ case    8:  		/* addi R11, R11, 25976 */
		/* 82242EB4h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6578);
		/* 82242EB4h case    8:*/		return 0x82242EB8;
		  /* 82242EB8h */ case    9:  		/* lwz R11, <#[R11 + 92]> */
		/* 82242EB8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000005C) );
		/* 82242EB8h case    9:*/		return 0x82242EBC;
		  /* 82242EBCh */ case   10:  		/* rlwimi R10, R11, 24, 3, 7 */
		/* 82242EBCh case   10:*/		cpu::op::rlwimi<0,24,3,7>(regs,&regs.R10,regs.R11);
		/* 82242EBCh case   10:*/		return 0x82242EC0;
		  /* 82242EC0h */ case   11:  		/* stw R10, <#[R30 + 8]> */
		/* 82242EC0h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82242EC0h case   11:*/		return 0x82242EC4;
		  /* 82242EC4h */ case   12:  		/* lwz R3, <#[R29 + 2736]> */
		/* 82242EC4h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000AB0) );
		/* 82242EC4h case   12:*/		return 0x82242EC8;
		  /* 82242EC8h */ case   13:  		/* lwz R4, <#[R31 + 236]> */
		/* 82242EC8h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000000EC) );
		/* 82242EC8h case   13:*/		return 0x82242ECC;
		  /* 82242ECCh */ case   14:  		/* bl 136476 */
		/* 82242ECCh case   14:*/		regs.LR = 0x82242ED0; return 0x822643E8;
		/* 82242ECCh case   14:*/		return 0x82242ED0;
		  /* 82242ED0h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 82242ED0h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82242ED0h case   15:*/		return 0x82242ED4;
		  /* 82242ED4h */ case   16:  		/* bc 12, CR0_LT, 76 */
		/* 82242ED4h case   16:*/		if ( regs.CR[0].lt ) { return 0x82242F20;  }
		/* 82242ED4h case   16:*/		return 0x82242ED8;
		  /* 82242ED8h */ case   17:  		/* lwz R10, <#[R31 + 132]> */
		/* 82242ED8h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 82242ED8h case   17:*/		return 0x82242EDC;
		  /* 82242EDCh */ case   18:  		/* rlwinm R11, R10, 8, 24, 31 */
		/* 82242EDCh case   18:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R11,regs.R10);
		/* 82242EDCh case   18:*/		return 0x82242EE0;
		  /* 82242EE0h */ case   19:  		/* rlwimi R11, R10, 24, 16, 23 */
		/* 82242EE0h case   19:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R11,regs.R10);
		/* 82242EE0h case   19:*/		return 0x82242EE4;
		  /* 82242EE4h */ case   20:  		/* rlwimi R11, R10, 8, 8, 15 */
		/* 82242EE4h case   20:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R11,regs.R10);
		/* 82242EE4h case   20:*/		return 0x82242EE8;
		  /* 82242EE8h */ case   21:  		/* rlwimi R11, R10, 24, 0, 7 */
		/* 82242EE8h case   21:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R11,regs.R10);
		/* 82242EE8h case   21:*/		return 0x82242EEC;
		  /* 82242EECh */ case   22:  		/* addis R10, R11, 256 */
		/* 82242EECh case   22:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R11,0x100);
		/* 82242EECh case   22:*/		return 0x82242EF0;
		  /* 82242EF0h */ case   23:  		/* addi R9, R11, -256 */
		/* 82242EF0h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFF00);
		/* 82242EF0h case   23:*/		return 0x82242EF4;
		  /* 82242EF4h */ case   24:  		/* rlwinm R10, R10, 14, 24, 25 */
		/* 82242EF4h case   24:*/		cpu::op::rlwinm<0,14,24,25>(regs,&regs.R10,regs.R10);
		/* 82242EF4h case   24:*/		return 0x82242EF8;
		  /* 82242EF8h */ case   25:  		/* rlwinm R9, R9, 26, 28, 29 */
		/* 82242EF8h case   25:*/		cpu::op::rlwinm<0,26,28,29>(regs,&regs.R9,regs.R9);
		/* 82242EF8h case   25:*/		return 0x82242EFC;
		  /* 82242EFCh */ case   26:  		/* addis R8, R11, -2 */
		/* 82242EFCh case   26:*/		cpu::op::addis<0>(regs,&regs.R8,regs.R11,0xFFFFFFFE);
		/* 82242EFCh case   26:*/		return 0x82242F00;
		  /* 82242F00h */ case   27:  		/* or R10, R10, R9 */
		/* 82242F00h case   27:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242F00h case   27:*/		return 0x82242F04;
		  /* 82242F04h */ case   28:  		/* rlwinm R9, R8, 20, 26, 27 */
		/* 82242F04h case   28:*/		cpu::op::rlwinm<0,20,26,27>(regs,&regs.R9,regs.R8);
		/* 82242F04h case   28:*/		return 0x82242F08;
		  /* 82242F08h */ case   29:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82242F08h case   29:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82242F08h case   29:*/		return 0x82242F0C;
		  /* 82242F0Ch */ case   30:  		/* or R10, R10, R9 */
		/* 82242F0Ch case   30:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82242F0Ch case   30:*/		return 0x82242F10;
		  /* 82242F10h */ case   31:  		/* or R11, R10, R11 */
		/* 82242F10h case   31:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82242F10h case   31:*/		return 0x82242F14;
		  /* 82242F14h */ case   32:  		/* stb R11, <#[R30 + 5]> */
		/* 82242F14h case   32:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 82242F14h case   32:*/		return 0x82242F18;
		  /* 82242F18h */ case   33:  		/* lhz R11, <#[R30 + 4]> */
		/* 82242F18h case   33:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82242F18h case   33:*/		return 0x82242F1C;
		  /* 82242F1Ch */ case   34:  		/* stb R11, <#[R30 + 6]> */
		/* 82242F1Ch case   34:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000006) );
		/* 82242F1Ch case   34:*/		return 0x82242F20;
	}
	return 0x82242F20;
} // Block from 82242E94h-82242F20h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82242F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242F20);
		  /* 82242F20h */ case    0:  		/* mr R4, R30 */
		/* 82242F20h case    0:*/		regs.R4 = regs.R30;
		/* 82242F20h case    0:*/		return 0x82242F24;
		  /* 82242F24h */ case    1:  		/* mr R3, R31 */
		/* 82242F24h case    1:*/		regs.R3 = regs.R31;
		/* 82242F24h case    1:*/		return 0x82242F28;
		  /* 82242F28h */ case    2:  		/* bl -9120 */
		/* 82242F28h case    2:*/		regs.LR = 0x82242F2C; return 0x82240B88;
		/* 82242F28h case    2:*/		return 0x82242F2C;
		  /* 82242F2Ch */ case    3:  		/* lwz R11, <#[R31 + 52]> */
		/* 82242F2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 82242F2Ch case    3:*/		return 0x82242F30;
		  /* 82242F30h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 82242F30h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82242F30h case    4:*/		return 0x82242F34;
		  /* 82242F34h */ case    5:  		/* bc 12, CR6_EQ, 176 */
		/* 82242F34h case    5:*/		if ( regs.CR[6].eq ) { return 0x82242FE4;  }
		/* 82242F34h case    5:*/		return 0x82242F38;
		  /* 82242F38h */ case    6:  		/* cmpwi CR6, R11, 2 */
		/* 82242F38h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 82242F38h case    6:*/		return 0x82242F3C;
		  /* 82242F3Ch */ case    7:  		/* bc 12, CR6_EQ, 104 */
		/* 82242F3Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82242FA4;  }
		/* 82242F3Ch case    7:*/		return 0x82242F40;
		  /* 82242F40h */ case    8:  		/* cmpwi CR6, R11, 3 */
		/* 82242F40h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 82242F40h case    8:*/		return 0x82242F44;
		  /* 82242F44h */ case    9:  		/* bc 12, CR6_EQ, 36 */
		/* 82242F44h case    9:*/		if ( regs.CR[6].eq ) { return 0x82242F68;  }
		/* 82242F44h case    9:*/		return 0x82242F48;
		  /* 82242F48h */ case   10:  		/* lis R11, -32255 */
		/* 82242F48h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82242F48h case   10:*/		return 0x82242F4C;
		  /* 82242F4Ch */ case   11:  		/* mr R6, R27 */
		/* 82242F4Ch case   11:*/		regs.R6 = regs.R27;
		/* 82242F4Ch case   11:*/		return 0x82242F50;
		  /* 82242F50h */ case   12:  		/* addi R5, R11, 5216 */
		/* 82242F50h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1460);
		/* 82242F50h case   12:*/		return 0x82242F54;
		  /* 82242F54h */ case   13:  		/* mr R4, R28 */
		/* 82242F54h case   13:*/		regs.R4 = regs.R28;
		/* 82242F54h case   13:*/		return 0x82242F58;
	}
	return 0x82242F58;
} // Block from 82242F20h-82242F58h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82242F58h
// Function '?Assemble@IRAlu@XGRAPHICS@@UAAXPAVAssembler@2@PADPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242F58);
		  /* 82242F58h */ case    0:  		/* li R7, 2784 */
		/* 82242F58h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0xAE0);
		/* 82242F58h case    0:*/		return 0x82242F5C;
		  /* 82242F5Ch */ case    1:  		/* li R3, 0 */
		/* 82242F5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82242F5Ch case    1:*/		return 0x82242F60;
		  /* 82242F60h */ case    2:  		/* bl -963416 */
		/* 82242F60h case    2:*/		regs.LR = 0x82242F64; return 0x82157C08;
		/* 82242F60h case    2:*/		return 0x82242F64;
		  /* 82242F64h */ case    3:  		/* b 180 */
		/* 82242F64h case    3:*/		return 0x82243018;
		/* 82242F64h case    3:*/		return 0x82242F68;
	}
	return 0x82242F68;
} // Block from 82242F58h-82242F68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82242F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242F68);
		  /* 82242F68h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 82242F68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82242F68h case    0:*/		return 0x82242F6C;
		  /* 82242F6Ch */ case    1:  		/* rlwinm. R11, R11, 5, 30, 31 */
		/* 82242F6Ch case    1:*/		cpu::op::rlwinm<1,5,30,31>(regs,&regs.R11,regs.R11);
		/* 82242F6Ch case    1:*/		return 0x82242F70;
		  /* 82242F70h */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 82242F70h case    2:*/		if ( regs.CR[0].eq ) { return 0x82242F98;  }
		/* 82242F70h case    2:*/		return 0x82242F74;
		  /* 82242F74h */ case    3:  		/* cmplwi CR6, R11, 3 */
		/* 82242F74h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82242F74h case    3:*/		return 0x82242F78;
		  /* 82242F78h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 82242F78h case    4:*/		if ( regs.CR[6].eq ) { return 0x82242F98;  }
		/* 82242F78h case    4:*/		return 0x82242F7C;
		  /* 82242F7Ch */ case    5:  		/* lis R11, -32252 */
		/* 82242F7Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242F7Ch case    5:*/		return 0x82242F80;
		  /* 82242F80h */ case    6:  		/* mr R6, R27 */
		/* 82242F80h case    6:*/		regs.R6 = regs.R27;
		/* 82242F80h case    6:*/		return 0x82242F84;
		  /* 82242F84h */ case    7:  		/* addi R5, R11, 12088 */
		/* 82242F84h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2F38);
		/* 82242F84h case    7:*/		return 0x82242F88;
		  /* 82242F88h */ case    8:  		/* mr R4, R28 */
		/* 82242F88h case    8:*/		regs.R4 = regs.R28;
		/* 82242F88h case    8:*/		return 0x82242F8C;
		  /* 82242F8Ch */ case    9:  		/* li R7, 2780 */
		/* 82242F8Ch case    9:*/		cpu::op::li<0>(regs,&regs.R7,0xADC);
		/* 82242F8Ch case    9:*/		return 0x82242F90;
		  /* 82242F90h */ case   10:  		/* li R3, 0 */
		/* 82242F90h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82242F90h case   10:*/		return 0x82242F94;
		  /* 82242F94h */ case   11:  		/* bl -963468 */
		/* 82242F94h case   11:*/		regs.LR = 0x82242F98; return 0x82157C08;
		/* 82242F94h case   11:*/		return 0x82242F98;
	}
	return 0x82242F98;
} // Block from 82242F68h-82242F98h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82242F98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242F98);
		  /* 82242F98h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 82242F98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82242F98h case    0:*/		return 0x82242F9C;
		  /* 82242F9Ch */ case    1:  		/* oris R11, R11, 6144 */
		/* 82242F9Ch case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1800);
		/* 82242F9Ch case    1:*/		return 0x82242FA0;
		  /* 82242FA0h */ case    2:  		/* b 116 */
		/* 82242FA0h case    2:*/		return 0x82243014;
		/* 82242FA0h case    2:*/		return 0x82242FA4;
	}
	return 0x82242FA4;
} // Block from 82242F98h-82242FA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82242FA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242FA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242FA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242FA4);
		  /* 82242FA4h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 82242FA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82242FA4h case    0:*/		return 0x82242FA8;
		  /* 82242FA8h */ case    1:  		/* rlwinm. R11, R11, 5, 30, 31 */
		/* 82242FA8h case    1:*/		cpu::op::rlwinm<1,5,30,31>(regs,&regs.R11,regs.R11);
		/* 82242FA8h case    1:*/		return 0x82242FAC;
		  /* 82242FACh */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 82242FACh case    2:*/		if ( regs.CR[0].eq ) { return 0x82242FD4;  }
		/* 82242FACh case    2:*/		return 0x82242FB0;
		  /* 82242FB0h */ case    3:  		/* cmplwi CR6, R11, 2 */
		/* 82242FB0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82242FB0h case    3:*/		return 0x82242FB4;
		  /* 82242FB4h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 82242FB4h case    4:*/		if ( regs.CR[6].eq ) { return 0x82242FD4;  }
		/* 82242FB4h case    4:*/		return 0x82242FB8;
		  /* 82242FB8h */ case    5:  		/* lis R11, -32252 */
		/* 82242FB8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242FB8h case    5:*/		return 0x82242FBC;
		  /* 82242FBCh */ case    6:  		/* mr R6, R27 */
		/* 82242FBCh case    6:*/		regs.R6 = regs.R27;
		/* 82242FBCh case    6:*/		return 0x82242FC0;
		  /* 82242FC0h */ case    7:  		/* addi R5, R11, 12048 */
		/* 82242FC0h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2F10);
		/* 82242FC0h case    7:*/		return 0x82242FC4;
		  /* 82242FC4h */ case    8:  		/* mr R4, R28 */
		/* 82242FC4h case    8:*/		regs.R4 = regs.R28;
		/* 82242FC4h case    8:*/		return 0x82242FC8;
		  /* 82242FC8h */ case    9:  		/* li R7, 2776 */
		/* 82242FC8h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0xAD8);
		/* 82242FC8h case    9:*/		return 0x82242FCC;
		  /* 82242FCCh */ case   10:  		/* li R3, 0 */
		/* 82242FCCh case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82242FCCh case   10:*/		return 0x82242FD0;
		  /* 82242FD0h */ case   11:  		/* bl -963528 */
		/* 82242FD0h case   11:*/		regs.LR = 0x82242FD4; return 0x82157C08;
		/* 82242FD0h case   11:*/		return 0x82242FD4;
	}
	return 0x82242FD4;
} // Block from 82242FA4h-82242FD4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82242FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242FD4);
		  /* 82242FD4h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 82242FD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82242FD4h case    0:*/		return 0x82242FD8;
		  /* 82242FD8h */ case    1:  		/* li R10, 1 */
		/* 82242FD8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82242FD8h case    1:*/		return 0x82242FDC;
		  /* 82242FDCh */ case    2:  		/* rlwimi R11, R10, 28, 3, 4 */
		/* 82242FDCh case    2:*/		cpu::op::rlwimi<0,28,3,4>(regs,&regs.R11,regs.R10);
		/* 82242FDCh case    2:*/		return 0x82242FE0;
		  /* 82242FE0h */ case    3:  		/* b 52 */
		/* 82242FE0h case    3:*/		return 0x82243014;
		/* 82242FE0h case    3:*/		return 0x82242FE4;
	}
	return 0x82242FE4;
} // Block from 82242FD4h-82242FE4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82242FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82242FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82242FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82242FE4);
		  /* 82242FE4h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 82242FE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82242FE4h case    0:*/		return 0x82242FE8;
		  /* 82242FE8h */ case    1:  		/* rlwinm. R11, R11, 0, 3, 4 */
		/* 82242FE8h case    1:*/		cpu::op::rlwinm<1,0,3,4>(regs,&regs.R11,regs.R11);
		/* 82242FE8h case    1:*/		return 0x82242FEC;
		  /* 82242FECh */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 82242FECh case    2:*/		if ( regs.CR[0].eq ) { return 0x8224300C;  }
		/* 82242FECh case    2:*/		return 0x82242FF0;
		  /* 82242FF0h */ case    3:  		/* lis R11, -32252 */
		/* 82242FF0h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82242FF0h case    3:*/		return 0x82242FF4;
		  /* 82242FF4h */ case    4:  		/* mr R6, R27 */
		/* 82242FF4h case    4:*/		regs.R6 = regs.R27;
		/* 82242FF4h case    4:*/		return 0x82242FF8;
		  /* 82242FF8h */ case    5:  		/* addi R5, R11, 12028 */
		/* 82242FF8h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2EFC);
		/* 82242FF8h case    5:*/		return 0x82242FFC;
		  /* 82242FFCh */ case    6:  		/* mr R4, R28 */
		/* 82242FFCh case    6:*/		regs.R4 = regs.R28;
		/* 82242FFCh case    6:*/		return 0x82243000;
		  /* 82243000h */ case    7:  		/* li R7, 2772 */
		/* 82243000h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0xAD4);
		/* 82243000h case    7:*/		return 0x82243004;
		  /* 82243004h */ case    8:  		/* li R3, 0 */
		/* 82243004h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82243004h case    8:*/		return 0x82243008;
		  /* 82243008h */ case    9:  		/* bl -963584 */
		/* 82243008h case    9:*/		regs.LR = 0x8224300C; return 0x82157C08;
		/* 82243008h case    9:*/		return 0x8224300C;
	}
	return 0x8224300C;
} // Block from 82242FE4h-8224300Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224300Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224300C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224300C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224300C);
		  /* 8224300Ch */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 8224300Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8224300Ch case    0:*/		return 0x82243010;
		  /* 82243010h */ case    1:  		/* rlwinm R11, R11, 0, 5, 2 */
		/* 82243010h case    1:*/		cpu::op::rlwinm<0,0,5,2>(regs,&regs.R11,regs.R11);
		/* 82243010h case    1:*/		return 0x82243014;
	}
	return 0x82243014;
} // Block from 8224300Ch-82243014h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82243014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243014);
		  /* 82243014h */ case    0:  		/* stw R11, <#[R30 + 4]> */
		/* 82243014h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82243014h case    0:*/		return 0x82243018;
	}
	return 0x82243018;
} // Block from 82243014h-82243018h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82243018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243018);
		  /* 82243018h */ case    0:  		/* addi R1, R1, 128 */
		/* 82243018h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82243018h case    0:*/		return 0x8224301C;
		  /* 8224301Ch */ case    1:  		/* b -1777016 */
		/* 8224301Ch case    1:*/		return 0x820912A4;
		/* 8224301Ch case    1:*/		return 0x82243020;
	}
	return 0x82243020;
} // Block from 82243018h-82243020h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82243020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243020);
		  /* 82243020h */ case    0:  		/* mfspr R12, LR */
		/* 82243020h case    0:*/		regs.R12 = regs.LR;
		/* 82243020h case    0:*/		return 0x82243024;
		  /* 82243024h */ case    1:  		/* bl -1777104 */
		/* 82243024h case    1:*/		regs.LR = 0x82243028; return 0x82091254;
		/* 82243024h case    1:*/		return 0x82243028;
		  /* 82243028h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82243028h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82243028h case    2:*/		return 0x8224302C;
		  /* 8224302Ch */ case    3:  		/* lwz R30, <#[R3 + 172]> */
		/* 8224302Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x000000AC) );
		/* 8224302Ch case    3:*/		return 0x82243030;
		  /* 82243030h */ case    4:  		/* mr R31, R3 */
		/* 82243030h case    4:*/		regs.R31 = regs.R3;
		/* 82243030h case    4:*/		return 0x82243034;
		  /* 82243034h */ case    5:  		/* mr R28, R4 */
		/* 82243034h case    5:*/		regs.R28 = regs.R4;
		/* 82243034h case    5:*/		return 0x82243038;
		  /* 82243038h */ case    6:  		/* mr R27, R5 */
		/* 82243038h case    6:*/		regs.R27 = regs.R5;
		/* 82243038h case    6:*/		return 0x8224303C;
		  /* 8224303Ch */ case    7:  		/* mr R29, R6 */
		/* 8224303Ch case    7:*/		regs.R29 = regs.R6;
		/* 8224303Ch case    7:*/		return 0x82243040;
		  /* 82243040h */ case    8:  		/* cmplwi CR6, R30, 0 */
		/* 82243040h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82243040h case    8:*/		return 0x82243044;
		  /* 82243044h */ case    9:  		/* bc 12, CR6_EQ, 96 */
		/* 82243044h case    9:*/		if ( regs.CR[6].eq ) { return 0x822430A4;  }
		/* 82243044h case    9:*/		return 0x82243048;
		  /* 82243048h */ case   10:  		/* lwz R11, <#[R30 + 228]> */
		/* 82243048h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 82243048h case   10:*/		return 0x8224304C;
		  /* 8224304Ch */ case   11:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224304Ch case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224304Ch case   11:*/		return 0x82243050;
		  /* 82243050h */ case   12:  		/* bc 12, CR0_EQ, 84 */
		/* 82243050h case   12:*/		if ( regs.CR[0].eq ) { return 0x822430A4;  }
		/* 82243050h case   12:*/		return 0x82243054;
		  /* 82243054h */ case   13:  		/* lwz R11, <#[R30 + 80]> */
		/* 82243054h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000050) );
		/* 82243054h case   13:*/		return 0x82243058;
		  /* 82243058h */ case   14:  		/* lwz R10, <#[R3 + 228]> */
		/* 82243058h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000000E4) );
		/* 82243058h case   14:*/		return 0x8224305C;
		  /* 8224305Ch */ case   15:  		/* rlwinm. R10, R10, 25, 31, 31 */
		/* 8224305Ch case   15:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R10,regs.R10);
		/* 8224305Ch case   15:*/		return 0x82243060;
		  /* 82243060h */ case   16:  		/* stw R11, <#[R3 + 80]> */
		/* 82243060h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 82243060h case   16:*/		return 0x82243064;
		  /* 82243064h */ case   17:  		/* bc 12, CR0_EQ, 40 */
		/* 82243064h case   17:*/		if ( regs.CR[0].eq ) { return 0x8224308C;  }
		/* 82243064h case   17:*/		return 0x82243068;
		  /* 82243068h */ case   18:  		/* lis R11, -32252 */
		/* 82243068h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243068h case   18:*/		return 0x8224306C;
		  /* 8224306Ch */ case   19:  		/* lis R10, -32252 */
		/* 8224306Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224306Ch case   19:*/		return 0x82243070;
		  /* 82243070h */ case   20:  		/* lis R9, -32253 */
		/* 82243070h case   20:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82243070h case   20:*/		return 0x82243074;
		  /* 82243074h */ case   21:  		/* addi R6, R11, 10344 */
		/* 82243074h case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2868);
		/* 82243074h case   21:*/		return 0x82243078;
		  /* 82243078h */ case   22:  		/* addi R5, R10, 12128 */
		/* 82243078h case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x2F60);
		/* 82243078h case   22:*/		return 0x8224307C;
		  /* 8224307Ch */ case   23:  		/* addi R4, R9, 27460 */
		/* 8224307Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8224307Ch case   23:*/		return 0x82243080;
		  /* 82243080h */ case   24:  		/* li R7, 2813 */
		/* 82243080h case   24:*/		cpu::op::li<0>(regs,&regs.R7,0xAFD);
		/* 82243080h case   24:*/		return 0x82243084;
		  /* 82243084h */ case   25:  		/* li R3, 0 */
		/* 82243084h case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82243084h case   25:*/		return 0x82243088;
		  /* 82243088h */ case   26:  		/* bl -963712 */
		/* 82243088h case   26:*/		regs.LR = 0x8224308C; return 0x82157C08;
		/* 82243088h case   26:*/		return 0x8224308C;
	}
	return 0x8224308C;
} // Block from 82243020h-8224308Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8224308Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224308C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224308C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224308C);
		  /* 8224308Ch */ case    0:  		/* mr R4, R30 */
		/* 8224308Ch case    0:*/		regs.R4 = regs.R30;
		/* 8224308Ch case    0:*/		return 0x82243090;
		  /* 82243090h */ case    1:  		/* lwz R3, <#[R29 + 2736]> */
		/* 82243090h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000AB0) );
		/* 82243090h case    1:*/		return 0x82243094;
		  /* 82243094h */ case    2:  		/* bl 136020 */
		/* 82243094h case    2:*/		regs.LR = 0x82243098; return 0x822643E8;
		/* 82243094h case    2:*/		return 0x82243098;
		  /* 82243098h */ case    3:  		/* stw R3, <#[R31 + 56]> */
		/* 82243098h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 82243098h case    3:*/		return 0x8224309C;
		  /* 8224309Ch */ case    4:  		/* lwz R11, <#[R30 + 128]> */
		/* 8224309Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8224309Ch case    4:*/		return 0x822430A0;
		  /* 822430A0h */ case    5:  		/* b 24 */
		/* 822430A0h case    5:*/		return 0x822430B8;
		/* 822430A0h case    5:*/		return 0x822430A4;
	}
	return 0x822430A4;
} // Block from 8224308Ch-822430A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822430A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822430A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822430A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822430A4);
		  /* 822430A4h */ case    0:  		/* lis R10, -32252 */
		/* 822430A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822430A4h case    0:*/		return 0x822430A8;
		  /* 822430A8h */ case    1:  		/* li R11, 0 */
		/* 822430A8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822430A8h case    1:*/		return 0x822430AC;
		  /* 822430ACh */ case    2:  		/* stw R11, <#[R31 + 80]> */
		/* 822430ACh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 822430ACh case    2:*/		return 0x822430B0;
		  /* 822430B0h */ case    3:  		/* stw R11, <#[R31 + 56]> */
		/* 822430B0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 822430B0h case    3:*/		return 0x822430B4;
		  /* 822430B4h */ case    4:  		/* lwz R11, <#[R10 + 9920]> */
		/* 822430B4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000026C0) );
		/* 822430B4h case    4:*/		return 0x822430B8;
	}
	return 0x822430B8;
} // Block from 822430A4h-822430B8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822430B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822430B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822430B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822430B8);
		  /* 822430B8h */ case    0:  		/* stw R11, <#[R31 + 128]> */
		/* 822430B8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 822430B8h case    0:*/		return 0x822430BC;
		  /* 822430BCh */ case    1:  		/* mr R6, R29 */
		/* 822430BCh case    1:*/		regs.R6 = regs.R29;
		/* 822430BCh case    1:*/		return 0x822430C0;
		  /* 822430C0h */ case    2:  		/* mr R5, R27 */
		/* 822430C0h case    2:*/		regs.R5 = regs.R27;
		/* 822430C0h case    2:*/		return 0x822430C4;
		  /* 822430C4h */ case    3:  		/* mr R4, R28 */
		/* 822430C4h case    3:*/		regs.R4 = regs.R28;
		/* 822430C4h case    3:*/		return 0x822430C8;
		  /* 822430C8h */ case    4:  		/* mr R3, R31 */
		/* 822430C8h case    4:*/		regs.R3 = regs.R31;
		/* 822430C8h case    4:*/		return 0x822430CC;
		  /* 822430CCh */ case    5:  		/* bl -3292 */
		/* 822430CCh case    5:*/		regs.LR = 0x822430D0; return 0x822423F0;
		/* 822430CCh case    5:*/		return 0x822430D0;
		  /* 822430D0h */ case    6:  		/* addi R1, R1, 128 */
		/* 822430D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822430D0h case    6:*/		return 0x822430D4;
		  /* 822430D4h */ case    7:  		/* b -1777200 */
		/* 822430D4h case    7:*/		return 0x820912A4;
		/* 822430D4h case    7:*/		return 0x822430D8;
	}
	return 0x822430D8;
} // Block from 822430B8h-822430D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822430D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822430D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822430D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822430D8);
		  /* 822430D8h */ case    0:  		/* lwz R11, <#[R3 + 168]> */
		/* 822430D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000A8) );
		/* 822430D8h case    0:*/		return 0x822430DC;
		  /* 822430DCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 822430DCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822430DCh case    1:*/		return 0x822430E0;
		  /* 822430E0h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 822430E0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82243108;  }
		/* 822430E0h case    2:*/		return 0x822430E4;
		  /* 822430E4h */ case    3:  		/* lwz R10, <#[R11 + 228]> */
		/* 822430E4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 822430E4h case    3:*/		return 0x822430E8;
		  /* 822430E8h */ case    4:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 822430E8h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 822430E8h case    4:*/		return 0x822430EC;
		  /* 822430ECh */ case    5:  		/* bc 12, CR0_EQ, 28 */
		/* 822430ECh case    5:*/		if ( regs.CR[0].eq ) { return 0x82243108;  }
		/* 822430ECh case    5:*/		return 0x822430F0;
		  /* 822430F0h */ case    6:  		/* lwz R10, <#[R11 + 80]> */
		/* 822430F0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 822430F0h case    6:*/		return 0x822430F4;
		  /* 822430F4h */ case    7:  		/* stw R10, <#[R3 + 80]> */
		/* 822430F4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000050) );
		/* 822430F4h case    7:*/		return 0x822430F8;
		  /* 822430F8h */ case    8:  		/* lwz R10, <#[R11 + 56]> */
		/* 822430F8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 822430F8h case    8:*/		return 0x822430FC;
		  /* 822430FCh */ case    9:  		/* stw R10, <#[R3 + 56]> */
		/* 822430FCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000038) );
		/* 822430FCh case    9:*/		return 0x82243100;
		  /* 82243100h */ case   10:  		/* lwz R11, <#[R11 + 128]> */
		/* 82243100h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000080) );
		/* 82243100h case   10:*/		return 0x82243104;
		  /* 82243104h */ case   11:  		/* b 24 */
		/* 82243104h case   11:*/		return 0x8224311C;
		/* 82243104h case   11:*/		return 0x82243108;
	}
	return 0x82243108;
} // Block from 822430D8h-82243108h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82243108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243108);
		  /* 82243108h */ case    0:  		/* lis R10, -32252 */
		/* 82243108h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82243108h case    0:*/		return 0x8224310C;
		  /* 8224310Ch */ case    1:  		/* li R11, 0 */
		/* 8224310Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224310Ch case    1:*/		return 0x82243110;
		  /* 82243110h */ case    2:  		/* stw R11, <#[R3 + 56]> */
		/* 82243110h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 82243110h case    2:*/		return 0x82243114;
		  /* 82243114h */ case    3:  		/* stw R11, <#[R3 + 80]> */
		/* 82243114h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 82243114h case    3:*/		return 0x82243118;
		  /* 82243118h */ case    4:  		/* lwz R11, <#[R10 + 9920]> */
		/* 82243118h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000026C0) );
		/* 82243118h case    4:*/		return 0x8224311C;
	}
	return 0x8224311C;
} // Block from 82243108h-8224311Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224311Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224311C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224311C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224311C);
		  /* 8224311Ch */ case    0:  		/* stw R11, <#[R3 + 128]> */
		/* 8224311Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 8224311Ch case    0:*/		return 0x82243120;
		  /* 82243120h */ case    1:  		/* b -3376 */
		/* 82243120h case    1:*/		return 0x822423F0;
		/* 82243120h case    1:*/		return 0x82243124;
		  /* 82243124h */ case    2:  		/* nop */
		/* 82243124h case    2:*/		cpu::op::nop();
		/* 82243124h case    2:*/		return 0x82243128;
	}
	return 0x82243128;
} // Block from 8224311Ch-82243128h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82243128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243128);
		  /* 82243128h */ case    0:  		/* mfspr R12, LR */
		/* 82243128h case    0:*/		regs.R12 = regs.LR;
		/* 82243128h case    0:*/		return 0x8224312C;
		  /* 8224312Ch */ case    1:  		/* bl -1777372 */
		/* 8224312Ch case    1:*/		regs.LR = 0x82243130; return 0x82091250;
		/* 8224312Ch case    1:*/		return 0x82243130;
		  /* 82243130h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82243130h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82243130h case    2:*/		return 0x82243134;
		  /* 82243134h */ case    3:  		/* lwz R11, <#[R3 + 92]> */
		/* 82243134h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000005C) );
		/* 82243134h case    3:*/		return 0x82243138;
		  /* 82243138h */ case    4:  		/* mr R31, R3 */
		/* 82243138h case    4:*/		regs.R31 = regs.R3;
		/* 82243138h case    4:*/		return 0x8224313C;
		  /* 8224313Ch */ case    5:  		/* mr R29, R4 */
		/* 8224313Ch case    5:*/		regs.R29 = regs.R4;
		/* 8224313Ch case    5:*/		return 0x82243140;
		  /* 82243140h */ case    6:  		/* mr R28, R5 */
		/* 82243140h case    6:*/		regs.R28 = regs.R5;
		/* 82243140h case    6:*/		return 0x82243144;
		  /* 82243144h */ case    7:  		/* mr R27, R6 */
		/* 82243144h case    7:*/		regs.R27 = regs.R6;
		/* 82243144h case    7:*/		return 0x82243148;
		  /* 82243148h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82243148h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82243148h case    8:*/		return 0x8224314C;
		  /* 8224314Ch */ case    9:  		/* bc 4, CR6_EQ, 64 */
		/* 8224314Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8224318C;  }
		/* 8224314Ch case    9:*/		return 0x82243150;
		  /* 82243150h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 82243150h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82243150h case   10:*/		return 0x82243154;
		  /* 82243154h */ case   11:  		/* li R4, 20 */
		/* 82243154h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82243154h case   11:*/		return 0x82243158;
		  /* 82243158h */ case   12:  		/* lwz R26, <#[R11 + 1456]> */
		/* 82243158h case   12:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x000005B0) );
		/* 82243158h case   12:*/		return 0x8224315C;
		  /* 8224315Ch */ case   13:  		/* mr R3, R26 */
		/* 8224315Ch case   13:*/		regs.R3 = regs.R26;
		/* 8224315Ch case   13:*/		return 0x82243160;
		  /* 82243160h */ case   14:  		/* bl -158888 */
		/* 82243160h case   14:*/		regs.LR = 0x82243164; return 0x8221C4B8;
		/* 82243160h case   14:*/		return 0x82243164;
		  /* 82243164h */ case   15:  		/* addic. R30, R3, 4 */
		/* 82243164h case   15:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 82243164h case   15:*/		return 0x82243168;
		  /* 82243168h */ case   16:  		/* stw R26, <#[R3]> */
		/* 82243168h case   16:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000000) );
		/* 82243168h case   16:*/		return 0x8224316C;
		  /* 8224316Ch */ case   17:  		/* bc 12, CR0_EQ, 24 */
		/* 8224316Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x82243184;  }
		/* 8224316Ch case   17:*/		return 0x82243170;
		  /* 82243170h */ case   18:  		/* lwz R11, <#[R31]> */
		/* 82243170h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82243170h case   18:*/		return 0x82243174;
		  /* 82243174h */ case   19:  		/* mr R3, R30 */
		/* 82243174h case   19:*/		regs.R3 = regs.R30;
		/* 82243174h case   19:*/		return 0x82243178;
		  /* 82243178h */ case   20:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82243178h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82243178h case   20:*/		return 0x8224317C;
		  /* 8224317Ch */ case   21:  		/* bl -54300 */
		/* 8224317Ch case   21:*/		regs.LR = 0x82243180; return 0x82235D60;
		/* 8224317Ch case   21:*/		return 0x82243180;
		  /* 82243180h */ case   22:  		/* b 8 */
		/* 82243180h case   22:*/		return 0x82243188;
		/* 82243180h case   22:*/		return 0x82243184;
	}
	return 0x82243184;
} // Block from 82243128h-82243184h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82243184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243184);
		  /* 82243184h */ case    0:  		/* li R30, 0 */
		/* 82243184h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82243184h case    0:*/		return 0x82243188;
	}
	return 0x82243188;
} // Block from 82243184h-82243188h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82243188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243188);
		  /* 82243188h */ case    0:  		/* stw R30, <#[R31 + 92]> */
		/* 82243188h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000005C) );
		/* 82243188h case    0:*/		return 0x8224318C;
	}
	return 0x8224318C;
} // Block from 82243188h-8224318Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224318Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224318C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224318C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224318C);
		  /* 8224318Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8224318Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224318Ch case    0:*/		return 0x82243190;
		  /* 82243190h */ case    1:  		/* li R4, 20 */
		/* 82243190h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82243190h case    1:*/		return 0x82243194;
		  /* 82243194h */ case    2:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82243194h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82243194h case    2:*/		return 0x82243198;
		  /* 82243198h */ case    3:  		/* mr R3, R30 */
		/* 82243198h case    3:*/		regs.R3 = regs.R30;
		/* 82243198h case    3:*/		return 0x8224319C;
		  /* 8224319Ch */ case    4:  		/* bl -158948 */
		/* 8224319Ch case    4:*/		regs.LR = 0x822431A0; return 0x8221C4B8;
		/* 8224319Ch case    4:*/		return 0x822431A0;
		  /* 822431A0h */ case    5:  		/* addic. R11, R3, 4 */
		/* 822431A0h case    5:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 822431A0h case    5:*/		return 0x822431A4;
		  /* 822431A4h */ case    6:  		/* stw R30, <#[R3]> */
		/* 822431A4h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 822431A4h case    6:*/		return 0x822431A8;
		  /* 822431A8h */ case    7:  		/* bc 12, CR0_EQ, 44 */
		/* 822431A8h case    7:*/		if ( regs.CR[0].eq ) { return 0x822431D4;  }
		/* 822431A8h case    7:*/		return 0x822431AC;
		  /* 822431ACh */ case    8:  		/* lwz R10, <#[R31 + 4]> */
		/* 822431ACh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 822431ACh case    8:*/		return 0x822431B0;
		  /* 822431B0h */ case    9:  		/* lis R9, -32252 */
		/* 822431B0h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 822431B0h case    9:*/		return 0x822431B4;
		  /* 822431B4h */ case   10:  		/* stw R29, <#[R11 + 4]> */
		/* 822431B4h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 822431B4h case   10:*/		return 0x822431B8;
		  /* 822431B8h */ case   11:  		/* mr R30, R11 */
		/* 822431B8h case   11:*/		regs.R30 = regs.R11;
		/* 822431B8h case   11:*/		return 0x822431BC;
		  /* 822431BCh */ case   12:  		/* addi R9, R9, 11412 */
		/* 822431BCh case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2C94);
		/* 822431BCh case   12:*/		return 0x822431C0;
		  /* 822431C0h */ case   13:  		/* stw R27, <#[R11 + 12]> */
		/* 822431C0h case   13:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x0000000C) );
		/* 822431C0h case   13:*/		return 0x822431C4;
		  /* 822431C4h */ case   14:  		/* subf R10, R10, R28 */
		/* 822431C4h case   14:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R28);
		/* 822431C4h case   14:*/		return 0x822431C8;
		  /* 822431C8h */ case   15:  		/* stw R9, <#[R11]> */
		/* 822431C8h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822431C8h case   15:*/		return 0x822431CC;
		  /* 822431CCh */ case   16:  		/* stw R10, <#[R11 + 8]> */
		/* 822431CCh case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 822431CCh case   16:*/		return 0x822431D0;
		  /* 822431D0h */ case   17:  		/* b 8 */
		/* 822431D0h case   17:*/		return 0x822431D8;
		/* 822431D0h case   17:*/		return 0x822431D4;
	}
	return 0x822431D4;
} // Block from 8224318Ch-822431D4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 822431D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822431D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822431D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822431D4);
		  /* 822431D4h */ case    0:  		/* li R30, 0 */
		/* 822431D4h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822431D4h case    0:*/		return 0x822431D8;
	}
	return 0x822431D8;
} // Block from 822431D4h-822431D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822431D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822431D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822431D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822431D8);
		  /* 822431D8h */ case    0:  		/* lwz R3, <#[R31 + 92]> */
		/* 822431D8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000005C) );
		/* 822431D8h case    0:*/		return 0x822431DC;
		  /* 822431DCh */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 822431DCh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 822431DCh case    1:*/		return 0x822431E0;
		  /* 822431E0h */ case    2:  		/* bl 67808 */
		/* 822431E0h case    2:*/		regs.LR = 0x822431E4; return 0x82253AC0;
		/* 822431E0h case    2:*/		return 0x822431E4;
		  /* 822431E4h */ case    3:  		/* stw R30, <#[R3]> */
		/* 822431E4h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 822431E4h case    3:*/		return 0x822431E8;
		  /* 822431E8h */ case    4:  		/* addi R1, R1, 144 */
		/* 822431E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 822431E8h case    4:*/		return 0x822431EC;
		  /* 822431ECh */ case    5:  		/* b -1777484 */
		/* 822431ECh case    5:*/		return 0x820912A0;
		/* 822431ECh case    5:*/		return 0x822431F0;
	}
	return 0x822431F0;
} // Block from 822431D8h-822431F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822431F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822431F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822431F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822431F0);
		  /* 822431F0h */ case    0:  		/* mfspr R12, LR */
		/* 822431F0h case    0:*/		regs.R12 = regs.LR;
		/* 822431F0h case    0:*/		return 0x822431F4;
		  /* 822431F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822431F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822431F4h case    1:*/		return 0x822431F8;
		  /* 822431F8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822431F8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822431F8h case    2:*/		return 0x822431FC;
		  /* 822431FCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822431FCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822431FCh case    3:*/		return 0x82243200;
		  /* 82243200h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82243200h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82243200h case    4:*/		return 0x82243204;
		  /* 82243204h */ case    5:  		/* mr R31, R3 */
		/* 82243204h case    5:*/		regs.R31 = regs.R3;
		/* 82243204h case    5:*/		return 0x82243208;
		  /* 82243208h */ case    6:  		/* lwz R3, <#[R3 + 120]> */
		/* 82243208h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000078) );
		/* 82243208h case    6:*/		return 0x8224320C;
		  /* 8224320Ch */ case    7:  		/* mr R30, R4 */
		/* 8224320Ch case    7:*/		regs.R30 = regs.R4;
		/* 8224320Ch case    7:*/		return 0x82243210;
		  /* 82243210h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 82243210h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82243210h case    8:*/		return 0x82243214;
		  /* 82243214h */ case    9:  		/* bc 12, CR6_EQ, 8 */
		/* 82243214h case    9:*/		if ( regs.CR[6].eq ) { return 0x8224321C;  }
		/* 82243214h case    9:*/		return 0x82243218;
		  /* 82243218h */ case   10:  		/* bl 67056 */
		/* 82243218h case   10:*/		regs.LR = 0x8224321C; return 0x82253808;
		/* 82243218h case   10:*/		return 0x8224321C;
	}
	return 0x8224321C;
} // Block from 822431F0h-8224321Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224321Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224321C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224321C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224321C);
		  /* 8224321Ch */ case    0:  		/* addi R4, R31, 20 */
		/* 8224321Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x14);
		/* 8224321Ch case    0:*/		return 0x82243220;
		  /* 82243220h */ case    1:  		/* lbz R5, <#[R31 + 124]> */
		/* 82243220h case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000007C) );
		/* 82243220h case    1:*/		return 0x82243224;
		  /* 82243224h */ case    2:  		/* mr R3, R30 */
		/* 82243224h case    2:*/		regs.R3 = regs.R30;
		/* 82243224h case    2:*/		return 0x82243228;
		  /* 82243228h */ case    3:  		/* bl -6520 */
		/* 82243228h case    3:*/		regs.LR = 0x8224322C; return 0x822418B0;
		/* 82243228h case    3:*/		return 0x8224322C;
		  /* 8224322Ch */ case    4:  		/* lwz R11, <#[R31 + 120]> */
		/* 8224322Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000078) );
		/* 8224322Ch case    4:*/		return 0x82243230;
		  /* 82243230h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82243230h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82243230h case    5:*/		return 0x82243234;
		  /* 82243234h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 82243234h case    6:*/		if ( regs.CR[6].eq ) { return 0x8224324C;  }
		/* 82243234h case    6:*/		return 0x82243238;
		  /* 82243238h */ case    7:  		/* li R6, 0 */
		/* 82243238h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82243238h case    7:*/		return 0x8224323C;
		  /* 8224323Ch */ case    8:  		/* lbz R4, <#[R11 + 168]> */
		/* 8224323Ch case    8:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R11 + 0x000000A8) );
		/* 8224323Ch case    8:*/		return 0x82243240;
		  /* 82243240h */ case    9:  		/* li R5, 0 */
		/* 82243240h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82243240h case    9:*/		return 0x82243244;
		  /* 82243244h */ case   10:  		/* mr R3, R30 */
		/* 82243244h case   10:*/		regs.R3 = regs.R30;
		/* 82243244h case   10:*/		return 0x82243248;
		  /* 82243248h */ case   11:  		/* bl -4408 */
		/* 82243248h case   11:*/		regs.LR = 0x8224324C; return 0x82242110;
		/* 82243248h case   11:*/		return 0x8224324C;
	}
	return 0x8224324C;
} // Block from 8224321Ch-8224324Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224324Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224324C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224324C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224324C);
		  /* 8224324Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8224324Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224324Ch case    0:*/		return 0x82243250;
		  /* 82243250h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82243250h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82243250h case    1:*/		return 0x82243254;
		  /* 82243254h */ case    2:  		/* mtspr LR, R12 */
		/* 82243254h case    2:*/		regs.LR = regs.R12;
		/* 82243254h case    2:*/		return 0x82243258;
		  /* 82243258h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82243258h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82243258h case    3:*/		return 0x8224325C;
		  /* 8224325Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8224325Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224325Ch case    4:*/		return 0x82243260;
		  /* 82243260h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82243260h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82243260h case    5:*/		return 0x82243264;
	}
	return 0x82243264;
} // Block from 8224324Ch-82243264h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82243264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243264);
		  /* 82243264h */ case    0:  		/* nop */
		/* 82243264h case    0:*/		cpu::op::nop();
		/* 82243264h case    0:*/		return 0x82243268;
	}
	return 0x82243268;
} // Block from 82243264h-82243268h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82243268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243268);
		  /* 82243268h */ case    0:  		/* mfspr R12, LR */
		/* 82243268h case    0:*/		regs.R12 = regs.LR;
		/* 82243268h case    0:*/		return 0x8224326C;
		  /* 8224326Ch */ case    1:  		/* bl -1777700 */
		/* 8224326Ch case    1:*/		regs.LR = 0x82243270; return 0x82091248;
		/* 8224326Ch case    1:*/		return 0x82243270;
		  /* 82243270h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82243270h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82243270h case    2:*/		return 0x82243274;
		  /* 82243274h */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 82243274h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82243274h case    3:*/		return 0x82243278;
		  /* 82243278h */ case    4:  		/* mr R27, R3 */
		/* 82243278h case    4:*/		regs.R27 = regs.R3;
		/* 82243278h case    4:*/		return 0x8224327C;
		  /* 8224327Ch */ case    5:  		/* mr R24, R4 */
		/* 8224327Ch case    5:*/		regs.R24 = regs.R4;
		/* 8224327Ch case    5:*/		return 0x82243280;
		  /* 82243280h */ case    6:  		/* lbz R11, <#[R11]> */
		/* 82243280h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82243280h case    6:*/		return 0x82243284;
		  /* 82243284h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82243284h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82243284h case    7:*/		return 0x82243288;
		  /* 82243288h */ case    8:  		/* bc 4, CR0_EQ, 788 */
		/* 82243288h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8224359C;  }
		/* 82243288h case    8:*/		return 0x8224328C;
		  /* 8224328Ch */ case    9:  		/* lwz R3, <#[R3 + 136]> */
		/* 8224328Ch case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000088) );
		/* 8224328Ch case    9:*/		return 0x82243290;
		  /* 82243290h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 82243290h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82243290h case   10:*/		return 0x82243294;
		  /* 82243294h */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 82243294h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82243294h case   11:*/		return 0x82243298;
		  /* 82243298h */ case   12:  		/* mtspr CTR, R11 */
		/* 82243298h case   12:*/		regs.CTR = regs.R11;
		/* 82243298h case   12:*/		return 0x8224329C;
		  /* 8224329Ch */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 8224329Ch case   13:*/		if ( 1 ) { regs.LR = 0x822432A0; return (uint32)regs.CTR; }
		/* 8224329Ch case   13:*/		return 0x822432A0;
		  /* 822432A0h */ case   14:  		/* lis R11, -32253 */
		/* 822432A0h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 822432A0h case   14:*/		return 0x822432A4;
		  /* 822432A4h */ case   15:  		/* lis R10, -32252 */
		/* 822432A4h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822432A4h case   15:*/		return 0x822432A8;
		  /* 822432A8h */ case   16:  		/* cmpwi CR6, R3, 1 */
		/* 822432A8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 822432A8h case   16:*/		return 0x822432AC;
		  /* 822432ACh */ case   17:  		/* addi R26, R11, 27460 */
		/* 822432ACh case   17:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x6B44);
		/* 822432ACh case   17:*/		return 0x822432B0;
		  /* 822432B0h */ case   18:  		/* addi R25, R10, 10344 */
		/* 822432B0h case   18:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R10,0x2868);
		/* 822432B0h case   18:*/		return 0x822432B4;
		  /* 822432B4h */ case   19:  		/* bc 12, CR6_EQ, 32 */
		/* 822432B4h case   19:*/		if ( regs.CR[6].eq ) { return 0x822432D4;  }
		/* 822432B4h case   19:*/		return 0x822432B8;
		  /* 822432B8h */ case   20:  		/* lis R11, -32252 */
		/* 822432B8h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822432B8h case   20:*/		return 0x822432BC;
		  /* 822432BCh */ case   21:  		/* mr R6, R25 */
		/* 822432BCh case   21:*/		regs.R6 = regs.R25;
		/* 822432BCh case   21:*/		return 0x822432C0;
		  /* 822432C0h */ case   22:  		/* addi R5, R11, 12264 */
		/* 822432C0h case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2FE8);
		/* 822432C0h case   22:*/		return 0x822432C4;
		  /* 822432C4h */ case   23:  		/* mr R4, R26 */
		/* 822432C4h case   23:*/		regs.R4 = regs.R26;
		/* 822432C4h case   23:*/		return 0x822432C8;
		  /* 822432C8h */ case   24:  		/* li R7, 427 */
		/* 822432C8h case   24:*/		cpu::op::li<0>(regs,&regs.R7,0x1AB);
		/* 822432C8h case   24:*/		return 0x822432CC;
		  /* 822432CCh */ case   25:  		/* li R3, 0 */
		/* 822432CCh case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822432CCh case   25:*/		return 0x822432D0;
		  /* 822432D0h */ case   26:  		/* bl -964296 */
		/* 822432D0h case   26:*/		regs.LR = 0x822432D4; return 0x82157C08;
		/* 822432D0h case   26:*/		return 0x822432D4;
	}
	return 0x822432D4;
} // Block from 82243268h-822432D4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 822432D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822432D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822432D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822432D4);
		  /* 822432D4h */ case    0:  		/* lwz R10, <#[R24 + 100]> */
		/* 822432D4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000064) );
		/* 822432D4h case    0:*/		return 0x822432D8;
		  /* 822432D8h */ case    1:  		/* li R30, 0 */
		/* 822432D8h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822432D8h case    1:*/		return 0x822432DC;
		  /* 822432DCh */ case    2:  		/* li R31, 1 */
		/* 822432DCh case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 822432DCh case    2:*/		return 0x822432E0;
		  /* 822432E0h */ case    3:  		/* lwz R11, <#[R10 + 4]> */
		/* 822432E0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 822432E0h case    3:*/		return 0x822432E4;
		  /* 822432E4h */ case    4:  		/* addi R9, R11, -1 */
		/* 822432E4h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 822432E4h case    4:*/		return 0x822432E8;
		  /* 822432E8h */ case    5:  		/* cmplw CR6, R9, R11 */
		/* 822432E8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 822432E8h case    5:*/		return 0x822432EC;
		  /* 822432ECh */ case    6:  		/* bc 4, CR6_LT, 20 */
		/* 822432ECh case    6:*/		if ( !regs.CR[6].lt ) { return 0x82243300;  }
		/* 822432ECh case    6:*/		return 0x822432F0;
		  /* 822432F0h */ case    7:  		/* lwz R11, <#[R10 + 8]> */
		/* 822432F0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 822432F0h case    7:*/		return 0x822432F4;
		  /* 822432F4h */ case    8:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 822432F4h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 822432F4h case    8:*/		return 0x822432F8;
		  /* 822432F8h */ case    9:  		/* add R11, R10, R11 */
		/* 822432F8h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822432F8h case    9:*/		return 0x822432FC;
		  /* 822432FCh */ case   10:  		/* b 8 */
		/* 822432FCh case   10:*/		return 0x82243304;
		/* 822432FCh case   10:*/		return 0x82243300;
	}
	return 0x82243300;
} // Block from 822432D4h-82243300h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82243300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243300);
		  /* 82243300h */ case    0:  		/* mr R11, R30 */
		/* 82243300h case    0:*/		regs.R11 = regs.R30;
		/* 82243300h case    0:*/		return 0x82243304;
	}
	return 0x82243304;
} // Block from 82243300h-82243304h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82243304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243304);
		  /* 82243304h */ case    0:  		/* lwz R29, <#[R11]> */
		/* 82243304h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82243304h case    0:*/		return 0x82243308;
		  /* 82243308h */ case    1:  		/* cmpwi CR6, R29, 3 */
		/* 82243308h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000003);
		/* 82243308h case    1:*/		return 0x8224330C;
		  /* 8224330Ch */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 8224330Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82243334;  }
		/* 8224330Ch case    2:*/		return 0x82243310;
		  /* 82243310h */ case    3:  		/* cmpwi CR6, R29, 0 */
		/* 82243310h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82243310h case    3:*/		return 0x82243314;
		  /* 82243314h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 82243314h case    4:*/		if ( regs.CR[6].eq ) { return 0x8224333C;  }
		/* 82243314h case    4:*/		return 0x82243318;
		  /* 82243318h */ case    5:  		/* lis R11, -32252 */
		/* 82243318h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243318h case    5:*/		return 0x8224331C;
		  /* 8224331Ch */ case    6:  		/* mr R6, R25 */
		/* 8224331Ch case    6:*/		regs.R6 = regs.R25;
		/* 8224331Ch case    6:*/		return 0x82243320;
		  /* 82243320h */ case    7:  		/* addi R5, R11, 12204 */
		/* 82243320h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2FAC);
		/* 82243320h case    7:*/		return 0x82243324;
		  /* 82243324h */ case    8:  		/* mr R4, R26 */
		/* 82243324h case    8:*/		regs.R4 = regs.R26;
		/* 82243324h case    8:*/		return 0x82243328;
		  /* 82243328h */ case    9:  		/* li R7, 432 */
		/* 82243328h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x1B0);
		/* 82243328h case    9:*/		return 0x8224332C;
		  /* 8224332Ch */ case   10:  		/* li R3, 0 */
		/* 8224332Ch case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224332Ch case   10:*/		return 0x82243330;
		  /* 82243330h */ case   11:  		/* bl -964392 */
		/* 82243330h case   11:*/		regs.LR = 0x82243334; return 0x82157C08;
		/* 82243330h case   11:*/		return 0x82243334;
	}
	return 0x82243334;
} // Block from 82243304h-82243334h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82243334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243334);
		  /* 82243334h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 82243334h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82243334h case    0:*/		return 0x82243338;
	}
	return 0x82243338;
} // Block from 82243334h-82243338h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82243338h
// Function '?Assemble@IRExport@XGRAPHICS@@UAAXPAVAssembler@2@PADPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243338);
		  /* 82243338h */ case    0:  		/* bc 4, CR6_EQ, 52 */
		/* 82243338h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8224336C;  }
		/* 82243338h case    0:*/		return 0x8224333C;
	}
	return 0x8224333C;
} // Block from 82243338h-8224333Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224333Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224333C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224333C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224333C);
		  /* 8224333Ch */ case    0:  		/* lwz R11, <#[R24 + 100]> */
		/* 8224333Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000064) );
		/* 8224333Ch case    0:*/		return 0x82243340;
		  /* 82243340h */ case    1:  		/* mr R31, R30 */
		/* 82243340h case    1:*/		regs.R31 = regs.R30;
		/* 82243340h case    1:*/		return 0x82243344;
		  /* 82243344h */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 82243344h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82243344h case    2:*/		return 0x82243348;
		  /* 82243348h */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 82243348h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82243348h case    3:*/		return 0x8224334C;
		  /* 8224334Ch */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 8224334Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8224336C;  }
		/* 8224334Ch case    4:*/		return 0x82243350;
		  /* 82243350h */ case    5:  		/* lis R11, -32252 */
		/* 82243350h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243350h case    5:*/		return 0x82243354;
		  /* 82243354h */ case    6:  		/* mr R6, R25 */
		/* 82243354h case    6:*/		regs.R6 = regs.R25;
		/* 82243354h case    6:*/		return 0x82243358;
		  /* 82243358h */ case    7:  		/* addi R5, R11, 12168 */
		/* 82243358h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2F88);
		/* 82243358h case    7:*/		return 0x8224335C;
		  /* 8224335Ch */ case    8:  		/* mr R4, R26 */
		/* 8224335Ch case    8:*/		regs.R4 = regs.R26;
		/* 8224335Ch case    8:*/		return 0x82243360;
		  /* 82243360h */ case    9:  		/* li R7, 435 */
		/* 82243360h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x1B3);
		/* 82243360h case    9:*/		return 0x82243364;
		  /* 82243364h */ case   10:  		/* li R3, 0 */
		/* 82243364h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82243364h case   10:*/		return 0x82243368;
		  /* 82243368h */ case   11:  		/* bl -964448 */
		/* 82243368h case   11:*/		regs.LR = 0x8224336C; return 0x82157C08;
		/* 82243368h case   11:*/		return 0x8224336C;
	}
	return 0x8224336C;
} // Block from 8224333Ch-8224336Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224336Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224336C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224336C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224336C);
		  /* 8224336Ch */ case    0:  		/* lwz R11, <#[R27 + 136]> */
		/* 8224336Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000088) );
		/* 8224336Ch case    0:*/		return 0x82243370;
		  /* 82243370h */ case    1:  		/* lwz R11, <#[R11 + 168]> */
		/* 82243370h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000A8) );
		/* 82243370h case    1:*/		return 0x82243374;
		  /* 82243374h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 82243374h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82243374h case    2:*/		return 0x82243378;
		  /* 82243378h */ case    3:  		/* bc 12, CR6_LT, 140 */
		/* 82243378h case    3:*/		if ( regs.CR[6].lt ) { return 0x82243404;  }
		/* 82243378h case    3:*/		return 0x8224337C;
		  /* 8224337Ch */ case    4:  		/* bc 12, CR6_EQ, 108 */
		/* 8224337Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x822433E8;  }
		/* 8224337Ch case    4:*/		return 0x82243380;
		  /* 82243380h */ case    5:  		/* cmplwi CR6, R11, 3 */
		/* 82243380h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82243380h case    5:*/		return 0x82243384;
		  /* 82243384h */ case    6:  		/* bc 12, CR6_LT, 72 */
		/* 82243384h case    6:*/		if ( regs.CR[6].lt ) { return 0x822433CC;  }
		/* 82243384h case    6:*/		return 0x82243388;
		  /* 82243388h */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 82243388h case    7:*/		if ( regs.CR[6].eq ) { return 0x822433B0;  }
		/* 82243388h case    7:*/		return 0x8224338C;
		  /* 8224338Ch */ case    8:  		/* lis R11, -32255 */
		/* 8224338Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8224338Ch case    8:*/		return 0x82243390;
		  /* 82243390h */ case    9:  		/* mr R6, R25 */
		/* 82243390h case    9:*/		regs.R6 = regs.R25;
		/* 82243390h case    9:*/		return 0x82243394;
		  /* 82243394h */ case   10:  		/* addi R5, R11, 5216 */
		/* 82243394h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1460);
		/* 82243394h case   10:*/		return 0x82243398;
		  /* 82243398h */ case   11:  		/* mr R4, R26 */
		/* 82243398h case   11:*/		regs.R4 = regs.R26;
		/* 82243398h case   11:*/		return 0x8224339C;
		  /* 8224339Ch */ case   12:  		/* li R7, 457 */
		/* 8224339Ch case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x1C9);
		/* 8224339Ch case   12:*/		return 0x822433A0;
		  /* 822433A0h */ case   13:  		/* li R3, 0 */
		/* 822433A0h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822433A0h case   13:*/		return 0x822433A4;
		  /* 822433A4h */ case   14:  		/* bl -964508 */
		/* 822433A4h case   14:*/		regs.LR = 0x822433A8; return 0x82157C08;
		/* 822433A4h case   14:*/		return 0x822433A8;
		  /* 822433A8h */ case   15:  		/* lwz R3, <#[R1 + 80]> */
		/* 822433A8h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 822433A8h case   15:*/		return 0x822433AC;
		  /* 822433ACh */ case   16:  		/* b 112 */
		/* 822433ACh case   16:*/		return 0x8224341C;
		/* 822433ACh case   16:*/		return 0x822433B0;
	}
	return 0x822433B0;
} // Block from 8224336Ch-822433B0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822433B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822433B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822433B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822433B0);
		  /* 822433B0h */ case    0:  		/* rlwinm R11, R31, 0, 24, 31 */
		/* 822433B0h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R31);
		/* 822433B0h case    0:*/		return 0x822433B4;
		  /* 822433B4h */ case    1:  		/* subfic R11, R11, 0 */
		/* 822433B4h case    1:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 822433B4h case    1:*/		return 0x822433B8;
		  /* 822433B8h */ case    2:  		/* subfe R11, R11, R11 */
		/* 822433B8h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 822433B8h case    2:*/		return 0x822433BC;
		  /* 822433BCh */ case    3:  		/* rlwinm R11, R11, 0, 31, 28 */
		/* 822433BCh case    3:*/		cpu::op::rlwinm<0,0,31,28>(regs,&regs.R11,regs.R11);
		/* 822433BCh case    3:*/		return 0x822433C0;
		  /* 822433C0h */ case    4:  		/* rlwinm R11, R11, 0, 27, 25 */
		/* 822433C0h case    4:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R11,regs.R11);
		/* 822433C0h case    4:*/		return 0x822433C4;
		  /* 822433C4h */ case    5:  		/* addi R3, R11, 86 */
		/* 822433C4h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x56);
		/* 822433C4h case    5:*/		return 0x822433C8;
		  /* 822433C8h */ case    6:  		/* b 84 */
		/* 822433C8h case    6:*/		return 0x8224341C;
		/* 822433C8h case    6:*/		return 0x822433CC;
	}
	return 0x822433CC;
} // Block from 822433B0h-822433CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 822433CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822433CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822433CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822433CC);
		  /* 822433CCh */ case    0:  		/* rlwinm R11, R31, 0, 24, 31 */
		/* 822433CCh case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R31);
		/* 822433CCh case    0:*/		return 0x822433D0;
		  /* 822433D0h */ case    1:  		/* subfic R11, R11, 0 */
		/* 822433D0h case    1:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 822433D0h case    1:*/		return 0x822433D4;
		  /* 822433D4h */ case    2:  		/* subfe R11, R11, R11 */
		/* 822433D4h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 822433D4h case    2:*/		return 0x822433D8;
		  /* 822433D8h */ case    3:  		/* rlwinm R11, R11, 0, 31, 28 */
		/* 822433D8h case    3:*/		cpu::op::rlwinm<0,0,31,28>(regs,&regs.R11,regs.R11);
		/* 822433D8h case    3:*/		return 0x822433DC;
		  /* 822433DCh */ case    4:  		/* rlwinm R11, R11, 0, 27, 25 */
		/* 822433DCh case    4:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R11,regs.R11);
		/* 822433DCh case    4:*/		return 0x822433E0;
		  /* 822433E0h */ case    5:  		/* addi R3, R11, 85 */
		/* 822433E0h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x55);
		/* 822433E0h case    5:*/		return 0x822433E4;
		  /* 822433E4h */ case    6:  		/* b 56 */
		/* 822433E4h case    6:*/		return 0x8224341C;
		/* 822433E4h case    6:*/		return 0x822433E8;
	}
	return 0x822433E8;
} // Block from 822433CCh-822433E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822433E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822433E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822433E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822433E8);
		  /* 822433E8h */ case    0:  		/* rlwinm R11, R31, 0, 24, 31 */
		/* 822433E8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R31);
		/* 822433E8h case    0:*/		return 0x822433EC;
		  /* 822433ECh */ case    1:  		/* subfic R11, R11, 0 */
		/* 822433ECh case    1:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 822433ECh case    1:*/		return 0x822433F0;
		  /* 822433F0h */ case    2:  		/* subfe R11, R11, R11 */
		/* 822433F0h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 822433F0h case    2:*/		return 0x822433F4;
		  /* 822433F4h */ case    3:  		/* rlwinm R11, R11, 0, 31, 28 */
		/* 822433F4h case    3:*/		cpu::op::rlwinm<0,0,31,28>(regs,&regs.R11,regs.R11);
		/* 822433F4h case    3:*/		return 0x822433F8;
		  /* 822433F8h */ case    4:  		/* rlwinm R11, R11, 0, 27, 25 */
		/* 822433F8h case    4:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R11,regs.R11);
		/* 822433F8h case    4:*/		return 0x822433FC;
		  /* 822433FCh */ case    5:  		/* addi R3, R11, 84 */
		/* 822433FCh case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x54);
		/* 822433FCh case    5:*/		return 0x82243400;
		  /* 82243400h */ case    6:  		/* b 28 */
		/* 82243400h case    6:*/		return 0x8224341C;
		/* 82243400h case    6:*/		return 0x82243404;
	}
	return 0x82243404;
} // Block from 822433E8h-82243404h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82243404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243404);
		  /* 82243404h */ case    0:  		/* rlwinm R11, R31, 0, 24, 31 */
		/* 82243404h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R31);
		/* 82243404h case    0:*/		return 0x82243408;
		  /* 82243408h */ case    1:  		/* subfic R11, R11, 0 */
		/* 82243408h case    1:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82243408h case    1:*/		return 0x8224340C;
		  /* 8224340Ch */ case    2:  		/* subfe R11, R11, R11 */
		/* 8224340Ch case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8224340Ch case    2:*/		return 0x82243410;
		  /* 82243410h */ case    3:  		/* rlwinm R11, R11, 0, 31, 28 */
		/* 82243410h case    3:*/		cpu::op::rlwinm<0,0,31,28>(regs,&regs.R11,regs.R11);
		/* 82243410h case    3:*/		return 0x82243414;
		  /* 82243414h */ case    4:  		/* rlwinm R11, R11, 0, 27, 25 */
		/* 82243414h case    4:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R11,regs.R11);
		/* 82243414h case    4:*/		return 0x82243418;
		  /* 82243418h */ case    5:  		/* addi R3, R11, 83 */
		/* 82243418h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x53);
		/* 82243418h case    5:*/		return 0x8224341C;
	}
	return 0x8224341C;
} // Block from 82243404h-8224341Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224341Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224341C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224341C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224341C);
		  /* 8224341Ch */ case    0:  		/* lwz R4, <#[R27 + 12]> */
		/* 8224341Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x0000000C) );
		/* 8224341Ch case    0:*/		return 0x82243420;
		  /* 82243420h */ case    1:  		/* bl 76560 */
		/* 82243420h case    1:*/		regs.LR = 0x82243424; return 0x82255F30;
		/* 82243420h case    1:*/		return 0x82243424;
		  /* 82243424h */ case    2:  		/* rlwinm. R28, R31, 0, 24, 31 */
		/* 82243424h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R28,regs.R31);
		/* 82243424h case    2:*/		return 0x82243428;
		  /* 82243428h */ case    3:  		/* mr R31, R3 */
		/* 82243428h case    3:*/		regs.R31 = regs.R3;
		/* 82243428h case    3:*/		return 0x8224342C;
		  /* 8224342Ch */ case    4:  		/* bc 12, CR0_EQ, 108 */
		/* 8224342Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82243498;  }
		/* 8224342Ch case    4:*/		return 0x82243430;
		  /* 82243430h */ case    5:  		/* mr R3, R24 */
		/* 82243430h case    5:*/		regs.R3 = regs.R24;
		/* 82243430h case    5:*/		return 0x82243434;
		  /* 82243434h */ case    6:  		/* bl -18460 */
		/* 82243434h case    6:*/		regs.LR = 0x82243438; return 0x8223EC18;
		/* 82243434h case    6:*/		return 0x82243438;
		  /* 82243438h */ case    7:  		/* or. R29, R3, R3 */
		/* 82243438h case    7:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 82243438h case    7:*/		return 0x8224343C;
		  /* 8224343Ch */ case    8:  		/* bc 4, CR0_EQ, 32 */
		/* 8224343Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x8224345C;  }
		/* 8224343Ch case    8:*/		return 0x82243440;
		  /* 82243440h */ case    9:  		/* lis R11, -32252 */
		/* 82243440h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243440h case    9:*/		return 0x82243444;
		  /* 82243444h */ case   10:  		/* mr R6, R25 */
		/* 82243444h case   10:*/		regs.R6 = regs.R25;
		/* 82243444h case   10:*/		return 0x82243448;
		  /* 82243448h */ case   11:  		/* addi R5, R11, 12152 */
		/* 82243448h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2F78);
		/* 82243448h case   11:*/		return 0x8224344C;
		  /* 8224344Ch */ case   12:  		/* mr R4, R26 */
		/* 8224344Ch case   12:*/		regs.R4 = regs.R26;
		/* 8224344Ch case   12:*/		return 0x82243450;
		  /* 82243450h */ case   13:  		/* li R7, 463 */
		/* 82243450h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x1CF);
		/* 82243450h case   13:*/		return 0x82243454;
		  /* 82243454h */ case   14:  		/* li R3, 0 */
		/* 82243454h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82243454h case   14:*/		return 0x82243458;
		  /* 82243458h */ case   15:  		/* bl -964688 */
		/* 82243458h case   15:*/		regs.LR = 0x8224345C; return 0x82157C08;
		/* 82243458h case   15:*/		return 0x8224345C;
	}
	return 0x8224345C;
} // Block from 8224341Ch-8224345Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8224345Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224345C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224345C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224345C);
		  /* 8224345Ch */ case    0:  		/* lis R11, -32252 */
		/* 8224345Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224345Ch case    0:*/		return 0x82243460;
		  /* 82243460h */ case    1:  		/* lwz R10, <#[R29 + 56]> */
		/* 82243460h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000038) );
		/* 82243460h case    1:*/		return 0x82243464;
		  /* 82243464h */ case    2:  		/* mr R5, R29 */
		/* 82243464h case    2:*/		regs.R5 = regs.R29;
		/* 82243464h case    2:*/		return 0x82243468;
		  /* 82243468h */ case    3:  		/* stw R30, <#[R31 + 80]> */
		/* 82243468h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000050) );
		/* 82243468h case    3:*/		return 0x8224346C;
		  /* 8224346Ch */ case    4:  		/* addi R29, R11, 9920 */
		/* 8224346Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x26C0);
		/* 8224346Ch case    4:*/		return 0x82243470;
		  /* 82243470h */ case    5:  		/* li R4, 1 */
		/* 82243470h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243470h case    5:*/		return 0x82243474;
		  /* 82243474h */ case    6:  		/* mr R3, R31 */
		/* 82243474h case    6:*/		regs.R3 = regs.R31;
		/* 82243474h case    6:*/		return 0x82243478;
		  /* 82243478h */ case    7:  		/* stw R10, <#[R31 + 56]> */
		/* 82243478h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 82243478h case    7:*/		return 0x8224347C;
		  /* 8224347Ch */ case    8:  		/* lwz R11, <#[R29 + 4]> */
		/* 8224347Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8224347Ch case    8:*/		return 0x82243480;
		  /* 82243480h */ case    9:  		/* stw R11, <#[R31 + 128]> */
		/* 82243480h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 82243480h case    9:*/		return 0x82243484;
		  /* 82243484h */ case   10:  		/* bl -54580 */
		/* 82243484h case   10:*/		regs.LR = 0x82243488; return 0x82235F50;
		/* 82243484h case   10:*/		return 0x82243488;
		  /* 82243488h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 82243488h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82243488h case   11:*/		return 0x8224348C;
		  /* 8224348Ch */ case   12:  		/* li R4, 2 */
		/* 8224348Ch case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8224348Ch case   12:*/		return 0x82243490;
		  /* 82243490h */ case   13:  		/* stw R11, <#[R31 + 132]> */
		/* 82243490h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 82243490h case   13:*/		return 0x82243494;
		  /* 82243494h */ case   14:  		/* b 112 */
		/* 82243494h case   14:*/		return 0x82243504;
		/* 82243494h case   14:*/		return 0x82243498;
	}
	return 0x82243498;
} // Block from 8224345Ch-82243498h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82243498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243498);
		  /* 82243498h */ case    0:  		/* lbz R11, <#[R27 + 140]> */
		/* 82243498h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000008C) );
		/* 82243498h case    0:*/		return 0x8224349C;
		  /* 8224349Ch */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8224349Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224349Ch case    1:*/		return 0x822434A0;
		  /* 822434A0h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 822434A0h case    2:*/		if ( regs.CR[0].eq ) { return 0x822434B8;  }
		/* 822434A0h case    2:*/		return 0x822434A4;
		  /* 822434A4h */ case    3:  		/* lis R11, -32252 */
		/* 822434A4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822434A4h case    3:*/		return 0x822434A8;
		  /* 822434A8h */ case    4:  		/* stw R30, <#[R31 + 56]> */
		/* 822434A8h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000038) );
		/* 822434A8h case    4:*/		return 0x822434AC;
		  /* 822434ACh */ case    5:  		/* stw R30, <#[R31 + 80]> */
		/* 822434ACh case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000050) );
		/* 822434ACh case    5:*/		return 0x822434B0;
		  /* 822434B0h */ case    6:  		/* lwz R11, <#[R11 + 9920]> */
		/* 822434B0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000026C0) );
		/* 822434B0h case    6:*/		return 0x822434B4;
		  /* 822434B4h */ case    7:  		/* b 72 */
		/* 822434B4h case    7:*/		return 0x822434FC;
		/* 822434B4h case    7:*/		return 0x822434B8;
	}
	return 0x822434B8;
} // Block from 82243498h-822434B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822434B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822434B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822434B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822434B8);
		  /* 822434B8h */ case    0:  		/* mr R3, R24 */
		/* 822434B8h case    0:*/		regs.R3 = regs.R24;
		/* 822434B8h case    0:*/		return 0x822434BC;
		  /* 822434BCh */ case    1:  		/* bl -18596 */
		/* 822434BCh case    1:*/		regs.LR = 0x822434C0; return 0x8223EC18;
		/* 822434BCh case    1:*/		return 0x822434C0;
		  /* 822434C0h */ case    2:  		/* or. R29, R3, R3 */
		/* 822434C0h case    2:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 822434C0h case    2:*/		return 0x822434C4;
		  /* 822434C4h */ case    3:  		/* bc 4, CR0_EQ, 32 */
		/* 822434C4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x822434E4;  }
		/* 822434C4h case    3:*/		return 0x822434C8;
		  /* 822434C8h */ case    4:  		/* lis R11, -32252 */
		/* 822434C8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822434C8h case    4:*/		return 0x822434CC;
		  /* 822434CCh */ case    5:  		/* mr R6, R25 */
		/* 822434CCh case    5:*/		regs.R6 = regs.R25;
		/* 822434CCh case    5:*/		return 0x822434D0;
		  /* 822434D0h */ case    6:  		/* addi R5, R11, 12152 */
		/* 822434D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2F78);
		/* 822434D0h case    6:*/		return 0x822434D4;
		  /* 822434D4h */ case    7:  		/* mr R4, R26 */
		/* 822434D4h case    7:*/		regs.R4 = regs.R26;
		/* 822434D4h case    7:*/		return 0x822434D8;
		  /* 822434D8h */ case    8:  		/* li R7, 477 */
		/* 822434D8h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x1DD);
		/* 822434D8h case    8:*/		return 0x822434DC;
		  /* 822434DCh */ case    9:  		/* li R3, 0 */
		/* 822434DCh case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822434DCh case    9:*/		return 0x822434E0;
		  /* 822434E0h */ case   10:  		/* bl -964824 */
		/* 822434E0h case   10:*/		regs.LR = 0x822434E4; return 0x82157C08;
		/* 822434E0h case   10:*/		return 0x822434E4;
	}
	return 0x822434E4;
} // Block from 822434B8h-822434E4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822434E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822434E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822434E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822434E4);
		  /* 822434E4h */ case    0:  		/* lis R11, -32252 */
		/* 822434E4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822434E4h case    0:*/		return 0x822434E8;
		  /* 822434E8h */ case    1:  		/* lwz R10, <#[R29 + 56]> */
		/* 822434E8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000038) );
		/* 822434E8h case    1:*/		return 0x822434EC;
		  /* 822434ECh */ case    2:  		/* stw R30, <#[R31 + 80]> */
		/* 822434ECh case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000050) );
		/* 822434ECh case    2:*/		return 0x822434F0;
		  /* 822434F0h */ case    3:  		/* addi R11, R11, 9920 */
		/* 822434F0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x26C0);
		/* 822434F0h case    3:*/		return 0x822434F4;
		  /* 822434F4h */ case    4:  		/* stw R10, <#[R31 + 56]> */
		/* 822434F4h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 822434F4h case    4:*/		return 0x822434F8;
		  /* 822434F8h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 822434F8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822434F8h case    5:*/		return 0x822434FC;
	}
	return 0x822434FC;
} // Block from 822434E4h-822434FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 822434FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822434FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822434FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822434FC);
		  /* 822434FCh */ case    0:  		/* stw R11, <#[R31 + 128]> */
		/* 822434FCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 822434FCh case    0:*/		return 0x82243500;
		  /* 82243500h */ case    1:  		/* li R4, 1 */
		/* 82243500h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243500h case    1:*/		return 0x82243504;
	}
	return 0x82243504;
} // Block from 822434FCh-82243504h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82243504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243504);
		  /* 82243504h */ case    0:  		/* lwz R11, <#[R27 + 136]> */
		/* 82243504h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000088) );
		/* 82243504h case    0:*/		return 0x82243508;
		  /* 82243508h */ case    1:  		/* mr R3, R31 */
		/* 82243508h case    1:*/		regs.R3 = regs.R31;
		/* 82243508h case    1:*/		return 0x8224350C;
		  /* 8224350Ch */ case    2:  		/* lwz R5, <#[R11 + 236]> */
		/* 8224350Ch case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x000000EC) );
		/* 8224350Ch case    2:*/		return 0x82243510;
		  /* 82243510h */ case    3:  		/* bl -54720 */
		/* 82243510h case    3:*/		regs.LR = 0x82243514; return 0x82235F50;
		/* 82243510h case    3:*/		return 0x82243514;
		  /* 82243514h */ case    4:  		/* cntlzw R11, R28 */
		/* 82243514h case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R28);
		/* 82243514h case    4:*/		return 0x82243518;
		  /* 82243518h */ case    5:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82243518h case    5:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82243518h case    5:*/		return 0x8224351C;
		  /* 8224351Ch */ case    6:  		/* xori R11, R11, 1 */
		/* 8224351Ch case    6:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224351Ch case    6:*/		return 0x82243520;
		  /* 82243520h */ case    7:  		/* addi R29, R11, 1 */
		/* 82243520h case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1);
		/* 82243520h case    7:*/		return 0x82243524;
		  /* 82243524h */ case    8:  		/* lwz R3, <#[R27 + 136]> */
		/* 82243524h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000088) );
		/* 82243524h case    8:*/		return 0x82243528;
		  /* 82243528h */ case    9:  		/* li R5, 3 */
		/* 82243528h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82243528h case    9:*/		return 0x8224352C;
		  /* 8224352Ch */ case   10:  		/* li R4, 1 */
		/* 8224352Ch case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224352Ch case   10:*/		return 0x82243530;
		  /* 82243530h */ case   11:  		/* lwz R28, <#[R31]> */
		/* 82243530h case   11:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 82243530h case   11:*/		return 0x82243534;
		  /* 82243534h */ case   12:  		/* lwz R11, <#[R3]> */
		/* 82243534h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82243534h case   12:*/		return 0x82243538;
		  /* 82243538h */ case   13:  		/* lwz R11, <#[R11 + 80]> */
		/* 82243538h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82243538h case   13:*/		return 0x8224353C;
		  /* 8224353Ch */ case   14:  		/* mtspr CTR, R11 */
		/* 8224353Ch case   14:*/		regs.CTR = regs.R11;
		/* 8224353Ch case   14:*/		return 0x82243540;
		  /* 82243540h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 82243540h case   15:*/		if ( 1 ) { regs.LR = 0x82243544; return (uint32)regs.CTR; }
		/* 82243540h case   15:*/		return 0x82243544;
		  /* 82243544h */ case   16:  		/* lwz R11, <#[R28 + 88]> */
		/* 82243544h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000058) );
		/* 82243544h case   16:*/		return 0x82243548;
		  /* 82243548h */ case   17:  		/* mr R6, R3 */
		/* 82243548h case   17:*/		regs.R6 = regs.R3;
		/* 82243548h case   17:*/		return 0x8224354C;
		  /* 8224354Ch */ case   18:  		/* mr R5, R30 */
		/* 8224354Ch case   18:*/		regs.R5 = regs.R30;
		/* 8224354Ch case   18:*/		return 0x82243550;
		  /* 82243550h */ case   19:  		/* mr R4, R29 */
		/* 82243550h case   19:*/		regs.R4 = regs.R29;
		/* 82243550h case   19:*/		return 0x82243554;
		  /* 82243554h */ case   20:  		/* mr R3, R31 */
		/* 82243554h case   20:*/		regs.R3 = regs.R31;
		/* 82243554h case   20:*/		return 0x82243558;
		  /* 82243558h */ case   21:  		/* mtspr CTR, R11 */
		/* 82243558h case   21:*/		regs.CTR = regs.R11;
		/* 82243558h case   21:*/		return 0x8224355C;
		  /* 8224355Ch */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 8224355Ch case   22:*/		if ( 1 ) { regs.LR = 0x82243560; return (uint32)regs.CTR; }
		/* 8224355Ch case   22:*/		return 0x82243560;
		  /* 82243560h */ case   23:  		/* addi R30, R30, 1 */
		/* 82243560h case   23:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82243560h case   23:*/		return 0x82243564;
		  /* 82243564h */ case   24:  		/* cmpwi CR6, R30, 4 */
		/* 82243564h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 82243564h case   24:*/		return 0x82243568;
		  /* 82243568h */ case   25:  		/* bc 12, CR6_LT, -68 */
		/* 82243568h case   25:*/		if ( regs.CR[6].lt ) { return 0x82243524;  }
		/* 82243568h case   25:*/		return 0x8224356C;
		  /* 8224356Ch */ case   26:  		/* lwz R11, <#[R27 + 136]> */
		/* 8224356Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000088) );
		/* 8224356Ch case   26:*/		return 0x82243570;
		  /* 82243570h */ case   27:  		/* lbz R11, <#[R11 + 153]> */
		/* 82243570h case   27:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000099) );
		/* 82243570h case   27:*/		return 0x82243574;
		  /* 82243574h */ case   28:  		/* cmplwi CR0, R11, 0 */
		/* 82243574h case   28:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82243574h case   28:*/		return 0x82243578;
		  /* 82243578h */ case   29:  		/* bc 12, CR0_EQ, 16 */
		/* 82243578h case   29:*/		if ( regs.CR[0].eq ) { return 0x82243588;  }
		/* 82243578h case   29:*/		return 0x8224357C;
		  /* 8224357Ch */ case   30:  		/* add R11, R29, R31 */
		/* 8224357Ch case   30:*/		cpu::op::add<0>(regs,&regs.R11,regs.R29,regs.R31);
		/* 8224357Ch case   30:*/		return 0x82243580;
	}
	return 0x82243580;
} // Block from 82243504h-82243580h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82243580h
// Function '?Assemble@IRExportColorAndFog@XGRAPHICS@@UAAXPAVAssembler@2@PADPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243580);
		  /* 82243580h */ case    0:  		/* li R10, 1 */
		/* 82243580h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82243580h case    0:*/		return 0x82243584;
		  /* 82243584h */ case    1:  		/* stb R10, <#[R11 + 152]> */
		/* 82243584h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000098) );
		/* 82243584h case    1:*/		return 0x82243588;
	}
	return 0x82243588;
} // Block from 82243580h-82243588h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82243588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243588);
		  /* 82243588h */ case    0:  		/* mr R4, R31 */
		/* 82243588h case    0:*/		regs.R4 = regs.R31;
		/* 82243588h case    0:*/		return 0x8224358C;
		  /* 8224358Ch */ case    1:  		/* mr R3, R27 */
		/* 8224358Ch case    1:*/		regs.R3 = regs.R27;
		/* 8224358Ch case    1:*/		return 0x82243590;
		  /* 82243590h */ case    2:  		/* bl 88480 */
		/* 82243590h case    2:*/		regs.LR = 0x82243594; return 0x82258F30;
		/* 82243590h case    2:*/		return 0x82243594;
		  /* 82243594h */ case    3:  		/* lwz R3, <#[R27 + 136]> */
		/* 82243594h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000088) );
		/* 82243594h case    3:*/		return 0x82243598;
		  /* 82243598h */ case    4:  		/* bl 66048 */
		/* 82243598h case    4:*/		regs.LR = 0x8224359C; return 0x82253798;
		/* 82243598h case    4:*/		return 0x8224359C;
	}
	return 0x8224359C;
} // Block from 82243588h-8224359Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224359Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224359C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224359C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224359C);
		  /* 8224359Ch */ case    0:  		/* addi R4, R27, 20 */
		/* 8224359Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R27,0x14);
		/* 8224359Ch case    0:*/		return 0x822435A0;
		  /* 822435A0h */ case    1:  		/* lbz R5, <#[R27 + 124]> */
		/* 822435A0h case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000007C) );
		/* 822435A0h case    1:*/		return 0x822435A4;
		  /* 822435A4h */ case    2:  		/* mr R3, R24 */
		/* 822435A4h case    2:*/		regs.R3 = regs.R24;
		/* 822435A4h case    2:*/		return 0x822435A8;
		  /* 822435A8h */ case    3:  		/* bl -7416 */
		/* 822435A8h case    3:*/		regs.LR = 0x822435AC; return 0x822418B0;
		/* 822435A8h case    3:*/		return 0x822435AC;
		  /* 822435ACh */ case    4:  		/* lwz R3, <#[R24 + 100]> */
		/* 822435ACh case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000064) );
		/* 822435ACh case    4:*/		return 0x822435B0;
		  /* 822435B0h */ case    5:  		/* lwz R4, <#[R3 + 4]> */
		/* 822435B0h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 822435B0h case    5:*/		return 0x822435B4;
		  /* 822435B4h */ case    6:  		/* bl 66828 */
		/* 822435B4h case    6:*/		regs.LR = 0x822435B8; return 0x82253AC0;
		/* 822435B4h case    6:*/		return 0x822435B8;
		  /* 822435B8h */ case    7:  		/* li R11, 3 */
		/* 822435B8h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 822435B8h case    7:*/		return 0x822435BC;
		  /* 822435BCh */ case    8:  		/* stw R11, <#[R3]> */
		/* 822435BCh case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822435BCh case    8:*/		return 0x822435C0;
		  /* 822435C0h */ case    9:  		/* addi R1, R1, 160 */
		/* 822435C0h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 822435C0h case    9:*/		return 0x822435C4;
		  /* 822435C4h */ case   10:  		/* b -1778476 */
		/* 822435C4h case   10:*/		return 0x82091298;
		/* 822435C4h case   10:*/		return 0x822435C8;
	}
	return 0x822435C8;
} // Block from 8224359Ch-822435C8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822435C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822435C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822435C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822435C8);
		  /* 822435C8h */ case    0:  		/* mfspr R12, LR */
		/* 822435C8h case    0:*/		regs.R12 = regs.LR;
		/* 822435C8h case    0:*/		return 0x822435CC;
		  /* 822435CCh */ case    1:  		/* bl -1778564 */
		/* 822435CCh case    1:*/		regs.LR = 0x822435D0; return 0x82091248;
		/* 822435CCh case    1:*/		return 0x822435D0;
		  /* 822435D0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 822435D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 822435D0h case    2:*/		return 0x822435D4;
		  /* 822435D4h */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 822435D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 822435D4h case    3:*/		return 0x822435D8;
		  /* 822435D8h */ case    4:  		/* mr R30, R3 */
		/* 822435D8h case    4:*/		regs.R30 = regs.R3;
		/* 822435D8h case    4:*/		return 0x822435DC;
		  /* 822435DCh */ case    5:  		/* mr R27, R4 */
		/* 822435DCh case    5:*/		regs.R27 = regs.R4;
		/* 822435DCh case    5:*/		return 0x822435E0;
		  /* 822435E0h */ case    6:  		/* mr R24, R5 */
		/* 822435E0h case    6:*/		regs.R24 = regs.R5;
		/* 822435E0h case    6:*/		return 0x822435E4;
		  /* 822435E4h */ case    7:  		/* lbz R11, <#[R11]> */
		/* 822435E4h case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822435E4h case    7:*/		return 0x822435E8;
		  /* 822435E8h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 822435E8h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822435E8h case    8:*/		return 0x822435EC;
		  /* 822435ECh */ case    9:  		/* bc 4, CR0_EQ, 668 */
		/* 822435ECh case    9:*/		if ( !regs.CR[0].eq ) { return 0x82243888;  }
		/* 822435ECh case    9:*/		return 0x822435F0;
		  /* 822435F0h */ case   10:  		/* lwz R11, <#[R4 + 100]> */
		/* 822435F0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000064) );
		/* 822435F0h case   10:*/		return 0x822435F4;
		  /* 822435F4h */ case   11:  		/* li R25, 0 */
		/* 822435F4h case   11:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 822435F4h case   11:*/		return 0x822435F8;
		  /* 822435F8h */ case   12:  		/* lwz R9, <#[R11 + 4]> */
		/* 822435F8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 822435F8h case   12:*/		return 0x822435FC;
		  /* 822435FCh */ case   13:  		/* addi R10, R9, -1 */
		/* 822435FCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 822435FCh case   13:*/		return 0x82243600;
		  /* 82243600h */ case   14:  		/* cmplw CR6, R10, R9 */
		/* 82243600h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82243600h case   14:*/		return 0x82243604;
		  /* 82243604h */ case   15:  		/* bc 4, CR6_LT, 20 */
		/* 82243604h case   15:*/		if ( !regs.CR[6].lt ) { return 0x82243618;  }
		/* 82243604h case   15:*/		return 0x82243608;
		  /* 82243608h */ case   16:  		/* lwz R11, <#[R11 + 8]> */
		/* 82243608h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82243608h case   16:*/		return 0x8224360C;
		  /* 8224360Ch */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8224360Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8224360Ch case   17:*/		return 0x82243610;
		  /* 82243610h */ case   18:  		/* add R11, R10, R11 */
		/* 82243610h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82243610h case   18:*/		return 0x82243614;
		  /* 82243614h */ case   19:  		/* b 8 */
		/* 82243614h case   19:*/		return 0x8224361C;
		/* 82243614h case   19:*/		return 0x82243618;
	}
	return 0x82243618;
} // Block from 822435C8h-82243618h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82243618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243618);
		  /* 82243618h */ case    0:  		/* mr R11, R25 */
		/* 82243618h case    0:*/		regs.R11 = regs.R25;
		/* 82243618h case    0:*/		return 0x8224361C;
	}
	return 0x8224361C;
} // Block from 82243618h-8224361Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224361Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224361C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224361C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224361C);
		  /* 8224361Ch */ case    0:  		/* lwz R26, <#[R11]> */
		/* 8224361Ch case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 8224361Ch case    0:*/		return 0x82243620;
		  /* 82243620h */ case    1:  		/* lis R11, -32253 */
		/* 82243620h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82243620h case    1:*/		return 0x82243624;
		  /* 82243624h */ case    2:  		/* lis R10, -32252 */
		/* 82243624h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82243624h case    2:*/		return 0x82243628;
		  /* 82243628h */ case    3:  		/* cmpwi CR6, R26, 3 */
		/* 82243628h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000003);
		/* 82243628h case    3:*/		return 0x8224362C;
		  /* 8224362Ch */ case    4:  		/* addi R31, R11, 27460 */
		/* 8224362Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x6B44);
		/* 8224362Ch case    4:*/		return 0x82243630;
		  /* 82243630h */ case    5:  		/* addi R29, R10, 10344 */
		/* 82243630h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0x2868);
		/* 82243630h case    5:*/		return 0x82243634;
		  /* 82243634h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 82243634h case    6:*/		if ( regs.CR[6].eq ) { return 0x82243654;  }
		/* 82243634h case    6:*/		return 0x82243638;
		  /* 82243638h */ case    7:  		/* lis R11, -32252 */
		/* 82243638h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243638h case    7:*/		return 0x8224363C;
		  /* 8224363Ch */ case    8:  		/* mr R6, R29 */
		/* 8224363Ch case    8:*/		regs.R6 = regs.R29;
		/* 8224363Ch case    8:*/		return 0x82243640;
		  /* 82243640h */ case    9:  		/* addi R5, R11, 12304 */
		/* 82243640h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3010);
		/* 82243640h case    9:*/		return 0x82243644;
		  /* 82243644h */ case   10:  		/* mr R4, R31 */
		/* 82243644h case   10:*/		regs.R4 = regs.R31;
		/* 82243644h case   10:*/		return 0x82243648;
		  /* 82243648h */ case   11:  		/* li R7, 535 */
		/* 82243648h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x217);
		/* 82243648h case   11:*/		return 0x8224364C;
		  /* 8224364Ch */ case   12:  		/* li R3, 0 */
		/* 8224364Ch case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224364Ch case   12:*/		return 0x82243650;
		  /* 82243650h */ case   13:  		/* bl -965192 */
		/* 82243650h case   13:*/		regs.LR = 0x82243654; return 0x82157C08;
		/* 82243650h case   13:*/		return 0x82243654;
	}
	return 0x82243654;
} // Block from 8224361Ch-82243654h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82243654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243654);
		  /* 82243654h */ case    0:  		/* lwz R3, <#[R30 + 136]> */
		/* 82243654h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000088) );
		/* 82243654h case    0:*/		return 0x82243658;
		  /* 82243658h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 82243658h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82243658h case    1:*/		return 0x8224365C;
		  /* 8224365Ch */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224365Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224365Ch case    2:*/		return 0x82243660;
		  /* 82243660h */ case    3:  		/* mtspr CTR, R11 */
		/* 82243660h case    3:*/		regs.CTR = regs.R11;
		/* 82243660h case    3:*/		return 0x82243664;
		  /* 82243664h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82243664h case    4:*/		if ( 1 ) { regs.LR = 0x82243668; return (uint32)regs.CTR; }
		/* 82243664h case    4:*/		return 0x82243668;
		  /* 82243668h */ case    5:  		/* cmpwi CR6, R3, 1 */
		/* 82243668h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82243668h case    5:*/		return 0x8224366C;
		  /* 8224366Ch */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 8224366Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8224368C;  }
		/* 8224366Ch case    6:*/		return 0x82243670;
		  /* 82243670h */ case    7:  		/* lis R11, -32252 */
		/* 82243670h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243670h case    7:*/		return 0x82243674;
		  /* 82243674h */ case    8:  		/* mr R6, R29 */
		/* 82243674h case    8:*/		regs.R6 = regs.R29;
		/* 82243674h case    8:*/		return 0x82243678;
		  /* 82243678h */ case    9:  		/* addi R5, R11, 12264 */
		/* 82243678h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2FE8);
		/* 82243678h case    9:*/		return 0x8224367C;
		  /* 8224367Ch */ case   10:  		/* mr R4, R31 */
		/* 8224367Ch case   10:*/		regs.R4 = regs.R31;
		/* 8224367Ch case   10:*/		return 0x82243680;
		  /* 82243680h */ case   11:  		/* li R7, 538 */
		/* 82243680h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x21A);
		/* 82243680h case   11:*/		return 0x82243684;
		  /* 82243684h */ case   12:  		/* li R3, 0 */
		/* 82243684h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82243684h case   12:*/		return 0x82243688;
		  /* 82243688h */ case   13:  		/* bl -965248 */
		/* 82243688h case   13:*/		regs.LR = 0x8224368C; return 0x82157C08;
		/* 82243688h case   13:*/		return 0x8224368C;
	}
	return 0x8224368C;
} // Block from 82243654h-8224368Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224368Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224368C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224368C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224368C);
		  /* 8224368Ch */ case    0:  		/* lwz R10, <#[R30 + 136]> */
		/* 8224368Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000088) );
		/* 8224368Ch case    0:*/		return 0x82243690;
		  /* 82243690h */ case    1:  		/* lwz R11, <#[R10 + 168]> */
		/* 82243690h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000000A8) );
		/* 82243690h case    1:*/		return 0x82243694;
		  /* 82243694h */ case    2:  		/* cmpwi CR6, R11, 1 */
		/* 82243694h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82243694h case    2:*/		return 0x82243698;
		  /* 82243698h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82243698h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822436A4;  }
		/* 82243698h case    3:*/		return 0x8224369C;
		  /* 8224369Ch */ case    4:  		/* lwz R29, <#[R10 + 236]> */
		/* 8224369Ch case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x000000EC) );
		/* 8224369Ch case    4:*/		return 0x822436A0;
		  /* 822436A0h */ case    5:  		/* b 212 */
		/* 822436A0h case    5:*/		return 0x82243774;
		/* 822436A0h case    5:*/		return 0x822436A4;
	}
	return 0x822436A4;
} // Block from 8224368Ch-822436A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822436A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822436A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822436A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822436A4);
		  /* 822436A4h */ case    0:  		/* cmpwi CR0, R11, 0 */
		/* 822436A4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 822436A4h case    0:*/		return 0x822436A8;
		  /* 822436A8h */ case    1:  		/* bc 12, CR0_EQ, 72 */
		/* 822436A8h case    1:*/		if ( regs.CR[0].eq ) { return 0x822436F0;  }
		/* 822436A8h case    1:*/		return 0x822436AC;
		  /* 822436ACh */ case    2:  		/* cmpwi CR6, R11, 2 */
		/* 822436ACh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 822436ACh case    2:*/		return 0x822436B0;
		  /* 822436B0h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 822436B0h case    3:*/		if ( regs.CR[6].eq ) { return 0x822436E8;  }
		/* 822436B0h case    3:*/		return 0x822436B4;
		  /* 822436B4h */ case    4:  		/* cmpwi CR6, R11, 3 */
		/* 822436B4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 822436B4h case    4:*/		return 0x822436B8;
		  /* 822436B8h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 822436B8h case    5:*/		if ( regs.CR[6].eq ) { return 0x822436E0;  }
		/* 822436B8h case    5:*/		return 0x822436BC;
		  /* 822436BCh */ case    6:  		/* lis R11, -32255 */
		/* 822436BCh case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 822436BCh case    6:*/		return 0x822436C0;
		  /* 822436C0h */ case    7:  		/* mr R6, R29 */
		/* 822436C0h case    7:*/		regs.R6 = regs.R29;
		/* 822436C0h case    7:*/		return 0x822436C4;
		  /* 822436C4h */ case    8:  		/* addi R5, R11, 5216 */
		/* 822436C4h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1460);
		/* 822436C4h case    8:*/		return 0x822436C8;
		  /* 822436C8h */ case    9:  		/* mr R4, R31 */
		/* 822436C8h case    9:*/		regs.R4 = regs.R31;
		/* 822436C8h case    9:*/		return 0x822436CC;
		  /* 822436CCh */ case   10:  		/* li R7, 556 */
		/* 822436CCh case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x22C);
		/* 822436CCh case   10:*/		return 0x822436D0;
		  /* 822436D0h */ case   11:  		/* li R3, 0 */
		/* 822436D0h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822436D0h case   11:*/		return 0x822436D4;
		  /* 822436D4h */ case   12:  		/* bl -965324 */
		/* 822436D4h case   12:*/		regs.LR = 0x822436D8; return 0x82157C08;
		/* 822436D4h case   12:*/		return 0x822436D8;
		  /* 822436D8h */ case   13:  		/* lwz R29, <#[R1 + 80]> */
		/* 822436D8h case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 822436D8h case   13:*/		return 0x822436DC;
		  /* 822436DCh */ case   14:  		/* b 36 */
		/* 822436DCh case   14:*/		return 0x82243700;
		/* 822436DCh case   14:*/		return 0x822436E0;
	}
	return 0x822436E0;
} // Block from 822436A4h-822436E0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822436E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822436E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822436E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822436E0);
		  /* 822436E0h */ case    0:  		/* li R3, 93 */
		/* 822436E0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x5D);
		/* 822436E0h case    0:*/		return 0x822436E4;
		  /* 822436E4h */ case    1:  		/* b 16 */
		/* 822436E4h case    1:*/		return 0x822436F4;
		/* 822436E4h case    1:*/		return 0x822436E8;
	}
	return 0x822436E8;
} // Block from 822436E0h-822436E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822436E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822436E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822436E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822436E8);
		  /* 822436E8h */ case    0:  		/* li R3, 92 */
		/* 822436E8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x5C);
		/* 822436E8h case    0:*/		return 0x822436EC;
		  /* 822436ECh */ case    1:  		/* b 8 */
		/* 822436ECh case    1:*/		return 0x822436F4;
		/* 822436ECh case    1:*/		return 0x822436F0;
	}
	return 0x822436F0;
} // Block from 822436E8h-822436F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822436F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822436F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822436F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822436F0);
		  /* 822436F0h */ case    0:  		/* li R3, 91 */
		/* 822436F0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x5B);
		/* 822436F0h case    0:*/		return 0x822436F4;
	}
	return 0x822436F4;
} // Block from 822436F0h-822436F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822436F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822436F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822436F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822436F4);
		  /* 822436F4h */ case    0:  		/* lwz R4, <#[R30 + 12]> */
		/* 822436F4h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 822436F4h case    0:*/		return 0x822436F8;
		  /* 822436F8h */ case    1:  		/* bl 75832 */
		/* 822436F8h case    1:*/		regs.LR = 0x822436FC; return 0x82255F30;
		/* 822436F8h case    1:*/		return 0x822436FC;
		  /* 822436FCh */ case    2:  		/* mr R29, R3 */
		/* 822436FCh case    2:*/		regs.R29 = regs.R3;
		/* 822436FCh case    2:*/		return 0x82243700;
	}
	return 0x82243700;
} // Block from 822436F4h-82243700h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82243700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243700);
		  /* 82243700h */ case    0:  		/* lwz R11, <#[R30 + 136]> */
		/* 82243700h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000088) );
		/* 82243700h case    0:*/		return 0x82243704;
		  /* 82243704h */ case    1:  		/* li R10, 1 */
		/* 82243704h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82243704h case    1:*/		return 0x82243708;
		  /* 82243708h */ case    2:  		/* li R4, 1 */
		/* 82243708h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243708h case    2:*/		return 0x8224370C;
		  /* 8224370Ch */ case    3:  		/* mr R3, R29 */
		/* 8224370Ch case    3:*/		regs.R3 = regs.R29;
		/* 8224370Ch case    3:*/		return 0x82243710;
		  /* 82243710h */ case    4:  		/* lwz R11, <#[R11 + 132]> */
		/* 82243710h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000084) );
		/* 82243710h case    4:*/		return 0x82243714;
		  /* 82243714h */ case    5:  		/* stw R11, <#[R29 + 132]> */
		/* 82243714h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000084) );
		/* 82243714h case    5:*/		return 0x82243718;
		  /* 82243718h */ case    6:  		/* lwz R11, <#[R30 + 136]> */
		/* 82243718h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000088) );
		/* 82243718h case    6:*/		return 0x8224371C;
		  /* 8224371Ch */ case    7:  		/* lbz R11, <#[R11 + 153]> */
		/* 8224371Ch case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000099) );
		/* 8224371Ch case    7:*/		return 0x82243720;
		  /* 82243720h */ case    8:  		/* add R11, R11, R29 */
		/* 82243720h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82243720h case    8:*/		return 0x82243724;
		  /* 82243724h */ case    9:  		/* stb R10, <#[R11 + 152]> */
		/* 82243724h case    9:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000098) );
		/* 82243724h case    9:*/		return 0x82243728;
		  /* 82243728h */ case   10:  		/* lwz R11, <#[R30 + 136]> */
		/* 82243728h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000088) );
		/* 82243728h case   10:*/		return 0x8224372C;
		  /* 8224372Ch */ case   11:  		/* lwz R5, <#[R11 + 236]> */
		/* 8224372Ch case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x000000EC) );
		/* 8224372Ch case   11:*/		return 0x82243730;
		  /* 82243730h */ case   12:  		/* bl -55264 */
		/* 82243730h case   12:*/		regs.LR = 0x82243734; return 0x82235F50;
		/* 82243730h case   12:*/		return 0x82243734;
		  /* 82243734h */ case   13:  		/* lwz R11, <#[R27 + 136]> */
		/* 82243734h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000088) );
		/* 82243734h case   13:*/		return 0x82243738;
		  /* 82243738h */ case   14:  		/* cmpwi CR6, R11, 0 */
		/* 82243738h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82243738h case   14:*/		return 0x8224373C;
		  /* 8224373Ch */ case   15:  		/* bc 4, CR6_LT, 16 */
		/* 8224373Ch case   15:*/		if ( !regs.CR[6].lt ) { return 0x8224374C;  }
		/* 8224373Ch case   15:*/		return 0x82243740;
		  /* 82243740h */ case   16:  		/* lwz R3, <#[R27 + 140]> */
		/* 82243740h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x0000008C) );
		/* 82243740h case   16:*/		return 0x82243744;
		  /* 82243744h */ case   17:  		/* bl 16420 */
		/* 82243744h case   17:*/		regs.LR = 0x82243748; return 0x82247768;
		/* 82243744h case   17:*/		return 0x82243748;
		  /* 82243748h */ case   18:  		/* stw R3, <#[R27 + 136]> */
		/* 82243748h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x00000088) );
		/* 82243748h case   18:*/		return 0x8224374C;
	}
	return 0x8224374C;
} // Block from 82243700h-8224374Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224374Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224374C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224374C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224374C);
		  /* 8224374Ch */ case    0:  		/* lwz R11, <#[R27 + 136]> */
		/* 8224374Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000088) );
		/* 8224374Ch case    0:*/		return 0x82243750;
		  /* 82243750h */ case    1:  		/* mr R4, R29 */
		/* 82243750h case    1:*/		regs.R4 = regs.R29;
		/* 82243750h case    1:*/		return 0x82243754;
		  /* 82243754h */ case    2:  		/* lwz R10, <#[R29 + 228]> */
		/* 82243754h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x000000E4) );
		/* 82243754h case    2:*/		return 0x82243758;
		  /* 82243758h */ case    3:  		/* mr R3, R30 */
		/* 82243758h case    3:*/		regs.R3 = regs.R30;
		/* 82243758h case    3:*/		return 0x8224375C;
		  /* 8224375Ch */ case    4:  		/* stw R25, <#[R29 + 80]> */
		/* 8224375Ch case    4:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R29 + 0x00000050) );
		/* 8224375Ch case    4:*/		return 0x82243760;
		  /* 82243760h */ case    5:  		/* rlwinm R10, R10, 0, 30, 28 */
		/* 82243760h case    5:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R10,regs.R10);
		/* 82243760h case    5:*/		return 0x82243764;
		  /* 82243764h */ case    6:  		/* stw R26, <#[R29 + 52]> */
		/* 82243764h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R29 + 0x00000034) );
		/* 82243764h case    6:*/		return 0x82243768;
		  /* 82243768h */ case    7:  		/* stw R11, <#[R29 + 56]> */
		/* 82243768h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000038) );
		/* 82243768h case    7:*/		return 0x8224376C;
		  /* 8224376Ch */ case    8:  		/* stw R10, <#[R29 + 228]> */
		/* 8224376Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x000000E4) );
		/* 8224376Ch case    8:*/		return 0x82243770;
		  /* 82243770h */ case    9:  		/* bl 88000 */
		/* 82243770h case    9:*/		regs.LR = 0x82243774; return 0x82258F30;
		/* 82243770h case    9:*/		return 0x82243774;
	}
	return 0x82243774;
} // Block from 8224374Ch-82243774h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82243774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243774);
		  /* 82243774h */ case    0:  		/* mr R3, R27 */
		/* 82243774h case    0:*/		regs.R3 = regs.R27;
		/* 82243774h case    0:*/		return 0x82243778;
		  /* 82243778h */ case    1:  		/* bl -19296 */
		/* 82243778h case    1:*/		regs.LR = 0x8224377C; return 0x8223EC18;
		/* 82243778h case    1:*/		return 0x8224377C;
		  /* 8224377Ch */ case    2:  		/* mr R11, R3 */
		/* 8224377Ch case    2:*/		regs.R11 = regs.R3;
		/* 8224377Ch case    2:*/		return 0x82243780;
		  /* 82243780h */ case    3:  		/* li R3, 19 */
		/* 82243780h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x13);
		/* 82243780h case    3:*/		return 0x82243784;
		  /* 82243784h */ case    4:  		/* lwz R4, <#[R30 + 12]> */
		/* 82243784h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 82243784h case    4:*/		return 0x82243788;
		  /* 82243788h */ case    5:  		/* lwz R28, <#[R11 + 56]> */
		/* 82243788h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000038) );
		/* 82243788h case    5:*/		return 0x8224378C;
		  /* 8224378Ch */ case    6:  		/* bl 75684 */
		/* 8224378Ch case    6:*/		regs.LR = 0x82243790; return 0x82255F30;
		/* 8224378Ch case    6:*/		return 0x82243790;
		  /* 82243790h */ case    7:  		/* mr R5, R29 */
		/* 82243790h case    7:*/		regs.R5 = regs.R29;
		/* 82243790h case    7:*/		return 0x82243794;
		  /* 82243794h */ case    8:  		/* li R4, 1 */
		/* 82243794h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243794h case    8:*/		return 0x82243798;
		  /* 82243798h */ case    9:  		/* mr R31, R3 */
		/* 82243798h case    9:*/		regs.R31 = regs.R3;
		/* 82243798h case    9:*/		return 0x8224379C;
		  /* 8224379Ch */ case   10:  		/* bl -55372 */
		/* 8224379Ch case   10:*/		regs.LR = 0x822437A0; return 0x82235F50;
		/* 8224379Ch case   10:*/		return 0x822437A0;
		  /* 822437A0h */ case   11:  		/* lbz R11, <#[R24]> */
		/* 822437A0h case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 822437A0h case   11:*/		return 0x822437A4;
		  /* 822437A4h */ case   12:  		/* lwz R4, <#[R30 + 16]> */
		/* 822437A4h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000010) );
		/* 822437A4h case   12:*/		return 0x822437A8;
		  /* 822437A8h */ case   13:  		/* li R5, 2 */
		/* 822437A8h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 822437A8h case   13:*/		return 0x822437AC;
		  /* 822437ACh */ case   14:  		/* cmplwi CR0, R11, 0 */
		/* 822437ACh case   14:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822437ACh case   14:*/		return 0x822437B0;
		  /* 822437B0h */ case   15:  		/* mr R3, R31 */
		/* 822437B0h case   15:*/		regs.R3 = regs.R31;
		/* 822437B0h case   15:*/		return 0x822437B4;
		  /* 822437B4h */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 822437B4h case   16:*/		if ( regs.CR[0].eq ) { return 0x822437C4;  }
		/* 822437B4h case   16:*/		return 0x822437B8;
		  /* 822437B8h */ case   17:  		/* lis R11, -32252 */
		/* 822437B8h case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822437B8h case   17:*/		return 0x822437BC;
		  /* 822437BCh */ case   18:  		/* lfs FR4, <#[R11 - 25384]> */
		/* 822437BCh case   18:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R11 + 0xFFFF9CD8) );
		/* 822437BCh case   18:*/		return 0x822437C0;
		  /* 822437C0h */ case   19:  		/* b 12 */
		/* 822437C0h case   19:*/		return 0x822437CC;
		/* 822437C0h case   19:*/		return 0x822437C4;
	}
	return 0x822437C4;
} // Block from 82243774h-822437C4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822437C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822437C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822437C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822437C4);
		  /* 822437C4h */ case    0:  		/* lis R11, -32252 */
		/* 822437C4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822437C4h case    0:*/		return 0x822437C8;
		  /* 822437C8h */ case    1:  		/* lfs FR4, <#[R11 + 12300]> */
		/* 822437C8h case    1:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R11 + 0x0000300C) );
		/* 822437C8h case    1:*/		return 0x822437CC;
	}
	return 0x822437CC;
} // Block from 822437C4h-822437CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822437CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822437CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822437CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822437CC);
		  /* 822437CCh */ case    0:  		/* fmr FR2, FR4 */
		/* 822437CCh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 822437CCh case    0:*/		return 0x822437D0;
		  /* 822437D0h */ case    1:  		/* fmr FR3, FR4 */
		/* 822437D0h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 822437D0h case    1:*/		return 0x822437D4;
		  /* 822437D4h */ case    2:  		/* fmr FR1, FR4 */
		/* 822437D4h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 822437D4h case    2:*/		return 0x822437D8;
		  /* 822437D8h */ case    3:  		/* bl 79680 */
		/* 822437D8h case    3:*/		regs.LR = 0x822437DC; return 0x82256F18;
		/* 822437D8h case    3:*/		return 0x822437DC;
		  /* 822437DCh */ case    4:  		/* lis R11, -32252 */
		/* 822437DCh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822437DCh case    4:*/		return 0x822437E0;
		  /* 822437E0h */ case    5:  		/* stw R28, <#[R31 + 56]> */
		/* 822437E0h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000038) );
		/* 822437E0h case    5:*/		return 0x822437E4;
		  /* 822437E4h */ case    6:  		/* stw R25, <#[R31 + 80]> */
		/* 822437E4h case    6:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000050) );
		/* 822437E4h case    6:*/		return 0x822437E8;
		  /* 822437E8h */ case    7:  		/* mr R4, R31 */
		/* 822437E8h case    7:*/		regs.R4 = regs.R31;
		/* 822437E8h case    7:*/		return 0x822437EC;
		  /* 822437ECh */ case    8:  		/* addi R28, R11, 9936 */
		/* 822437ECh case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x26D0);
		/* 822437ECh case    8:*/		return 0x822437F0;
		  /* 822437F0h */ case    9:  		/* mr R3, R30 */
		/* 822437F0h case    9:*/		regs.R3 = regs.R30;
		/* 822437F0h case    9:*/		return 0x822437F4;
		  /* 822437F4h */ case   10:  		/* lwz R11, <#[R28 - 12]> */
		/* 822437F4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFFFFF4) );
		/* 822437F4h case   10:*/		return 0x822437F8;
		  /* 822437F8h */ case   11:  		/* stw R11, <#[R31 + 128]> */
		/* 822437F8h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 822437F8h case   11:*/		return 0x822437FC;
		  /* 822437FCh */ case   12:  		/* lwz R11, <#[R31 + 228]> */
		/* 822437FCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 822437FCh case   12:*/		return 0x82243800;
		  /* 82243800h */ case   13:  		/* ori R11, R11, 4 */
		/* 82243800h case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82243800h case   13:*/		return 0x82243804;
		  /* 82243804h */ case   14:  		/* stw R26, <#[R31 + 52]> */
		/* 82243804h case   14:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000034) );
		/* 82243804h case   14:*/		return 0x82243808;
		  /* 82243808h */ case   15:  		/* stw R11, <#[R31 + 228]> */
		/* 82243808h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82243808h case   15:*/		return 0x8224380C;
		  /* 8224380Ch */ case   16:  		/* bl 87844 */
		/* 8224380Ch case   16:*/		regs.LR = 0x82243810; return 0x82258F30;
		/* 8224380Ch case   16:*/		return 0x82243810;
		  /* 82243810h */ case   17:  		/* li R3, 90 */
		/* 82243810h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x5A);
		/* 82243810h case   17:*/		return 0x82243814;
		  /* 82243814h */ case   18:  		/* lwz R4, <#[R30 + 12]> */
		/* 82243814h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 82243814h case   18:*/		return 0x82243818;
		  /* 82243818h */ case   19:  		/* bl 75544 */
		/* 82243818h case   19:*/		regs.LR = 0x8224381C; return 0x82255F30;
		/* 82243818h case   19:*/		return 0x8224381C;
		  /* 8224381Ch */ case   20:  		/* lwz R11, <#[R27 + 136]> */
		/* 8224381Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000088) );
		/* 8224381Ch case   20:*/		return 0x82243820;
		  /* 82243820h */ case   21:  		/* mr R31, R3 */
		/* 82243820h case   21:*/		regs.R31 = regs.R3;
		/* 82243820h case   21:*/		return 0x82243824;
		  /* 82243824h */ case   22:  		/* cmpwi CR6, R11, 0 */
		/* 82243824h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82243824h case   22:*/		return 0x82243828;
		  /* 82243828h */ case   23:  		/* bc 4, CR6_LT, 16 */
		/* 82243828h case   23:*/		if ( !regs.CR[6].lt ) { return 0x82243838;  }
		/* 82243828h case   23:*/		return 0x8224382C;
		  /* 8224382Ch */ case   24:  		/* lwz R3, <#[R27 + 140]> */
		/* 8224382Ch case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x0000008C) );
		/* 8224382Ch case   24:*/		return 0x82243830;
		  /* 82243830h */ case   25:  		/* bl 16184 */
		/* 82243830h case   25:*/		regs.LR = 0x82243834; return 0x82247768;
		/* 82243830h case   25:*/		return 0x82243834;
		  /* 82243834h */ case   26:  		/* stw R3, <#[R27 + 136]> */
		/* 82243834h case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x00000088) );
		/* 82243834h case   26:*/		return 0x82243838;
	}
	return 0x82243838;
} // Block from 822437CCh-82243838h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82243838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243838);
		  /* 82243838h */ case    0:  		/* lwz R10, <#[R27 + 136]> */
		/* 82243838h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000088) );
		/* 82243838h case    0:*/		return 0x8224383C;
		  /* 8224383Ch */ case    1:  		/* mr R5, R29 */
		/* 8224383Ch case    1:*/		regs.R5 = regs.R29;
		/* 8224383Ch case    1:*/		return 0x82243840;
		  /* 82243840h */ case    2:  		/* lwz R11, <#[R28 - 12]> */
		/* 82243840h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFFFFF4) );
		/* 82243840h case    2:*/		return 0x82243844;
		  /* 82243844h */ case    3:  		/* li R4, 1 */
		/* 82243844h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243844h case    3:*/		return 0x82243848;
		  /* 82243848h */ case    4:  		/* stw R25, <#[R31 + 80]> */
		/* 82243848h case    4:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000050) );
		/* 82243848h case    4:*/		return 0x8224384C;
		  /* 8224384Ch */ case    5:  		/* mr R3, R31 */
		/* 8224384Ch case    5:*/		regs.R3 = regs.R31;
		/* 8224384Ch case    5:*/		return 0x82243850;
		  /* 82243850h */ case    6:  		/* stw R10, <#[R31 + 56]> */
		/* 82243850h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 82243850h case    6:*/		return 0x82243854;
		  /* 82243854h */ case    7:  		/* stw R11, <#[R31 + 128]> */
		/* 82243854h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 82243854h case    7:*/		return 0x82243858;
		  /* 82243858h */ case    8:  		/* bl -55560 */
		/* 82243858h case    8:*/		regs.LR = 0x8224385C; return 0x82235F50;
		/* 82243858h case    8:*/		return 0x8224385C;
		  /* 8224385Ch */ case    9:  		/* lwz R11, <#[R28]> */
		/* 8224385Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8224385Ch case    9:*/		return 0x82243860;
		  /* 82243860h */ case   10:  		/* mr R4, R31 */
		/* 82243860h case   10:*/		regs.R4 = regs.R31;
		/* 82243860h case   10:*/		return 0x82243864;
		  /* 82243864h */ case   11:  		/* mr R3, R30 */
		/* 82243864h case   11:*/		regs.R3 = regs.R30;
		/* 82243864h case   11:*/		return 0x82243868;
		  /* 82243868h */ case   12:  		/* stw R11, <#[R31 + 132]> */
		/* 82243868h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 82243868h case   12:*/		return 0x8224386C;
		  /* 8224386Ch */ case   13:  		/* stw R26, <#[R31 + 52]> */
		/* 8224386Ch case   13:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000034) );
		/* 8224386Ch case   13:*/		return 0x82243870;
		  /* 82243870h */ case   14:  		/* lwz R11, <#[R31 + 228]> */
		/* 82243870h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82243870h case   14:*/		return 0x82243874;
		  /* 82243874h */ case   15:  		/* rlwinm R11, R11, 0, 30, 28 */
		/* 82243874h case   15:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R11,regs.R11);
		/* 82243874h case   15:*/		return 0x82243878;
		  /* 82243878h */ case   16:  		/* stw R11, <#[R31 + 228]> */
		/* 82243878h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82243878h case   16:*/		return 0x8224387C;
		  /* 8224387Ch */ case   17:  		/* bl 87732 */
		/* 8224387Ch case   17:*/		regs.LR = 0x82243880; return 0x82258F30;
		/* 8224387Ch case   17:*/		return 0x82243880;
		  /* 82243880h */ case   18:  		/* lwz R3, <#[R30 + 136]> */
		/* 82243880h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000088) );
		/* 82243880h case   18:*/		return 0x82243884;
		  /* 82243884h */ case   19:  		/* bl 65300 */
		/* 82243884h case   19:*/		regs.LR = 0x82243888; return 0x82253798;
		/* 82243884h case   19:*/		return 0x82243888;
	}
	return 0x82243888;
} // Block from 82243838h-82243888h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82243888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243888);
		  /* 82243888h */ case    0:  		/* addi R4, R30, 20 */
		/* 82243888h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x14);
		/* 82243888h case    0:*/		return 0x8224388C;
		  /* 8224388Ch */ case    1:  		/* lbz R5, <#[R30 + 124]> */
		/* 8224388Ch case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000007C) );
		/* 8224388Ch case    1:*/		return 0x82243890;
		  /* 82243890h */ case    2:  		/* mr R3, R27 */
		/* 82243890h case    2:*/		regs.R3 = regs.R27;
		/* 82243890h case    2:*/		return 0x82243894;
		  /* 82243894h */ case    3:  		/* bl -8164 */
		/* 82243894h case    3:*/		regs.LR = 0x82243898; return 0x822418B0;
		/* 82243894h case    3:*/		return 0x82243898;
		  /* 82243898h */ case    4:  		/* mr R4, R27 */
		/* 82243898h case    4:*/		regs.R4 = regs.R27;
		/* 82243898h case    4:*/		return 0x8224389C;
		  /* 8224389Ch */ case    5:  		/* lwz R3, <#[R30 + 152]> */
		/* 8224389Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000098) );
		/* 8224389Ch case    5:*/		return 0x822438A0;
		  /* 822438A0h */ case    6:  		/* bl -1712 */
		/* 822438A0h case    6:*/		regs.LR = 0x822438A4; return 0x822431F0;
		/* 822438A0h case    6:*/		return 0x822438A4;
		  /* 822438A4h */ case    7:  		/* addi R1, R1, 160 */
		/* 822438A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 822438A4h case    7:*/		return 0x822438A8;
		  /* 822438A8h */ case    8:  		/* b -1779216 */
		/* 822438A8h case    8:*/		return 0x82091298;
		/* 822438A8h case    8:*/		return 0x822438AC;
		  /* 822438ACh */ case    9:  		/* nop */
		/* 822438ACh case    9:*/		cpu::op::nop();
		/* 822438ACh case    9:*/		return 0x822438B0;
	}
	return 0x822438B0;
} // Block from 82243888h-822438B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822438B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822438B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822438B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822438B0);
		  /* 822438B0h */ case    0:  		/* mfspr R12, LR */
		/* 822438B0h case    0:*/		regs.R12 = regs.LR;
		/* 822438B0h case    0:*/		return 0x822438B4;
		  /* 822438B4h */ case    1:  		/* bl -1779300 */
		/* 822438B4h case    1:*/		regs.LR = 0x822438B8; return 0x82091250;
		/* 822438B4h case    1:*/		return 0x822438B8;
		  /* 822438B8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 822438B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822438B8h case    2:*/		return 0x822438BC;
		  /* 822438BCh */ case    3:  		/* mr R27, R3 */
		/* 822438BCh case    3:*/		regs.R27 = regs.R3;
		/* 822438BCh case    3:*/		return 0x822438C0;
		  /* 822438C0h */ case    4:  		/* lwz R3, <#[R4 + 100]> */
		/* 822438C0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000064) );
		/* 822438C0h case    4:*/		return 0x822438C4;
		  /* 822438C4h */ case    5:  		/* mr R26, R4 */
		/* 822438C4h case    5:*/		regs.R26 = regs.R4;
		/* 822438C4h case    5:*/		return 0x822438C8;
		  /* 822438C8h */ case    6:  		/* bl 95368 */
		/* 822438C8h case    6:*/		regs.LR = 0x822438CC; return 0x8225AD50;
		/* 822438C8h case    6:*/		return 0x822438CC;
		  /* 822438CCh */ case    7:  		/* lwz R11, <#[R27 + 16]> */
		/* 822438CCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 822438CCh case    7:*/		return 0x822438D0;
	}
	return 0x822438D0;
} // Block from 822438B0h-822438D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822438D0h
// Function '?Assemble@IRMov@XGRAPHICS@@UAAXPAVAssembler@2@PADPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822438D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822438D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822438D0);
		  /* 822438D0h */ case    0:  		/* lbz R11, <#[R11]> */
		/* 822438D0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822438D0h case    0:*/		return 0x822438D4;
		  /* 822438D4h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 822438D4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822438D4h case    1:*/		return 0x822438D8;
		  /* 822438D8h */ case    2:  		/* bc 4, CR0_EQ, 256 */
		/* 822438D8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x822439D8;  }
		/* 822438D8h case    2:*/		return 0x822438DC;
		  /* 822438DCh */ case    3:  		/* lwz R9, <#[R26 + 100]> */
		/* 822438DCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000064) );
		/* 822438DCh case    3:*/		return 0x822438E0;
		  /* 822438E0h */ case    4:  		/* lwz R10, <#[R9 + 4]> */
		/* 822438E0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 822438E0h case    4:*/		return 0x822438E4;
		  /* 822438E4h */ case    5:  		/* addi R11, R10, -1 */
		/* 822438E4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 822438E4h case    5:*/		return 0x822438E8;
		  /* 822438E8h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 822438E8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822438E8h case    6:*/		return 0x822438EC;
		  /* 822438ECh */ case    7:  		/* bc 4, CR6_LT, 20 */
		/* 822438ECh case    7:*/		if ( !regs.CR[6].lt ) { return 0x82243900;  }
		/* 822438ECh case    7:*/		return 0x822438F0;
		  /* 822438F0h */ case    8:  		/* lwz R10, <#[R9 + 8]> */
		/* 822438F0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 822438F0h case    8:*/		return 0x822438F4;
		  /* 822438F4h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822438F4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822438F4h case    9:*/		return 0x822438F8;
		  /* 822438F8h */ case   10:  		/* add R11, R11, R10 */
		/* 822438F8h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822438F8h case   10:*/		return 0x822438FC;
		  /* 822438FCh */ case   11:  		/* b 8 */
		/* 822438FCh case   11:*/		return 0x82243904;
		/* 822438FCh case   11:*/		return 0x82243900;
	}
	return 0x82243900;
} // Block from 822438D0h-82243900h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82243900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243900);
		  /* 82243900h */ case    0:  		/* li R11, 0 */
		/* 82243900h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82243900h case    0:*/		return 0x82243904;
	}
	return 0x82243904;
} // Block from 82243900h-82243904h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82243904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243904);
		  /* 82243904h */ case    0:  		/* lwz R8, <#[R11]> */
		/* 82243904h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82243904h case    0:*/		return 0x82243908;
		  /* 82243908h */ case    1:  		/* lis R10, -32253 */
		/* 82243908h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8203);
		/* 82243908h case    1:*/		return 0x8224390C;
		  /* 8224390Ch */ case    2:  		/* lis R11, -32252 */
		/* 8224390Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224390Ch case    2:*/		return 0x82243910;
		  /* 82243910h */ case    3:  		/* li R31, 1 */
		/* 82243910h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 82243910h case    3:*/		return 0x82243914;
		  /* 82243914h */ case    4:  		/* cmpwi CR6, R8, 0 */
		/* 82243914h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 82243914h case    4:*/		return 0x82243918;
		  /* 82243918h */ case    5:  		/* addi R29, R10, 27460 */
		/* 82243918h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0x6B44);
		/* 82243918h case    5:*/		return 0x8224391C;
		  /* 8224391Ch */ case    6:  		/* addi R28, R11, 10344 */
		/* 8224391Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x2868);
		/* 8224391Ch case    6:*/		return 0x82243920;
		  /* 82243920h */ case    7:  		/* bc 4, CR6_EQ, 48 */
		/* 82243920h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82243950;  }
		/* 82243920h case    7:*/		return 0x82243924;
		  /* 82243924h */ case    8:  		/* lwz R11, <#[R9 + 4]> */
		/* 82243924h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82243924h case    8:*/		return 0x82243928;
		  /* 82243928h */ case    9:  		/* li R31, 0 */
		/* 82243928h case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82243928h case    9:*/		return 0x8224392C;
		  /* 8224392Ch */ case   10:  		/* cmplwi CR6, R11, 1 */
		/* 8224392Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8224392Ch case   10:*/		return 0x82243930;
		  /* 82243930h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 82243930h case   11:*/		if ( regs.CR[6].eq ) { return 0x82243950;  }
		/* 82243930h case   11:*/		return 0x82243934;
		  /* 82243934h */ case   12:  		/* lis R11, -32252 */
		/* 82243934h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243934h case   12:*/		return 0x82243938;
		  /* 82243938h */ case   13:  		/* mr R6, R28 */
		/* 82243938h case   13:*/		regs.R6 = regs.R28;
		/* 82243938h case   13:*/		return 0x8224393C;
		  /* 8224393Ch */ case   14:  		/* addi R5, R11, 12168 */
		/* 8224393Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2F88);
		/* 8224393Ch case   14:*/		return 0x82243940;
		  /* 82243940h */ case   15:  		/* mr R4, R29 */
		/* 82243940h case   15:*/		regs.R4 = regs.R29;
		/* 82243940h case   15:*/		return 0x82243944;
		  /* 82243944h */ case   16:  		/* li R7, 635 */
		/* 82243944h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x27B);
		/* 82243944h case   16:*/		return 0x82243948;
		  /* 82243948h */ case   17:  		/* li R3, 0 */
		/* 82243948h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82243948h case   17:*/		return 0x8224394C;
		  /* 8224394Ch */ case   18:  		/* bl -965956 */
		/* 8224394Ch case   18:*/		regs.LR = 0x82243950; return 0x82157C08;
		/* 8224394Ch case   18:*/		return 0x82243950;
	}
	return 0x82243950;
} // Block from 82243904h-82243950h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82243950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243950);
		  /* 82243950h */ case    0:  		/* rlwinm. R11, R31, 0, 24, 31 */
		/* 82243950h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R31);
		/* 82243950h case    0:*/		return 0x82243954;
		  /* 82243954h */ case    1:  		/* bc 12, CR0_EQ, 132 */
		/* 82243954h case    1:*/		if ( regs.CR[0].eq ) { return 0x822439D8;  }
		/* 82243954h case    1:*/		return 0x82243958;
		  /* 82243958h */ case    2:  		/* li R3, 88 */
		/* 82243958h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x58);
		/* 82243958h case    2:*/		return 0x8224395C;
		  /* 8224395Ch */ case    3:  		/* lwz R4, <#[R27 + 12]> */
		/* 8224395Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x0000000C) );
		/* 8224395Ch case    3:*/		return 0x82243960;
		  /* 82243960h */ case    4:  		/* bl 75216 */
		/* 82243960h case    4:*/		regs.LR = 0x82243964; return 0x82255F30;
		/* 82243960h case    4:*/		return 0x82243964;
		  /* 82243964h */ case    5:  		/* mr R31, R3 */
		/* 82243964h case    5:*/		regs.R31 = regs.R3;
		/* 82243964h case    5:*/		return 0x82243968;
		  /* 82243968h */ case    6:  		/* mr R3, R26 */
		/* 82243968h case    6:*/		regs.R3 = regs.R26;
		/* 82243968h case    6:*/		return 0x8224396C;
		  /* 8224396Ch */ case    7:  		/* bl -19796 */
		/* 8224396Ch case    7:*/		regs.LR = 0x82243970; return 0x8223EC18;
		/* 8224396Ch case    7:*/		return 0x82243970;
		  /* 82243970h */ case    8:  		/* or. R30, R3, R3 */
		/* 82243970h case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82243970h case    8:*/		return 0x82243974;
		  /* 82243974h */ case    9:  		/* bc 4, CR0_EQ, 32 */
		/* 82243974h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82243994;  }
		/* 82243974h case    9:*/		return 0x82243978;
		  /* 82243978h */ case   10:  		/* lis R11, -32252 */
		/* 82243978h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243978h case   10:*/		return 0x8224397C;
		  /* 8224397Ch */ case   11:  		/* mr R6, R28 */
		/* 8224397Ch case   11:*/		regs.R6 = regs.R28;
		/* 8224397Ch case   11:*/		return 0x82243980;
		  /* 82243980h */ case   12:  		/* addi R5, R11, 12152 */
		/* 82243980h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2F78);
		/* 82243980h case   12:*/		return 0x82243984;
		  /* 82243984h */ case   13:  		/* mr R4, R29 */
		/* 82243984h case   13:*/		regs.R4 = regs.R29;
		/* 82243984h case   13:*/		return 0x82243988;
		  /* 82243988h */ case   14:  		/* li R7, 642 */
		/* 82243988h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x282);
		/* 82243988h case   14:*/		return 0x8224398C;
		  /* 8224398Ch */ case   15:  		/* li R3, 0 */
		/* 8224398Ch case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224398Ch case   15:*/		return 0x82243990;
		  /* 82243990h */ case   16:  		/* bl -966024 */
		/* 82243990h case   16:*/		regs.LR = 0x82243994; return 0x82157C08;
		/* 82243990h case   16:*/		return 0x82243994;
	}
	return 0x82243994;
} // Block from 82243950h-82243994h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82243994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243994);
		  /* 82243994h */ case    0:  		/* lis R29, -32252 */
		/* 82243994h case    0:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8204);
		/* 82243994h case    0:*/		return 0x82243998;
		  /* 82243998h */ case    1:  		/* lwz R11, <#[R30 + 56]> */
		/* 82243998h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 82243998h case    1:*/		return 0x8224399C;
		  /* 8224399Ch */ case    2:  		/* li R10, 0 */
		/* 8224399Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8224399Ch case    2:*/		return 0x822439A0;
		  /* 822439A0h */ case    3:  		/* addi R9, R29, 9936 */
		/* 822439A0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R29,0x26D0);
		/* 822439A0h case    3:*/		return 0x822439A4;
		  /* 822439A4h */ case    4:  		/* stw R10, <#[R31 + 80]> */
		/* 822439A4h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 822439A4h case    4:*/		return 0x822439A8;
		  /* 822439A8h */ case    5:  		/* mr R5, R30 */
		/* 822439A8h case    5:*/		regs.R5 = regs.R30;
		/* 822439A8h case    5:*/		return 0x822439AC;
		  /* 822439ACh */ case    6:  		/* li R4, 1 */
		/* 822439ACh case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822439ACh case    6:*/		return 0x822439B0;
		  /* 822439B0h */ case    7:  		/* stw R11, <#[R31 + 56]> */
		/* 822439B0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 822439B0h case    7:*/		return 0x822439B4;
		  /* 822439B4h */ case    8:  		/* mr R3, R31 */
		/* 822439B4h case    8:*/		regs.R3 = regs.R31;
		/* 822439B4h case    8:*/		return 0x822439B8;
		  /* 822439B8h */ case    9:  		/* lwz R11, <#[R9 - 12]> */
		/* 822439B8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0xFFFFFFF4) );
		/* 822439B8h case    9:*/		return 0x822439BC;
		  /* 822439BCh */ case   10:  		/* stw R11, <#[R31 + 128]> */
		/* 822439BCh case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 822439BCh case   10:*/		return 0x822439C0;
		  /* 822439C0h */ case   11:  		/* bl -55920 */
		/* 822439C0h case   11:*/		regs.LR = 0x822439C4; return 0x82235F50;
		/* 822439C0h case   11:*/		return 0x822439C4;
		  /* 822439C4h */ case   12:  		/* lwz R11, <#[R29 + 9936]> */
		/* 822439C4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000026D0) );
		/* 822439C4h case   12:*/		return 0x822439C8;
		  /* 822439C8h */ case   13:  		/* mr R4, R31 */
		/* 822439C8h case   13:*/		regs.R4 = regs.R31;
		/* 822439C8h case   13:*/		return 0x822439CC;
		  /* 822439CCh */ case   14:  		/* mr R3, R27 */
		/* 822439CCh case   14:*/		regs.R3 = regs.R27;
		/* 822439CCh case   14:*/		return 0x822439D0;
		  /* 822439D0h */ case   15:  		/* stw R11, <#[R31 + 132]> */
		/* 822439D0h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 822439D0h case   15:*/		return 0x822439D4;
		  /* 822439D4h */ case   16:  		/* bl 87460 */
		/* 822439D4h case   16:*/		regs.LR = 0x822439D8; return 0x82258F78;
		/* 822439D4h case   16:*/		return 0x822439D8;
	}
	return 0x822439D8;
} // Block from 82243994h-822439D8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822439D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822439D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822439D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822439D8);
		  /* 822439D8h */ case    0:  		/* addi R4, R27, 20 */
		/* 822439D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R27,0x14);
		/* 822439D8h case    0:*/		return 0x822439DC;
		  /* 822439DCh */ case    1:  		/* lbz R5, <#[R27 + 124]> */
		/* 822439DCh case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000007C) );
		/* 822439DCh case    1:*/		return 0x822439E0;
		  /* 822439E0h */ case    2:  		/* mr R3, R26 */
		/* 822439E0h case    2:*/		regs.R3 = regs.R26;
		/* 822439E0h case    2:*/		return 0x822439E4;
		  /* 822439E4h */ case    3:  		/* bl -8500 */
		/* 822439E4h case    3:*/		regs.LR = 0x822439E8; return 0x822418B0;
		/* 822439E4h case    3:*/		return 0x822439E8;
		  /* 822439E8h */ case    4:  		/* addi R1, R1, 144 */
		/* 822439E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 822439E8h case    4:*/		return 0x822439EC;
		  /* 822439ECh */ case    5:  		/* b -1779532 */
		/* 822439ECh case    5:*/		return 0x820912A0;
		/* 822439ECh case    5:*/		return 0x822439F0;
	}
	return 0x822439F0;
} // Block from 822439D8h-822439F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822439F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822439F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822439F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822439F0);
		  /* 822439F0h */ case    0:  		/* mfspr R12, LR */
		/* 822439F0h case    0:*/		regs.R12 = regs.LR;
		/* 822439F0h case    0:*/		return 0x822439F4;
		  /* 822439F4h */ case    1:  		/* bl -1779608 */
		/* 822439F4h case    1:*/		regs.LR = 0x822439F8; return 0x8209125C;
		/* 822439F4h case    1:*/		return 0x822439F8;
		  /* 822439F8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 822439F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822439F8h case    2:*/		return 0x822439FC;
		  /* 822439FCh */ case    3:  		/* lwz R11, <#[R3 + 136]> */
		/* 822439FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000088) );
		/* 822439FCh case    3:*/		return 0x82243A00;
		  /* 82243A00h */ case    4:  		/* mr R31, R3 */
		/* 82243A00h case    4:*/		regs.R31 = regs.R3;
		/* 82243A00h case    4:*/		return 0x82243A04;
		  /* 82243A04h */ case    5:  		/* lwz R10, <#[R3 + 12]> */
		/* 82243A04h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82243A04h case    5:*/		return 0x82243A08;
		  /* 82243A08h */ case    6:  		/* mr R30, R4 */
		/* 82243A08h case    6:*/		regs.R30 = regs.R4;
		/* 82243A08h case    6:*/		return 0x82243A0C;
		  /* 82243A0Ch */ case    7:  		/* lwz R4, <#[R11 + 236]> */
		/* 82243A0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000000EC) );
		/* 82243A0Ch case    7:*/		return 0x82243A10;
		  /* 82243A10h */ case    8:  		/* lwz R3, <#[R10 + 2736]> */
		/* 82243A10h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000AB0) );
		/* 82243A10h case    8:*/		return 0x82243A14;
		  /* 82243A14h */ case    9:  		/* bl 133588 */
		/* 82243A14h case    9:*/		regs.LR = 0x82243A18; return 0x822643E8;
		/* 82243A14h case    9:*/		return 0x82243A18;
		  /* 82243A18h */ case   10:  		/* mr R29, R3 */
		/* 82243A18h case   10:*/		regs.R29 = regs.R3;
		/* 82243A18h case   10:*/		return 0x82243A1C;
		  /* 82243A1Ch */ case   11:  		/* lbz R5, <#[R31 + 124]> */
		/* 82243A1Ch case   11:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000007C) );
		/* 82243A1Ch case   11:*/		return 0x82243A20;
		  /* 82243A20h */ case   12:  		/* mr R3, R30 */
		/* 82243A20h case   12:*/		regs.R3 = regs.R30;
		/* 82243A20h case   12:*/		return 0x82243A24;
		  /* 82243A24h */ case   13:  		/* addi R4, R31, 20 */
		/* 82243A24h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x14);
		/* 82243A24h case   13:*/		return 0x82243A28;
		  /* 82243A28h */ case   14:  		/* bl -8568 */
		/* 82243A28h case   14:*/		regs.LR = 0x82243A2C; return 0x822418B0;
		/* 82243A28h case   14:*/		return 0x82243A2C;
		  /* 82243A2Ch */ case   15:  		/* li R6, 0 */
		/* 82243A2Ch case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82243A2Ch case   15:*/		return 0x82243A30;
		  /* 82243A30h */ case   16:  		/* mr R5, R29 */
		/* 82243A30h case   16:*/		regs.R5 = regs.R29;
		/* 82243A30h case   16:*/		return 0x82243A34;
		  /* 82243A34h */ case   17:  		/* li R4, 0 */
		/* 82243A34h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82243A34h case   17:*/		return 0x82243A38;
		  /* 82243A38h */ case   18:  		/* mr R3, R30 */
		/* 82243A38h case   18:*/		regs.R3 = regs.R30;
		/* 82243A38h case   18:*/		return 0x82243A3C;
		  /* 82243A3Ch */ case   19:  		/* bl -6444 */
		/* 82243A3Ch case   19:*/		regs.LR = 0x82243A40; return 0x82242110;
		/* 82243A3Ch case   19:*/		return 0x82243A40;
		  /* 82243A40h */ case   20:  		/* addi R1, R1, 112 */
		/* 82243A40h case   20:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82243A40h case   20:*/		return 0x82243A44;
		  /* 82243A44h */ case   21:  		/* b -1779608 */
		/* 82243A44h case   21:*/		return 0x820912AC;
		/* 82243A44h case   21:*/		return 0x82243A48;
	}
	return 0x82243A48;
} // Block from 822439F0h-82243A48h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82243A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243A48);
		  /* 82243A48h */ case    0:  		/* mfspr R12, LR */
		/* 82243A48h case    0:*/		regs.R12 = regs.LR;
		/* 82243A48h case    0:*/		return 0x82243A4C;
		  /* 82243A4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82243A4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82243A4Ch case    1:*/		return 0x82243A50;
		  /* 82243A50h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82243A50h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82243A50h case    2:*/		return 0x82243A54;
		  /* 82243A54h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82243A54h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82243A54h case    3:*/		return 0x82243A58;
		  /* 82243A58h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82243A58h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82243A58h case    4:*/		return 0x82243A5C;
		  /* 82243A5Ch */ case    5:  		/* mr R31, R3 */
		/* 82243A5Ch case    5:*/		regs.R31 = regs.R3;
		/* 82243A5Ch case    5:*/		return 0x82243A60;
		  /* 82243A60h */ case    6:  		/* mr R3, R4 */
		/* 82243A60h case    6:*/		regs.R3 = regs.R4;
		/* 82243A60h case    6:*/		return 0x82243A64;
		  /* 82243A64h */ case    7:  		/* mr R30, R4 */
		/* 82243A64h case    7:*/		regs.R30 = regs.R4;
		/* 82243A64h case    7:*/		return 0x82243A68;
		  /* 82243A68h */ case    8:  		/* lwz R4, <#[R4 + 56]> */
		/* 82243A68h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000038) );
		/* 82243A68h case    8:*/		return 0x82243A6C;
		  /* 82243A6Ch */ case    9:  		/* bl -6924 */
		/* 82243A6Ch case    9:*/		regs.LR = 0x82243A70; return 0x82241F60;
		/* 82243A6Ch case    9:*/		return 0x82243A70;
		  /* 82243A70h */ case   10:  		/* addi R4, R31, 20 */
		/* 82243A70h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x14);
		/* 82243A70h case   10:*/		return 0x82243A74;
		  /* 82243A74h */ case   11:  		/* mr R3, R30 */
		/* 82243A74h case   11:*/		regs.R3 = regs.R30;
		/* 82243A74h case   11:*/		return 0x82243A78;
		  /* 82243A78h */ case   12:  		/* lbz R5, <#[R31 + 124]> */
		/* 82243A78h case   12:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000007C) );
		/* 82243A78h case   12:*/		return 0x82243A7C;
		  /* 82243A7Ch */ case   13:  		/* bl -8652 */
		/* 82243A7Ch case   13:*/		regs.LR = 0x82243A80; return 0x822418B0;
		/* 82243A7Ch case   13:*/		return 0x82243A80;
		  /* 82243A80h */ case   14:  		/* addi R1, R1, 112 */
		/* 82243A80h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82243A80h case   14:*/		return 0x82243A84;
		  /* 82243A84h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 82243A84h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82243A84h case   15:*/		return 0x82243A88;
		  /* 82243A88h */ case   16:  		/* mtspr LR, R12 */
		/* 82243A88h case   16:*/		regs.LR = regs.R12;
		/* 82243A88h case   16:*/		return 0x82243A8C;
		  /* 82243A8Ch */ case   17:  		/* ld R30, <#[R1 - 24]> */
		/* 82243A8Ch case   17:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82243A8Ch case   17:*/		return 0x82243A90;
		  /* 82243A90h */ case   18:  		/* ld R31, <#[R1 - 16]> */
		/* 82243A90h case   18:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82243A90h case   18:*/		return 0x82243A94;
		  /* 82243A94h */ case   19:  		/* bclr 20, CR0_LT */
		/* 82243A94h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82243A94h case   19:*/		return 0x82243A98;
	}
	return 0x82243A98;
} // Block from 82243A48h-82243A98h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82243A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243A98);
		  /* 82243A98h */ case    0:  		/* mfspr R12, LR */
		/* 82243A98h case    0:*/		regs.R12 = regs.LR;
		/* 82243A98h case    0:*/		return 0x82243A9C;
		  /* 82243A9Ch */ case    1:  		/* bl -1779792 */
		/* 82243A9Ch case    1:*/		regs.LR = 0x82243AA0; return 0x8209124C;
		/* 82243A9Ch case    1:*/		return 0x82243AA0;
		  /* 82243AA0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82243AA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82243AA0h case    2:*/		return 0x82243AA4;
		  /* 82243AA4h */ case    3:  		/* lbz R11, <#[R3 + 140]> */
		/* 82243AA4h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000008C) );
		/* 82243AA4h case    3:*/		return 0x82243AA8;
		  /* 82243AA8h */ case    4:  		/* mr R29, R3 */
		/* 82243AA8h case    4:*/		regs.R29 = regs.R3;
		/* 82243AA8h case    4:*/		return 0x82243AAC;
		  /* 82243AACh */ case    5:  		/* mr R28, R4 */
		/* 82243AACh case    5:*/		regs.R28 = regs.R4;
		/* 82243AACh case    5:*/		return 0x82243AB0;
		  /* 82243AB0h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 82243AB0h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82243AB0h case    6:*/		return 0x82243AB4;
		  /* 82243AB4h */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 82243AB4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82243AC4;  }
		/* 82243AB4h case    7:*/		return 0x82243AB8;
		  /* 82243AB8h */ case    8:  		/* lbz R11, <#[R3 + 141]> */
		/* 82243AB8h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000008D) );
		/* 82243AB8h case    8:*/		return 0x82243ABC;
		  /* 82243ABCh */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 82243ABCh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82243ABCh case    9:*/		return 0x82243AC0;
		  /* 82243AC0h */ case   10:  		/* bc 12, CR0_EQ, 492 */
		/* 82243AC0h case   10:*/		if ( regs.CR[0].eq ) { return 0x82243CAC;  }
		/* 82243AC0h case   10:*/		return 0x82243AC4;
	}
	return 0x82243AC4;
} // Block from 82243A98h-82243AC4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82243AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243AC4);
		  /* 82243AC4h */ case    0:  		/* mr R3, R28 */
		/* 82243AC4h case    0:*/		regs.R3 = regs.R28;
		/* 82243AC4h case    0:*/		return 0x82243AC8;
		  /* 82243AC8h */ case    1:  		/* bl -20144 */
		/* 82243AC8h case    1:*/		regs.LR = 0x82243ACC; return 0x8223EC18;
		/* 82243AC8h case    1:*/		return 0x82243ACC;
		  /* 82243ACCh */ case    2:  		/* lwz R9, <#[R28 + 100]> */
		/* 82243ACCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000064) );
		/* 82243ACCh case    2:*/		return 0x82243AD0;
		  /* 82243AD0h */ case    3:  		/* lwz R31, <#[R3 + 56]> */
		/* 82243AD0h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000038) );
		/* 82243AD0h case    3:*/		return 0x82243AD4;
		  /* 82243AD4h */ case    4:  		/* mr R27, R3 */
		/* 82243AD4h case    4:*/		regs.R27 = regs.R3;
		/* 82243AD4h case    4:*/		return 0x82243AD8;
		  /* 82243AD8h */ case    5:  		/* li R26, 0 */
		/* 82243AD8h case    5:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82243AD8h case    5:*/		return 0x82243ADC;
		  /* 82243ADCh */ case    6:  		/* lwz R11, <#[R9 + 4]> */
		/* 82243ADCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82243ADCh case    6:*/		return 0x82243AE0;
		  /* 82243AE0h */ case    7:  		/* addi R10, R11, -1 */
		/* 82243AE0h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82243AE0h case    7:*/		return 0x82243AE4;
		  /* 82243AE4h */ case    8:  		/* cmplw CR6, R10, R11 */
		/* 82243AE4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82243AE4h case    8:*/		return 0x82243AE8;
		  /* 82243AE8h */ case    9:  		/* bc 4, CR6_LT, 20 */
		/* 82243AE8h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82243AFC;  }
		/* 82243AE8h case    9:*/		return 0x82243AEC;
		  /* 82243AECh */ case   10:  		/* lwz R11, <#[R9 + 8]> */
		/* 82243AECh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82243AECh case   10:*/		return 0x82243AF0;
		  /* 82243AF0h */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82243AF0h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82243AF0h case   11:*/		return 0x82243AF4;
		  /* 82243AF4h */ case   12:  		/* add R11, R10, R11 */
		/* 82243AF4h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82243AF4h case   12:*/		return 0x82243AF8;
		  /* 82243AF8h */ case   13:  		/* b 8 */
		/* 82243AF8h case   13:*/		return 0x82243B00;
		/* 82243AF8h case   13:*/		return 0x82243AFC;
	}
	return 0x82243AFC;
} // Block from 82243AC4h-82243AFCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 82243AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243AFC);
		  /* 82243AFCh */ case    0:  		/* mr R11, R26 */
		/* 82243AFCh case    0:*/		regs.R11 = regs.R26;
		/* 82243AFCh case    0:*/		return 0x82243B00;
	}
	return 0x82243B00;
} // Block from 82243AFCh-82243B00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82243B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243B00);
		  /* 82243B00h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82243B00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82243B00h case    0:*/		return 0x82243B04;
		  /* 82243B04h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82243B04h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82243B04h case    1:*/		return 0x82243B08;
		  /* 82243B08h */ case    2:  		/* bc 4, CR6_EQ, 168 */
		/* 82243B08h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82243BB0;  }
		/* 82243B08h case    2:*/		return 0x82243B0C;
		  /* 82243B0Ch */ case    3:  		/* lwz R11, <#[R9 + 4]> */
		/* 82243B0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82243B0Ch case    3:*/		return 0x82243B10;
		  /* 82243B10h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 82243B10h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82243B10h case    4:*/		return 0x82243B14;
		  /* 82243B14h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 82243B14h case    5:*/		if ( regs.CR[6].eq ) { return 0x82243B3C;  }
		/* 82243B14h case    5:*/		return 0x82243B18;
		  /* 82243B18h */ case    6:  		/* lis R11, -32252 */
		/* 82243B18h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243B18h case    6:*/		return 0x82243B1C;
		  /* 82243B1Ch */ case    7:  		/* lis R10, -32252 */
		/* 82243B1Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82243B1Ch case    7:*/		return 0x82243B20;
		  /* 82243B20h */ case    8:  		/* lis R9, -32253 */
		/* 82243B20h case    8:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82243B20h case    8:*/		return 0x82243B24;
		  /* 82243B24h */ case    9:  		/* addi R6, R11, 10344 */
		/* 82243B24h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2868);
		/* 82243B24h case    9:*/		return 0x82243B28;
		  /* 82243B28h */ case   10:  		/* addi R5, R10, 12168 */
		/* 82243B28h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x2F88);
		/* 82243B28h case   10:*/		return 0x82243B2C;
		  /* 82243B2Ch */ case   11:  		/* addi R4, R9, 27460 */
		/* 82243B2Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82243B2Ch case   11:*/		return 0x82243B30;
		  /* 82243B30h */ case   12:  		/* li R7, 680 */
		/* 82243B30h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x2A8);
		/* 82243B30h case   12:*/		return 0x82243B34;
		  /* 82243B34h */ case   13:  		/* li R3, 0 */
		/* 82243B34h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82243B34h case   13:*/		return 0x82243B38;
		  /* 82243B38h */ case   14:  		/* bl -966448 */
		/* 82243B38h case   14:*/		regs.LR = 0x82243B3C; return 0x82157C08;
		/* 82243B38h case   14:*/		return 0x82243B3C;
	}
	return 0x82243B3C;
} // Block from 82243B00h-82243B3Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82243B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243B3C);
		  /* 82243B3Ch */ case    0:  		/* lwz R11, <#[R29 + 16]> */
		/* 82243B3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82243B3Ch case    0:*/		return 0x82243B40;
		  /* 82243B40h */ case    1:  		/* lbz R11, <#[R11]> */
		/* 82243B40h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82243B40h case    1:*/		return 0x82243B44;
		  /* 82243B44h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82243B44h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82243B44h case    2:*/		return 0x82243B48;
		  /* 82243B48h */ case    3:  		/* bc 4, CR0_EQ, 336 */
		/* 82243B48h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82243C98;  }
		/* 82243B48h case    3:*/		return 0x82243B4C;
		  /* 82243B4Ch */ case    4:  		/* li R3, 83 */
		/* 82243B4Ch case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x53);
		/* 82243B4Ch case    4:*/		return 0x82243B50;
		  /* 82243B50h */ case    5:  		/* lwz R4, <#[R29 + 12]> */
		/* 82243B50h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000000C) );
		/* 82243B50h case    5:*/		return 0x82243B54;
		  /* 82243B54h */ case    6:  		/* bl 74716 */
		/* 82243B54h case    6:*/		regs.LR = 0x82243B58; return 0x82255F30;
		/* 82243B54h case    6:*/		return 0x82243B58;
		  /* 82243B58h */ case    7:  		/* lis R11, -32252 */
		/* 82243B58h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243B58h case    7:*/		return 0x82243B5C;
		  /* 82243B5Ch */ case    8:  		/* stw R31, <#[R3 + 56]> */
		/* 82243B5Ch case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000038) );
		/* 82243B5Ch case    8:*/		return 0x82243B60;
		  /* 82243B60h */ case    9:  		/* lis R10, -32256 */
		/* 82243B60h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82243B60h case    9:*/		return 0x82243B64;
		  /* 82243B64h */ case   10:  		/* addi R11, R11, 9920 */
		/* 82243B64h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x26C0);
		/* 82243B64h case   10:*/		return 0x82243B68;
		  /* 82243B68h */ case   11:  		/* stw R26, <#[R3 + 80]> */
		/* 82243B68h case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000050) );
		/* 82243B68h case   11:*/		return 0x82243B6C;
		  /* 82243B6Ch */ case   12:  		/* li R5, 1 */
		/* 82243B6Ch case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82243B6Ch case   12:*/		return 0x82243B70;
		  /* 82243B70h */ case   13:  		/* mr R30, R3 */
		/* 82243B70h case   13:*/		regs.R30 = regs.R3;
		/* 82243B70h case   13:*/		return 0x82243B74;
		  /* 82243B74h */ case   14:  		/* lfs FR4, <#[R10 + 1816]> */
		/* 82243B74h case   14:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R10 + 0x00000718) );
		/* 82243B74h case   14:*/		return 0x82243B78;
		  /* 82243B78h */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 82243B78h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82243B78h case   15:*/		return 0x82243B7C;
		  /* 82243B7Ch */ case   16:  		/* fmr FR3, FR4 */
		/* 82243B7Ch case   16:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 82243B7Ch case   16:*/		return 0x82243B80;
		  /* 82243B80h */ case   17:  		/* fmr FR2, FR4 */
		/* 82243B80h case   17:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 82243B80h case   17:*/		return 0x82243B84;
		  /* 82243B84h */ case   18:  		/* fmr FR1, FR4 */
		/* 82243B84h case   18:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 82243B84h case   18:*/		return 0x82243B88;
	}
	return 0x82243B88;
} // Block from 82243B3Ch-82243B88h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82243B88h
// Function '?Assemble@IRMovBase@XGRAPHICS@@UAAXPAVAssembler@2@PADPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243B88);
		  /* 82243B88h */ case    0:  		/* stw R11, <#[R3 + 128]> */
		/* 82243B88h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 82243B88h case    0:*/		return 0x82243B8C;
		  /* 82243B8Ch */ case    1:  		/* lwz R4, <#[R29 + 16]> */
		/* 82243B8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000010) );
		/* 82243B8Ch case    1:*/		return 0x82243B90;
		  /* 82243B90h */ case    2:  		/* bl 78728 */
		/* 82243B90h case    2:*/		regs.LR = 0x82243B94; return 0x82256F18;
		/* 82243B90h case    2:*/		return 0x82243B94;
		  /* 82243B94h */ case    3:  		/* lwz R11, <#[R30 + 228]> */
		/* 82243B94h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 82243B94h case    3:*/		return 0x82243B98;
		  /* 82243B98h */ case    4:  		/* rlwinm R11, R11, 0, 30, 28 */
		/* 82243B98h case    4:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R11,regs.R11);
		/* 82243B98h case    4:*/		return 0x82243B9C;
		  /* 82243B9Ch */ case    5:  		/* mr R3, R29 */
		/* 82243B9Ch case    5:*/		regs.R3 = regs.R29;
		/* 82243B9Ch case    5:*/		return 0x82243BA0;
		  /* 82243BA0h */ case    6:  		/* stw R11, <#[R30 + 228]> */
		/* 82243BA0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 82243BA0h case    6:*/		return 0x82243BA4;
		  /* 82243BA4h */ case    7:  		/* mr R4, R30 */
		/* 82243BA4h case    7:*/		regs.R4 = regs.R30;
		/* 82243BA4h case    7:*/		return 0x82243BA8;
		  /* 82243BA8h */ case    8:  		/* bl 86920 */
		/* 82243BA8h case    8:*/		regs.LR = 0x82243BAC; return 0x82258F30;
		/* 82243BA8h case    8:*/		return 0x82243BAC;
		  /* 82243BACh */ case    9:  		/* b 236 */
		/* 82243BACh case    9:*/		return 0x82243C98;
		/* 82243BACh case    9:*/		return 0x82243BB0;
	}
	return 0x82243BB0;
} // Block from 82243B88h-82243BB0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82243BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243BB0);
		  /* 82243BB0h */ case    0:  		/* lwz R3, <#[R29 + 16]> */
		/* 82243BB0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000010) );
		/* 82243BB0h case    0:*/		return 0x82243BB4;
		  /* 82243BB4h */ case    1:  		/* lbz R11, <#[R3]> */
		/* 82243BB4h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82243BB4h case    1:*/		return 0x82243BB8;
		  /* 82243BB8h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82243BB8h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82243BB8h case    2:*/		return 0x82243BBC;
		  /* 82243BBCh */ case    3:  		/* bc 4, CR0_EQ, 220 */
		/* 82243BBCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x82243C98;  }
		/* 82243BBCh case    3:*/		return 0x82243BC0;
		  /* 82243BC0h */ case    4:  		/* lwz R11, <#[R28 + 104]> */
		/* 82243BC0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000068) );
		/* 82243BC0h case    4:*/		return 0x82243BC4;
		  /* 82243BC4h */ case    5:  		/* lwz R30, <#[R11 + 4]> */
		/* 82243BC4h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 82243BC4h case    5:*/		return 0x82243BC8;
		  /* 82243BC8h */ case    6:  		/* cmpwi CR6, R30, 3 */
		/* 82243BC8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000003);
		/* 82243BC8h case    6:*/		return 0x82243BCC;
		  /* 82243BCCh */ case    7:  		/* bc 12, CR6_LT, 72 */
		/* 82243BCCh case    7:*/		if ( regs.CR[6].lt ) { return 0x82243C14;  }
		/* 82243BCCh case    7:*/		return 0x82243BD0;
		  /* 82243BD0h */ case    8:  		/* cmpwi CR6, R30, 7 */
		/* 82243BD0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000007);
		/* 82243BD0h case    8:*/		return 0x82243BD4;
		  /* 82243BD4h */ case    9:  		/* bc 4, CR6_LT, 20 */
		/* 82243BD4h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82243BE8;  }
		/* 82243BD4h case    9:*/		return 0x82243BD8;
		  /* 82243BD8h */ case   10:  		/* bl 15248 */
		/* 82243BD8h case   10:*/		regs.LR = 0x82243BDC; return 0x82247768;
		/* 82243BD8h case   10:*/		return 0x82243BDC;
		  /* 82243BDCh */ case   11:  		/* mr R31, R3 */
		/* 82243BDCh case   11:*/		regs.R31 = regs.R3;
		/* 82243BDCh case   11:*/		return 0x82243BE0;
		  /* 82243BE0h */ case   12:  		/* addi R30, R30, -3 */
		/* 82243BE0h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFD);
		/* 82243BE0h case   12:*/		return 0x82243BE4;
		  /* 82243BE4h */ case   13:  		/* b 48 */
		/* 82243BE4h case   13:*/		return 0x82243C14;
		/* 82243BE4h case   13:*/		return 0x82243BE8;
	}
	return 0x82243BE8;
} // Block from 82243BB0h-82243BE8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82243BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243BE8);
		  /* 82243BE8h */ case    0:  		/* lis R11, -32252 */
		/* 82243BE8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243BE8h case    0:*/		return 0x82243BEC;
		  /* 82243BECh */ case    1:  		/* lis R10, -32255 */
		/* 82243BECh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82243BECh case    1:*/		return 0x82243BF0;
		  /* 82243BF0h */ case    2:  		/* lis R9, -32253 */
		/* 82243BF0h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82243BF0h case    2:*/		return 0x82243BF4;
		  /* 82243BF4h */ case    3:  		/* addi R6, R11, 10344 */
		/* 82243BF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2868);
		/* 82243BF4h case    3:*/		return 0x82243BF8;
		  /* 82243BF8h */ case    4:  		/* addi R5, R10, 5216 */
		/* 82243BF8h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 82243BF8h case    4:*/		return 0x82243BFC;
		  /* 82243BFCh */ case    5:  		/* addi R4, R9, 27460 */
		/* 82243BFCh case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82243BFCh case    5:*/		return 0x82243C00;
		  /* 82243C00h */ case    6:  		/* li R7, 703 */
		/* 82243C00h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x2BF);
		/* 82243C00h case    6:*/		return 0x82243C04;
		  /* 82243C04h */ case    7:  		/* li R3, 0 */
		/* 82243C04h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82243C04h case    7:*/		return 0x82243C08;
		  /* 82243C08h */ case    8:  		/* bl -966656 */
		/* 82243C08h case    8:*/		regs.LR = 0x82243C0C; return 0x82157C08;
		/* 82243C08h case    8:*/		return 0x82243C0C;
		  /* 82243C0Ch */ case    9:  		/* lwz R31, <#[R1 + 80]> */
		/* 82243C0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 82243C0Ch case    9:*/		return 0x82243C10;
		  /* 82243C10h */ case   10:  		/* lwz R30, <#[R1 + 80]> */
		/* 82243C10h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 82243C10h case   10:*/		return 0x82243C14;
	}
	return 0x82243C14;
} // Block from 82243BE8h-82243C14h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82243C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243C14);
		  /* 82243C14h */ case    0:  		/* li R3, 102 */
		/* 82243C14h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x66);
		/* 82243C14h case    0:*/		return 0x82243C18;
		  /* 82243C18h */ case    1:  		/* lwz R4, <#[R29 + 12]> */
		/* 82243C18h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000000C) );
		/* 82243C18h case    1:*/		return 0x82243C1C;
		  /* 82243C1Ch */ case    2:  		/* bl 82252 */
		/* 82243C1Ch case    2:*/		regs.LR = 0x82243C20; return 0x82257D68;
		/* 82243C1Ch case    2:*/		return 0x82243C20;
		  /* 82243C20h */ case    3:  		/* lis R11, -32252 */
		/* 82243C20h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243C20h case    3:*/		return 0x82243C24;
		  /* 82243C24h */ case    4:  		/* stw R31, <#[R3 + 56]> */
		/* 82243C24h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000038) );
		/* 82243C24h case    4:*/		return 0x82243C28;
		  /* 82243C28h */ case    5:  		/* li R6, 0 */
		/* 82243C28h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82243C28h case    5:*/		return 0x82243C2C;
		  /* 82243C2Ch */ case    6:  		/* addi R31, R11, 9920 */
		/* 82243C2Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x26C0);
		/* 82243C2Ch case    6:*/		return 0x82243C30;
		  /* 82243C30h */ case    7:  		/* stw R26, <#[R3 + 80]> */
		/* 82243C30h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000050) );
		/* 82243C30h case    7:*/		return 0x82243C34;
		  /* 82243C34h */ case    8:  		/* mr R5, R30 */
		/* 82243C34h case    8:*/		regs.R5 = regs.R30;
		/* 82243C34h case    8:*/		return 0x82243C38;
		  /* 82243C38h */ case    9:  		/* li R4, 0 */
		/* 82243C38h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82243C38h case    9:*/		return 0x82243C3C;
		  /* 82243C3Ch */ case   10:  		/* lwz R11, <#[R11 + 9920]> */
		/* 82243C3Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000026C0) );
		/* 82243C3Ch case   10:*/		return 0x82243C40;
	}
	return 0x82243C40;
} // Block from 82243C14h-82243C40h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82243C40h
// Function '?Assemble@IRKill2@XGRAPHICS@@UAAXPAVAssembler@2@PADPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243C40);
		  /* 82243C40h */ case    0:  		/* mr R25, R3 */
		/* 82243C40h case    0:*/		regs.R25 = regs.R3;
		/* 82243C40h case    0:*/		return 0x82243C44;
		  /* 82243C44h */ case    1:  		/* stw R11, <#[R3 + 128]> */
		/* 82243C44h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 82243C44h case    1:*/		return 0x82243C48;
		  /* 82243C48h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 82243C48h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82243C48h case    2:*/		return 0x82243C4C;
		  /* 82243C4Ch */ case    3:  		/* lwz R11, <#[R11 + 84]> */
		/* 82243C4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 82243C4Ch case    3:*/		return 0x82243C50;
		  /* 82243C50h */ case    4:  		/* mtspr CTR, R11 */
		/* 82243C50h case    4:*/		regs.CTR = regs.R11;
		/* 82243C50h case    4:*/		return 0x82243C54;
		  /* 82243C54h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 82243C54h case    5:*/		if ( 1 ) { regs.LR = 0x82243C58; return (uint32)regs.CTR; }
		/* 82243C54h case    5:*/		return 0x82243C58;
		  /* 82243C58h */ case    6:  		/* mr R5, R27 */
		/* 82243C58h case    6:*/		regs.R5 = regs.R27;
		/* 82243C58h case    6:*/		return 0x82243C5C;
		  /* 82243C5Ch */ case    7:  		/* li R4, 1 */
		/* 82243C5Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243C5Ch case    7:*/		return 0x82243C60;
		  /* 82243C60h */ case    8:  		/* mr R3, R25 */
		/* 82243C60h case    8:*/		regs.R3 = regs.R25;
		/* 82243C60h case    8:*/		return 0x82243C64;
		  /* 82243C64h */ case    9:  		/* bl -56596 */
		/* 82243C64h case    9:*/		regs.LR = 0x82243C68; return 0x82235F50;
		/* 82243C64h case    9:*/		return 0x82243C68;
		  /* 82243C68h */ case   10:  		/* lwz R11, <#[R31 + 16]> */
		/* 82243C68h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82243C68h case   10:*/		return 0x82243C6C;
		  /* 82243C6Ch */ case   11:  		/* mr R4, R25 */
		/* 82243C6Ch case   11:*/		regs.R4 = regs.R25;
		/* 82243C6Ch case   11:*/		return 0x82243C70;
		  /* 82243C70h */ case   12:  		/* mr R3, R29 */
		/* 82243C70h case   12:*/		regs.R3 = regs.R29;
		/* 82243C70h case   12:*/		return 0x82243C74;
		  /* 82243C74h */ case   13:  		/* stw R11, <#[R25 + 132]> */
		/* 82243C74h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000084) );
		/* 82243C74h case   13:*/		return 0x82243C78;
		  /* 82243C78h */ case   14:  		/* lwz R11, <#[R25 + 228]> */
		/* 82243C78h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x000000E4) );
		/* 82243C78h case   14:*/		return 0x82243C7C;
		  /* 82243C7Ch */ case   15:  		/* rlwinm R11, R11, 0, 30, 28 */
		/* 82243C7Ch case   15:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R11,regs.R11);
		/* 82243C7Ch case   15:*/		return 0x82243C80;
		  /* 82243C80h */ case   16:  		/* stw R11, <#[R25 + 228]> */
		/* 82243C80h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x000000E4) );
		/* 82243C80h case   16:*/		return 0x82243C84;
		  /* 82243C84h */ case   17:  		/* bl 86700 */
		/* 82243C84h case   17:*/		regs.LR = 0x82243C88; return 0x82258F30;
		/* 82243C84h case   17:*/		return 0x82243C88;
		  /* 82243C88h */ case   18:  		/* lwz R3, <#[R28 + 104]> */
		/* 82243C88h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000068) );
		/* 82243C88h case   18:*/		return 0x82243C8C;
		  /* 82243C8Ch */ case   19:  		/* lwz R4, <#[R3 + 4]> */
		/* 82243C8Ch case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82243C8Ch case   19:*/		return 0x82243C90;
	}
	return 0x82243C90;
} // Block from 82243C40h-82243C90h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82243C90h
// Function '?AddVertexPatch@Assembler@XGRAPHICS@@QAAXHPADH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243C90);
		  /* 82243C90h */ case    0:  		/* bl 65072 */
		/* 82243C90h case    0:*/		regs.LR = 0x82243C94; return 0x82253AC0;
		/* 82243C90h case    0:*/		return 0x82243C94;
		  /* 82243C94h */ case    1:  		/* stw R25, <#[R3]> */
		/* 82243C94h case    1:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000000) );
		/* 82243C94h case    1:*/		return 0x82243C98;
	}
	return 0x82243C98;
} // Block from 82243C90h-82243C98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82243C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243C98);
		  /* 82243C98h */ case    0:  		/* lwz R3, <#[R28 + 100]> */
		/* 82243C98h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000064) );
		/* 82243C98h case    0:*/		return 0x82243C9C;
		  /* 82243C9Ch */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 82243C9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82243C9Ch case    1:*/		return 0x82243CA0;
		  /* 82243CA0h */ case    2:  		/* bl 65056 */
		/* 82243CA0h case    2:*/		regs.LR = 0x82243CA4; return 0x82253AC0;
		/* 82243CA0h case    2:*/		return 0x82243CA4;
		  /* 82243CA4h */ case    3:  		/* li R11, 3 */
		/* 82243CA4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 82243CA4h case    3:*/		return 0x82243CA8;
		  /* 82243CA8h */ case    4:  		/* stw R11, <#[R3]> */
		/* 82243CA8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82243CA8h case    4:*/		return 0x82243CAC;
	}
	return 0x82243CAC;
} // Block from 82243C98h-82243CACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82243CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243CAC);
		  /* 82243CACh */ case    0:  		/* addi R4, R29, 20 */
		/* 82243CACh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0x14);
		/* 82243CACh case    0:*/		return 0x82243CB0;
		  /* 82243CB0h */ case    1:  		/* lbz R5, <#[R29 + 124]> */
		/* 82243CB0h case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000007C) );
		/* 82243CB0h case    1:*/		return 0x82243CB4;
		  /* 82243CB4h */ case    2:  		/* mr R3, R28 */
		/* 82243CB4h case    2:*/		regs.R3 = regs.R28;
		/* 82243CB4h case    2:*/		return 0x82243CB8;
		  /* 82243CB8h */ case    3:  		/* bl -9224 */
		/* 82243CB8h case    3:*/		regs.LR = 0x82243CBC; return 0x822418B0;
		/* 82243CB8h case    3:*/		return 0x82243CBC;
		  /* 82243CBCh */ case    4:  		/* mr R3, R28 */
		/* 82243CBCh case    4:*/		regs.R3 = regs.R28;
		/* 82243CBCh case    4:*/		return 0x82243CC0;
		  /* 82243CC0h */ case    5:  		/* lwz R4, <#[R29 + 136]> */
		/* 82243CC0h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000088) );
		/* 82243CC0h case    5:*/		return 0x82243CC4;
		  /* 82243CC4h */ case    6:  		/* bl -6892 */
		/* 82243CC4h case    6:*/		regs.LR = 0x82243CC8; return 0x822421D8;
		/* 82243CC4h case    6:*/		return 0x82243CC8;
		  /* 82243CC8h */ case    7:  		/* addi R1, R1, 160 */
		/* 82243CC8h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82243CC8h case    7:*/		return 0x82243CCC;
		  /* 82243CCCh */ case    8:  		/* b -1780272 */
		/* 82243CCCh case    8:*/		return 0x8209129C;
		/* 82243CCCh case    8:*/		return 0x82243CD0;
	}
	return 0x82243CD0;
} // Block from 82243CACh-82243CD0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82243CD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243CD0);
		  /* 82243CD0h */ case    0:  		/* mfspr R12, LR */
		/* 82243CD0h case    0:*/		regs.R12 = regs.LR;
		/* 82243CD0h case    0:*/		return 0x82243CD4;
		  /* 82243CD4h */ case    1:  		/* bl -1780364 */
		/* 82243CD4h case    1:*/		regs.LR = 0x82243CD8; return 0x82091248;
		/* 82243CD4h case    1:*/		return 0x82243CD8;
		  /* 82243CD8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82243CD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82243CD8h case    2:*/		return 0x82243CDC;
		  /* 82243CDCh */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 82243CDCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82243CDCh case    3:*/		return 0x82243CE0;
		  /* 82243CE0h */ case    4:  		/* mr R31, R3 */
		/* 82243CE0h case    4:*/		regs.R31 = regs.R3;
		/* 82243CE0h case    4:*/		return 0x82243CE4;
		  /* 82243CE4h */ case    5:  		/* mr R28, R4 */
		/* 82243CE4h case    5:*/		regs.R28 = regs.R4;
		/* 82243CE4h case    5:*/		return 0x82243CE8;
		  /* 82243CE8h */ case    6:  		/* lbz R11, <#[R11]> */
		/* 82243CE8h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82243CE8h case    6:*/		return 0x82243CEC;
		  /* 82243CECh */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82243CECh case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82243CECh case    7:*/		return 0x82243CF0;
		  /* 82243CF0h */ case    8:  		/* bc 4, CR0_EQ, 336 */
		/* 82243CF0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82243E40;  }
		/* 82243CF0h case    8:*/		return 0x82243CF4;
		  /* 82243CF4h */ case    9:  		/* lwz R11, <#[R3 + 136]> */
		/* 82243CF4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000088) );
		/* 82243CF4h case    9:*/		return 0x82243CF8;
		  /* 82243CF8h */ case   10:  		/* lbz R11, <#[R11 + 141]> */
		/* 82243CF8h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000008D) );
		/* 82243CF8h case   10:*/		return 0x82243CFC;
		  /* 82243CFCh */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 82243CFCh case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82243CFCh case   11:*/		return 0x82243D00;
		  /* 82243D00h */ case   12:  		/* bc 12, CR0_EQ, 320 */
		/* 82243D00h case   12:*/		if ( regs.CR[0].eq ) { return 0x82243E40;  }
		/* 82243D00h case   12:*/		return 0x82243D04;
		  /* 82243D04h */ case   13:  		/* mr R3, R4 */
		/* 82243D04h case   13:*/		regs.R3 = regs.R4;
		/* 82243D04h case   13:*/		return 0x82243D08;
		  /* 82243D08h */ case   14:  		/* bl -20720 */
		/* 82243D08h case   14:*/		regs.LR = 0x82243D0C; return 0x8223EC18;
		/* 82243D08h case   14:*/		return 0x82243D0C;
		  /* 82243D0Ch */ case   15:  		/* lwz R11, <#[R31 + 136]> */
		/* 82243D0Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 82243D0Ch case   15:*/		return 0x82243D10;
		  /* 82243D10h */ case   16:  		/* lwz R30, <#[R3 + 56]> */
		/* 82243D10h case   16:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000038) );
		/* 82243D10h case   16:*/		return 0x82243D14;
		  /* 82243D14h */ case   17:  		/* mr R29, R3 */
		/* 82243D14h case   17:*/		regs.R29 = regs.R3;
		/* 82243D14h case   17:*/		return 0x82243D18;
		  /* 82243D18h */ case   18:  		/* lwz R4, <#[R31 + 12]> */
		/* 82243D18h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82243D18h case   18:*/		return 0x82243D1C;
		  /* 82243D1Ch */ case   19:  		/* lbz R11, <#[R11 + 140]> */
		/* 82243D1Ch case   19:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000008C) );
		/* 82243D1Ch case   19:*/		return 0x82243D20;
		  /* 82243D20h */ case   20:  		/* cmplwi CR0, R11, 0 */
		/* 82243D20h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82243D20h case   20:*/		return 0x82243D24;
		  /* 82243D24h */ case   21:  		/* bc 12, CR0_EQ, 188 */
		/* 82243D24h case   21:*/		if ( regs.CR[0].eq ) { return 0x82243DE0;  }
		/* 82243D24h case   21:*/		return 0x82243D28;
		  /* 82243D28h */ case   22:  		/* li R3, 40 */
		/* 82243D28h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x28);
		/* 82243D28h case   22:*/		return 0x82243D2C;
		  /* 82243D2Ch */ case   23:  		/* bl 74244 */
		/* 82243D2Ch case   23:*/		regs.LR = 0x82243D30; return 0x82255F30;
		/* 82243D2Ch case   23:*/		return 0x82243D30;
		  /* 82243D30h */ case   24:  		/* mr R5, R29 */
		/* 82243D30h case   24:*/		regs.R5 = regs.R29;
		/* 82243D30h case   24:*/		return 0x82243D34;
		  /* 82243D34h */ case   25:  		/* li R4, 1 */
		/* 82243D34h case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243D34h case   25:*/		return 0x82243D38;
		  /* 82243D38h */ case   26:  		/* mr R27, R3 */
		/* 82243D38h case   26:*/		regs.R27 = regs.R3;
		/* 82243D38h case   26:*/		return 0x82243D3C;
		  /* 82243D3Ch */ case   27:  		/* bl -56812 */
		/* 82243D3Ch case   27:*/		regs.LR = 0x82243D40; return 0x82235F50;
		/* 82243D3Ch case   27:*/		return 0x82243D40;
		  /* 82243D40h */ case   28:  		/* lis R11, -32252 */
		/* 82243D40h case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243D40h case   28:*/		return 0x82243D44;
		  /* 82243D44h */ case   29:  		/* mr R3, R27 */
		/* 82243D44h case   29:*/		regs.R3 = regs.R27;
		/* 82243D44h case   29:*/		return 0x82243D48;
		  /* 82243D48h */ case   30:  		/* lwz R4, <#[R31 + 16]> */
		/* 82243D48h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 82243D48h case   30:*/		return 0x82243D4C;
		  /* 82243D4Ch */ case   31:  		/* li R5, 2 */
		/* 82243D4Ch case   31:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82243D4Ch case   31:*/		return 0x82243D50;
		  /* 82243D50h */ case   32:  		/* lfs FR4, <#[R11 - 25384]> */
		/* 82243D50h case   32:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R11 + 0xFFFF9CD8) );
		/* 82243D50h case   32:*/		return 0x82243D54;
		  /* 82243D54h */ case   33:  		/* fmr FR3, FR4 */
		/* 82243D54h case   33:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 82243D54h case   33:*/		return 0x82243D58;
	}
	return 0x82243D58;
} // Block from 82243CD0h-82243D58h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82243D58h
// Function '?Assemble@Block@XGRAPHICS@@UAAXAAVAssembler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243D58);
		  /* 82243D58h */ case    0:  		/* fmr FR2, FR4 */
		/* 82243D58h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 82243D58h case    0:*/		return 0x82243D5C;
		  /* 82243D5Ch */ case    1:  		/* fmr FR1, FR4 */
		/* 82243D5Ch case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 82243D5Ch case    1:*/		return 0x82243D60;
		  /* 82243D60h */ case    2:  		/* bl 78264 */
		/* 82243D60h case    2:*/		regs.LR = 0x82243D64; return 0x82256F18;
		/* 82243D60h case    2:*/		return 0x82243D64;
		  /* 82243D64h */ case    3:  		/* lis R26, -32252 */
		/* 82243D64h case    3:*/		cpu::op::lis<0>(regs,&regs.R26,0xFFFF8204);
		/* 82243D64h case    3:*/		return 0x82243D68;
		  /* 82243D68h */ case    4:  		/* stw R30, <#[R27 + 56]> */
		/* 82243D68h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R27 + 0x00000038) );
		/* 82243D68h case    4:*/		return 0x82243D6C;
		  /* 82243D6Ch */ case    5:  		/* li R29, 0 */
		/* 82243D6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82243D6Ch case    5:*/		return 0x82243D70;
		  /* 82243D70h */ case    6:  		/* addi R25, R26, 9936 */
		/* 82243D70h case    6:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R26,0x26D0);
		/* 82243D70h case    6:*/		return 0x82243D74;
		  /* 82243D74h */ case    7:  		/* stw R29, <#[R27 + 80]> */
		/* 82243D74h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + 0x00000050) );
		/* 82243D74h case    7:*/		return 0x82243D78;
		  /* 82243D78h */ case    8:  		/* mr R4, R27 */
		/* 82243D78h case    8:*/		regs.R4 = regs.R27;
		/* 82243D78h case    8:*/		return 0x82243D7C;
		  /* 82243D7Ch */ case    9:  		/* mr R3, R31 */
		/* 82243D7Ch case    9:*/		regs.R3 = regs.R31;
		/* 82243D7Ch case    9:*/		return 0x82243D80;
		  /* 82243D80h */ case   10:  		/* lwz R11, <#[R25 - 12]> */
		/* 82243D80h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0xFFFFFFF4) );
		/* 82243D80h case   10:*/		return 0x82243D84;
		  /* 82243D84h */ case   11:  		/* stw R11, <#[R27 + 128]> */
		/* 82243D84h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000080) );
		/* 82243D84h case   11:*/		return 0x82243D88;
		  /* 82243D88h */ case   12:  		/* lwz R11, <#[R27 + 228]> */
		/* 82243D88h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x000000E4) );
		/* 82243D88h case   12:*/		return 0x82243D8C;
		  /* 82243D8Ch */ case   13:  		/* rlwinm R11, R11, 0, 30, 28 */
		/* 82243D8Ch case   13:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R11,regs.R11);
		/* 82243D8Ch case   13:*/		return 0x82243D90;
		  /* 82243D90h */ case   14:  		/* stw R11, <#[R27 + 228]> */
		/* 82243D90h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x000000E4) );
		/* 82243D90h case   14:*/		return 0x82243D94;
		  /* 82243D94h */ case   15:  		/* bl 86428 */
		/* 82243D94h case   15:*/		regs.LR = 0x82243D98; return 0x82258F30;
		/* 82243D94h case   15:*/		return 0x82243D98;
		  /* 82243D98h */ case   16:  		/* li R3, 90 */
		/* 82243D98h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x5A);
		/* 82243D98h case   16:*/		return 0x82243D9C;
		  /* 82243D9Ch */ case   17:  		/* lwz R4, <#[R31 + 12]> */
		/* 82243D9Ch case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82243D9Ch case   17:*/		return 0x82243DA0;
		  /* 82243DA0h */ case   18:  		/* bl 74128 */
		/* 82243DA0h case   18:*/		regs.LR = 0x82243DA4; return 0x82255F30;
		/* 82243DA0h case   18:*/		return 0x82243DA4;
		  /* 82243DA4h */ case   19:  		/* lwz R11, <#[R25 - 12]> */
		/* 82243DA4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0xFFFFFFF4) );
		/* 82243DA4h case   19:*/		return 0x82243DA8;
		  /* 82243DA8h */ case   20:  		/* stw R30, <#[R3 + 56]> */
		/* 82243DA8h case   20:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000038) );
		/* 82243DA8h case   20:*/		return 0x82243DAC;
		  /* 82243DACh */ case   21:  		/* mr R5, R27 */
		/* 82243DACh case   21:*/		regs.R5 = regs.R27;
		/* 82243DACh case   21:*/		return 0x82243DB0;
		  /* 82243DB0h */ case   22:  		/* stw R29, <#[R3 + 80]> */
		/* 82243DB0h case   22:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000050) );
		/* 82243DB0h case   22:*/		return 0x82243DB4;
		  /* 82243DB4h */ case   23:  		/* li R4, 1 */
		/* 82243DB4h case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243DB4h case   23:*/		return 0x82243DB8;
		  /* 82243DB8h */ case   24:  		/* mr R24, R3 */
		/* 82243DB8h case   24:*/		regs.R24 = regs.R3;
		/* 82243DB8h case   24:*/		return 0x82243DBC;
		  /* 82243DBCh */ case   25:  		/* stw R11, <#[R3 + 128]> */
		/* 82243DBCh case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 82243DBCh case   25:*/		return 0x82243DC0;
		  /* 82243DC0h */ case   26:  		/* bl -56944 */
		/* 82243DC0h case   26:*/		regs.LR = 0x82243DC4; return 0x82235F50;
		/* 82243DC0h case   26:*/		return 0x82243DC4;
		  /* 82243DC4h */ case   27:  		/* lwz R11, <#[R26 + 9936]> */
		/* 82243DC4h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x000026D0) );
		/* 82243DC4h case   27:*/		return 0x82243DC8;
		  /* 82243DC8h */ case   28:  		/* mr R4, R24 */
		/* 82243DC8h case   28:*/		regs.R4 = regs.R24;
		/* 82243DC8h case   28:*/		return 0x82243DCC;
		  /* 82243DCCh */ case   29:  		/* stw R11, <#[R24 + 132]> */
		/* 82243DCCh case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000084) );
		/* 82243DCCh case   29:*/		return 0x82243DD0;
	}
	return 0x82243DD0;
} // Block from 82243D58h-82243DD0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82243DD0h
// Function '?Assemble@IfHeader@XGRAPHICS@@UAAXAAVAssembler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243DD0);
		  /* 82243DD0h */ case    0:  		/* lwz R11, <#[R24 + 228]> */
		/* 82243DD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x000000E4) );
		/* 82243DD0h case    0:*/		return 0x82243DD4;
		  /* 82243DD4h */ case    1:  		/* rlwinm R11, R11, 0, 30, 28 */
		/* 82243DD4h case    1:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R11,regs.R11);
		/* 82243DD4h case    1:*/		return 0x82243DD8;
		  /* 82243DD8h */ case    2:  		/* stw R11, <#[R24 + 228]> */
		/* 82243DD8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x000000E4) );
		/* 82243DD8h case    2:*/		return 0x82243DDC;
		  /* 82243DDCh */ case    3:  		/* b 92 */
		/* 82243DDCh case    3:*/		return 0x82243E38;
		/* 82243DDCh case    3:*/		return 0x82243DE0;
	}
	return 0x82243DE0;
} // Block from 82243DD0h-82243DE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82243DE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243DE0);
		  /* 82243DE0h */ case    0:  		/* li R3, 83 */
		/* 82243DE0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x53);
		/* 82243DE0h case    0:*/		return 0x82243DE4;
		  /* 82243DE4h */ case    1:  		/* bl 74060 */
		/* 82243DE4h case    1:*/		regs.LR = 0x82243DE8; return 0x82255F30;
		/* 82243DE4h case    1:*/		return 0x82243DE8;
		  /* 82243DE8h */ case    2:  		/* lis R11, -32252 */
		/* 82243DE8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243DE8h case    2:*/		return 0x82243DEC;
		  /* 82243DECh */ case    3:  		/* li R10, 0 */
		/* 82243DECh case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82243DECh case    3:*/		return 0x82243DF0;
		  /* 82243DF0h */ case    4:  		/* stw R30, <#[R3 + 56]> */
		/* 82243DF0h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000038) );
		/* 82243DF0h case    4:*/		return 0x82243DF4;
		  /* 82243DF4h */ case    5:  		/* addi R11, R11, 9936 */
		/* 82243DF4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 82243DF4h case    5:*/		return 0x82243DF8;
		  /* 82243DF8h */ case    6:  		/* stw R10, <#[R3 + 80]> */
		/* 82243DF8h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000050) );
		/* 82243DF8h case    6:*/		return 0x82243DFC;
		  /* 82243DFCh */ case    7:  		/* lis R9, -32256 */
		/* 82243DFCh case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82243DFCh case    7:*/		return 0x82243E00;
		  /* 82243E00h */ case    8:  		/* li R5, 1 */
		/* 82243E00h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82243E00h case    8:*/		return 0x82243E04;
		  /* 82243E04h */ case    9:  		/* mr R29, R3 */
		/* 82243E04h case    9:*/		regs.R29 = regs.R3;
		/* 82243E04h case    9:*/		return 0x82243E08;
		  /* 82243E08h */ case   10:  		/* lwz R11, <#[R11 - 12]> */
		/* 82243E08h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFF4) );
		/* 82243E08h case   10:*/		return 0x82243E0C;
		  /* 82243E0Ch */ case   11:  		/* lfs FR4, <#[R9 + 1816]> */
		/* 82243E0Ch case   11:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R9 + 0x00000718) );
		/* 82243E0Ch case   11:*/		return 0x82243E10;
		  /* 82243E10h */ case   12:  		/* fmr FR3, FR4 */
		/* 82243E10h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 82243E10h case   12:*/		return 0x82243E14;
		  /* 82243E14h */ case   13:  		/* fmr FR2, FR4 */
		/* 82243E14h case   13:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 82243E14h case   13:*/		return 0x82243E18;
		  /* 82243E18h */ case   14:  		/* fmr FR1, FR4 */
		/* 82243E18h case   14:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 82243E18h case   14:*/		return 0x82243E1C;
		  /* 82243E1Ch */ case   15:  		/* stw R11, <#[R3 + 128]> */
		/* 82243E1Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 82243E1Ch case   15:*/		return 0x82243E20;
		  /* 82243E20h */ case   16:  		/* lwz R4, <#[R31 + 16]> */
		/* 82243E20h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 82243E20h case   16:*/		return 0x82243E24;
		  /* 82243E24h */ case   17:  		/* bl 78068 */
		/* 82243E24h case   17:*/		regs.LR = 0x82243E28; return 0x82256F18;
		/* 82243E24h case   17:*/		return 0x82243E28;
		  /* 82243E28h */ case   18:  		/* lwz R11, <#[R29 + 228]> */
		/* 82243E28h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000E4) );
		/* 82243E28h case   18:*/		return 0x82243E2C;
		  /* 82243E2Ch */ case   19:  		/* rlwinm R11, R11, 0, 30, 28 */
		/* 82243E2Ch case   19:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R11,regs.R11);
		/* 82243E2Ch case   19:*/		return 0x82243E30;
		  /* 82243E30h */ case   20:  		/* mr R4, R29 */
		/* 82243E30h case   20:*/		regs.R4 = regs.R29;
		/* 82243E30h case   20:*/		return 0x82243E34;
		  /* 82243E34h */ case   21:  		/* stw R11, <#[R29 + 228]> */
		/* 82243E34h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x000000E4) );
		/* 82243E34h case   21:*/		return 0x82243E38;
	}
	return 0x82243E38;
} // Block from 82243DE0h-82243E38h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82243E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243E38);
		  /* 82243E38h */ case    0:  		/* mr R3, R31 */
		/* 82243E38h case    0:*/		regs.R3 = regs.R31;
		/* 82243E38h case    0:*/		return 0x82243E3C;
		  /* 82243E3Ch */ case    1:  		/* bl 86260 */
		/* 82243E3Ch case    1:*/		regs.LR = 0x82243E40; return 0x82258F30;
		/* 82243E3Ch case    1:*/		return 0x82243E40;
	}
	return 0x82243E40;
} // Block from 82243E38h-82243E40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82243E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243E40);
		  /* 82243E40h */ case    0:  		/* addi R4, R31, 20 */
		/* 82243E40h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x14);
		/* 82243E40h case    0:*/		return 0x82243E44;
		  /* 82243E44h */ case    1:  		/* lbz R5, <#[R31 + 124]> */
		/* 82243E44h case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000007C) );
		/* 82243E44h case    1:*/		return 0x82243E48;
		  /* 82243E48h */ case    2:  		/* mr R3, R28 */
		/* 82243E48h case    2:*/		regs.R3 = regs.R28;
		/* 82243E48h case    2:*/		return 0x82243E4C;
		  /* 82243E4Ch */ case    3:  		/* bl -9628 */
		/* 82243E4Ch case    3:*/		regs.LR = 0x82243E50; return 0x822418B0;
		/* 82243E4Ch case    3:*/		return 0x82243E50;
		  /* 82243E50h */ case    4:  		/* lwz R11, <#[R31 + 136]> */
		/* 82243E50h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 82243E50h case    4:*/		return 0x82243E54;
		  /* 82243E54h */ case    5:  		/* mr R3, R28 */
		/* 82243E54h case    5:*/		regs.R3 = regs.R28;
		/* 82243E54h case    5:*/		return 0x82243E58;
		  /* 82243E58h */ case    6:  		/* lwz R4, <#[R11 + 136]> */
		/* 82243E58h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000088) );
		/* 82243E58h case    6:*/		return 0x82243E5C;
		  /* 82243E5Ch */ case    7:  		/* bl -7076 */
		/* 82243E5Ch case    7:*/		regs.LR = 0x82243E60; return 0x822422B8;
		/* 82243E5Ch case    7:*/		return 0x82243E60;
		  /* 82243E60h */ case    8:  		/* addi R1, R1, 160 */
		/* 82243E60h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82243E60h case    8:*/		return 0x82243E64;
		  /* 82243E64h */ case    9:  		/* b -1780684 */
		/* 82243E64h case    9:*/		return 0x82091298;
		/* 82243E64h case    9:*/		return 0x82243E68;
	}
	return 0x82243E68;
} // Block from 82243E40h-82243E68h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82243E68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243E68);
		  /* 82243E68h */ case    0:  		/* mfspr R12, LR */
		/* 82243E68h case    0:*/		regs.R12 = regs.LR;
		/* 82243E68h case    0:*/		return 0x82243E6C;
		  /* 82243E6Ch */ case    1:  		/* bl -1780772 */
		/* 82243E6Ch case    1:*/		regs.LR = 0x82243E70; return 0x82091248;
		/* 82243E6Ch case    1:*/		return 0x82243E70;
		  /* 82243E70h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82243E70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82243E70h case    2:*/		return 0x82243E74;
		  /* 82243E74h */ case    3:  		/* lwz R11, <#[R3 + 136]> */
		/* 82243E74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000088) );
		/* 82243E74h case    3:*/		return 0x82243E78;
		  /* 82243E78h */ case    4:  		/* mr R26, R3 */
		/* 82243E78h case    4:*/		regs.R26 = regs.R3;
		/* 82243E78h case    4:*/		return 0x82243E7C;
		  /* 82243E7Ch */ case    5:  		/* mr R29, R4 */
		/* 82243E7Ch case    5:*/		regs.R29 = regs.R4;
		/* 82243E7Ch case    5:*/		return 0x82243E80;
		  /* 82243E80h */ case    6:  		/* lbz R10, <#[R11 + 140]> */
		/* 82243E80h case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000008C) );
		/* 82243E80h case    6:*/		return 0x82243E84;
		  /* 82243E84h */ case    7:  		/* cmplwi CR0, R10, 0 */
		/* 82243E84h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82243E84h case    7:*/		return 0x82243E88;
		  /* 82243E88h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 82243E88h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82243E98;  }
		/* 82243E88h case    8:*/		return 0x82243E8C;
		  /* 82243E8Ch */ case    9:  		/* lbz R11, <#[R11 + 141]> */
		/* 82243E8Ch case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000008D) );
		/* 82243E8Ch case    9:*/		return 0x82243E90;
		  /* 82243E90h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 82243E90h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82243E90h case   10:*/		return 0x82243E94;
		  /* 82243E94h */ case   11:  		/* bc 12, CR0_EQ, 468 */
		/* 82243E94h case   11:*/		if ( regs.CR[0].eq ) { return 0x82244068;  }
		/* 82243E94h case   11:*/		return 0x82243E98;
	}
	return 0x82243E98;
} // Block from 82243E68h-82243E98h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82243E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243E98);
		  /* 82243E98h */ case    0:  		/* lwz R3, <#[R29 + 100]> */
		/* 82243E98h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000064) );
		/* 82243E98h case    0:*/		return 0x82243E9C;
		  /* 82243E9Ch */ case    1:  		/* bl 93876 */
		/* 82243E9Ch case    1:*/		regs.LR = 0x82243EA0; return 0x8225AD50;
		/* 82243E9Ch case    1:*/		return 0x82243EA0;
		  /* 82243EA0h */ case    2:  		/* lis R11, -32253 */
		/* 82243EA0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82243EA0h case    2:*/		return 0x82243EA4;
		  /* 82243EA4h */ case    3:  		/* lis R10, -32252 */
		/* 82243EA4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82243EA4h case    3:*/		return 0x82243EA8;
		  /* 82243EA8h */ case    4:  		/* cmpwi CR6, R3, 3 */
		/* 82243EA8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 82243EA8h case    4:*/		return 0x82243EAC;
		  /* 82243EACh */ case    5:  		/* addi R28, R11, 27460 */
		/* 82243EACh case    5:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x6B44);
		/* 82243EACh case    5:*/		return 0x82243EB0;
		  /* 82243EB0h */ case    6:  		/* addi R27, R10, 10344 */
		/* 82243EB0h case    6:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R10,0x2868);
		/* 82243EB0h case    6:*/		return 0x82243EB4;
		  /* 82243EB4h */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 82243EB4h case    7:*/		if ( regs.CR[6].eq ) { return 0x82243ED4;  }
		/* 82243EB4h case    7:*/		return 0x82243EB8;
		  /* 82243EB8h */ case    8:  		/* lis R11, -32252 */
		/* 82243EB8h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243EB8h case    8:*/		return 0x82243EBC;
		  /* 82243EBCh */ case    9:  		/* mr R6, R27 */
		/* 82243EBCh case    9:*/		regs.R6 = regs.R27;
		/* 82243EBCh case    9:*/		return 0x82243EC0;
		  /* 82243EC0h */ case   10:  		/* addi R5, R11, 12304 */
		/* 82243EC0h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3010);
		/* 82243EC0h case   10:*/		return 0x82243EC4;
		  /* 82243EC4h */ case   11:  		/* mr R4, R28 */
		/* 82243EC4h case   11:*/		regs.R4 = regs.R28;
		/* 82243EC4h case   11:*/		return 0x82243EC8;
		  /* 82243EC8h */ case   12:  		/* li R7, 792 */
		/* 82243EC8h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x318);
		/* 82243EC8h case   12:*/		return 0x82243ECC;
		  /* 82243ECCh */ case   13:  		/* li R3, 0 */
		/* 82243ECCh case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82243ECCh case   13:*/		return 0x82243ED0;
		  /* 82243ED0h */ case   14:  		/* bl -967368 */
		/* 82243ED0h case   14:*/		regs.LR = 0x82243ED4; return 0x82157C08;
		/* 82243ED0h case   14:*/		return 0x82243ED4;
	}
	return 0x82243ED4;
} // Block from 82243E98h-82243ED4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82243ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243ED4);
		  /* 82243ED4h */ case    0:  		/* lwz R11, <#[R26 + 16]> */
		/* 82243ED4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 82243ED4h case    0:*/		return 0x82243ED8;
		  /* 82243ED8h */ case    1:  		/* lbz R11, <#[R11]> */
		/* 82243ED8h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82243ED8h case    1:*/		return 0x82243EDC;
		  /* 82243EDCh */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82243EDCh case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82243EDCh case    2:*/		return 0x82243EE0;
		  /* 82243EE0h */ case    3:  		/* bc 4, CR0_EQ, 392 */
		/* 82243EE0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82244068;  }
		/* 82243EE0h case    3:*/		return 0x82243EE4;
		  /* 82243EE4h */ case    4:  		/* lwz R3, <#[R29 + 104]> */
		/* 82243EE4h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000068) );
		/* 82243EE4h case    4:*/		return 0x82243EE8;
		  /* 82243EE8h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 82243EE8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82243EE8h case    5:*/		return 0x82243EEC;
		  /* 82243EECh */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82243EECh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82243EECh case    6:*/		return 0x82243EF0;
		  /* 82243EF0h */ case    7:  		/* bc 4, CR6_GT, 284 */
		/* 82243EF0h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8224400C;  }
		/* 82243EF0h case    7:*/		return 0x82243EF4;
		  /* 82243EF4h */ case    8:  		/* addi R30, R11, -1 */
		/* 82243EF4h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFF);
		/* 82243EF4h case    8:*/		return 0x82243EF8;
		  /* 82243EF8h */ case    9:  		/* bl 93784 */
		/* 82243EF8h case    9:*/		regs.LR = 0x82243EFC; return 0x8225AD50;
		/* 82243EF8h case    9:*/		return 0x82243EFC;
		  /* 82243EFCh */ case   10:  		/* mr R25, R3 */
		/* 82243EFCh case   10:*/		regs.R25 = regs.R3;
		/* 82243EFCh case   10:*/		return 0x82243F00;
		  /* 82243F00h */ case   11:  		/* mr R3, R29 */
		/* 82243F00h case   11:*/		regs.R3 = regs.R29;
		/* 82243F00h case   11:*/		return 0x82243F04;
		  /* 82243F04h */ case   12:  		/* bl -21228 */
		/* 82243F04h case   12:*/		regs.LR = 0x82243F08; return 0x8223EC18;
		/* 82243F04h case   12:*/		return 0x82243F08;
		  /* 82243F08h */ case   13:  		/* mr R11, R3 */
		/* 82243F08h case   13:*/		regs.R11 = regs.R3;
		/* 82243F08h case   13:*/		return 0x82243F0C;
		  /* 82243F0Ch */ case   14:  		/* li R3, 90 */
		/* 82243F0Ch case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x5A);
		/* 82243F0Ch case   14:*/		return 0x82243F10;
		  /* 82243F10h */ case   15:  		/* lwz R4, <#[R26 + 12]> */
		/* 82243F10h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x0000000C) );
		/* 82243F10h case   15:*/		return 0x82243F14;
		  /* 82243F14h */ case   16:  		/* lwz R24, <#[R11 + 56]> */
		/* 82243F14h case   16:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R11 + 0x00000038) );
		/* 82243F14h case   16:*/		return 0x82243F18;
		  /* 82243F18h */ case   17:  		/* bl 73752 */
		/* 82243F18h case   17:*/		regs.LR = 0x82243F1C; return 0x82255F30;
		/* 82243F18h case   17:*/		return 0x82243F1C;
		  /* 82243F1Ch */ case   18:  		/* lis R11, -32252 */
		/* 82243F1Ch case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82243F1Ch case   18:*/		return 0x82243F20;
		  /* 82243F20h */ case   19:  		/* stw R24, <#[R3 + 56]> */
		/* 82243F20h case   19:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000038) );
		/* 82243F20h case   19:*/		return 0x82243F24;
		  /* 82243F24h */ case   20:  		/* li R10, 0 */
		/* 82243F24h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82243F24h case   20:*/		return 0x82243F28;
		  /* 82243F28h */ case   21:  		/* mr R5, R25 */
		/* 82243F28h case   21:*/		regs.R5 = regs.R25;
		/* 82243F28h case   21:*/		return 0x82243F2C;
		  /* 82243F2Ch */ case   22:  		/* stw R10, <#[R3 + 80]> */
		/* 82243F2Ch case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000050) );
		/* 82243F2Ch case   22:*/		return 0x82243F30;
		  /* 82243F30h */ case   23:  		/* li R4, 1 */
		/* 82243F30h case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243F30h case   23:*/		return 0x82243F34;
		  /* 82243F34h */ case   24:  		/* mr R31, R3 */
		/* 82243F34h case   24:*/		regs.R31 = regs.R3;
		/* 82243F34h case   24:*/		return 0x82243F38;
		  /* 82243F38h */ case   25:  		/* lwz R11, <#[R11 + 9924]> */
		/* 82243F38h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000026C4) );
		/* 82243F38h case   25:*/		return 0x82243F3C;
		  /* 82243F3Ch */ case   26:  		/* stw R11, <#[R3 + 128]> */
		/* 82243F3Ch case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 82243F3Ch case   26:*/		return 0x82243F40;
		  /* 82243F40h */ case   27:  		/* bl -57328 */
		/* 82243F40h case   27:*/		regs.LR = 0x82243F44; return 0x82235F50;
		/* 82243F40h case   27:*/		return 0x82243F44;
		  /* 82243F44h */ case   28:  		/* cmpwi CR6, R30, 3 */
		/* 82243F44h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000003);
		/* 82243F44h case   28:*/		return 0x82243F48;
		  /* 82243F48h */ case   29:  		/* bc 12, CR6_LT, 52 */
		/* 82243F48h case   29:*/		if ( regs.CR[6].lt ) { return 0x82243F7C;  }
		/* 82243F48h case   29:*/		return 0x82243F4C;
		  /* 82243F4Ch */ case   30:  		/* cmpwi CR6, R30, 7 */
		/* 82243F4Ch case   30:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000007);
		/* 82243F4Ch case   30:*/		return 0x82243F50;
		  /* 82243F50h */ case   31:  		/* bc 4, CR6_LT, 12 */
		/* 82243F50h case   31:*/		if ( !regs.CR[6].lt ) { return 0x82243F5C;  }
		/* 82243F50h case   31:*/		return 0x82243F54;
		  /* 82243F54h */ case   32:  		/* addi R30, R30, -3 */
		/* 82243F54h case   32:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFD);
		/* 82243F54h case   32:*/		return 0x82243F58;
		  /* 82243F58h */ case   33:  		/* b 36 */
		/* 82243F58h case   33:*/		return 0x82243F7C;
		/* 82243F58h case   33:*/		return 0x82243F5C;
	}
	return 0x82243F5C;
} // Block from 82243ED4h-82243F5Ch (34 instructions)

//////////////////////////////////////////////////////
// Block at 82243F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243F5C);
		  /* 82243F5Ch */ case    0:  		/* lis R11, -32255 */
		/* 82243F5Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82243F5Ch case    0:*/		return 0x82243F60;
		  /* 82243F60h */ case    1:  		/* mr R6, R27 */
		/* 82243F60h case    1:*/		regs.R6 = regs.R27;
		/* 82243F60h case    1:*/		return 0x82243F64;
		  /* 82243F64h */ case    2:  		/* addi R5, R11, 5216 */
		/* 82243F64h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1460);
		/* 82243F64h case    2:*/		return 0x82243F68;
		  /* 82243F68h */ case    3:  		/* mr R4, R28 */
		/* 82243F68h case    3:*/		regs.R4 = regs.R28;
		/* 82243F68h case    3:*/		return 0x82243F6C;
		  /* 82243F6Ch */ case    4:  		/* li R7, 819 */
		/* 82243F6Ch case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x333);
		/* 82243F6Ch case    4:*/		return 0x82243F70;
		  /* 82243F70h */ case    5:  		/* li R3, 0 */
		/* 82243F70h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82243F70h case    5:*/		return 0x82243F74;
		  /* 82243F74h */ case    6:  		/* bl -967532 */
		/* 82243F74h case    6:*/		regs.LR = 0x82243F78; return 0x82157C08;
		/* 82243F74h case    6:*/		return 0x82243F78;
		  /* 82243F78h */ case    7:  		/* lwz R30, <#[R1 + 80]> */
		/* 82243F78h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 82243F78h case    7:*/		return 0x82243F7C;
	}
	return 0x82243F7C;
} // Block from 82243F5Ch-82243F7Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82243F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82243F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82243F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82243F7C);
		  /* 82243F7Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82243F7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82243F7Ch case    0:*/		return 0x82243F80;
		  /* 82243F80h */ case    1:  		/* mr R6, R30 */
		/* 82243F80h case    1:*/		regs.R6 = regs.R30;
		/* 82243F80h case    1:*/		return 0x82243F84;
		  /* 82243F84h */ case    2:  		/* li R5, 0 */
		/* 82243F84h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82243F84h case    2:*/		return 0x82243F88;
		  /* 82243F88h */ case    3:  		/* li R4, 1 */
		/* 82243F88h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243F88h case    3:*/		return 0x82243F8C;
		  /* 82243F8Ch */ case    4:  		/* mr R3, R31 */
		/* 82243F8Ch case    4:*/		regs.R3 = regs.R31;
		/* 82243F8Ch case    4:*/		return 0x82243F90;
		  /* 82243F90h */ case    5:  		/* lwz R11, <#[R11 + 88]> */
		/* 82243F90h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 82243F90h case    5:*/		return 0x82243F94;
		  /* 82243F94h */ case    6:  		/* mtspr CTR, R11 */
		/* 82243F94h case    6:*/		regs.CTR = regs.R11;
		/* 82243F94h case    6:*/		return 0x82243F98;
		  /* 82243F98h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82243F98h case    7:*/		if ( 1 ) { regs.LR = 0x82243F9C; return (uint32)regs.CTR; }
		/* 82243F98h case    7:*/		return 0x82243F9C;
		  /* 82243F9Ch */ case    8:  		/* lwz R11, <#[R31]> */
		/* 82243F9Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82243F9Ch case    8:*/		return 0x82243FA0;
		  /* 82243FA0h */ case    9:  		/* mr R6, R30 */
		/* 82243FA0h case    9:*/		regs.R6 = regs.R30;
		/* 82243FA0h case    9:*/		return 0x82243FA4;
		  /* 82243FA4h */ case   10:  		/* li R5, 1 */
		/* 82243FA4h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82243FA4h case   10:*/		return 0x82243FA8;
		  /* 82243FA8h */ case   11:  		/* li R4, 1 */
		/* 82243FA8h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243FA8h case   11:*/		return 0x82243FAC;
		  /* 82243FACh */ case   12:  		/* mr R3, R31 */
		/* 82243FACh case   12:*/		regs.R3 = regs.R31;
		/* 82243FACh case   12:*/		return 0x82243FB0;
		  /* 82243FB0h */ case   13:  		/* lwz R11, <#[R11 + 88]> */
		/* 82243FB0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 82243FB0h case   13:*/		return 0x82243FB4;
		  /* 82243FB4h */ case   14:  		/* mtspr CTR, R11 */
		/* 82243FB4h case   14:*/		regs.CTR = regs.R11;
		/* 82243FB4h case   14:*/		return 0x82243FB8;
		  /* 82243FB8h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 82243FB8h case   15:*/		if ( 1 ) { regs.LR = 0x82243FBC; return (uint32)regs.CTR; }
		/* 82243FB8h case   15:*/		return 0x82243FBC;
		  /* 82243FBCh */ case   16:  		/* lwz R11, <#[R31]> */
		/* 82243FBCh case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82243FBCh case   16:*/		return 0x82243FC0;
		  /* 82243FC0h */ case   17:  		/* mr R6, R30 */
		/* 82243FC0h case   17:*/		regs.R6 = regs.R30;
		/* 82243FC0h case   17:*/		return 0x82243FC4;
		  /* 82243FC4h */ case   18:  		/* li R5, 2 */
		/* 82243FC4h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82243FC4h case   18:*/		return 0x82243FC8;
		  /* 82243FC8h */ case   19:  		/* li R4, 1 */
		/* 82243FC8h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243FC8h case   19:*/		return 0x82243FCC;
		  /* 82243FCCh */ case   20:  		/* mr R3, R31 */
		/* 82243FCCh case   20:*/		regs.R3 = regs.R31;
		/* 82243FCCh case   20:*/		return 0x82243FD0;
		  /* 82243FD0h */ case   21:  		/* lwz R11, <#[R11 + 88]> */
		/* 82243FD0h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 82243FD0h case   21:*/		return 0x82243FD4;
		  /* 82243FD4h */ case   22:  		/* mtspr CTR, R11 */
		/* 82243FD4h case   22:*/		regs.CTR = regs.R11;
		/* 82243FD4h case   22:*/		return 0x82243FD8;
		  /* 82243FD8h */ case   23:  		/* bcctrl 20, CR0_LT */
		/* 82243FD8h case   23:*/		if ( 1 ) { regs.LR = 0x82243FDC; return (uint32)regs.CTR; }
		/* 82243FD8h case   23:*/		return 0x82243FDC;
		  /* 82243FDCh */ case   24:  		/* lwz R11, <#[R31]> */
		/* 82243FDCh case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82243FDCh case   24:*/		return 0x82243FE0;
		  /* 82243FE0h */ case   25:  		/* mr R6, R30 */
		/* 82243FE0h case   25:*/		regs.R6 = regs.R30;
		/* 82243FE0h case   25:*/		return 0x82243FE4;
		  /* 82243FE4h */ case   26:  		/* li R5, 3 */
		/* 82243FE4h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82243FE4h case   26:*/		return 0x82243FE8;
		  /* 82243FE8h */ case   27:  		/* li R4, 1 */
		/* 82243FE8h case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82243FE8h case   27:*/		return 0x82243FEC;
		  /* 82243FECh */ case   28:  		/* mr R3, R31 */
		/* 82243FECh case   28:*/		regs.R3 = regs.R31;
		/* 82243FECh case   28:*/		return 0x82243FF0;
		  /* 82243FF0h */ case   29:  		/* lwz R11, <#[R11 + 88]> */
		/* 82243FF0h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 82243FF0h case   29:*/		return 0x82243FF4;
		  /* 82243FF4h */ case   30:  		/* mtspr CTR, R11 */
		/* 82243FF4h case   30:*/		regs.CTR = regs.R11;
		/* 82243FF4h case   30:*/		return 0x82243FF8;
		  /* 82243FF8h */ case   31:  		/* bcctrl 20, CR0_LT */
		/* 82243FF8h case   31:*/		if ( 1 ) { regs.LR = 0x82243FFC; return (uint32)regs.CTR; }
		/* 82243FF8h case   31:*/		return 0x82243FFC;
		  /* 82243FFCh */ case   32:  		/* mr R4, R31 */
		/* 82243FFCh case   32:*/		regs.R4 = regs.R31;
		/* 82243FFCh case   32:*/		return 0x82244000;
		  /* 82244000h */ case   33:  		/* mr R3, R26 */
		/* 82244000h case   33:*/		regs.R3 = regs.R26;
		/* 82244000h case   33:*/		return 0x82244004;
		  /* 82244004h */ case   34:  		/* bl 85876 */
		/* 82244004h case   34:*/		regs.LR = 0x82244008; return 0x82258F78;
		/* 82244004h case   34:*/		return 0x82244008;
		  /* 82244008h */ case   35:  		/* b 96 */
		/* 82244008h case   35:*/		return 0x82244068;
		/* 82244008h case   35:*/		return 0x8224400C;
	}
	return 0x8224400C;
} // Block from 82243F7Ch-8224400Ch (36 instructions)

//////////////////////////////////////////////////////
// Block at 8224400Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224400C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224400C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224400C);
		  /* 8224400Ch */ case    0:  		/* lwz R11, <#[R29 + 100]> */
		/* 8224400Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000064) );
		/* 8224400Ch case    0:*/		return 0x82244010;
		  /* 82244010h */ case    1:  		/* lwz R10, <#[R11 + 4]> */
		/* 82244010h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82244010h case    1:*/		return 0x82244014;
		  /* 82244014h */ case    2:  		/* cmplwi CR6, R10, 1 */
		/* 82244014h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82244014h case    2:*/		return 0x82244018;
		  /* 82244018h */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 82244018h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224404C;  }
		/* 82244018h case    3:*/		return 0x8224401C;
		  /* 8224401Ch */ case    4:  		/* rlwinm R9, R10, 0, 0, 31 */
		/* 8224401Ch case    4:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R10);
		/* 8224401Ch case    4:*/		return 0x82244020;
		  /* 82244020h */ case    5:  		/* addi R10, R9, -1 */
		/* 82244020h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 82244020h case    5:*/		return 0x82244024;
		  /* 82244024h */ case    6:  		/* cmplw CR6, R10, R9 */
		/* 82244024h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82244024h case    6:*/		return 0x82244028;
		  /* 82244028h */ case    7:  		/* bc 4, CR6_LT, 20 */
		/* 82244028h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8224403C;  }
		/* 82244028h case    7:*/		return 0x8224402C;
		  /* 8224402Ch */ case    8:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224402Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224402Ch case    8:*/		return 0x82244030;
		  /* 82244030h */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82244030h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82244030h case    9:*/		return 0x82244034;
		  /* 82244034h */ case   10:  		/* add R11, R10, R11 */
		/* 82244034h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82244034h case   10:*/		return 0x82244038;
		  /* 82244038h */ case   11:  		/* b 8 */
		/* 82244038h case   11:*/		return 0x82244040;
		/* 82244038h case   11:*/		return 0x8224403C;
	}
	return 0x8224403C;
} // Block from 8224400Ch-8224403Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224403Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224403C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224403C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224403C);
		  /* 8224403Ch */ case    0:  		/* li R11, 0 */
		/* 8224403Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224403Ch case    0:*/		return 0x82244040;
	}
	return 0x82244040;
} // Block from 8224403Ch-82244040h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82244040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244040);
		  /* 82244040h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82244040h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82244040h case    0:*/		return 0x82244044;
		  /* 82244044h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82244044h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82244044h case    1:*/		return 0x82244048;
		  /* 82244048h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 82244048h case    2:*/		if ( regs.CR[6].eq ) { return 0x82244068;  }
		/* 82244048h case    2:*/		return 0x8224404C;
	}
	return 0x8224404C;
} // Block from 82244040h-8224404Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224404Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224404C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224404C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224404C);
		  /* 8224404Ch */ case    0:  		/* lis R11, -32252 */
		/* 8224404Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224404Ch case    0:*/		return 0x82244050;
		  /* 82244050h */ case    1:  		/* mr R6, R27 */
		/* 82244050h case    1:*/		regs.R6 = regs.R27;
		/* 82244050h case    1:*/		return 0x82244054;
		  /* 82244054h */ case    2:  		/* addi R5, R11, 12336 */
		/* 82244054h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3030);
		/* 82244054h case    2:*/		return 0x82244058;
		  /* 82244058h */ case    3:  		/* mr R4, R28 */
		/* 82244058h case    3:*/		regs.R4 = regs.R28;
		/* 82244058h case    3:*/		return 0x8224405C;
		  /* 8224405Ch */ case    4:  		/* li R7, 828 */
		/* 8224405Ch case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x33C);
		/* 8224405Ch case    4:*/		return 0x82244060;
		  /* 82244060h */ case    5:  		/* li R3, 0 */
		/* 82244060h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82244060h case    5:*/		return 0x82244064;
		  /* 82244064h */ case    6:  		/* bl -967772 */
		/* 82244064h case    6:*/		regs.LR = 0x82244068; return 0x82157C08;
		/* 82244064h case    6:*/		return 0x82244068;
	}
	return 0x82244068;
} // Block from 8224404Ch-82244068h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82244068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244068);
		  /* 82244068h */ case    0:  		/* addi R4, R26, 20 */
		/* 82244068h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x14);
		/* 82244068h case    0:*/		return 0x8224406C;
		  /* 8224406Ch */ case    1:  		/* lbz R5, <#[R26 + 124]> */
		/* 8224406Ch case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R26 + 0x0000007C) );
		/* 8224406Ch case    1:*/		return 0x82244070;
		  /* 82244070h */ case    2:  		/* mr R3, R29 */
		/* 82244070h case    2:*/		regs.R3 = regs.R29;
		/* 82244070h case    2:*/		return 0x82244074;
		  /* 82244074h */ case    3:  		/* bl -10180 */
		/* 82244074h case    3:*/		regs.LR = 0x82244078; return 0x822418B0;
		/* 82244074h case    3:*/		return 0x82244078;
		  /* 82244078h */ case    4:  		/* addi R1, R1, 160 */
		/* 82244078h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82244078h case    4:*/		return 0x8224407C;
		  /* 8224407Ch */ case    5:  		/* b -1781220 */
		/* 8224407Ch case    5:*/		return 0x82091298;
		/* 8224407Ch case    5:*/		return 0x82244080;
	}
	return 0x82244080;
} // Block from 82244068h-82244080h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82244080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244080);
		  /* 82244080h */ case    0:  		/* mfspr R12, LR */
		/* 82244080h case    0:*/		regs.R12 = regs.LR;
		/* 82244080h case    0:*/		return 0x82244084;
		  /* 82244084h */ case    1:  		/* bl -1781288 */
		/* 82244084h case    1:*/		regs.LR = 0x82244088; return 0x8209125C;
		/* 82244084h case    1:*/		return 0x82244088;
		  /* 82244088h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82244088h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82244088h case    2:*/		return 0x8224408C;
		  /* 8224408Ch */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 8224408Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8224408Ch case    3:*/		return 0x82244090;
		  /* 82244090h */ case    4:  		/* mr R31, R3 */
		/* 82244090h case    4:*/		regs.R31 = regs.R3;
		/* 82244090h case    4:*/		return 0x82244094;
		  /* 82244094h */ case    5:  		/* mr R30, R4 */
		/* 82244094h case    5:*/		regs.R30 = regs.R4;
		/* 82244094h case    5:*/		return 0x82244098;
		  /* 82244098h */ case    6:  		/* lbz R11, <#[R11]> */
		/* 82244098h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82244098h case    6:*/		return 0x8224409C;
		  /* 8224409Ch */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 8224409Ch case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224409Ch case    7:*/		return 0x822440A0;
		  /* 822440A0h */ case    8:  		/* bc 4, CR0_EQ, 112 */
		/* 822440A0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82244110;  }
		/* 822440A0h case    8:*/		return 0x822440A4;
		  /* 822440A4h */ case    9:  		/* mr R3, R4 */
		/* 822440A4h case    9:*/		regs.R3 = regs.R4;
		/* 822440A4h case    9:*/		return 0x822440A8;
		  /* 822440A8h */ case   10:  		/* bl -21648 */
		/* 822440A8h case   10:*/		regs.LR = 0x822440AC; return 0x8223EC18;
		/* 822440A8h case   10:*/		return 0x822440AC;
		  /* 822440ACh */ case   11:  		/* mr R29, R3 */
		/* 822440ACh case   11:*/		regs.R29 = regs.R3;
		/* 822440ACh case   11:*/		return 0x822440B0;
		  /* 822440B0h */ case   12:  		/* li R3, 90 */
		/* 822440B0h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x5A);
		/* 822440B0h case   12:*/		return 0x822440B4;
		  /* 822440B4h */ case   13:  		/* lwz R4, <#[R31 + 12]> */
		/* 822440B4h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 822440B4h case   13:*/		return 0x822440B8;
		  /* 822440B8h */ case   14:  		/* bl 73336 */
		/* 822440B8h case   14:*/		regs.LR = 0x822440BC; return 0x82255F30;
		/* 822440B8h case   14:*/		return 0x822440BC;
		  /* 822440BCh */ case   15:  		/* lis R11, -32252 */
		/* 822440BCh case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822440BCh case   15:*/		return 0x822440C0;
		  /* 822440C0h */ case   16:  		/* lwz R10, <#[R29 + 56]> */
		/* 822440C0h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000038) );
		/* 822440C0h case   16:*/		return 0x822440C4;
		  /* 822440C4h */ case   17:  		/* li R9, 0 */
		/* 822440C4h case   17:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 822440C4h case   17:*/		return 0x822440C8;
		  /* 822440C8h */ case   18:  		/* li R8, 3 */
		/* 822440C8h case   18:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 822440C8h case   18:*/		return 0x822440CC;
		  /* 822440CCh */ case   19:  		/* stw R9, <#[R3 + 80]> */
		/* 822440CCh case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000050) );
		/* 822440CCh case   19:*/		return 0x822440D0;
		  /* 822440D0h */ case   20:  		/* lis R7, -32252 */
		/* 822440D0h case   20:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8204);
		/* 822440D0h case   20:*/		return 0x822440D4;
		  /* 822440D4h */ case   21:  		/* li R5, 1 */
		/* 822440D4h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 822440D4h case   21:*/		return 0x822440D8;
		  /* 822440D8h */ case   22:  		/* lwz R11, <#[R11 + 9924]> */
		/* 822440D8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000026C4) );
		/* 822440D8h case   22:*/		return 0x822440DC;
		  /* 822440DCh */ case   23:  		/* mr R29, R3 */
		/* 822440DCh case   23:*/		regs.R29 = regs.R3;
		/* 822440DCh case   23:*/		return 0x822440E0;
		  /* 822440E0h */ case   24:  		/* stw R10, <#[R3 + 56]> */
		/* 822440E0h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000038) );
		/* 822440E0h case   24:*/		return 0x822440E4;
		  /* 822440E4h */ case   25:  		/* lfs FR4, <#[R7 + 12300]> */
		/* 822440E4h case   25:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R7 + 0x0000300C) );
		/* 822440E4h case   25:*/		return 0x822440E8;
		  /* 822440E8h */ case   26:  		/* fmr FR3, FR4 */
		/* 822440E8h case   26:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 822440E8h case   26:*/		return 0x822440EC;
		  /* 822440ECh */ case   27:  		/* stw R11, <#[R3 + 128]> */
		/* 822440ECh case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 822440ECh case   27:*/		return 0x822440F0;
		  /* 822440F0h */ case   28:  		/* fmr FR2, FR4 */
		/* 822440F0h case   28:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 822440F0h case   28:*/		return 0x822440F4;
		  /* 822440F4h */ case   29:  		/* stw R8, <#[R3 + 52]> */
		/* 822440F4h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000034) );
		/* 822440F4h case   29:*/		return 0x822440F8;
		  /* 822440F8h */ case   30:  		/* fmr FR1, FR4 */
		/* 822440F8h case   30:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 822440F8h case   30:*/		return 0x822440FC;
		  /* 822440FCh */ case   31:  		/* lwz R4, <#[R31 + 16]> */
		/* 822440FCh case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 822440FCh case   31:*/		return 0x82244100;
		  /* 82244100h */ case   32:  		/* bl 77336 */
		/* 82244100h case   32:*/		regs.LR = 0x82244104; return 0x82256F18;
		/* 82244100h case   32:*/		return 0x82244104;
		  /* 82244104h */ case   33:  		/* mr R4, R29 */
		/* 82244104h case   33:*/		regs.R4 = regs.R29;
		/* 82244104h case   33:*/		return 0x82244108;
		  /* 82244108h */ case   34:  		/* mr R3, R31 */
		/* 82244108h case   34:*/		regs.R3 = regs.R31;
		/* 82244108h case   34:*/		return 0x8224410C;
		  /* 8224410Ch */ case   35:  		/* bl 85540 */
		/* 8224410Ch case   35:*/		regs.LR = 0x82244110; return 0x82258F30;
		/* 8224410Ch case   35:*/		return 0x82244110;
	}
	return 0x82244110;
} // Block from 82244080h-82244110h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82244110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244110);
		  /* 82244110h */ case    0:  		/* addi R4, R31, 20 */
		/* 82244110h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x14);
		/* 82244110h case    0:*/		return 0x82244114;
		  /* 82244114h */ case    1:  		/* lbz R5, <#[R31 + 124]> */
		/* 82244114h case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000007C) );
		/* 82244114h case    1:*/		return 0x82244118;
		  /* 82244118h */ case    2:  		/* mr R3, R30 */
		/* 82244118h case    2:*/		regs.R3 = regs.R30;
		/* 82244118h case    2:*/		return 0x8224411C;
		  /* 8224411Ch */ case    3:  		/* bl -10348 */
		/* 8224411Ch case    3:*/		regs.LR = 0x82244120; return 0x822418B0;
		/* 8224411Ch case    3:*/		return 0x82244120;
		  /* 82244120h */ case    4:  		/* addi R1, R1, 112 */
		/* 82244120h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82244120h case    4:*/		return 0x82244124;
		  /* 82244124h */ case    5:  		/* b -1781368 */
		/* 82244124h case    5:*/		return 0x820912AC;
		/* 82244124h case    5:*/		return 0x82244128;
	}
	return 0x82244128;
} // Block from 82244110h-82244128h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82244128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244128);
		  /* 82244128h */ case    0:  		/* mfspr R12, LR */
		/* 82244128h case    0:*/		regs.R12 = regs.LR;
		/* 82244128h case    0:*/		return 0x8224412C;
		  /* 8224412Ch */ case    1:  		/* bl -1781456 */
		/* 8224412Ch case    1:*/		regs.LR = 0x82244130; return 0x8209125C;
		/* 8224412Ch case    1:*/		return 0x82244130;
	}
	return 0x82244130;
} // Block from 82244128h-82244130h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244130h
// Function '?AssembleAsConditionalBreak@IfHeader@XGRAPHICS@@QAAXAAVAssembler@2@AA_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244130);
		  /* 82244130h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82244130h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82244130h case    0:*/		return 0x82244134;
		  /* 82244134h */ case    1:  		/* lwz R11, <#[R3 + 16]> */
		/* 82244134h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82244134h case    1:*/		return 0x82244138;
		  /* 82244138h */ case    2:  		/* mr R31, R3 */
		/* 82244138h case    2:*/		regs.R31 = regs.R3;
		/* 82244138h case    2:*/		return 0x8224413C;
		  /* 8224413Ch */ case    3:  		/* mr R30, R4 */
		/* 8224413Ch case    3:*/		regs.R30 = regs.R4;
		/* 8224413Ch case    3:*/		return 0x82244140;
		  /* 82244140h */ case    4:  		/* lbz R11, <#[R11]> */
		/* 82244140h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82244140h case    4:*/		return 0x82244144;
		  /* 82244144h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 82244144h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82244144h case    5:*/		return 0x82244148;
		  /* 82244148h */ case    6:  		/* bc 4, CR0_EQ, 112 */
		/* 82244148h case    6:*/		if ( !regs.CR[0].eq ) { return 0x822441B8;  }
		/* 82244148h case    6:*/		return 0x8224414C;
		  /* 8224414Ch */ case    7:  		/* mr R3, R4 */
		/* 8224414Ch case    7:*/		regs.R3 = regs.R4;
		/* 8224414Ch case    7:*/		return 0x82244150;
		  /* 82244150h */ case    8:  		/* bl -21816 */
		/* 82244150h case    8:*/		regs.LR = 0x82244154; return 0x8223EC18;
		/* 82244150h case    8:*/		return 0x82244154;
		  /* 82244154h */ case    9:  		/* mr R29, R3 */
		/* 82244154h case    9:*/		regs.R29 = regs.R3;
		/* 82244154h case    9:*/		return 0x82244158;
		  /* 82244158h */ case   10:  		/* li R3, 90 */
		/* 82244158h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x5A);
		/* 82244158h case   10:*/		return 0x8224415C;
		  /* 8224415Ch */ case   11:  		/* lwz R4, <#[R31 + 12]> */
		/* 8224415Ch case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224415Ch case   11:*/		return 0x82244160;
		  /* 82244160h */ case   12:  		/* bl 73168 */
		/* 82244160h case   12:*/		regs.LR = 0x82244164; return 0x82255F30;
		/* 82244160h case   12:*/		return 0x82244164;
		  /* 82244164h */ case   13:  		/* lis R11, -32252 */
		/* 82244164h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82244164h case   13:*/		return 0x82244168;
		  /* 82244168h */ case   14:  		/* lwz R10, <#[R29 + 56]> */
		/* 82244168h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000038) );
		/* 82244168h case   14:*/		return 0x8224416C;
		  /* 8224416Ch */ case   15:  		/* li R9, 0 */
		/* 8224416Ch case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8224416Ch case   15:*/		return 0x82244170;
		  /* 82244170h */ case   16:  		/* li R8, 3 */
		/* 82244170h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 82244170h case   16:*/		return 0x82244174;
		  /* 82244174h */ case   17:  		/* stw R9, <#[R3 + 80]> */
		/* 82244174h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000050) );
		/* 82244174h case   17:*/		return 0x82244178;
		  /* 82244178h */ case   18:  		/* lis R7, -32252 */
		/* 82244178h case   18:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8204);
		/* 82244178h case   18:*/		return 0x8224417C;
		  /* 8224417Ch */ case   19:  		/* li R5, 1 */
		/* 8224417Ch case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8224417Ch case   19:*/		return 0x82244180;
		  /* 82244180h */ case   20:  		/* lwz R11, <#[R11 + 9924]> */
		/* 82244180h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000026C4) );
		/* 82244180h case   20:*/		return 0x82244184;
		  /* 82244184h */ case   21:  		/* mr R29, R3 */
		/* 82244184h case   21:*/		regs.R29 = regs.R3;
		/* 82244184h case   21:*/		return 0x82244188;
		  /* 82244188h */ case   22:  		/* stw R10, <#[R3 + 56]> */
		/* 82244188h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000038) );
		/* 82244188h case   22:*/		return 0x8224418C;
		  /* 8224418Ch */ case   23:  		/* lfs FR4, <#[R7 - 25384]> */
		/* 8224418Ch case   23:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R7 + 0xFFFF9CD8) );
		/* 8224418Ch case   23:*/		return 0x82244190;
		  /* 82244190h */ case   24:  		/* fmr FR3, FR4 */
		/* 82244190h case   24:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 82244190h case   24:*/		return 0x82244194;
		  /* 82244194h */ case   25:  		/* stw R11, <#[R3 + 128]> */
		/* 82244194h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 82244194h case   25:*/		return 0x82244198;
		  /* 82244198h */ case   26:  		/* fmr FR2, FR4 */
		/* 82244198h case   26:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 82244198h case   26:*/		return 0x8224419C;
		  /* 8224419Ch */ case   27:  		/* stw R8, <#[R3 + 52]> */
		/* 8224419Ch case   27:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000034) );
		/* 8224419Ch case   27:*/		return 0x822441A0;
		  /* 822441A0h */ case   28:  		/* fmr FR1, FR4 */
		/* 822441A0h case   28:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 822441A0h case   28:*/		return 0x822441A4;
		  /* 822441A4h */ case   29:  		/* lwz R4, <#[R31 + 16]> */
		/* 822441A4h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 822441A4h case   29:*/		return 0x822441A8;
		  /* 822441A8h */ case   30:  		/* bl 77168 */
		/* 822441A8h case   30:*/		regs.LR = 0x822441AC; return 0x82256F18;
		/* 822441A8h case   30:*/		return 0x822441AC;
		  /* 822441ACh */ case   31:  		/* mr R4, R29 */
		/* 822441ACh case   31:*/		regs.R4 = regs.R29;
		/* 822441ACh case   31:*/		return 0x822441B0;
		  /* 822441B0h */ case   32:  		/* mr R3, R31 */
		/* 822441B0h case   32:*/		regs.R3 = regs.R31;
		/* 822441B0h case   32:*/		return 0x822441B4;
		  /* 822441B4h */ case   33:  		/* bl 85372 */
		/* 822441B4h case   33:*/		regs.LR = 0x822441B8; return 0x82258F30;
		/* 822441B4h case   33:*/		return 0x822441B8;
	}
	return 0x822441B8;
} // Block from 82244130h-822441B8h (34 instructions)

//////////////////////////////////////////////////////
// Block at 822441B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822441B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822441B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822441B8);
		  /* 822441B8h */ case    0:  		/* addi R4, R31, 20 */
		/* 822441B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x14);
		/* 822441B8h case    0:*/		return 0x822441BC;
		  /* 822441BCh */ case    1:  		/* lbz R5, <#[R31 + 124]> */
		/* 822441BCh case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000007C) );
		/* 822441BCh case    1:*/		return 0x822441C0;
		  /* 822441C0h */ case    2:  		/* mr R3, R30 */
		/* 822441C0h case    2:*/		regs.R3 = regs.R30;
		/* 822441C0h case    2:*/		return 0x822441C4;
		  /* 822441C4h */ case    3:  		/* bl -10516 */
		/* 822441C4h case    3:*/		regs.LR = 0x822441C8; return 0x822418B0;
		/* 822441C4h case    3:*/		return 0x822441C8;
		  /* 822441C8h */ case    4:  		/* addi R1, R1, 112 */
		/* 822441C8h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822441C8h case    4:*/		return 0x822441CC;
		  /* 822441CCh */ case    5:  		/* b -1781536 */
		/* 822441CCh case    5:*/		return 0x820912AC;
		/* 822441CCh case    5:*/		return 0x822441D0;
	}
	return 0x822441D0;
} // Block from 822441B8h-822441D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822441D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822441D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822441D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822441D0);
		  /* 822441D0h */ case    0:  		/* mfspr R12, LR */
		/* 822441D0h case    0:*/		regs.R12 = regs.LR;
		/* 822441D0h case    0:*/		return 0x822441D4;
		  /* 822441D4h */ case    1:  		/* bl -1781636 */
		/* 822441D4h case    1:*/		regs.LR = 0x822441D8; return 0x82091250;
		/* 822441D4h case    1:*/		return 0x822441D8;
		  /* 822441D8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 822441D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822441D8h case    2:*/		return 0x822441DC;
		  /* 822441DCh */ case    3:  		/* lwz R29, <#[R4 + 148]> */
		/* 822441DCh case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x00000094) );
		/* 822441DCh case    3:*/		return 0x822441E0;
		  /* 822441E0h */ case    4:  		/* lis R11, -32253 */
		/* 822441E0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 822441E0h case    4:*/		return 0x822441E4;
		  /* 822441E4h */ case    5:  		/* lis R10, -32252 */
		/* 822441E4h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822441E4h case    5:*/		return 0x822441E8;
		  /* 822441E8h */ case    6:  		/* mr R30, R3 */
		/* 822441E8h case    6:*/		regs.R30 = regs.R3;
		/* 822441E8h case    6:*/		return 0x822441EC;
		  /* 822441ECh */ case    7:  		/* mr R31, R4 */
		/* 822441ECh case    7:*/		regs.R31 = regs.R4;
		/* 822441ECh case    7:*/		return 0x822441F0;
		  /* 822441F0h */ case    8:  		/* cmplwi CR6, R29, 0 */
		/* 822441F0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 822441F0h case    8:*/		return 0x822441F4;
		  /* 822441F4h */ case    9:  		/* addi R28, R11, 27460 */
		/* 822441F4h case    9:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x6B44);
		/* 822441F4h case    9:*/		return 0x822441F8;
		  /* 822441F8h */ case   10:  		/* addi R27, R10, 10344 */
		/* 822441F8h case   10:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R10,0x2868);
		/* 822441F8h case   10:*/		return 0x822441FC;
		  /* 822441FCh */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 822441FCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x8224421C;  }
		/* 822441FCh case   11:*/		return 0x82244200;
		  /* 82244200h */ case   12:  		/* lis R11, -32252 */
		/* 82244200h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82244200h case   12:*/		return 0x82244204;
		  /* 82244204h */ case   13:  		/* mr R6, R27 */
		/* 82244204h case   13:*/		regs.R6 = regs.R27;
		/* 82244204h case   13:*/		return 0x82244208;
		  /* 82244208h */ case   14:  		/* addi R5, R11, 12416 */
		/* 82244208h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3080);
		/* 82244208h case   14:*/		return 0x8224420C;
		  /* 8224420Ch */ case   15:  		/* mr R4, R28 */
		/* 8224420Ch case   15:*/		regs.R4 = regs.R28;
		/* 8224420Ch case   15:*/		return 0x82244210;
		  /* 82244210h */ case   16:  		/* li R7, 1628 */
		/* 82244210h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x65C);
		/* 82244210h case   16:*/		return 0x82244214;
		  /* 82244214h */ case   17:  		/* li R3, 0 */
		/* 82244214h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82244214h case   17:*/		return 0x82244218;
		  /* 82244218h */ case   18:  		/* bl -968208 */
		/* 82244218h case   18:*/		regs.LR = 0x8224421C; return 0x82157C08;
		/* 82244218h case   18:*/		return 0x8224421C;
	}
	return 0x8224421C;
} // Block from 822441D0h-8224421Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224421Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224421C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224421C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224421C);
		  /* 8224421Ch */ case    0:  		/* addi R3, R29, 20 */
		/* 8224421Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R29,0x14);
		/* 8224421Ch case    0:*/		return 0x82244220;
		  /* 82244220h */ case    1:  		/* bl 63040 */
		/* 82244220h case    1:*/		regs.LR = 0x82244224; return 0x82253860;
		/* 82244220h case    1:*/		return 0x82244224;
		  /* 82244224h */ case    2:  		/* li R26, 0 */
		/* 82244224h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82244224h case    2:*/		return 0x82244228;
		  /* 82244228h */ case    3:  		/* cmpwi CR6, R3, 2 */
		/* 82244228h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82244228h case    3:*/		return 0x8224422C;
		  /* 8224422Ch */ case    4:  		/* bc 12, CR6_GT, 64 */
		/* 8224422Ch case    4:*/		if ( regs.CR[6].gt ) { return 0x8224426C;  }
		/* 8224422Ch case    4:*/		return 0x82244230;
		  /* 82244230h */ case    5:  		/* mr R3, R29 */
		/* 82244230h case    5:*/		regs.R3 = regs.R29;
		/* 82244230h case    5:*/		return 0x82244234;
		  /* 82244234h */ case    6:  		/* bl 86676 */
		/* 82244234h case    6:*/		regs.LR = 0x82244238; return 0x822594C8;
		/* 82244234h case    6:*/		return 0x82244238;
		  /* 82244238h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82244238h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82244238h case    7:*/		return 0x8224423C;
		  /* 8224423Ch */ case    8:  		/* bc 12, CR0_EQ, 48 */
		/* 8224423Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x8224426C;  }
		/* 8224423Ch case    8:*/		return 0x82244240;
		  /* 82244240h */ case    9:  		/* lwz R11, <#[R29 + 56]> */
		/* 82244240h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000038) );
		/* 82244240h case    9:*/		return 0x82244244;
		  /* 82244244h */ case   10:  		/* lwz R10, <#[R11 + 4]> */
		/* 82244244h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82244244h case   10:*/		return 0x82244248;
		  /* 82244248h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 82244248h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82244248h case   11:*/		return 0x8224424C;
		  /* 8224424Ch */ case   12:  		/* bc 4, CR6_GT, 12 */
		/* 8224424Ch case   12:*/		if ( !regs.CR[6].gt ) { return 0x82244258;  }
		/* 8224424Ch case   12:*/		return 0x82244250;
		  /* 82244250h */ case   13:  		/* lwz R11, <#[R11 + 8]> */
		/* 82244250h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82244250h case   13:*/		return 0x82244254;
		  /* 82244254h */ case   14:  		/* b 8 */
		/* 82244254h case   14:*/		return 0x8224425C;
		/* 82244254h case   14:*/		return 0x82244258;
	}
	return 0x82244258;
} // Block from 8224421Ch-82244258h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82244258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244258);
		  /* 82244258h */ case    0:  		/* mr R11, R26 */
		/* 82244258h case    0:*/		regs.R11 = regs.R26;
		/* 82244258h case    0:*/		return 0x8224425C;
	}
	return 0x8224425C;
} // Block from 82244258h-8224425Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224425Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224425C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224425C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224425C);
		  /* 8224425Ch */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8224425Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8224425Ch case    0:*/		return 0x82244260;
		  /* 82244260h */ case    1:  		/* lwz R10, <#[R31 + 152]> */
		/* 82244260h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000098) );
		/* 82244260h case    1:*/		return 0x82244264;
		  /* 82244264h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82244264h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244264h case    2:*/		return 0x82244268;
		  /* 82244268h */ case    3:  		/* bc 12, CR6_EQ, 388 */
		/* 82244268h case    3:*/		if ( regs.CR[6].eq ) { return 0x822443EC;  }
		/* 82244268h case    3:*/		return 0x8224426C;
	}
	return 0x8224426C;
} // Block from 8224425Ch-8224426Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224426Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224426C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224426C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224426C);
		  /* 8224426Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8224426Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224426Ch case    0:*/		return 0x82244270;
		  /* 82244270h */ case    1:  		/* mr R3, R31 */
		/* 82244270h case    1:*/		regs.R3 = regs.R31;
		/* 82244270h case    1:*/		return 0x82244274;
		  /* 82244274h */ case    2:  		/* lwz R11, <#[R11 + 48]> */
		/* 82244274h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82244274h case    2:*/		return 0x82244278;
		  /* 82244278h */ case    3:  		/* mtspr CTR, R11 */
		/* 82244278h case    3:*/		regs.CTR = regs.R11;
		/* 82244278h case    3:*/		return 0x8224427C;
		  /* 8224427Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224427Ch case    4:*/		if ( 1 ) { regs.LR = 0x82244280; return (uint32)regs.CTR; }
		/* 8224427Ch case    4:*/		return 0x82244280;
		  /* 82244280h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82244280h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82244280h case    5:*/		return 0x82244284;
		  /* 82244284h */ case    6:  		/* bc 12, CR0_EQ, 44 */
		/* 82244284h case    6:*/		if ( regs.CR[0].eq ) { return 0x822442B0;  }
		/* 82244284h case    6:*/		return 0x82244288;
		  /* 82244288h */ case    7:  		/* lwz R11, <#[R30 + 56]> */
		/* 82244288h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 82244288h case    7:*/		return 0x8224428C;
		  /* 8224428Ch */ case    8:  		/* mr R3, R30 */
		/* 8224428Ch case    8:*/		regs.R3 = regs.R30;
		/* 8224428Ch case    8:*/		return 0x82244290;
		  /* 82244290h */ case    9:  		/* addi R4, R11, 1 */
		/* 82244290h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1);
		/* 82244290h case    9:*/		return 0x82244294;
		  /* 82244294h */ case   10:  		/* bl -9012 */
		/* 82244294h case   10:*/		regs.LR = 0x82244298; return 0x82241F60;
		/* 82244294h case   10:*/		return 0x82244298;
		  /* 82244298h */ case   11:  		/* li R6, 1 */
		/* 82244298h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82244298h case   11:*/		return 0x8224429C;
		  /* 8224429Ch */ case   12:  		/* li R5, 0 */
		/* 8224429Ch case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8224429Ch case   12:*/		return 0x822442A0;
		  /* 822442A0h */ case   13:  		/* li R4, 1 */
		/* 822442A0h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822442A0h case   13:*/		return 0x822442A4;
		  /* 822442A4h */ case   14:  		/* mr R3, R30 */
		/* 822442A4h case   14:*/		regs.R3 = regs.R30;
		/* 822442A4h case   14:*/		return 0x822442A8;
		  /* 822442A8h */ case   15:  		/* bl -8600 */
		/* 822442A8h case   15:*/		regs.LR = 0x822442AC; return 0x82242110;
		/* 822442A8h case   15:*/		return 0x822442AC;
		  /* 822442ACh */ case   16:  		/* b 320 */
		/* 822442ACh case   16:*/		return 0x822443EC;
		/* 822442ACh case   16:*/		return 0x822442B0;
	}
	return 0x822442B0;
} // Block from 8224426Ch-822442B0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822442B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822442B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822442B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822442B0);
		  /* 822442B0h */ case    0:  		/* lbz R11, <#[R31 + 140]> */
		/* 822442B0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 822442B0h case    0:*/		return 0x822442B4;
		  /* 822442B4h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 822442B4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822442B4h case    1:*/		return 0x822442B8;
		  /* 822442B8h */ case    2:  		/* bc 12, CR0_EQ, 84 */
		/* 822442B8h case    2:*/		if ( regs.CR[0].eq ) { return 0x8224430C;  }
		/* 822442B8h case    2:*/		return 0x822442BC;
		  /* 822442BCh */ case    3:  		/* lwz R3, <#[R30 + 100]> */
		/* 822442BCh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000064) );
		/* 822442BCh case    3:*/		return 0x822442C0;
		  /* 822442C0h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 822442C0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822442C0h case    4:*/		return 0x822442C4;
		  /* 822442C4h */ case    5:  		/* cmplwi CR6, R11, 2 */
		/* 822442C4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 822442C4h case    5:*/		return 0x822442C8;
		  /* 822442C8h */ case    6:  		/* bc 4, CR6_EQ, 68 */
		/* 822442C8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8224430C;  }
		/* 822442C8h case    6:*/		return 0x822442CC;
		  /* 822442CCh */ case    7:  		/* bl 92804 */
		/* 822442CCh case    7:*/		regs.LR = 0x822442D0; return 0x8225AD50;
		/* 822442CCh case    7:*/		return 0x822442D0;
		  /* 822442D0h */ case    8:  		/* cmpwi CR6, R3, 3 */
		/* 822442D0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 822442D0h case    8:*/		return 0x822442D4;
		  /* 822442D4h */ case    9:  		/* bc 12, CR6_EQ, 32 */
		/* 822442D4h case    9:*/		if ( regs.CR[6].eq ) { return 0x822442F4;  }
		/* 822442D4h case    9:*/		return 0x822442D8;
		  /* 822442D8h */ case   10:  		/* lis R11, -32252 */
		/* 822442D8h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822442D8h case   10:*/		return 0x822442DC;
		  /* 822442DCh */ case   11:  		/* mr R6, R27 */
		/* 822442DCh case   11:*/		regs.R6 = regs.R27;
		/* 822442DCh case   11:*/		return 0x822442E0;
		  /* 822442E0h */ case   12:  		/* addi R5, R11, 12304 */
		/* 822442E0h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3010);
		/* 822442E0h case   12:*/		return 0x822442E4;
		  /* 822442E4h */ case   13:  		/* mr R4, R28 */
		/* 822442E4h case   13:*/		regs.R4 = regs.R28;
		/* 822442E4h case   13:*/		return 0x822442E8;
		  /* 822442E8h */ case   14:  		/* li R7, 1648 */
		/* 822442E8h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x670);
		/* 822442E8h case   14:*/		return 0x822442EC;
		  /* 822442ECh */ case   15:  		/* li R3, 0 */
		/* 822442ECh case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822442ECh case   15:*/		return 0x822442F0;
		  /* 822442F0h */ case   16:  		/* bl -968424 */
		/* 822442F0h case   16:*/		regs.LR = 0x822442F4; return 0x82157C08;
		/* 822442F0h case   16:*/		return 0x822442F4;
	}
	return 0x822442F4;
} // Block from 822442B0h-822442F4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822442F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822442F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822442F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822442F4);
		  /* 822442F4h */ case    0:  		/* lwz R3, <#[R30 + 100]> */
		/* 822442F4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000064) );
		/* 822442F4h case    0:*/		return 0x822442F8;
		  /* 822442F8h */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 822442F8h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 822442F8h case    1:*/		return 0x822442FC;
		  /* 822442FCh */ case    2:  		/* bl 63428 */
		/* 822442FCh case    2:*/		regs.LR = 0x82244300; return 0x82253AC0;
		/* 822442FCh case    2:*/		return 0x82244300;
		  /* 82244300h */ case    3:  		/* li R11, 2 */
		/* 82244300h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 82244300h case    3:*/		return 0x82244304;
		  /* 82244304h */ case    4:  		/* stw R11, <#[R3]> */
		/* 82244304h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82244304h case    4:*/		return 0x82244308;
		  /* 82244308h */ case    5:  		/* b 228 */
		/* 82244308h case    5:*/		return 0x822443EC;
		/* 82244308h case    5:*/		return 0x8224430C;
	}
	return 0x8224430C;
} // Block from 822442F4h-8224430Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224430Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224430C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224430C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224430C);
		  /* 8224430Ch */ case    0:  		/* lwz R11, <#[R30 + 100]> */
		/* 8224430Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000064) );
		/* 8224430Ch case    0:*/		return 0x82244310;
		  /* 82244310h */ case    1:  		/* lwz R9, <#[R11 + 4]> */
		/* 82244310h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82244310h case    1:*/		return 0x82244314;
		  /* 82244314h */ case    2:  		/* addi R10, R9, -1 */
		/* 82244314h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 82244314h case    2:*/		return 0x82244318;
		  /* 82244318h */ case    3:  		/* cmplw CR6, R10, R9 */
		/* 82244318h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82244318h case    3:*/		return 0x8224431C;
		  /* 8224431Ch */ case    4:  		/* bc 4, CR6_LT, 20 */
		/* 8224431Ch case    4:*/		if ( !regs.CR[6].lt ) { return 0x82244330;  }
		/* 8224431Ch case    4:*/		return 0x82244320;
		  /* 82244320h */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 82244320h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82244320h case    5:*/		return 0x82244324;
		  /* 82244324h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82244324h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82244324h case    6:*/		return 0x82244328;
		  /* 82244328h */ case    7:  		/* add R11, R10, R11 */
		/* 82244328h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82244328h case    7:*/		return 0x8224432C;
		  /* 8224432Ch */ case    8:  		/* b 8 */
		/* 8224432Ch case    8:*/		return 0x82244334;
		/* 8224432Ch case    8:*/		return 0x82244330;
	}
	return 0x82244330;
} // Block from 8224430Ch-82244330h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82244330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244330);
		  /* 82244330h */ case    0:  		/* mr R11, R26 */
		/* 82244330h case    0:*/		regs.R11 = regs.R26;
		/* 82244330h case    0:*/		return 0x82244334;
	}
	return 0x82244334;
} // Block from 82244330h-82244334h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82244334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244334);
		  /* 82244334h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82244334h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82244334h case    0:*/		return 0x82244338;
		  /* 82244338h */ case    1:  		/* cmpwi CR6, R11, 3 */
		/* 82244338h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 82244338h case    1:*/		return 0x8224433C;
		  /* 8224433Ch */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 8224433Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8224435C;  }
		/* 8224433Ch case    2:*/		return 0x82244340;
		  /* 82244340h */ case    3:  		/* lis R11, -32252 */
		/* 82244340h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82244340h case    3:*/		return 0x82244344;
		  /* 82244344h */ case    4:  		/* mr R6, R27 */
		/* 82244344h case    4:*/		regs.R6 = regs.R27;
		/* 82244344h case    4:*/		return 0x82244348;
		  /* 82244348h */ case    5:  		/* addi R5, R11, 12304 */
		/* 82244348h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3010);
		/* 82244348h case    5:*/		return 0x8224434C;
		  /* 8224434Ch */ case    6:  		/* mr R4, R28 */
		/* 8224434Ch case    6:*/		regs.R4 = regs.R28;
		/* 8224434Ch case    6:*/		return 0x82244350;
		  /* 82244350h */ case    7:  		/* li R7, 1653 */
		/* 82244350h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x675);
		/* 82244350h case    7:*/		return 0x82244354;
		  /* 82244354h */ case    8:  		/* li R3, 0 */
		/* 82244354h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82244354h case    8:*/		return 0x82244358;
		  /* 82244358h */ case    9:  		/* bl -968528 */
		/* 82244358h case    9:*/		regs.LR = 0x8224435C; return 0x82157C08;
		/* 82244358h case    9:*/		return 0x8224435C;
	}
	return 0x8224435C;
} // Block from 82244334h-8224435Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224435Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224435C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224435C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224435C);
		  /* 8224435Ch */ case    0:  		/* lwz R11, <#[R30 + 140]> */
		/* 8224435Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000008C) );
		/* 8224435Ch case    0:*/		return 0x82244360;
		  /* 82244360h */ case    1:  		/* lbz R11, <#[R11]> */
		/* 82244360h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82244360h case    1:*/		return 0x82244364;
		  /* 82244364h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82244364h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82244364h case    2:*/		return 0x82244368;
		  /* 82244368h */ case    3:  		/* bc 4, CR0_EQ, 132 */
		/* 82244368h case    3:*/		if ( !regs.CR[0].eq ) { return 0x822443EC;  }
		/* 82244368h case    3:*/		return 0x8224436C;
		  /* 8224436Ch */ case    4:  		/* li R3, 87 */
		/* 8224436Ch case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x57);
		/* 8224436Ch case    4:*/		return 0x82244370;
		  /* 82244370h */ case    5:  		/* lwz R4, <#[R30]> */
		/* 82244370h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 82244370h case    5:*/		return 0x82244374;
		  /* 82244374h */ case    6:  		/* bl 72636 */
		/* 82244374h case    6:*/		regs.LR = 0x82244378; return 0x82255F30;
		/* 82244374h case    6:*/		return 0x82244378;
		  /* 82244378h */ case    7:  		/* mr R31, R3 */
		/* 82244378h case    7:*/		regs.R31 = regs.R3;
		/* 82244378h case    7:*/		return 0x8224437C;
		  /* 8224437Ch */ case    8:  		/* mr R3, R30 */
		/* 8224437Ch case    8:*/		regs.R3 = regs.R30;
		/* 8224437Ch case    8:*/		return 0x82244380;
		  /* 82244380h */ case    9:  		/* bl -22376 */
		/* 82244380h case    9:*/		regs.LR = 0x82244384; return 0x8223EC18;
		/* 82244380h case    9:*/		return 0x82244384;
		  /* 82244384h */ case   10:  		/* or. R30, R3, R3 */
		/* 82244384h case   10:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82244384h case   10:*/		return 0x82244388;
		  /* 82244388h */ case   11:  		/* bc 4, CR0_EQ, 32 */
		/* 82244388h case   11:*/		if ( !regs.CR[0].eq ) { return 0x822443A8;  }
		/* 82244388h case   11:*/		return 0x8224438C;
		  /* 8224438Ch */ case   12:  		/* lis R11, -32252 */
		/* 8224438Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224438Ch case   12:*/		return 0x82244390;
		  /* 82244390h */ case   13:  		/* mr R6, R27 */
		/* 82244390h case   13:*/		regs.R6 = regs.R27;
		/* 82244390h case   13:*/		return 0x82244394;
		  /* 82244394h */ case   14:  		/* addi R5, R11, 12152 */
		/* 82244394h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2F78);
		/* 82244394h case   14:*/		return 0x82244398;
		  /* 82244398h */ case   15:  		/* mr R4, R28 */
		/* 82244398h case   15:*/		regs.R4 = regs.R28;
		/* 82244398h case   15:*/		return 0x8224439C;
		  /* 8224439Ch */ case   16:  		/* li R7, 1658 */
		/* 8224439Ch case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x67A);
		/* 8224439Ch case   16:*/		return 0x822443A0;
		  /* 822443A0h */ case   17:  		/* li R3, 0 */
		/* 822443A0h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822443A0h case   17:*/		return 0x822443A4;
		  /* 822443A4h */ case   18:  		/* bl -968604 */
		/* 822443A4h case   18:*/		regs.LR = 0x822443A8; return 0x82157C08;
		/* 822443A4h case   18:*/		return 0x822443A8;
	}
	return 0x822443A8;
} // Block from 8224435Ch-822443A8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 822443A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822443A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822443A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822443A8);
		  /* 822443A8h */ case    0:  		/* lis R28, -32252 */
		/* 822443A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8204);
		/* 822443A8h case    0:*/		return 0x822443AC;
		  /* 822443ACh */ case    1:  		/* lwz R11, <#[R30 + 56]> */
		/* 822443ACh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 822443ACh case    1:*/		return 0x822443B0;
		  /* 822443B0h */ case    2:  		/* stw R26, <#[R31 + 80]> */
		/* 822443B0h case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000050) );
		/* 822443B0h case    2:*/		return 0x822443B4;
		  /* 822443B4h */ case    3:  		/* mr R5, R30 */
		/* 822443B4h case    3:*/		regs.R5 = regs.R30;
		/* 822443B4h case    3:*/		return 0x822443B8;
		  /* 822443B8h */ case    4:  		/* addi R10, R28, 9936 */
		/* 822443B8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x26D0);
		/* 822443B8h case    4:*/		return 0x822443BC;
		  /* 822443BCh */ case    5:  		/* li R4, 1 */
		/* 822443BCh case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822443BCh case    5:*/		return 0x822443C0;
		  /* 822443C0h */ case    6:  		/* mr R3, R31 */
		/* 822443C0h case    6:*/		regs.R3 = regs.R31;
		/* 822443C0h case    6:*/		return 0x822443C4;
		  /* 822443C4h */ case    7:  		/* stw R11, <#[R31 + 56]> */
		/* 822443C4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 822443C4h case    7:*/		return 0x822443C8;
		  /* 822443C8h */ case    8:  		/* lwz R11, <#[R10 - 12]> */
		/* 822443C8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFFFF4) );
		/* 822443C8h case    8:*/		return 0x822443CC;
		  /* 822443CCh */ case    9:  		/* stw R11, <#[R31 + 128]> */
		/* 822443CCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 822443CCh case    9:*/		return 0x822443D0;
		  /* 822443D0h */ case   10:  		/* bl -58496 */
		/* 822443D0h case   10:*/		regs.LR = 0x822443D4; return 0x82235F50;
		/* 822443D0h case   10:*/		return 0x822443D4;
		  /* 822443D4h */ case   11:  		/* lwz R11, <#[R28 + 9936]> */
		/* 822443D4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000026D0) );
		/* 822443D4h case   11:*/		return 0x822443D8;
		  /* 822443D8h */ case   12:  		/* mr R4, R31 */
		/* 822443D8h case   12:*/		regs.R4 = regs.R31;
		/* 822443D8h case   12:*/		return 0x822443DC;
		  /* 822443DCh */ case   13:  		/* mr R3, R29 */
		/* 822443DCh case   13:*/		regs.R3 = regs.R29;
		/* 822443DCh case   13:*/		return 0x822443E0;
		  /* 822443E0h */ case   14:  		/* stw R11, <#[R31 + 132]> */
		/* 822443E0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 822443E0h case   14:*/		return 0x822443E4;
		  /* 822443E4h */ case   15:  		/* stw R26, <#[R31 + 52]> */
		/* 822443E4h case   15:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000034) );
		/* 822443E4h case   15:*/		return 0x822443E8;
		  /* 822443E8h */ case   16:  		/* bl 84880 */
		/* 822443E8h case   16:*/		regs.LR = 0x822443EC; return 0x82258F78;
		/* 822443E8h case   16:*/		return 0x822443EC;
	}
	return 0x822443EC;
} // Block from 822443A8h-822443ECh (17 instructions)

//////////////////////////////////////////////////////
// Block at 822443ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822443EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822443EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822443EC);
		  /* 822443ECh */ case    0:  		/* addi R1, R1, 144 */
		/* 822443ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 822443ECh case    0:*/		return 0x822443F0;
		  /* 822443F0h */ case    1:  		/* b -1782096 */
		/* 822443F0h case    1:*/		return 0x820912A0;
		/* 822443F0h case    1:*/		return 0x822443F4;
		  /* 822443F4h */ case    2:  		/* nop */
		/* 822443F4h case    2:*/		cpu::op::nop();
		/* 822443F4h case    2:*/		return 0x822443F8;
	}
	return 0x822443F8;
} // Block from 822443ECh-822443F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822443F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822443F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822443F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822443F8);
		  /* 822443F8h */ case    0:  		/* mfspr R12, LR */
		/* 822443F8h case    0:*/		regs.R12 = regs.LR;
		/* 822443F8h case    0:*/		return 0x822443FC;
		  /* 822443FCh */ case    1:  		/* bl -1782188 */
		/* 822443FCh case    1:*/		regs.LR = 0x82244400; return 0x82091250;
		/* 822443FCh case    1:*/		return 0x82244400;
		  /* 82244400h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82244400h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82244400h case    2:*/		return 0x82244404;
		  /* 82244404h */ case    3:  		/* lwz R10, <#[R4 + 4]> */
		/* 82244404h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 82244404h case    3:*/		return 0x82244408;
		  /* 82244408h */ case    4:  		/* li R9, 12 */
		/* 82244408h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 82244408h case    4:*/		return 0x8224440C;
		  /* 8224440Ch */ case    5:  		/* lwz R11, <#[R4 + 52]> */
		/* 8224440Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000034) );
		/* 8224440Ch case    5:*/		return 0x82244410;
		  /* 82244410h */ case    6:  		/* mr R30, R3 */
		/* 82244410h case    6:*/		regs.R30 = regs.R3;
		/* 82244410h case    6:*/		return 0x82244414;
		  /* 82244414h */ case    7:  		/* subf R10, R10, R5 */
		/* 82244414h case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 82244414h case    7:*/		return 0x82244418;
	}
	return 0x82244418;
} // Block from 822443F8h-82244418h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82244418h
// Function '?Assemble@IfFooter@XGRAPHICS@@UAAXAAVAssembler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244418);
		  /* 82244418h */ case    0:  		/* mr R28, R4 */
		/* 82244418h case    0:*/		regs.R28 = regs.R4;
		/* 82244418h case    0:*/		return 0x8224441C;
		  /* 8224441Ch */ case    1:  		/* divw R10, R10, R9 */
		/* 8224441Ch case    1:*/		cpu::op::divw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8224441Ch case    1:*/		return 0x82244420;
		  /* 82244420h */ case    2:  		/* mr R31, R5 */
		/* 82244420h case    2:*/		regs.R31 = regs.R5;
		/* 82244420h case    2:*/		return 0x82244424;
		  /* 82244424h */ case    3:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82244424h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82244424h case    3:*/		return 0x82244428;
		  /* 82244428h */ case    4:  		/* mr R29, R6 */
		/* 82244428h case    4:*/		regs.R29 = regs.R6;
		/* 82244428h case    4:*/		return 0x8224442C;
		  /* 8224442Ch */ case    5:  		/* add R11, R10, R11 */
		/* 8224442Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8224442Ch case    5:*/		return 0x82244430;
		  /* 82244430h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 82244430h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82244430h case    6:*/		return 0x82244434;
		  /* 82244434h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 82244434h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82244434h case    7:*/		return 0x82244438;
		  /* 82244438h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 82244438h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82244444;  }
		/* 82244438h case    8:*/		return 0x8224443C;
		  /* 8224443Ch */ case    9:  		/* stw R3, <#[R11]> */
		/* 8224443Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 8224443Ch case    9:*/		return 0x82244440;
		  /* 82244440h */ case   10:  		/* b 8 */
		/* 82244440h case   10:*/		return 0x82244448;
		/* 82244440h case   10:*/		return 0x82244444;
	}
	return 0x82244444;
} // Block from 82244418h-82244444h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82244444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244444);
		  /* 82244444h */ case    0:  		/* stw R30, <#[R11 + 4]> */
		/* 82244444h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 82244444h case    0:*/		return 0x82244448;
	}
	return 0x82244448;
} // Block from 82244444h-82244448h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82244448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244448);
		  /* 82244448h */ case    0:  		/* lis R11, -32222 */
		/* 82244448h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 82244448h case    0:*/		return 0x8224444C;
		  /* 8224444Ch */ case    1:  		/* lwz R6, <#[R29 + 1384]> */
		/* 8224444Ch case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000568) );
		/* 8224444Ch case    1:*/		return 0x82244450;
		  /* 82244450h */ case    2:  		/* mr R8, R29 */
		/* 82244450h case    2:*/		regs.R8 = regs.R29;
		/* 82244450h case    2:*/		return 0x82244454;
		  /* 82244454h */ case    3:  		/* lwz R4, <#[R30 + 172]> */
		/* 82244454h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000000AC) );
		/* 82244454h case    3:*/		return 0x82244458;
		  /* 82244458h */ case    4:  		/* addi R7, R11, -12392 */
		/* 82244458h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFCF98);
		/* 82244458h case    4:*/		return 0x8224445C;
		  /* 8224445Ch */ case    5:  		/* lwz R3, <#[R29 + 1536]> */
		/* 8224445Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000600) );
		/* 8224445Ch case    5:*/		return 0x82244460;
		  /* 82244460h */ case    6:  		/* addi R5, R1, 96 */
		/* 82244460h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82244460h case    6:*/		return 0x82244464;
		  /* 82244464h */ case    7:  		/* bl -72572 */
		/* 82244464h case    7:*/		regs.LR = 0x82244468; return 0x822328E8;
		/* 82244464h case    7:*/		return 0x82244468;
		  /* 82244468h */ case    8:  		/* mr R5, R31 */
		/* 82244468h case    8:*/		regs.R5 = regs.R31;
		/* 82244468h case    8:*/		return 0x8224446C;
		  /* 8224446Ch */ case    9:  		/* mr R3, R28 */
		/* 8224446Ch case    9:*/		regs.R3 = regs.R28;
		/* 8224446Ch case    9:*/		return 0x82244470;
		  /* 82244470h */ case   10:  		/* lwz R6, <#[R30 + 168]> */
		/* 82244470h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x000000A8) );
		/* 82244470h case   10:*/		return 0x82244474;
		  /* 82244474h */ case   11:  		/* lwz R4, <#[R30 + 172]> */
		/* 82244474h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000000AC) );
		/* 82244474h case   11:*/		return 0x82244478;
		  /* 82244478h */ case   12:  		/* bl -4944 */
		/* 82244478h case   12:*/		regs.LR = 0x8224447C; return 0x82243128;
		/* 82244478h case   12:*/		return 0x8224447C;
		  /* 8224447Ch */ case   13:  		/* addi R6, R1, 84 */
		/* 8224447Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 8224447Ch case   13:*/		return 0x82244480;
		  /* 82244480h */ case   14:  		/* addi R5, R1, 80 */
		/* 82244480h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82244480h case   14:*/		return 0x82244484;
		  /* 82244484h */ case   15:  		/* lwz R4, <#[R30 + 172]> */
		/* 82244484h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000000AC) );
		/* 82244484h case   15:*/		return 0x82244488;
		  /* 82244488h */ case   16:  		/* mr R3, R29 */
		/* 82244488h case   16:*/		regs.R3 = regs.R29;
		/* 82244488h case   16:*/		return 0x8224448C;
		  /* 8224448Ch */ case   17:  		/* bl -163492 */
		/* 8224448Ch case   17:*/		regs.LR = 0x82244490; return 0x8221C5E8;
		/* 8224448Ch case   17:*/		return 0x82244490;
		  /* 82244490h */ case   18:  		/* lis R11, -32252 */
		/* 82244490h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82244490h case   18:*/		return 0x82244494;
		  /* 82244494h */ case   19:  		/* lwz R10, <#[R1 + 84]> */
		/* 82244494h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82244494h case   19:*/		return 0x82244498;
		  /* 82244498h */ case   20:  		/* addi R9, R11, 25976 */
		/* 82244498h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x6578);
		/* 82244498h case   20:*/		return 0x8224449C;
		  /* 8224449Ch */ case   21:  		/* lwz R8, <#[R1 + 96]> */
		/* 8224449Ch case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 8224449Ch case   21:*/		return 0x822444A0;
		  /* 822444A0h */ case   22:  		/* lwz R7, <#[R31]> */
		/* 822444A0h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 822444A0h case   22:*/		return 0x822444A4;
		  /* 822444A4h */ case   23:  		/* lwz R5, <#[R1 + 120]> */
		/* 822444A4h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000078) );
		/* 822444A4h case   23:*/		return 0x822444A8;
		  /* 822444A8h */ case   24:  		/* rlwinm R7, R7, 0, 13, 4 */
		/* 822444A8h case   24:*/		cpu::op::rlwinm<0,0,13,4>(regs,&regs.R7,regs.R7);
		/* 822444A8h case   24:*/		return 0x822444AC;
		  /* 822444ACh */ case   25:  		/* lwz R6, <#[R1 + 116]> */
		/* 822444ACh case   25:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000074) );
		/* 822444ACh case   25:*/		return 0x822444B0;
		  /* 822444B0h */ case   26:  		/* lwz R4, <#[R1 + 108]> */
		/* 822444B0h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000006C) );
		/* 822444B0h case   26:*/		return 0x822444B4;
		  /* 822444B4h */ case   27:  		/* rlwimi R6, R5, 8, 18, 23 */
		/* 822444B4h case   27:*/		cpu::op::rlwimi<0,8,18,23>(regs,&regs.R6,regs.R5);
		/* 822444B4h case   27:*/		return 0x822444B8;
		  /* 822444B8h */ case   28:  		/* lwz R3, <#[R1 + 104]> */
		/* 822444B8h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000068) );
		/* 822444B8h case   28:*/		return 0x822444BC;
		  /* 822444BCh */ case   29:  		/* lwz R11, <#[R1 + 80]> */
		/* 822444BCh case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822444BCh case   29:*/		return 0x822444C0;
		  /* 822444C0h */ case   30:  		/* lwz R28, <#[R1 + 100]> */
		/* 822444C0h case   30:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000064) );
		/* 822444C0h case   30:*/		return 0x822444C4;
		  /* 822444C4h */ case   31:  		/* rlwimi R11, R10, 5, 25, 26 */
		/* 822444C4h case   31:*/		cpu::op::rlwimi<0,5,25,26>(regs,&regs.R11,regs.R10);
		/* 822444C4h case   31:*/		return 0x822444C8;
		  /* 822444C8h */ case   32:  		/* lwz R10, <#[R1 + 124]> */
		/* 822444C8h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000007C) );
		/* 822444C8h case   32:*/		return 0x822444CC;
		  /* 822444CCh */ case   33:  		/* lwz R27, <#[R1 + 128]> */
		/* 822444CCh case   33:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000080) );
		/* 822444CCh case   33:*/		return 0x822444D0;
		  /* 822444D0h */ case   34:  		/* rlwinm R11, R11, 0, 25, 31 */
		/* 822444D0h case   34:*/		cpu::op::rlwinm<0,0,25,31>(regs,&regs.R11,regs.R11);
		/* 822444D0h case   34:*/		return 0x822444D4;
		  /* 822444D4h */ case   35:  		/* srawi R10, R10, 2 */
		/* 822444D4h case   35:*/		cpu::op::srawi<0,2>(regs,&regs.R10,regs.R10);
		/* 822444D4h case   35:*/		return 0x822444D8;
		  /* 822444D8h */ case   36:  		/* rlwimi R8, R11, 1, 0, 30 */
		/* 822444D8h case   36:*/		cpu::op::rlwimi<0,1,0,30>(regs,&regs.R8,regs.R11);
		/* 822444D8h case   36:*/		return 0x822444DC;
		  /* 822444DCh */ case   37:  		/* lwz R11, <#[R1 + 112]> */
		/* 822444DCh case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 822444DCh case   37:*/		return 0x822444E0;
		  /* 822444E0h */ case   38:  		/* addze R10, R10 */
		/* 822444E0h case   38:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R10);
		/* 822444E0h case   38:*/		return 0x822444E4;
		  /* 822444E4h */ case   39:  		/* rlwinm R8, R8, 19, 0, 12 */
		/* 822444E4h case   39:*/		cpu::op::rlwinm<0,19,0,12>(regs,&regs.R8,regs.R8);
		/* 822444E4h case   39:*/		return 0x822444E8;
		  /* 822444E8h */ case   40:  		/* or R8, R8, R7 */
		/* 822444E8h case   40:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 822444E8h case   40:*/		return 0x822444EC;
		  /* 822444ECh */ case   41:  		/* lwz R7, <#[R31 + 4]> */
		/* 822444ECh case   41:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000004) );
		/* 822444ECh case   41:*/		return 0x822444F0;
		  /* 822444F0h */ case   42:  		/* stw R8, <#[R31]> */
		/* 822444F0h case   42:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 822444F0h case   42:*/		return 0x822444F4;
		  /* 822444F4h */ case   43:  		/* lwz R5, <#[R30 + 132]> */
		/* 822444F4h case   43:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000084) );
		/* 822444F4h case   43:*/		return 0x822444F8;
		  /* 822444F8h */ case   44:  		/* stb R10, <#[R31 + 11]> */
		/* 822444F8h case   44:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x0000000B) );
		/* 822444F8h case   44:*/		return 0x822444FC;
		  /* 822444FCh */ case   45:  		/* andi. R10, R6, 16191 */
		/* 822444FCh case   45:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R6,0x3F3F);
		/* 822444FCh case   45:*/		return 0x82244500;
		  /* 82244500h */ case   46:  		/* rlwimi R11, R10, 1, 0, 30 */
		/* 82244500h case   46:*/		cpu::op::rlwimi<0,1,0,30>(regs,&regs.R11,regs.R10);
		/* 82244500h case   46:*/		return 0x82244504;
		  /* 82244504h */ case   47:  		/* rlwinm R10, R7, 0, 20, 9 */
		/* 82244504h case   47:*/		cpu::op::rlwinm<0,0,20,9>(regs,&regs.R10,regs.R7);
		/* 82244504h case   47:*/		return 0x82244508;
		  /* 82244508h */ case   48:  		/* rlwimi R4, R11, 1, 0, 30 */
		/* 82244508h case   48:*/		cpu::op::rlwimi<0,1,0,30>(regs,&regs.R4,regs.R11);
		/* 82244508h case   48:*/		return 0x8224450C;
		  /* 8224450Ch */ case   49:  		/* rlwinm R10, R10, 0, 8, 1 */
		/* 8224450Ch case   49:*/		cpu::op::rlwinm<0,0,8,1>(regs,&regs.R10,regs.R10);
		/* 8224450Ch case   49:*/		return 0x82244510;
		  /* 82244510h */ case   50:  		/* rlwimi R3, R4, 1, 0, 30 */
		/* 82244510h case   50:*/		cpu::op::rlwimi<0,1,0,30>(regs,&regs.R3,regs.R4);
		/* 82244510h case   50:*/		return 0x82244514;
		  /* 82244514h */ case   51:  		/* lwz R6, <#[R31 + 8]> */
		/* 82244514h case   51:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 82244514h case   51:*/		return 0x82244518;
		  /* 82244518h */ case   52:  		/* srawi R7, R27, 2 */
		/* 82244518h case   52:*/		cpu::op::srawi<0,2>(regs,&regs.R7,regs.R27);
		/* 82244518h case   52:*/		return 0x8224451C;
		  /* 8224451Ch */ case   53:  		/* rlwimi R28, R3, 1, 0, 30 */
		/* 8224451Ch case   53:*/		cpu::op::rlwimi<0,1,0,30>(regs,&regs.R28,regs.R3);
		/* 8224451Ch case   53:*/		return 0x82244520;
		  /* 82244520h */ case   54:  		/* rlwinm R11, R28, 12, 0, 19 */
		/* 82244520h case   54:*/		cpu::op::rlwinm<0,12,0,19>(regs,&regs.R11,regs.R28);
		/* 82244520h case   54:*/		return 0x82244524;
		  /* 82244524h */ case   55:  		/* or R11, R11, R10 */
		/* 82244524h case   55:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82244524h case   55:*/		return 0x82244528;
		  /* 82244528h */ case   56:  		/* addze R10, R7 */
		/* 82244528h case   56:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R7);
		/* 82244528h case   56:*/		return 0x8224452C;
		  /* 8224452Ch */ case   57:  		/* stw R11, <#[R31 + 4]> */
		/* 8224452Ch case   57:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224452Ch case   57:*/		return 0x82244530;
		  /* 82244530h */ case   58:  		/* rlwinm R26, R5, 8, 24, 31 */
		/* 82244530h case   58:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R26,regs.R5);
		/* 82244530h case   58:*/		return 0x82244534;
		  /* 82244534h */ case   59:  		/* rlwimi R26, R5, 24, 16, 23 */
		/* 82244534h case   59:*/		cpu::op::rlwimi<0,24,16,23>(regs,&regs.R26,regs.R5);
		/* 82244534h case   59:*/		return 0x82244538;
		  /* 82244538h */ case   60:  		/* rlwimi R26, R5, 8, 8, 15 */
		/* 82244538h case   60:*/		cpu::op::rlwimi<0,8,8,15>(regs,&regs.R26,regs.R5);
		/* 82244538h case   60:*/		return 0x8224453C;
		  /* 8224453Ch */ case   61:  		/* rlwimi R26, R5, 24, 0, 7 */
		/* 8224453Ch case   61:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R26,regs.R5);
		/* 8224453Ch case   61:*/		return 0x82244540;
		  /* 82244540h */ case   62:  		/* rlwimi R8, R26, 30, 0, 1 */
		/* 82244540h case   62:*/		cpu::op::rlwimi<0,30,0,1>(regs,&regs.R8,regs.R26);
		/* 82244540h case   62:*/		return 0x82244544;
		  /* 82244544h */ case   63:  		/* stw R8, <#[R31]> */
		/* 82244544h case   63:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 82244544h case   63:*/		return 0x82244548;
		  /* 82244548h */ case   64:  		/* lwz R11, <#[R30 + 168]> */
		/* 82244548h case   64:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000A8) );
		/* 82244548h case   64:*/		return 0x8224454C;
		  /* 8224454Ch */ case   65:  		/* add R11, R10, R11 */
		/* 8224454Ch case   65:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8224454Ch case   65:*/		return 0x82244550;
		  /* 82244550h */ case   66:  		/* rlwimi R6, R11, 8, 1, 23 */
		/* 82244550h case   66:*/		cpu::op::rlwimi<0,8,1,23>(regs,&regs.R6,regs.R11);
		/* 82244550h case   66:*/		return 0x82244554;
		  /* 82244554h */ case   67:  		/* stw R6, <#[R31 + 8]> */
		/* 82244554h case   67:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 82244554h case   67:*/		return 0x82244558;
	}
	return 0x82244558;
} // Block from 82244448h-82244558h (68 instructions)

//////////////////////////////////////////////////////
// Block at 82244558h
// Function '?Assemble@IfHeaderStatic@XGRAPHICS@@UAAXAAVAssembler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244558);
		  /* 82244558h */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 82244558h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82244558h case    0:*/		return 0x8224455C;
		  /* 8224455Ch */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224455Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224455Ch case    1:*/		return 0x82244560;
		  /* 82244560h */ case    2:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82244560h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82244560h case    2:*/		return 0x82244564;
		  /* 82244564h */ case    3:  		/* rlwimi R11, R8, 0, 0, 26 */
		/* 82244564h case    3:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R11,regs.R8);
		/* 82244564h case    3:*/		return 0x82244568;
		  /* 82244568h */ case    4:  		/* stw R11, <#[R31]> */
		/* 82244568h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82244568h case    4:*/		return 0x8224456C;
		  /* 8224456Ch */ case    5:  		/* lwz R3, <#[R29 + 2736]> */
		/* 8224456Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000AB0) );
		/* 8224456Ch case    5:*/		return 0x82244570;
		  /* 82244570h */ case    6:  		/* lwz R4, <#[R30 + 236]> */
		/* 82244570h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000000EC) );
		/* 82244570h case    6:*/		return 0x82244574;
		  /* 82244574h */ case    7:  		/* bl 130676 */
		/* 82244574h case    7:*/		regs.LR = 0x82244578; return 0x822643E8;
		/* 82244574h case    7:*/		return 0x82244578;
		  /* 82244578h */ case    8:  		/* lwz R9, <#[R31]> */
		/* 82244578h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82244578h case    8:*/		return 0x8224457C;
		  /* 8224457Ch */ case    9:  		/* rlwimi R9, R3, 5, 21, 26 */
		/* 8224457Ch case    9:*/		cpu::op::rlwimi<0,5,21,26>(regs,&regs.R9,regs.R3);
		/* 8224457Ch case    9:*/		return 0x82244580;
		  /* 82244580h */ case   10:  		/* lis R11, -32253 */
		/* 82244580h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82244580h case   10:*/		return 0x82244584;
		  /* 82244584h */ case   11:  		/* lis R10, -32252 */
		/* 82244584h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82244584h case   11:*/		return 0x82244588;
		  /* 82244588h */ case   12:  		/* rlwinm R9, R9, 0, 21, 19 */
		/* 82244588h case   12:*/		cpu::op::rlwinm<0,0,21,19>(regs,&regs.R9,regs.R9);
		/* 82244588h case   12:*/		return 0x8224458C;
		  /* 8224458Ch */ case   13:  		/* stw R9, <#[R31]> */
		/* 8224458Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8224458Ch case   13:*/		return 0x82244590;
		  /* 82244590h */ case   14:  		/* addi R27, R11, 27460 */
		/* 82244590h case   14:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x6B44);
		/* 82244590h case   14:*/		return 0x82244594;
		  /* 82244594h */ case   15:  		/* lwz R28, <#[R30 + 180]> */
		/* 82244594h case   15:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x000000B4) );
		/* 82244594h case   15:*/		return 0x82244598;
		  /* 82244598h */ case   16:  		/* addi R26, R10, 10344 */
		/* 82244598h case   16:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R10,0x2868);
		/* 82244598h case   16:*/		return 0x8224459C;
		  /* 8224459Ch */ case   17:  		/* cmplwi CR6, R28, 0 */
		/* 8224459Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8224459Ch case   17:*/		return 0x822445A0;
		  /* 822445A0h */ case   18:  		/* bc 12, CR6_EQ, 136 */
		/* 822445A0h case   18:*/		if ( regs.CR[6].eq ) { return 0x82244628;  }
		/* 822445A0h case   18:*/		return 0x822445A4;
		  /* 822445A4h */ case   19:  		/* lwz R11, <#[R28 + 228]> */
		/* 822445A4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 822445A4h case   19:*/		return 0x822445A8;
		  /* 822445A8h */ case   20:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 822445A8h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 822445A8h case   20:*/		return 0x822445AC;
		  /* 822445ACh */ case   21:  		/* bc 12, CR0_EQ, 76 */
		/* 822445ACh case   21:*/		if ( regs.CR[0].eq ) { return 0x822445F8;  }
		/* 822445ACh case   21:*/		return 0x822445B0;
	}
	return 0x822445B0;
} // Block from 82244558h-822445B0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 822445B0h
// Function '?Assemble@IfFooterStatic@XGRAPHICS@@UAAXAAVAssembler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822445B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822445B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822445B0);
		  /* 822445B0h */ case    0:  		/* lwz R11, <#[R28 + 80]> */
		/* 822445B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000050) );
		/* 822445B0h case    0:*/		return 0x822445B4;
		  /* 822445B4h */ case    1:  		/* lwz R10, <#[R30 + 228]> */
		/* 822445B4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x000000E4) );
		/* 822445B4h case    1:*/		return 0x822445B8;
		  /* 822445B8h */ case    2:  		/* rlwinm. R10, R10, 25, 31, 31 */
		/* 822445B8h case    2:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R10,regs.R10);
		/* 822445B8h case    2:*/		return 0x822445BC;
		  /* 822445BCh */ case    3:  		/* stw R11, <#[R30 + 80]> */
		/* 822445BCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000050) );
		/* 822445BCh case    3:*/		return 0x822445C0;
		  /* 822445C0h */ case    4:  		/* bc 12, CR0_EQ, 32 */
		/* 822445C0h case    4:*/		if ( regs.CR[0].eq ) { return 0x822445E0;  }
		/* 822445C0h case    4:*/		return 0x822445C4;
		  /* 822445C4h */ case    5:  		/* lis R11, -32252 */
		/* 822445C4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822445C4h case    5:*/		return 0x822445C8;
		  /* 822445C8h */ case    6:  		/* mr R6, R26 */
		/* 822445C8h case    6:*/		regs.R6 = regs.R26;
		/* 822445C8h case    6:*/		return 0x822445CC;
		  /* 822445CCh */ case    7:  		/* addi R5, R11, 12128 */
		/* 822445CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x2F60);
		/* 822445CCh case    7:*/		return 0x822445D0;
		  /* 822445D0h */ case    8:  		/* mr R4, R27 */
		/* 822445D0h case    8:*/		regs.R4 = regs.R27;
		/* 822445D0h case    8:*/		return 0x822445D4;
		  /* 822445D4h */ case    9:  		/* li R7, 2944 */
		/* 822445D4h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0xB80);
		/* 822445D4h case    9:*/		return 0x822445D8;
		  /* 822445D8h */ case   10:  		/* li R3, 0 */
		/* 822445D8h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822445D8h case   10:*/		return 0x822445DC;
		  /* 822445DCh */ case   11:  		/* bl -969172 */
		/* 822445DCh case   11:*/		regs.LR = 0x822445E0; return 0x82157C08;
		/* 822445DCh case   11:*/		return 0x822445E0;
	}
	return 0x822445E0;
} // Block from 822445B0h-822445E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822445E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822445E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822445E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822445E0);
		  /* 822445E0h */ case    0:  		/* mr R4, R28 */
		/* 822445E0h case    0:*/		regs.R4 = regs.R28;
		/* 822445E0h case    0:*/		return 0x822445E4;
		  /* 822445E4h */ case    1:  		/* lwz R3, <#[R29 + 2736]> */
		/* 822445E4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000AB0) );
		/* 822445E4h case    1:*/		return 0x822445E8;
		  /* 822445E8h */ case    2:  		/* bl 130560 */
		/* 822445E8h case    2:*/		regs.LR = 0x822445EC; return 0x822643E8;
		/* 822445E8h case    2:*/		return 0x822445EC;
		  /* 822445ECh */ case    3:  		/* stw R3, <#[R30 + 56]> */
		/* 822445ECh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000038) );
		/* 822445ECh case    3:*/		return 0x822445F0;
		  /* 822445F0h */ case    4:  		/* lwz R11, <#[R28 + 128]> */
		/* 822445F0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000080) );
		/* 822445F0h case    4:*/		return 0x822445F4;
		  /* 822445F4h */ case    5:  		/* b 12 */
		/* 822445F4h case    5:*/		return 0x82244600;
		/* 822445F4h case    5:*/		return 0x822445F8;
	}
	return 0x822445F8;
} // Block from 822445E0h-822445F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822445F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822445F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822445F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822445F8);
		  /* 822445F8h */ case    0:  		/* lis R11, -32252 */
		/* 822445F8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822445F8h case    0:*/		return 0x822445FC;
		  /* 822445FCh */ case    1:  		/* lwz R11, <#[R11 + 9920]> */
		/* 822445FCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000026C0) );
		/* 822445FCh case    1:*/		return 0x82244600;
	}
	return 0x82244600;
} // Block from 822445F8h-82244600h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244600h
// Function '?Assemble@LoopHeader@XGRAPHICS@@UAAXAAVAssembler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244600);
		  /* 82244600h */ case    0:  		/* stw R11, <#[R30 + 128]> */
		/* 82244600h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 82244600h case    0:*/		return 0x82244604;
		  /* 82244604h */ case    1:  		/* lwz R11, <#[R31 + 4]> */
		/* 82244604h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82244604h case    1:*/		return 0x82244608;
		  /* 82244608h */ case    2:  		/* rlwinm R11, R11, 0, 2, 0 */
		/* 82244608h case    2:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R11,regs.R11);
		/* 82244608h case    2:*/		return 0x8224460C;
		  /* 8224460Ch */ case    3:  		/* stw R11, <#[R31 + 4]> */
		/* 8224460Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224460Ch case    3:*/		return 0x82244610;
		  /* 82244610h */ case    4:  		/* lwz R11, <#[R30 + 184]> */
		/* 82244610h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000B8) );
		/* 82244610h case    4:*/		return 0x82244614;
		  /* 82244614h */ case    5:  		/* addi R11, R11, -1 */
		/* 82244614h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82244614h case    5:*/		return 0x82244618;
		  /* 82244618h */ case    6:  		/* lwz R10, <#[R31]> */
		/* 82244618h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82244618h case    6:*/		return 0x8224461C;
		  /* 8224461Ch */ case    7:  		/* rlwimi R10, R11, 27, 2, 4 */
		/* 8224461Ch case    7:*/		cpu::op::rlwimi<0,27,2,4>(regs,&regs.R10,regs.R11);
		/* 8224461Ch case    7:*/		return 0x82244620;
		  /* 82244620h */ case    8:  		/* stw R10, <#[R31]> */
		/* 82244620h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82244620h case    8:*/		return 0x82244624;
		  /* 82244624h */ case    9:  		/* b 28 */
		/* 82244624h case    9:*/		return 0x82244640;
		/* 82244624h case    9:*/		return 0x82244628;
	}
	return 0x82244628;
} // Block from 82244600h-82244628h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82244628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244628);
		  /* 82244628h */ case    0:  		/* lbz R11, <#[R30 + 176]> */
		/* 82244628h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000B0) );
		/* 82244628h case    0:*/		return 0x8224462C;
		  /* 8224462Ch */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8224462Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224462Ch case    1:*/		return 0x82244630;
		  /* 82244630h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82244630h case    2:*/		if ( regs.CR[0].eq ) { return 0x82244640;  }
		/* 82244630h case    2:*/		return 0x82244634;
		  /* 82244634h */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 82244634h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82244634h case    3:*/		return 0x82244638;
		  /* 82244638h */ case    4:  		/* oris R11, R11, 16384 */
		/* 82244638h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 82244638h case    4:*/		return 0x8224463C;
		  /* 8224463Ch */ case    5:  		/* stw R11, <#[R31 + 4]> */
		/* 8224463Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224463Ch case    5:*/		return 0x82244640;
	}
	return 0x82244640;
} // Block from 82244628h-82244640h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82244640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244640);
		  /* 82244640h */ case    0:  		/* mr R4, R30 */
		/* 82244640h case    0:*/		regs.R4 = regs.R30;
		/* 82244640h case    0:*/		return 0x82244644;
		  /* 82244644h */ case    1:  		/* lwz R3, <#[R29 + 2736]> */
		/* 82244644h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000AB0) );
		/* 82244644h case    1:*/		return 0x82244648;
		  /* 82244648h */ case    2:  		/* bl 130464 */
		/* 82244648h case    2:*/		regs.LR = 0x8224464C; return 0x822643E8;
		/* 82244648h case    2:*/		return 0x8224464C;
		  /* 8224464Ch */ case    3:  		/* lwz R11, <#[R31]> */
		/* 8224464Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224464Ch case    3:*/		return 0x82244650;
		  /* 82244650h */ case    4:  		/* rlwimi R11, R3, 12, 14, 19 */
		/* 82244650h case    4:*/		cpu::op::rlwimi<0,12,14,19>(regs,&regs.R11,regs.R3);
		/* 82244650h case    4:*/		return 0x82244654;
		  /* 82244654h */ case    5:  		/* stw R11, <#[R31]> */
		/* 82244654h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82244654h case    5:*/		return 0x82244658;
		  /* 82244658h */ case    6:  		/* lbz R3, <#[R30 + 128]> */
		/* 82244658h case    6:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000080) );
		/* 82244658h case    6:*/		return 0x8224465C;
		  /* 8224465Ch */ case    7:  		/* bl -24172 */
		/* 8224465Ch case    7:*/		regs.LR = 0x82244660; return 0x8223E7F0;
		/* 8224465Ch case    7:*/		return 0x82244660;
		  /* 82244660h */ case    8:  		/* lwz R11, <#[R31 + 4]> */
		/* 82244660h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82244660h case    8:*/		return 0x82244664;
		  /* 82244664h */ case    9:  		/* rlwimi R3, R11, 0, 0, 28 */
		/* 82244664h case    9:*/		cpu::op::rlwimi<0,0,0,28>(regs,&regs.R3,regs.R11);
		/* 82244664h case    9:*/		return 0x82244668;
		  /* 82244668h */ case   10:  		/* stw R3, <#[R31 + 4]> */
		/* 82244668h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 82244668h case   10:*/		return 0x8224466C;
		  /* 8224466Ch */ case   11:  		/* lbz R3, <#[R30 + 129]> */
		/* 8224466Ch case   11:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000081) );
		/* 8224466Ch case   11:*/		return 0x82244670;
		  /* 82244670h */ case   12:  		/* bl -24192 */
		/* 82244670h case   12:*/		regs.LR = 0x82244674; return 0x8223E7F0;
		/* 82244670h case   12:*/		return 0x82244674;
		  /* 82244674h */ case   13:  		/* lwz R11, <#[R31 + 4]> */
		/* 82244674h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82244674h case   13:*/		return 0x82244678;
		  /* 82244678h */ case   14:  		/* rlwimi R11, R3, 3, 26, 28 */
		/* 82244678h case   14:*/		cpu::op::rlwimi<0,3,26,28>(regs,&regs.R11,regs.R3);
		/* 82244678h case   14:*/		return 0x8224467C;
		  /* 8224467Ch */ case   15:  		/* stw R11, <#[R31 + 4]> */
		/* 8224467Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224467Ch case   15:*/		return 0x82244680;
		  /* 82244680h */ case   16:  		/* lbz R3, <#[R30 + 130]> */
		/* 82244680h case   16:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000082) );
		/* 82244680h case   16:*/		return 0x82244684;
		  /* 82244684h */ case   17:  		/* bl -24212 */
		/* 82244684h case   17:*/		regs.LR = 0x82244688; return 0x8223E7F0;
		/* 82244684h case   17:*/		return 0x82244688;
		  /* 82244688h */ case   18:  		/* lwz R11, <#[R31 + 4]> */
		/* 82244688h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82244688h case   18:*/		return 0x8224468C;
		  /* 8224468Ch */ case   19:  		/* rlwimi R11, R3, 6, 23, 25 */
		/* 8224468Ch case   19:*/		cpu::op::rlwimi<0,6,23,25>(regs,&regs.R11,regs.R3);
		/* 8224468Ch case   19:*/		return 0x82244690;
		  /* 82244690h */ case   20:  		/* stw R11, <#[R31 + 4]> */
		/* 82244690h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82244690h case   20:*/		return 0x82244694;
		  /* 82244694h */ case   21:  		/* lbz R3, <#[R30 + 131]> */
		/* 82244694h case   21:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000083) );
		/* 82244694h case   21:*/		return 0x82244698;
		  /* 82244698h */ case   22:  		/* bl -24232 */
		/* 82244698h case   22:*/		regs.LR = 0x8224469C; return 0x8223E7F0;
		/* 82244698h case   22:*/		return 0x8224469C;
		  /* 8224469Ch */ case   23:  		/* lwz R11, <#[R31 + 4]> */
		/* 8224469Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224469Ch case   23:*/		return 0x822446A0;
		  /* 822446A0h */ case   24:  		/* rlwimi R11, R3, 9, 20, 22 */
		/* 822446A0h case   24:*/		cpu::op::rlwimi<0,9,20,22>(regs,&regs.R11,regs.R3);
		/* 822446A0h case   24:*/		return 0x822446A4;
		  /* 822446A4h */ case   25:  		/* stw R11, <#[R31 + 4]> */
		/* 822446A4h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822446A4h case   25:*/		return 0x822446A8;
		  /* 822446A8h */ case   26:  		/* lwz R10, <#[R30 + 52]> */
		/* 822446A8h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000034) );
		/* 822446A8h case   26:*/		return 0x822446AC;
		  /* 822446ACh */ case   27:  		/* cmpwi CR6, R10, 0 */
		/* 822446ACh case   27:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 822446ACh case   27:*/		return 0x822446B0;
		  /* 822446B0h */ case   28:  		/* bc 12, CR6_EQ, 76 */
		/* 822446B0h case   28:*/		if ( regs.CR[6].eq ) { return 0x822446FC;  }
		/* 822446B0h case   28:*/		return 0x822446B4;
		  /* 822446B4h */ case   29:  		/* cmpwi CR6, R10, 2 */
		/* 822446B4h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000002);
		/* 822446B4h case   29:*/		return 0x822446B8;
		  /* 822446B8h */ case   30:  		/* bc 12, CR6_EQ, 60 */
		/* 822446B8h case   30:*/		if ( regs.CR[6].eq ) { return 0x822446F4;  }
		/* 822446B8h case   30:*/		return 0x822446BC;
		  /* 822446BCh */ case   31:  		/* cmpwi CR6, R10, 3 */
		/* 822446BCh case   31:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 822446BCh case   31:*/		return 0x822446C0;
		  /* 822446C0h */ case   32:  		/* bc 12, CR6_EQ, 36 */
		/* 822446C0h case   32:*/		if ( regs.CR[6].eq ) { return 0x822446E4;  }
		/* 822446C0h case   32:*/		return 0x822446C4;
		  /* 822446C4h */ case   33:  		/* lis R11, -32255 */
		/* 822446C4h case   33:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 822446C4h case   33:*/		return 0x822446C8;
		  /* 822446C8h */ case   34:  		/* mr R6, R26 */
		/* 822446C8h case   34:*/		regs.R6 = regs.R26;
		/* 822446C8h case   34:*/		return 0x822446CC;
		  /* 822446CCh */ case   35:  		/* addi R5, R11, 5216 */
		/* 822446CCh case   35:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1460);
		/* 822446CCh case   35:*/		return 0x822446D0;
		  /* 822446D0h */ case   36:  		/* mr R4, R27 */
		/* 822446D0h case   36:*/		regs.R4 = regs.R27;
		/* 822446D0h case   36:*/		return 0x822446D4;
		  /* 822446D4h */ case   37:  		/* li R7, 2983 */
		/* 822446D4h case   37:*/		cpu::op::li<0>(regs,&regs.R7,0xBA7);
		/* 822446D4h case   37:*/		return 0x822446D8;
		  /* 822446D8h */ case   38:  		/* li R3, 0 */
		/* 822446D8h case   38:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822446D8h case   38:*/		return 0x822446DC;
		  /* 822446DCh */ case   39:  		/* bl -969428 */
		/* 822446DCh case   39:*/		regs.LR = 0x822446E0; return 0x82157C08;
		/* 822446DCh case   39:*/		return 0x822446E0;
		  /* 822446E0h */ case   40:  		/* b 48 */
		/* 822446E0h case   40:*/		return 0x82244710;
		/* 822446E0h case   40:*/		return 0x822446E4;
	}
	return 0x822446E4;
} // Block from 82244640h-822446E4h (41 instructions)

//////////////////////////////////////////////////////
// Block at 822446E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822446E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822446E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822446E4);
		  /* 822446E4h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 822446E4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 822446E4h case    0:*/		return 0x822446E8;
		  /* 822446E8h */ case    1:  		/* oris R11, R11, 32768 */
		/* 822446E8h case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 822446E8h case    1:*/		return 0x822446EC;
		  /* 822446ECh */ case    2:  		/* oris R10, R10, 32768 */
		/* 822446ECh case    2:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 822446ECh case    2:*/		return 0x822446F0;
		  /* 822446F0h */ case    3:  		/* b 24 */
		/* 822446F0h case    3:*/		return 0x82244708;
		/* 822446F0h case    3:*/		return 0x822446F4;
	}
	return 0x822446F4;
} // Block from 822446E4h-822446F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822446F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822446F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822446F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822446F4);
		  /* 822446F4h */ case    0:  		/* oris R11, R11, 32768 */
		/* 822446F4h case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 822446F4h case    0:*/		return 0x822446F8;
		  /* 822446F8h */ case    1:  		/* b 8 */
		/* 822446F8h case    1:*/		return 0x82244700;
		/* 822446F8h case    1:*/		return 0x822446FC;
	}
	return 0x822446FC;
} // Block from 822446F4h-822446FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822446FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822446FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822446FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822446FC);
		  /* 822446FCh */ case    0:  		/* rlwinm R11, R11, 0, 1, 31 */
		/* 822446FCh case    0:*/		cpu::op::rlwinm<0,0,1,31>(regs,&regs.R11,regs.R11);
		/* 822446FCh case    0:*/		return 0x82244700;
	}
	return 0x82244700;
} // Block from 822446FCh-82244700h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82244700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244700);
		  /* 82244700h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 82244700h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82244700h case    0:*/		return 0x82244704;
		  /* 82244704h */ case    1:  		/* rlwinm R10, R10, 0, 1, 31 */
		/* 82244704h case    1:*/		cpu::op::rlwinm<0,0,1,31>(regs,&regs.R10,regs.R10);
		/* 82244704h case    1:*/		return 0x82244708;
	}
	return 0x82244708;
} // Block from 82244700h-82244708h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244708);
		  /* 82244708h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 82244708h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82244708h case    0:*/		return 0x8224470C;
		  /* 8224470Ch */ case    1:  		/* stw R10, <#[R31 + 8]> */
		/* 8224470Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8224470Ch case    1:*/		return 0x82244710;
	}
	return 0x82244710;
} // Block from 82244708h-82244710h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244710);
		  /* 82244710h */ case    0:  		/* addi R1, R1, 192 */
		/* 82244710h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82244710h case    0:*/		return 0x82244714;
		  /* 82244714h */ case    1:  		/* b -1782900 */
		/* 82244714h case    1:*/		return 0x820912A0;
		/* 82244714h case    1:*/		return 0x82244718;
	}
	return 0x82244718;
} // Block from 82244710h-82244718h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244718h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244718);
		  /* 82244718h */ case    0:  		/* mfspr R12, LR */
		/* 82244718h case    0:*/		regs.R12 = regs.LR;
		/* 82244718h case    0:*/		return 0x8224471C;
		  /* 8224471Ch */ case    1:  		/* bl -1782996 */
		/* 8224471Ch case    1:*/		regs.LR = 0x82244720; return 0x82091248;
		/* 8224471Ch case    1:*/		return 0x82244720;
		  /* 82244720h */ case    2:  		/* stwu R1, <#[R1 - 320]> */
		/* 82244720h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEC0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEC0);
		/* 82244720h case    2:*/		return 0x82244724;
		  /* 82244724h */ case    3:  		/* mr R27, R4 */
		/* 82244724h case    3:*/		regs.R27 = regs.R4;
		/* 82244724h case    3:*/		return 0x82244728;
		  /* 82244728h */ case    4:  		/* mr R30, R3 */
		/* 82244728h case    4:*/		regs.R30 = regs.R3;
		/* 82244728h case    4:*/		return 0x8224472C;
		  /* 8224472Ch */ case    5:  		/* mr R4, R3 */
		/* 8224472Ch case    5:*/		regs.R4 = regs.R3;
		/* 8224472Ch case    5:*/		return 0x82244730;
		  /* 82244730h */ case    6:  		/* addi R3, R1, 96 */
		/* 82244730h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82244730h case    6:*/		return 0x82244734;
		  /* 82244734h */ case    7:  		/* mr R24, R5 */
		/* 82244734h case    7:*/		regs.R24 = regs.R5;
		/* 82244734h case    7:*/		return 0x82244738;
		  /* 82244738h */ case    8:  		/* bl -19856 */
		/* 82244738h case    8:*/		regs.LR = 0x8224473C; return 0x8223F9A8;
		/* 82244738h case    8:*/		return 0x8224473C;
		  /* 8224473Ch */ case    9:  		/* lbz R11, <#[R30]> */
		/* 8224473Ch case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8224473Ch case    9:*/		return 0x82244740;
		  /* 82244740h */ case   10:  		/* li R26, 1 */
		/* 82244740h case   10:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82244740h case   10:*/		return 0x82244744;
		  /* 82244744h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 82244744h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82244744h case   11:*/		return 0x82244748;
		  /* 82244748h */ case   12:  		/* li R25, 0 */
		/* 82244748h case   12:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82244748h case   12:*/		return 0x8224474C;
		  /* 8224474Ch */ case   13:  		/* lwz R11, <#[R30 + 12]> */
		/* 8224474Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224474Ch case   13:*/		return 0x82244750;
		  /* 82244750h */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 82244750h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8224475C;  }
		/* 82244750h case   14:*/		return 0x82244754;
		  /* 82244754h */ case   15:  		/* stw R25, <#[R11 + 1532]> */
		/* 82244754h case   15:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x000005FC) );
		/* 82244754h case   15:*/		return 0x82244758;
		  /* 82244758h */ case   16:  		/* b 64 */
		/* 82244758h case   16:*/		return 0x82244798;
		/* 82244758h case   16:*/		return 0x8224475C;
	}
	return 0x8224475C;
} // Block from 82244718h-8224475Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224475Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224475C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224475C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224475C);
		  /* 8224475Ch */ case    0:  		/* lwz R10, <#[R11 + 1532]> */
		/* 8224475Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000005FC) );
		/* 8224475Ch case    0:*/		return 0x82244760;
		  /* 82244760h */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 82244760h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82244760h case    1:*/		return 0x82244764;
		  /* 82244764h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 82244764h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224476C;  }
		/* 82244764h case    2:*/		return 0x82244768;
		  /* 82244768h */ case    3:  		/* stw R26, <#[R11 + 1532]> */
		/* 82244768h case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x000005FC) );
		/* 82244768h case    3:*/		return 0x8224476C;
	}
	return 0x8224476C;
} // Block from 8224475Ch-8224476Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224476Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224476C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224476C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224476C);
		  /* 8224476Ch */ case    0:  		/* lwz R3, <#[R30 + 12]> */
		/* 8224476Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224476Ch case    0:*/		return 0x82244770;
		  /* 82244770h */ case    1:  		/* lwz R11, <#[R3 + 1532]> */
		/* 82244770h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000005FC) );
		/* 82244770h case    1:*/		return 0x82244774;
		  /* 82244774h */ case    2:  		/* rlwinm R4, R11, 3, 0, 28 */
		/* 82244774h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R4,regs.R11);
		/* 82244774h case    2:*/		return 0x82244778;
		  /* 82244778h */ case    3:  		/* bl -162728 */
		/* 82244778h case    3:*/		regs.LR = 0x8224477C; return 0x8221CBD0;
		/* 82244778h case    3:*/		return 0x8224477C;
		  /* 8224477Ch */ case    4:  		/* stw R3, <#[R30 + 8]> */
		/* 8224477Ch case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 8224477Ch case    4:*/		return 0x82244780;
		  /* 82244780h */ case    5:  		/* lwz R3, <#[R30 + 12]> */
		/* 82244780h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 82244780h case    5:*/		return 0x82244784;
		  /* 82244784h */ case    6:  		/* lwz R11, <#[R3 + 1376]> */
		/* 82244784h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000560) );
		/* 82244784h case    6:*/		return 0x82244788;
		  /* 82244788h */ case    7:  		/* mulli R4, R11, 6 */
		/* 82244788h case    7:*/		cpu::op::mulli<0>(regs,&regs.R4,regs.R11,0x6);
		/* 82244788h case    7:*/		return 0x8224478C;
		  /* 8224478Ch */ case    8:  		/* bl -162748 */
		/* 8224478Ch case    8:*/		regs.LR = 0x82244790; return 0x8221CBD0;
		/* 8224478Ch case    8:*/		return 0x82244790;
		  /* 82244790h */ case    9:  		/* stw R3, <#[R1 + 116]> */
		/* 82244790h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000074) );
		/* 82244790h case    9:*/		return 0x82244794;
		  /* 82244794h */ case   10:  		/* stw R3, <#[R1 + 120]> */
		/* 82244794h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000078) );
		/* 82244794h case   10:*/		return 0x82244798;
	}
	return 0x82244798;
} // Block from 8224476Ch-82244798h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82244798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244798);
		  /* 82244798h */ case    0:  		/* lwz R3, <#[R1 + 196]> */
		/* 82244798h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000000C4) );
		/* 82244798h case    0:*/		return 0x8224479C;
		  /* 8224479Ch */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 8224479Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 8224479Ch case    1:*/		return 0x822447A0;
		  /* 822447A0h */ case    2:  		/* bl 62240 */
		/* 822447A0h case    2:*/		regs.LR = 0x822447A4; return 0x82253AC0;
		/* 822447A0h case    2:*/		return 0x822447A4;
		  /* 822447A4h */ case    3:  		/* stw R25, <#[R3]> */
		/* 822447A4h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000000) );
		/* 822447A4h case    3:*/		return 0x822447A8;
		  /* 822447A8h */ case    4:  		/* lwz R29, <#[R30 + 136]> */
		/* 822447A8h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000088) );
		/* 822447A8h case    4:*/		return 0x822447AC;
		  /* 822447ACh */ case    5:  		/* lwz R28, <#[R29 + 8]> */
		/* 822447ACh case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000008) );
		/* 822447ACh case    5:*/		return 0x822447B0;
		  /* 822447B0h */ case    6:  		/* b 84 */
		/* 822447B0h case    6:*/		return 0x82244804;
		/* 822447B0h case    6:*/		return 0x822447B4;
		  /* 822447B4h */ case    7:  		/* lwz R11, <#[R29]> */
		/* 822447B4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 822447B4h case    7:*/		return 0x822447B8;
		  /* 822447B8h */ case    8:  		/* mr R3, R29 */
		/* 822447B8h case    8:*/		regs.R3 = regs.R29;
		/* 822447B8h case    8:*/		return 0x822447BC;
		  /* 822447BCh */ case    9:  		/* lwz R11, <#[R11 + 12]> */
		/* 822447BCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 822447BCh case    9:*/		return 0x822447C0;
		  /* 822447C0h */ case   10:  		/* mtspr CTR, R11 */
		/* 822447C0h case   10:*/		regs.CTR = regs.R11;
		/* 822447C0h case   10:*/		return 0x822447C4;
		  /* 822447C4h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 822447C4h case   11:*/		if ( 1 ) { regs.LR = 0x822447C8; return (uint32)regs.CTR; }
		/* 822447C4h case   11:*/		return 0x822447C8;
		  /* 822447C8h */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822447C8h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822447C8h case   12:*/		return 0x822447CC;
		  /* 822447CCh */ case   13:  		/* bc 12, CR0_EQ, 236 */
		/* 822447CCh case   13:*/		if ( regs.CR[0].eq ) { return 0x822448B8;  }
		/* 822447CCh case   13:*/		return 0x822447D0;
		  /* 822447D0h */ case   14:  		/* addi R4, R1, 80 */
		/* 822447D0h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822447D0h case   14:*/		return 0x822447D4;
		  /* 822447D4h */ case   15:  		/* mr R3, R29 */
		/* 822447D4h case   15:*/		regs.R3 = regs.R29;
		/* 822447D4h case   15:*/		return 0x822447D8;
		  /* 822447D8h */ case   16:  		/* bl -22608 */
		/* 822447D8h case   16:*/		regs.LR = 0x822447DC; return 0x8223EF88;
		/* 822447D8h case   16:*/		return 0x822447DC;
		  /* 822447DCh */ case   17:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822447DCh case   17:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822447DCh case   17:*/		return 0x822447E0;
		  /* 822447E0h */ case   18:  		/* bc 12, CR0_EQ, 216 */
		/* 822447E0h case   18:*/		if ( regs.CR[0].eq ) { return 0x822448B8;  }
		/* 822447E0h case   18:*/		return 0x822447E4;
		  /* 822447E4h */ case   19:  		/* addi R5, R1, 80 */
		/* 822447E4h case   19:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 822447E4h case   19:*/		return 0x822447E8;
		  /* 822447E8h */ case   20:  		/* addi R4, R1, 96 */
		/* 822447E8h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 822447E8h case   20:*/		return 0x822447EC;
		  /* 822447ECh */ case   21:  		/* mr R3, R29 */
		/* 822447ECh case   21:*/		regs.R3 = regs.R29;
		/* 822447ECh case   21:*/		return 0x822447F0;
		  /* 822447F0h */ case   22:  		/* bl -4648 */
		/* 822447F0h case   22:*/		regs.LR = 0x822447F4; return 0x822435C8;
		/* 822447F0h case   22:*/		return 0x822447F4;
		  /* 822447F4h */ case   23:  		/* lwz R11, <#[R29 + 152]> */
		/* 822447F4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000098) );
		/* 822447F4h case   23:*/		return 0x822447F8;
		  /* 822447F8h */ case   24:  		/* lwz R28, <#[R11 + 8]> */
		/* 822447F8h case   24:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000008) );
		/* 822447F8h case   24:*/		return 0x822447FC;
		  /* 822447FCh */ case   25:  		/* mr R29, R28 */
		/* 822447FCh case   25:*/		regs.R29 = regs.R28;
		/* 822447FCh case   25:*/		return 0x82244800;
		  /* 82244800h */ case   26:  		/* lwz R28, <#[R28 + 8]> */
		/* 82244800h case   26:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000008) );
		/* 82244800h case   26:*/		return 0x82244804;
	}
	return 0x82244804;
} // Block from 82244798h-82244804h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82244804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244804);
		  /* 82244804h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 82244804h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82244804h case    0:*/		return 0x82244808;
		  /* 82244808h */ case    1:  		/* bc 4, CR6_EQ, -84 */
		/* 82244808h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822447B4;  }
		/* 82244808h case    1:*/		return 0x8224480C;
		  /* 8224480Ch */ case    2:  		/* addi R3, R1, 96 */
		/* 8224480Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8224480Ch case    2:*/		return 0x82244810;
		  /* 82244810h */ case    3:  		/* bl -23424 */
		/* 82244810h case    3:*/		regs.LR = 0x82244814; return 0x8223EC90;
		/* 82244810h case    3:*/		return 0x82244814;
		  /* 82244814h */ case    4:  		/* lwz R10, <#[R1 + 156]> */
		/* 82244814h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000009C) );
		/* 82244814h case    4:*/		return 0x82244818;
		  /* 82244818h */ case    5:  		/* lwz R11, <#[R1 + 152]> */
		/* 82244818h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000098) );
		/* 82244818h case    5:*/		return 0x8224481C;
		  /* 8224481Ch */ case    6:  		/* addi R4, R1, 96 */
		/* 8224481Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8224481Ch case    6:*/		return 0x82244820;
		  /* 82244820h */ case    7:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 82244820h case    7:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 82244820h case    7:*/		return 0x82244824;
		  /* 82244824h */ case    8:  		/* mr R3, R30 */
		/* 82244824h case    8:*/		regs.R3 = regs.R30;
		/* 82244824h case    8:*/		return 0x82244828;
		  /* 82244828h */ case    9:  		/* add R11, R10, R11 */
		/* 82244828h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82244828h case    9:*/		return 0x8224482C;
		  /* 8224482Ch */ case   10:  		/* mulli R11, R11, 6 */
		/* 8224482Ch case   10:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x6);
		/* 8224482Ch case   10:*/		return 0x82244830;
		  /* 82244830h */ case   11:  		/* stw R11, <#[R30 + 4]> */
		/* 82244830h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82244830h case   11:*/		return 0x82244834;
		  /* 82244834h */ case   12:  		/* bl -25716 */
		/* 82244834h case   12:*/		regs.LR = 0x82244838; return 0x8223E3C0;
		/* 82244834h case   12:*/		return 0x82244838;
	}
	return 0x82244838;
} // Block from 82244804h-82244838h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82244838h
// Function '?Assemble@LoopFooter@XGRAPHICS@@UAAXAAVAssembler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244838);
		  /* 82244838h */ case    0:  		/* lwz R6, <#[R30 + 12]> */
		/* 82244838h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x0000000C) );
		/* 82244838h case    0:*/		return 0x8224483C;
		  /* 8224483Ch */ case    1:  		/* lwz R11, <#[R6 + 2136]> */
		/* 8224483Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000858) );
		/* 8224483Ch case    1:*/		return 0x82244840;
		  /* 82244840h */ case    2:  		/* rlwinm. R11, R11, 20, 31, 31 */
		/* 82244840h case    2:*/		cpu::op::rlwinm<1,20,31,31>(regs,&regs.R11,regs.R11);
		/* 82244840h case    2:*/		return 0x82244844;
		  /* 82244844h */ case    3:  		/* bc 12, CR0_EQ, 452 */
		/* 82244844h case    3:*/		if ( regs.CR[0].eq ) { return 0x82244A08;  }
		/* 82244844h case    3:*/		return 0x82244848;
		  /* 82244848h */ case    4:  		/* lbz R11, <#[R30]> */
		/* 82244848h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82244848h case    4:*/		return 0x8224484C;
		  /* 8224484Ch */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 8224484Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224484Ch case    5:*/		return 0x82244850;
		  /* 82244850h */ case    6:  		/* bc 4, CR0_EQ, 440 */
		/* 82244850h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82244A08;  }
		/* 82244850h case    6:*/		return 0x82244854;
		  /* 82244854h */ case    7:  		/* stb R26, <#[R30]> */
		/* 82244854h case    7:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R30 + 0x00000000) );
		/* 82244854h case    7:*/		return 0x82244858;
		  /* 82244858h */ case    8:  		/* addi R3, R1, 96 */
		/* 82244858h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82244858h case    8:*/		return 0x8224485C;
		  /* 8224485Ch */ case    9:  		/* lwz R31, <#[R30 + 4]> */
		/* 8224485Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 8224485Ch case    9:*/		return 0x82244860;
		  /* 82244860h */ case   10:  		/* lwz R5, <#[R1 + 100]> */
		/* 82244860h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000064) );
		/* 82244860h case   10:*/		return 0x82244864;
		  /* 82244864h */ case   11:  		/* lwz R4, <#[R1 + 156]> */
		/* 82244864h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000009C) );
		/* 82244864h case   11:*/		return 0x82244868;
		  /* 82244868h */ case   12:  		/* bl 136776 */
		/* 82244868h case   12:*/		regs.LR = 0x8224486C; return 0x82265EB0;
		/* 82244868h case   12:*/		return 0x8224486C;
		  /* 8224486Ch */ case   13:  		/* mr R5, R24 */
		/* 8224486Ch case   13:*/		regs.R5 = regs.R24;
		/* 8224486Ch case   13:*/		return 0x82244870;
		  /* 82244870h */ case   14:  		/* mr R4, R27 */
		/* 82244870h case   14:*/		regs.R4 = regs.R27;
		/* 82244870h case   14:*/		return 0x82244874;
		  /* 82244874h */ case   15:  		/* mr R3, R30 */
		/* 82244874h case   15:*/		regs.R3 = regs.R30;
		/* 82244874h case   15:*/		return 0x82244878;
		  /* 82244878h */ case   16:  		/* bl -352 */
		/* 82244878h case   16:*/		regs.LR = 0x8224487C; return 0x82244718;
		/* 82244878h case   16:*/		return 0x8224487C;
		  /* 8224487Ch */ case   17:  		/* lis R11, -32252 */
		/* 8224487Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224487Ch case   17:*/		return 0x82244880;
		  /* 82244880h */ case   18:  		/* lwz R6, <#[R30 + 4]> */
		/* 82244880h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000004) );
		/* 82244880h case   18:*/		return 0x82244884;
		  /* 82244884h */ case   19:  		/* mr R5, R31 */
		/* 82244884h case   19:*/		regs.R5 = regs.R31;
		/* 82244884h case   19:*/		return 0x82244888;
		  /* 82244888h */ case   20:  		/* addi R4, R11, 12428 */
		/* 82244888h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x308C);
		/* 82244888h case   20:*/		return 0x8224488C;
		  /* 8224488Ch */ case   21:  		/* lwz R3, <#[R30 + 12]> */
		/* 8224488Ch case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224488Ch case   21:*/		return 0x82244890;
		  /* 82244890h */ case   22:  		/* subf R11, R6, R31 */
		/* 82244890h case   22:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R31);
		/* 82244890h case   22:*/		return 0x82244894;
		  /* 82244894h */ case   23:  		/* twi 6, R31, 0 */
		/* 82244894h case   23:*/		cpu::op::tw<6>(regs, 0x82244894, regs.R31, 0x00000000);
		/* 82244894h case   23:*/		return 0x82244898;
		  /* 82244898h */ case   24:  		/* mulli R10, R11, 100 */
		/* 82244898h case   24:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0x64);
		/* 82244898h case   24:*/		return 0x8224489C;
		  /* 8224489Ch */ case   25:  		/* rlwinm R11, R10, 1, 0, 31 */
		/* 8224489Ch case   25:*/		cpu::op::rlwinm<0,1,0,31>(regs,&regs.R11,regs.R10);
		/* 8224489Ch case   25:*/		return 0x822448A0;
		  /* 822448A0h */ case   26:  		/* divw R7, R10, R31 */
		/* 822448A0h case   26:*/		cpu::op::divw<0>(regs,&regs.R7,regs.R10,regs.R31);
		/* 822448A0h case   26:*/		return 0x822448A4;
		  /* 822448A4h */ case   27:  		/* addi R11, R11, -1 */
		/* 822448A4h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822448A4h case   27:*/		return 0x822448A8;
		  /* 822448A8h */ case   28:  		/* andc R11, R31, R11 */
		/* 822448A8h case   28:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 822448A8h case   28:*/		return 0x822448AC;
		  /* 822448ACh */ case   29:  		/* twi 5, R11, -1 */
		/* 822448ACh case   29:*/		cpu::op::tw<5>(regs, 0x822448AC, regs.R11, 0xFFFFFFFF);
		/* 822448ACh case   29:*/		return 0x822448B0;
		  /* 822448B0h */ case   30:  		/* bl -161008 */
		/* 822448B0h case   30:*/		regs.LR = 0x822448B4; return 0x8221D3C0;
		/* 822448B0h case   30:*/		return 0x822448B4;
		  /* 822448B4h */ case   31:  		/* b 528 */
		/* 822448B4h case   31:*/		return 0x82244AC4;
		/* 822448B4h case   31:*/		return 0x822448B8;
	}
	return 0x822448B8;
} // Block from 82244838h-822448B8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 822448B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822448B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822448B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822448B8);
		  /* 822448B8h */ case    0:  		/* mr R3, R29 */
		/* 822448B8h case    0:*/		regs.R3 = regs.R29;
		/* 822448B8h case    0:*/		return 0x822448BC;
		  /* 822448BCh */ case    1:  		/* bl 84988 */
		/* 822448BCh case    1:*/		regs.LR = 0x822448C0; return 0x822594B8;
		/* 822448BCh case    1:*/		return 0x822448C0;
		  /* 822448C0h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 822448C0h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822448C0h case    2:*/		return 0x822448C4;
		  /* 822448C4h */ case    3:  		/* bc 4, CR0_GT, 92 */
		/* 822448C4h case    3:*/		if ( !regs.CR[0].gt ) { return 0x82244920;  }
		/* 822448C4h case    3:*/		return 0x822448C8;
		  /* 822448C8h */ case    4:  		/* lwz R3, <#[R29 + 60]> */
		/* 822448C8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000003C) );
		/* 822448C8h case    4:*/		return 0x822448CC;
		  /* 822448CCh */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 822448CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822448CCh case    5:*/		return 0x822448D0;
		  /* 822448D0h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 822448D0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822448D0h case    6:*/		return 0x822448D4;
		  /* 822448D4h */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 822448D4h case    7:*/		if ( !regs.CR[6].gt ) { return 0x822448E0;  }
		/* 822448D4h case    7:*/		return 0x822448D8;
		  /* 822448D8h */ case    8:  		/* lwz R3, <#[R3 + 8]> */
		/* 822448D8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 822448D8h case    8:*/		return 0x822448DC;
		  /* 822448DCh */ case    9:  		/* b 12 */
		/* 822448DCh case    9:*/		return 0x822448E8;
		/* 822448DCh case    9:*/		return 0x822448E0;
	}
	return 0x822448E0;
} // Block from 822448B8h-822448E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822448E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822448E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822448E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822448E0);
		  /* 822448E0h */ case    0:  		/* li R4, 0 */
		/* 822448E0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822448E0h case    0:*/		return 0x822448E4;
		  /* 822448E4h */ case    1:  		/* bl 61916 */
		/* 822448E4h case    1:*/		regs.LR = 0x822448E8; return 0x82253AC0;
		/* 822448E4h case    1:*/		return 0x822448E8;
	}
	return 0x822448E8;
} // Block from 822448E0h-822448E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822448E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822448E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822448E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822448E8);
		  /* 822448E8h */ case    0:  		/* lwz R31, <#[R3]> */
		/* 822448E8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 822448E8h case    0:*/		return 0x822448EC;
		  /* 822448ECh */ case    1:  		/* mr R3, R31 */
		/* 822448ECh case    1:*/		regs.R3 = regs.R31;
		/* 822448ECh case    1:*/		return 0x822448F0;
		  /* 822448F0h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 822448F0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822448F0h case    2:*/		return 0x822448F4;
		  /* 822448F4h */ case    3:  		/* lwz R11, <#[R11 + 12]> */
		/* 822448F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 822448F4h case    3:*/		return 0x822448F8;
		  /* 822448F8h */ case    4:  		/* mtspr CTR, R11 */
		/* 822448F8h case    4:*/		regs.CTR = regs.R11;
		/* 822448F8h case    4:*/		return 0x822448FC;
		  /* 822448FCh */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 822448FCh case    5:*/		if ( 1 ) { regs.LR = 0x82244900; return (uint32)regs.CTR; }
		/* 822448FCh case    5:*/		return 0x82244900;
		  /* 82244900h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82244900h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82244900h case    6:*/		return 0x82244904;
		  /* 82244904h */ case    7:  		/* bc 12, CR0_EQ, 28 */
		/* 82244904h case    7:*/		if ( regs.CR[0].eq ) { return 0x82244920;  }
		/* 82244904h case    7:*/		return 0x82244908;
		  /* 82244908h */ case    8:  		/* lwz R11, <#[R31 + 148]> */
		/* 82244908h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000094) );
		/* 82244908h case    8:*/		return 0x8224490C;
		  /* 8224490Ch */ case    9:  		/* cmplw CR6, R29, R11 */
		/* 8224490Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8224490Ch case    9:*/		return 0x82244910;
		  /* 82244910h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 82244910h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82244920;  }
		/* 82244910h case   10:*/		return 0x82244914;
		  /* 82244914h */ case   11:  		/* mr R4, R31 */
		/* 82244914h case   11:*/		regs.R4 = regs.R31;
		/* 82244914h case   11:*/		return 0x82244918;
		  /* 82244918h */ case   12:  		/* addi R3, R1, 96 */
		/* 82244918h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82244918h case   12:*/		return 0x8224491C;
		  /* 8224491Ch */ case   13:  		/* bl -1868 */
		/* 8224491Ch case   13:*/		regs.LR = 0x82244920; return 0x822441D0;
		/* 8224491Ch case   13:*/		return 0x82244920;
	}
	return 0x82244920;
} // Block from 822448E8h-82244920h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82244920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244920);
		  /* 82244920h */ case    0:  		/* lbz R11, <#[R30]> */
		/* 82244920h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82244920h case    0:*/		return 0x82244924;
		  /* 82244924h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 82244924h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82244924h case    1:*/		return 0x82244928;
		  /* 82244928h */ case    2:  		/* bc 4, CR0_EQ, 100 */
		/* 82244928h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8224498C;  }
		/* 82244928h case    2:*/		return 0x8224492C;
		  /* 8224492Ch */ case    3:  		/* lwz R9, <#[R1 + 196]> */
		/* 8224492Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000C4) );
		/* 8224492Ch case    3:*/		return 0x82244930;
		  /* 82244930h */ case    4:  		/* lwz R10, <#[R9 + 4]> */
		/* 82244930h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 82244930h case    4:*/		return 0x82244934;
		  /* 82244934h */ case    5:  		/* addi R11, R10, -1 */
		/* 82244934h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82244934h case    5:*/		return 0x82244938;
		  /* 82244938h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 82244938h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244938h case    6:*/		return 0x8224493C;
		  /* 8224493Ch */ case    7:  		/* bc 4, CR6_LT, 20 */
		/* 8224493Ch case    7:*/		if ( !regs.CR[6].lt ) { return 0x82244950;  }
		/* 8224493Ch case    7:*/		return 0x82244940;
		  /* 82244940h */ case    8:  		/* lwz R10, <#[R9 + 8]> */
		/* 82244940h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 82244940h case    8:*/		return 0x82244944;
		  /* 82244944h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82244944h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82244944h case    9:*/		return 0x82244948;
		  /* 82244948h */ case   10:  		/* add R10, R11, R10 */
		/* 82244948h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82244948h case   10:*/		return 0x8224494C;
		  /* 8224494Ch */ case   11:  		/* b 8 */
		/* 8224494Ch case   11:*/		return 0x82244954;
		/* 8224494Ch case   11:*/		return 0x82244950;
	}
	return 0x82244950;
} // Block from 82244920h-82244950h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82244950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244950);
		  /* 82244950h */ case    0:  		/* mr R10, R25 */
		/* 82244950h case    0:*/		regs.R10 = regs.R25;
		/* 82244950h case    0:*/		return 0x82244954;
	}
	return 0x82244954;
} // Block from 82244950h-82244954h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82244954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244954);
		  /* 82244954h */ case    0:  		/* lwz R11, <#[R29 + 28]> */
		/* 82244954h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 82244954h case    0:*/		return 0x82244958;
		  /* 82244958h */ case    1:  		/* lwz R10, <#[R10]> */
		/* 82244958h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82244958h case    1:*/		return 0x8224495C;
		  /* 8224495Ch */ case    2:  		/* b 36 */
		/* 8224495Ch case    2:*/		return 0x82244980;
		/* 8224495Ch case    2:*/		return 0x82244960;
		  /* 82244960h */ case    3:  		/* lwz R9, <#[R11 + 228]> */
		/* 82244960h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x000000E4) );
		/* 82244960h case    3:*/		return 0x82244964;
		  /* 82244964h */ case    4:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82244964h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82244964h case    4:*/		return 0x82244968;
		  /* 82244968h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 82244968h case    5:*/		if ( regs.CR[0].eq ) { return 0x8224497C;  }
		/* 82244968h case    5:*/		return 0x8224496C;
		  /* 8224496Ch */ case    6:  		/* lwz R9, <#[R11 + 24]> */
		/* 8224496Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000018) );
		/* 8224496Ch case    6:*/		return 0x82244970;
		  /* 82244970h */ case    7:  		/* cmpwi CR6, R9, 87 */
		/* 82244970h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000057);
		/* 82244970h case    7:*/		return 0x82244974;
		  /* 82244974h */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 82244974h case    8:*/		if ( regs.CR[6].eq ) { return 0x8224497C;  }
		/* 82244974h case    8:*/		return 0x82244978;
		  /* 82244978h */ case    9:  		/* stw R10, <#[R11 + 52]> */
		/* 82244978h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 82244978h case    9:*/		return 0x8224497C;
	}
	return 0x8224497C;
} // Block from 82244954h-8224497Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224497Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224497C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224497C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224497C);
		  /* 8224497Ch */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8224497Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8224497Ch case    0:*/		return 0x82244980;
	}
	return 0x82244980;
} // Block from 8224497Ch-82244980h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82244980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244980);
		  /* 82244980h */ case    0:  		/* lwz R9, <#[R11 + 8]> */
		/* 82244980h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82244980h case    0:*/		return 0x82244984;
		  /* 82244984h */ case    1:  		/* cmpwi CR6, R9, 0 */
		/* 82244984h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 82244984h case    1:*/		return 0x82244988;
		  /* 82244988h */ case    2:  		/* bc 4, CR6_EQ, -40 */
		/* 82244988h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82244960;  }
		/* 82244988h case    2:*/		return 0x8224498C;
	}
	return 0x8224498C;
} // Block from 82244980h-8224498Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224498Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224498C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224498C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224498C);
		  /* 8224498Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8224498Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224498Ch case    0:*/		return 0x82244990;
		  /* 82244990h */ case    1:  		/* addi R4, R1, 96 */
		/* 82244990h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82244990h case    1:*/		return 0x82244994;
		  /* 82244994h */ case    2:  		/* mr R3, R29 */
		/* 82244994h case    2:*/		regs.R3 = regs.R29;
		/* 82244994h case    2:*/		return 0x82244998;
		  /* 82244998h */ case    3:  		/* lwz R31, <#[R1 + 156]> */
		/* 82244998h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x0000009C) );
		/* 82244998h case    3:*/		return 0x8224499C;
		  /* 8224499Ch */ case    4:  		/* lwz R11, <#[R11 + 36]> */
		/* 8224499Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8224499Ch case    4:*/		return 0x822449A0;
		  /* 822449A0h */ case    5:  		/* mtspr CTR, R11 */
		/* 822449A0h case    5:*/		regs.CTR = regs.R11;
		/* 822449A0h case    5:*/		return 0x822449A4;
		  /* 822449A4h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 822449A4h case    6:*/		if ( 1 ) { regs.LR = 0x822449A8; return (uint32)regs.CTR; }
		/* 822449A4h case    6:*/		return 0x822449A8;
		  /* 822449A8h */ case    7:  		/* lbz R11, <#[R29 + 124]> */
		/* 822449A8h case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000007C) );
		/* 822449A8h case    7:*/		return 0x822449AC;
		  /* 822449ACh */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 822449ACh case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822449ACh case    8:*/		return 0x822449B0;
		  /* 822449B0h */ case    9:  		/* bc 12, CR0_EQ, -436 */
		/* 822449B0h case    9:*/		if ( regs.CR[0].eq ) { return 0x822447FC;  }
		/* 822449B0h case    9:*/		return 0x822449B4;
		  /* 822449B4h */ case   10:  		/* lwz R11, <#[R1 + 156]> */
		/* 822449B4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000009C) );
		/* 822449B4h case   10:*/		return 0x822449B8;
		  /* 822449B8h */ case   11:  		/* cmpw CR6, R31, R11 */
		/* 822449B8h case   11:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 822449B8h case   11:*/		return 0x822449BC;
		  /* 822449BCh */ case   12:  		/* bc 4, CR6_EQ, -448 */
		/* 822449BCh case   12:*/		if ( !regs.CR[6].eq ) { return 0x822447FC;  }
		/* 822449BCh case   12:*/		return 0x822449C0;
		  /* 822449C0h */ case   13:  		/* mr R8, R25 */
		/* 822449C0h case   13:*/		regs.R8 = regs.R25;
		/* 822449C0h case   13:*/		return 0x822449C4;
		  /* 822449C4h */ case   14:  		/* mr R11, R25 */
		/* 822449C4h case   14:*/		regs.R11 = regs.R25;
		/* 822449C4h case   14:*/		return 0x822449C8;
		  /* 822449C8h */ case   15:  		/* mr R9, R26 */
		/* 822449C8h case   15:*/		regs.R9 = regs.R26;
		/* 822449C8h case   15:*/		return 0x822449CC;
		  /* 822449CCh */ case   16:  		/* lwz R10, <#[R29 + 56]> */
		/* 822449CCh case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000038) );
		/* 822449CCh case   16:*/		return 0x822449D0;
	}
	return 0x822449D0;
} // Block from 8224498Ch-822449D0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822449D0h
// Function '?Assemble@PostLoopFooter@XGRAPHICS@@UAAXAAVAssembler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822449D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822449D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822449D0);
		  /* 822449D0h */ case    0:  		/* lwz R7, <#[R10 + 4]> */
		/* 822449D0h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 822449D0h case    0:*/		return 0x822449D4;
		  /* 822449D4h */ case    1:  		/* cmplw CR6, R9, R7 */
		/* 822449D4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 822449D4h case    1:*/		return 0x822449D8;
		  /* 822449D8h */ case    2:  		/* bc 4, CR6_GT, 12 */
		/* 822449D8h case    2:*/		if ( !regs.CR[6].gt ) { return 0x822449E4;  }
		/* 822449D8h case    2:*/		return 0x822449DC;
		  /* 822449DCh */ case    3:  		/* mr R10, R25 */
		/* 822449DCh case    3:*/		regs.R10 = regs.R25;
		/* 822449DCh case    3:*/		return 0x822449E0;
		  /* 822449E0h */ case    4:  		/* b 16 */
		/* 822449E0h case    4:*/		return 0x822449F0;
		/* 822449E0h case    4:*/		return 0x822449E4;
	}
	return 0x822449E4;
} // Block from 822449D0h-822449E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822449E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822449E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822449E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822449E4);
		  /* 822449E4h */ case    0:  		/* lwz R8, <#[R10 + 8]> */
		/* 822449E4h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 822449E4h case    0:*/		return 0x822449E8;
		  /* 822449E8h */ case    1:  		/* mr R10, R26 */
		/* 822449E8h case    1:*/		regs.R10 = regs.R26;
		/* 822449E8h case    1:*/		return 0x822449EC;
		  /* 822449ECh */ case    2:  		/* lwzx R8, <#[R8 + R11]> */
		/* 822449ECh case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 822449ECh case    2:*/		return 0x822449F0;
	}
	return 0x822449F0;
} // Block from 822449E4h-822449F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822449F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822449F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822449F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822449F0);
		  /* 822449F0h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 822449F0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 822449F0h case    0:*/		return 0x822449F4;
		  /* 822449F4h */ case    1:  		/* bc 12, CR0_EQ, -504 */
		/* 822449F4h case    1:*/		if ( regs.CR[0].eq ) { return 0x822447FC;  }
		/* 822449F4h case    1:*/		return 0x822449F8;
		  /* 822449F8h */ case    2:  		/* addi R9, R9, 1 */
		/* 822449F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 822449F8h case    2:*/		return 0x822449FC;
		  /* 822449FCh */ case    3:  		/* stb R26, <#[R8 + 124]> */
		/* 822449FCh case    3:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R8 + 0x0000007C) );
		/* 822449FCh case    3:*/		return 0x82244A00;
		  /* 82244A00h */ case    4:  		/* addi R11, R11, 4 */
		/* 82244A00h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82244A00h case    4:*/		return 0x82244A04;
		  /* 82244A04h */ case    5:  		/* b -56 */
		/* 82244A04h case    5:*/		return 0x822449CC;
		/* 82244A04h case    5:*/		return 0x82244A08;
	}
	return 0x82244A08;
} // Block from 822449F0h-82244A08h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82244A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244A08);
		  /* 82244A08h */ case    0:  		/* lwz R10, <#[R6 + 1360]> */
		/* 82244A08h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000550) );
		/* 82244A08h case    0:*/		return 0x82244A0C;
		  /* 82244A0Ch */ case    1:  		/* lwz R11, <#[R1 + 152]> */
		/* 82244A0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000098) );
		/* 82244A0Ch case    1:*/		return 0x82244A10;
		  /* 82244A10h */ case    2:  		/* srawi R9, R11, 1 */
		/* 82244A10h case    2:*/		cpu::op::srawi<0,1>(regs,&regs.R9,regs.R11);
		/* 82244A10h case    2:*/		return 0x82244A14;
		  /* 82244A14h */ case    3:  		/* mulli R31, R11, 6 */
		/* 82244A14h case    3:*/		cpu::op::mulli<0>(regs,&regs.R31,regs.R11,0x6);
		/* 82244A14h case    3:*/		return 0x82244A18;
		  /* 82244A18h */ case    4:  		/* lwz R11, <#[R1 + 156]> */
		/* 82244A18h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000009C) );
		/* 82244A18h case    4:*/		return 0x82244A1C;
		  /* 82244A1Ch */ case    5:  		/* lwz R8, <#[R10 + 12]> */
		/* 82244A1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 82244A1Ch case    5:*/		return 0x82244A20;
		  /* 82244A20h */ case    6:  		/* addze R10, R9 */
		/* 82244A20h case    6:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R9);
		/* 82244A20h case    6:*/		return 0x82244A24;
		  /* 82244A24h */ case    7:  		/* mulli R28, R11, 12 */
		/* 82244A24h case    7:*/		cpu::op::mulli<0>(regs,&regs.R28,regs.R11,0xC);
		/* 82244A24h case    7:*/		return 0x82244A28;
		  /* 82244A28h */ case    8:  		/* add R11, R10, R11 */
		/* 82244A28h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82244A28h case    8:*/		return 0x82244A2C;
		  /* 82244A2Ch */ case    9:  		/* cmpw CR6, R11, R8 */
		/* 82244A2Ch case    9:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 82244A2Ch case    9:*/		return 0x82244A30;
		  /* 82244A30h */ case   10:  		/* bc 4, CR6_GT, 24 */
		/* 82244A30h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82244A48;  }
		/* 82244A30h case   10:*/		return 0x82244A34;
		  /* 82244A34h */ case   11:  		/* li R11, 23 */
		/* 82244A34h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x17);
		/* 82244A34h case   11:*/		return 0x82244A38;
		  /* 82244A38h */ case   12:  		/* li R4, 1 */
		/* 82244A38h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82244A38h case   12:*/		return 0x82244A3C;
		  /* 82244A3Ch */ case   13:  		/* stw R11, <#[R6 + 1364]> */
		/* 82244A3Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000554) );
		/* 82244A3Ch case   13:*/		return 0x82244A40;
		  /* 82244A40h */ case   14:  		/* addi R3, R6, 16 */
		/* 82244A40h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R6,0x10);
		/* 82244A40h case   14:*/		return 0x82244A44;
		  /* 82244A44h */ case   15:  		/* bl 148588 */
		/* 82244A44h case   15:*/		regs.LR = 0x82244A48; return 0x82268EB0;
		/* 82244A44h case   15:*/		return 0x82244A48;
	}
	return 0x82244A48;
} // Block from 82244A08h-82244A48h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82244A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244A48);
		  /* 82244A48h */ case    0:  		/* add R4, R28, R31 */
		/* 82244A48h case    0:*/		cpu::op::add<0>(regs,&regs.R4,regs.R28,regs.R31);
		/* 82244A48h case    0:*/		return 0x82244A4C;
		  /* 82244A4Ch */ case    1:  		/* mr R5, R24 */
		/* 82244A4Ch case    1:*/		regs.R5 = regs.R24;
		/* 82244A4Ch case    1:*/		return 0x82244A50;
		  /* 82244A50h */ case    2:  		/* stw R4, <#[R27]> */
		/* 82244A50h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R27 + 0x00000000) );
		/* 82244A50h case    2:*/		return 0x82244A54;
		  /* 82244A54h */ case    3:  		/* lwz R3, <#[R30 + 12]> */
		/* 82244A54h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 82244A54h case    3:*/		return 0x82244A58;
		  /* 82244A58h */ case    4:  		/* bl -163552 */
		/* 82244A58h case    4:*/		regs.LR = 0x82244A5C; return 0x8221CB78;
		/* 82244A58h case    4:*/		return 0x82244A5C;
		  /* 82244A5Ch */ case    5:  		/* mr R5, R31 */
		/* 82244A5Ch case    5:*/		regs.R5 = regs.R31;
		/* 82244A5Ch case    5:*/		return 0x82244A60;
		  /* 82244A60h */ case    6:  		/* lwz R4, <#[R1 + 104]> */
		/* 82244A60h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 82244A60h case    6:*/		return 0x82244A64;
		  /* 82244A64h */ case    7:  		/* mr R29, R3 */
		/* 82244A64h case    7:*/		regs.R29 = regs.R3;
		/* 82244A64h case    7:*/		return 0x82244A68;
		  /* 82244A68h */ case    8:  		/* bl -1781944 */
		/* 82244A68h case    8:*/		regs.LR = 0x82244A6C; return 0x820919B0;
		/* 82244A68h case    8:*/		return 0x82244A6C;
		  /* 82244A6Ch */ case    9:  		/* mr R5, R28 */
		/* 82244A6Ch case    9:*/		regs.R5 = regs.R28;
		/* 82244A6Ch case    9:*/		return 0x82244A70;
		  /* 82244A70h */ case   10:  		/* add R3, R29, R31 */
		/* 82244A70h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R29,regs.R31);
		/* 82244A70h case   10:*/		return 0x82244A74;
		  /* 82244A74h */ case   11:  		/* lwz R4, <#[R1 + 100]> */
		/* 82244A74h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 82244A74h case   11:*/		return 0x82244A78;
		  /* 82244A78h */ case   12:  		/* bl -1781960 */
		/* 82244A78h case   12:*/		regs.LR = 0x82244A7C; return 0x820919B0;
		/* 82244A78h case   12:*/		return 0x82244A7C;
		  /* 82244A7Ch */ case   13:  		/* lwz R10, <#[R27]> */
		/* 82244A7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 82244A7Ch case   13:*/		return 0x82244A80;
		  /* 82244A80h */ case   14:  		/* li R11, 12 */
		/* 82244A80h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 82244A80h case   14:*/		return 0x82244A84;
		  /* 82244A84h */ case   15:  		/* mr R4, R31 */
		/* 82244A84h case   15:*/		regs.R4 = regs.R31;
		/* 82244A84h case   15:*/		return 0x82244A88;
		  /* 82244A88h */ case   16:  		/* divwu R11, R10, R11 */
		/* 82244A88h case   16:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82244A88h case   16:*/		return 0x82244A8C;
		  /* 82244A8Ch */ case   17:  		/* addi R3, R1, 96 */
		/* 82244A8Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82244A8Ch case   17:*/		return 0x82244A90;
		  /* 82244A90h */ case   18:  		/* mulli R11, R11, 3 */
		/* 82244A90h case   18:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x3);
		/* 82244A90h case   18:*/		return 0x82244A94;
		  /* 82244A94h */ case   19:  		/* stw R11, <#[R27]> */
		/* 82244A94h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82244A94h case   19:*/		return 0x82244A98;
		  /* 82244A98h */ case   20:  		/* bl -23456 */
		/* 82244A98h case   20:*/		regs.LR = 0x82244A9C; return 0x8223EEF8;
		/* 82244A98h case   20:*/		return 0x82244A9C;
		  /* 82244A9Ch */ case   21:  		/* mr R3, R30 */
		/* 82244A9Ch case   21:*/		regs.R3 = regs.R30;
		/* 82244A9Ch case   21:*/		return 0x82244AA0;
		  /* 82244AA0h */ case   22:  		/* bl 11360 */
		/* 82244AA0h case   22:*/		regs.LR = 0x82244AA4; return 0x82247700;
		/* 82244AA0h case   22:*/		return 0x82244AA4;
		  /* 82244AA4h */ case   23:  		/* lwz R4, <#[R30 + 8]> */
		/* 82244AA4h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000008) );
		/* 82244AA4h case   23:*/		return 0x82244AA8;
		  /* 82244AA8h */ case   24:  		/* cmplwi CR6, R4, 0 */
		/* 82244AA8h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82244AA8h case   24:*/		return 0x82244AAC;
		  /* 82244AACh */ case   25:  		/* bc 12, CR6_EQ, 24 */
		/* 82244AACh case   25:*/		if ( regs.CR[6].eq ) { return 0x82244AC4;  }
		/* 82244AACh case   25:*/		return 0x82244AB0;
		  /* 82244AB0h */ case   26:  		/* lwz R11, <#[R30 + 12]> */
		/* 82244AB0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82244AB0h case   26:*/		return 0x82244AB4;
		  /* 82244AB4h */ case   27:  		/* lwz R10, <#[R11 + 1436]> */
		/* 82244AB4h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000059C) );
		/* 82244AB4h case   27:*/		return 0x82244AB8;
		  /* 82244AB8h */ case   28:  		/* lwz R3, <#[R11 + 1444]> */
		/* 82244AB8h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005A4) );
		/* 82244AB8h case   28:*/		return 0x82244ABC;
		  /* 82244ABCh */ case   29:  		/* mtspr CTR, R10 */
		/* 82244ABCh case   29:*/		regs.CTR = regs.R10;
		/* 82244ABCh case   29:*/		return 0x82244AC0;
		  /* 82244AC0h */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 82244AC0h case   30:*/		if ( 1 ) { regs.LR = 0x82244AC4; return (uint32)regs.CTR; }
		/* 82244AC0h case   30:*/		return 0x82244AC4;
	}
	return 0x82244AC4;
} // Block from 82244A48h-82244AC4h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82244AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244AC4);
		  /* 82244AC4h */ case    0:  		/* addi R3, R1, 96 */
		/* 82244AC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82244AC4h case    0:*/		return 0x82244AC8;
		  /* 82244AC8h */ case    1:  		/* bl -10968 */
		/* 82244AC8h case    1:*/		regs.LR = 0x82244ACC; return 0x82241FF0;
		/* 82244AC8h case    1:*/		return 0x82244ACC;
		  /* 82244ACCh */ case    2:  		/* addi R1, R1, 320 */
		/* 82244ACCh case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x140);
		/* 82244ACCh case    2:*/		return 0x82244AD0;
		  /* 82244AD0h */ case    3:  		/* b -1783864 */
		/* 82244AD0h case    3:*/		return 0x82091298;
		/* 82244AD0h case    3:*/		return 0x82244AD4;
		  /* 82244AD4h */ case    4:  		/* nop */
		/* 82244AD4h case    4:*/		cpu::op::nop();
		/* 82244AD4h case    4:*/		return 0x82244AD8;
		  /* 82244AD8h */ case    5:  		/* lwz R3, <#[R3 + 900]> */
		/* 82244AD8h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000384) );
		/* 82244AD8h case    5:*/		return 0x82244ADC;
		  /* 82244ADCh */ case    6:  		/* bclr 20, CR0_LT */
		/* 82244ADCh case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244ADCh case    6:*/		return 0x82244AE0;
	}
	return 0x82244AE0;
} // Block from 82244AC4h-82244AE0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82244AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244AE0);
		  /* 82244AE0h */ case    0:  		/* lwz R11, <#[R3 + 908]> */
		/* 82244AE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000038C) );
		/* 82244AE0h case    0:*/		return 0x82244AE4;
		  /* 82244AE4h */ case    1:  		/* lwz R10, <#[R3 + 900]> */
		/* 82244AE4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000384) );
		/* 82244AE4h case    1:*/		return 0x82244AE8;
		  /* 82244AE8h */ case    2:  		/* add R3, R11, R10 */
		/* 82244AE8h case    2:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82244AE8h case    2:*/		return 0x82244AEC;
		  /* 82244AECh */ case    3:  		/* bclr 20, CR0_LT */
		/* 82244AECh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244AECh case    3:*/		return 0x82244AF0;
	}
	return 0x82244AF0;
} // Block from 82244AE0h-82244AF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82244AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244AF0);
		  /* 82244AF0h */ case    0:  		/* lwz R11, <#[R3 + 916]> */
		/* 82244AF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000394) );
		/* 82244AF0h case    0:*/		return 0x82244AF4;
		  /* 82244AF4h */ case    1:  		/* lwz R9, <#[R3 + 908]> */
		/* 82244AF4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000038C) );
		/* 82244AF4h case    1:*/		return 0x82244AF8;
		  /* 82244AF8h */ case    2:  		/* lwz R10, <#[R3 + 900]> */
		/* 82244AF8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000384) );
		/* 82244AF8h case    2:*/		return 0x82244AFC;
		  /* 82244AFCh */ case    3:  		/* add R11, R11, R9 */
		/* 82244AFCh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82244AFCh case    3:*/		return 0x82244B00;
		  /* 82244B00h */ case    4:  		/* add R3, R11, R10 */
		/* 82244B00h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82244B00h case    4:*/		return 0x82244B04;
		  /* 82244B04h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82244B04h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244B04h case    5:*/		return 0x82244B08;
	}
	return 0x82244B08;
} // Block from 82244AF0h-82244B08h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82244B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244B08);
		  /* 82244B08h */ case    0:  		/* lwz R10, <#[R3 + 916]> */
		/* 82244B08h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000394) );
		/* 82244B08h case    0:*/		return 0x82244B0C;
		  /* 82244B0Ch */ case    1:  		/* lwz R11, <#[R3 + 924]> */
		/* 82244B0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000039C) );
		/* 82244B0Ch case    1:*/		return 0x82244B10;
		  /* 82244B10h */ case    2:  		/* lwz R9, <#[R3 + 908]> */
		/* 82244B10h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000038C) );
		/* 82244B10h case    2:*/		return 0x82244B14;
		  /* 82244B14h */ case    3:  		/* add R11, R11, R10 */
		/* 82244B14h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82244B14h case    3:*/		return 0x82244B18;
		  /* 82244B18h */ case    4:  		/* lwz R10, <#[R3 + 900]> */
		/* 82244B18h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000384) );
		/* 82244B18h case    4:*/		return 0x82244B1C;
		  /* 82244B1Ch */ case    5:  		/* add R11, R11, R9 */
		/* 82244B1Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82244B1Ch case    5:*/		return 0x82244B20;
		  /* 82244B20h */ case    6:  		/* add R3, R11, R10 */
		/* 82244B20h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82244B20h case    6:*/		return 0x82244B24;
		  /* 82244B24h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82244B24h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244B24h case    7:*/		return 0x82244B28;
	}
	return 0x82244B28;
} // Block from 82244B08h-82244B28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82244B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244B28);
		  /* 82244B28h */ case    0:  		/* lwz R11, <#[R3 + 928]> */
		/* 82244B28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003A0) );
		/* 82244B28h case    0:*/		return 0x82244B2C;
		  /* 82244B2Ch */ case    1:  		/* lwz R10, <#[R4 + 928]> */
		/* 82244B2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000003A0) );
		/* 82244B2Ch case    1:*/		return 0x82244B30;
		  /* 82244B30h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82244B30h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244B30h case    2:*/		return 0x82244B34;
		  /* 82244B34h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82244B34h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82244B4C;  }
		/* 82244B34h case    3:*/		return 0x82244B38;
		  /* 82244B38h */ case    4:  		/* lwz R11, <#[R3 + 900]> */
		/* 82244B38h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000384) );
		/* 82244B38h case    4:*/		return 0x82244B3C;
		  /* 82244B3Ch */ case    5:  		/* li R3, 0 */
		/* 82244B3Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82244B3Ch case    5:*/		return 0x82244B40;
		  /* 82244B40h */ case    6:  		/* lwz R10, <#[R4 + 900]> */
		/* 82244B40h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000384) );
		/* 82244B40h case    6:*/		return 0x82244B44;
		  /* 82244B44h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82244B44h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244B44h case    7:*/		return 0x82244B48;
		  /* 82244B48h */ case    8:  		/* bclr 12, CR6_EQ */
		/* 82244B48h case    8:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82244B48h case    8:*/		return 0x82244B4C;
	}
	return 0x82244B4C;
} // Block from 82244B28h-82244B4Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82244B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244B4C);
		  /* 82244B4Ch */ case    0:  		/* li R3, -1 */
		/* 82244B4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82244B4Ch case    0:*/		return 0x82244B50;
		  /* 82244B50h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82244B50h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244B50h case    1:*/		return 0x82244B54;
	}
	return 0x82244B54;
} // Block from 82244B4Ch-82244B54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244B54);
		  /* 82244B54h */ case    0:  		/* nop */
		/* 82244B54h case    0:*/		cpu::op::nop();
		/* 82244B54h case    0:*/		return 0x82244B58;
		  /* 82244B58h */ case    1:  		/* lwz R11, <#[R3 + 928]> */
		/* 82244B58h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003A0) );
		/* 82244B58h case    1:*/		return 0x82244B5C;
		  /* 82244B5Ch */ case    2:  		/* lwz R10, <#[R4 + 928]> */
		/* 82244B5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000003A0) );
		/* 82244B5Ch case    2:*/		return 0x82244B60;
		  /* 82244B60h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82244B60h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244B60h case    3:*/		return 0x82244B64;
		  /* 82244B64h */ case    4:  		/* bc 4, CR6_EQ, 56 */
		/* 82244B64h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82244B9C;  }
		/* 82244B64h case    4:*/		return 0x82244B68;
		  /* 82244B68h */ case    5:  		/* lwz R11, <#[R3 + 900]> */
		/* 82244B68h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000384) );
		/* 82244B68h case    5:*/		return 0x82244B6C;
		  /* 82244B6Ch */ case    6:  		/* lwz R10, <#[R4 + 900]> */
		/* 82244B6Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000384) );
		/* 82244B6Ch case    6:*/		return 0x82244B70;
		  /* 82244B70h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82244B70h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244B70h case    7:*/		return 0x82244B74;
		  /* 82244B74h */ case    8:  		/* bc 4, CR6_EQ, 40 */
		/* 82244B74h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82244B9C;  }
		/* 82244B74h case    8:*/		return 0x82244B78;
		  /* 82244B78h */ case    9:  		/* lwz R11, <#[R3 + 932]> */
		/* 82244B78h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003A4) );
		/* 82244B78h case    9:*/		return 0x82244B7C;
		  /* 82244B7Ch */ case   10:  		/* lwz R10, <#[R4 + 932]> */
		/* 82244B7Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000003A4) );
		/* 82244B7Ch case   10:*/		return 0x82244B80;
		  /* 82244B80h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 82244B80h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244B80h case   11:*/		return 0x82244B84;
		  /* 82244B84h */ case   12:  		/* bc 4, CR6_EQ, 24 */
		/* 82244B84h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82244B9C;  }
		/* 82244B84h case   12:*/		return 0x82244B88;
		  /* 82244B88h */ case   13:  		/* lwz R11, <#[R3 + 908]> */
		/* 82244B88h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000038C) );
		/* 82244B88h case   13:*/		return 0x82244B8C;
		  /* 82244B8Ch */ case   14:  		/* li R3, 0 */
		/* 82244B8Ch case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82244B8Ch case   14:*/		return 0x82244B90;
		  /* 82244B90h */ case   15:  		/* lwz R10, <#[R4 + 908]> */
		/* 82244B90h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000038C) );
		/* 82244B90h case   15:*/		return 0x82244B94;
		  /* 82244B94h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 82244B94h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244B94h case   16:*/		return 0x82244B98;
		  /* 82244B98h */ case   17:  		/* bclr 12, CR6_EQ */
		/* 82244B98h case   17:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82244B98h case   17:*/		return 0x82244B9C;
	}
	return 0x82244B9C;
} // Block from 82244B54h-82244B9Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 82244B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244B9C);
		  /* 82244B9Ch */ case    0:  		/* li R3, -1 */
		/* 82244B9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82244B9Ch case    0:*/		return 0x82244BA0;
		  /* 82244BA0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82244BA0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244BA0h case    1:*/		return 0x82244BA4;
	}
	return 0x82244BA4;
} // Block from 82244B9Ch-82244BA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244BA4);
		  /* 82244BA4h */ case    0:  		/* nop */
		/* 82244BA4h case    0:*/		cpu::op::nop();
		/* 82244BA4h case    0:*/		return 0x82244BA8;
		  /* 82244BA8h */ case    1:  		/* lwz R11, <#[R3 + 928]> */
		/* 82244BA8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003A0) );
		/* 82244BA8h case    1:*/		return 0x82244BAC;
		  /* 82244BACh */ case    2:  		/* lwz R10, <#[R4 + 928]> */
		/* 82244BACh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000003A0) );
		/* 82244BACh case    2:*/		return 0x82244BB0;
		  /* 82244BB0h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82244BB0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244BB0h case    3:*/		return 0x82244BB4;
		  /* 82244BB4h */ case    4:  		/* bc 4, CR6_EQ, 88 */
		/* 82244BB4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82244C0C;  }
		/* 82244BB4h case    4:*/		return 0x82244BB8;
		  /* 82244BB8h */ case    5:  		/* lwz R11, <#[R3 + 900]> */
		/* 82244BB8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000384) );
		/* 82244BB8h case    5:*/		return 0x82244BBC;
		  /* 82244BBCh */ case    6:  		/* lwz R10, <#[R4 + 900]> */
		/* 82244BBCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000384) );
		/* 82244BBCh case    6:*/		return 0x82244BC0;
		  /* 82244BC0h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82244BC0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244BC0h case    7:*/		return 0x82244BC4;
		  /* 82244BC4h */ case    8:  		/* bc 4, CR6_EQ, 72 */
		/* 82244BC4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82244C0C;  }
		/* 82244BC4h case    8:*/		return 0x82244BC8;
		  /* 82244BC8h */ case    9:  		/* lwz R11, <#[R3 + 932]> */
		/* 82244BC8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003A4) );
		/* 82244BC8h case    9:*/		return 0x82244BCC;
		  /* 82244BCCh */ case   10:  		/* lwz R10, <#[R4 + 932]> */
		/* 82244BCCh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000003A4) );
		/* 82244BCCh case   10:*/		return 0x82244BD0;
		  /* 82244BD0h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 82244BD0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244BD0h case   11:*/		return 0x82244BD4;
		  /* 82244BD4h */ case   12:  		/* bc 4, CR6_EQ, 56 */
		/* 82244BD4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82244C0C;  }
		/* 82244BD4h case   12:*/		return 0x82244BD8;
		  /* 82244BD8h */ case   13:  		/* lwz R11, <#[R3 + 908]> */
		/* 82244BD8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000038C) );
		/* 82244BD8h case   13:*/		return 0x82244BDC;
		  /* 82244BDCh */ case   14:  		/* lwz R10, <#[R4 + 908]> */
		/* 82244BDCh case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000038C) );
		/* 82244BDCh case   14:*/		return 0x82244BE0;
		  /* 82244BE0h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 82244BE0h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244BE0h case   15:*/		return 0x82244BE4;
		  /* 82244BE4h */ case   16:  		/* bc 4, CR6_EQ, 40 */
		/* 82244BE4h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82244C0C;  }
		/* 82244BE4h case   16:*/		return 0x82244BE8;
	}
	return 0x82244BE8;
} // Block from 82244BA4h-82244BE8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82244BE8h
// Function '?Assemble@BreakBlock@XGRAPHICS@@UAAXAAVAssembler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244BE8);
		  /* 82244BE8h */ case    0:  		/* lwz R11, <#[R3 + 936]> */
		/* 82244BE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003A8) );
		/* 82244BE8h case    0:*/		return 0x82244BEC;
		  /* 82244BECh */ case    1:  		/* lwz R10, <#[R4 + 936]> */
		/* 82244BECh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000003A8) );
		/* 82244BECh case    1:*/		return 0x82244BF0;
		  /* 82244BF0h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82244BF0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244BF0h case    2:*/		return 0x82244BF4;
		  /* 82244BF4h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82244BF4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82244C0C;  }
		/* 82244BF4h case    3:*/		return 0x82244BF8;
		  /* 82244BF8h */ case    4:  		/* lwz R11, <#[R3 + 916]> */
		/* 82244BF8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000394) );
		/* 82244BF8h case    4:*/		return 0x82244BFC;
		  /* 82244BFCh */ case    5:  		/* li R3, 0 */
		/* 82244BFCh case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82244BFCh case    5:*/		return 0x82244C00;
		  /* 82244C00h */ case    6:  		/* lwz R10, <#[R4 + 916]> */
		/* 82244C00h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000394) );
		/* 82244C00h case    6:*/		return 0x82244C04;
		  /* 82244C04h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82244C04h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244C04h case    7:*/		return 0x82244C08;
		  /* 82244C08h */ case    8:  		/* bclr 12, CR6_EQ */
		/* 82244C08h case    8:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82244C08h case    8:*/		return 0x82244C0C;
	}
	return 0x82244C0C;
} // Block from 82244BE8h-82244C0Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82244C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244C0C);
		  /* 82244C0Ch */ case    0:  		/* li R3, -1 */
		/* 82244C0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82244C0Ch case    0:*/		return 0x82244C10;
		  /* 82244C10h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82244C10h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244C10h case    1:*/		return 0x82244C14;
	}
	return 0x82244C14;
} // Block from 82244C0Ch-82244C14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244C14);
		  /* 82244C14h */ case    0:  		/* nop */
		/* 82244C14h case    0:*/		cpu::op::nop();
		/* 82244C14h case    0:*/		return 0x82244C18;
		  /* 82244C18h */ case    1:  		/* lwz R11, <#[R3 + 928]> */
		/* 82244C18h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003A0) );
		/* 82244C18h case    1:*/		return 0x82244C1C;
		  /* 82244C1Ch */ case    2:  		/* lwz R10, <#[R4 + 928]> */
		/* 82244C1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000003A0) );
		/* 82244C1Ch case    2:*/		return 0x82244C20;
		  /* 82244C20h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82244C20h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244C20h case    3:*/		return 0x82244C24;
		  /* 82244C24h */ case    4:  		/* bc 4, CR6_EQ, 120 */
		/* 82244C24h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82244C9C;  }
		/* 82244C24h case    4:*/		return 0x82244C28;
		  /* 82244C28h */ case    5:  		/* lwz R11, <#[R3 + 900]> */
		/* 82244C28h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000384) );
		/* 82244C28h case    5:*/		return 0x82244C2C;
		  /* 82244C2Ch */ case    6:  		/* lwz R10, <#[R4 + 900]> */
		/* 82244C2Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000384) );
		/* 82244C2Ch case    6:*/		return 0x82244C30;
		  /* 82244C30h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82244C30h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244C30h case    7:*/		return 0x82244C34;
		  /* 82244C34h */ case    8:  		/* bc 4, CR6_EQ, 104 */
		/* 82244C34h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82244C9C;  }
		/* 82244C34h case    8:*/		return 0x82244C38;
		  /* 82244C38h */ case    9:  		/* lwz R11, <#[R3 + 932]> */
		/* 82244C38h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003A4) );
		/* 82244C38h case    9:*/		return 0x82244C3C;
		  /* 82244C3Ch */ case   10:  		/* lwz R10, <#[R4 + 932]> */
		/* 82244C3Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000003A4) );
		/* 82244C3Ch case   10:*/		return 0x82244C40;
		  /* 82244C40h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 82244C40h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244C40h case   11:*/		return 0x82244C44;
		  /* 82244C44h */ case   12:  		/* bc 4, CR6_EQ, 88 */
		/* 82244C44h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82244C9C;  }
		/* 82244C44h case   12:*/		return 0x82244C48;
		  /* 82244C48h */ case   13:  		/* lwz R11, <#[R3 + 908]> */
		/* 82244C48h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000038C) );
		/* 82244C48h case   13:*/		return 0x82244C4C;
		  /* 82244C4Ch */ case   14:  		/* lwz R10, <#[R4 + 908]> */
		/* 82244C4Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000038C) );
		/* 82244C4Ch case   14:*/		return 0x82244C50;
		  /* 82244C50h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 82244C50h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244C50h case   15:*/		return 0x82244C54;
		  /* 82244C54h */ case   16:  		/* bc 4, CR6_EQ, 72 */
		/* 82244C54h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82244C9C;  }
		/* 82244C54h case   16:*/		return 0x82244C58;
		  /* 82244C58h */ case   17:  		/* lwz R11, <#[R3 + 936]> */
		/* 82244C58h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003A8) );
		/* 82244C58h case   17:*/		return 0x82244C5C;
		  /* 82244C5Ch */ case   18:  		/* lwz R10, <#[R4 + 936]> */
		/* 82244C5Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000003A8) );
		/* 82244C5Ch case   18:*/		return 0x82244C60;
		  /* 82244C60h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 82244C60h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244C60h case   19:*/		return 0x82244C64;
		  /* 82244C64h */ case   20:  		/* bc 4, CR6_EQ, 56 */
		/* 82244C64h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82244C9C;  }
		/* 82244C64h case   20:*/		return 0x82244C68;
		  /* 82244C68h */ case   21:  		/* lwz R11, <#[R3 + 916]> */
		/* 82244C68h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000394) );
		/* 82244C68h case   21:*/		return 0x82244C6C;
		  /* 82244C6Ch */ case   22:  		/* lwz R10, <#[R4 + 916]> */
		/* 82244C6Ch case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000394) );
		/* 82244C6Ch case   22:*/		return 0x82244C70;
		  /* 82244C70h */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 82244C70h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244C70h case   23:*/		return 0x82244C74;
		  /* 82244C74h */ case   24:  		/* bc 4, CR6_EQ, 40 */
		/* 82244C74h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82244C9C;  }
		/* 82244C74h case   24:*/		return 0x82244C78;
		  /* 82244C78h */ case   25:  		/* lwz R11, <#[R3 + 940]> */
		/* 82244C78h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003AC) );
		/* 82244C78h case   25:*/		return 0x82244C7C;
		  /* 82244C7Ch */ case   26:  		/* lwz R10, <#[R4 + 940]> */
		/* 82244C7Ch case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000003AC) );
		/* 82244C7Ch case   26:*/		return 0x82244C80;
		  /* 82244C80h */ case   27:  		/* cmplw CR6, R11, R10 */
		/* 82244C80h case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244C80h case   27:*/		return 0x82244C84;
		  /* 82244C84h */ case   28:  		/* bc 4, CR6_EQ, 24 */
		/* 82244C84h case   28:*/		if ( !regs.CR[6].eq ) { return 0x82244C9C;  }
		/* 82244C84h case   28:*/		return 0x82244C88;
		  /* 82244C88h */ case   29:  		/* lwz R11, <#[R3 + 924]> */
		/* 82244C88h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000039C) );
		/* 82244C88h case   29:*/		return 0x82244C8C;
		  /* 82244C8Ch */ case   30:  		/* li R3, 0 */
		/* 82244C8Ch case   30:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82244C8Ch case   30:*/		return 0x82244C90;
	}
	return 0x82244C90;
} // Block from 82244C14h-82244C90h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82244C90h
// Function '?Assemble@ContinueBlock@XGRAPHICS@@UAAXAAVAssembler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244C90);
		  /* 82244C90h */ case    0:  		/* lwz R10, <#[R4 + 924]> */
		/* 82244C90h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000039C) );
		/* 82244C90h case    0:*/		return 0x82244C94;
		  /* 82244C94h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 82244C94h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82244C94h case    1:*/		return 0x82244C98;
		  /* 82244C98h */ case    2:  		/* bclr 12, CR6_EQ */
		/* 82244C98h case    2:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82244C98h case    2:*/		return 0x82244C9C;
	}
	return 0x82244C9C;
} // Block from 82244C90h-82244C9Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82244C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244C9C);
		  /* 82244C9Ch */ case    0:  		/* li R3, -1 */
		/* 82244C9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82244C9Ch case    0:*/		return 0x82244CA0;
		  /* 82244CA0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82244CA0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244CA0h case    1:*/		return 0x82244CA4;
	}
	return 0x82244CA4;
} // Block from 82244C9Ch-82244CA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244CA4);
		  /* 82244CA4h */ case    0:  		/* nop */
		/* 82244CA4h case    0:*/		cpu::op::nop();
		/* 82244CA4h case    0:*/		return 0x82244CA8;
	}
	return 0x82244CA8;
} // Block from 82244CA4h-82244CA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82244CA8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244CA8);
		  /* 82244CA8h */ case    0:  		/* stw R4, <#[R3]> */
		/* 82244CA8h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 82244CA8h case    0:*/		return 0x82244CAC;
		  /* 82244CACh */ case    1:  		/* bclr 20, CR0_LT */
		/* 82244CACh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244CACh case    1:*/		return 0x82244CB0;
	}
	return 0x82244CB0;
} // Block from 82244CA8h-82244CB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244CB0);
		  /* 82244CB0h */ case    0:  		/* stw R3, <#[R1 - 16]> */
		/* 82244CB0h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82244CB0h case    0:*/		return 0x82244CB4;
		  /* 82244CB4h */ case    1:  		/* lfs FR0, <#[R1 - 16]> */
		/* 82244CB4h case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82244CB4h case    1:*/		return 0x82244CB8;
		  /* 82244CB8h */ case    2:  		/* stw R4, <#[R1 - 12]> */
		/* 82244CB8h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 82244CB8h case    2:*/		return 0x82244CBC;
		  /* 82244CBCh */ case    3:  		/* lfs FR13, <#[R1 - 12]> */
		/* 82244CBCh case    3:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 82244CBCh case    3:*/		return 0x82244CC0;
		  /* 82244CC0h */ case    4:  		/* fcmpu CR6, FR0, FR13 */
		/* 82244CC0h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82244CC0h case    4:*/		return 0x82244CC4;
		  /* 82244CC4h */ case    5:  		/* li R3, 1 */
		/* 82244CC4h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82244CC4h case    5:*/		return 0x82244CC8;
		  /* 82244CC8h */ case    6:  		/* bclr 12, CR6_GT */
		/* 82244CC8h case    6:*/		if ( regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82244CC8h case    6:*/		return 0x82244CCC;
	}
	return 0x82244CCC;
} // Block from 82244CB0h-82244CCCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82244CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244CCC);
		  /* 82244CCCh */ case    0:  		/* li R3, 0 */
		/* 82244CCCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82244CCCh case    0:*/		return 0x82244CD0;
		  /* 82244CD0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82244CD0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244CD0h case    1:*/		return 0x82244CD4;
	}
	return 0x82244CD4;
} // Block from 82244CCCh-82244CD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244CD4);
		  /* 82244CD4h */ case    0:  		/* nop */
		/* 82244CD4h case    0:*/		cpu::op::nop();
		/* 82244CD4h case    0:*/		return 0x82244CD8;
		  /* 82244CD8h */ case    1:  		/* mr R11, R3 */
		/* 82244CD8h case    1:*/		regs.R11 = regs.R3;
		/* 82244CD8h case    1:*/		return 0x82244CDC;
		  /* 82244CDCh */ case    2:  		/* li R3, 0 */
		/* 82244CDCh case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82244CDCh case    2:*/		return 0x82244CE0;
		  /* 82244CE0h */ case    3:  		/* li R9, 0 */
		/* 82244CE0h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82244CE0h case    3:*/		return 0x82244CE4;
		  /* 82244CE4h */ case    4:  		/* cmpwi CR6, R4, 0 */
		/* 82244CE4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82244CE4h case    4:*/		return 0x82244CE8;
		  /* 82244CE8h */ case    5:  		/* bc 4, CR6_GT, 80 */
		/* 82244CE8h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82244D38;  }
		/* 82244CE8h case    5:*/		return 0x82244CEC;
		  /* 82244CECh */ case    6:  		/* mr R8, R11 */
		/* 82244CECh case    6:*/		regs.R8 = regs.R11;
		/* 82244CECh case    6:*/		return 0x82244CF0;
		  /* 82244CF0h */ case    7:  		/* lwz R10, <#[R8]> */
		/* 82244CF0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 82244CF0h case    7:*/		return 0x82244CF4;
		  /* 82244CF4h */ case    8:  		/* cmpwi CR6, R10, 0 */
		/* 82244CF4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82244CF4h case    8:*/		return 0x82244CF8;
		  /* 82244CF8h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 82244CF8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82244D04;  }
		/* 82244CF8h case    9:*/		return 0x82244CFC;
		  /* 82244CFCh */ case   10:  		/* addi R3, R3, 32 */
		/* 82244CFCh case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x20);
		/* 82244CFCh case   10:*/		return 0x82244D00;
		  /* 82244D00h */ case   11:  		/* b 40 */
		/* 82244D00h case   11:*/		return 0x82244D28;
		/* 82244D00h case   11:*/		return 0x82244D04;
	}
	return 0x82244D04;
} // Block from 82244CD4h-82244D04h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82244D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244D04);
		  /* 82244D04h */ case    0:  		/* li R11, 0 */
		/* 82244D04h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82244D04h case    0:*/		return 0x82244D08;
		  /* 82244D08h */ case    1:  		/* rlwinm R7, R10, 0, 31, 31 */
		/* 82244D08h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R7,regs.R10);
		/* 82244D08h case    1:*/		return 0x82244D0C;
		  /* 82244D0Ch */ case    2:  		/* cmplwi CR6, R7, 1 */
		/* 82244D0Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000001);
		/* 82244D0Ch case    2:*/		return 0x82244D10;
		  /* 82244D10h */ case    3:  		/* bclr 12, CR6_EQ */
		/* 82244D10h case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82244D10h case    3:*/		return 0x82244D14;
	}
	return 0x82244D14;
} // Block from 82244D04h-82244D14h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82244D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244D14);
		  /* 82244D14h */ case    0:  		/* addi R11, R11, 1 */
		/* 82244D14h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82244D14h case    0:*/		return 0x82244D18;
		  /* 82244D18h */ case    1:  		/* rlwinm R10, R10, 31, 1, 31 */
		/* 82244D18h case    1:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R10);
		/* 82244D18h case    1:*/		return 0x82244D1C;
		  /* 82244D1Ch */ case    2:  		/* addi R3, R3, 1 */
		/* 82244D1Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82244D1Ch case    2:*/		return 0x82244D20;
		  /* 82244D20h */ case    3:  		/* cmpwi CR6, R11, 32 */
		/* 82244D20h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000020);
		/* 82244D20h case    3:*/		return 0x82244D24;
		  /* 82244D24h */ case    4:  		/* bc 12, CR6_LT, -28 */
		/* 82244D24h case    4:*/		if ( regs.CR[6].lt ) { return 0x82244D08;  }
		/* 82244D24h case    4:*/		return 0x82244D28;
	}
	return 0x82244D28;
} // Block from 82244D14h-82244D28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82244D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244D28);
		  /* 82244D28h */ case    0:  		/* addi R9, R9, 1 */
		/* 82244D28h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82244D28h case    0:*/		return 0x82244D2C;
		  /* 82244D2Ch */ case    1:  		/* addi R8, R8, 4 */
		/* 82244D2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82244D2Ch case    1:*/		return 0x82244D30;
		  /* 82244D30h */ case    2:  		/* cmpw CR6, R9, R4 */
		/* 82244D30h case    2:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R4);
		/* 82244D30h case    2:*/		return 0x82244D34;
		  /* 82244D34h */ case    3:  		/* bc 12, CR6_LT, -68 */
		/* 82244D34h case    3:*/		if ( regs.CR[6].lt ) { return 0x82244CF0;  }
		/* 82244D34h case    3:*/		return 0x82244D38;
	}
	return 0x82244D38;
} // Block from 82244D28h-82244D38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82244D38h
// Function '?EmitElse@Assembler@XGRAPHICS@@QAAXPAVIfHeader@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244D38);
		  /* 82244D38h */ case    0:  		/* li R3, -1 */
		/* 82244D38h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82244D38h case    0:*/		return 0x82244D3C;
		  /* 82244D3Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82244D3Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244D3Ch case    1:*/		return 0x82244D40;
	}
	return 0x82244D40;
} // Block from 82244D38h-82244D40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244D40);
		  /* 82244D40h */ case    0:  		/* mfspr R12, LR */
		/* 82244D40h case    0:*/		regs.R12 = regs.LR;
		/* 82244D40h case    0:*/		return 0x82244D44;
		  /* 82244D44h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82244D44h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82244D44h case    1:*/		return 0x82244D48;
		  /* 82244D48h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82244D48h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82244D48h case    2:*/		return 0x82244D4C;
		  /* 82244D4Ch */ case    3:  		/* std R3, <#[R1 + 112]> */
		/* 82244D4Ch case    3:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 82244D4Ch case    3:*/		return 0x82244D50;
		  /* 82244D50h */ case    4:  		/* mr R3, R4 */
		/* 82244D50h case    4:*/		regs.R3 = regs.R4;
		/* 82244D50h case    4:*/		return 0x82244D54;
		  /* 82244D54h */ case    5:  		/* lwz R11, <#[R1 + 112]> */
		/* 82244D54h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82244D54h case    5:*/		return 0x82244D58;
		  /* 82244D58h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82244D58h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82244D58h case    6:*/		return 0x82244D5C;
		  /* 82244D5Ch */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 82244D5Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82244D6C;  }
		/* 82244D5Ch case    7:*/		return 0x82244D60;
		  /* 82244D60h */ case    8:  		/* lfs FR1, <#[R1 + 116]> */
		/* 82244D60h case    8:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000074) );
		/* 82244D60h case    8:*/		return 0x82244D64;
		  /* 82244D64h */ case    9:  		/* bl 136740 */
		/* 82244D64h case    9:*/		regs.LR = 0x82244D68; return 0x82266388;
		/* 82244D64h case    9:*/		return 0x82244D68;
		  /* 82244D68h */ case   10:  		/* b 40 */
		/* 82244D68h case   10:*/		return 0x82244D90;
		/* 82244D68h case   10:*/		return 0x82244D6C;
	}
	return 0x82244D6C;
} // Block from 82244D40h-82244D6Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82244D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244D6C);
		  /* 82244D6Ch */ case    0:  		/* lha R11, <#[R1 + 116]> */
		/* 82244D6Ch case    0:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 82244D6Ch case    0:*/		return 0x82244D70;
		  /* 82244D70h */ case    1:  		/* lis R10, -32216 */
		/* 82244D70h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 82244D70h case    1:*/		return 0x82244D74;
		  /* 82244D74h */ case    2:  		/* addi R10, R10, 10392 */
		/* 82244D74h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2898);
		/* 82244D74h case    2:*/		return 0x82244D78;
		  /* 82244D78h */ case    3:  		/* lha R6, <#[R1 + 118]> */
		/* 82244D78h case    3:*/		cpu::mem::load16a( regs, &regs.R6, (uint32)(regs.R1 + 0x00000076) );
		/* 82244D78h case    3:*/		return 0x82244D7C;
		  /* 82244D7Ch */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82244D7Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82244D7Ch case    4:*/		return 0x82244D80;
		  /* 82244D80h */ case    5:  		/* lis R8, -32252 */
		/* 82244D80h case    5:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 82244D80h case    5:*/		return 0x82244D84;
		  /* 82244D84h */ case    6:  		/* addi R4, R8, 12488 */
		/* 82244D84h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R8,0x30C8);
		/* 82244D84h case    6:*/		return 0x82244D88;
		  /* 82244D88h */ case    7:  		/* lwzx R5, <#[R11 + R10]> */
		/* 82244D88h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82244D88h case    7:*/		return 0x82244D8C;
		  /* 82244D8Ch */ case    8:  		/* bl 147252 */
		/* 82244D8Ch case    8:*/		regs.LR = 0x82244D90; return 0x82268CC0;
		/* 82244D8Ch case    8:*/		return 0x82244D90;
	}
	return 0x82244D90;
} // Block from 82244D6Ch-82244D90h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82244D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244D90);
		  /* 82244D90h */ case    0:  		/* addi R1, R1, 96 */
		/* 82244D90h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82244D90h case    0:*/		return 0x82244D94;
		  /* 82244D94h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82244D94h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82244D94h case    1:*/		return 0x82244D98;
		  /* 82244D98h */ case    2:  		/* mtspr LR, R12 */
		/* 82244D98h case    2:*/		regs.LR = regs.R12;
		/* 82244D98h case    2:*/		return 0x82244D9C;
		  /* 82244D9Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 82244D9Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244D9Ch case    3:*/		return 0x82244DA0;
	}
	return 0x82244DA0;
} // Block from 82244D90h-82244DA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82244DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244DA0);
		  /* 82244DA0h */ case    0:  		/* mfspr R12, LR */
		/* 82244DA0h case    0:*/		regs.R12 = regs.LR;
		/* 82244DA0h case    0:*/		return 0x82244DA4;
		  /* 82244DA4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82244DA4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82244DA4h case    1:*/		return 0x82244DA8;
		  /* 82244DA8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82244DA8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82244DA8h case    2:*/		return 0x82244DAC;
		  /* 82244DACh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82244DACh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82244DACh case    3:*/		return 0x82244DB0;
		  /* 82244DB0h */ case    4:  		/* mr R31, R3 */
		/* 82244DB0h case    4:*/		regs.R31 = regs.R3;
		/* 82244DB0h case    4:*/		return 0x82244DB4;
		  /* 82244DB4h */ case    5:  		/* li R11, 1 */
		/* 82244DB4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82244DB4h case    5:*/		return 0x82244DB8;
		  /* 82244DB8h */ case    6:  		/* mr R3, R4 */
		/* 82244DB8h case    6:*/		regs.R3 = regs.R4;
		/* 82244DB8h case    6:*/		return 0x82244DBC;
		  /* 82244DBCh */ case    7:  		/* li R10, 0 */
		/* 82244DBCh case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82244DBCh case    7:*/		return 0x82244DC0;
		  /* 82244DC0h */ case    8:  		/* stw R5, <#[R31 + 12]> */
		/* 82244DC0h case    8:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82244DC0h case    8:*/		return 0x82244DC4;
		  /* 82244DC4h */ case    9:  		/* stw R6, <#[R31 + 16]> */
		/* 82244DC4h case    9:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 82244DC4h case    9:*/		return 0x82244DC8;
		  /* 82244DC8h */ case   10:  		/* stw R4, <#[R31 + 20]> */
		/* 82244DC8h case   10:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 82244DC8h case   10:*/		return 0x82244DCC;
		  /* 82244DCCh */ case   11:  		/* stw R11, <#[R31]> */
		/* 82244DCCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82244DCCh case   11:*/		return 0x82244DD0;
		  /* 82244DD0h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 82244DD0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82244DD0h case   12:*/		return 0x82244DD4;
		  /* 82244DD4h */ case   13:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 82244DD4h case   13:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 82244DD4h case   13:*/		return 0x82244DD8;
		  /* 82244DD8h */ case   14:  		/* stw R11, <#[R31]> */
		/* 82244DD8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82244DD8h case   14:*/		return 0x82244DDC;
		  /* 82244DDCh */ case   15:  		/* cmplw CR6, R11, R7 */
		/* 82244DDCh case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 82244DDCh case   15:*/		return 0x82244DE0;
		  /* 82244DE0h */ case   16:  		/* bc 4, CR6_LT, 16 */
		/* 82244DE0h case   16:*/		if ( !regs.CR[6].lt ) { return 0x82244DF0;  }
		/* 82244DE0h case   16:*/		return 0x82244DE4;
		  /* 82244DE4h */ case   17:  		/* addi R10, R10, 1 */
		/* 82244DE4h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82244DE4h case   17:*/		return 0x82244DE8;
		  /* 82244DE8h */ case   18:  		/* cmpwi CR6, R10, 32 */
		/* 82244DE8h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000020);
		/* 82244DE8h case   18:*/		return 0x82244DEC;
		  /* 82244DECh */ case   19:  		/* bc 12, CR6_LT, -28 */
		/* 82244DECh case   19:*/		if ( regs.CR[6].lt ) { return 0x82244DD0;  }
		/* 82244DECh case   19:*/		return 0x82244DF0;
	}
	return 0x82244DF0;
} // Block from 82244DA0h-82244DF0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82244DF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244DF0);
		  /* 82244DF0h */ case    0:  		/* li R10, 0 */
		/* 82244DF0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82244DF0h case    0:*/		return 0x82244DF4;
		  /* 82244DF4h */ case    1:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 82244DF4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 82244DF4h case    1:*/		return 0x82244DF8;
		  /* 82244DF8h */ case    2:  		/* stw R10, <#[R31 + 4]> */
		/* 82244DF8h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82244DF8h case    2:*/		return 0x82244DFC;
		  /* 82244DFCh */ case    3:  		/* bl -166212 */
		/* 82244DFCh case    3:*/		regs.LR = 0x82244E00; return 0x8221C4B8;
		/* 82244DFCh case    3:*/		return 0x82244E00;
		  /* 82244E00h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 82244E00h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82244E00h case    4:*/		return 0x82244E04;
		  /* 82244E04h */ case    5:  		/* li R4, 0 */
		/* 82244E04h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82244E04h case    5:*/		return 0x82244E08;
		  /* 82244E08h */ case    6:  		/* stw R3, <#[R31 + 8]> */
		/* 82244E08h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 82244E08h case    6:*/		return 0x82244E0C;
		  /* 82244E0Ch */ case    7:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82244E0Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82244E0Ch case    7:*/		return 0x82244E10;
		  /* 82244E10h */ case    8:  		/* bl -1784528 */
		/* 82244E10h case    8:*/		regs.LR = 0x82244E14; return 0x82091340;
		/* 82244E10h case    8:*/		return 0x82244E14;
		  /* 82244E14h */ case    9:  		/* mr R3, R31 */
		/* 82244E14h case    9:*/		regs.R3 = regs.R31;
		/* 82244E14h case    9:*/		return 0x82244E18;
		  /* 82244E18h */ case   10:  		/* addi R1, R1, 96 */
		/* 82244E18h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82244E18h case   10:*/		return 0x82244E1C;
		  /* 82244E1Ch */ case   11:  		/* lwz R12, <#[R1 - 8]> */
		/* 82244E1Ch case   11:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82244E1Ch case   11:*/		return 0x82244E20;
		  /* 82244E20h */ case   12:  		/* mtspr LR, R12 */
		/* 82244E20h case   12:*/		regs.LR = regs.R12;
		/* 82244E20h case   12:*/		return 0x82244E24;
		  /* 82244E24h */ case   13:  		/* ld R31, <#[R1 - 16]> */
		/* 82244E24h case   13:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82244E24h case   13:*/		return 0x82244E28;
		  /* 82244E28h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82244E28h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244E28h case   14:*/		return 0x82244E2C;
	}
	return 0x82244E2C;
} // Block from 82244DF0h-82244E2Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82244E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244E2C);
		  /* 82244E2Ch */ case    0:  		/* nop */
		/* 82244E2Ch case    0:*/		cpu::op::nop();
		/* 82244E2Ch case    0:*/		return 0x82244E30;
		  /* 82244E30h */ case    1:  		/* lwz R11, <#[R3 + 32]> */
		/* 82244E30h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82244E30h case    1:*/		return 0x82244E34;
		  /* 82244E34h */ case    2:  		/* lwz R10, <#[R3 + 12]> */
		/* 82244E34h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82244E34h case    2:*/		return 0x82244E38;
		  /* 82244E38h */ case    3:  		/* add R3, R11, R10 */
		/* 82244E38h case    3:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82244E38h case    3:*/		return 0x82244E3C;
		  /* 82244E3Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 82244E3Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244E3Ch case    4:*/		return 0x82244E40;
	}
	return 0x82244E40;
} // Block from 82244E2Ch-82244E40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82244E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244E40);
		  /* 82244E40h */ case    0:  		/* lwz R11, <#[R3 + 32]> */
		/* 82244E40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82244E40h case    0:*/		return 0x82244E44;
		  /* 82244E44h */ case    1:  		/* lwz R10, <#[R4 + 32]> */
		/* 82244E44h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000020) );
		/* 82244E44h case    1:*/		return 0x82244E48;
		  /* 82244E48h */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 82244E48h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82244E48h case    2:*/		return 0x82244E4C;
		  /* 82244E4Ch */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82244E4Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82244E64;  }
		/* 82244E4Ch case    3:*/		return 0x82244E50;
		  /* 82244E50h */ case    4:  		/* lwz R11, <#[R3 + 12]> */
		/* 82244E50h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82244E50h case    4:*/		return 0x82244E54;
		  /* 82244E54h */ case    5:  		/* li R3, 0 */
		/* 82244E54h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82244E54h case    5:*/		return 0x82244E58;
		  /* 82244E58h */ case    6:  		/* lwz R10, <#[R4 + 12]> */
		/* 82244E58h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000000C) );
		/* 82244E58h case    6:*/		return 0x82244E5C;
		  /* 82244E5Ch */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 82244E5Ch case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82244E5Ch case    7:*/		return 0x82244E60;
		  /* 82244E60h */ case    8:  		/* bclr 12, CR6_EQ */
		/* 82244E60h case    8:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82244E60h case    8:*/		return 0x82244E64;
	}
	return 0x82244E64;
} // Block from 82244E40h-82244E64h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82244E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244E64);
		  /* 82244E64h */ case    0:  		/* li R3, -1 */
		/* 82244E64h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82244E64h case    0:*/		return 0x82244E68;
		  /* 82244E68h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82244E68h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244E68h case    1:*/		return 0x82244E6C;
	}
	return 0x82244E6C;
} // Block from 82244E64h-82244E6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82244E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244E6C);
		  /* 82244E6Ch */ case    0:  		/* nop */
		/* 82244E6Ch case    0:*/		cpu::op::nop();
		/* 82244E6Ch case    0:*/		return 0x82244E70;
		  /* 82244E70h */ case    1:  		/* lbz R11, <#[R3 + 32]> */
		/* 82244E70h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82244E70h case    1:*/		return 0x82244E74;
		  /* 82244E74h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82244E74h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82244E74h case    2:*/		return 0x82244E78;
		  /* 82244E78h */ case    3:  		/* lwz R11, <#[R3 + 40]> */
		/* 82244E78h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82244E78h case    3:*/		return 0x82244E7C;
		  /* 82244E7Ch */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 82244E7Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82244E88;  }
		/* 82244E7Ch case    4:*/		return 0x82244E80;
		  /* 82244E80h */ case    5:  		/* addi R11, R11, 1 */
		/* 82244E80h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82244E80h case    5:*/		return 0x82244E84;
		  /* 82244E84h */ case    6:  		/* b 8 */
		/* 82244E84h case    6:*/		return 0x82244E8C;
		/* 82244E84h case    6:*/		return 0x82244E88;
	}
	return 0x82244E88;
} // Block from 82244E6Ch-82244E88h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82244E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244E88);
		  /* 82244E88h */ case    0:  		/* addi R11, R11, -1 */
		/* 82244E88h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82244E88h case    0:*/		return 0x82244E8C;
	}
	return 0x82244E8C;
} // Block from 82244E88h-82244E8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82244E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244E8C);
		  /* 82244E8Ch */ case    0:  		/* lwz R10, <#[R3]> */
		/* 82244E8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82244E8Ch case    0:*/		return 0x82244E90;
		  /* 82244E90h */ case    1:  		/* stw R11, <#[R3 + 40]> */
		/* 82244E90h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82244E90h case    1:*/		return 0x82244E94;
		  /* 82244E94h */ case    2:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 82244E94h case    2:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 82244E94h case    2:*/		return 0x82244E98;
		  /* 82244E98h */ case    3:  		/* lwz R11, <#[R10 + 1360]> */
		/* 82244E98h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000550) );
		/* 82244E98h case    3:*/		return 0x82244E9C;
		  /* 82244E9Ch */ case    4:  		/* lwz R9, <#[R11 + 44]> */
		/* 82244E9Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000002C) );
		/* 82244E9Ch case    4:*/		return 0x82244EA0;
		  /* 82244EA0h */ case    5:  		/* cmpw CR6, R3, R9 */
		/* 82244EA0h case    5:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R9);
		/* 82244EA0h case    5:*/		return 0x82244EA4;
		  /* 82244EA4h */ case    6:  		/* bc 12, CR6_LT, 16 */
		/* 82244EA4h case    6:*/		if ( regs.CR[6].lt ) { return 0x82244EB4;  }
		/* 82244EA4h case    6:*/		return 0x82244EA8;
		  /* 82244EA8h */ case    7:  		/* lwz R11, <#[R11 + 48]> */
		/* 82244EA8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82244EA8h case    7:*/		return 0x82244EAC;
		  /* 82244EACh */ case    8:  		/* cmpw CR6, R3, R11 */
		/* 82244EACh case    8:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R11);
		/* 82244EACh case    8:*/		return 0x82244EB0;
		  /* 82244EB0h */ case    9:  		/* bclr 4, CR6_GT */
		/* 82244EB0h case    9:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82244EB0h case    9:*/		return 0x82244EB4;
	}
	return 0x82244EB4;
} // Block from 82244E8Ch-82244EB4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82244EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244EB4);
		  /* 82244EB4h */ case    0:  		/* li R11, 31 */
		/* 82244EB4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1F);
		/* 82244EB4h case    0:*/		return 0x82244EB8;
		  /* 82244EB8h */ case    1:  		/* li R4, 1 */
		/* 82244EB8h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82244EB8h case    1:*/		return 0x82244EBC;
		  /* 82244EBCh */ case    2:  		/* stw R11, <#[R10 + 1364]> */
		/* 82244EBCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000554) );
		/* 82244EBCh case    2:*/		return 0x82244EC0;
		  /* 82244EC0h */ case    3:  		/* addi R3, R10, 16 */
		/* 82244EC0h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0x10);
		/* 82244EC0h case    3:*/		return 0x82244EC4;
		  /* 82244EC4h */ case    4:  		/* b 147436 */
		/* 82244EC4h case    4:*/		return 0x82268EB0;
		/* 82244EC4h case    4:*/		return 0x82244EC8;
		  /* 82244EC8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82244EC8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244EC8h case    5:*/		return 0x82244ECC;
	}
	return 0x82244ECC;
} // Block from 82244EB4h-82244ECCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82244ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244ECC);
		  /* 82244ECCh */ case    0:  		/* nop */
		/* 82244ECCh case    0:*/		cpu::op::nop();
		/* 82244ECCh case    0:*/		return 0x82244ED0;
	}
	return 0x82244ED0;
} // Block from 82244ECCh-82244ED0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82244ED0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244ED0);
		  /* 82244ED0h */ case    0:  		/* addi R11, R5, 14 */
		/* 82244ED0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xE);
		/* 82244ED0h case    0:*/		return 0x82244ED4;
		  /* 82244ED4h */ case    1:  		/* lwz R10, <#[R3 + 24]> */
		/* 82244ED4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 82244ED4h case    1:*/		return 0x82244ED8;
		  /* 82244ED8h */ case    2:  		/* addi R9, R5, 20 */
		/* 82244ED8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R5,0x14);
		/* 82244ED8h case    2:*/		return 0x82244EDC;
		  /* 82244EDCh */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82244EDCh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82244EDCh case    3:*/		return 0x82244EE0;
		  /* 82244EE0h */ case    4:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82244EE0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82244EE0h case    4:*/		return 0x82244EE4;
		  /* 82244EE4h */ case    5:  		/* lwzx R11, <#[R11 + R4]> */
		/* 82244EE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 82244EE4h case    5:*/		return 0x82244EE8;
		  /* 82244EE8h */ case    6:  		/* stw R11, <#[R10 + 12]> */
		/* 82244EE8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 82244EE8h case    6:*/		return 0x82244EEC;
		  /* 82244EECh */ case    7:  		/* lwz R11, <#[R3 + 24]> */
		/* 82244EECh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82244EECh case    7:*/		return 0x82244EF0;
		  /* 82244EF0h */ case    8:  		/* lwzx R10, <#[R9 + R4]> */
		/* 82244EF0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R4 + 0x00000000) );
		/* 82244EF0h case    8:*/		return 0x82244EF4;
		  /* 82244EF4h */ case    9:  		/* stw R10, <#[R11 + 32]> */
		/* 82244EF4h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 82244EF4h case    9:*/		return 0x82244EF8;
		  /* 82244EF8h */ case   10:  		/* lwz R4, <#[R3 + 24]> */
		/* 82244EF8h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000018) );
		/* 82244EF8h case   10:*/		return 0x82244EFC;
		  /* 82244EFCh */ case   11:  		/* lwz R3, <#[R3 + 4]> */
		/* 82244EFCh case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 82244EFCh case   11:*/		return 0x82244F00;
		  /* 82244F00h */ case   12:  		/* b 61048 */
		/* 82244F00h case   12:*/		return 0x82253D78;
		/* 82244F00h case   12:*/		return 0x82244F04;
		  /* 82244F04h */ case   13:  		/* nop */
		/* 82244F04h case   13:*/		cpu::op::nop();
		/* 82244F04h case   13:*/		return 0x82244F08;
	}
	return 0x82244F08;
} // Block from 82244ED0h-82244F08h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82244F08h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244F08);
		  /* 82244F08h */ case    0:  		/* lwz R11, <#[R3 + 24]> */
		/* 82244F08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82244F08h case    0:*/		return 0x82244F0C;
		  /* 82244F0Ch */ case    1:  		/* stw R5, <#[R11 + 12]> */
		/* 82244F0Ch case    1:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 82244F0Ch case    1:*/		return 0x82244F10;
		  /* 82244F10h */ case    2:  		/* lwz R11, <#[R3 + 24]> */
		/* 82244F10h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82244F10h case    2:*/		return 0x82244F14;
		  /* 82244F14h */ case    3:  		/* stw R4, <#[R11 + 32]> */
		/* 82244F14h case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000020) );
		/* 82244F14h case    3:*/		return 0x82244F18;
		  /* 82244F18h */ case    4:  		/* lwz R4, <#[R3 + 24]> */
		/* 82244F18h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000018) );
		/* 82244F18h case    4:*/		return 0x82244F1C;
		  /* 82244F1Ch */ case    5:  		/* lwz R3, <#[R3 + 4]> */
		/* 82244F1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 82244F1Ch case    5:*/		return 0x82244F20;
		  /* 82244F20h */ case    6:  		/* b 61016 */
		/* 82244F20h case    6:*/		return 0x82253D78;
		/* 82244F20h case    6:*/		return 0x82244F24;
		  /* 82244F24h */ case    7:  		/* nop */
		/* 82244F24h case    7:*/		cpu::op::nop();
		/* 82244F24h case    7:*/		return 0x82244F28;
	}
	return 0x82244F28;
} // Block from 82244F08h-82244F28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82244F28h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244F28);
		  /* 82244F28h */ case    0:  		/* mfspr R12, LR */
		/* 82244F28h case    0:*/		regs.R12 = regs.LR;
		/* 82244F28h case    0:*/		return 0x82244F2C;
		  /* 82244F2Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82244F2Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82244F2Ch case    1:*/		return 0x82244F30;
		  /* 82244F30h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82244F30h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82244F30h case    2:*/		return 0x82244F34;
		  /* 82244F34h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82244F34h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82244F34h case    3:*/		return 0x82244F38;
		  /* 82244F38h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82244F38h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82244F38h case    4:*/		return 0x82244F3C;
		  /* 82244F3Ch */ case    5:  		/* mr R31, R3 */
		/* 82244F3Ch case    5:*/		regs.R31 = regs.R3;
		/* 82244F3Ch case    5:*/		return 0x82244F40;
		  /* 82244F40h */ case    6:  		/* mr R3, R5 */
		/* 82244F40h case    6:*/		regs.R3 = regs.R5;
		/* 82244F40h case    6:*/		return 0x82244F44;
		  /* 82244F44h */ case    7:  		/* lwz R5, <#[R31]> */
		/* 82244F44h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000000) );
		/* 82244F44h case    7:*/		return 0x82244F48;
		  /* 82244F48h */ case    8:  		/* bl 61912 */
		/* 82244F48h case    8:*/		regs.LR = 0x82244F4C; return 0x82254120;
		/* 82244F48h case    8:*/		return 0x82244F4C;
		  /* 82244F4Ch */ case    9:  		/* mr R30, R3 */
		/* 82244F4Ch case    9:*/		regs.R30 = regs.R3;
		/* 82244F4Ch case    9:*/		return 0x82244F50;
		  /* 82244F50h */ case   10:  		/* lwz R3, <#[R31 + 4]> */
		/* 82244F50h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 82244F50h case   10:*/		return 0x82244F54;
		  /* 82244F54h */ case   11:  		/* mr R4, R30 */
		/* 82244F54h case   11:*/		regs.R4 = regs.R30;
		/* 82244F54h case   11:*/		return 0x82244F58;
		  /* 82244F58h */ case   12:  		/* bl 61152 */
		/* 82244F58h case   12:*/		regs.LR = 0x82244F5C; return 0x82253E38;
		/* 82244F58h case   12:*/		return 0x82244F5C;
		  /* 82244F5Ch */ case   13:  		/* mr R3, R30 */
		/* 82244F5Ch case   13:*/		regs.R3 = regs.R30;
		/* 82244F5Ch case   13:*/		return 0x82244F60;
	}
	return 0x82244F60;
} // Block from 82244F28h-82244F60h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82244F60h
// Function '?Assemble@IRVertexFetch@XGRAPHICS@@UAAXPAVAssembler@2@PADPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244F60);
		  /* 82244F60h */ case    0:  		/* addi R1, R1, 112 */
		/* 82244F60h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82244F60h case    0:*/		return 0x82244F64;
		  /* 82244F64h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82244F64h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82244F64h case    1:*/		return 0x82244F68;
		  /* 82244F68h */ case    2:  		/* mtspr LR, R12 */
		/* 82244F68h case    2:*/		regs.LR = regs.R12;
		/* 82244F68h case    2:*/		return 0x82244F6C;
		  /* 82244F6Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82244F6Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82244F6Ch case    3:*/		return 0x82244F70;
		  /* 82244F70h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82244F70h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82244F70h case    4:*/		return 0x82244F74;
		  /* 82244F74h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82244F74h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82244F74h case    5:*/		return 0x82244F78;
	}
	return 0x82244F78;
} // Block from 82244F60h-82244F78h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82244F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244F78);
		  /* 82244F78h */ case    0:  		/* mfspr R12, LR */
		/* 82244F78h case    0:*/		regs.R12 = regs.LR;
		/* 82244F78h case    0:*/		return 0x82244F7C;
		  /* 82244F7Ch */ case    1:  		/* bl -1785128 */
		/* 82244F7Ch case    1:*/		regs.LR = 0x82244F80; return 0x82091254;
		/* 82244F7Ch case    1:*/		return 0x82244F80;
		  /* 82244F80h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82244F80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82244F80h case    2:*/		return 0x82244F84;
		  /* 82244F84h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82244F84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82244F84h case    3:*/		return 0x82244F88;
		  /* 82244F88h */ case    4:  		/* mr R31, R3 */
		/* 82244F88h case    4:*/		regs.R31 = regs.R3;
		/* 82244F88h case    4:*/		return 0x82244F8C;
		  /* 82244F8Ch */ case    5:  		/* mr R30, R4 */
		/* 82244F8Ch case    5:*/		regs.R30 = regs.R4;
		/* 82244F8Ch case    5:*/		return 0x82244F90;
		  /* 82244F90h */ case    6:  		/* li R4, 68 */
		/* 82244F90h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x44);
		/* 82244F90h case    6:*/		return 0x82244F94;
		  /* 82244F94h */ case    7:  		/* mr R29, R5 */
		/* 82244F94h case    7:*/		regs.R29 = regs.R5;
		/* 82244F94h case    7:*/		return 0x82244F98;
		  /* 82244F98h */ case    8:  		/* mr R28, R6 */
		/* 82244F98h case    8:*/		regs.R28 = regs.R6;
		/* 82244F98h case    8:*/		return 0x82244F9C;
		  /* 82244F9Ch */ case    9:  		/* lwz R27, <#[R11 + 1452]> */
		/* 82244F9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005AC) );
		/* 82244F9Ch case    9:*/		return 0x82244FA0;
		  /* 82244FA0h */ case   10:  		/* mr R3, R27 */
		/* 82244FA0h case   10:*/		regs.R3 = regs.R27;
		/* 82244FA0h case   10:*/		return 0x82244FA4;
		  /* 82244FA4h */ case   11:  		/* bl -166636 */
		/* 82244FA4h case   11:*/		regs.LR = 0x82244FA8; return 0x8221C4B8;
		/* 82244FA4h case   11:*/		return 0x82244FA8;
		  /* 82244FA8h */ case   12:  		/* mr R11, R3 */
		/* 82244FA8h case   12:*/		regs.R11 = regs.R3;
		/* 82244FA8h case   12:*/		return 0x82244FAC;
		  /* 82244FACh */ case   13:  		/* addic. R3, R3, 4 */
		/* 82244FACh case   13:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82244FACh case   13:*/		return 0x82244FB0;
		  /* 82244FB0h */ case   14:  		/* stw R27, <#[R11]> */
		/* 82244FB0h case   14:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 82244FB0h case   14:*/		return 0x82244FB4;
		  /* 82244FB4h */ case   15:  		/* bc 12, CR0_EQ, 32 */
		/* 82244FB4h case   15:*/		if ( regs.CR[0].eq ) { return 0x82244FD4;  }
		/* 82244FB4h case   15:*/		return 0x82244FB8;
		  /* 82244FB8h */ case   16:  		/* mr R6, R28 */
		/* 82244FB8h case   16:*/		regs.R6 = regs.R28;
		/* 82244FB8h case   16:*/		return 0x82244FBC;
		  /* 82244FBCh */ case   17:  		/* lwz R7, <#[R31]> */
		/* 82244FBCh case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 82244FBCh case   17:*/		return 0x82244FC0;
		  /* 82244FC0h */ case   18:  		/* mr R5, R30 */
		/* 82244FC0h case   18:*/		regs.R5 = regs.R30;
		/* 82244FC0h case   18:*/		return 0x82244FC4;
		  /* 82244FC4h */ case   19:  		/* mr R4, R29 */
		/* 82244FC4h case   19:*/		regs.R4 = regs.R29;
		/* 82244FC4h case   19:*/		return 0x82244FC8;
		  /* 82244FC8h */ case   20:  		/* bl 65464 */
		/* 82244FC8h case   20:*/		regs.LR = 0x82244FCC; return 0x82254F80;
		/* 82244FC8h case   20:*/		return 0x82244FCC;
		  /* 82244FCCh */ case   21:  		/* mr R30, R3 */
		/* 82244FCCh case   21:*/		regs.R30 = regs.R3;
		/* 82244FCCh case   21:*/		return 0x82244FD0;
		  /* 82244FD0h */ case   22:  		/* b 8 */
		/* 82244FD0h case   22:*/		return 0x82244FD8;
		/* 82244FD0h case   22:*/		return 0x82244FD4;
	}
	return 0x82244FD4;
} // Block from 82244F78h-82244FD4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82244FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244FD4);
		  /* 82244FD4h */ case    0:  		/* li R30, 0 */
		/* 82244FD4h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82244FD4h case    0:*/		return 0x82244FD8;
	}
	return 0x82244FD8;
} // Block from 82244FD4h-82244FD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82244FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244FD8);
		  /* 82244FD8h */ case    0:  		/* mr R4, R30 */
		/* 82244FD8h case    0:*/		regs.R4 = regs.R30;
		/* 82244FD8h case    0:*/		return 0x82244FDC;
		  /* 82244FDCh */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 82244FDCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 82244FDCh case    1:*/		return 0x82244FE0;
		  /* 82244FE0h */ case    2:  		/* bl 61016 */
		/* 82244FE0h case    2:*/		regs.LR = 0x82244FE4; return 0x82253E38;
		/* 82244FE0h case    2:*/		return 0x82244FE4;
		  /* 82244FE4h */ case    3:  		/* mr R3, R30 */
		/* 82244FE4h case    3:*/		regs.R3 = regs.R30;
		/* 82244FE4h case    3:*/		return 0x82244FE8;
		  /* 82244FE8h */ case    4:  		/* addi R1, R1, 128 */
		/* 82244FE8h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82244FE8h case    4:*/		return 0x82244FEC;
		  /* 82244FECh */ case    5:  		/* b -1785160 */
		/* 82244FECh case    5:*/		return 0x820912A4;
		/* 82244FECh case    5:*/		return 0x82244FF0;
	}
	return 0x82244FF0;
} // Block from 82244FD8h-82244FF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82244FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82244FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82244FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82244FF0);
		  /* 82244FF0h */ case    0:  		/* mfspr R12, LR */
		/* 82244FF0h case    0:*/		regs.R12 = regs.LR;
		/* 82244FF0h case    0:*/		return 0x82244FF4;
		  /* 82244FF4h */ case    1:  		/* bl -1785276 */
		/* 82244FF4h case    1:*/		regs.LR = 0x82244FF8; return 0x82091238;
		/* 82244FF4h case    1:*/		return 0x82244FF8;
		  /* 82244FF8h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 82244FF8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 82244FF8h case    2:*/		return 0x82244FFC;
		  /* 82244FFCh */ case    3:  		/* lwz R9, <#[R3]> */
		/* 82244FFCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82244FFCh case    3:*/		return 0x82245000;
		  /* 82245000h */ case    4:  		/* lis R11, -32253 */
		/* 82245000h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82245000h case    4:*/		return 0x82245004;
		  /* 82245004h */ case    5:  		/* std R5, <#[R1 + 272]> */
		/* 82245004h case    5:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000110) );
		/* 82245004h case    5:*/		return 0x82245008;
		  /* 82245008h */ case    6:  		/* lis R10, -32252 */
		/* 82245008h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82245008h case    6:*/		return 0x8224500C;
		  /* 8224500Ch */ case    7:  		/* addi R24, R11, 27460 */
		/* 8224500Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x6B44);
		/* 8224500Ch case    7:*/		return 0x82245010;
		  /* 82245010h */ case    8:  		/* std R6, <#[R1 + 280]> */
		/* 82245010h case    8:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000118) );
		/* 82245010h case    8:*/		return 0x82245014;
		  /* 82245014h */ case    9:  		/* std R7, <#[R1 + 288]> */
		/* 82245014h case    9:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000120) );
		/* 82245014h case    9:*/		return 0x82245018;
		  /* 82245018h */ case   10:  		/* mr R31, R3 */
		/* 82245018h case   10:*/		regs.R31 = regs.R3;
		/* 82245018h case   10:*/		return 0x8224501C;
		  /* 8224501Ch */ case   11:  		/* mr R25, R4 */
		/* 8224501Ch case   11:*/		regs.R25 = regs.R4;
		/* 8224501Ch case   11:*/		return 0x82245020;
		  /* 82245020h */ case   12:  		/* std R8, <#[R1 + 296]> */
		/* 82245020h case   12:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000128) );
		/* 82245020h case   12:*/		return 0x82245024;
		  /* 82245024h */ case   13:  		/* lbz R11, <#[R9 + 1393]> */
		/* 82245024h case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000571) );
		/* 82245024h case   13:*/		return 0x82245028;
		  /* 82245028h */ case   14:  		/* addi R23, R10, 12584 */
		/* 82245028h case   14:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0x3128);
		/* 82245028h case   14:*/		return 0x8224502C;
		  /* 8224502Ch */ case   15:  		/* cmplwi CR0, R11, 0 */
		/* 8224502Ch case   15:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224502Ch case   15:*/		return 0x82245030;
		  /* 82245030h */ case   16:  		/* bc 4, CR0_EQ, 32 */
		/* 82245030h case   16:*/		if ( !regs.CR[0].eq ) { return 0x82245050;  }
		/* 82245030h case   16:*/		return 0x82245034;
		  /* 82245034h */ case   17:  		/* lis R11, -32252 */
		/* 82245034h case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82245034h case   17:*/		return 0x82245038;
		  /* 82245038h */ case   18:  		/* mr R6, R23 */
		/* 82245038h case   18:*/		regs.R6 = regs.R23;
		/* 82245038h case   18:*/		return 0x8224503C;
		  /* 8224503Ch */ case   19:  		/* addi R5, R11, 12560 */
		/* 8224503Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3110);
		/* 8224503Ch case   19:*/		return 0x82245040;
		  /* 82245040h */ case   20:  		/* mr R4, R24 */
		/* 82245040h case   20:*/		regs.R4 = regs.R24;
		/* 82245040h case   20:*/		return 0x82245044;
		  /* 82245044h */ case   21:  		/* li R7, 422 */
		/* 82245044h case   21:*/		cpu::op::li<0>(regs,&regs.R7,0x1A6);
		/* 82245044h case   21:*/		return 0x82245048;
		  /* 82245048h */ case   22:  		/* li R3, 0 */
		/* 82245048h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82245048h case   22:*/		return 0x8224504C;
		  /* 8224504Ch */ case   23:  		/* bl -971844 */
		/* 8224504Ch case   23:*/		regs.LR = 0x82245050; return 0x82157C08;
		/* 8224504Ch case   23:*/		return 0x82245050;
	}
	return 0x82245050;
} // Block from 82244FF0h-82245050h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82245050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245050);
		  /* 82245050h */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 82245050h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82245050h case    0:*/		return 0x82245054;
		  /* 82245054h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82245054h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82245060;  }
		/* 82245054h case    1:*/		return 0x82245058;
		  /* 82245058h */ case    2:  		/* cmpwi CR6, R25, 5 */
		/* 82245058h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000005);
		/* 82245058h case    2:*/		return 0x8224505C;
		  /* 8224505Ch */ case    3:  		/* bc 12, CR6_LT, 32 */
		/* 8224505Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8224507C;  }
		/* 8224505Ch case    3:*/		return 0x82245060;
	}
	return 0x82245060;
} // Block from 82245050h-82245060h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82245060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245060);
		  /* 82245060h */ case    0:  		/* lis R11, -32252 */
		/* 82245060h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82245060h case    0:*/		return 0x82245064;
		  /* 82245064h */ case    1:  		/* mr R6, R23 */
		/* 82245064h case    1:*/		regs.R6 = regs.R23;
		/* 82245064h case    1:*/		return 0x82245068;
		  /* 82245068h */ case    2:  		/* addi R5, R11, 12516 */
		/* 82245068h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x30E4);
		/* 82245068h case    2:*/		return 0x8224506C;
		  /* 8224506Ch */ case    3:  		/* mr R4, R24 */
		/* 8224506Ch case    3:*/		regs.R4 = regs.R24;
		/* 8224506Ch case    3:*/		return 0x82245070;
		  /* 82245070h */ case    4:  		/* li R7, 423 */
		/* 82245070h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1A7);
		/* 82245070h case    4:*/		return 0x82245074;
		  /* 82245074h */ case    5:  		/* li R3, 0 */
		/* 82245074h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82245074h case    5:*/		return 0x82245078;
		  /* 82245078h */ case    6:  		/* bl -971888 */
		/* 82245078h case    6:*/		regs.LR = 0x8224507C; return 0x82157C08;
		/* 82245078h case    6:*/		return 0x8224507C;
	}
	return 0x8224507C;
} // Block from 82245060h-8224507Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224507Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224507C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224507C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224507C);
		  /* 8224507Ch */ case    0:  		/* lwz R22, <#[R1 + 296]> */
		/* 8224507Ch case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000128) );
		/* 8224507Ch case    0:*/		return 0x82245080;
		  /* 82245080h */ case    1:  		/* li R11, 4 */
		/* 82245080h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82245080h case    1:*/		return 0x82245084;
		  /* 82245084h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82245084h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82245084h case    2:*/		return 0x82245088;
		  /* 82245088h */ case    3:  		/* li R21, 0 */
		/* 82245088h case    3:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 82245088h case    3:*/		return 0x8224508C;
		  /* 8224508Ch */ case    4:  		/* lwz R8, <#[R31 + 12]> */
		/* 8224508Ch case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224508Ch case    4:*/		return 0x82245090;
		  /* 82245090h */ case    5:  		/* addi R7, R1, 96 */
		/* 82245090h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82245090h case    5:*/		return 0x82245094;
		  /* 82245094h */ case    6:  		/* lwz R5, <#[R31 + 16]> */
		/* 82245094h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 82245094h case    6:*/		return 0x82245098;
		  /* 82245098h */ case    7:  		/* mr R6, R21 */
		/* 82245098h case    7:*/		regs.R6 = regs.R21;
		/* 82245098h case    7:*/		return 0x8224509C;
		  /* 8224509Ch */ case    8:  		/* lwz R4, <#[R1 + 272]> */
		/* 8224509Ch case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000110) );
		/* 8224509Ch case    8:*/		return 0x822450A0;
		  /* 822450A0h */ case    9:  		/* li R9, 928 */
		/* 822450A0h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x3A0);
		/* 822450A0h case    9:*/		return 0x822450A4;
		  /* 822450A4h */ case   10:  		/* lwz R3, <#[R31 + 20]> */
		/* 822450A4h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 822450A4h case   10:*/		return 0x822450A8;
		  /* 822450A8h */ case   11:  		/* mtspr CTR, R11 */
		/* 822450A8h case   11:*/		regs.CTR = regs.R11;
		/* 822450A8h case   11:*/		return 0x822450AC;
		  /* 822450ACh */ case   12:  		/* lwz R30, <#[R1 + 276]> */
		/* 822450ACh case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000114) );
		/* 822450ACh case   12:*/		return 0x822450B0;
		  /* 822450B0h */ case   13:  		/* addi R11, R1, 96 */
		/* 822450B0h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 822450B0h case   13:*/		return 0x822450B4;
		  /* 822450B4h */ case   14:  		/* lwz R29, <#[R1 + 280]> */
		/* 822450B4h case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000118) );
		/* 822450B4h case   14:*/		return 0x822450B8;
		  /* 822450B8h */ case   15:  		/* subfic R7, R7, 896 */
		/* 822450B8h case   15:*/		cpu::op::subfic<0>(regs,&regs.R7,regs.R7,0x380);
		/* 822450B8h case   15:*/		return 0x822450BC;
		  /* 822450BCh */ case   16:  		/* lwz R28, <#[R1 + 284]> */
		/* 822450BCh case   16:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000011C) );
		/* 822450BCh case   16:*/		return 0x822450C0;
		  /* 822450C0h */ case   17:  		/* lwz R27, <#[R1 + 288]> */
		/* 822450C0h case   17:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000120) );
		/* 822450C0h case   17:*/		return 0x822450C4;
		  /* 822450C4h */ case   18:  		/* lwz R26, <#[R1 + 292]> */
		/* 822450C4h case   18:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000124) );
		/* 822450C4h case   18:*/		return 0x822450C8;
		  /* 822450C8h */ case   19:  		/* lwz R20, <#[R1 + 300]> */
		/* 822450C8h case   19:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x0000012C) );
		/* 822450C8h case   19:*/		return 0x822450CC;
		  /* 822450CCh */ case   20:  		/* stw R22, <#[R1 + 120]> */
		/* 822450CCh case   20:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000078) );
		/* 822450CCh case   20:*/		return 0x822450D0;
		  /* 822450D0h */ case   21:  		/* li R22, 1 */
		/* 822450D0h case   21:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 822450D0h case   21:*/		return 0x822450D4;
		  /* 822450D4h */ case   22:  		/* stw R10, <#[R1 + 80]> */
		/* 822450D4h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 822450D4h case   22:*/		return 0x822450D8;
		  /* 822450D8h */ case   23:  		/* stw R8, <#[R1 + 84]> */
		/* 822450D8h case   23:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 822450D8h case   23:*/		return 0x822450DC;
		  /* 822450DCh */ case   24:  		/* stw R5, <#[R1 + 88]> */
		/* 822450DCh case   24:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 822450DCh case   24:*/		return 0x822450E0;
		  /* 822450E0h */ case   25:  		/* stw R4, <#[R1 + 96]> */
		/* 822450E0h case   25:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 822450E0h case   25:*/		return 0x822450E4;
		  /* 822450E4h */ case   26:  		/* stw R3, <#[R1 + 92]> */
		/* 822450E4h case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 822450E4h case   26:*/		return 0x822450E8;
		  /* 822450E8h */ case   27:  		/* stw R30, <#[R1 + 100]> */
		/* 822450E8h case   27:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 822450E8h case   27:*/		return 0x822450EC;
		  /* 822450ECh */ case   28:  		/* stw R29, <#[R1 + 104]> */
		/* 822450ECh case   28:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000068) );
		/* 822450ECh case   28:*/		return 0x822450F0;
		  /* 822450F0h */ case   29:  		/* stw R28, <#[R1 + 108]> */
		/* 822450F0h case   29:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x0000006C) );
		/* 822450F0h case   29:*/		return 0x822450F4;
		  /* 822450F4h */ case   30:  		/* stw R27, <#[R1 + 112]> */
		/* 822450F4h case   30:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000070) );
		/* 822450F4h case   30:*/		return 0x822450F8;
		  /* 822450F8h */ case   31:  		/* stw R26, <#[R1 + 116]> */
		/* 822450F8h case   31:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000074) );
		/* 822450F8h case   31:*/		return 0x822450FC;
		  /* 822450FCh */ case   32:  		/* stw R20, <#[R1 + 124]> */
		/* 822450FCh case   32:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x0000007C) );
		/* 822450FCh case   32:*/		return 0x82245100;
		  /* 82245100h */ case   33:  		/* lwz R10, <#[R31 + 28]> */
		/* 82245100h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 82245100h case   33:*/		return 0x82245104;
		  /* 82245104h */ case   34:  		/* cmpw CR6, R6, R25 */
		/* 82245104h case   34:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R25);
		/* 82245104h case   34:*/		return 0x82245108;
		  /* 82245108h */ case   35:  		/* bc 4, CR6_LT, 40 */
		/* 82245108h case   35:*/		if ( !regs.CR[6].lt ) { return 0x82245130;  }
		/* 82245108h case   35:*/		return 0x8224510C;
		  /* 8224510Ch */ case   36:  		/* add R8, R7, R11 */
		/* 8224510Ch case   36:*/		cpu::op::add<0>(regs,&regs.R8,regs.R7,regs.R11);
		/* 8224510Ch case   36:*/		return 0x82245110;
		  /* 82245110h */ case   37:  		/* stwx R22, <#[R9 + R10]> */
		/* 82245110h case   37:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82245110h case   37:*/		return 0x82245114;
		  /* 82245114h */ case   38:  		/* lwz R10, <#[R31 + 28]> */
		/* 82245114h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 82245114h case   38:*/		return 0x82245118;
		  /* 82245118h */ case   39:  		/* lwz R5, <#[R11]> */
		/* 82245118h case   39:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 82245118h case   39:*/		return 0x8224511C;
		  /* 8224511Ch */ case   40:  		/* add R10, R8, R10 */
		/* 8224511Ch case   40:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8224511Ch case   40:*/		return 0x82245120;
		  /* 82245120h */ case   41:  		/* lwz R4, <#[R11 + 4]> */
		/* 82245120h case   41:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 82245120h case   41:*/		return 0x82245124;
		  /* 82245124h */ case   42:  		/* stw R5, <#[R10]> */
		/* 82245124h case   42:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 82245124h case   42:*/		return 0x82245128;
		  /* 82245128h */ case   43:  		/* stw R4, <#[R10 + 4]> */
		/* 82245128h case   43:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 82245128h case   43:*/		return 0x8224512C;
		  /* 8224512Ch */ case   44:  		/* b 8 */
		/* 8224512Ch case   44:*/		return 0x82245134;
		/* 8224512Ch case   44:*/		return 0x82245130;
	}
	return 0x82245130;
} // Block from 8224507Ch-82245130h (45 instructions)

//////////////////////////////////////////////////////
// Block at 82245130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245130);
		  /* 82245130h */ case    0:  		/* stwx R21, <#[R9 + R10]> */
		/* 82245130h case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82245130h case    0:*/		return 0x82245134;
	}
	return 0x82245134;
} // Block from 82245130h-82245134h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245134);
		  /* 82245134h */ case    0:  		/* addi R6, R6, 1 */
		/* 82245134h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82245134h case    0:*/		return 0x82245138;
		  /* 82245138h */ case    1:  		/* addi R9, R9, 4 */
		/* 82245138h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82245138h case    1:*/		return 0x8224513C;
		  /* 8224513Ch */ case    2:  		/* addi R11, R11, 8 */
		/* 8224513Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8224513Ch case    2:*/		return 0x82245140;
		  /* 82245140h */ case    3:  		/* bc 16, CR0_LT, -64 */
		/* 82245140h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82245100;  }
		/* 82245140h case    3:*/		return 0x82245144;
		  /* 82245144h */ case    4:  		/* rlwinm R10, R25, 2, 0, 29 */
		/* 82245144h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R25);
		/* 82245144h case    4:*/		return 0x82245148;
		  /* 82245148h */ case    5:  		/* lwz R4, <#[R31 + 28]> */
		/* 82245148h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000001C) );
		/* 82245148h case    5:*/		return 0x8224514C;
		  /* 8224514Ch */ case    6:  		/* addi R11, R1, 80 */
		/* 8224514Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8224514Ch case    6:*/		return 0x82245150;
		  /* 82245150h */ case    7:  		/* add R11, R10, R11 */
		/* 82245150h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82245150h case    7:*/		return 0x82245154;
		  /* 82245154h */ case    8:  		/* lwz R26, <#[R11 - 4]> */
		/* 82245154h case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82245154h case    8:*/		return 0x82245158;
		  /* 82245158h */ case    9:  		/* mr R3, R26 */
		/* 82245158h case    9:*/		regs.R3 = regs.R26;
		/* 82245158h case    9:*/		return 0x8224515C;
		  /* 8224515Ch */ case   10:  		/* bl 60444 */
		/* 8224515Ch case   10:*/		regs.LR = 0x82245160; return 0x82253D78;
		/* 8224515Ch case   10:*/		return 0x82245160;
		  /* 82245160h */ case   11:  		/* or. R30, R3, R3 */
		/* 82245160h case   11:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82245160h case   11:*/		return 0x82245164;
		  /* 82245164h */ case   12:  		/* bc 4, CR0_EQ, 344 */
		/* 82245164h case   12:*/		if ( !regs.CR[0].eq ) { return 0x822452BC;  }
		/* 82245164h case   12:*/		return 0x82245168;
		  /* 82245168h */ case   13:  		/* lwz R11, <#[R31]> */
		/* 82245168h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245168h case   13:*/		return 0x8224516C;
		  /* 8224516Ch */ case   14:  		/* li R4, 964 */
		/* 8224516Ch case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 8224516Ch case   14:*/		return 0x82245170;
		  /* 82245170h */ case   15:  		/* lwz R30, <#[R11 + 1452]> */
		/* 82245170h case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005AC) );
		/* 82245170h case   15:*/		return 0x82245174;
		  /* 82245174h */ case   16:  		/* mr R3, R30 */
		/* 82245174h case   16:*/		regs.R3 = regs.R30;
		/* 82245174h case   16:*/		return 0x82245178;
		  /* 82245178h */ case   17:  		/* bl -167104 */
		/* 82245178h case   17:*/		regs.LR = 0x8224517C; return 0x8221C4B8;
		/* 82245178h case   17:*/		return 0x8224517C;
		  /* 8224517Ch */ case   18:  		/* mr R11, R3 */
		/* 8224517Ch case   18:*/		regs.R11 = regs.R3;
		/* 8224517Ch case   18:*/		return 0x82245180;
		  /* 82245180h */ case   19:  		/* addic. R3, R3, 4 */
		/* 82245180h case   19:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82245180h case   19:*/		return 0x82245184;
		  /* 82245184h */ case   20:  		/* stw R30, <#[R11]> */
		/* 82245184h case   20:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82245184h case   20:*/		return 0x82245188;
		  /* 82245188h */ case   21:  		/* bc 12, CR0_EQ, 20 */
		/* 82245188h case   21:*/		if ( regs.CR[0].eq ) { return 0x8224519C;  }
		/* 82245188h case   21:*/		return 0x8224518C;
		  /* 8224518Ch */ case   22:  		/* lwz R4, <#[R31]> */
		/* 8224518Ch case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 8224518Ch case   22:*/		return 0x82245190;
		  /* 82245190h */ case   23:  		/* bl 74128 */
		/* 82245190h case   23:*/		regs.LR = 0x82245194; return 0x82257320;
		/* 82245190h case   23:*/		return 0x82245194;
		  /* 82245194h */ case   24:  		/* mr R30, R3 */
		/* 82245194h case   24:*/		regs.R30 = regs.R3;
		/* 82245194h case   24:*/		return 0x82245198;
		  /* 82245198h */ case   25:  		/* b 8 */
		/* 82245198h case   25:*/		return 0x822451A0;
		/* 82245198h case   25:*/		return 0x8224519C;
	}
	return 0x8224519C;
} // Block from 82245134h-8224519Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 8224519Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224519C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224519C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224519C);
		  /* 8224519Ch */ case    0:  		/* mr R30, R21 */
		/* 8224519Ch case    0:*/		regs.R30 = regs.R21;
		/* 8224519Ch case    0:*/		return 0x822451A0;
	}
	return 0x822451A0;
} // Block from 8224519Ch-822451A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822451A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822451A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822451A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822451A0);
		  /* 822451A0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 822451A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822451A0h case    0:*/		return 0x822451A4;
		  /* 822451A4h */ case    1:  		/* lbz R11, <#[R11 + 1392]> */
		/* 822451A4h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000570) );
		/* 822451A4h case    1:*/		return 0x822451A8;
		  /* 822451A8h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 822451A8h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822451A8h case    2:*/		return 0x822451AC;
		  /* 822451ACh */ case    3:  		/* bc 4, CR0_EQ, 32 */
		/* 822451ACh case    3:*/		if ( !regs.CR[0].eq ) { return 0x822451CC;  }
		/* 822451ACh case    3:*/		return 0x822451B0;
		  /* 822451B0h */ case    4:  		/* lwz R11, <#[R31 + 36]> */
		/* 822451B0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 822451B0h case    4:*/		return 0x822451B4;
		  /* 822451B4h */ case    5:  		/* li R10, 11 */
		/* 822451B4h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0xB);
		/* 822451B4h case    5:*/		return 0x822451B8;
		  /* 822451B8h */ case    6:  		/* addi R11, R11, 1 */
		/* 822451B8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822451B8h case    6:*/		return 0x822451BC;
		  /* 822451BCh */ case    7:  		/* stw R11, <#[R31 + 36]> */
		/* 822451BCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 822451BCh case    7:*/		return 0x822451C0;
		  /* 822451C0h */ case    8:  		/* stw R11, <#[R30 + 56]> */
		/* 822451C0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 822451C0h case    8:*/		return 0x822451C4;
		  /* 822451C4h */ case    9:  		/* stw R10, <#[R30 + 80]> */
		/* 822451C4h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000050) );
		/* 822451C4h case    9:*/		return 0x822451C8;
		  /* 822451C8h */ case   10:  		/* b 120 */
		/* 822451C8h case   10:*/		return 0x82245240;
		/* 822451C8h case   10:*/		return 0x822451CC;
	}
	return 0x822451CC;
} // Block from 822451A0h-822451CCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 822451CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822451CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822451CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822451CC);
		  /* 822451CCh */ case    0:  		/* mr R3, R31 */
		/* 822451CCh case    0:*/		regs.R3 = regs.R31;
		/* 822451CCh case    0:*/		return 0x822451D0;
		  /* 822451D0h */ case    1:  		/* bl -864 */
		/* 822451D0h case    1:*/		regs.LR = 0x822451D4; return 0x82244E70;
		/* 822451D0h case    1:*/		return 0x822451D4;
		  /* 822451D4h */ case    2:  		/* li R11, 11 */
		/* 822451D4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 822451D4h case    2:*/		return 0x822451D8;
		  /* 822451D8h */ case    3:  		/* stw R3, <#[R30 + 56]> */
		/* 822451D8h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000038) );
		/* 822451D8h case    3:*/		return 0x822451DC;
		  /* 822451DCh */ case    4:  		/* mr R29, R21 */
		/* 822451DCh case    4:*/		regs.R29 = regs.R21;
		/* 822451DCh case    4:*/		return 0x822451E0;
		  /* 822451E0h */ case    5:  		/* stw R11, <#[R30 + 80]> */
		/* 822451E0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000050) );
		/* 822451E0h case    5:*/		return 0x822451E4;
		  /* 822451E4h */ case    6:  		/* cmpwi CR6, R25, 0 */
		/* 822451E4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 822451E4h case    6:*/		return 0x822451E8;
		  /* 822451E8h */ case    7:  		/* bc 4, CR6_GT, 88 */
		/* 822451E8h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82245240;  }
		/* 822451E8h case    7:*/		return 0x822451EC;
		  /* 822451ECh */ case    8:  		/* lis R11, -32252 */
		/* 822451ECh case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822451ECh case    8:*/		return 0x822451F0;
		  /* 822451F0h */ case    9:  		/* addi R28, R1, 96 */
		/* 822451F0h case    9:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x60);
		/* 822451F0h case    9:*/		return 0x822451F4;
		  /* 822451F4h */ case   10:  		/* addi R27, R11, 12500 */
		/* 822451F4h case   10:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x30D4);
		/* 822451F4h case   10:*/		return 0x822451F8;
		  /* 822451F8h */ case   11:  		/* lwz R11, <#[R28]> */
		/* 822451F8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 822451F8h case   11:*/		return 0x822451FC;
		  /* 822451FCh */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 822451FCh case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822451FCh case   12:*/		return 0x82245200;
		  /* 82245200h */ case   13:  		/* bc 12, CR6_EQ, 28 */
		/* 82245200h case   13:*/		if ( regs.CR[6].eq ) { return 0x8224521C;  }
		/* 82245200h case   13:*/		return 0x82245204;
		  /* 82245204h */ case   14:  		/* mr R6, R23 */
		/* 82245204h case   14:*/		regs.R6 = regs.R23;
		/* 82245204h case   14:*/		return 0x82245208;
		  /* 82245208h */ case   15:  		/* mr R5, R27 */
		/* 82245208h case   15:*/		regs.R5 = regs.R27;
		/* 82245208h case   15:*/		return 0x8224520C;
		  /* 8224520Ch */ case   16:  		/* mr R4, R24 */
		/* 8224520Ch case   16:*/		regs.R4 = regs.R24;
		/* 8224520Ch case   16:*/		return 0x82245210;
		  /* 82245210h */ case   17:  		/* li R7, 457 */
		/* 82245210h case   17:*/		cpu::op::li<0>(regs,&regs.R7,0x1C9);
		/* 82245210h case   17:*/		return 0x82245214;
		  /* 82245214h */ case   18:  		/* li R3, 0 */
		/* 82245214h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82245214h case   18:*/		return 0x82245218;
		  /* 82245218h */ case   19:  		/* bl -972304 */
		/* 82245218h case   19:*/		regs.LR = 0x8224521C; return 0x82157C08;
		/* 82245218h case   19:*/		return 0x8224521C;
	}
	return 0x8224521C;
} // Block from 822451CCh-8224521Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8224521Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224521C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224521C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224521C);
		  /* 8224521Ch */ case    0:  		/* mr R5, R29 */
		/* 8224521Ch case    0:*/		regs.R5 = regs.R29;
		/* 8224521Ch case    0:*/		return 0x82245220;
		  /* 82245220h */ case    1:  		/* ld R6, <#[R28]> */
		/* 82245220h case    1:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R28 + 0x00000000) );
		/* 82245220h case    1:*/		return 0x82245224;
		  /* 82245224h */ case    2:  		/* lwz R4, <#[R30 + 56]> */
		/* 82245224h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000038) );
		/* 82245224h case    2:*/		return 0x82245228;
		  /* 82245228h */ case    3:  		/* lwz R3, <#[R31]> */
		/* 82245228h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 82245228h case    3:*/		return 0x8224522C;
		  /* 8224522Ch */ case    4:  		/* bl -165100 */
		/* 8224522Ch case    4:*/		regs.LR = 0x82245230; return 0x8221CD40;
		/* 8224522Ch case    4:*/		return 0x82245230;
		  /* 82245230h */ case    5:  		/* addi R29, R29, 1 */
		/* 82245230h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82245230h case    5:*/		return 0x82245234;
		  /* 82245234h */ case    6:  		/* addi R28, R28, 8 */
		/* 82245234h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 82245234h case    6:*/		return 0x82245238;
		  /* 82245238h */ case    7:  		/* cmpw CR6, R29, R25 */
		/* 82245238h case    7:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R25);
		/* 82245238h case    7:*/		return 0x8224523C;
		  /* 8224523Ch */ case    8:  		/* bc 12, CR6_LT, -68 */
		/* 8224523Ch case    8:*/		if ( regs.CR[6].lt ) { return 0x822451F8;  }
		/* 8224523Ch case    8:*/		return 0x82245240;
	}
	return 0x82245240;
} // Block from 8224521Ch-82245240h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82245240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245240);
		  /* 82245240h */ case    0:  		/* li R8, 4 */
		/* 82245240h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82245240h case    0:*/		return 0x82245244;
		  /* 82245244h */ case    1:  		/* mr R7, R21 */
		/* 82245244h case    1:*/		regs.R7 = regs.R21;
		/* 82245244h case    1:*/		return 0x82245248;
		  /* 82245248h */ case    2:  		/* addi R10, R1, 96 */
		/* 82245248h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 82245248h case    2:*/		return 0x8224524C;
		  /* 8224524Ch */ case    3:  		/* addi R11, R30, 928 */
		/* 8224524Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x3A0);
		/* 8224524Ch case    3:*/		return 0x82245250;
		  /* 82245250h */ case    4:  		/* addi R9, R30, 896 */
		/* 82245250h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x380);
		/* 82245250h case    4:*/		return 0x82245254;
		  /* 82245254h */ case    5:  		/* mtspr CTR, R8 */
		/* 82245254h case    5:*/		regs.CTR = regs.R8;
		/* 82245254h case    5:*/		return 0x82245258;
		  /* 82245258h */ case    6:  		/* cmpw CR6, R7, R25 */
		/* 82245258h case    6:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R25);
		/* 82245258h case    6:*/		return 0x8224525C;
		  /* 8224525Ch */ case    7:  		/* bc 4, CR6_LT, 28 */
		/* 8224525Ch case    7:*/		if ( !regs.CR[6].lt ) { return 0x82245278;  }
		/* 8224525Ch case    7:*/		return 0x82245260;
		  /* 82245260h */ case    8:  		/* lwz R8, <#[R10]> */
		/* 82245260h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82245260h case    8:*/		return 0x82245264;
		  /* 82245264h */ case    9:  		/* lwz R6, <#[R10 + 4]> */
		/* 82245264h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82245264h case    9:*/		return 0x82245268;
		  /* 82245268h */ case   10:  		/* stw R22, <#[R11]> */
		/* 82245268h case   10:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000000) );
		/* 82245268h case   10:*/		return 0x8224526C;
		  /* 8224526Ch */ case   11:  		/* stw R8, <#[R9]> */
		/* 8224526Ch case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 8224526Ch case   11:*/		return 0x82245270;
		  /* 82245270h */ case   12:  		/* stw R6, <#[R9 + 4]> */
		/* 82245270h case   12:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + 0x00000004) );
		/* 82245270h case   12:*/		return 0x82245274;
		  /* 82245274h */ case   13:  		/* b 8 */
		/* 82245274h case   13:*/		return 0x8224527C;
		/* 82245274h case   13:*/		return 0x82245278;
	}
	return 0x82245278;
} // Block from 82245240h-82245278h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82245278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245278);
		  /* 82245278h */ case    0:  		/* stw R21, <#[R11]> */
		/* 82245278h case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x00000000) );
		/* 82245278h case    0:*/		return 0x8224527C;
	}
	return 0x8224527C;
} // Block from 82245278h-8224527Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224527Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224527C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224527C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224527C);
		  /* 8224527Ch */ case    0:  		/* addi R7, R7, 1 */
		/* 8224527Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8224527Ch case    0:*/		return 0x82245280;
	}
	return 0x82245280;
} // Block from 8224527Ch-82245280h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245280h
// Function '?Assemble@CFG@XGRAPHICS@@QAAXAAIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245280);
		  /* 82245280h */ case    0:  		/* addi R11, R11, 4 */
		/* 82245280h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82245280h case    0:*/		return 0x82245284;
		  /* 82245284h */ case    1:  		/* addi R10, R10, 8 */
		/* 82245284h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82245284h case    1:*/		return 0x82245288;
		  /* 82245288h */ case    2:  		/* addi R9, R9, 8 */
		/* 82245288h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 82245288h case    2:*/		return 0x8224528C;
		  /* 8224528Ch */ case    3:  		/* bc 16, CR0_LT, -52 */
		/* 8224528Ch case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82245258;  }
		/* 8224528Ch case    3:*/		return 0x82245290;
		  /* 82245290h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 82245290h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245290h case    4:*/		return 0x82245294;
		  /* 82245294h */ case    5:  		/* mr R4, R30 */
		/* 82245294h case    5:*/		regs.R4 = regs.R30;
		/* 82245294h case    5:*/		return 0x82245298;
		  /* 82245298h */ case    6:  		/* lwz R11, <#[R11 + 2736]> */
		/* 82245298h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000AB0) );
		/* 82245298h case    6:*/		return 0x8224529C;
		  /* 8224529Ch */ case    7:  		/* lwz R3, <#[R11 + 164]> */
		/* 8224529Ch case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000000A4) );
		/* 8224529Ch case    7:*/		return 0x822452A0;
		  /* 822452A0h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 822452A0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822452A0h case    8:*/		return 0x822452A4;
		  /* 822452A4h */ case    9:  		/* lwz R11, <#[R11 + 40]> */
		/* 822452A4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 822452A4h case    9:*/		return 0x822452A8;
		  /* 822452A8h */ case   10:  		/* mtspr CTR, R11 */
		/* 822452A8h case   10:*/		regs.CTR = regs.R11;
		/* 822452A8h case   10:*/		return 0x822452AC;
		  /* 822452ACh */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 822452ACh case   11:*/		if ( 1 ) { regs.LR = 0x822452B0; return (uint32)regs.CTR; }
		/* 822452ACh case   11:*/		return 0x822452B0;
		  /* 822452B0h */ case   12:  		/* mr R4, R30 */
		/* 822452B0h case   12:*/		regs.R4 = regs.R30;
		/* 822452B0h case   12:*/		return 0x822452B4;
		  /* 822452B4h */ case   13:  		/* mr R3, R26 */
		/* 822452B4h case   13:*/		regs.R3 = regs.R26;
		/* 822452B4h case   13:*/		return 0x822452B8;
		  /* 822452B8h */ case   14:  		/* bl 60288 */
		/* 822452B8h case   14:*/		regs.LR = 0x822452BC; return 0x82253E38;
		/* 822452B8h case   14:*/		return 0x822452BC;
	}
	return 0x822452BC;
} // Block from 82245280h-822452BCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 822452BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822452BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822452BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822452BC);
		  /* 822452BCh */ case    0:  		/* mr R3, R30 */
		/* 822452BCh case    0:*/		regs.R3 = regs.R30;
		/* 822452BCh case    0:*/		return 0x822452C0;
		  /* 822452C0h */ case    1:  		/* addi R1, R1, 240 */
		/* 822452C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 822452C0h case    1:*/		return 0x822452C4;
		  /* 822452C4h */ case    2:  		/* b -1785916 */
		/* 822452C4h case    2:*/		return 0x82091288;
		/* 822452C4h case    2:*/		return 0x822452C8;
		  /* 822452C8h */ case    3:  		/* li R6, 0 */
		/* 822452C8h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822452C8h case    3:*/		return 0x822452CC;
		  /* 822452CCh */ case    4:  		/* li R10, 3 */
		/* 822452CCh case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 822452CCh case    4:*/		return 0x822452D0;
		  /* 822452D0h */ case    5:  		/* addi R11, R4, 940 */
		/* 822452D0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x3AC);
		/* 822452D0h case    5:*/		return 0x822452D4;
		  /* 822452D4h */ case    6:  		/* subf R9, R4, R3 */
		/* 822452D4h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R4,regs.R3);
		/* 822452D4h case    6:*/		return 0x822452D8;
		  /* 822452D8h */ case    7:  		/* lwzx R8, <#[R9 + R11]> */
		/* 822452D8h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 822452D8h case    7:*/		return 0x822452DC;
		  /* 822452DCh */ case    8:  		/* cmplwi CR6, R8, 0 */
		/* 822452DCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 822452DCh case    8:*/		return 0x822452E0;
		  /* 822452E0h */ case    9:  		/* lwz R8, <#[R11]> */
		/* 822452E0h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 822452E0h case    9:*/		return 0x822452E4;
		  /* 822452E4h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 822452E4h case   10:*/		if ( regs.CR[6].eq ) { return 0x822452F8;  }
		/* 822452E4h case   10:*/		return 0x822452E8;
		  /* 822452E8h */ case   11:  		/* cmplwi CR6, R8, 0 */
		/* 822452E8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 822452E8h case   11:*/		return 0x822452EC;
		  /* 822452ECh */ case   12:  		/* bc 12, CR6_EQ, 132 */
		/* 822452ECh case   12:*/		if ( regs.CR[6].eq ) { return 0x82245370;  }
		/* 822452ECh case   12:*/		return 0x822452F0;
		  /* 822452F0h */ case   13:  		/* addi R6, R6, 1 */
		/* 822452F0h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 822452F0h case   13:*/		return 0x822452F4;
		  /* 822452F4h */ case   14:  		/* b 12 */
		/* 822452F4h case   14:*/		return 0x82245300;
		/* 822452F4h case   14:*/		return 0x822452F8;
	}
	return 0x822452F8;
} // Block from 822452BCh-822452F8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822452F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822452F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822452F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822452F8);
		  /* 822452F8h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 822452F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 822452F8h case    0:*/		return 0x822452FC;
		  /* 822452FCh */ case    1:  		/* bc 4, CR6_EQ, 124 */
		/* 822452FCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82245378;  }
		/* 822452FCh case    1:*/		return 0x82245300;
	}
	return 0x82245300;
} // Block from 822452F8h-82245300h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245300);
		  /* 82245300h */ case    0:  		/* addic. R10, R10, -1 */
		/* 82245300h case    0:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82245300h case    0:*/		return 0x82245304;
		  /* 82245304h */ case    1:  		/* addi R11, R11, -4 */
		/* 82245304h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82245304h case    1:*/		return 0x82245308;
		  /* 82245308h */ case    2:  		/* bc 4, CR0_LT, -48 */
		/* 82245308h case    2:*/		if ( !regs.CR[0].lt ) { return 0x822452D8;  }
		/* 82245308h case    2:*/		return 0x8224530C;
		  /* 8224530Ch */ case    3:  		/* li R10, 0 */
		/* 8224530Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8224530Ch case    3:*/		return 0x82245310;
		  /* 82245310h */ case    4:  		/* cmpwi CR6, R6, 0 */
		/* 82245310h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 82245310h case    4:*/		return 0x82245314;
		  /* 82245314h */ case    5:  		/* bc 4, CR6_GT, 84 */
		/* 82245314h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82245368;  }
		/* 82245314h case    5:*/		return 0x82245318;
		  /* 82245318h */ case    6:  		/* addi R9, R4, 896 */
		/* 82245318h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x380);
		/* 82245318h case    6:*/		return 0x8224531C;
		  /* 8224531Ch */ case    7:  		/* addi R11, R3, 900 */
		/* 8224531Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x384);
		/* 8224531Ch case    7:*/		return 0x82245320;
		  /* 82245320h */ case    8:  		/* subf R7, R3, R4 */
		/* 82245320h case    8:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R3,regs.R4);
		/* 82245320h case    8:*/		return 0x82245324;
		  /* 82245324h */ case    9:  		/* lwz R8, <#[R9]> */
		/* 82245324h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82245324h case    9:*/		return 0x82245328;
		  /* 82245328h */ case   10:  		/* lwz R5, <#[R11 - 4]> */
		/* 82245328h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82245328h case   10:*/		return 0x8224532C;
		  /* 8224532Ch */ case   11:  		/* cmplw CR6, R5, R8 */
		/* 8224532Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R8);
		/* 8224532Ch case   11:*/		return 0x82245330;
		  /* 82245330h */ case   12:  		/* bc 4, CR6_EQ, 24 */
		/* 82245330h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82245348;  }
		/* 82245330h case   12:*/		return 0x82245334;
		  /* 82245334h */ case   13:  		/* lwz R8, <#[R11]> */
		/* 82245334h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82245334h case   13:*/		return 0x82245338;
		  /* 82245338h */ case   14:  		/* lwzx R5, <#[R7 + R11]> */
		/* 82245338h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82245338h case   14:*/		return 0x8224533C;
		  /* 8224533Ch */ case   15:  		/* cmplw CR6, R8, R5 */
		/* 8224533Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R5);
		/* 8224533Ch case   15:*/		return 0x82245340;
		  /* 82245340h */ case   16:  		/* li R8, 0 */
		/* 82245340h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82245340h case   16:*/		return 0x82245344;
		  /* 82245344h */ case   17:  		/* bc 12, CR6_EQ, 8 */
		/* 82245344h case   17:*/		if ( regs.CR[6].eq ) { return 0x8224534C;  }
		/* 82245344h case   17:*/		return 0x82245348;
	}
	return 0x82245348;
} // Block from 82245300h-82245348h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82245348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245348);
		  /* 82245348h */ case    0:  		/* li R8, 1 */
		/* 82245348h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82245348h case    0:*/		return 0x8224534C;
	}
	return 0x8224534C;
} // Block from 82245348h-8224534Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224534Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224534C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224534C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224534C);
		  /* 8224534Ch */ case    0:  		/* rlwinm. R8, R8, 0, 24, 31 */
		/* 8224534Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R8,regs.R8);
		/* 8224534Ch case    0:*/		return 0x82245350;
		  /* 82245350h */ case    1:  		/* bc 4, CR0_EQ, 48 */
		/* 82245350h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82245380;  }
		/* 82245350h case    1:*/		return 0x82245354;
		  /* 82245354h */ case    2:  		/* addi R10, R10, 1 */
		/* 82245354h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82245354h case    2:*/		return 0x82245358;
		  /* 82245358h */ case    3:  		/* addi R9, R9, 8 */
		/* 82245358h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 82245358h case    3:*/		return 0x8224535C;
		  /* 8224535Ch */ case    4:  		/* addi R11, R11, 8 */
		/* 8224535Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8224535Ch case    4:*/		return 0x82245360;
		  /* 82245360h */ case    5:  		/* cmpw CR6, R10, R6 */
		/* 82245360h case    5:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R6);
		/* 82245360h case    5:*/		return 0x82245364;
		  /* 82245364h */ case    6:  		/* bc 12, CR6_LT, -64 */
		/* 82245364h case    6:*/		if ( regs.CR[6].lt ) { return 0x82245324;  }
		/* 82245364h case    6:*/		return 0x82245368;
	}
	return 0x82245368;
} // Block from 8224534Ch-82245368h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82245368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245368);
		  /* 82245368h */ case    0:  		/* li R3, 0 */
		/* 82245368h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82245368h case    0:*/		return 0x8224536C;
		  /* 8224536Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224536Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224536Ch case    1:*/		return 0x82245370;
	}
	return 0x82245370;
} // Block from 82245368h-82245370h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245370);
		  /* 82245370h */ case    0:  		/* li R3, -1 */
		/* 82245370h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82245370h case    0:*/		return 0x82245374;
		  /* 82245374h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82245374h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82245374h case    1:*/		return 0x82245378;
	}
	return 0x82245378;
} // Block from 82245370h-82245378h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245378);
		  /* 82245378h */ case    0:  		/* li R3, 1 */
		/* 82245378h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82245378h case    0:*/		return 0x8224537C;
		  /* 8224537Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224537Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224537Ch case    1:*/		return 0x82245380;
	}
	return 0x82245380;
} // Block from 82245378h-82245380h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245380);
		  /* 82245380h */ case    0:  		/* addi R11, R10, 112 */
		/* 82245380h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x70);
		/* 82245380h case    0:*/		return 0x82245384;
		  /* 82245384h */ case    1:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82245384h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82245384h case    1:*/		return 0x82245388;
		  /* 82245388h */ case    2:  		/* add R10, R11, R4 */
		/* 82245388h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R4);
		/* 82245388h case    2:*/		return 0x8224538C;
		  /* 8224538Ch */ case    3:  		/* add R11, R11, R3 */
		/* 8224538Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8224538Ch case    3:*/		return 0x82245390;
		  /* 82245390h */ case    4:  		/* lwz R9, <#[R10]> */
		/* 82245390h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82245390h case    4:*/		return 0x82245394;
		  /* 82245394h */ case    5:  		/* lwz R8, <#[R11]> */
		/* 82245394h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82245394h case    5:*/		return 0x82245398;
		  /* 82245398h */ case    6:  		/* cmplw CR6, R8, R9 */
		/* 82245398h case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 82245398h case    6:*/		return 0x8224539C;
		  /* 8224539Ch */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 8224539Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x822453A8;  }
		/* 8224539Ch case    7:*/		return 0x822453A0;
		  /* 822453A0h */ case    8:  		/* subfc R11, R9, R8 */
		/* 822453A0h case    8:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R9,regs.R8);
		/* 822453A0h case    8:*/		return 0x822453A4;
		  /* 822453A4h */ case    9:  		/* b 16 */
		/* 822453A4h case    9:*/		return 0x822453B4;
		/* 822453A4h case    9:*/		return 0x822453A8;
	}
	return 0x822453A8;
} // Block from 82245380h-822453A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822453A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822453A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822453A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822453A8);
		  /* 822453A8h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 822453A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822453A8h case    0:*/		return 0x822453AC;
		  /* 822453ACh */ case    1:  		/* lwz R10, <#[R10 + 4]> */
		/* 822453ACh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 822453ACh case    1:*/		return 0x822453B0;
		  /* 822453B0h */ case    2:  		/* subfc R11, R10, R11 */
		/* 822453B0h case    2:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822453B0h case    2:*/		return 0x822453B4;
	}
	return 0x822453B4;
} // Block from 822453A8h-822453B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822453B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822453B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822453B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822453B4);
		  /* 822453B4h */ case    0:  		/* subfe R11, R11, R11 */
		/* 822453B4h case    0:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 822453B4h case    0:*/		return 0x822453B8;
		  /* 822453B8h */ case    1:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 822453B8h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 822453B8h case    1:*/		return 0x822453BC;
		  /* 822453BCh */ case    2:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 822453BCh case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822453BCh case    2:*/		return 0x822453C0;
		  /* 822453C0h */ case    3:  		/* subfic R11, R11, 0 */
		/* 822453C0h case    3:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 822453C0h case    3:*/		return 0x822453C4;
		  /* 822453C4h */ case    4:  		/* subfe R11, R11, R11 */
		/* 822453C4h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 822453C4h case    4:*/		return 0x822453C8;
		  /* 822453C8h */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 822453C8h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 822453C8h case    5:*/		return 0x822453CC;
		  /* 822453CCh */ case    6:  		/* addi R3, R11, 1 */
		/* 822453CCh case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 822453CCh case    6:*/		return 0x822453D0;
		  /* 822453D0h */ case    7:  		/* bclr 20, CR0_LT */
		/* 822453D0h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822453D0h case    7:*/		return 0x822453D4;
	}
	return 0x822453D4;
} // Block from 822453B4h-822453D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822453D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822453D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822453D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822453D4);
		  /* 822453D4h */ case    0:  		/* nop */
		/* 822453D4h case    0:*/		cpu::op::nop();
		/* 822453D4h case    0:*/		return 0x822453D8;
	}
	return 0x822453D8;
} // Block from 822453D4h-822453D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822453D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822453D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822453D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822453D8);
		  /* 822453D8h */ case    0:  		/* mfspr R12, LR */
		/* 822453D8h case    0:*/		regs.R12 = regs.LR;
		/* 822453D8h case    0:*/		return 0x822453DC;
		  /* 822453DCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822453DCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822453DCh case    1:*/		return 0x822453E0;
		  /* 822453E0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 822453E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822453E0h case    2:*/		return 0x822453E4;
		  /* 822453E4h */ case    3:  		/* li R11, 0 */
		/* 822453E4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822453E4h case    3:*/		return 0x822453E8;
		  /* 822453E8h */ case    4:  		/* addi R10, R4, 928 */
		/* 822453E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x3A0);
		/* 822453E8h case    4:*/		return 0x822453EC;
		  /* 822453ECh */ case    5:  		/* lwz R9, <#[R10]> */
		/* 822453ECh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 822453ECh case    5:*/		return 0x822453F0;
		  /* 822453F0h */ case    6:  		/* cmplwi CR6, R9, 0 */
		/* 822453F0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 822453F0h case    6:*/		return 0x822453F4;
		  /* 822453F4h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 822453F4h case    7:*/		if ( regs.CR[6].eq ) { return 0x82245408;  }
		/* 822453F4h case    7:*/		return 0x822453F8;
		  /* 822453F8h */ case    8:  		/* addi R11, R11, 1 */
		/* 822453F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822453F8h case    8:*/		return 0x822453FC;
		  /* 822453FCh */ case    9:  		/* addi R10, R10, 4 */
		/* 822453FCh case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 822453FCh case    9:*/		return 0x82245400;
		  /* 82245400h */ case   10:  		/* cmpwi CR6, R11, 4 */
		/* 82245400h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 82245400h case   10:*/		return 0x82245404;
		  /* 82245404h */ case   11:  		/* bc 12, CR6_LT, -24 */
		/* 82245404h case   11:*/		if ( regs.CR[6].lt ) { return 0x822453EC;  }
		/* 82245404h case   11:*/		return 0x82245408;
	}
	return 0x82245408;
} // Block from 822453D8h-82245408h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82245408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245408);
		  /* 82245408h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82245408h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82245408h case    0:*/		return 0x8224540C;
		  /* 8224540Ch */ case    1:  		/* lwz R9, <#[R3 + 8]> */
		/* 8224540Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8224540Ch case    1:*/		return 0x82245410;
		  /* 82245410h */ case    2:  		/* addi R10, R1, 80 */
		/* 82245410h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82245410h case    2:*/		return 0x82245414;
		  /* 82245414h */ case    3:  		/* lwz R8, <#[R3 + 12]> */
		/* 82245414h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000000C) );
		/* 82245414h case    3:*/		return 0x82245418;
		  /* 82245418h */ case    4:  		/* lwz R7, <#[R3 + 16]> */
		/* 82245418h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000010) );
		/* 82245418h case    4:*/		return 0x8224541C;
		  /* 8224541Ch */ case    5:  		/* lwz R6, <#[R3 + 20]> */
		/* 8224541Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000014) );
		/* 8224541Ch case    5:*/		return 0x82245420;
		  /* 82245420h */ case    6:  		/* add R11, R11, R10 */
		/* 82245420h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82245420h case    6:*/		return 0x82245424;
		  /* 82245424h */ case    7:  		/* stw R9, <#[R1 + 80]> */
		/* 82245424h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82245424h case    7:*/		return 0x82245428;
		  /* 82245428h */ case    8:  		/* stw R8, <#[R1 + 84]> */
		/* 82245428h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 82245428h case    8:*/		return 0x8224542C;
		  /* 8224542Ch */ case    9:  		/* stw R7, <#[R1 + 88]> */
		/* 8224542Ch case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 8224542Ch case    9:*/		return 0x82245430;
		  /* 82245430h */ case   10:  		/* stw R6, <#[R1 + 92]> */
		/* 82245430h case   10:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 82245430h case   10:*/		return 0x82245434;
		  /* 82245434h */ case   11:  		/* lwz R3, <#[R11 - 4]> */
		/* 82245434h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82245434h case   11:*/		return 0x82245438;
		  /* 82245438h */ case   12:  		/* bl 60096 */
		/* 82245438h case   12:*/		regs.LR = 0x8224543C; return 0x82253EF8;
		/* 82245438h case   12:*/		return 0x8224543C;
		  /* 8224543Ch */ case   13:  		/* addi R1, R1, 112 */
		/* 8224543Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224543Ch case   13:*/		return 0x82245440;
		  /* 82245440h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 82245440h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82245440h case   14:*/		return 0x82245444;
		  /* 82245444h */ case   15:  		/* mtspr LR, R12 */
		/* 82245444h case   15:*/		regs.LR = regs.R12;
		/* 82245444h case   15:*/		return 0x82245448;
		  /* 82245448h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82245448h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82245448h case   16:*/		return 0x8224544C;
	}
	return 0x8224544C;
} // Block from 82245408h-8224544Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224544Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224544C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224544C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224544C);
		  /* 8224544Ch */ case    0:  		/* nop */
		/* 8224544Ch case    0:*/		cpu::op::nop();
		/* 8224544Ch case    0:*/		return 0x82245450;
	}
	return 0x82245450;
} // Block from 8224544Ch-82245450h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245450h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245450);
		  /* 82245450h */ case    0:  		/* mfspr R12, LR */
		/* 82245450h case    0:*/		regs.R12 = regs.LR;
		/* 82245450h case    0:*/		return 0x82245454;
		  /* 82245454h */ case    1:  		/* bl -1786364 */
		/* 82245454h case    1:*/		regs.LR = 0x82245458; return 0x82091258;
		/* 82245454h case    1:*/		return 0x82245458;
		  /* 82245458h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82245458h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82245458h case    2:*/		return 0x8224545C;
		  /* 8224545Ch */ case    3:  		/* li R29, 0 */
		/* 8224545Ch case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224545Ch case    3:*/		return 0x82245460;
		  /* 82245460h */ case    4:  		/* stb R4, <#[R3 + 32]> */
		/* 82245460h case    4:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R3 + 0x00000020) );
		/* 82245460h case    4:*/		return 0x82245464;
		  /* 82245464h */ case    5:  		/* mr R31, R3 */
		/* 82245464h case    5:*/		regs.R31 = regs.R3;
		/* 82245464h case    5:*/		return 0x82245468;
		  /* 82245468h */ case    6:  		/* rlwinm. R11, R4, 0, 24, 31 */
		/* 82245468h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R4);
		/* 82245468h case    6:*/		return 0x8224546C;
		  /* 8224546Ch */ case    7:  		/* stw R29, <#[R3 + 36]> */
		/* 8224546Ch case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000024) );
		/* 8224546Ch case    7:*/		return 0x82245470;
		  /* 82245470h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 82245470h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224547C;  }
		/* 82245470h case    8:*/		return 0x82245474;
		  /* 82245474h */ case    9:  		/* stw R29, <#[R3 + 40]> */
		/* 82245474h case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000028) );
		/* 82245474h case    9:*/		return 0x82245478;
		  /* 82245478h */ case   10:  		/* b 12 */
		/* 82245478h case   10:*/		return 0x82245484;
		/* 82245478h case   10:*/		return 0x8224547C;
	}
	return 0x8224547C;
} // Block from 82245450h-8224547Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224547Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224547C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224547C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224547C);
		  /* 8224547Ch */ case    0:  		/* li R11, 32 */
		/* 8224547Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 8224547Ch case    0:*/		return 0x82245480;
		  /* 82245480h */ case    1:  		/* stw R11, <#[R31 + 40]> */
		/* 82245480h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82245480h case    1:*/		return 0x82245484;
	}
	return 0x82245484;
} // Block from 8224547Ch-82245484h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245484);
		  /* 82245484h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82245484h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245484h case    0:*/		return 0x82245488;
		  /* 82245488h */ case    1:  		/* li R4, 28 */
		/* 82245488h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 82245488h case    1:*/		return 0x8224548C;
		  /* 8224548Ch */ case    2:  		/* lwz R28, <#[R11 + 1452]> */
		/* 8224548Ch case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x000005AC) );
		/* 8224548Ch case    2:*/		return 0x82245490;
		  /* 82245490h */ case    3:  		/* mr R3, R28 */
		/* 82245490h case    3:*/		regs.R3 = regs.R28;
		/* 82245490h case    3:*/		return 0x82245494;
		  /* 82245494h */ case    4:  		/* bl -167900 */
		/* 82245494h case    4:*/		regs.LR = 0x82245498; return 0x8221C4B8;
		/* 82245494h case    4:*/		return 0x82245498;
		  /* 82245498h */ case    5:  		/* addic. R30, R3, 4 */
		/* 82245498h case    5:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 82245498h case    5:*/		return 0x8224549C;
		  /* 8224549Ch */ case    6:  		/* stw R28, <#[R3]> */
		/* 8224549Ch case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 8224549Ch case    6:*/		return 0x822454A0;
		  /* 822454A0h */ case    7:  		/* bc 12, CR0_EQ, 44 */
		/* 822454A0h case    7:*/		if ( regs.CR[0].eq ) { return 0x822454CC;  }
		/* 822454A0h case    7:*/		return 0x822454A4;
		  /* 822454A4h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 822454A4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822454A4h case    8:*/		return 0x822454A8;
		  /* 822454A8h */ case    9:  		/* lis R10, -32220 */
		/* 822454A8h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8224);
		/* 822454A8h case    9:*/		return 0x822454AC;
		  /* 822454ACh */ case   10:  		/* lis R9, -32220 */
		/* 822454ACh case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8224);
		/* 822454ACh case   10:*/		return 0x822454B0;
		  /* 822454B0h */ case   11:  		/* li R7, 16 */
		/* 822454B0h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 822454B0h case   11:*/		return 0x822454B4;
		  /* 822454B4h */ case   12:  		/* addi R6, R10, 20016 */
		/* 822454B4h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x4E30);
		/* 822454B4h case   12:*/		return 0x822454B8;
		  /* 822454B8h */ case   13:  		/* addi R5, R9, 20032 */
		/* 822454B8h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x4E40);
		/* 822454B8h case   13:*/		return 0x822454BC;
		  /* 822454BCh */ case   14:  		/* mr R3, R30 */
		/* 822454BCh case   14:*/		regs.R3 = regs.R30;
		/* 822454BCh case   14:*/		return 0x822454C0;
		  /* 822454C0h */ case   15:  		/* lwz R4, <#[R11 + 1452]> */
		/* 822454C0h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 822454C0h case   15:*/		return 0x822454C4;
		  /* 822454C4h */ case   16:  		/* bl -1828 */
		/* 822454C4h case   16:*/		regs.LR = 0x822454C8; return 0x82244DA0;
		/* 822454C4h case   16:*/		return 0x822454C8;
		  /* 822454C8h */ case   17:  		/* b 8 */
		/* 822454C8h case   17:*/		return 0x822454D0;
		/* 822454C8h case   17:*/		return 0x822454CC;
	}
	return 0x822454CC;
} // Block from 82245484h-822454CCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 822454CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822454CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822454CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822454CC);
		  /* 822454CCh */ case    0:  		/* mr R30, R29 */
		/* 822454CCh case    0:*/		regs.R30 = regs.R29;
		/* 822454CCh case    0:*/		return 0x822454D0;
	}
	return 0x822454D0;
} // Block from 822454CCh-822454D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822454D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822454D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822454D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822454D0);
		  /* 822454D0h */ case    0:  		/* stw R30, <#[R31 + 4]> */
		/* 822454D0h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 822454D0h case    0:*/		return 0x822454D4;
		  /* 822454D4h */ case    1:  		/* li R4, 28 */
		/* 822454D4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 822454D4h case    1:*/		return 0x822454D8;
		  /* 822454D8h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 822454D8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822454D8h case    2:*/		return 0x822454DC;
		  /* 822454DCh */ case    3:  		/* lwz R28, <#[R11 + 1452]> */
		/* 822454DCh case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x000005AC) );
		/* 822454DCh case    3:*/		return 0x822454E0;
		  /* 822454E0h */ case    4:  		/* mr R3, R28 */
		/* 822454E0h case    4:*/		regs.R3 = regs.R28;
		/* 822454E0h case    4:*/		return 0x822454E4;
		  /* 822454E4h */ case    5:  		/* bl -167980 */
		/* 822454E4h case    5:*/		regs.LR = 0x822454E8; return 0x8221C4B8;
		/* 822454E4h case    5:*/		return 0x822454E8;
		  /* 822454E8h */ case    6:  		/* addic. R30, R3, 4 */
		/* 822454E8h case    6:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 822454E8h case    6:*/		return 0x822454EC;
		  /* 822454ECh */ case    7:  		/* stw R28, <#[R3]> */
		/* 822454ECh case    7:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 822454ECh case    7:*/		return 0x822454F0;
		  /* 822454F0h */ case    8:  		/* bc 12, CR0_EQ, 44 */
		/* 822454F0h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224551C;  }
		/* 822454F0h case    8:*/		return 0x822454F4;
		  /* 822454F4h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 822454F4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822454F4h case    9:*/		return 0x822454F8;
		  /* 822454F8h */ case   10:  		/* lis R10, -32220 */
		/* 822454F8h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8224);
		/* 822454F8h case   10:*/		return 0x822454FC;
		  /* 822454FCh */ case   11:  		/* lis R9, -32220 */
		/* 822454FCh case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8224);
		/* 822454FCh case   11:*/		return 0x82245500;
		  /* 82245500h */ case   12:  		/* li R7, 16 */
		/* 82245500h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 82245500h case   12:*/		return 0x82245504;
		  /* 82245504h */ case   13:  		/* addi R6, R10, 19160 */
		/* 82245504h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x4AD8);
		/* 82245504h case   13:*/		return 0x82245508;
		  /* 82245508h */ case   14:  		/* addi R5, R9, 19240 */
		/* 82245508h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x4B28);
		/* 82245508h case   14:*/		return 0x8224550C;
		  /* 8224550Ch */ case   15:  		/* mr R3, R30 */
		/* 8224550Ch case   15:*/		regs.R3 = regs.R30;
		/* 8224550Ch case   15:*/		return 0x82245510;
		  /* 82245510h */ case   16:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82245510h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82245510h case   16:*/		return 0x82245514;
		  /* 82245514h */ case   17:  		/* bl -1908 */
		/* 82245514h case   17:*/		regs.LR = 0x82245518; return 0x82244DA0;
		/* 82245514h case   17:*/		return 0x82245518;
		  /* 82245518h */ case   18:  		/* b 8 */
		/* 82245518h case   18:*/		return 0x82245520;
		/* 82245518h case   18:*/		return 0x8224551C;
	}
	return 0x8224551C;
} // Block from 822454D0h-8224551Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224551Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224551C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224551C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224551C);
		  /* 8224551Ch */ case    0:  		/* mr R30, R29 */
		/* 8224551Ch case    0:*/		regs.R30 = regs.R29;
		/* 8224551Ch case    0:*/		return 0x82245520;
	}
	return 0x82245520;
} // Block from 8224551Ch-82245520h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245520);
		  /* 82245520h */ case    0:  		/* stw R30, <#[R31 + 8]> */
		/* 82245520h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 82245520h case    0:*/		return 0x82245524;
		  /* 82245524h */ case    1:  		/* li R4, 28 */
		/* 82245524h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 82245524h case    1:*/		return 0x82245528;
		  /* 82245528h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 82245528h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245528h case    2:*/		return 0x8224552C;
		  /* 8224552Ch */ case    3:  		/* lwz R28, <#[R11 + 1452]> */
		/* 8224552Ch case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x000005AC) );
		/* 8224552Ch case    3:*/		return 0x82245530;
		  /* 82245530h */ case    4:  		/* mr R3, R28 */
		/* 82245530h case    4:*/		regs.R3 = regs.R28;
		/* 82245530h case    4:*/		return 0x82245534;
		  /* 82245534h */ case    5:  		/* bl -168060 */
		/* 82245534h case    5:*/		regs.LR = 0x82245538; return 0x8221C4B8;
		/* 82245534h case    5:*/		return 0x82245538;
		  /* 82245538h */ case    6:  		/* addic. R30, R3, 4 */
		/* 82245538h case    6:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 82245538h case    6:*/		return 0x8224553C;
		  /* 8224553Ch */ case    7:  		/* stw R28, <#[R3]> */
		/* 8224553Ch case    7:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 8224553Ch case    7:*/		return 0x82245540;
		  /* 82245540h */ case    8:  		/* bc 12, CR0_EQ, 44 */
		/* 82245540h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224556C;  }
		/* 82245540h case    8:*/		return 0x82245544;
		  /* 82245544h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 82245544h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245544h case    9:*/		return 0x82245548;
		  /* 82245548h */ case   10:  		/* lis R10, -32220 */
		/* 82245548h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8224);
		/* 82245548h case   10:*/		return 0x8224554C;
		  /* 8224554Ch */ case   11:  		/* lis R9, -32220 */
		/* 8224554Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8224);
		/* 8224554Ch case   11:*/		return 0x82245550;
		  /* 82245550h */ case   12:  		/* li R7, 16 */
		/* 82245550h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 82245550h case   12:*/		return 0x82245554;
		  /* 82245554h */ case   13:  		/* addi R6, R10, 19168 */
		/* 82245554h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x4AE0);
		/* 82245554h case   13:*/		return 0x82245558;
		  /* 82245558h */ case   14:  		/* addi R5, R9, 19288 */
		/* 82245558h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x4B58);
		/* 82245558h case   14:*/		return 0x8224555C;
		  /* 8224555Ch */ case   15:  		/* mr R3, R30 */
		/* 8224555Ch case   15:*/		regs.R3 = regs.R30;
		/* 8224555Ch case   15:*/		return 0x82245560;
		  /* 82245560h */ case   16:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82245560h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82245560h case   16:*/		return 0x82245564;
		  /* 82245564h */ case   17:  		/* bl -1988 */
		/* 82245564h case   17:*/		regs.LR = 0x82245568; return 0x82244DA0;
		/* 82245564h case   17:*/		return 0x82245568;
		  /* 82245568h */ case   18:  		/* b 8 */
		/* 82245568h case   18:*/		return 0x82245570;
		/* 82245568h case   18:*/		return 0x8224556C;
	}
	return 0x8224556C;
} // Block from 82245520h-8224556Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224556Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224556C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224556C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224556C);
		  /* 8224556Ch */ case    0:  		/* mr R30, R29 */
		/* 8224556Ch case    0:*/		regs.R30 = regs.R29;
		/* 8224556Ch case    0:*/		return 0x82245570;
	}
	return 0x82245570;
} // Block from 8224556Ch-82245570h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245570);
		  /* 82245570h */ case    0:  		/* stw R30, <#[R31 + 12]> */
		/* 82245570h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 82245570h case    0:*/		return 0x82245574;
		  /* 82245574h */ case    1:  		/* li R4, 28 */
		/* 82245574h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 82245574h case    1:*/		return 0x82245578;
		  /* 82245578h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 82245578h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245578h case    2:*/		return 0x8224557C;
		  /* 8224557Ch */ case    3:  		/* lwz R28, <#[R11 + 1452]> */
		/* 8224557Ch case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x000005AC) );
		/* 8224557Ch case    3:*/		return 0x82245580;
		  /* 82245580h */ case    4:  		/* mr R3, R28 */
		/* 82245580h case    4:*/		regs.R3 = regs.R28;
		/* 82245580h case    4:*/		return 0x82245584;
		  /* 82245584h */ case    5:  		/* bl -168140 */
		/* 82245584h case    5:*/		regs.LR = 0x82245588; return 0x8221C4B8;
		/* 82245584h case    5:*/		return 0x82245588;
		  /* 82245588h */ case    6:  		/* addic. R30, R3, 4 */
		/* 82245588h case    6:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 82245588h case    6:*/		return 0x8224558C;
		  /* 8224558Ch */ case    7:  		/* stw R28, <#[R3]> */
		/* 8224558Ch case    7:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 8224558Ch case    7:*/		return 0x82245590;
		  /* 82245590h */ case    8:  		/* bc 12, CR0_EQ, 44 */
		/* 82245590h case    8:*/		if ( regs.CR[0].eq ) { return 0x822455BC;  }
		/* 82245590h case    8:*/		return 0x82245594;
		  /* 82245594h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 82245594h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245594h case    9:*/		return 0x82245598;
		  /* 82245598h */ case   10:  		/* lis R10, -32220 */
		/* 82245598h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8224);
		/* 82245598h case   10:*/		return 0x8224559C;
		  /* 8224559Ch */ case   11:  		/* lis R9, -32220 */
		/* 8224559Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8224);
		/* 8224559Ch case   11:*/		return 0x822455A0;
		  /* 822455A0h */ case   12:  		/* li R7, 16 */
		/* 822455A0h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 822455A0h case   12:*/		return 0x822455A4;
		  /* 822455A4h */ case   13:  		/* addi R6, R10, 19184 */
		/* 822455A4h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x4AF0);
		/* 822455A4h case   13:*/		return 0x822455A8;
		  /* 822455A8h */ case   14:  		/* addi R5, R9, 19368 */
		/* 822455A8h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x4BA8);
		/* 822455A8h case   14:*/		return 0x822455AC;
		  /* 822455ACh */ case   15:  		/* mr R3, R30 */
		/* 822455ACh case   15:*/		regs.R3 = regs.R30;
		/* 822455ACh case   15:*/		return 0x822455B0;
		  /* 822455B0h */ case   16:  		/* lwz R4, <#[R11 + 1452]> */
		/* 822455B0h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 822455B0h case   16:*/		return 0x822455B4;
		  /* 822455B4h */ case   17:  		/* bl -2068 */
		/* 822455B4h case   17:*/		regs.LR = 0x822455B8; return 0x82244DA0;
		/* 822455B4h case   17:*/		return 0x822455B8;
		  /* 822455B8h */ case   18:  		/* b 8 */
		/* 822455B8h case   18:*/		return 0x822455C0;
		/* 822455B8h case   18:*/		return 0x822455BC;
	}
	return 0x822455BC;
} // Block from 82245570h-822455BCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 822455BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822455BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822455BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822455BC);
		  /* 822455BCh */ case    0:  		/* mr R30, R29 */
		/* 822455BCh case    0:*/		regs.R30 = regs.R29;
		/* 822455BCh case    0:*/		return 0x822455C0;
	}
	return 0x822455C0;
} // Block from 822455BCh-822455C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822455C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822455C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822455C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822455C0);
		  /* 822455C0h */ case    0:  		/* stw R30, <#[R31 + 16]> */
		/* 822455C0h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 822455C0h case    0:*/		return 0x822455C4;
		  /* 822455C4h */ case    1:  		/* li R4, 28 */
		/* 822455C4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 822455C4h case    1:*/		return 0x822455C8;
		  /* 822455C8h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 822455C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822455C8h case    2:*/		return 0x822455CC;
		  /* 822455CCh */ case    3:  		/* lwz R28, <#[R11 + 1452]> */
		/* 822455CCh case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x000005AC) );
		/* 822455CCh case    3:*/		return 0x822455D0;
		  /* 822455D0h */ case    4:  		/* mr R3, R28 */
		/* 822455D0h case    4:*/		regs.R3 = regs.R28;
		/* 822455D0h case    4:*/		return 0x822455D4;
		  /* 822455D4h */ case    5:  		/* bl -168220 */
		/* 822455D4h case    5:*/		regs.LR = 0x822455D8; return 0x8221C4B8;
		/* 822455D4h case    5:*/		return 0x822455D8;
		  /* 822455D8h */ case    6:  		/* addic. R30, R3, 4 */
		/* 822455D8h case    6:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 822455D8h case    6:*/		return 0x822455DC;
		  /* 822455DCh */ case    7:  		/* stw R28, <#[R3]> */
		/* 822455DCh case    7:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 822455DCh case    7:*/		return 0x822455E0;
		  /* 822455E0h */ case    8:  		/* bc 12, CR0_EQ, 44 */
		/* 822455E0h case    8:*/		if ( regs.CR[0].eq ) { return 0x8224560C;  }
		/* 822455E0h case    8:*/		return 0x822455E4;
		  /* 822455E4h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 822455E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822455E4h case    9:*/		return 0x822455E8;
		  /* 822455E8h */ case   10:  		/* lis R10, -32220 */
		/* 822455E8h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8224);
		/* 822455E8h case   10:*/		return 0x822455EC;
		  /* 822455ECh */ case   11:  		/* lis R9, -32220 */
		/* 822455ECh case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8224);
		/* 822455ECh case   11:*/		return 0x822455F0;
		  /* 822455F0h */ case   12:  		/* li R7, 16 */
		/* 822455F0h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 822455F0h case   12:*/		return 0x822455F4;
		  /* 822455F4h */ case   13:  		/* addi R6, R10, 19208 */
		/* 822455F4h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x4B08);
		/* 822455F4h case   13:*/		return 0x822455F8;
		  /* 822455F8h */ case   14:  		/* addi R5, R9, 19480 */
		/* 822455F8h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x4C18);
		/* 822455F8h case   14:*/		return 0x822455FC;
		  /* 822455FCh */ case   15:  		/* mr R3, R30 */
		/* 822455FCh case   15:*/		regs.R3 = regs.R30;
		/* 822455FCh case   15:*/		return 0x82245600;
		  /* 82245600h */ case   16:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82245600h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82245600h case   16:*/		return 0x82245604;
		  /* 82245604h */ case   17:  		/* bl -2148 */
		/* 82245604h case   17:*/		regs.LR = 0x82245608; return 0x82244DA0;
		/* 82245604h case   17:*/		return 0x82245608;
		  /* 82245608h */ case   18:  		/* b 8 */
		/* 82245608h case   18:*/		return 0x82245610;
		/* 82245608h case   18:*/		return 0x8224560C;
	}
	return 0x8224560C;
} // Block from 822455C0h-8224560Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224560Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224560C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224560C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224560C);
		  /* 8224560Ch */ case    0:  		/* mr R30, R29 */
		/* 8224560Ch case    0:*/		regs.R30 = regs.R29;
		/* 8224560Ch case    0:*/		return 0x82245610;
	}
	return 0x82245610;
} // Block from 8224560Ch-82245610h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245610);
		  /* 82245610h */ case    0:  		/* stw R30, <#[R31 + 20]> */
		/* 82245610h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 82245610h case    0:*/		return 0x82245614;
		  /* 82245614h */ case    1:  		/* li R4, 52 */
		/* 82245614h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 82245614h case    1:*/		return 0x82245618;
		  /* 82245618h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 82245618h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245618h case    2:*/		return 0x8224561C;
		  /* 8224561Ch */ case    3:  		/* lwz R30, <#[R11 + 1452]> */
		/* 8224561Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005AC) );
		/* 8224561Ch case    3:*/		return 0x82245620;
		  /* 82245620h */ case    4:  		/* mr R3, R30 */
		/* 82245620h case    4:*/		regs.R3 = regs.R30;
		/* 82245620h case    4:*/		return 0x82245624;
		  /* 82245624h */ case    5:  		/* bl -168300 */
		/* 82245624h case    5:*/		regs.LR = 0x82245628; return 0x8221C4B8;
		/* 82245624h case    5:*/		return 0x82245628;
		  /* 82245628h */ case    6:  		/* mr R11, R3 */
		/* 82245628h case    6:*/		regs.R11 = regs.R3;
		/* 82245628h case    6:*/		return 0x8224562C;
		  /* 8224562Ch */ case    7:  		/* addic. R3, R3, 4 */
		/* 8224562Ch case    7:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8224562Ch case    7:*/		return 0x82245630;
		  /* 82245630h */ case    8:  		/* stw R30, <#[R11]> */
		/* 82245630h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82245630h case    8:*/		return 0x82245634;
		  /* 82245634h */ case    9:  		/* bc 12, CR0_EQ, 24 */
		/* 82245634h case    9:*/		if ( regs.CR[0].eq ) { return 0x8224564C;  }
		/* 82245634h case    9:*/		return 0x82245638;
		  /* 82245638h */ case   10:  		/* li R5, 0 */
		/* 82245638h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82245638h case   10:*/		return 0x8224563C;
		  /* 8224563Ch */ case   11:  		/* lwz R6, <#[R31]> */
		/* 8224563Ch case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 8224563Ch case   11:*/		return 0x82245640;
	}
	return 0x82245640;
} // Block from 82245610h-82245640h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82245640h
// Function '?HashKonstant1@VRegTable@XGRAPHICS@@CAHPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245640);
		  /* 82245640h */ case    0:  		/* li R4, 0 */
		/* 82245640h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82245640h case    0:*/		return 0x82245644;
		  /* 82245644h */ case    1:  		/* bl 60700 */
		/* 82245644h case    1:*/		regs.LR = 0x82245648; return 0x82254360;
		/* 82245644h case    1:*/		return 0x82245648;
	}
	return 0x82245648;
} // Block from 82245640h-82245648h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245648h
// Function '?HashKonstant2@VRegTable@XGRAPHICS@@CAHPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245648);
		  /* 82245648h */ case    0:  		/* b 8 */
		/* 82245648h case    0:*/		return 0x82245650;
		/* 82245648h case    0:*/		return 0x8224564C;
	}
	return 0x8224564C;
} // Block from 82245648h-8224564Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224564Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224564C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224564C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224564C);
		  /* 8224564Ch */ case    0:  		/* mr R3, R29 */
		/* 8224564Ch case    0:*/		regs.R3 = regs.R29;
		/* 8224564Ch case    0:*/		return 0x82245650;
	}
	return 0x82245650;
} // Block from 8224564Ch-82245650h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245650);
		  /* 82245650h */ case    0:  		/* stw R3, <#[R31 + 24]> */
		/* 82245650h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 82245650h case    0:*/		return 0x82245654;
		  /* 82245654h */ case    1:  		/* li R4, 964 */
		/* 82245654h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82245654h case    1:*/		return 0x82245658;
	}
	return 0x82245658;
} // Block from 82245650h-82245658h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245658h
// Function '?HashKonstant3@VRegTable@XGRAPHICS@@CAHPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245658);
		  /* 82245658h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82245658h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245658h case    0:*/		return 0x8224565C;
		  /* 8224565Ch */ case    1:  		/* lwz R30, <#[R11 + 1452]> */
		/* 8224565Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005AC) );
		/* 8224565Ch case    1:*/		return 0x82245660;
		  /* 82245660h */ case    2:  		/* mr R3, R30 */
		/* 82245660h case    2:*/		regs.R3 = regs.R30;
		/* 82245660h case    2:*/		return 0x82245664;
		  /* 82245664h */ case    3:  		/* bl -168364 */
		/* 82245664h case    3:*/		regs.LR = 0x82245668; return 0x8221C4B8;
		/* 82245664h case    3:*/		return 0x82245668;
		  /* 82245668h */ case    4:  		/* mr R11, R3 */
		/* 82245668h case    4:*/		regs.R11 = regs.R3;
		/* 82245668h case    4:*/		return 0x8224566C;
		  /* 8224566Ch */ case    5:  		/* addic. R3, R3, 4 */
		/* 8224566Ch case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8224566Ch case    5:*/		return 0x82245670;
	}
	return 0x82245670;
} // Block from 82245658h-82245670h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82245670h
// Function '?HashKonstant4@VRegTable@XGRAPHICS@@CAHPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245670);
		  /* 82245670h */ case    0:  		/* stw R30, <#[R11]> */
		/* 82245670h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82245670h case    0:*/		return 0x82245674;
		  /* 82245674h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82245674h case    1:*/		if ( regs.CR[0].eq ) { return 0x82245684;  }
		/* 82245674h case    1:*/		return 0x82245678;
		  /* 82245678h */ case    2:  		/* lwz R4, <#[R31]> */
		/* 82245678h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82245678h case    2:*/		return 0x8224567C;
		  /* 8224567Ch */ case    3:  		/* bl 72868 */
		/* 8224567Ch case    3:*/		regs.LR = 0x82245680; return 0x82257320;
		/* 8224567Ch case    3:*/		return 0x82245680;
		  /* 82245680h */ case    4:  		/* b 8 */
		/* 82245680h case    4:*/		return 0x82245688;
		/* 82245680h case    4:*/		return 0x82245684;
	}
	return 0x82245684;
} // Block from 82245670h-82245684h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82245684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245684);
		  /* 82245684h */ case    0:  		/* mr R3, R29 */
		/* 82245684h case    0:*/		regs.R3 = regs.R29;
		/* 82245684h case    0:*/		return 0x82245688;
	}
	return 0x82245688;
} // Block from 82245684h-82245688h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245688);
		  /* 82245688h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82245688h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245688h case    0:*/		return 0x8224568C;
		  /* 8224568Ch */ case    1:  		/* li R10, 1 */
		/* 8224568Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8224568Ch case    1:*/		return 0x82245690;
	}
	return 0x82245690;
} // Block from 82245688h-82245690h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245690h
// Function '?CompareKonstant1@VRegTable@XGRAPHICS@@CAHPAX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245690);
		  /* 82245690h */ case    0:  		/* stw R3, <#[R31 + 28]> */
		/* 82245690h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 82245690h case    0:*/		return 0x82245694;
		  /* 82245694h */ case    1:  		/* stw R29, <#[R11 + 1432]> */
		/* 82245694h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000598) );
		/* 82245694h case    1:*/		return 0x82245698;
		  /* 82245698h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 82245698h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245698h case    2:*/		return 0x8224569C;
		  /* 8224569Ch */ case    3:  		/* stw R29, <#[R11 + 1404]> */
		/* 8224569Ch case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x0000057C) );
		/* 8224569Ch case    3:*/		return 0x822456A0;
		  /* 822456A0h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 822456A0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822456A0h case    4:*/		return 0x822456A4;
		  /* 822456A4h */ case    5:  		/* stw R29, <#[R11 + 1408]> */
		/* 822456A4h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000580) );
		/* 822456A4h case    5:*/		return 0x822456A8;
		  /* 822456A8h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 822456A8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822456A8h case    6:*/		return 0x822456AC;
		  /* 822456ACh */ case    7:  		/* stw R10, <#[R11 + 1412]> */
		/* 822456ACh case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000584) );
		/* 822456ACh case    7:*/		return 0x822456B0;
		  /* 822456B0h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 822456B0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822456B0h case    8:*/		return 0x822456B4;
		  /* 822456B4h */ case    9:  		/* stw R29, <#[R11 + 1416]> */
		/* 822456B4h case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000588) );
		/* 822456B4h case    9:*/		return 0x822456B8;
		  /* 822456B8h */ case   10:  		/* addi R1, R1, 128 */
		/* 822456B8h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822456B8h case   10:*/		return 0x822456BC;
		  /* 822456BCh */ case   11:  		/* b -1786900 */
		/* 822456BCh case   11:*/		return 0x820912A8;
		/* 822456BCh case   11:*/		return 0x822456C0;
	}
	return 0x822456C0;
} // Block from 82245690h-822456C0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822456C0h
// Function '?CompareKonstant2@VRegTable@XGRAPHICS@@CAHPAX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822456C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822456C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822456C0);
		  /* 822456C0h */ case    0:  		/* mfspr R12, LR */
		/* 822456C0h case    0:*/		regs.R12 = regs.LR;
		/* 822456C0h case    0:*/		return 0x822456C4;
		  /* 822456C4h */ case    1:  		/* bl -1786984 */
		/* 822456C4h case    1:*/		regs.LR = 0x822456C8; return 0x8209125C;
		/* 822456C4h case    1:*/		return 0x822456C8;
		  /* 822456C8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 822456C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822456C8h case    2:*/		return 0x822456CC;
		  /* 822456CCh */ case    3:  		/* mr R30, R3 */
		/* 822456CCh case    3:*/		regs.R30 = regs.R3;
		/* 822456CCh case    3:*/		return 0x822456D0;
		  /* 822456D0h */ case    4:  		/* addi R3, R1, 80 */
		/* 822456D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 822456D0h case    4:*/		return 0x822456D4;
		  /* 822456D4h */ case    5:  		/* lwz R4, <#[R30 + 4]> */
		/* 822456D4h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000004) );
		/* 822456D4h case    5:*/		return 0x822456D8;
		  /* 822456D8h */ case    6:  		/* bl 59952 */
		/* 822456D8h case    6:*/		regs.LR = 0x822456DC; return 0x82254108;
		/* 822456D8h case    6:*/		return 0x822456DC;
		  /* 822456DCh */ case    7:  		/* b 32 */
		/* 822456DCh case    7:*/		return 0x822456FC;
		/* 822456DCh case    7:*/		return 0x822456E0;
		  /* 822456E0h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 822456E0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822456E0h case    8:*/		return 0x822456E4;
		  /* 822456E4h */ case    9:  		/* li R4, 1 */
		/* 822456E4h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822456E4h case    9:*/		return 0x822456E8;
		  /* 822456E8h */ case   10:  		/* lwz R11, <#[R11]> */
		/* 822456E8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822456E8h case   10:*/		return 0x822456EC;
		  /* 822456ECh */ case   11:  		/* mtspr CTR, R11 */
		/* 822456ECh case   11:*/		regs.CTR = regs.R11;
		/* 822456ECh case   11:*/		return 0x822456F0;
		  /* 822456F0h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 822456F0h case   12:*/		if ( 1 ) { regs.LR = 0x822456F4; return (uint32)regs.CTR; }
		/* 822456F0h case   12:*/		return 0x822456F4;
		  /* 822456F4h */ case   13:  		/* addi R3, R1, 80 */
		/* 822456F4h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 822456F4h case   13:*/		return 0x822456F8;
		  /* 822456F8h */ case   14:  		/* bl 59736 */
		/* 822456F8h case   14:*/		regs.LR = 0x822456FC; return 0x82254050;
		/* 822456F8h case   14:*/		return 0x822456FC;
	}
	return 0x822456FC;
} // Block from 822456C0h-822456FCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 822456FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822456FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822456FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822456FC);
		  /* 822456FCh */ case    0:  		/* lwz R3, <#[R1 + 96]> */
		/* 822456FCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 822456FCh case    0:*/		return 0x82245700;
		  /* 82245700h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82245700h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82245700h case    1:*/		return 0x82245704;
		  /* 82245704h */ case    2:  		/* stw R3, <#[R1 + 100]> */
		/* 82245704h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000064) );
		/* 82245704h case    2:*/		return 0x82245708;
		  /* 82245708h */ case    3:  		/* bc 4, CR6_EQ, -40 */
		/* 82245708h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822456E0;  }
		/* 82245708h case    3:*/		return 0x8224570C;
		  /* 8224570Ch */ case    4:  		/* lwz R31, <#[R30 + 4]> */
		/* 8224570Ch case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 8224570Ch case    4:*/		return 0x82245710;
	}
	return 0x82245710;
} // Block from 822456FCh-82245710h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82245710h
// Function '?CompareKonstant3@VRegTable@XGRAPHICS@@CAHPAX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245710);
		  /* 82245710h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82245710h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82245710h case    0:*/		return 0x82245714;
		  /* 82245714h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 82245714h case    1:*/		if ( regs.CR[6].eq ) { return 0x8224572C;  }
		/* 82245714h case    1:*/		return 0x82245718;
		  /* 82245718h */ case    2:  		/* mr R3, R31 */
		/* 82245718h case    2:*/		regs.R3 = regs.R31;
		/* 82245718h case    2:*/		return 0x8224571C;
		  /* 8224571Ch */ case    3:  		/* bl 59588 */
		/* 8224571Ch case    3:*/		regs.LR = 0x82245720; return 0x82253FE0;
		/* 8224571Ch case    3:*/		return 0x82245720;
		  /* 82245720h */ case    4:  		/* addi R4, R31, -4 */
		/* 82245720h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xFFFFFFFC);
		/* 82245720h case    4:*/		return 0x82245724;
		  /* 82245724h */ case    5:  		/* lwz R3, <#[R31 - 4]> */
		/* 82245724h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 82245724h case    5:*/		return 0x82245728;
		  /* 82245728h */ case    6:  		/* bl -168168 */
		/* 82245728h case    6:*/		regs.LR = 0x8224572C; return 0x8221C640;
		/* 82245728h case    6:*/		return 0x8224572C;
	}
	return 0x8224572C;
} // Block from 82245710h-8224572Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224572Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224572C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224572C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224572C);
		  /* 8224572Ch */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8224572Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8224572Ch case    0:*/		return 0x82245730;
		  /* 82245730h */ case    1:  		/* li R4, 28 */
		/* 82245730h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 82245730h case    1:*/		return 0x82245734;
		  /* 82245734h */ case    2:  		/* lwz R29, <#[R11 + 1452]> */
		/* 82245734h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005AC) );
		/* 82245734h case    2:*/		return 0x82245738;
		  /* 82245738h */ case    3:  		/* mr R3, R29 */
		/* 82245738h case    3:*/		regs.R3 = regs.R29;
		/* 82245738h case    3:*/		return 0x8224573C;
		  /* 8224573Ch */ case    4:  		/* bl -168580 */
		/* 8224573Ch case    4:*/		regs.LR = 0x82245740; return 0x8221C4B8;
		/* 8224573Ch case    4:*/		return 0x82245740;
		  /* 82245740h */ case    5:  		/* addic. R31, R3, 4 */
		/* 82245740h case    5:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82245740h case    5:*/		return 0x82245744;
		  /* 82245744h */ case    6:  		/* stw R29, <#[R3]> */
		/* 82245744h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82245744h case    6:*/		return 0x82245748;
		  /* 82245748h */ case    7:  		/* bc 12, CR0_EQ, 44 */
		/* 82245748h case    7:*/		if ( regs.CR[0].eq ) { return 0x82245774;  }
		/* 82245748h case    7:*/		return 0x8224574C;
		  /* 8224574Ch */ case    8:  		/* lwz R11, <#[R30]> */
		/* 8224574Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8224574Ch case    8:*/		return 0x82245750;
		  /* 82245750h */ case    9:  		/* lis R10, -32220 */
		/* 82245750h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8224);
		/* 82245750h case    9:*/		return 0x82245754;
		  /* 82245754h */ case   10:  		/* lis R9, -32220 */
		/* 82245754h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8224);
		/* 82245754h case   10:*/		return 0x82245758;
		  /* 82245758h */ case   11:  		/* li R7, 16 */
		/* 82245758h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 82245758h case   11:*/		return 0x8224575C;
		  /* 8224575Ch */ case   12:  		/* addi R6, R10, 20016 */
		/* 8224575Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x4E30);
		/* 8224575Ch case   12:*/		return 0x82245760;
		  /* 82245760h */ case   13:  		/* addi R5, R9, 20032 */
		/* 82245760h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x4E40);
		/* 82245760h case   13:*/		return 0x82245764;
		  /* 82245764h */ case   14:  		/* mr R3, R31 */
		/* 82245764h case   14:*/		regs.R3 = regs.R31;
		/* 82245764h case   14:*/		return 0x82245768;
		  /* 82245768h */ case   15:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82245768h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82245768h case   15:*/		return 0x8224576C;
		  /* 8224576Ch */ case   16:  		/* bl -2508 */
		/* 8224576Ch case   16:*/		regs.LR = 0x82245770; return 0x82244DA0;
		/* 8224576Ch case   16:*/		return 0x82245770;
		  /* 82245770h */ case   17:  		/* b 8 */
		/* 82245770h case   17:*/		return 0x82245778;
		/* 82245770h case   17:*/		return 0x82245774;
	}
	return 0x82245774;
} // Block from 8224572Ch-82245774h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82245774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245774);
		  /* 82245774h */ case    0:  		/* li R31, 0 */
		/* 82245774h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82245774h case    0:*/		return 0x82245778;
	}
	return 0x82245778;
} // Block from 82245774h-82245778h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245778);
		  /* 82245778h */ case    0:  		/* stw R31, <#[R30 + 4]> */
		/* 82245778h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 82245778h case    0:*/		return 0x8224577C;
		  /* 8224577Ch */ case    1:  		/* addi R1, R1, 144 */
		/* 8224577Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8224577Ch case    1:*/		return 0x82245780;
	}
	return 0x82245780;
} // Block from 82245778h-82245780h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245780h
// Function '?CompareKonstant4@VRegTable@XGRAPHICS@@CAHPAX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245780);
		  /* 82245780h */ case    0:  		/* b -1787092 */
		/* 82245780h case    0:*/		return 0x820912AC;
		/* 82245780h case    0:*/		return 0x82245784;
		  /* 82245784h */ case    1:  		/* nop */
		/* 82245784h case    1:*/		cpu::op::nop();
		/* 82245784h case    1:*/		return 0x82245788;
	}
	return 0x82245788;
} // Block from 82245780h-82245788h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245788h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245788);
		  /* 82245788h */ case    0:  		/* mfspr R12, LR */
		/* 82245788h case    0:*/		regs.R12 = regs.LR;
		/* 82245788h case    0:*/		return 0x8224578C;
		  /* 8224578Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224578Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224578Ch case    1:*/		return 0x82245790;
		  /* 82245790h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82245790h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82245790h case    2:*/		return 0x82245794;
		  /* 82245794h */ case    3:  		/* stwu R1, <#[R1 - 128]> */
		/* 82245794h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82245794h case    3:*/		return 0x82245798;
		  /* 82245798h */ case    4:  		/* mr R31, R3 */
		/* 82245798h case    4:*/		regs.R31 = regs.R3;
		/* 82245798h case    4:*/		return 0x8224579C;
		  /* 8224579Ch */ case    5:  		/* addi R3, R1, 80 */
		/* 8224579Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8224579Ch case    5:*/		return 0x822457A0;
		  /* 822457A0h */ case    6:  		/* lwz R4, <#[R31 + 4]> */
		/* 822457A0h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 822457A0h case    6:*/		return 0x822457A4;
		  /* 822457A4h */ case    7:  		/* bl 59748 */
		/* 822457A4h case    7:*/		regs.LR = 0x822457A8; return 0x82254108;
		/* 822457A4h case    7:*/		return 0x822457A8;
		  /* 822457A8h */ case    8:  		/* b 32 */
		/* 822457A8h case    8:*/		return 0x822457C8;
		/* 822457A8h case    8:*/		return 0x822457AC;
		  /* 822457ACh */ case    9:  		/* lwz R11, <#[R3]> */
		/* 822457ACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822457ACh case    9:*/		return 0x822457B0;
		  /* 822457B0h */ case   10:  		/* li R4, 1 */
		/* 822457B0h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822457B0h case   10:*/		return 0x822457B4;
		  /* 822457B4h */ case   11:  		/* lwz R11, <#[R11]> */
		/* 822457B4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822457B4h case   11:*/		return 0x822457B8;
		  /* 822457B8h */ case   12:  		/* mtspr CTR, R11 */
		/* 822457B8h case   12:*/		regs.CTR = regs.R11;
		/* 822457B8h case   12:*/		return 0x822457BC;
		  /* 822457BCh */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 822457BCh case   13:*/		if ( 1 ) { regs.LR = 0x822457C0; return (uint32)regs.CTR; }
		/* 822457BCh case   13:*/		return 0x822457C0;
		  /* 822457C0h */ case   14:  		/* addi R3, R1, 80 */
		/* 822457C0h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 822457C0h case   14:*/		return 0x822457C4;
		  /* 822457C4h */ case   15:  		/* bl 59532 */
		/* 822457C4h case   15:*/		regs.LR = 0x822457C8; return 0x82254050;
		/* 822457C4h case   15:*/		return 0x822457C8;
	}
	return 0x822457C8;
} // Block from 82245788h-822457C8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822457C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822457C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822457C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822457C8);
		  /* 822457C8h */ case    0:  		/* lwz R3, <#[R1 + 96]> */
		/* 822457C8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 822457C8h case    0:*/		return 0x822457CC;
		  /* 822457CCh */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 822457CCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 822457CCh case    1:*/		return 0x822457D0;
		  /* 822457D0h */ case    2:  		/* stw R3, <#[R1 + 100]> */
		/* 822457D0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000064) );
		/* 822457D0h case    2:*/		return 0x822457D4;
		  /* 822457D4h */ case    3:  		/* bc 4, CR6_EQ, -40 */
		/* 822457D4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822457AC;  }
		/* 822457D4h case    3:*/		return 0x822457D8;
		  /* 822457D8h */ case    4:  		/* lwz R31, <#[R31 + 4]> */
		/* 822457D8h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 822457D8h case    4:*/		return 0x822457DC;
		  /* 822457DCh */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 822457DCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 822457DCh case    5:*/		return 0x822457E0;
		  /* 822457E0h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 822457E0h case    6:*/		if ( regs.CR[6].eq ) { return 0x822457F8;  }
		/* 822457E0h case    6:*/		return 0x822457E4;
		  /* 822457E4h */ case    7:  		/* mr R3, R31 */
		/* 822457E4h case    7:*/		regs.R3 = regs.R31;
		/* 822457E4h case    7:*/		return 0x822457E8;
		  /* 822457E8h */ case    8:  		/* bl 59384 */
		/* 822457E8h case    8:*/		regs.LR = 0x822457EC; return 0x82253FE0;
		/* 822457E8h case    8:*/		return 0x822457EC;
		  /* 822457ECh */ case    9:  		/* addi R4, R31, -4 */
		/* 822457ECh case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xFFFFFFFC);
		/* 822457ECh case    9:*/		return 0x822457F0;
		  /* 822457F0h */ case   10:  		/* lwz R3, <#[R31 - 4]> */
		/* 822457F0h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 822457F0h case   10:*/		return 0x822457F4;
		  /* 822457F4h */ case   11:  		/* bl -168372 */
		/* 822457F4h case   11:*/		regs.LR = 0x822457F8; return 0x8221C640;
		/* 822457F4h case   11:*/		return 0x822457F8;
	}
	return 0x822457F8;
} // Block from 822457C8h-822457F8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822457F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822457F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822457F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822457F8);
		  /* 822457F8h */ case    0:  		/* addi R1, R1, 128 */
		/* 822457F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822457F8h case    0:*/		return 0x822457FC;
		  /* 822457FCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822457FCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822457FCh case    1:*/		return 0x82245800;
		  /* 82245800h */ case    2:  		/* mtspr LR, R12 */
		/* 82245800h case    2:*/		regs.LR = regs.R12;
		/* 82245800h case    2:*/		return 0x82245804;
		  /* 82245804h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82245804h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82245804h case    3:*/		return 0x82245808;
		  /* 82245808h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82245808h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82245808h case    4:*/		return 0x8224580C;
	}
	return 0x8224580C;
} // Block from 822457F8h-8224580Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224580Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224580C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224580C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224580C);
		  /* 8224580Ch */ case    0:  		/* nop */
		/* 8224580Ch case    0:*/		cpu::op::nop();
		/* 8224580Ch case    0:*/		return 0x82245810;
	}
	return 0x82245810;
} // Block from 8224580Ch-82245810h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245810h
// Function '??0VRegTable@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245810);
		  /* 82245810h */ case    0:  		/* mfspr R12, LR */
		/* 82245810h case    0:*/		regs.R12 = regs.LR;
		/* 82245810h case    0:*/		return 0x82245814;
		  /* 82245814h */ case    1:  		/* bl -1787320 */
		/* 82245814h case    1:*/		regs.LR = 0x82245818; return 0x8209125C;
		/* 82245814h case    1:*/		return 0x82245818;
	}
	return 0x82245818;
} // Block from 82245810h-82245818h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245818h
// Function '?compare_floats@XGRAPHICS@@YAHPAX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245818);
		  /* 82245818h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82245818h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82245818h case    0:*/		return 0x8224581C;
		  /* 8224581Ch */ case    1:  		/* lwz R11, <#[R3 + 24]> */
		/* 8224581Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8224581Ch case    1:*/		return 0x82245820;
		  /* 82245820h */ case    2:  		/* mr R30, R4 */
		/* 82245820h case    2:*/		regs.R30 = regs.R4;
		/* 82245820h case    2:*/		return 0x82245824;
		  /* 82245824h */ case    3:  		/* mr R31, R3 */
		/* 82245824h case    3:*/		regs.R31 = regs.R3;
		/* 82245824h case    3:*/		return 0x82245828;
		  /* 82245828h */ case    4:  		/* mr R29, R5 */
		/* 82245828h case    4:*/		regs.R29 = regs.R5;
		/* 82245828h case    4:*/		return 0x8224582C;
		  /* 8224582Ch */ case    5:  		/* stw R5, <#[R11 + 12]> */
		/* 8224582Ch case    5:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 8224582Ch case    5:*/		return 0x82245830;
		  /* 82245830h */ case    6:  		/* lwz R11, <#[R3 + 24]> */
		/* 82245830h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82245830h case    6:*/		return 0x82245834;
		  /* 82245834h */ case    7:  		/* stw R4, <#[R11 + 32]> */
		/* 82245834h case    7:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000020) );
		/* 82245834h case    7:*/		return 0x82245838;
		  /* 82245838h */ case    8:  		/* lwz R4, <#[R3 + 24]> */
		/* 82245838h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000018) );
		/* 82245838h case    8:*/		return 0x8224583C;
		  /* 8224583Ch */ case    9:  		/* lwz R3, <#[R3 + 4]> */
		/* 8224583Ch case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 8224583Ch case    9:*/		return 0x82245840;
	}
	return 0x82245840;
} // Block from 82245818h-82245840h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82245840h
// Function '?find_bit@XGRAPHICS@@YAHPAHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245840);
		  /* 82245840h */ case    0:  		/* bl 58680 */
		/* 82245840h case    0:*/		regs.LR = 0x82245844; return 0x82253D78;
		/* 82245840h case    0:*/		return 0x82245844;
		  /* 82245844h */ case    1:  		/* cmplwi CR0, R3, 0 */
		/* 82245844h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82245844h case    1:*/		return 0x82245848;
		  /* 82245848h */ case    2:  		/* bc 4, CR0_EQ, 20 */
		/* 82245848h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8224585C;  }
		/* 82245848h case    2:*/		return 0x8224584C;
		  /* 8224584Ch */ case    3:  		/* mr R5, R29 */
		/* 8224584Ch case    3:*/		regs.R5 = regs.R29;
		/* 8224584Ch case    3:*/		return 0x82245850;
		  /* 82245850h */ case    4:  		/* mr R4, R30 */
		/* 82245850h case    4:*/		regs.R4 = regs.R30;
		/* 82245850h case    4:*/		return 0x82245854;
		  /* 82245854h */ case    5:  		/* mr R3, R31 */
		/* 82245854h case    5:*/		regs.R3 = regs.R31;
		/* 82245854h case    5:*/		return 0x82245858;
		  /* 82245858h */ case    6:  		/* bl -2352 */
		/* 82245858h case    6:*/		regs.LR = 0x8224585C; return 0x82244F28;
		/* 82245858h case    6:*/		return 0x8224585C;
	}
	return 0x8224585C;
} // Block from 82245840h-8224585Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224585Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224585C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224585C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224585C);
		  /* 8224585Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8224585Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224585Ch case    0:*/		return 0x82245860;
		  /* 82245860h */ case    1:  		/* b -1787316 */
		/* 82245860h case    1:*/		return 0x820912AC;
		/* 82245860h case    1:*/		return 0x82245864;
		  /* 82245864h */ case    2:  		/* nop */
		/* 82245864h case    2:*/		cpu::op::nop();
		/* 82245864h case    2:*/		return 0x82245868;
	}
	return 0x82245868;
} // Block from 8224585Ch-82245868h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82245868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245868);
		  /* 82245868h */ case    0:  		/* mfspr R12, LR */
		/* 82245868h case    0:*/		regs.R12 = regs.LR;
		/* 82245868h case    0:*/		return 0x8224586C;
		  /* 8224586Ch */ case    1:  		/* bl -1787412 */
		/* 8224586Ch case    1:*/		regs.LR = 0x82245870; return 0x82091258;
		/* 8224586Ch case    1:*/		return 0x82245870;
		  /* 82245870h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82245870h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82245870h case    2:*/		return 0x82245874;
		  /* 82245874h */ case    3:  		/* lwz R11, <#[R3 + 24]> */
		/* 82245874h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82245874h case    3:*/		return 0x82245878;
		  /* 82245878h */ case    4:  		/* mr R30, R4 */
		/* 82245878h case    4:*/		regs.R30 = regs.R4;
		/* 82245878h case    4:*/		return 0x8224587C;
		  /* 8224587Ch */ case    5:  		/* mr R31, R3 */
		/* 8224587Ch case    5:*/		regs.R31 = regs.R3;
		/* 8224587Ch case    5:*/		return 0x82245880;
		  /* 82245880h */ case    6:  		/* mr R29, R5 */
		/* 82245880h case    6:*/		regs.R29 = regs.R5;
		/* 82245880h case    6:*/		return 0x82245884;
		  /* 82245884h */ case    7:  		/* mr R28, R6 */
		/* 82245884h case    7:*/		regs.R28 = regs.R6;
		/* 82245884h case    7:*/		return 0x82245888;
		  /* 82245888h */ case    8:  		/* stw R5, <#[R11 + 12]> */
		/* 82245888h case    8:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 82245888h case    8:*/		return 0x8224588C;
		  /* 8224588Ch */ case    9:  		/* lwz R11, <#[R3 + 24]> */
		/* 8224588Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8224588Ch case    9:*/		return 0x82245890;
		  /* 82245890h */ case   10:  		/* stw R4, <#[R11 + 32]> */
		/* 82245890h case   10:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000020) );
		/* 82245890h case   10:*/		return 0x82245894;
		  /* 82245894h */ case   11:  		/* lwz R4, <#[R3 + 24]> */
		/* 82245894h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000018) );
		/* 82245894h case   11:*/		return 0x82245898;
		  /* 82245898h */ case   12:  		/* lwz R3, <#[R3 + 4]> */
		/* 82245898h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 82245898h case   12:*/		return 0x8224589C;
		  /* 8224589Ch */ case   13:  		/* bl 58588 */
		/* 8224589Ch case   13:*/		regs.LR = 0x822458A0; return 0x82253D78;
		/* 8224589Ch case   13:*/		return 0x822458A0;
		  /* 822458A0h */ case   14:  		/* cmplwi CR0, R3, 0 */
		/* 822458A0h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 822458A0h case   14:*/		return 0x822458A4;
		  /* 822458A4h */ case   15:  		/* bc 4, CR0_EQ, 24 */
		/* 822458A4h case   15:*/		if ( !regs.CR[0].eq ) { return 0x822458BC;  }
		/* 822458A4h case   15:*/		return 0x822458A8;
	}
	return 0x822458A8;
} // Block from 82245868h-822458A8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822458A8h
// Function '?print_konst@XGRAPHICS@@YAXUkonst@1@PAD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822458A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822458A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822458A8);
		  /* 822458A8h */ case    0:  		/* mr R6, R28 */
		/* 822458A8h case    0:*/		regs.R6 = regs.R28;
		/* 822458A8h case    0:*/		return 0x822458AC;
		  /* 822458ACh */ case    1:  		/* mr R5, R29 */
		/* 822458ACh case    1:*/		regs.R5 = regs.R29;
		/* 822458ACh case    1:*/		return 0x822458B0;
		  /* 822458B0h */ case    2:  		/* mr R4, R30 */
		/* 822458B0h case    2:*/		regs.R4 = regs.R30;
		/* 822458B0h case    2:*/		return 0x822458B4;
		  /* 822458B4h */ case    3:  		/* mr R3, R31 */
		/* 822458B4h case    3:*/		regs.R3 = regs.R31;
		/* 822458B4h case    3:*/		return 0x822458B8;
		  /* 822458B8h */ case    4:  		/* bl -2368 */
		/* 822458B8h case    4:*/		regs.LR = 0x822458BC; return 0x82244F78;
		/* 822458B8h case    4:*/		return 0x822458BC;
	}
	return 0x822458BC;
} // Block from 822458A8h-822458BCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822458BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822458BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822458BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822458BC);
		  /* 822458BCh */ case    0:  		/* addi R1, R1, 128 */
		/* 822458BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822458BCh case    0:*/		return 0x822458C0;
		  /* 822458C0h */ case    1:  		/* b -1787416 */
		/* 822458C0h case    1:*/		return 0x820912A8;
		/* 822458C0h case    1:*/		return 0x822458C4;
		  /* 822458C4h */ case    2:  		/* nop */
		/* 822458C4h case    2:*/		cpu::op::nop();
		/* 822458C4h case    2:*/		return 0x822458C8;
	}
	return 0x822458C8;
} // Block from 822458BCh-822458C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822458C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822458C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822458C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822458C8);
		  /* 822458C8h */ case    0:  		/* mfspr R12, LR */
		/* 822458C8h case    0:*/		regs.R12 = regs.LR;
		/* 822458C8h case    0:*/		return 0x822458CC;
		  /* 822458CCh */ case    1:  		/* bl -1787540 */
		/* 822458CCh case    1:*/		regs.LR = 0x822458D0; return 0x82091238;
		/* 822458CCh case    1:*/		return 0x822458D0;
		  /* 822458D0h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 822458D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 822458D0h case    2:*/		return 0x822458D4;
		  /* 822458D4h */ case    3:  		/* lwz R9, <#[R3]> */
		/* 822458D4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 822458D4h case    3:*/		return 0x822458D8;
		  /* 822458D8h */ case    4:  		/* lis R11, -32253 */
		/* 822458D8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 822458D8h case    4:*/		return 0x822458DC;
		  /* 822458DCh */ case    5:  		/* std R5, <#[R1 + 272]> */
		/* 822458DCh case    5:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000110) );
		/* 822458DCh case    5:*/		return 0x822458E0;
		  /* 822458E0h */ case    6:  		/* lis R10, -32252 */
		/* 822458E0h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822458E0h case    6:*/		return 0x822458E4;
		  /* 822458E4h */ case    7:  		/* addi R29, R11, 27460 */
		/* 822458E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x6B44);
		/* 822458E4h case    7:*/		return 0x822458E8;
		  /* 822458E8h */ case    8:  		/* std R6, <#[R1 + 280]> */
		/* 822458E8h case    8:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000118) );
		/* 822458E8h case    8:*/		return 0x822458EC;
		  /* 822458ECh */ case    9:  		/* std R7, <#[R1 + 288]> */
		/* 822458ECh case    9:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000120) );
		/* 822458ECh case    9:*/		return 0x822458F0;
		  /* 822458F0h */ case   10:  		/* mr R31, R3 */
		/* 822458F0h case   10:*/		regs.R31 = regs.R3;
		/* 822458F0h case   10:*/		return 0x822458F4;
		  /* 822458F4h */ case   11:  		/* mr R25, R4 */
		/* 822458F4h case   11:*/		regs.R25 = regs.R4;
		/* 822458F4h case   11:*/		return 0x822458F8;
		  /* 822458F8h */ case   12:  		/* std R8, <#[R1 + 296]> */
		/* 822458F8h case   12:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000128) );
		/* 822458F8h case   12:*/		return 0x822458FC;
		  /* 822458FCh */ case   13:  		/* lbz R11, <#[R9 + 1393]> */
		/* 822458FCh case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000571) );
		/* 822458FCh case   13:*/		return 0x82245900;
		  /* 82245900h */ case   14:  		/* addi R28, R10, 12584 */
		/* 82245900h case   14:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0x3128);
		/* 82245900h case   14:*/		return 0x82245904;
		  /* 82245904h */ case   15:  		/* cmplwi CR0, R11, 0 */
		/* 82245904h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82245904h case   15:*/		return 0x82245908;
	}
	return 0x82245908;
} // Block from 822458C8h-82245908h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82245908h
// Function '??0InternalHashTable@XGRAPHICS@@IAA@PAVArena@1@P6AHPAX1@ZP6AH1@ZI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245908);
		  /* 82245908h */ case    0:  		/* bc 12, CR0_EQ, 32 */
		/* 82245908h case    0:*/		if ( regs.CR[0].eq ) { return 0x82245928;  }
		/* 82245908h case    0:*/		return 0x8224590C;
		  /* 8224590Ch */ case    1:  		/* lis R11, -32252 */
		/* 8224590Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224590Ch case    1:*/		return 0x82245910;
		  /* 82245910h */ case    2:  		/* mr R6, R28 */
		/* 82245910h case    2:*/		regs.R6 = regs.R28;
		/* 82245910h case    2:*/		return 0x82245914;
		  /* 82245914h */ case    3:  		/* addi R5, R11, 12708 */
		/* 82245914h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x31A4);
		/* 82245914h case    3:*/		return 0x82245918;
		  /* 82245918h */ case    4:  		/* mr R4, R29 */
		/* 82245918h case    4:*/		regs.R4 = regs.R29;
		/* 82245918h case    4:*/		return 0x8224591C;
		  /* 8224591Ch */ case    5:  		/* li R7, 343 */
		/* 8224591Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x157);
		/* 8224591Ch case    5:*/		return 0x82245920;
		  /* 82245920h */ case    6:  		/* li R3, 0 */
		/* 82245920h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82245920h case    6:*/		return 0x82245924;
		  /* 82245924h */ case    7:  		/* bl -974108 */
		/* 82245924h case    7:*/		regs.LR = 0x82245928; return 0x82157C08;
		/* 82245924h case    7:*/		return 0x82245928;
	}
	return 0x82245928;
} // Block from 82245908h-82245928h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82245928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245928);
		  /* 82245928h */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 82245928h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82245928h case    0:*/		return 0x8224592C;
		  /* 8224592Ch */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 8224592Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x82245938;  }
		/* 8224592Ch case    1:*/		return 0x82245930;
		  /* 82245930h */ case    2:  		/* cmpwi CR6, R25, 5 */
		/* 82245930h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000005);
		/* 82245930h case    2:*/		return 0x82245934;
		  /* 82245934h */ case    3:  		/* bc 12, CR6_LT, 32 */
		/* 82245934h case    3:*/		if ( regs.CR[6].lt ) { return 0x82245954;  }
		/* 82245934h case    3:*/		return 0x82245938;
	}
	return 0x82245938;
} // Block from 82245928h-82245938h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82245938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245938);
		  /* 82245938h */ case    0:  		/* lis R11, -32252 */
		/* 82245938h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82245938h case    0:*/		return 0x8224593C;
		  /* 8224593Ch */ case    1:  		/* mr R6, R28 */
		/* 8224593Ch case    1:*/		regs.R6 = regs.R28;
		/* 8224593Ch case    1:*/		return 0x82245940;
		  /* 82245940h */ case    2:  		/* addi R5, R11, 12516 */
		/* 82245940h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x30E4);
		/* 82245940h case    2:*/		return 0x82245944;
		  /* 82245944h */ case    3:  		/* mr R4, R29 */
		/* 82245944h case    3:*/		regs.R4 = regs.R29;
		/* 82245944h case    3:*/		return 0x82245948;
		  /* 82245948h */ case    4:  		/* li R7, 346 */
		/* 82245948h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x15A);
		/* 82245948h case    4:*/		return 0x8224594C;
		  /* 8224594Ch */ case    5:  		/* li R3, 0 */
		/* 8224594Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224594Ch case    5:*/		return 0x82245950;
		  /* 82245950h */ case    6:  		/* bl -974152 */
		/* 82245950h case    6:*/		regs.LR = 0x82245954; return 0x82157C08;
		/* 82245950h case    6:*/		return 0x82245954;
	}
	return 0x82245954;
} // Block from 82245938h-82245954h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82245954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245954);
		  /* 82245954h */ case    0:  		/* lwz R27, <#[R1 + 280]> */
		/* 82245954h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000118) );
		/* 82245954h case    0:*/		return 0x82245958;
		  /* 82245958h */ case    1:  		/* li R11, 4 */
		/* 82245958h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82245958h case    1:*/		return 0x8224595C;
		  /* 8224595Ch */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8224595Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8224595Ch case    2:*/		return 0x82245960;
		  /* 82245960h */ case    3:  		/* li R26, 0 */
		/* 82245960h case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82245960h case    3:*/		return 0x82245964;
		  /* 82245964h */ case    4:  		/* lwz R8, <#[R31 + 12]> */
		/* 82245964h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 82245964h case    4:*/		return 0x82245968;
		  /* 82245968h */ case    5:  		/* addi R7, R1, 96 */
		/* 82245968h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82245968h case    5:*/		return 0x8224596C;
		  /* 8224596Ch */ case    6:  		/* lwz R5, <#[R31 + 16]> */
		/* 8224596Ch case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 8224596Ch case    6:*/		return 0x82245970;
		  /* 82245970h */ case    7:  		/* mr R6, R26 */
		/* 82245970h case    7:*/		regs.R6 = regs.R26;
		/* 82245970h case    7:*/		return 0x82245974;
		  /* 82245974h */ case    8:  		/* lwz R4, <#[R1 + 272]> */
		/* 82245974h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000110) );
		/* 82245974h case    8:*/		return 0x82245978;
		  /* 82245978h */ case    9:  		/* li R9, 928 */
		/* 82245978h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x3A0);
		/* 82245978h case    9:*/		return 0x8224597C;
		  /* 8224597Ch */ case   10:  		/* lwz R3, <#[R31 + 20]> */
		/* 8224597Ch case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 8224597Ch case   10:*/		return 0x82245980;
		  /* 82245980h */ case   11:  		/* mtspr CTR, R11 */
		/* 82245980h case   11:*/		regs.CTR = regs.R11;
		/* 82245980h case   11:*/		return 0x82245984;
		  /* 82245984h */ case   12:  		/* lwz R30, <#[R1 + 276]> */
		/* 82245984h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000114) );
		/* 82245984h case   12:*/		return 0x82245988;
		  /* 82245988h */ case   13:  		/* addi R11, R1, 96 */
		/* 82245988h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82245988h case   13:*/		return 0x8224598C;
		  /* 8224598Ch */ case   14:  		/* lwz R24, <#[R1 + 284]> */
		/* 8224598Ch case   14:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x0000011C) );
		/* 8224598Ch case   14:*/		return 0x82245990;
		  /* 82245990h */ case   15:  		/* subfic R7, R7, 896 */
		/* 82245990h case   15:*/		cpu::op::subfic<0>(regs,&regs.R7,regs.R7,0x380);
		/* 82245990h case   15:*/		return 0x82245994;
		  /* 82245994h */ case   16:  		/* lwz R23, <#[R1 + 288]> */
		/* 82245994h case   16:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x00000120) );
		/* 82245994h case   16:*/		return 0x82245998;
	}
	return 0x82245998;
} // Block from 82245954h-82245998h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82245998h
// Function '?HashVRegInfo@XGRAPHICS@@YAHPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245998);
		  /* 82245998h */ case    0:  		/* lwz R22, <#[R1 + 292]> */
		/* 82245998h case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000124) );
		/* 82245998h case    0:*/		return 0x8224599C;
		  /* 8224599Ch */ case    1:  		/* lwz R21, <#[R1 + 296]> */
		/* 8224599Ch case    1:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000128) );
		/* 8224599Ch case    1:*/		return 0x822459A0;
		  /* 822459A0h */ case    2:  		/* lwz R20, <#[R1 + 300]> */
		/* 822459A0h case    2:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x0000012C) );
		/* 822459A0h case    2:*/		return 0x822459A4;
		  /* 822459A4h */ case    3:  		/* stw R27, <#[R1 + 104]> */
		/* 822459A4h case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000068) );
		/* 822459A4h case    3:*/		return 0x822459A8;
	}
	return 0x822459A8;
} // Block from 82245998h-822459A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822459A8h
// Function '?CompareVRegInfo@XGRAPHICS@@YAHPAX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822459A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822459A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822459A8);
		  /* 822459A8h */ case    0:  		/* li R27, 1 */
		/* 822459A8h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 822459A8h case    0:*/		return 0x822459AC;
		  /* 822459ACh */ case    1:  		/* stw R10, <#[R1 + 80]> */
		/* 822459ACh case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 822459ACh case    1:*/		return 0x822459B0;
		  /* 822459B0h */ case    2:  		/* stw R8, <#[R1 + 84]> */
		/* 822459B0h case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 822459B0h case    2:*/		return 0x822459B4;
		  /* 822459B4h */ case    3:  		/* stw R5, <#[R1 + 88]> */
		/* 822459B4h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 822459B4h case    3:*/		return 0x822459B8;
		  /* 822459B8h */ case    4:  		/* stw R4, <#[R1 + 96]> */
		/* 822459B8h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 822459B8h case    4:*/		return 0x822459BC;
		  /* 822459BCh */ case    5:  		/* stw R3, <#[R1 + 92]> */
		/* 822459BCh case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 822459BCh case    5:*/		return 0x822459C0;
		  /* 822459C0h */ case    6:  		/* stw R30, <#[R1 + 100]> */
		/* 822459C0h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 822459C0h case    6:*/		return 0x822459C4;
		  /* 822459C4h */ case    7:  		/* stw R24, <#[R1 + 108]> */
		/* 822459C4h case    7:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x0000006C) );
		/* 822459C4h case    7:*/		return 0x822459C8;
		  /* 822459C8h */ case    8:  		/* stw R23, <#[R1 + 112]> */
		/* 822459C8h case    8:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000070) );
		/* 822459C8h case    8:*/		return 0x822459CC;
		  /* 822459CCh */ case    9:  		/* stw R22, <#[R1 + 116]> */
		/* 822459CCh case    9:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000074) );
		/* 822459CCh case    9:*/		return 0x822459D0;
		  /* 822459D0h */ case   10:  		/* stw R21, <#[R1 + 120]> */
		/* 822459D0h case   10:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000078) );
		/* 822459D0h case   10:*/		return 0x822459D4;
		  /* 822459D4h */ case   11:  		/* stw R20, <#[R1 + 124]> */
		/* 822459D4h case   11:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x0000007C) );
		/* 822459D4h case   11:*/		return 0x822459D8;
	}
	return 0x822459D8;
} // Block from 822459A8h-822459D8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822459D8h
// Function '?NextKonstRegNum@VRegTable@XGRAPHICS@@AAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822459D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822459D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822459D8);
		  /* 822459D8h */ case    0:  		/* lwz R10, <#[R31 + 28]> */
		/* 822459D8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 822459D8h case    0:*/		return 0x822459DC;
		  /* 822459DCh */ case    1:  		/* cmpw CR6, R6, R25 */
		/* 822459DCh case    1:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R25);
		/* 822459DCh case    1:*/		return 0x822459E0;
		  /* 822459E0h */ case    2:  		/* bc 4, CR6_LT, 40 */
		/* 822459E0h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82245A08;  }
		/* 822459E0h case    2:*/		return 0x822459E4;
		  /* 822459E4h */ case    3:  		/* add R8, R7, R11 */
		/* 822459E4h case    3:*/		cpu::op::add<0>(regs,&regs.R8,regs.R7,regs.R11);
		/* 822459E4h case    3:*/		return 0x822459E8;
		  /* 822459E8h */ case    4:  		/* stwx R27, <#[R9 + R10]> */
		/* 822459E8h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 822459E8h case    4:*/		return 0x822459EC;
		  /* 822459ECh */ case    5:  		/* lwz R10, <#[R31 + 28]> */
		/* 822459ECh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 822459ECh case    5:*/		return 0x822459F0;
		  /* 822459F0h */ case    6:  		/* lwz R5, <#[R11]> */
		/* 822459F0h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 822459F0h case    6:*/		return 0x822459F4;
		  /* 822459F4h */ case    7:  		/* add R10, R8, R10 */
		/* 822459F4h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 822459F4h case    7:*/		return 0x822459F8;
		  /* 822459F8h */ case    8:  		/* lwz R4, <#[R11 + 4]> */
		/* 822459F8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 822459F8h case    8:*/		return 0x822459FC;
		  /* 822459FCh */ case    9:  		/* stw R5, <#[R10]> */
		/* 822459FCh case    9:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 822459FCh case    9:*/		return 0x82245A00;
		  /* 82245A00h */ case   10:  		/* stw R4, <#[R10 + 4]> */
		/* 82245A00h case   10:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 82245A00h case   10:*/		return 0x82245A04;
		  /* 82245A04h */ case   11:  		/* b 8 */
		/* 82245A04h case   11:*/		return 0x82245A0C;
		/* 82245A04h case   11:*/		return 0x82245A08;
	}
	return 0x82245A08;
} // Block from 822459D8h-82245A08h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82245A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245A08);
		  /* 82245A08h */ case    0:  		/* stwx R26, <#[R9 + R10]> */
		/* 82245A08h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82245A08h case    0:*/		return 0x82245A0C;
	}
	return 0x82245A0C;
} // Block from 82245A08h-82245A0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245A0C);
		  /* 82245A0Ch */ case    0:  		/* addi R6, R6, 1 */
		/* 82245A0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82245A0Ch case    0:*/		return 0x82245A10;
		  /* 82245A10h */ case    1:  		/* addi R9, R9, 4 */
		/* 82245A10h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82245A10h case    1:*/		return 0x82245A14;
		  /* 82245A14h */ case    2:  		/* addi R11, R11, 8 */
		/* 82245A14h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82245A14h case    2:*/		return 0x82245A18;
		  /* 82245A18h */ case    3:  		/* bc 16, CR0_LT, -64 */
		/* 82245A18h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822459D8;  }
		/* 82245A18h case    3:*/		return 0x82245A1C;
		  /* 82245A1Ch */ case    4:  		/* rlwinm R10, R25, 2, 0, 29 */
		/* 82245A1Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R25);
		/* 82245A1Ch case    4:*/		return 0x82245A20;
		  /* 82245A20h */ case    5:  		/* lwz R4, <#[R31 + 28]> */
		/* 82245A20h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000001C) );
		/* 82245A20h case    5:*/		return 0x82245A24;
		  /* 82245A24h */ case    6:  		/* addi R11, R1, 80 */
		/* 82245A24h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 82245A24h case    6:*/		return 0x82245A28;
		  /* 82245A28h */ case    7:  		/* add R11, R10, R11 */
		/* 82245A28h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82245A28h case    7:*/		return 0x82245A2C;
		  /* 82245A2Ch */ case    8:  		/* lwz R30, <#[R11 - 4]> */
		/* 82245A2Ch case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82245A2Ch case    8:*/		return 0x82245A30;
		  /* 82245A30h */ case    9:  		/* mr R3, R30 */
		/* 82245A30h case    9:*/		regs.R3 = regs.R30;
		/* 82245A30h case    9:*/		return 0x82245A34;
		  /* 82245A34h */ case   10:  		/* bl 58180 */
		/* 82245A34h case   10:*/		regs.LR = 0x82245A38; return 0x82253D78;
		/* 82245A34h case   10:*/		return 0x82245A38;
	}
	return 0x82245A38;
} // Block from 82245A0Ch-82245A38h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82245A38h
// Function '?Find@VRegTable@XGRAPHICS@@QAAPAVVRegInfo@2@AAVIRInst@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245A38);
		  /* 82245A38h */ case    0:  		/* cmplwi CR0, R3, 0 */
		/* 82245A38h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82245A38h case    0:*/		return 0x82245A3C;
		  /* 82245A3Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82245A3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82245A48;  }
		/* 82245A3Ch case    1:*/		return 0x82245A40;
		  /* 82245A40h */ case    2:  		/* lwz R31, <#[R3 + 28]> */
		/* 82245A40h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x0000001C) );
		/* 82245A40h case    2:*/		return 0x82245A44;
		  /* 82245A44h */ case    3:  		/* b 200 */
		/* 82245A44h case    3:*/		return 0x82245B0C;
		/* 82245A44h case    3:*/		return 0x82245A48;
	}
	return 0x82245A48;
} // Block from 82245A38h-82245A48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82245A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245A48);
		  /* 82245A48h */ case    0:  		/* lwz R11, <#[R31 + 36]> */
		/* 82245A48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 82245A48h case    0:*/		return 0x82245A4C;
		  /* 82245A4Ch */ case    1:  		/* li R4, 11 */
		/* 82245A4Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xB);
		/* 82245A4Ch case    1:*/		return 0x82245A50;
		  /* 82245A50h */ case    2:  		/* mr R3, R31 */
		/* 82245A50h case    2:*/		regs.R3 = regs.R31;
		/* 82245A50h case    2:*/		return 0x82245A54;
		  /* 82245A54h */ case    3:  		/* addi R5, R11, 1 */
		/* 82245A54h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 82245A54h case    3:*/		return 0x82245A58;
		  /* 82245A58h */ case    4:  		/* stw R5, <#[R31 + 36]> */
		/* 82245A58h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x00000024) );
		/* 82245A58h case    4:*/		return 0x82245A5C;
		  /* 82245A5Ch */ case    5:  		/* bl -2868 */
		/* 82245A5Ch case    5:*/		regs.LR = 0x82245A60; return 0x82244F28;
		/* 82245A5Ch case    5:*/		return 0x82245A60;
		  /* 82245A60h */ case    6:  		/* lwz R11, <#[R3 + 40]> */
		/* 82245A60h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82245A60h case    6:*/		return 0x82245A64;
		  /* 82245A64h */ case    7:  		/* mr R31, R3 */
		/* 82245A64h case    7:*/		regs.R31 = regs.R3;
		/* 82245A64h case    7:*/		return 0x82245A68;
		  /* 82245A68h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 82245A68h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82245A68h case    8:*/		return 0x82245A6C;
		  /* 82245A6Ch */ case    9:  		/* cmplwi CR6, R11, 1 */
		/* 82245A6Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82245A6Ch case    9:*/		return 0x82245A70;
	}
	return 0x82245A70;
} // Block from 82245A48h-82245A70h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82245A70h
// Function '?Find@VRegTable@XGRAPHICS@@QAAPAVVRegInfo@2@W4RegType@R400Tables@@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245A70);
		  /* 82245A70h */ case    0:  		/* bc 12, CR6_EQ, 32 */
		/* 82245A70h case    0:*/		if ( regs.CR[6].eq ) { return 0x82245A90;  }
		/* 82245A70h case    0:*/		return 0x82245A74;
		  /* 82245A74h */ case    1:  		/* lis R11, -32252 */
		/* 82245A74h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82245A74h case    1:*/		return 0x82245A78;
		  /* 82245A78h */ case    2:  		/* mr R6, R28 */
		/* 82245A78h case    2:*/		regs.R6 = regs.R28;
		/* 82245A78h case    2:*/		return 0x82245A7C;
		  /* 82245A7Ch */ case    3:  		/* addi R5, R11, 12680 */
		/* 82245A7Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3188);
		/* 82245A7Ch case    3:*/		return 0x82245A80;
		  /* 82245A80h */ case    4:  		/* mr R4, R29 */
		/* 82245A80h case    4:*/		regs.R4 = regs.R29;
		/* 82245A80h case    4:*/		return 0x82245A84;
		  /* 82245A84h */ case    5:  		/* li R7, 376 */
		/* 82245A84h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x178);
		/* 82245A84h case    5:*/		return 0x82245A88;
		  /* 82245A88h */ case    6:  		/* li R3, 0 */
		/* 82245A88h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82245A88h case    6:*/		return 0x82245A8C;
		  /* 82245A8Ch */ case    7:  		/* bl -974468 */
		/* 82245A8Ch case    7:*/		regs.LR = 0x82245A90; return 0x82157C08;
		/* 82245A8Ch case    7:*/		return 0x82245A90;
	}
	return 0x82245A90;
} // Block from 82245A70h-82245A90h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82245A90h
// Function '?Create@VRegTable@XGRAPHICS@@QAAPAVVRegInfo@2@W4RegType@R400Tables@@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245A90);
		  /* 82245A90h */ case    0:  		/* lwz R3, <#[R31 + 40]> */
		/* 82245A90h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 82245A90h case    0:*/		return 0x82245A94;
		  /* 82245A94h */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 82245A94h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82245A94h case    1:*/		return 0x82245A98;
		  /* 82245A98h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82245A98h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82245A98h case    2:*/		return 0x82245A9C;
		  /* 82245A9Ch */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 82245A9Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x82245AA8;  }
		/* 82245A9Ch case    3:*/		return 0x82245AA0;
		  /* 82245AA0h */ case    4:  		/* lwz R3, <#[R3 + 8]> */
		/* 82245AA0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 82245AA0h case    4:*/		return 0x82245AA4;
		  /* 82245AA4h */ case    5:  		/* b 12 */
		/* 82245AA4h case    5:*/		return 0x82245AB0;
		/* 82245AA4h case    5:*/		return 0x82245AA8;
	}
	return 0x82245AA8;
} // Block from 82245A90h-82245AA8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82245AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245AA8);
		  /* 82245AA8h */ case    0:  		/* li R4, 0 */
		/* 82245AA8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82245AA8h case    0:*/		return 0x82245AAC;
		  /* 82245AACh */ case    1:  		/* bl 57364 */
		/* 82245AACh case    1:*/		regs.LR = 0x82245AB0; return 0x82253AC0;
		/* 82245AACh case    1:*/		return 0x82245AB0;
	}
	return 0x82245AB0;
} // Block from 82245AA8h-82245AB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245AB0);
		  /* 82245AB0h */ case    0:  		/* li R8, 4 */
		/* 82245AB0h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82245AB0h case    0:*/		return 0x82245AB4;
		  /* 82245AB4h */ case    1:  		/* lwz R4, <#[R3]> */
		/* 82245AB4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 82245AB4h case    1:*/		return 0x82245AB8;
		  /* 82245AB8h */ case    2:  		/* mr R7, R26 */
		/* 82245AB8h case    2:*/		regs.R7 = regs.R26;
		/* 82245AB8h case    2:*/		return 0x82245ABC;
		  /* 82245ABCh */ case    3:  		/* addi R10, R1, 96 */
		/* 82245ABCh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 82245ABCh case    3:*/		return 0x82245AC0;
		  /* 82245AC0h */ case    4:  		/* addi R11, R4, 928 */
		/* 82245AC0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x3A0);
		/* 82245AC0h case    4:*/		return 0x82245AC4;
		  /* 82245AC4h */ case    5:  		/* addi R9, R4, 896 */
		/* 82245AC4h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x380);
		/* 82245AC4h case    5:*/		return 0x82245AC8;
		  /* 82245AC8h */ case    6:  		/* mtspr CTR, R8 */
		/* 82245AC8h case    6:*/		regs.CTR = regs.R8;
		/* 82245AC8h case    6:*/		return 0x82245ACC;
		  /* 82245ACCh */ case    7:  		/* cmpw CR6, R7, R25 */
		/* 82245ACCh case    7:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R25);
		/* 82245ACCh case    7:*/		return 0x82245AD0;
		  /* 82245AD0h */ case    8:  		/* bc 4, CR6_LT, 28 */
		/* 82245AD0h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82245AEC;  }
		/* 82245AD0h case    8:*/		return 0x82245AD4;
		  /* 82245AD4h */ case    9:  		/* lwz R8, <#[R10]> */
		/* 82245AD4h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82245AD4h case    9:*/		return 0x82245AD8;
		  /* 82245AD8h */ case   10:  		/* lwz R6, <#[R10 + 4]> */
		/* 82245AD8h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82245AD8h case   10:*/		return 0x82245ADC;
		  /* 82245ADCh */ case   11:  		/* stw R27, <#[R11]> */
		/* 82245ADCh case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 82245ADCh case   11:*/		return 0x82245AE0;
	}
	return 0x82245AE0;
} // Block from 82245AB0h-82245AE0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82245AE0h
// Function '?Create@VRegTable@XGRAPHICS@@QAAPAVVRegInfo@2@W4RegType@R400Tables@@HH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245AE0);
		  /* 82245AE0h */ case    0:  		/* stw R8, <#[R9]> */
		/* 82245AE0h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82245AE0h case    0:*/		return 0x82245AE4;
		  /* 82245AE4h */ case    1:  		/* stw R6, <#[R9 + 4]> */
		/* 82245AE4h case    1:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + 0x00000004) );
		/* 82245AE4h case    1:*/		return 0x82245AE8;
		  /* 82245AE8h */ case    2:  		/* b 8 */
		/* 82245AE8h case    2:*/		return 0x82245AF0;
		/* 82245AE8h case    2:*/		return 0x82245AEC;
	}
	return 0x82245AEC;
} // Block from 82245AE0h-82245AECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82245AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245AEC);
		  /* 82245AECh */ case    0:  		/* stw R26, <#[R11]> */
		/* 82245AECh case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 82245AECh case    0:*/		return 0x82245AF0;
	}
	return 0x82245AF0;
} // Block from 82245AECh-82245AF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245AF0);
		  /* 82245AF0h */ case    0:  		/* addi R7, R7, 1 */
		/* 82245AF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82245AF0h case    0:*/		return 0x82245AF4;
		  /* 82245AF4h */ case    1:  		/* addi R11, R11, 4 */
		/* 82245AF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82245AF4h case    1:*/		return 0x82245AF8;
		  /* 82245AF8h */ case    2:  		/* addi R10, R10, 8 */
		/* 82245AF8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82245AF8h case    2:*/		return 0x82245AFC;
		  /* 82245AFCh */ case    3:  		/* addi R9, R9, 8 */
		/* 82245AFCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 82245AFCh case    3:*/		return 0x82245B00;
		  /* 82245B00h */ case    4:  		/* bc 16, CR0_LT, -52 */
		/* 82245B00h case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82245ACC;  }
		/* 82245B00h case    4:*/		return 0x82245B04;
		  /* 82245B04h */ case    5:  		/* mr R3, R30 */
		/* 82245B04h case    5:*/		regs.R3 = regs.R30;
		/* 82245B04h case    5:*/		return 0x82245B08;
		  /* 82245B08h */ case    6:  		/* bl 58160 */
		/* 82245B08h case    6:*/		regs.LR = 0x82245B0C; return 0x82253E38;
		/* 82245B08h case    6:*/		return 0x82245B0C;
	}
	return 0x82245B0C;
} // Block from 82245AF0h-82245B0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82245B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245B0C);
		  /* 82245B0Ch */ case    0:  		/* mr R3, R31 */
		/* 82245B0Ch case    0:*/		regs.R3 = regs.R31;
		/* 82245B0Ch case    0:*/		return 0x82245B10;
		  /* 82245B10h */ case    1:  		/* addi R1, R1, 240 */
		/* 82245B10h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 82245B10h case    1:*/		return 0x82245B14;
		  /* 82245B14h */ case    2:  		/* b -1788044 */
		/* 82245B14h case    2:*/		return 0x82091288;
		/* 82245B14h case    2:*/		return 0x82245B18;
		  /* 82245B18h */ case    3:  		/* lis R11, -32252 */
		/* 82245B18h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82245B18h case    3:*/		return 0x82245B1C;
		  /* 82245B1Ch */ case    4:  		/* mr R5, R4 */
		/* 82245B1Ch case    4:*/		regs.R5 = regs.R4;
		/* 82245B1Ch case    4:*/		return 0x82245B20;
		  /* 82245B20h */ case    5:  		/* li R4, 1 */
		/* 82245B20h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82245B20h case    5:*/		return 0x82245B24;
		  /* 82245B24h */ case    6:  		/* ld R8, <#[R11 + 27576]> */
		/* 82245B24h case    6:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R11 + 0x00006BB8) );
		/* 82245B24h case    6:*/		return 0x82245B28;
		  /* 82245B28h */ case    7:  		/* mr R7, R8 */
		/* 82245B28h case    7:*/		regs.R7 = regs.R8;
		/* 82245B28h case    7:*/		return 0x82245B2C;
		  /* 82245B2Ch */ case    8:  		/* mr R6, R8 */
		/* 82245B2Ch case    8:*/		regs.R6 = regs.R8;
		/* 82245B2Ch case    8:*/		return 0x82245B30;
		  /* 82245B30h */ case    9:  		/* b -2880 */
		/* 82245B30h case    9:*/		return 0x82244FF0;
		/* 82245B30h case    9:*/		return 0x82245B34;
		  /* 82245B34h */ case   10:  		/* nop */
		/* 82245B34h case   10:*/		cpu::op::nop();
		/* 82245B34h case   10:*/		return 0x82245B38;
		  /* 82245B38h */ case   11:  		/* lis R11, -32252 */
		/* 82245B38h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82245B38h case   11:*/		return 0x82245B3C;
		  /* 82245B3Ch */ case   12:  		/* mr R6, R5 */
		/* 82245B3Ch case   12:*/		regs.R6 = regs.R5;
		/* 82245B3Ch case   12:*/		return 0x82245B40;
		  /* 82245B40h */ case   13:  		/* mr R5, R4 */
		/* 82245B40h case   13:*/		regs.R5 = regs.R4;
		/* 82245B40h case   13:*/		return 0x82245B44;
		  /* 82245B44h */ case   14:  		/* li R4, 2 */
		/* 82245B44h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82245B44h case   14:*/		return 0x82245B48;
		  /* 82245B48h */ case   15:  		/* ld R8, <#[R11 + 27576]> */
		/* 82245B48h case   15:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R11 + 0x00006BB8) );
		/* 82245B48h case   15:*/		return 0x82245B4C;
		  /* 82245B4Ch */ case   16:  		/* mr R7, R8 */
		/* 82245B4Ch case   16:*/		regs.R7 = regs.R8;
		/* 82245B4Ch case   16:*/		return 0x82245B50;
		  /* 82245B50h */ case   17:  		/* b -2912 */
		/* 82245B50h case   17:*/		return 0x82244FF0;
		/* 82245B50h case   17:*/		return 0x82245B54;
		  /* 82245B54h */ case   18:  		/* nop */
		/* 82245B54h case   18:*/		cpu::op::nop();
		/* 82245B54h case   18:*/		return 0x82245B58;
	}
	return 0x82245B58;
} // Block from 82245B0Ch-82245B58h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82245B58h
// Function '?FindOrCreateInst@VRegTable@XGRAPHICS@@AAAPAVIRInst@2@HUkonst@2@000@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245B58);
		  /* 82245B58h */ case    0:  		/* lis R11, -32252 */
		/* 82245B58h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82245B58h case    0:*/		return 0x82245B5C;
		  /* 82245B5Ch */ case    1:  		/* mr R7, R6 */
		/* 82245B5Ch case    1:*/		regs.R7 = regs.R6;
		/* 82245B5Ch case    1:*/		return 0x82245B60;
		  /* 82245B60h */ case    2:  		/* mr R6, R5 */
		/* 82245B60h case    2:*/		regs.R6 = regs.R5;
		/* 82245B60h case    2:*/		return 0x82245B64;
		  /* 82245B64h */ case    3:  		/* mr R5, R4 */
		/* 82245B64h case    3:*/		regs.R5 = regs.R4;
		/* 82245B64h case    3:*/		return 0x82245B68;
		  /* 82245B68h */ case    4:  		/* li R4, 3 */
		/* 82245B68h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 82245B68h case    4:*/		return 0x82245B6C;
		  /* 82245B6Ch */ case    5:  		/* ld R8, <#[R11 + 27576]> */
		/* 82245B6Ch case    5:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R11 + 0x00006BB8) );
		/* 82245B6Ch case    5:*/		return 0x82245B70;
		  /* 82245B70h */ case    6:  		/* b -2944 */
		/* 82245B70h case    6:*/		return 0x82244FF0;
		/* 82245B70h case    6:*/		return 0x82245B74;
		  /* 82245B74h */ case    7:  		/* nop */
		/* 82245B74h case    7:*/		cpu::op::nop();
		/* 82245B74h case    7:*/		return 0x82245B78;
		  /* 82245B78h */ case    8:  		/* mr R8, R7 */
		/* 82245B78h case    8:*/		regs.R8 = regs.R7;
		/* 82245B78h case    8:*/		return 0x82245B7C;
		  /* 82245B7Ch */ case    9:  		/* mr R7, R6 */
		/* 82245B7Ch case    9:*/		regs.R7 = regs.R6;
		/* 82245B7Ch case    9:*/		return 0x82245B80;
		  /* 82245B80h */ case   10:  		/* mr R6, R5 */
		/* 82245B80h case   10:*/		regs.R6 = regs.R5;
		/* 82245B80h case   10:*/		return 0x82245B84;
		  /* 82245B84h */ case   11:  		/* mr R5, R4 */
		/* 82245B84h case   11:*/		regs.R5 = regs.R4;
		/* 82245B84h case   11:*/		return 0x82245B88;
		  /* 82245B88h */ case   12:  		/* li R4, 4 */
		/* 82245B88h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 82245B88h case   12:*/		return 0x82245B8C;
		  /* 82245B8Ch */ case   13:  		/* b -2972 */
		/* 82245B8Ch case   13:*/		return 0x82244FF0;
		/* 82245B8Ch case   13:*/		return 0x82245B90;
	}
	return 0x82245B90;
} // Block from 82245B58h-82245B90h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82245B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245B90);
		  /* 82245B90h */ case    0:  		/* mfspr R12, LR */
		/* 82245B90h case    0:*/		regs.R12 = regs.LR;
		/* 82245B90h case    0:*/		return 0x82245B94;
		  /* 82245B94h */ case    1:  		/* bl -1788216 */
		/* 82245B94h case    1:*/		regs.LR = 0x82245B98; return 0x8209125C;
		/* 82245B94h case    1:*/		return 0x82245B98;
		  /* 82245B98h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82245B98h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82245B98h case    2:*/		return 0x82245B9C;
		  /* 82245B9Ch */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 82245B9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82245B9Ch case    3:*/		return 0x82245BA0;
		  /* 82245BA0h */ case    4:  		/* mr R30, R3 */
		/* 82245BA0h case    4:*/		regs.R30 = regs.R3;
		/* 82245BA0h case    4:*/		return 0x82245BA4;
		  /* 82245BA4h */ case    5:  		/* std R4, <#[R1 + 136]> */
		/* 82245BA4h case    5:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 82245BA4h case    5:*/		return 0x82245BA8;
		  /* 82245BA8h */ case    6:  		/* li R31, 0 */
		/* 82245BA8h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82245BA8h case    6:*/		return 0x82245BAC;
		  /* 82245BACh */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82245BACh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82245BACh case    7:*/		return 0x82245BB0;
		  /* 82245BB0h */ case    8:  		/* bc 12, CR6_EQ, 112 */
		/* 82245BB0h case    8:*/		if ( regs.CR[6].eq ) { return 0x82245C20;  }
		/* 82245BB0h case    8:*/		return 0x82245BB4;
		  /* 82245BB4h */ case    9:  		/* li R29, 0 */
		/* 82245BB4h case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82245BB4h case    9:*/		return 0x82245BB8;
		  /* 82245BB8h */ case   10:  		/* cmplw CR6, R31, R11 */
		/* 82245BB8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82245BB8h case   10:*/		return 0x82245BBC;
		  /* 82245BBCh */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 82245BBCh case   11:*/		if ( !regs.CR[6].lt ) { return 0x82245BCC;  }
		/* 82245BBCh case   11:*/		return 0x82245BC0;
		  /* 82245BC0h */ case   12:  		/* lwz R11, <#[R30 + 8]> */
		/* 82245BC0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82245BC0h case   12:*/		return 0x82245BC4;
		  /* 82245BC4h */ case   13:  		/* add R3, R11, R29 */
		/* 82245BC4h case   13:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 82245BC4h case   13:*/		return 0x82245BC8;
		  /* 82245BC8h */ case   14:  		/* b 16 */
		/* 82245BC8h case   14:*/		return 0x82245BD8;
		/* 82245BC8h case   14:*/		return 0x82245BCC;
	}
	return 0x82245BCC;
} // Block from 82245B90h-82245BCCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 82245BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245BCC);
		  /* 82245BCCh */ case    0:  		/* mr R4, R31 */
		/* 82245BCCh case    0:*/		regs.R4 = regs.R31;
		/* 82245BCCh case    0:*/		return 0x82245BD0;
		  /* 82245BD0h */ case    1:  		/* mr R3, R30 */
		/* 82245BD0h case    1:*/		regs.R3 = regs.R30;
		/* 82245BD0h case    1:*/		return 0x82245BD4;
		  /* 82245BD4h */ case    2:  		/* bl 57068 */
		/* 82245BD4h case    2:*/		regs.LR = 0x82245BD8; return 0x82253AC0;
		/* 82245BD4h case    2:*/		return 0x82245BD8;
	}
	return 0x82245BD8;
} // Block from 82245BCCh-82245BD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82245BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245BD8);
		  /* 82245BD8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82245BD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82245BD8h case    0:*/		return 0x82245BDC;
		  /* 82245BDCh */ case    1:  		/* lwz R10, <#[R1 + 136]> */
		/* 82245BDCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 82245BDCh case    1:*/		return 0x82245BE0;
		  /* 82245BE0h */ case    2:  		/* lwz R9, <#[R11]> */
		/* 82245BE0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82245BE0h case    2:*/		return 0x82245BE4;
		  /* 82245BE4h */ case    3:  		/* cmplw CR6, R9, R10 */
		/* 82245BE4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82245BE4h case    3:*/		return 0x82245BE8;
		  /* 82245BE8h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 82245BE8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82245C00;  }
		/* 82245BE8h case    4:*/		return 0x82245BEC;
		  /* 82245BECh */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82245BECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82245BECh case    5:*/		return 0x82245BF0;
		  /* 82245BF0h */ case    6:  		/* lwz R10, <#[R1 + 140]> */
		/* 82245BF0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000008C) );
		/* 82245BF0h case    6:*/		return 0x82245BF4;
		  /* 82245BF4h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82245BF4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82245BF4h case    7:*/		return 0x82245BF8;
		  /* 82245BF8h */ case    8:  		/* li R11, 1 */
		/* 82245BF8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82245BF8h case    8:*/		return 0x82245BFC;
		  /* 82245BFCh */ case    9:  		/* bc 12, CR6_EQ, 8 */
		/* 82245BFCh case    9:*/		if ( regs.CR[6].eq ) { return 0x82245C04;  }
		/* 82245BFCh case    9:*/		return 0x82245C00;
	}
	return 0x82245C00;
} // Block from 82245BD8h-82245C00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82245C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245C00);
		  /* 82245C00h */ case    0:  		/* li R11, 0 */
		/* 82245C00h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82245C00h case    0:*/		return 0x82245C04;
	}
	return 0x82245C04;
} // Block from 82245C00h-82245C04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245C04);
		  /* 82245C04h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82245C04h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82245C04h case    0:*/		return 0x82245C08;
		  /* 82245C08h */ case    1:  		/* bc 4, CR0_EQ, 72 */
		/* 82245C08h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82245C50;  }
		/* 82245C08h case    1:*/		return 0x82245C0C;
		  /* 82245C0Ch */ case    2:  		/* lwz R11, <#[R30 + 4]> */
		/* 82245C0Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82245C0Ch case    2:*/		return 0x82245C10;
		  /* 82245C10h */ case    3:  		/* addi R31, R31, 1 */
		/* 82245C10h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82245C10h case    3:*/		return 0x82245C14;
		  /* 82245C14h */ case    4:  		/* addi R29, R29, 4 */
		/* 82245C14h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82245C14h case    4:*/		return 0x82245C18;
		  /* 82245C18h */ case    5:  		/* cmplw CR6, R31, R11 */
		/* 82245C18h case    5:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82245C18h case    5:*/		return 0x82245C1C;
		  /* 82245C1Ch */ case    6:  		/* bc 12, CR6_LT, -92 */
		/* 82245C1Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x82245BC0;  }
		/* 82245C1Ch case    6:*/		return 0x82245C20;
	}
	return 0x82245C20;
} // Block from 82245C04h-82245C20h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82245C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245C20);
		  /* 82245C20h */ case    0:  		/* lis R11, -32252 */
		/* 82245C20h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82245C20h case    0:*/		return 0x82245C24;
		  /* 82245C24h */ case    1:  		/* lis R10, -32255 */
		/* 82245C24h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82245C24h case    1:*/		return 0x82245C28;
		  /* 82245C28h */ case    2:  		/* lis R9, -32253 */
		/* 82245C28h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82245C28h case    2:*/		return 0x82245C2C;
		  /* 82245C2Ch */ case    3:  		/* addi R6, R11, 12584 */
		/* 82245C2Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3128);
		/* 82245C2Ch case    3:*/		return 0x82245C30;
		  /* 82245C30h */ case    4:  		/* addi R5, R10, 5216 */
		/* 82245C30h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 82245C30h case    4:*/		return 0x82245C34;
		  /* 82245C34h */ case    5:  		/* addi R4, R9, 27460 */
		/* 82245C34h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82245C34h case    5:*/		return 0x82245C38;
		  /* 82245C38h */ case    6:  		/* li R7, 572 */
		/* 82245C38h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x23C);
		/* 82245C38h case    6:*/		return 0x82245C3C;
		  /* 82245C3Ch */ case    7:  		/* li R3, 0 */
		/* 82245C3Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82245C3Ch case    7:*/		return 0x82245C40;
		  /* 82245C40h */ case    8:  		/* bl -974904 */
		/* 82245C40h case    8:*/		regs.LR = 0x82245C44; return 0x82157C08;
		/* 82245C40h case    8:*/		return 0x82245C44;
		  /* 82245C44h */ case    9:  		/* lwz R3, <#[R30 + 4]> */
		/* 82245C44h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 82245C44h case    9:*/		return 0x82245C48;
		  /* 82245C48h */ case   10:  		/* addi R1, R1, 112 */
		/* 82245C48h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82245C48h case   10:*/		return 0x82245C4C;
		  /* 82245C4Ch */ case   11:  		/* b -1788320 */
		/* 82245C4Ch case   11:*/		return 0x820912AC;
		/* 82245C4Ch case   11:*/		return 0x82245C50;
	}
	return 0x82245C50;
} // Block from 82245C20h-82245C50h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82245C50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245C50);
		  /* 82245C50h */ case    0:  		/* mr R3, R31 */
		/* 82245C50h case    0:*/		regs.R3 = regs.R31;
		/* 82245C50h case    0:*/		return 0x82245C54;
		  /* 82245C54h */ case    1:  		/* b -12 */
		/* 82245C54h case    1:*/		return 0x82245C48;
		/* 82245C54h case    1:*/		return 0x82245C58;
	}
	return 0x82245C58;
} // Block from 82245C50h-82245C58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245C58);
		  /* 82245C58h */ case    0:  		/* mfspr R12, LR */
		/* 82245C58h case    0:*/		regs.R12 = regs.LR;
		/* 82245C58h case    0:*/		return 0x82245C5C;
		  /* 82245C5Ch */ case    1:  		/* bl -1788476 */
		/* 82245C5Ch case    1:*/		regs.LR = 0x82245C60; return 0x82091220;
		/* 82245C5Ch case    1:*/		return 0x82245C60;
		  /* 82245C60h */ case    2:  		/* stwu R1, <#[R1 - 432]> */
		/* 82245C60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE50);
		/* 82245C60h case    2:*/		return 0x82245C64;
		  /* 82245C64h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82245C64h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82245C64h case    3:*/		return 0x82245C68;
		  /* 82245C68h */ case    4:  		/* mr R17, R3 */
		/* 82245C68h case    4:*/		regs.R17 = regs.R3;
		/* 82245C68h case    4:*/		return 0x82245C6C;
		  /* 82245C6Ch */ case    5:  		/* mr R30, R4 */
		/* 82245C6Ch case    5:*/		regs.R30 = regs.R4;
		/* 82245C6Ch case    5:*/		return 0x82245C70;
		  /* 82245C70h */ case    6:  		/* li R4, 20 */
		/* 82245C70h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82245C70h case    6:*/		return 0x82245C74;
		  /* 82245C74h */ case    7:  		/* lwz R29, <#[R11 + 1456]> */
		/* 82245C74h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245C74h case    7:*/		return 0x82245C78;
		  /* 82245C78h */ case    8:  		/* mr R3, R29 */
		/* 82245C78h case    8:*/		regs.R3 = regs.R29;
		/* 82245C78h case    8:*/		return 0x82245C7C;
		  /* 82245C7Ch */ case    9:  		/* bl -169924 */
		/* 82245C7Ch case    9:*/		regs.LR = 0x82245C80; return 0x8221C4B8;
		/* 82245C7Ch case    9:*/		return 0x82245C80;
		  /* 82245C80h */ case   10:  		/* addic. R31, R3, 4 */
		/* 82245C80h case   10:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82245C80h case   10:*/		return 0x82245C84;
		  /* 82245C84h */ case   11:  		/* stw R29, <#[R3]> */
		/* 82245C84h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82245C84h case   11:*/		return 0x82245C88;
		  /* 82245C88h */ case   12:  		/* bc 12, CR0_EQ, 32 */
		/* 82245C88h case   12:*/		if ( regs.CR[0].eq ) { return 0x82245CA8;  }
		/* 82245C88h case   12:*/		return 0x82245C8C;
		  /* 82245C8Ch */ case   13:  		/* lwz R11, <#[R17]> */
		/* 82245C8Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245C8Ch case   13:*/		return 0x82245C90;
		  /* 82245C90h */ case   14:  		/* mr R3, R31 */
		/* 82245C90h case   14:*/		regs.R3 = regs.R31;
		/* 82245C90h case   14:*/		return 0x82245C94;
		  /* 82245C94h */ case   15:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82245C94h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245C94h case   15:*/		return 0x82245C98;
		  /* 82245C98h */ case   16:  		/* bl -65336 */
		/* 82245C98h case   16:*/		regs.LR = 0x82245C9C; return 0x82235D60;
		/* 82245C98h case   16:*/		return 0x82245C9C;
		  /* 82245C9Ch */ case   17:  		/* mr R23, R31 */
		/* 82245C9Ch case   17:*/		regs.R23 = regs.R31;
		/* 82245C9Ch case   17:*/		return 0x82245CA0;
		  /* 82245CA0h */ case   18:  		/* li R24, 0 */
		/* 82245CA0h case   18:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82245CA0h case   18:*/		return 0x82245CA4;
		  /* 82245CA4h */ case   19:  		/* b 12 */
		/* 82245CA4h case   19:*/		return 0x82245CB0;
		/* 82245CA4h case   19:*/		return 0x82245CA8;
	}
	return 0x82245CA8;
} // Block from 82245C58h-82245CA8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82245CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245CA8);
		  /* 82245CA8h */ case    0:  		/* li R24, 0 */
		/* 82245CA8h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82245CA8h case    0:*/		return 0x82245CAC;
		  /* 82245CACh */ case    1:  		/* mr R23, R24 */
		/* 82245CACh case    1:*/		regs.R23 = regs.R24;
		/* 82245CACh case    1:*/		return 0x82245CB0;
	}
	return 0x82245CB0;
} // Block from 82245CA8h-82245CB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82245CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245CB0);
		  /* 82245CB0h */ case    0:  		/* lis R11, -32252 */
		/* 82245CB0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82245CB0h case    0:*/		return 0x82245CB4;
		  /* 82245CB4h */ case    1:  		/* lwz R3, <#[R17]> */
		/* 82245CB4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 82245CB4h case    1:*/		return 0x82245CB8;
		  /* 82245CB8h */ case    2:  		/* addi R4, R11, 12788 */
		/* 82245CB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x31F4);
		/* 82245CB8h case    2:*/		return 0x82245CBC;
		  /* 82245CBCh */ case    3:  		/* bl -166140 */
		/* 82245CBCh case    3:*/		regs.LR = 0x82245CC0; return 0x8221D3C0;
		/* 82245CBCh case    3:*/		return 0x82245CC0;
		  /* 82245CC0h */ case    4:  		/* lwz R30, <#[R30 + 136]> */
		/* 82245CC0h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000088) );
		/* 82245CC0h case    4:*/		return 0x82245CC4;
		  /* 82245CC4h */ case    5:  		/* b 112 */
		/* 82245CC4h case    5:*/		return 0x82245D34;
		/* 82245CC4h case    5:*/		return 0x82245CC8;
		  /* 82245CC8h */ case    6:  		/* lwz R31, <#[R30 + 28]> */
		/* 82245CC8h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x0000001C) );
		/* 82245CC8h case    6:*/		return 0x82245CCC;
		  /* 82245CCCh */ case    7:  		/* b 88 */
		/* 82245CCCh case    7:*/		return 0x82245D24;
		/* 82245CCCh case    7:*/		return 0x82245CD0;
		  /* 82245CD0h */ case    8:  		/* lwz R11, <#[R31 + 228]> */
		/* 82245CD0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82245CD0h case    8:*/		return 0x82245CD4;
		  /* 82245CD4h */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82245CD4h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82245CD4h case    9:*/		return 0x82245CD8;
		  /* 82245CD8h */ case   10:  		/* bc 12, CR0_EQ, 72 */
		/* 82245CD8h case   10:*/		if ( regs.CR[0].eq ) { return 0x82245D20;  }
		/* 82245CD8h case   10:*/		return 0x82245CDC;
		  /* 82245CDCh */ case   11:  		/* lwz R11, <#[R31]> */
		/* 82245CDCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82245CDCh case   11:*/		return 0x82245CE0;
		  /* 82245CE0h */ case   12:  		/* mr R3, R31 */
		/* 82245CE0h case   12:*/		regs.R3 = regs.R31;
		/* 82245CE0h case   12:*/		return 0x82245CE4;
		  /* 82245CE4h */ case   13:  		/* lwz R11, <#[R11 + 64]> */
		/* 82245CE4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000040) );
		/* 82245CE4h case   13:*/		return 0x82245CE8;
		  /* 82245CE8h */ case   14:  		/* mtspr CTR, R11 */
		/* 82245CE8h case   14:*/		regs.CTR = regs.R11;
		/* 82245CE8h case   14:*/		return 0x82245CEC;
		  /* 82245CECh */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 82245CECh case   15:*/		if ( 1 ) { regs.LR = 0x82245CF0; return (uint32)regs.CTR; }
		/* 82245CECh case   15:*/		return 0x82245CF0;
		  /* 82245CF0h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82245CF0h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82245CF0h case   16:*/		return 0x82245CF4;
		  /* 82245CF4h */ case   17:  		/* bc 12, CR0_EQ, 44 */
		/* 82245CF4h case   17:*/		if ( regs.CR[0].eq ) { return 0x82245D20;  }
		/* 82245CF4h case   17:*/		return 0x82245CF8;
		  /* 82245CF8h */ case   18:  		/* lwz R11, <#[R31 + 228]> */
		/* 82245CF8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82245CF8h case   18:*/		return 0x82245CFC;
		  /* 82245CFCh */ case   19:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82245CFCh case   19:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82245CFCh case   19:*/		return 0x82245D00;
		  /* 82245D00h */ case   20:  		/* bc 12, CR0_EQ, 32 */
		/* 82245D00h case   20:*/		if ( regs.CR[0].eq ) { return 0x82245D20;  }
		/* 82245D00h case   20:*/		return 0x82245D04;
		  /* 82245D04h */ case   21:  		/* lwz R11, <#[R31 + 80]> */
		/* 82245D04h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 82245D04h case   21:*/		return 0x82245D08;
		  /* 82245D08h */ case   22:  		/* cmpwi CR6, R11, 11 */
		/* 82245D08h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 82245D08h case   22:*/		return 0x82245D0C;
		  /* 82245D0Ch */ case   23:  		/* bc 4, CR6_EQ, 20 */
		/* 82245D0Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x82245D20;  }
		/* 82245D0Ch case   23:*/		return 0x82245D10;
		  /* 82245D10h */ case   24:  		/* mr R3, R23 */
		/* 82245D10h case   24:*/		regs.R3 = regs.R23;
		/* 82245D10h case   24:*/		return 0x82245D14;
		  /* 82245D14h */ case   25:  		/* lwz R4, <#[R23 + 4]> */
		/* 82245D14h case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000004) );
		/* 82245D14h case   25:*/		return 0x82245D18;
		  /* 82245D18h */ case   26:  		/* bl 56744 */
		/* 82245D18h case   26:*/		regs.LR = 0x82245D1C; return 0x82253AC0;
		/* 82245D18h case   26:*/		return 0x82245D1C;
		  /* 82245D1Ch */ case   27:  		/* stw R31, <#[R3]> */
		/* 82245D1Ch case   27:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82245D1Ch case   27:*/		return 0x82245D20;
	}
	return 0x82245D20;
} // Block from 82245CB0h-82245D20h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82245D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245D20);
		  /* 82245D20h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 82245D20h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82245D20h case    0:*/		return 0x82245D24;
	}
	return 0x82245D24;
} // Block from 82245D20h-82245D24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245D24);
		  /* 82245D24h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82245D24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82245D24h case    0:*/		return 0x82245D28;
		  /* 82245D28h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82245D28h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82245D28h case    1:*/		return 0x82245D2C;
		  /* 82245D2Ch */ case    2:  		/* bc 4, CR6_EQ, -92 */
		/* 82245D2Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82245CD0;  }
		/* 82245D2Ch case    2:*/		return 0x82245D30;
		  /* 82245D30h */ case    3:  		/* lwz R30, <#[R30 + 8]> */
		/* 82245D30h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 82245D30h case    3:*/		return 0x82245D34;
	}
	return 0x82245D34;
} // Block from 82245D24h-82245D34h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82245D34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245D34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245D34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245D34);
		  /* 82245D34h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82245D34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82245D34h case    0:*/		return 0x82245D38;
		  /* 82245D38h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82245D38h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82245D38h case    1:*/		return 0x82245D3C;
		  /* 82245D3Ch */ case    2:  		/* bc 4, CR6_EQ, -116 */
		/* 82245D3Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82245CC8;  }
		/* 82245D3Ch case    2:*/		return 0x82245D40;
		  /* 82245D40h */ case    3:  		/* lwz R11, <#[R23 + 4]> */
		/* 82245D40h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82245D40h case    3:*/		return 0x82245D44;
		  /* 82245D44h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82245D44h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82245D44h case    4:*/		return 0x82245D48;
		  /* 82245D48h */ case    5:  		/* bc 12, CR6_EQ, 5880 */
		/* 82245D48h case    5:*/		if ( regs.CR[6].eq ) { return 0x82247440;  }
		/* 82245D48h case    5:*/		return 0x82245D4C;
		  /* 82245D4Ch */ case    6:  		/* lis R11, -32220 */
		/* 82245D4Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8224);
		/* 82245D4Ch case    6:*/		return 0x82245D50;
		  /* 82245D50h */ case    7:  		/* mr R3, R23 */
		/* 82245D50h case    7:*/		regs.R3 = regs.R23;
		/* 82245D50h case    7:*/		return 0x82245D54;
		  /* 82245D54h */ case    8:  		/* addi R4, R11, 21192 */
		/* 82245D54h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x52C8);
		/* 82245D54h case    8:*/		return 0x82245D58;
		  /* 82245D58h */ case    9:  		/* bl 56272 */
		/* 82245D58h case    9:*/		regs.LR = 0x82245D5C; return 0x82253928;
		/* 82245D58h case    9:*/		return 0x82245D5C;
		  /* 82245D5Ch */ case   10:  		/* lwz R11, <#[R17]> */
		/* 82245D5Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245D5Ch case   10:*/		return 0x82245D60;
		  /* 82245D60h */ case   11:  		/* lwz R10, <#[R11 + 2136]> */
		/* 82245D60h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000858) );
		/* 82245D60h case   11:*/		return 0x82245D64;
		  /* 82245D64h */ case   12:  		/* rlwinm. R10, R10, 19, 31, 31 */
		/* 82245D64h case   12:*/		cpu::op::rlwinm<1,19,31,31>(regs,&regs.R10,regs.R10);
		/* 82245D64h case   12:*/		return 0x82245D68;
		  /* 82245D68h */ case   13:  		/* bc 12, CR0_EQ, 5444 */
		/* 82245D68h case   13:*/		if ( regs.CR[0].eq ) { return 0x822472AC;  }
		/* 82245D68h case   13:*/		return 0x82245D6C;
		  /* 82245D6Ch */ case   14:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82245D6Ch case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245D6Ch case   14:*/		return 0x82245D70;
		  /* 82245D70h */ case   15:  		/* li R4, 20 */
		/* 82245D70h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82245D70h case   15:*/		return 0x82245D74;
		  /* 82245D74h */ case   16:  		/* mr R3, R30 */
		/* 82245D74h case   16:*/		regs.R3 = regs.R30;
		/* 82245D74h case   16:*/		return 0x82245D78;
		  /* 82245D78h */ case   17:  		/* bl -170176 */
		/* 82245D78h case   17:*/		regs.LR = 0x82245D7C; return 0x8221C4B8;
		/* 82245D78h case   17:*/		return 0x82245D7C;
		  /* 82245D7Ch */ case   18:  		/* addic. R31, R3, 4 */
		/* 82245D7Ch case   18:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82245D7Ch case   18:*/		return 0x82245D80;
		  /* 82245D80h */ case   19:  		/* stw R30, <#[R3]> */
		/* 82245D80h case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82245D80h case   19:*/		return 0x82245D84;
		  /* 82245D84h */ case   20:  		/* bc 12, CR0_EQ, 28 */
		/* 82245D84h case   20:*/		if ( regs.CR[0].eq ) { return 0x82245DA0;  }
		/* 82245D84h case   20:*/		return 0x82245D88;
		  /* 82245D88h */ case   21:  		/* lwz R11, <#[R17]> */
		/* 82245D88h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245D88h case   21:*/		return 0x82245D8C;
		  /* 82245D8Ch */ case   22:  		/* mr R3, R31 */
		/* 82245D8Ch case   22:*/		regs.R3 = regs.R31;
		/* 82245D8Ch case   22:*/		return 0x82245D90;
		  /* 82245D90h */ case   23:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82245D90h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245D90h case   23:*/		return 0x82245D94;
		  /* 82245D94h */ case   24:  		/* bl -65588 */
		/* 82245D94h case   24:*/		regs.LR = 0x82245D98; return 0x82235D60;
		/* 82245D94h case   24:*/		return 0x82245D98;
		  /* 82245D98h */ case   25:  		/* mr R18, R31 */
		/* 82245D98h case   25:*/		regs.R18 = regs.R31;
		/* 82245D98h case   25:*/		return 0x82245D9C;
		  /* 82245D9Ch */ case   26:  		/* b 8 */
		/* 82245D9Ch case   26:*/		return 0x82245DA4;
		/* 82245D9Ch case   26:*/		return 0x82245DA0;
	}
	return 0x82245DA0;
} // Block from 82245D34h-82245DA0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82245DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245DA0);
		  /* 82245DA0h */ case    0:  		/* mr R18, R24 */
		/* 82245DA0h case    0:*/		regs.R18 = regs.R24;
		/* 82245DA0h case    0:*/		return 0x82245DA4;
	}
	return 0x82245DA4;
} // Block from 82245DA0h-82245DA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245DA4);
		  /* 82245DA4h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 82245DA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82245DA4h case    0:*/		return 0x82245DA8;
		  /* 82245DA8h */ case    1:  		/* mr R26, R24 */
		/* 82245DA8h case    1:*/		regs.R26 = regs.R24;
		/* 82245DA8h case    1:*/		return 0x82245DAC;
		  /* 82245DACh */ case    2:  		/* stw R18, <#[R1 + 132]> */
		/* 82245DACh case    2:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000084) );
		/* 82245DACh case    2:*/		return 0x82245DB0;
		  /* 82245DB0h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82245DB0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82245DB0h case    3:*/		return 0x82245DB4;
		  /* 82245DB4h */ case    4:  		/* bc 12, CR6_EQ, 248 */
		/* 82245DB4h case    4:*/		if ( regs.CR[6].eq ) { return 0x82245EAC;  }
		/* 82245DB4h case    4:*/		return 0x82245DB8;
		  /* 82245DB8h */ case    5:  		/* mr R25, R24 */
		/* 82245DB8h case    5:*/		regs.R25 = regs.R24;
		/* 82245DB8h case    5:*/		return 0x82245DBC;
		  /* 82245DBCh */ case    6:  		/* cmplw CR6, R24, R11 */
		/* 82245DBCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 82245DBCh case    6:*/		return 0x82245DC0;
		  /* 82245DC0h */ case    7:  		/* bc 4, CR6_LT, 16 */
		/* 82245DC0h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82245DD0;  }
		/* 82245DC0h case    7:*/		return 0x82245DC4;
		  /* 82245DC4h */ case    8:  		/* lwz R11, <#[R23 + 8]> */
		/* 82245DC4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82245DC4h case    8:*/		return 0x82245DC8;
		  /* 82245DC8h */ case    9:  		/* add R3, R11, R25 */
		/* 82245DC8h case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 82245DC8h case    9:*/		return 0x82245DCC;
		  /* 82245DCCh */ case   10:  		/* b 16 */
		/* 82245DCCh case   10:*/		return 0x82245DDC;
		/* 82245DCCh case   10:*/		return 0x82245DD0;
	}
	return 0x82245DD0;
} // Block from 82245DA4h-82245DD0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82245DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245DD0);
		  /* 82245DD0h */ case    0:  		/* mr R4, R26 */
		/* 82245DD0h case    0:*/		regs.R4 = regs.R26;
		/* 82245DD0h case    0:*/		return 0x82245DD4;
		  /* 82245DD4h */ case    1:  		/* mr R3, R23 */
		/* 82245DD4h case    1:*/		regs.R3 = regs.R23;
		/* 82245DD4h case    1:*/		return 0x82245DD8;
		  /* 82245DD8h */ case    2:  		/* bl 56552 */
		/* 82245DD8h case    2:*/		regs.LR = 0x82245DDC; return 0x82253AC0;
		/* 82245DD8h case    2:*/		return 0x82245DDC;
	}
	return 0x82245DDC;
} // Block from 82245DD0h-82245DDCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82245DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245DDC);
		  /* 82245DDCh */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82245DDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82245DDCh case    0:*/		return 0x82245DE0;
		  /* 82245DE0h */ case    1:  		/* mr R28, R24 */
		/* 82245DE0h case    1:*/		regs.R28 = regs.R24;
		/* 82245DE0h case    1:*/		return 0x82245DE4;
		  /* 82245DE4h */ case    2:  		/* addi R29, R11, 896 */
		/* 82245DE4h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x380);
		/* 82245DE4h case    2:*/		return 0x82245DE8;
		  /* 82245DE8h */ case    3:  		/* addi R27, R11, 928 */
		/* 82245DE8h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x3A0);
		/* 82245DE8h case    3:*/		return 0x82245DEC;
		  /* 82245DECh */ case    4:  		/* lwz R11, <#[R27]> */
		/* 82245DECh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82245DECh case    4:*/		return 0x82245DF0;
		  /* 82245DF0h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82245DF0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82245DF0h case    5:*/		return 0x82245DF4;
		  /* 82245DF4h */ case    6:  		/* bc 12, CR6_EQ, 164 */
		/* 82245DF4h case    6:*/		if ( regs.CR[6].eq ) { return 0x82245E98;  }
		/* 82245DF4h case    6:*/		return 0x82245DF8;
		  /* 82245DF8h */ case    7:  		/* lwz R11, <#[R18 + 4]> */
		/* 82245DF8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 82245DF8h case    7:*/		return 0x82245DFC;
		  /* 82245DFCh */ case    8:  		/* mr R31, R24 */
		/* 82245DFCh case    8:*/		regs.R31 = regs.R24;
		/* 82245DFCh case    8:*/		return 0x82245E00;
		  /* 82245E00h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82245E00h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82245E00h case    9:*/		return 0x82245E04;
		  /* 82245E04h */ case   10:  		/* bc 12, CR6_EQ, 112 */
		/* 82245E04h case   10:*/		if ( regs.CR[6].eq ) { return 0x82245E74;  }
		/* 82245E04h case   10:*/		return 0x82245E08;
		  /* 82245E08h */ case   11:  		/* mr R30, R24 */
		/* 82245E08h case   11:*/		regs.R30 = regs.R24;
		/* 82245E08h case   11:*/		return 0x82245E0C;
		  /* 82245E0Ch */ case   12:  		/* cmplw CR6, R24, R11 */
		/* 82245E0Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 82245E0Ch case   12:*/		return 0x82245E10;
		  /* 82245E10h */ case   13:  		/* bc 4, CR6_LT, 16 */
		/* 82245E10h case   13:*/		if ( !regs.CR[6].lt ) { return 0x82245E20;  }
		/* 82245E10h case   13:*/		return 0x82245E14;
		  /* 82245E14h */ case   14:  		/* lwz R11, <#[R18 + 8]> */
		/* 82245E14h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000008) );
		/* 82245E14h case   14:*/		return 0x82245E18;
		  /* 82245E18h */ case   15:  		/* add R3, R11, R30 */
		/* 82245E18h case   15:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 82245E18h case   15:*/		return 0x82245E1C;
		  /* 82245E1Ch */ case   16:  		/* b 16 */
		/* 82245E1Ch case   16:*/		return 0x82245E2C;
		/* 82245E1Ch case   16:*/		return 0x82245E20;
	}
	return 0x82245E20;
} // Block from 82245DDCh-82245E20h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82245E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245E20);
		  /* 82245E20h */ case    0:  		/* mr R4, R31 */
		/* 82245E20h case    0:*/		regs.R4 = regs.R31;
		/* 82245E20h case    0:*/		return 0x82245E24;
		  /* 82245E24h */ case    1:  		/* mr R3, R18 */
		/* 82245E24h case    1:*/		regs.R3 = regs.R18;
		/* 82245E24h case    1:*/		return 0x82245E28;
		  /* 82245E28h */ case    2:  		/* bl 56472 */
		/* 82245E28h case    2:*/		regs.LR = 0x82245E2C; return 0x82253AC0;
		/* 82245E28h case    2:*/		return 0x82245E2C;
	}
	return 0x82245E2C;
} // Block from 82245E20h-82245E2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82245E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245E2C);
		  /* 82245E2Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82245E2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82245E2Ch case    0:*/		return 0x82245E30;
	}
	return 0x82245E30;
} // Block from 82245E2Ch-82245E30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245E30h
// Function '?compare_loadconsts@XGRAPHICS@@YAHPAX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245E30);
		  /* 82245E30h */ case    0:  		/* lwz R10, <#[R29]> */
		/* 82245E30h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82245E30h case    0:*/		return 0x82245E34;
		  /* 82245E34h */ case    1:  		/* lwz R9, <#[R11]> */
		/* 82245E34h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82245E34h case    1:*/		return 0x82245E38;
		  /* 82245E38h */ case    2:  		/* cmplw CR6, R10, R9 */
		/* 82245E38h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82245E38h case    2:*/		return 0x82245E3C;
		  /* 82245E3Ch */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82245E3Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82245E54;  }
		/* 82245E3Ch case    3:*/		return 0x82245E40;
		  /* 82245E40h */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 82245E40h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82245E40h case    4:*/		return 0x82245E44;
		  /* 82245E44h */ case    5:  		/* lwz R10, <#[R29 + 4]> */
		/* 82245E44h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 82245E44h case    5:*/		return 0x82245E48;
		  /* 82245E48h */ case    6:  		/* cmplw CR6, R10, R11 */
		/* 82245E48h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82245E48h case    6:*/		return 0x82245E4C;
		  /* 82245E4Ch */ case    7:  		/* li R11, 1 */
		/* 82245E4Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82245E4Ch case    7:*/		return 0x82245E50;
		  /* 82245E50h */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 82245E50h case    8:*/		if ( regs.CR[6].eq ) { return 0x82245E58;  }
		/* 82245E50h case    8:*/		return 0x82245E54;
	}
	return 0x82245E54;
} // Block from 82245E30h-82245E54h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82245E54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245E54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245E54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245E54);
		  /* 82245E54h */ case    0:  		/* mr R11, R24 */
		/* 82245E54h case    0:*/		regs.R11 = regs.R24;
		/* 82245E54h case    0:*/		return 0x82245E58;
	}
	return 0x82245E58;
} // Block from 82245E54h-82245E58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82245E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245E58);
		  /* 82245E58h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82245E58h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82245E58h case    0:*/		return 0x82245E5C;
		  /* 82245E5Ch */ case    1:  		/* bc 4, CR0_EQ, 40 */
		/* 82245E5Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82245E84;  }
		/* 82245E5Ch case    1:*/		return 0x82245E60;
		  /* 82245E60h */ case    2:  		/* lwz R11, <#[R18 + 4]> */
		/* 82245E60h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 82245E60h case    2:*/		return 0x82245E64;
		  /* 82245E64h */ case    3:  		/* addi R31, R31, 1 */
		/* 82245E64h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82245E64h case    3:*/		return 0x82245E68;
		  /* 82245E68h */ case    4:  		/* addi R30, R30, 4 */
		/* 82245E68h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82245E68h case    4:*/		return 0x82245E6C;
		  /* 82245E6Ch */ case    5:  		/* cmplw CR6, R31, R11 */
		/* 82245E6Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82245E6Ch case    5:*/		return 0x82245E70;
		  /* 82245E70h */ case    6:  		/* bc 12, CR6_LT, -92 */
		/* 82245E70h case    6:*/		if ( regs.CR[6].lt ) { return 0x82245E14;  }
		/* 82245E70h case    6:*/		return 0x82245E74;
	}
	return 0x82245E74;
} // Block from 82245E58h-82245E74h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82245E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245E74);
		  /* 82245E74h */ case    0:  		/* mr R3, R18 */
		/* 82245E74h case    0:*/		regs.R3 = regs.R18;
		/* 82245E74h case    0:*/		return 0x82245E78;
		  /* 82245E78h */ case    1:  		/* lwz R4, <#[R18 + 4]> */
		/* 82245E78h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R18 + 0x00000004) );
		/* 82245E78h case    1:*/		return 0x82245E7C;
		  /* 82245E7Ch */ case    2:  		/* bl 56388 */
		/* 82245E7Ch case    2:*/		regs.LR = 0x82245E80; return 0x82253AC0;
		/* 82245E7Ch case    2:*/		return 0x82245E80;
		  /* 82245E80h */ case    3:  		/* stw R29, <#[R3]> */
		/* 82245E80h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82245E80h case    3:*/		return 0x82245E84;
	}
	return 0x82245E84;
} // Block from 82245E74h-82245E84h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82245E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245E84);
		  /* 82245E84h */ case    0:  		/* addi R28, R28, 1 */
		/* 82245E84h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82245E84h case    0:*/		return 0x82245E88;
		  /* 82245E88h */ case    1:  		/* addi R27, R27, 4 */
		/* 82245E88h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 82245E88h case    1:*/		return 0x82245E8C;
		  /* 82245E8Ch */ case    2:  		/* addi R29, R29, 8 */
		/* 82245E8Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x8);
		/* 82245E8Ch case    2:*/		return 0x82245E90;
		  /* 82245E90h */ case    3:  		/* cmpwi CR6, R28, 4 */
		/* 82245E90h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000004);
		/* 82245E90h case    3:*/		return 0x82245E94;
		  /* 82245E94h */ case    4:  		/* bc 12, CR6_LT, -168 */
		/* 82245E94h case    4:*/		if ( regs.CR[6].lt ) { return 0x82245DEC;  }
		/* 82245E94h case    4:*/		return 0x82245E98;
	}
	return 0x82245E98;
} // Block from 82245E84h-82245E98h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82245E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245E98);
		  /* 82245E98h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 82245E98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82245E98h case    0:*/		return 0x82245E9C;
		  /* 82245E9Ch */ case    1:  		/* addi R26, R26, 1 */
		/* 82245E9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82245E9Ch case    1:*/		return 0x82245EA0;
		  /* 82245EA0h */ case    2:  		/* addi R25, R25, 4 */
		/* 82245EA0h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82245EA0h case    2:*/		return 0x82245EA4;
		  /* 82245EA4h */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 82245EA4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82245EA4h case    3:*/		return 0x82245EA8;
		  /* 82245EA8h */ case    4:  		/* bc 12, CR6_LT, -228 */
		/* 82245EA8h case    4:*/		if ( regs.CR[6].lt ) { return 0x82245DC4;  }
		/* 82245EA8h case    4:*/		return 0x82245EAC;
	}
	return 0x82245EAC;
} // Block from 82245E98h-82245EACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82245EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245EAC);
		  /* 82245EACh */ case    0:  		/* lis R11, -32220 */
		/* 82245EACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8224);
		/* 82245EACh case    0:*/		return 0x82245EB0;
		  /* 82245EB0h */ case    1:  		/* mr R3, R18 */
		/* 82245EB0h case    1:*/		regs.R3 = regs.R18;
		/* 82245EB0h case    1:*/		return 0x82245EB4;
		  /* 82245EB4h */ case    2:  		/* addi R4, R11, 19632 */
		/* 82245EB4h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4CB0);
		/* 82245EB4h case    2:*/		return 0x82245EB8;
		  /* 82245EB8h */ case    3:  		/* bl 55920 */
		/* 82245EB8h case    3:*/		regs.LR = 0x82245EBC; return 0x82253928;
		/* 82245EB8h case    3:*/		return 0x82245EBC;
		  /* 82245EBCh */ case    4:  		/* lwz R11, <#[R17]> */
		/* 82245EBCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245EBCh case    4:*/		return 0x82245EC0;
		  /* 82245EC0h */ case    5:  		/* lwz R10, <#[R18 + 4]> */
		/* 82245EC0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000004) );
		/* 82245EC0h case    5:*/		return 0x82245EC4;
		  /* 82245EC4h */ case    6:  		/* rlwinm R4, R10, 2, 0, 29 */
		/* 82245EC4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R10);
		/* 82245EC4h case    6:*/		return 0x82245EC8;
		  /* 82245EC8h */ case    7:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82245EC8h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245EC8h case    7:*/		return 0x82245ECC;
		  /* 82245ECCh */ case    8:  		/* bl -170516 */
		/* 82245ECCh case    8:*/		regs.LR = 0x82245ED0; return 0x8221C4B8;
		/* 82245ECCh case    8:*/		return 0x82245ED0;
		  /* 82245ED0h */ case    9:  		/* lwz R11, <#[R17]> */
		/* 82245ED0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245ED0h case    9:*/		return 0x82245ED4;
		  /* 82245ED4h */ case   10:  		/* mr R15, R3 */
		/* 82245ED4h case   10:*/		regs.R15 = regs.R3;
		/* 82245ED4h case   10:*/		return 0x82245ED8;
		  /* 82245ED8h */ case   11:  		/* lwz R10, <#[R18 + 4]> */
		/* 82245ED8h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000004) );
		/* 82245ED8h case   11:*/		return 0x82245EDC;
		  /* 82245EDCh */ case   12:  		/* stw R3, <#[R1 + 100]> */
		/* 82245EDCh case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000064) );
		/* 82245EDCh case   12:*/		return 0x82245EE0;
		  /* 82245EE0h */ case   13:  		/* rlwinm R4, R10, 2, 0, 29 */
		/* 82245EE0h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R10);
		/* 82245EE0h case   13:*/		return 0x82245EE4;
		  /* 82245EE4h */ case   14:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82245EE4h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245EE4h case   14:*/		return 0x82245EE8;
		  /* 82245EE8h */ case   15:  		/* bl -170544 */
		/* 82245EE8h case   15:*/		regs.LR = 0x82245EEC; return 0x8221C4B8;
		/* 82245EE8h case   15:*/		return 0x82245EEC;
		  /* 82245EECh */ case   16:  		/* lwz R11, <#[R17]> */
		/* 82245EECh case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245EECh case   16:*/		return 0x82245EF0;
		  /* 82245EF0h */ case   17:  		/* mr R21, R3 */
		/* 82245EF0h case   17:*/		regs.R21 = regs.R3;
		/* 82245EF0h case   17:*/		return 0x82245EF4;
		  /* 82245EF4h */ case   18:  		/* lwz R10, <#[R18 + 4]> */
		/* 82245EF4h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000004) );
		/* 82245EF4h case   18:*/		return 0x82245EF8;
		  /* 82245EF8h */ case   19:  		/* stw R3, <#[R1 + 80]> */
		/* 82245EF8h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 82245EF8h case   19:*/		return 0x82245EFC;
		  /* 82245EFCh */ case   20:  		/* rlwinm R4, R10, 2, 0, 29 */
		/* 82245EFCh case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R10);
		/* 82245EFCh case   20:*/		return 0x82245F00;
		  /* 82245F00h */ case   21:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82245F00h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245F00h case   21:*/		return 0x82245F04;
		  /* 82245F04h */ case   22:  		/* bl -170572 */
		/* 82245F04h case   22:*/		regs.LR = 0x82245F08; return 0x8221C4B8;
		/* 82245F04h case   22:*/		return 0x82245F08;
		  /* 82245F08h */ case   23:  		/* lwz R11, <#[R17]> */
		/* 82245F08h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245F08h case   23:*/		return 0x82245F0C;
		  /* 82245F0Ch */ case   24:  		/* mr R19, R3 */
		/* 82245F0Ch case   24:*/		regs.R19 = regs.R3;
		/* 82245F0Ch case   24:*/		return 0x82245F10;
		  /* 82245F10h */ case   25:  		/* lwz R10, <#[R18 + 4]> */
		/* 82245F10h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000004) );
		/* 82245F10h case   25:*/		return 0x82245F14;
		  /* 82245F14h */ case   26:  		/* stw R3, <#[R1 + 88]> */
		/* 82245F14h case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 82245F14h case   26:*/		return 0x82245F18;
		  /* 82245F18h */ case   27:  		/* rlwinm R4, R10, 2, 0, 29 */
		/* 82245F18h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R10);
		/* 82245F18h case   27:*/		return 0x82245F1C;
		  /* 82245F1Ch */ case   28:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82245F1Ch case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245F1Ch case   28:*/		return 0x82245F20;
		  /* 82245F20h */ case   29:  		/* bl -170600 */
		/* 82245F20h case   29:*/		regs.LR = 0x82245F24; return 0x8221C4B8;
		/* 82245F20h case   29:*/		return 0x82245F24;
		  /* 82245F24h */ case   30:  		/* lwz R11, <#[R17]> */
		/* 82245F24h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245F24h case   30:*/		return 0x82245F28;
		  /* 82245F28h */ case   31:  		/* mr R25, R3 */
		/* 82245F28h case   31:*/		regs.R25 = regs.R3;
		/* 82245F28h case   31:*/		return 0x82245F2C;
		  /* 82245F2Ch */ case   32:  		/* lwz R10, <#[R23 + 4]> */
		/* 82245F2Ch case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000004) );
		/* 82245F2Ch case   32:*/		return 0x82245F30;
		  /* 82245F30h */ case   33:  		/* stw R3, <#[R1 + 140]> */
		/* 82245F30h case   33:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000008C) );
		/* 82245F30h case   33:*/		return 0x82245F34;
		  /* 82245F34h */ case   34:  		/* rlwinm R4, R10, 2, 0, 29 */
		/* 82245F34h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R10);
		/* 82245F34h case   34:*/		return 0x82245F38;
		  /* 82245F38h */ case   35:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82245F38h case   35:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245F38h case   35:*/		return 0x82245F3C;
		  /* 82245F3Ch */ case   36:  		/* bl -170628 */
		/* 82245F3Ch case   36:*/		regs.LR = 0x82245F40; return 0x8221C4B8;
		/* 82245F3Ch case   36:*/		return 0x82245F40;
	}
	return 0x82245F40;
} // Block from 82245EACh-82245F40h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82245F40h
// Function '?RemoveConstant@VRegTable@XGRAPHICS@@QAAXPAVIRLoadConst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245F40);
		  /* 82245F40h */ case    0:  		/* lwz R11, <#[R17]> */
		/* 82245F40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245F40h case    0:*/		return 0x82245F44;
		  /* 82245F44h */ case    1:  		/* mr R14, R3 */
		/* 82245F44h case    1:*/		regs.R14 = regs.R3;
		/* 82245F44h case    1:*/		return 0x82245F48;
		  /* 82245F48h */ case    2:  		/* lwz R10, <#[R23 + 4]> */
		/* 82245F48h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000004) );
		/* 82245F48h case    2:*/		return 0x82245F4C;
		  /* 82245F4Ch */ case    3:  		/* stw R3, <#[R1 + 128]> */
		/* 82245F4Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000080) );
		/* 82245F4Ch case    3:*/		return 0x82245F50;
		  /* 82245F50h */ case    4:  		/* rlwinm R4, R10, 2, 0, 29 */
		/* 82245F50h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R10);
		/* 82245F50h case    4:*/		return 0x82245F54;
		  /* 82245F54h */ case    5:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82245F54h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245F54h case    5:*/		return 0x82245F58;
		  /* 82245F58h */ case    6:  		/* bl -170656 */
		/* 82245F58h case    6:*/		regs.LR = 0x82245F5C; return 0x8221C4B8;
		/* 82245F58h case    6:*/		return 0x82245F5C;
		  /* 82245F5Ch */ case    7:  		/* lwz R11, <#[R17]> */
		/* 82245F5Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245F5Ch case    7:*/		return 0x82245F60;
		  /* 82245F60h */ case    8:  		/* mr R16, R3 */
		/* 82245F60h case    8:*/		regs.R16 = regs.R3;
		/* 82245F60h case    8:*/		return 0x82245F64;
		  /* 82245F64h */ case    9:  		/* lwz R10, <#[R23 + 4]> */
		/* 82245F64h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000004) );
		/* 82245F64h case    9:*/		return 0x82245F68;
		  /* 82245F68h */ case   10:  		/* stw R3, <#[R1 + 84]> */
		/* 82245F68h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 82245F68h case   10:*/		return 0x82245F6C;
		  /* 82245F6Ch */ case   11:  		/* rlwinm R4, R10, 2, 0, 29 */
		/* 82245F6Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R10);
		/* 82245F6Ch case   11:*/		return 0x82245F70;
		  /* 82245F70h */ case   12:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82245F70h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245F70h case   12:*/		return 0x82245F74;
		  /* 82245F74h */ case   13:  		/* bl -170684 */
		/* 82245F74h case   13:*/		regs.LR = 0x82245F78; return 0x8221C4B8;
		/* 82245F74h case   13:*/		return 0x82245F78;
		  /* 82245F78h */ case   14:  		/* lwz R11, <#[R23 + 4]> */
		/* 82245F78h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82245F78h case   14:*/		return 0x82245F7C;
		  /* 82245F7Ch */ case   15:  		/* mr R22, R3 */
		/* 82245F7Ch case   15:*/		regs.R22 = regs.R3;
		/* 82245F7Ch case   15:*/		return 0x82245F80;
		  /* 82245F80h */ case   16:  		/* lwz R10, <#[R18 + 4]> */
		/* 82245F80h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000004) );
		/* 82245F80h case   16:*/		return 0x82245F84;
		  /* 82245F84h */ case   17:  		/* mr R28, R24 */
		/* 82245F84h case   17:*/		regs.R28 = regs.R24;
		/* 82245F84h case   17:*/		return 0x82245F88;
		  /* 82245F88h */ case   18:  		/* addi R11, R11, 31 */
		/* 82245F88h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 82245F88h case   18:*/		return 0x82245F8C;
		  /* 82245F8Ch */ case   19:  		/* stw R3, <#[R1 + 92]> */
		/* 82245F8Ch case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 82245F8Ch case   19:*/		return 0x82245F90;
		  /* 82245F90h */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 82245F90h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82245F90h case   20:*/		return 0x82245F94;
		  /* 82245F94h */ case   21:  		/* rlwinm R20, R11, 27, 5, 31 */
		/* 82245F94h case   21:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R20,regs.R11);
		/* 82245F94h case   21:*/		return 0x82245F98;
		  /* 82245F98h */ case   22:  		/* bc 4, CR6_GT, 184 */
		/* 82245F98h case   22:*/		if ( !regs.CR[6].gt ) { return 0x82246050;  }
		/* 82245F98h case   22:*/		return 0x82245F9C;
		  /* 82245F9Ch */ case   23:  		/* rlwinm R30, R20, 2, 0, 29 */
		/* 82245F9Ch case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R20);
		/* 82245F9Ch case   23:*/		return 0x82245FA0;
		  /* 82245FA0h */ case   24:  		/* mr R31, R21 */
		/* 82245FA0h case   24:*/		regs.R31 = regs.R21;
		/* 82245FA0h case   24:*/		return 0x82245FA4;
		  /* 82245FA4h */ case   25:  		/* subf R27, R21, R15 */
		/* 82245FA4h case   25:*/		cpu::op::subf<0>(regs,&regs.R27,regs.R21,regs.R15);
		/* 82245FA4h case   25:*/		return 0x82245FA8;
		  /* 82245FA8h */ case   26:  		/* subf R26, R21, R19 */
		/* 82245FA8h case   26:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R21,regs.R19);
		/* 82245FA8h case   26:*/		return 0x82245FAC;
		  /* 82245FACh */ case   27:  		/* subf R29, R21, R25 */
		/* 82245FACh case   27:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R21,regs.R25);
		/* 82245FACh case   27:*/		return 0x82245FB0;
		  /* 82245FB0h */ case   28:  		/* lwz R11, <#[R17]> */
		/* 82245FB0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245FB0h case   28:*/		return 0x82245FB4;
		  /* 82245FB4h */ case   29:  		/* mr R4, R30 */
		/* 82245FB4h case   29:*/		regs.R4 = regs.R30;
		/* 82245FB4h case   29:*/		return 0x82245FB8;
	}
	return 0x82245FB8;
} // Block from 82245F40h-82245FB8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82245FB8h
// Function '?Init@VRegTable@XGRAPHICS@@QAAX_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82245FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82245FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82245FB8);
		  /* 82245FB8h */ case    0:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82245FB8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245FB8h case    0:*/		return 0x82245FBC;
		  /* 82245FBCh */ case    1:  		/* bl -170756 */
		/* 82245FBCh case    1:*/		regs.LR = 0x82245FC0; return 0x8221C4B8;
		/* 82245FBCh case    1:*/		return 0x82245FC0;
		  /* 82245FC0h */ case    2:  		/* stwx R3, <#[R27 + R31]> */
		/* 82245FC0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + regs.R31 + 0x00000000) );
		/* 82245FC0h case    2:*/		return 0x82245FC4;
		  /* 82245FC4h */ case    3:  		/* mr R4, R30 */
		/* 82245FC4h case    3:*/		regs.R4 = regs.R30;
		/* 82245FC4h case    3:*/		return 0x82245FC8;
		  /* 82245FC8h */ case    4:  		/* lwz R11, <#[R17]> */
		/* 82245FC8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245FC8h case    4:*/		return 0x82245FCC;
		  /* 82245FCCh */ case    5:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82245FCCh case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245FCCh case    5:*/		return 0x82245FD0;
		  /* 82245FD0h */ case    6:  		/* bl -170776 */
		/* 82245FD0h case    6:*/		regs.LR = 0x82245FD4; return 0x8221C4B8;
		/* 82245FD0h case    6:*/		return 0x82245FD4;
		  /* 82245FD4h */ case    7:  		/* stw R3, <#[R31]> */
		/* 82245FD4h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 82245FD4h case    7:*/		return 0x82245FD8;
		  /* 82245FD8h */ case    8:  		/* mr R4, R30 */
		/* 82245FD8h case    8:*/		regs.R4 = regs.R30;
		/* 82245FD8h case    8:*/		return 0x82245FDC;
		  /* 82245FDCh */ case    9:  		/* lwz R11, <#[R17]> */
		/* 82245FDCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245FDCh case    9:*/		return 0x82245FE0;
		  /* 82245FE0h */ case   10:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82245FE0h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245FE0h case   10:*/		return 0x82245FE4;
		  /* 82245FE4h */ case   11:  		/* bl -170796 */
		/* 82245FE4h case   11:*/		regs.LR = 0x82245FE8; return 0x8221C4B8;
		/* 82245FE4h case   11:*/		return 0x82245FE8;
		  /* 82245FE8h */ case   12:  		/* stwx R3, <#[R26 + R31]> */
		/* 82245FE8h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R26 + regs.R31 + 0x00000000) );
		/* 82245FE8h case   12:*/		return 0x82245FEC;
		  /* 82245FECh */ case   13:  		/* mr R4, R30 */
		/* 82245FECh case   13:*/		regs.R4 = regs.R30;
		/* 82245FECh case   13:*/		return 0x82245FF0;
		  /* 82245FF0h */ case   14:  		/* lwz R11, <#[R17]> */
		/* 82245FF0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82245FF0h case   14:*/		return 0x82245FF4;
		  /* 82245FF4h */ case   15:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82245FF4h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82245FF4h case   15:*/		return 0x82245FF8;
		  /* 82245FF8h */ case   16:  		/* bl -170816 */
		/* 82245FF8h case   16:*/		regs.LR = 0x82245FFC; return 0x8221C4B8;
		/* 82245FF8h case   16:*/		return 0x82245FFC;
		  /* 82245FFCh */ case   17:  		/* stwx R3, <#[R29 + R31]> */
		/* 82245FFCh case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 82245FFCh case   17:*/		return 0x82246000;
		  /* 82246000h */ case   18:  		/* cmpwi CR6, R20, 0 */
		/* 82246000h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 82246000h case   18:*/		return 0x82246004;
		  /* 82246004h */ case   19:  		/* bc 4, CR6_GT, 56 */
		/* 82246004h case   19:*/		if ( !regs.CR[6].gt ) { return 0x8224603C;  }
		/* 82246004h case   19:*/		return 0x82246008;
		  /* 82246008h */ case   20:  		/* rlwinm R10, R28, 2, 0, 29 */
		/* 82246008h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R28);
		/* 82246008h case   20:*/		return 0x8224600C;
		  /* 8224600Ch */ case   21:  		/* mtspr CTR, R20 */
		/* 8224600Ch case   21:*/		regs.CTR = regs.R20;
		/* 8224600Ch case   21:*/		return 0x82246010;
		  /* 82246010h */ case   22:  		/* mr R11, R24 */
		/* 82246010h case   22:*/		regs.R11 = regs.R24;
		/* 82246010h case   22:*/		return 0x82246014;
		  /* 82246014h */ case   23:  		/* lwzx R9, <#[R10 + R15]> */
		/* 82246014h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R15 + 0x00000000) );
		/* 82246014h case   23:*/		return 0x82246018;
		  /* 82246018h */ case   24:  		/* stwx R24, <#[R9 + R11]> */
		/* 82246018h case   24:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82246018h case   24:*/		return 0x8224601C;
		  /* 8224601Ch */ case   25:  		/* lwzx R9, <#[R10 + R21]> */
		/* 8224601Ch case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R21 + 0x00000000) );
		/* 8224601Ch case   25:*/		return 0x82246020;
		  /* 82246020h */ case   26:  		/* stwx R24, <#[R9 + R11]> */
		/* 82246020h case   26:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82246020h case   26:*/		return 0x82246024;
		  /* 82246024h */ case   27:  		/* lwzx R9, <#[R10 + R19]> */
		/* 82246024h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R19 + 0x00000000) );
		/* 82246024h case   27:*/		return 0x82246028;
		  /* 82246028h */ case   28:  		/* stwx R24, <#[R9 + R11]> */
		/* 82246028h case   28:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82246028h case   28:*/		return 0x8224602C;
		  /* 8224602Ch */ case   29:  		/* lwzx R9, <#[R29 + R31]> */
		/* 8224602Ch case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 8224602Ch case   29:*/		return 0x82246030;
		  /* 82246030h */ case   30:  		/* stwx R24, <#[R11 + R9]> */
		/* 82246030h case   30:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82246030h case   30:*/		return 0x82246034;
		  /* 82246034h */ case   31:  		/* addi R11, R11, 4 */
		/* 82246034h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82246034h case   31:*/		return 0x82246038;
		  /* 82246038h */ case   32:  		/* bc 16, CR0_LT, -36 */
		/* 82246038h case   32:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82246014;  }
		/* 82246038h case   32:*/		return 0x8224603C;
	}
	return 0x8224603C;
} // Block from 82245FB8h-8224603Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 8224603Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224603C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224603C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224603C);
		  /* 8224603Ch */ case    0:  		/* lwz R11, <#[R18 + 4]> */
		/* 8224603Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 8224603Ch case    0:*/		return 0x82246040;
		  /* 82246040h */ case    1:  		/* addi R28, R28, 1 */
		/* 82246040h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82246040h case    1:*/		return 0x82246044;
		  /* 82246044h */ case    2:  		/* addi R31, R31, 4 */
		/* 82246044h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82246044h case    2:*/		return 0x82246048;
		  /* 82246048h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 82246048h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82246048h case    3:*/		return 0x8224604C;
		  /* 8224604Ch */ case    4:  		/* bc 12, CR6_LT, -156 */
		/* 8224604Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82245FB0;  }
		/* 8224604Ch case    4:*/		return 0x82246050;
	}
	return 0x82246050;
} // Block from 8224603Ch-82246050h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82246050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246050);
		  /* 82246050h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246050h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246050h case    0:*/		return 0x82246054;
		  /* 82246054h */ case    1:  		/* mr R10, R24 */
		/* 82246054h case    1:*/		regs.R10 = regs.R24;
		/* 82246054h case    1:*/		return 0x82246058;
		  /* 82246058h */ case    2:  		/* li R24, 4 */
		/* 82246058h case    2:*/		cpu::op::li<0>(regs,&regs.R24,0x4);
		/* 82246058h case    2:*/		return 0x8224605C;
		  /* 8224605Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8224605Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224605Ch case    3:*/		return 0x82246060;
		  /* 82246060h */ case    4:  		/* bc 4, CR6_GT, 52 */
		/* 82246060h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82246094;  }
		/* 82246060h case    4:*/		return 0x82246064;
		  /* 82246064h */ case    5:  		/* mr R11, R16 */
		/* 82246064h case    5:*/		regs.R11 = regs.R16;
		/* 82246064h case    5:*/		return 0x82246068;
		  /* 82246068h */ case    6:  		/* subf R9, R16, R14 */
		/* 82246068h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R16,regs.R14);
		/* 82246068h case    6:*/		return 0x8224606C;
		  /* 8224606Ch */ case    7:  		/* subf R8, R16, R22 */
		/* 8224606Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R16,regs.R22);
		/* 8224606Ch case    7:*/		return 0x82246070;
		  /* 82246070h */ case    8:  		/* li R7, 0 */
		/* 82246070h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82246070h case    8:*/		return 0x82246074;
		  /* 82246074h */ case    9:  		/* stwx R7, <#[R9 + R11]> */
		/* 82246074h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82246074h case    9:*/		return 0x82246078;
		  /* 82246078h */ case   10:  		/* stw R10, <#[R11]> */
		/* 82246078h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82246078h case   10:*/		return 0x8224607C;
		  /* 8224607Ch */ case   11:  		/* addi R10, R10, 1 */
		/* 8224607Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8224607Ch case   11:*/		return 0x82246080;
		  /* 82246080h */ case   12:  		/* stwx R24, <#[R8 + R11]> */
		/* 82246080h case   12:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82246080h case   12:*/		return 0x82246084;
		  /* 82246084h */ case   13:  		/* addi R11, R11, 4 */
		/* 82246084h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82246084h case   13:*/		return 0x82246088;
		  /* 82246088h */ case   14:  		/* lwz R7, <#[R23 + 4]> */
		/* 82246088h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000004) );
		/* 82246088h case   14:*/		return 0x8224608C;
		  /* 8224608Ch */ case   15:  		/* cmplw CR6, R10, R7 */
		/* 8224608Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8224608Ch case   15:*/		return 0x82246090;
		  /* 82246090h */ case   16:  		/* bc 12, CR6_LT, -32 */
		/* 82246090h case   16:*/		if ( regs.CR[6].lt ) { return 0x82246070;  }
		/* 82246090h case   16:*/		return 0x82246094;
	}
	return 0x82246094;
} // Block from 82246050h-82246094h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82246094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246094);
		  /* 82246094h */ case    0:  		/* lwz R11, <#[R17]> */
		/* 82246094h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82246094h case    0:*/		return 0x82246098;
		  /* 82246098h */ case    1:  		/* rlwinm R31, R20, 2, 0, 29 */
		/* 82246098h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R20);
		/* 82246098h case    1:*/		return 0x8224609C;
		  /* 8224609Ch */ case    2:  		/* mr R4, R31 */
		/* 8224609Ch case    2:*/		regs.R4 = regs.R31;
		/* 8224609Ch case    2:*/		return 0x822460A0;
		  /* 822460A0h */ case    3:  		/* lwz R3, <#[R11 + 1456]> */
		/* 822460A0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 822460A0h case    3:*/		return 0x822460A4;
		  /* 822460A4h */ case    4:  		/* bl -170988 */
		/* 822460A4h case    4:*/		regs.LR = 0x822460A8; return 0x8221C4B8;
		/* 822460A4h case    4:*/		return 0x822460A8;
		  /* 822460A8h */ case    5:  		/* lwz R11, <#[R17]> */
		/* 822460A8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 822460A8h case    5:*/		return 0x822460AC;
		  /* 822460ACh */ case    6:  		/* mr R4, R31 */
		/* 822460ACh case    6:*/		regs.R4 = regs.R31;
		/* 822460ACh case    6:*/		return 0x822460B0;
		  /* 822460B0h */ case    7:  		/* stw R3, <#[R1 + 136]> */
		/* 822460B0h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000088) );
		/* 822460B0h case    7:*/		return 0x822460B4;
		  /* 822460B4h */ case    8:  		/* lwz R3, <#[R11 + 1456]> */
		/* 822460B4h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 822460B4h case    8:*/		return 0x822460B8;
		  /* 822460B8h */ case    9:  		/* bl -171008 */
		/* 822460B8h case    9:*/		regs.LR = 0x822460BC; return 0x8221C4B8;
		/* 822460B8h case    9:*/		return 0x822460BC;
		  /* 822460BCh */ case   10:  		/* lwz R11, <#[R17]> */
		/* 822460BCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 822460BCh case   10:*/		return 0x822460C0;
		  /* 822460C0h */ case   11:  		/* mr R4, R31 */
		/* 822460C0h case   11:*/		regs.R4 = regs.R31;
		/* 822460C0h case   11:*/		return 0x822460C4;
		  /* 822460C4h */ case   12:  		/* stw R3, <#[R1 + 96]> */
		/* 822460C4h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 822460C4h case   12:*/		return 0x822460C8;
		  /* 822460C8h */ case   13:  		/* lwz R3, <#[R11 + 1456]> */
		/* 822460C8h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 822460C8h case   13:*/		return 0x822460CC;
		  /* 822460CCh */ case   14:  		/* bl -171028 */
		/* 822460CCh case   14:*/		regs.LR = 0x822460D0; return 0x8221C4B8;
		/* 822460CCh case   14:*/		return 0x822460D0;
		  /* 822460D0h */ case   15:  		/* lwz R11, <#[R17]> */
		/* 822460D0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 822460D0h case   15:*/		return 0x822460D4;
		  /* 822460D4h */ case   16:  		/* mr R4, R31 */
		/* 822460D4h case   16:*/		regs.R4 = regs.R31;
		/* 822460D4h case   16:*/		return 0x822460D8;
		  /* 822460D8h */ case   17:  		/* stw R3, <#[R1 + 104]> */
		/* 822460D8h case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000068) );
		/* 822460D8h case   17:*/		return 0x822460DC;
		  /* 822460DCh */ case   18:  		/* lwz R3, <#[R11 + 1456]> */
		/* 822460DCh case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 822460DCh case   18:*/		return 0x822460E0;
		  /* 822460E0h */ case   19:  		/* bl -171048 */
		/* 822460E0h case   19:*/		regs.LR = 0x822460E4; return 0x8221C4B8;
		/* 822460E0h case   19:*/		return 0x822460E4;
		  /* 822460E4h */ case   20:  		/* lwz R11, <#[R23 + 4]> */
		/* 822460E4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 822460E4h case   20:*/		return 0x822460E8;
		  /* 822460E8h */ case   21:  		/* li R22, 0 */
		/* 822460E8h case   21:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 822460E8h case   21:*/		return 0x822460EC;
		  /* 822460ECh */ case   22:  		/* stw R3, <#[R1 + 108]> */
		/* 822460ECh case   22:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000006C) );
		/* 822460ECh case   22:*/		return 0x822460F0;
		  /* 822460F0h */ case   23:  		/* stw R25, <#[R1 + 144]> */
		/* 822460F0h case   23:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000090) );
		/* 822460F0h case   23:*/		return 0x822460F4;
		  /* 822460F4h */ case   24:  		/* cmplwi CR6, R11, 0 */
		/* 822460F4h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822460F4h case   24:*/		return 0x822460F8;
		  /* 822460F8h */ case   25:  		/* stw R19, <#[R1 + 148]> */
		/* 822460F8h case   25:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000094) );
		/* 822460F8h case   25:*/		return 0x822460FC;
		  /* 822460FCh */ case   26:  		/* stw R21, <#[R1 + 152]> */
		/* 822460FCh case   26:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000098) );
		/* 822460FCh case   26:*/		return 0x82246100;
		  /* 82246100h */ case   27:  		/* stw R15, <#[R1 + 156]> */
		/* 82246100h case   27:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x0000009C) );
		/* 82246100h case   27:*/		return 0x82246104;
		  /* 82246104h */ case   28:  		/* bc 12, CR6_EQ, 248 */
		/* 82246104h case   28:*/		if ( regs.CR[6].eq ) { return 0x822461FC;  }
		/* 82246104h case   28:*/		return 0x82246108;
		  /* 82246108h */ case   29:  		/* lwz R10, <#[R1 + 92]> */
		/* 82246108h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82246108h case   29:*/		return 0x8224610C;
		  /* 8224610Ch */ case   30:  		/* li R27, 0 */
		/* 8224610Ch case   30:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8224610Ch case   30:*/		return 0x82246110;
		  /* 82246110h */ case   31:  		/* mr R29, R16 */
		/* 82246110h case   31:*/		regs.R29 = regs.R16;
		/* 82246110h case   31:*/		return 0x82246114;
		  /* 82246114h */ case   32:  		/* subf R26, R16, R14 */
		/* 82246114h case   32:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R16,regs.R14);
		/* 82246114h case   32:*/		return 0x82246118;
		  /* 82246118h */ case   33:  		/* subf R25, R16, R10 */
		/* 82246118h case   33:*/		cpu::op::subf<0>(regs,&regs.R25,regs.R16,regs.R10);
		/* 82246118h case   33:*/		return 0x8224611C;
		  /* 8224611Ch */ case   34:  		/* cmplw CR6, R22, R11 */
		/* 8224611Ch case   34:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 8224611Ch case   34:*/		return 0x82246120;
		  /* 82246120h */ case   35:  		/* bc 4, CR6_LT, 16 */
		/* 82246120h case   35:*/		if ( !regs.CR[6].lt ) { return 0x82246130;  }
		/* 82246120h case   35:*/		return 0x82246124;
		  /* 82246124h */ case   36:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246124h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246124h case   36:*/		return 0x82246128;
		  /* 82246128h */ case   37:  		/* add R3, R11, R27 */
		/* 82246128h case   37:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R27);
		/* 82246128h case   37:*/		return 0x8224612C;
		  /* 8224612Ch */ case   38:  		/* b 16 */
		/* 8224612Ch case   38:*/		return 0x8224613C;
		/* 8224612Ch case   38:*/		return 0x82246130;
	}
	return 0x82246130;
} // Block from 82246094h-82246130h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82246130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246130);
		  /* 82246130h */ case    0:  		/* mr R4, R22 */
		/* 82246130h case    0:*/		regs.R4 = regs.R22;
		/* 82246130h case    0:*/		return 0x82246134;
		  /* 82246134h */ case    1:  		/* mr R3, R23 */
		/* 82246134h case    1:*/		regs.R3 = regs.R23;
		/* 82246134h case    1:*/		return 0x82246138;
		  /* 82246138h */ case    2:  		/* bl 55688 */
		/* 82246138h case    2:*/		regs.LR = 0x8224613C; return 0x82253AC0;
		/* 82246138h case    2:*/		return 0x8224613C;
	}
	return 0x8224613C;
} // Block from 82246130h-8224613Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224613Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224613C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224613C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224613C);
		  /* 8224613Ch */ case    0:  		/* lwz R9, <#[R3]> */
		/* 8224613Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8224613Ch case    0:*/		return 0x82246140;
		  /* 82246140h */ case    1:  		/* li R10, 0 */
		/* 82246140h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82246140h case    1:*/		return 0x82246144;
		  /* 82246144h */ case    2:  		/* li R11, 928 */
		/* 82246144h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3A0);
		/* 82246144h case    2:*/		return 0x82246148;
		  /* 82246148h */ case    3:  		/* lwzx R8, <#[R9 + R11]> */
		/* 82246148h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82246148h case    3:*/		return 0x8224614C;
		  /* 8224614Ch */ case    4:  		/* cmplwi CR6, R8, 0 */
		/* 8224614Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8224614Ch case    4:*/		return 0x82246150;
		  /* 82246150h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82246150h case    5:*/		if ( regs.CR[6].eq ) { return 0x82246164;  }
		/* 82246150h case    5:*/		return 0x82246154;
		  /* 82246154h */ case    6:  		/* addi R11, R11, 4 */
		/* 82246154h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82246154h case    6:*/		return 0x82246158;
		  /* 82246158h */ case    7:  		/* addi R10, R10, 1 */
		/* 82246158h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82246158h case    7:*/		return 0x8224615C;
		  /* 8224615Ch */ case    8:  		/* cmpwi CR6, R11, 944 */
		/* 8224615Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x000003B0);
		/* 8224615Ch case    8:*/		return 0x82246160;
		  /* 82246160h */ case    9:  		/* bc 12, CR6_LT, -24 */
		/* 82246160h case    9:*/		if ( regs.CR[6].lt ) { return 0x82246148;  }
		/* 82246160h case    9:*/		return 0x82246164;
	}
	return 0x82246164;
} // Block from 8224613Ch-82246164h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82246164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246164);
		  /* 82246164h */ case    0:  		/* cmpwi CR6, R10, 4 */
		/* 82246164h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000004);
		/* 82246164h case    0:*/		return 0x82246168;
		  /* 82246168h */ case    1:  		/* bc 4, CR6_EQ, 148 */
		/* 82246168h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822461FC;  }
		/* 82246168h case    1:*/		return 0x8224616C;
		  /* 8224616Ch */ case    2:  		/* rlwinm R11, R22, 0, 27, 31 */
		/* 8224616Ch case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R22);
		/* 8224616Ch case    2:*/		return 0x82246170;
		  /* 82246170h */ case    3:  		/* stwx R24, <#[R26 + R29]> */
		/* 82246170h case    3:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R26 + regs.R29 + 0x00000000) );
		/* 82246170h case    3:*/		return 0x82246174;
		  /* 82246174h */ case    4:  		/* li R10, 0 */
		/* 82246174h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82246174h case    4:*/		return 0x82246178;
		  /* 82246178h */ case    5:  		/* stw R22, <#[R29]> */
		/* 82246178h case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R29 + 0x00000000) );
		/* 82246178h case    5:*/		return 0x8224617C;
		  /* 8224617Ch */ case    6:  		/* li R9, 1 */
		/* 8224617Ch case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8224617Ch case    6:*/		return 0x82246180;
		  /* 82246180h */ case    7:  		/* stwx R10, <#[R25 + R29]> */
		/* 82246180h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + regs.R29 + 0x00000000) );
		/* 82246180h case    7:*/		return 0x82246184;
		  /* 82246184h */ case    8:  		/* rlwinm R30, R22, 29, 3, 29 */
		/* 82246184h case    8:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R30,regs.R22);
		/* 82246184h case    8:*/		return 0x82246188;
		  /* 82246188h */ case    9:  		/* slw R28, R9, R11 */
		/* 82246188h case    9:*/		cpu::op::slw<0>(regs,&regs.R28,regs.R9,regs.R11);
		/* 82246188h case    9:*/		return 0x8224618C;
		  /* 8224618Ch */ case   10:  		/* li R31, 896 */
		/* 8224618Ch case   10:*/		cpu::op::li<0>(regs,&regs.R31,0x380);
		/* 8224618Ch case   10:*/		return 0x82246190;
		  /* 82246190h */ case   11:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246190h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246190h case   11:*/		return 0x82246194;
		  /* 82246194h */ case   12:  		/* cmplw CR6, R22, R11 */
		/* 82246194h case   12:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82246194h case   12:*/		return 0x82246198;
		  /* 82246198h */ case   13:  		/* bc 4, CR6_LT, 16 */
		/* 82246198h case   13:*/		if ( !regs.CR[6].lt ) { return 0x822461A8;  }
		/* 82246198h case   13:*/		return 0x8224619C;
		  /* 8224619Ch */ case   14:  		/* lwz R11, <#[R23 + 8]> */
		/* 8224619Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8224619Ch case   14:*/		return 0x822461A0;
		  /* 822461A0h */ case   15:  		/* add R3, R11, R27 */
		/* 822461A0h case   15:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R27);
		/* 822461A0h case   15:*/		return 0x822461A4;
		  /* 822461A4h */ case   16:  		/* b 16 */
		/* 822461A4h case   16:*/		return 0x822461B4;
		/* 822461A4h case   16:*/		return 0x822461A8;
	}
	return 0x822461A8;
} // Block from 82246164h-822461A8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822461A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822461A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822461A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822461A8);
		  /* 822461A8h */ case    0:  		/* mr R4, R22 */
		/* 822461A8h case    0:*/		regs.R4 = regs.R22;
		/* 822461A8h case    0:*/		return 0x822461AC;
		  /* 822461ACh */ case    1:  		/* mr R3, R23 */
		/* 822461ACh case    1:*/		regs.R3 = regs.R23;
		/* 822461ACh case    1:*/		return 0x822461B0;
		  /* 822461B0h */ case    2:  		/* bl 55568 */
		/* 822461B0h case    2:*/		regs.LR = 0x822461B4; return 0x82253AC0;
		/* 822461B0h case    2:*/		return 0x822461B4;
	}
	return 0x822461B4;
} // Block from 822461A8h-822461B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822461B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822461B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822461B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822461B4);
		  /* 822461B4h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 822461B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822461B4h case    0:*/		return 0x822461B8;
		  /* 822461B8h */ case    1:  		/* mr R3, R18 */
		/* 822461B8h case    1:*/		regs.R3 = regs.R18;
		/* 822461B8h case    1:*/		return 0x822461BC;
		  /* 822461BCh */ case    2:  		/* ldx R4, <#[R11 + R31]> */
		/* 822461BCh case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 822461BCh case    2:*/		return 0x822461C0;
		  /* 822461C0h */ case    3:  		/* bl -1584 */
		/* 822461C0h case    3:*/		regs.LR = 0x822461C4; return 0x82245B90;
		/* 822461C0h case    3:*/		return 0x822461C4;
		  /* 822461C4h */ case    4:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 822461C4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 822461C4h case    4:*/		return 0x822461C8;
		  /* 822461C8h */ case    5:  		/* addi R31, R31, 8 */
		/* 822461C8h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 822461C8h case    5:*/		return 0x822461CC;
		  /* 822461CCh */ case    6:  		/* cmpwi CR6, R31, 928 */
		/* 822461CCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x000003A0);
		/* 822461CCh case    6:*/		return 0x822461D0;
		  /* 822461D0h */ case    7:  		/* lwzx R11, <#[R11 + R15]> */
		/* 822461D0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R15 + 0x00000000) );
		/* 822461D0h case    7:*/		return 0x822461D4;
		  /* 822461D4h */ case    8:  		/* lwzx R10, <#[R30 + R11]> */
		/* 822461D4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 822461D4h case    8:*/		return 0x822461D8;
		  /* 822461D8h */ case    9:  		/* or R10, R28, R10 */
		/* 822461D8h case    9:*/		cpu::op::or<0>(regs,&regs.R10,regs.R28,regs.R10);
		/* 822461D8h case    9:*/		return 0x822461DC;
		  /* 822461DCh */ case   10:  		/* stwx R10, <#[R30 + R11]> */
		/* 822461DCh case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 822461DCh case   10:*/		return 0x822461E0;
		  /* 822461E0h */ case   11:  		/* bc 12, CR6_LT, -80 */
		/* 822461E0h case   11:*/		if ( regs.CR[6].lt ) { return 0x82246190;  }
		/* 822461E0h case   11:*/		return 0x822461E4;
		  /* 822461E4h */ case   12:  		/* lwz R11, <#[R23 + 4]> */
		/* 822461E4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 822461E4h case   12:*/		return 0x822461E8;
		  /* 822461E8h */ case   13:  		/* addi R22, R22, 1 */
		/* 822461E8h case   13:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 822461E8h case   13:*/		return 0x822461EC;
		  /* 822461ECh */ case   14:  		/* addi R27, R27, 4 */
		/* 822461ECh case   14:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 822461ECh case   14:*/		return 0x822461F0;
		  /* 822461F0h */ case   15:  		/* addi R29, R29, 4 */
		/* 822461F0h case   15:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 822461F0h case   15:*/		return 0x822461F4;
		  /* 822461F4h */ case   16:  		/* cmplw CR6, R22, R11 */
		/* 822461F4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 822461F4h case   16:*/		return 0x822461F8;
		  /* 822461F8h */ case   17:  		/* bc 12, CR6_LT, -212 */
		/* 822461F8h case   17:*/		if ( regs.CR[6].lt ) { return 0x82246124;  }
		/* 822461F8h case   17:*/		return 0x822461FC;
	}
	return 0x822461FC;
} // Block from 822461B4h-822461FCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 822461FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822461FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822461FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822461FC);
		  /* 822461FCh */ case    0:  		/* lwz R6, <#[R23 + 4]> */
		/* 822461FCh case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R23 + 0x00000004) );
		/* 822461FCh case    0:*/		return 0x82246200;
		  /* 82246200h */ case    1:  		/* li R19, -1 */
		/* 82246200h case    1:*/		cpu::op::li<0>(regs,&regs.R19,0xFFFFFFFF);
		/* 82246200h case    1:*/		return 0x82246204;
		  /* 82246204h */ case    2:  		/* mr R15, R22 */
		/* 82246204h case    2:*/		regs.R15 = regs.R22;
		/* 82246204h case    2:*/		return 0x82246208;
		  /* 82246208h */ case    3:  		/* mr R16, R19 */
		/* 82246208h case    3:*/		regs.R16 = regs.R19;
		/* 82246208h case    3:*/		return 0x8224620C;
		  /* 8224620Ch */ case    4:  		/* mr R14, R19 */
		/* 8224620Ch case    4:*/		regs.R14 = regs.R19;
		/* 8224620Ch case    4:*/		return 0x82246210;
		  /* 82246210h */ case    5:  		/* cmplw CR6, R22, R6 */
		/* 82246210h case    5:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R6);
		/* 82246210h case    5:*/		return 0x82246214;
		  /* 82246214h */ case    6:  		/* bc 4, CR6_LT, 2672 */
		/* 82246214h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82246C84;  }
		/* 82246214h case    6:*/		return 0x82246218;
		  /* 82246218h */ case    7:  		/* lwz R21, <#[R1 + 120]> */
		/* 82246218h case    7:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000078) );
		/* 82246218h case    7:*/		return 0x8224621C;
		  /* 8224621Ch */ case    8:  		/* lwz R24, <#[R1 + 116]> */
		/* 8224621Ch case    8:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000074) );
		/* 8224621Ch case    8:*/		return 0x82246220;
		  /* 82246220h */ case    9:  		/* lwz R25, <#[R1 + 112]> */
		/* 82246220h case    9:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000070) );
		/* 82246220h case    9:*/		return 0x82246224;
		  /* 82246224h */ case   10:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246224h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246224h case   10:*/		return 0x82246228;
	}
	return 0x82246228;
} // Block from 822461FCh-82246228h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82246228h
// Function '?Clear@VRegTable@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246228);
		  /* 82246228h */ case    0:  		/* rlwinm R10, R22, 2, 0, 29 */
		/* 82246228h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R22);
		/* 82246228h case    0:*/		return 0x8224622C;
		  /* 8224622Ch */ case    1:  		/* li R31, 0 */
		/* 8224622Ch case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8224622Ch case    1:*/		return 0x82246230;
		  /* 82246230h */ case    2:  		/* add R3, R10, R11 */
		/* 82246230h case    2:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82246230h case    2:*/		return 0x82246234;
		  /* 82246234h */ case    3:  		/* li R11, 928 */
		/* 82246234h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x3A0);
		/* 82246234h case    3:*/		return 0x82246238;
		  /* 82246238h */ case    4:  		/* lwz R10, <#[R3]> */
		/* 82246238h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82246238h case    4:*/		return 0x8224623C;
		  /* 8224623Ch */ case    5:  		/* lwzx R9, <#[R10 + R11]> */
		/* 8224623Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224623Ch case    5:*/		return 0x82246240;
		  /* 82246240h */ case    6:  		/* cmplwi CR6, R9, 0 */
		/* 82246240h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82246240h case    6:*/		return 0x82246244;
		  /* 82246244h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82246244h case    7:*/		if ( regs.CR[6].eq ) { return 0x82246258;  }
		/* 82246244h case    7:*/		return 0x82246248;
		  /* 82246248h */ case    8:  		/* addi R11, R11, 4 */
		/* 82246248h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82246248h case    8:*/		return 0x8224624C;
		  /* 8224624Ch */ case    9:  		/* addi R31, R31, 1 */
		/* 8224624Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224624Ch case    9:*/		return 0x82246250;
		  /* 82246250h */ case   10:  		/* cmpwi CR6, R11, 944 */
		/* 82246250h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x000003B0);
		/* 82246250h case   10:*/		return 0x82246254;
		  /* 82246254h */ case   11:  		/* bc 12, CR6_LT, -24 */
		/* 82246254h case   11:*/		if ( regs.CR[6].lt ) { return 0x8224623C;  }
		/* 82246254h case   11:*/		return 0x82246258;
	}
	return 0x82246258;
} // Block from 82246228h-82246258h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82246258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246258);
		  /* 82246258h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246258h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246258h case    0:*/		return 0x8224625C;
		  /* 8224625Ch */ case    1:  		/* cmplw CR6, R22, R11 */
		/* 8224625Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 8224625Ch case    1:*/		return 0x82246260;
		  /* 82246260h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 82246260h case    2:*/		if ( regs.CR[6].lt ) { return 0x82246270;  }
		/* 82246260h case    2:*/		return 0x82246264;
		  /* 82246264h */ case    3:  		/* mr R4, R22 */
		/* 82246264h case    3:*/		regs.R4 = regs.R22;
		/* 82246264h case    3:*/		return 0x82246268;
		  /* 82246268h */ case    4:  		/* mr R3, R23 */
		/* 82246268h case    4:*/		regs.R3 = regs.R23;
		/* 82246268h case    4:*/		return 0x8224626C;
		  /* 8224626Ch */ case    5:  		/* bl 55380 */
		/* 8224626Ch case    5:*/		regs.LR = 0x82246270; return 0x82253AC0;
		/* 8224626Ch case    5:*/		return 0x82246270;
	}
	return 0x82246270;
} // Block from 82246258h-82246270h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82246270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246270);
		  /* 82246270h */ case    0:  		/* lwz R11, <#[R1 + 92]> */
		/* 82246270h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82246270h case    0:*/		return 0x82246274;
		  /* 82246274h */ case    1:  		/* rlwinm R26, R22, 2, 0, 29 */
		/* 82246274h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R22);
		/* 82246274h case    1:*/		return 0x82246278;
		  /* 82246278h */ case    2:  		/* subfic R10, R31, 4 */
		/* 82246278h case    2:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R31,0x4);
		/* 82246278h case    2:*/		return 0x8224627C;
		  /* 8224627Ch */ case    3:  		/* lwz R3, <#[R1 + 96]> */
		/* 8224627Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8224627Ch case    3:*/		return 0x82246280;
		  /* 82246280h */ case    4:  		/* cmpwi CR6, R20, 0 */
		/* 82246280h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 82246280h case    4:*/		return 0x82246284;
		  /* 82246284h */ case    5:  		/* stwx R10, <#[R26 + R11]> */
		/* 82246284h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 82246284h case    5:*/		return 0x82246288;
		  /* 82246288h */ case    6:  		/* bc 4, CR6_GT, 60 */
		/* 82246288h case    6:*/		if ( !regs.CR[6].gt ) { return 0x822462C4;  }
		/* 82246288h case    6:*/		return 0x8224628C;
		  /* 8224628Ch */ case    7:  		/* lwz R10, <#[R1 + 136]> */
		/* 8224628Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 8224628Ch case    7:*/		return 0x82246290;
		  /* 82246290h */ case    8:  		/* mtspr CTR, R20 */
		/* 82246290h case    8:*/		regs.CTR = regs.R20;
		/* 82246290h case    8:*/		return 0x82246294;
		  /* 82246294h */ case    9:  		/* lwz R9, <#[R1 + 104]> */
		/* 82246294h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000068) );
		/* 82246294h case    9:*/		return 0x82246298;
		  /* 82246298h */ case   10:  		/* mr R11, R3 */
		/* 82246298h case   10:*/		regs.R11 = regs.R3;
		/* 82246298h case   10:*/		return 0x8224629C;
		  /* 8224629Ch */ case   11:  		/* lwz R8, <#[R1 + 108]> */
		/* 8224629Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000006C) );
		/* 8224629Ch case   11:*/		return 0x822462A0;
		  /* 822462A0h */ case   12:  		/* subf R10, R3, R10 */
		/* 822462A0h case   12:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R3,regs.R10);
		/* 822462A0h case   12:*/		return 0x822462A4;
		  /* 822462A4h */ case   13:  		/* subf R9, R3, R9 */
		/* 822462A4h case   13:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R3,regs.R9);
		/* 822462A4h case   13:*/		return 0x822462A8;
		  /* 822462A8h */ case   14:  		/* subf R8, R3, R8 */
		/* 822462A8h case   14:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R3,regs.R8);
		/* 822462A8h case   14:*/		return 0x822462AC;
		  /* 822462ACh */ case   15:  		/* stwx R19, <#[R10 + R11]> */
		/* 822462ACh case   15:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822462ACh case   15:*/		return 0x822462B0;
		  /* 822462B0h */ case   16:  		/* stw R19, <#[R11]> */
		/* 822462B0h case   16:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000000) );
		/* 822462B0h case   16:*/		return 0x822462B4;
		  /* 822462B4h */ case   17:  		/* stwx R19, <#[R9 + R11]> */
		/* 822462B4h case   17:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 822462B4h case   17:*/		return 0x822462B8;
		  /* 822462B8h */ case   18:  		/* stwx R19, <#[R8 + R11]> */
		/* 822462B8h case   18:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 822462B8h case   18:*/		return 0x822462BC;
		  /* 822462BCh */ case   19:  		/* addi R11, R11, 4 */
		/* 822462BCh case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822462BCh case   19:*/		return 0x822462C0;
		  /* 822462C0h */ case   20:  		/* bc 16, CR0_LT, -20 */
		/* 822462C0h case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822462AC;  }
		/* 822462C0h case   20:*/		return 0x822462C4;
	}
	return 0x822462C4;
} // Block from 82246270h-822462C4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 822462C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822462C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822462C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822462C4);
		  /* 822462C4h */ case    0:  		/* lwz R11, <#[R1 + 128]> */
		/* 822462C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 822462C4h case    0:*/		return 0x822462C8;
		  /* 822462C8h */ case    1:  		/* cmpwi CR6, R16, -1 */
		/* 822462C8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R16,0xFFFFFFFF);
		/* 822462C8h case    1:*/		return 0x822462CC;
		  /* 822462CCh */ case    2:  		/* stwx R31, <#[R26 + R11]> */
		/* 822462CCh case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 822462CCh case    2:*/		return 0x822462D0;
		  /* 822462D0h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 822462D0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822462DC;  }
		/* 822462D0h case    3:*/		return 0x822462D4;
		  /* 822462D4h */ case    4:  		/* cmpwi CR6, R31, 2 */
		/* 822462D4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000002);
		/* 822462D4h case    4:*/		return 0x822462D8;
		  /* 822462D8h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 822462D8h case    5:*/		if ( regs.CR[6].eq ) { return 0x822462F8;  }
		/* 822462D8h case    5:*/		return 0x822462DC;
	}
	return 0x822462DC;
} // Block from 822462C4h-822462DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 822462DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822462DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822462DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822462DC);
		  /* 822462DCh */ case    0:  		/* cmpwi CR6, R14, -1 */
		/* 822462DCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0xFFFFFFFF);
		/* 822462DCh case    0:*/		return 0x822462E0;
		  /* 822462E0h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 822462E0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822462FC;  }
		/* 822462E0h case    1:*/		return 0x822462E4;
		  /* 822462E4h */ case    2:  		/* cmpwi CR6, R31, 1 */
		/* 822462E4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000001);
		/* 822462E4h case    2:*/		return 0x822462E8;
		  /* 822462E8h */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 822462E8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822462FC;  }
		/* 822462E8h case    3:*/		return 0x822462EC;
		  /* 822462ECh */ case    4:  		/* mr R14, R22 */
		/* 822462ECh case    4:*/		regs.R14 = regs.R22;
		/* 822462ECh case    4:*/		return 0x822462F0;
	}
	return 0x822462F0;
} // Block from 822462DCh-822462F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822462F0h
// Function '??1VRegTable@XGRAPHICS@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822462F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822462F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822462F0);
		  /* 822462F0h */ case    0:  		/* cmpwi CR6, R16, -1 */
		/* 822462F0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R16,0xFFFFFFFF);
		/* 822462F0h case    0:*/		return 0x822462F4;
		  /* 822462F4h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 822462F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822462FC;  }
		/* 822462F4h case    1:*/		return 0x822462F8;
	}
	return 0x822462F8;
} // Block from 822462F0h-822462F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822462F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822462F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822462F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822462F8);
		  /* 822462F8h */ case    0:  		/* mr R16, R22 */
		/* 822462F8h case    0:*/		regs.R16 = regs.R22;
		/* 822462F8h case    0:*/		return 0x822462FC;
	}
	return 0x822462FC;
} // Block from 822462F8h-822462FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822462FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822462FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822462FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822462FC);
		  /* 822462FCh */ case    0:  		/* li R27, 0 */
		/* 822462FCh case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 822462FCh case    0:*/		return 0x82246300;
		  /* 82246300h */ case    1:  		/* cmpwi CR6, R31, 0 */
		/* 82246300h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82246300h case    1:*/		return 0x82246304;
		  /* 82246304h */ case    2:  		/* bc 4, CR6_GT, 400 */
		/* 82246304h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82246494;  }
		/* 82246304h case    2:*/		return 0x82246308;
		  /* 82246308h */ case    3:  		/* li R28, 896 */
		/* 82246308h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x380);
		/* 82246308h case    3:*/		return 0x8224630C;
		  /* 8224630Ch */ case    4:  		/* lwz R11, <#[R23 + 4]> */
		/* 8224630Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8224630Ch case    4:*/		return 0x82246310;
		  /* 82246310h */ case    5:  		/* cmplw CR6, R22, R11 */
		/* 82246310h case    5:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82246310h case    5:*/		return 0x82246314;
		  /* 82246314h */ case    6:  		/* bc 4, CR6_LT, 16 */
		/* 82246314h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82246324;  }
		/* 82246314h case    6:*/		return 0x82246318;
		  /* 82246318h */ case    7:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246318h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246318h case    7:*/		return 0x8224631C;
		  /* 8224631Ch */ case    8:  		/* add R3, R11, R26 */
		/* 8224631Ch case    8:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 8224631Ch case    8:*/		return 0x82246320;
		  /* 82246320h */ case    9:  		/* b 16 */
		/* 82246320h case    9:*/		return 0x82246330;
		/* 82246320h case    9:*/		return 0x82246324;
	}
	return 0x82246324;
} // Block from 822462FCh-82246324h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82246324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246324);
		  /* 82246324h */ case    0:  		/* mr R4, R22 */
		/* 82246324h case    0:*/		regs.R4 = regs.R22;
		/* 82246324h case    0:*/		return 0x82246328;
		  /* 82246328h */ case    1:  		/* mr R3, R23 */
		/* 82246328h case    1:*/		regs.R3 = regs.R23;
		/* 82246328h case    1:*/		return 0x8224632C;
		  /* 8224632Ch */ case    2:  		/* bl 55188 */
		/* 8224632Ch case    2:*/		regs.LR = 0x82246330; return 0x82253AC0;
		/* 8224632Ch case    2:*/		return 0x82246330;
	}
	return 0x82246330;
} // Block from 82246324h-82246330h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246330);
		  /* 82246330h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246330h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246330h case    0:*/		return 0x82246334;
		  /* 82246334h */ case    1:  		/* mr R3, R18 */
		/* 82246334h case    1:*/		regs.R3 = regs.R18;
		/* 82246334h case    1:*/		return 0x82246338;
		  /* 82246338h */ case    2:  		/* ldx R4, <#[R28 + R11]> */
		/* 82246338h case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 82246338h case    2:*/		return 0x8224633C;
		  /* 8224633Ch */ case    3:  		/* bl -1964 */
		/* 8224633Ch case    3:*/		regs.LR = 0x82246340; return 0x82245B90;
		/* 8224633Ch case    3:*/		return 0x82246340;
		  /* 82246340h */ case    4:  		/* lwz R11, <#[R1 + 100]> */
		/* 82246340h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82246340h case    4:*/		return 0x82246344;
		  /* 82246344h */ case    5:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82246344h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82246344h case    5:*/		return 0x82246348;
		  /* 82246348h */ case    6:  		/* lwz R9, <#[R23 + 4]> */
		/* 82246348h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000004) );
		/* 82246348h case    6:*/		return 0x8224634C;
		  /* 8224634Ch */ case    7:  		/* cmplw CR6, R22, R9 */
		/* 8224634Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R9);
		/* 8224634Ch case    7:*/		return 0x82246350;
		  /* 82246350h */ case    8:  		/* lwzx R29, <#[R10 + R11]> */
		/* 82246350h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82246350h case    8:*/		return 0x82246354;
		  /* 82246354h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 82246354h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82246364;  }
		/* 82246354h case    9:*/		return 0x82246358;
		  /* 82246358h */ case   10:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246358h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246358h case   10:*/		return 0x8224635C;
		  /* 8224635Ch */ case   11:  		/* add R3, R11, R26 */
		/* 8224635Ch case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 8224635Ch case   11:*/		return 0x82246360;
		  /* 82246360h */ case   12:  		/* b 16 */
		/* 82246360h case   12:*/		return 0x82246370;
		/* 82246360h case   12:*/		return 0x82246364;
	}
	return 0x82246364;
} // Block from 82246330h-82246364h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82246364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246364);
		  /* 82246364h */ case    0:  		/* mr R4, R22 */
		/* 82246364h case    0:*/		regs.R4 = regs.R22;
		/* 82246364h case    0:*/		return 0x82246368;
		  /* 82246368h */ case    1:  		/* mr R3, R23 */
		/* 82246368h case    1:*/		regs.R3 = regs.R23;
		/* 82246368h case    1:*/		return 0x8224636C;
		  /* 8224636Ch */ case    2:  		/* bl 55124 */
		/* 8224636Ch case    2:*/		regs.LR = 0x82246370; return 0x82253AC0;
		/* 8224636Ch case    2:*/		return 0x82246370;
	}
	return 0x82246370;
} // Block from 82246364h-82246370h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246370);
		  /* 82246370h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246370h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246370h case    0:*/		return 0x82246374;
		  /* 82246374h */ case    1:  		/* mr R3, R18 */
		/* 82246374h case    1:*/		regs.R3 = regs.R18;
		/* 82246374h case    1:*/		return 0x82246378;
	}
	return 0x82246378;
} // Block from 82246370h-82246378h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82246378h
// Function '?FindOrCreate@VRegTable@XGRAPHICS@@QAAPAVVRegInfo@2@W4RegType@R400Tables@@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246378);
		  /* 82246378h */ case    0:  		/* ldx R4, <#[R28 + R11]> */
		/* 82246378h case    0:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 82246378h case    0:*/		return 0x8224637C;
		  /* 8224637Ch */ case    1:  		/* bl -2028 */
		/* 8224637Ch case    1:*/		regs.LR = 0x82246380; return 0x82245B90;
		/* 8224637Ch case    1:*/		return 0x82246380;
		  /* 82246380h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 82246380h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82246380h case    2:*/		return 0x82246384;
		  /* 82246384h */ case    3:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82246384h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82246384h case    3:*/		return 0x82246388;
		  /* 82246388h */ case    4:  		/* lwz R9, <#[R23 + 4]> */
		/* 82246388h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000004) );
		/* 82246388h case    4:*/		return 0x8224638C;
		  /* 8224638Ch */ case    5:  		/* cmplw CR6, R22, R9 */
		/* 8224638Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R9);
		/* 8224638Ch case    5:*/		return 0x82246390;
		  /* 82246390h */ case    6:  		/* lwzx R30, <#[R10 + R11]> */
		/* 82246390h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82246390h case    6:*/		return 0x82246394;
		  /* 82246394h */ case    7:  		/* bc 4, CR6_LT, 16 */
		/* 82246394h case    7:*/		if ( !regs.CR[6].lt ) { return 0x822463A4;  }
		/* 82246394h case    7:*/		return 0x82246398;
		  /* 82246398h */ case    8:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246398h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246398h case    8:*/		return 0x8224639C;
		  /* 8224639Ch */ case    9:  		/* add R3, R11, R26 */
		/* 8224639Ch case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 8224639Ch case    9:*/		return 0x822463A0;
		  /* 822463A0h */ case   10:  		/* b 16 */
		/* 822463A0h case   10:*/		return 0x822463B0;
		/* 822463A0h case   10:*/		return 0x822463A4;
	}
	return 0x822463A4;
} // Block from 82246378h-822463A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822463A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822463A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822463A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822463A4);
		  /* 822463A4h */ case    0:  		/* mr R4, R22 */
		/* 822463A4h case    0:*/		regs.R4 = regs.R22;
		/* 822463A4h case    0:*/		return 0x822463A8;
		  /* 822463A8h */ case    1:  		/* mr R3, R23 */
		/* 822463A8h case    1:*/		regs.R3 = regs.R23;
		/* 822463A8h case    1:*/		return 0x822463AC;
		  /* 822463ACh */ case    2:  		/* bl 55060 */
		/* 822463ACh case    2:*/		regs.LR = 0x822463B0; return 0x82253AC0;
		/* 822463ACh case    2:*/		return 0x822463B0;
	}
	return 0x822463B0;
} // Block from 822463A4h-822463B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822463B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822463B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822463B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822463B0);
		  /* 822463B0h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 822463B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822463B0h case    0:*/		return 0x822463B4;
		  /* 822463B4h */ case    1:  		/* mr R3, R18 */
		/* 822463B4h case    1:*/		regs.R3 = regs.R18;
		/* 822463B4h case    1:*/		return 0x822463B8;
		  /* 822463B8h */ case    2:  		/* ldx R4, <#[R28 + R11]> */
		/* 822463B8h case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 822463B8h case    2:*/		return 0x822463BC;
		  /* 822463BCh */ case    3:  		/* bl -2092 */
		/* 822463BCh case    3:*/		regs.LR = 0x822463C0; return 0x82245B90;
		/* 822463BCh case    3:*/		return 0x822463C0;
		  /* 822463C0h */ case    4:  		/* lwz R11, <#[R1 + 88]> */
		/* 822463C0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 822463C0h case    4:*/		return 0x822463C4;
		  /* 822463C4h */ case    5:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 822463C4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 822463C4h case    5:*/		return 0x822463C8;
		  /* 822463C8h */ case    6:  		/* li R21, 0 */
		/* 822463C8h case    6:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 822463C8h case    6:*/		return 0x822463CC;
		  /* 822463CCh */ case    7:  		/* li R24, 0 */
		/* 822463CCh case    7:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 822463CCh case    7:*/		return 0x822463D0;
	}
	return 0x822463D0;
} // Block from 822463B0h-822463D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822463D0h
// Function '?FindOrCreate@VRegTable@XGRAPHICS@@QAAPAVVRegInfo@2@W4RegType@R400Tables@@HH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822463D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822463D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822463D0);
		  /* 822463D0h */ case    0:  		/* li R25, 0 */
		/* 822463D0h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 822463D0h case    0:*/		return 0x822463D4;
		  /* 822463D4h */ case    1:  		/* cmpwi CR6, R20, 0 */
		/* 822463D4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 822463D4h case    1:*/		return 0x822463D8;
		  /* 822463D8h */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 822463D8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822463D8h case    2:*/		return 0x822463DC;
		  /* 822463DCh */ case    3:  		/* bc 4, CR6_GT, 244 */
		/* 822463DCh case    3:*/		if ( !regs.CR[6].gt ) { return 0x822464D0;  }
		/* 822463DCh case    3:*/		return 0x822463E0;
		  /* 822463E0h */ case    4:  		/* lwz R9, <#[R1 + 108]> */
		/* 822463E0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000006C) );
		/* 822463E0h case    4:*/		return 0x822463E4;
		  /* 822463E4h */ case    5:  		/* neg R10, R11 */
		/* 822463E4h case    5:*/		cpu::op::neg<0>(regs,&regs.R10,regs.R11);
		/* 822463E4h case    5:*/		return 0x822463E8;
		  /* 822463E8h */ case    6:  		/* lwz R6, <#[R1 + 104]> */
		/* 822463E8h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000068) );
		/* 822463E8h case    6:*/		return 0x822463EC;
		  /* 822463ECh */ case    7:  		/* mtspr CTR, R20 */
		/* 822463ECh case    7:*/		regs.CTR = regs.R20;
		/* 822463ECh case    7:*/		return 0x822463F0;
		  /* 822463F0h */ case    8:  		/* lwz R5, <#[R1 + 96]> */
		/* 822463F0h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000060) );
		/* 822463F0h case    8:*/		return 0x822463F4;
		  /* 822463F4h */ case    9:  		/* subf R8, R11, R30 */
		/* 822463F4h case    9:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R30);
		/* 822463F4h case    9:*/		return 0x822463F8;
		  /* 822463F8h */ case   10:  		/* subf R7, R11, R29 */
		/* 822463F8h case   10:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R11,regs.R29);
		/* 822463F8h case   10:*/		return 0x822463FC;
		  /* 822463FCh */ case   11:  		/* add R9, R10, R9 */
		/* 822463FCh case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 822463FCh case   11:*/		return 0x82246400;
		  /* 82246400h */ case   12:  		/* add R6, R10, R6 */
		/* 82246400h case   12:*/		cpu::op::add<0>(regs,&regs.R6,regs.R10,regs.R6);
		/* 82246400h case   12:*/		return 0x82246404;
		  /* 82246404h */ case   13:  		/* add R5, R10, R5 */
		/* 82246404h case   13:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R5);
		/* 82246404h case   13:*/		return 0x82246408;
		  /* 82246408h */ case   14:  		/* lwzx R4, <#[R7 + R11]> */
		/* 82246408h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82246408h case   14:*/		return 0x8224640C;
		  /* 8224640Ch */ case   15:  		/* lwzx R3, <#[R9 + R11]> */
		/* 8224640Ch case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8224640Ch case   15:*/		return 0x82246410;
		  /* 82246410h */ case   16:  		/* lwzx R10, <#[R8 + R11]> */
		/* 82246410h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82246410h case   16:*/		return 0x82246414;
		  /* 82246414h */ case   17:  		/* and. R3, R4, R3 */
		/* 82246414h case   17:*/		cpu::op::and<1>(regs,&regs.R3,regs.R4,regs.R3);
		/* 82246414h case   17:*/		return 0x82246418;
		  /* 82246418h */ case   18:  		/* lwz R4, <#[R11]> */
		/* 82246418h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 82246418h case   18:*/		return 0x8224641C;
		  /* 8224641Ch */ case   19:  		/* stwx R3, <#[R9 + R11]> */
		/* 8224641Ch case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8224641Ch case   19:*/		return 0x82246420;
		  /* 82246420h */ case   20:  		/* bc 12, CR0_EQ, 8 */
		/* 82246420h case   20:*/		if ( regs.CR[0].eq ) { return 0x82246428;  }
		/* 82246420h case   20:*/		return 0x82246424;
		  /* 82246424h */ case   21:  		/* li R25, 1 */
		/* 82246424h case   21:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 82246424h case   21:*/		return 0x82246428;
	}
	return 0x82246428;
} // Block from 822463D0h-82246428h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82246428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246428);
		  /* 82246428h */ case    0:  		/* cmpwi CR6, R31, 3 */
		/* 82246428h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000003);
		/* 82246428h case    0:*/		return 0x8224642C;
		  /* 8224642Ch */ case    1:  		/* bc 4, CR6_LT, 24 */
		/* 8224642Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x82246444;  }
		/* 8224642Ch case    1:*/		return 0x82246430;
	}
	return 0x82246430;
} // Block from 82246428h-82246430h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82246430h
// Function '?FindOrCreateVReg@VRegTable@XGRAPHICS@@AAAPAVVRegInfo@2@HUkonst@2@000@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246430);
		  /* 82246430h */ case    0:  		/* lwzx R3, <#[R6 + R11]> */
		/* 82246430h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82246430h case    0:*/		return 0x82246434;
		  /* 82246434h */ case    1:  		/* and. R10, R3, R10 */
		/* 82246434h case    1:*/		cpu::op::and<1>(regs,&regs.R10,regs.R3,regs.R10);
		/* 82246434h case    1:*/		return 0x82246438;
		  /* 82246438h */ case    2:  		/* stwx R10, <#[R6 + R11]> */
		/* 82246438h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82246438h case    2:*/		return 0x8224643C;
		  /* 8224643Ch */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 8224643Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82246444;  }
		/* 8224643Ch case    3:*/		return 0x82246440;
		  /* 82246440h */ case    4:  		/* li R24, 1 */
		/* 82246440h case    4:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 82246440h case    4:*/		return 0x82246444;
	}
	return 0x82246444;
} // Block from 82246430h-82246444h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82246444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246444);
		  /* 82246444h */ case    0:  		/* cmpwi CR6, R31, 2 */
		/* 82246444h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000002);
		/* 82246444h case    0:*/		return 0x82246448;
		  /* 82246448h */ case    1:  		/* bc 4, CR6_LT, 24 */
		/* 82246448h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82246460;  }
		/* 82246448h case    1:*/		return 0x8224644C;
		  /* 8224644Ch */ case    2:  		/* lwzx R10, <#[R5 + R11]> */
		/* 8224644Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 8224644Ch case    2:*/		return 0x82246450;
		  /* 82246450h */ case    3:  		/* and. R10, R10, R4 */
		/* 82246450h case    3:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R4);
		/* 82246450h case    3:*/		return 0x82246454;
		  /* 82246454h */ case    4:  		/* stwx R10, <#[R5 + R11]> */
		/* 82246454h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82246454h case    4:*/		return 0x82246458;
		  /* 82246458h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 82246458h case    5:*/		if ( regs.CR[0].eq ) { return 0x82246460;  }
		/* 82246458h case    5:*/		return 0x8224645C;
		  /* 8224645Ch */ case    6:  		/* li R21, 1 */
		/* 8224645Ch case    6:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 8224645Ch case    6:*/		return 0x82246460;
	}
	return 0x82246460;
} // Block from 82246444h-82246460h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82246460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246460);
		  /* 82246460h */ case    0:  		/* addi R11, R11, 4 */
		/* 82246460h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82246460h case    0:*/		return 0x82246464;
		  /* 82246464h */ case    1:  		/* bc 16, CR0_LT, -92 */
		/* 82246464h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82246408;  }
		/* 82246464h case    1:*/		return 0x82246468;
		  /* 82246468h */ case    2:  		/* cmpwi CR6, R25, 0 */
		/* 82246468h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82246468h case    2:*/		return 0x8224646C;
		  /* 8224646Ch */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 8224646Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82246480;  }
		/* 8224646Ch case    3:*/		return 0x82246470;
		  /* 82246470h */ case    4:  		/* cmpwi CR6, R24, 0 */
		/* 82246470h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82246470h case    4:*/		return 0x82246474;
		  /* 82246474h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82246474h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82246480;  }
		/* 82246474h case    5:*/		return 0x82246478;
		  /* 82246478h */ case    6:  		/* cmpwi CR6, R21, 0 */
		/* 82246478h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 82246478h case    6:*/		return 0x8224647C;
		  /* 8224647Ch */ case    7:  		/* bc 12, CR6_EQ, 84 */
		/* 8224647Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x822464D0;  }
		/* 8224647Ch case    7:*/		return 0x82246480;
	}
	return 0x82246480;
} // Block from 82246460h-82246480h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82246480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246480);
		  /* 82246480h */ case    0:  		/* addi R27, R27, 1 */
		/* 82246480h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82246480h case    0:*/		return 0x82246484;
		  /* 82246484h */ case    1:  		/* addi R28, R28, 8 */
		/* 82246484h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 82246484h case    1:*/		return 0x82246488;
		  /* 82246488h */ case    2:  		/* cmpw CR6, R27, R31 */
		/* 82246488h case    2:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R31);
		/* 82246488h case    2:*/		return 0x8224648C;
		  /* 8224648Ch */ case    3:  		/* bc 12, CR6_LT, -384 */
		/* 8224648Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8224630C;  }
		/* 8224648Ch case    3:*/		return 0x82246490;
		  /* 82246490h */ case    4:  		/* lwz R3, <#[R1 + 96]> */
		/* 82246490h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 82246490h case    4:*/		return 0x82246494;
	}
	return 0x82246494;
} // Block from 82246480h-82246494h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82246494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246494);
		  /* 82246494h */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 82246494h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82246494h case    0:*/		return 0x82246498;
		  /* 82246498h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82246498h case    1:*/		if ( regs.CR[6].eq ) { return 0x822464A4;  }
		/* 82246498h case    1:*/		return 0x8224649C;
		  /* 8224649Ch */ case    2:  		/* lwz R3, <#[R1 + 108]> */
		/* 8224649Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000006C) );
		/* 8224649Ch case    2:*/		return 0x822464A0;
		  /* 822464A0h */ case    3:  		/* b 28 */
		/* 822464A0h case    3:*/		return 0x822464BC;
		/* 822464A0h case    3:*/		return 0x822464A4;
	}
	return 0x822464A4;
} // Block from 82246494h-822464A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822464A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822464A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822464A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822464A4);
		  /* 822464A4h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 822464A4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 822464A4h case    0:*/		return 0x822464A8;
		  /* 822464A8h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 822464A8h case    1:*/		if ( regs.CR[6].eq ) { return 0x822464B4;  }
		/* 822464A8h case    1:*/		return 0x822464AC;
		  /* 822464ACh */ case    2:  		/* lwz R3, <#[R1 + 104]> */
		/* 822464ACh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000068) );
		/* 822464ACh case    2:*/		return 0x822464B0;
		  /* 822464B0h */ case    3:  		/* b 12 */
		/* 822464B0h case    3:*/		return 0x822464BC;
		/* 822464B0h case    3:*/		return 0x822464B4;
	}
	return 0x822464B4;
} // Block from 822464A4h-822464B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822464B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822464B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822464B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822464B4);
		  /* 822464B4h */ case    0:  		/* cmpwi CR6, R21, 0 */
		/* 822464B4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 822464B4h case    0:*/		return 0x822464B8;
		  /* 822464B8h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 822464B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x822464D0;  }
		/* 822464B8h case    1:*/		return 0x822464BC;
	}
	return 0x822464BC;
} // Block from 822464B4h-822464BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822464BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822464BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822464BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822464BC);
		  /* 822464BCh */ case    0:  		/* mr R4, R20 */
		/* 822464BCh case    0:*/		regs.R4 = regs.R20;
		/* 822464BCh case    0:*/		return 0x822464C0;
		  /* 822464C0h */ case    1:  		/* bl -6120 */
		/* 822464C0h case    1:*/		regs.LR = 0x822464C4; return 0x82244CD8;
		/* 822464C0h case    1:*/		return 0x822464C4;
		  /* 822464C4h */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 822464C4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 822464C4h case    2:*/		return 0x822464C8;
		  /* 822464C8h */ case    3:  		/* stwx R3, <#[R26 + R11]> */
		/* 822464C8h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 822464C8h case    3:*/		return 0x822464CC;
		  /* 822464CCh */ case    4:  		/* b 1960 */
		/* 822464CCh case    4:*/		return 0x82246C74;
		/* 822464CCh case    4:*/		return 0x822464D0;
	}
	return 0x822464D0;
} // Block from 822464BCh-822464D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822464D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822464D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822464D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822464D0);
		  /* 822464D0h */ case    0:  		/* cmpwi CR6, R31, 3 */
		/* 822464D0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000003);
		/* 822464D0h case    0:*/		return 0x822464D4;
		  /* 822464D4h */ case    1:  		/* bc 4, CR6_EQ, 740 */
		/* 822464D4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822467B8;  }
		/* 822464D4h case    1:*/		return 0x822464D8;
		  /* 822464D8h */ case    2:  		/* lwz R11, <#[R23 + 4]> */
		/* 822464D8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 822464D8h case    2:*/		return 0x822464DC;
		  /* 822464DCh */ case    3:  		/* cmplw CR6, R22, R11 */
		/* 822464DCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 822464DCh case    3:*/		return 0x822464E0;
		  /* 822464E0h */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 822464E0h case    4:*/		if ( !regs.CR[6].lt ) { return 0x822464F0;  }
		/* 822464E0h case    4:*/		return 0x822464E4;
		  /* 822464E4h */ case    5:  		/* lwz R11, <#[R23 + 8]> */
		/* 822464E4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 822464E4h case    5:*/		return 0x822464E8;
		  /* 822464E8h */ case    6:  		/* add R3, R11, R26 */
		/* 822464E8h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 822464E8h case    6:*/		return 0x822464EC;
		  /* 822464ECh */ case    7:  		/* b 16 */
		/* 822464ECh case    7:*/		return 0x822464FC;
		/* 822464ECh case    7:*/		return 0x822464F0;
	}
	return 0x822464F0;
} // Block from 822464D0h-822464F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822464F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822464F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822464F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822464F0);
		  /* 822464F0h */ case    0:  		/* mr R4, R22 */
		/* 822464F0h case    0:*/		regs.R4 = regs.R22;
		/* 822464F0h case    0:*/		return 0x822464F4;
		  /* 822464F4h */ case    1:  		/* mr R3, R23 */
		/* 822464F4h case    1:*/		regs.R3 = regs.R23;
		/* 822464F4h case    1:*/		return 0x822464F8;
		  /* 822464F8h */ case    2:  		/* bl 54728 */
		/* 822464F8h case    2:*/		regs.LR = 0x822464FC; return 0x82253AC0;
		/* 822464F8h case    2:*/		return 0x822464FC;
	}
	return 0x822464FC;
} // Block from 822464F0h-822464FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822464FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822464FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822464FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822464FC);
		  /* 822464FCh */ case    0:  		/* lwz R11, <#[R3]> */
		/* 822464FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822464FCh case    0:*/		return 0x82246500;
		  /* 82246500h */ case    1:  		/* mr R3, R18 */
		/* 82246500h case    1:*/		regs.R3 = regs.R18;
		/* 82246500h case    1:*/		return 0x82246504;
		  /* 82246504h */ case    2:  		/* ld R4, <#[R11 + 896]> */
		/* 82246504h case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + 0x00000380) );
		/* 82246504h case    2:*/		return 0x82246508;
		  /* 82246508h */ case    3:  		/* bl -2424 */
		/* 82246508h case    3:*/		regs.LR = 0x8224650C; return 0x82245B90;
		/* 82246508h case    3:*/		return 0x8224650C;
		  /* 8224650Ch */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 8224650Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8224650Ch case    4:*/		return 0x82246510;
		  /* 82246510h */ case    5:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82246510h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82246510h case    5:*/		return 0x82246514;
		  /* 82246514h */ case    6:  		/* lwz R9, <#[R23 + 4]> */
		/* 82246514h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000004) );
		/* 82246514h case    6:*/		return 0x82246518;
		  /* 82246518h */ case    7:  		/* cmplw CR6, R22, R9 */
		/* 82246518h case    7:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R9);
		/* 82246518h case    7:*/		return 0x8224651C;
		  /* 8224651Ch */ case    8:  		/* lwzx R28, <#[R10 + R11]> */
		/* 8224651Ch case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224651Ch case    8:*/		return 0x82246520;
		  /* 82246520h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 82246520h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82246530;  }
		/* 82246520h case    9:*/		return 0x82246524;
		  /* 82246524h */ case   10:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246524h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246524h case   10:*/		return 0x82246528;
		  /* 82246528h */ case   11:  		/* add R3, R11, R26 */
		/* 82246528h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82246528h case   11:*/		return 0x8224652C;
		  /* 8224652Ch */ case   12:  		/* b 16 */
		/* 8224652Ch case   12:*/		return 0x8224653C;
		/* 8224652Ch case   12:*/		return 0x82246530;
	}
	return 0x82246530;
} // Block from 822464FCh-82246530h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82246530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246530);
		  /* 82246530h */ case    0:  		/* mr R4, R22 */
		/* 82246530h case    0:*/		regs.R4 = regs.R22;
		/* 82246530h case    0:*/		return 0x82246534;
		  /* 82246534h */ case    1:  		/* mr R3, R23 */
		/* 82246534h case    1:*/		regs.R3 = regs.R23;
		/* 82246534h case    1:*/		return 0x82246538;
		  /* 82246538h */ case    2:  		/* bl 54664 */
		/* 82246538h case    2:*/		regs.LR = 0x8224653C; return 0x82253AC0;
		/* 82246538h case    2:*/		return 0x8224653C;
	}
	return 0x8224653C;
} // Block from 82246530h-8224653Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224653Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224653C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224653C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224653C);
		  /* 8224653Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224653Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224653Ch case    0:*/		return 0x82246540;
		  /* 82246540h */ case    1:  		/* mr R3, R18 */
		/* 82246540h case    1:*/		regs.R3 = regs.R18;
		/* 82246540h case    1:*/		return 0x82246544;
		  /* 82246544h */ case    2:  		/* ld R4, <#[R11 + 904]> */
		/* 82246544h case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + 0x00000388) );
		/* 82246544h case    2:*/		return 0x82246548;
		  /* 82246548h */ case    3:  		/* bl -2488 */
		/* 82246548h case    3:*/		regs.LR = 0x8224654C; return 0x82245B90;
		/* 82246548h case    3:*/		return 0x8224654C;
		  /* 8224654Ch */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 8224654Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8224654Ch case    4:*/		return 0x82246550;
		  /* 82246550h */ case    5:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82246550h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82246550h case    5:*/		return 0x82246554;
		  /* 82246554h */ case    6:  		/* lwz R9, <#[R23 + 4]> */
		/* 82246554h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000004) );
		/* 82246554h case    6:*/		return 0x82246558;
		  /* 82246558h */ case    7:  		/* cmplw CR6, R22, R9 */
		/* 82246558h case    7:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R9);
		/* 82246558h case    7:*/		return 0x8224655C;
		  /* 8224655Ch */ case    8:  		/* lwzx R30, <#[R10 + R11]> */
		/* 8224655Ch case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224655Ch case    8:*/		return 0x82246560;
		  /* 82246560h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 82246560h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82246570;  }
		/* 82246560h case    9:*/		return 0x82246564;
		  /* 82246564h */ case   10:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246564h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246564h case   10:*/		return 0x82246568;
		  /* 82246568h */ case   11:  		/* add R3, R11, R26 */
		/* 82246568h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82246568h case   11:*/		return 0x8224656C;
		  /* 8224656Ch */ case   12:  		/* b 16 */
		/* 8224656Ch case   12:*/		return 0x8224657C;
		/* 8224656Ch case   12:*/		return 0x82246570;
	}
	return 0x82246570;
} // Block from 8224653Ch-82246570h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82246570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246570);
		  /* 82246570h */ case    0:  		/* mr R4, R22 */
		/* 82246570h case    0:*/		regs.R4 = regs.R22;
		/* 82246570h case    0:*/		return 0x82246574;
		  /* 82246574h */ case    1:  		/* mr R3, R23 */
		/* 82246574h case    1:*/		regs.R3 = regs.R23;
		/* 82246574h case    1:*/		return 0x82246578;
		  /* 82246578h */ case    2:  		/* bl 54600 */
		/* 82246578h case    2:*/		regs.LR = 0x8224657C; return 0x82253AC0;
		/* 82246578h case    2:*/		return 0x8224657C;
	}
	return 0x8224657C;
} // Block from 82246570h-8224657Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224657Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224657C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224657C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224657C);
		  /* 8224657Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224657Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224657Ch case    0:*/		return 0x82246580;
		  /* 82246580h */ case    1:  		/* mr R3, R18 */
		/* 82246580h case    1:*/		regs.R3 = regs.R18;
		/* 82246580h case    1:*/		return 0x82246584;
		  /* 82246584h */ case    2:  		/* ld R4, <#[R11 + 912]> */
		/* 82246584h case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + 0x00000390) );
		/* 82246584h case    2:*/		return 0x82246588;
		  /* 82246588h */ case    3:  		/* bl -2552 */
		/* 82246588h case    3:*/		regs.LR = 0x8224658C; return 0x82245B90;
		/* 82246588h case    3:*/		return 0x8224658C;
		  /* 8224658Ch */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 8224658Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8224658Ch case    4:*/		return 0x82246590;
		  /* 82246590h */ case    5:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82246590h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82246590h case    5:*/		return 0x82246594;
		  /* 82246594h */ case    6:  		/* li R25, 0 */
		/* 82246594h case    6:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82246594h case    6:*/		return 0x82246598;
		  /* 82246598h */ case    7:  		/* li R24, 0 */
		/* 82246598h case    7:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82246598h case    7:*/		return 0x8224659C;
		  /* 8224659Ch */ case    8:  		/* li R21, 0 */
		/* 8224659Ch case    8:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8224659Ch case    8:*/		return 0x822465A0;
		  /* 822465A0h */ case    9:  		/* stw R25, <#[R1 + 112]> */
		/* 822465A0h case    9:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000070) );
		/* 822465A0h case    9:*/		return 0x822465A4;
		  /* 822465A4h */ case   10:  		/* stw R24, <#[R1 + 116]> */
		/* 822465A4h case   10:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000074) );
		/* 822465A4h case   10:*/		return 0x822465A8;
		  /* 822465A8h */ case   11:  		/* li R29, 0 */
		/* 822465A8h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 822465A8h case   11:*/		return 0x822465AC;
		  /* 822465ACh */ case   12:  		/* lwzx R10, <#[R10 + R11]> */
		/* 822465ACh case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822465ACh case   12:*/		return 0x822465B0;
		  /* 822465B0h */ case   13:  		/* li R6, 0 */
		/* 822465B0h case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822465B0h case   13:*/		return 0x822465B4;
		  /* 822465B4h */ case   14:  		/* stw R21, <#[R1 + 120]> */
		/* 822465B4h case   14:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000078) );
		/* 822465B4h case   14:*/		return 0x822465B8;
		  /* 822465B8h */ case   15:  		/* cmpwi CR6, R20, 0 */
		/* 822465B8h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 822465B8h case   15:*/		return 0x822465BC;
		  /* 822465BCh */ case   16:  		/* bc 4, CR6_GT, 112 */
		/* 822465BCh case   16:*/		if ( !regs.CR[6].gt ) { return 0x8224662C;  }
		/* 822465BCh case   16:*/		return 0x822465C0;
		  /* 822465C0h */ case   17:  		/* mr R11, R30 */
		/* 822465C0h case   17:*/		regs.R11 = regs.R30;
		/* 822465C0h case   17:*/		return 0x822465C4;
		  /* 822465C4h */ case   18:  		/* subf R9, R30, R28 */
		/* 822465C4h case   18:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R30,regs.R28);
		/* 822465C4h case   18:*/		return 0x822465C8;
		  /* 822465C8h */ case   19:  		/* subf R10, R30, R10 */
		/* 822465C8h case   19:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R30,regs.R10);
		/* 822465C8h case   19:*/		return 0x822465CC;
		  /* 822465CCh */ case   20:  		/* lwzx R8, <#[R9 + R11]> */
		/* 822465CCh case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 822465CCh case   20:*/		return 0x822465D0;
		  /* 822465D0h */ case   21:  		/* lwz R7, <#[R11]> */
		/* 822465D0h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 822465D0h case   21:*/		return 0x822465D4;
		  /* 822465D4h */ case   22:  		/* lwzx R5, <#[R10 + R11]> */
		/* 822465D4h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822465D4h case   22:*/		return 0x822465D8;
		  /* 822465D8h */ case   23:  		/* and. R25, R7, R8 */
		/* 822465D8h case   23:*/		cpu::op::and<1>(regs,&regs.R25,regs.R7,regs.R8);
		/* 822465D8h case   23:*/		return 0x822465DC;
		  /* 822465DCh */ case   24:  		/* and R24, R5, R8 */
		/* 822465DCh case   24:*/		cpu::op::and<0>(regs,&regs.R24,regs.R5,regs.R8);
		/* 822465DCh case   24:*/		return 0x822465E0;
		  /* 822465E0h */ case   25:  		/* stw R25, <#[R1 + 112]> */
		/* 822465E0h case   25:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000070) );
		/* 822465E0h case   25:*/		return 0x822465E4;
		  /* 822465E4h */ case   26:  		/* and R21, R5, R7 */
		/* 822465E4h case   26:*/		cpu::op::and<0>(regs,&regs.R21,regs.R5,regs.R7);
		/* 822465E4h case   26:*/		return 0x822465E8;
		  /* 822465E8h */ case   27:  		/* stw R24, <#[R1 + 116]> */
		/* 822465E8h case   27:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000074) );
		/* 822465E8h case   27:*/		return 0x822465EC;
		  /* 822465ECh */ case   28:  		/* stw R21, <#[R1 + 120]> */
		/* 822465ECh case   28:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000078) );
		/* 822465ECh case   28:*/		return 0x822465F0;
		  /* 822465F0h */ case   29:  		/* bc 4, CR0_EQ, 40 */
		/* 822465F0h case   29:*/		if ( !regs.CR[0].eq ) { return 0x82246618;  }
		/* 822465F0h case   29:*/		return 0x822465F4;
		  /* 822465F4h */ case   30:  		/* cmpwi CR6, R24, 0 */
		/* 822465F4h case   30:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 822465F4h case   30:*/		return 0x822465F8;
		  /* 822465F8h */ case   31:  		/* bc 4, CR6_EQ, 40 */
		/* 822465F8h case   31:*/		if ( !regs.CR[6].eq ) { return 0x82246620;  }
		/* 822465F8h case   31:*/		return 0x822465FC;
		  /* 822465FCh */ case   32:  		/* cmpwi CR6, R21, 0 */
		/* 822465FCh case   32:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 822465FCh case   32:*/		return 0x82246600;
		  /* 82246600h */ case   33:  		/* bc 4, CR6_EQ, 40 */
		/* 82246600h case   33:*/		if ( !regs.CR[6].eq ) { return 0x82246628;  }
		/* 82246600h case   33:*/		return 0x82246604;
		  /* 82246604h */ case   34:  		/* addi R6, R6, 1 */
		/* 82246604h case   34:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82246604h case   34:*/		return 0x82246608;
		  /* 82246608h */ case   35:  		/* addi R11, R11, 4 */
		/* 82246608h case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82246608h case   35:*/		return 0x8224660C;
		  /* 8224660Ch */ case   36:  		/* cmpw CR6, R6, R20 */
		/* 8224660Ch case   36:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R20);
		/* 8224660Ch case   36:*/		return 0x82246610;
		  /* 82246610h */ case   37:  		/* bc 12, CR6_LT, -68 */
		/* 82246610h case   37:*/		if ( regs.CR[6].lt ) { return 0x822465CC;  }
		/* 82246610h case   37:*/		return 0x82246614;
		  /* 82246614h */ case   38:  		/* b 24 */
		/* 82246614h case   38:*/		return 0x8224662C;
		/* 82246614h case   38:*/		return 0x82246618;
	}
	return 0x82246618;
} // Block from 8224657Ch-82246618h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82246618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246618);
		  /* 82246618h */ case    0:  		/* li R29, 0 */
		/* 82246618h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82246618h case    0:*/		return 0x8224661C;
		  /* 8224661Ch */ case    1:  		/* b 16 */
		/* 8224661Ch case    1:*/		return 0x8224662C;
		/* 8224661Ch case    1:*/		return 0x82246620;
	}
	return 0x82246620;
} // Block from 82246618h-82246620h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82246620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246620);
		  /* 82246620h */ case    0:  		/* li R29, 1 */
		/* 82246620h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82246620h case    0:*/		return 0x82246624;
		  /* 82246624h */ case    1:  		/* b 8 */
		/* 82246624h case    1:*/		return 0x8224662C;
		/* 82246624h case    1:*/		return 0x82246628;
	}
	return 0x82246628;
} // Block from 82246620h-82246628h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82246628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246628);
		  /* 82246628h */ case    0:  		/* li R29, 2 */
		/* 82246628h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x2);
		/* 82246628h case    0:*/		return 0x8224662C;
	}
	return 0x8224662C;
} // Block from 82246628h-8224662Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224662Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224662C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224662C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224662C);
		  /* 8224662Ch */ case    0:  		/* cmpw CR6, R6, R20 */
		/* 8224662Ch case    0:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R20);
		/* 8224662Ch case    0:*/		return 0x82246630;
		  /* 82246630h */ case    1:  		/* bc 12, CR6_EQ, 1468 */
		/* 82246630h case    1:*/		if ( regs.CR[6].eq ) { return 0x82246BEC;  }
		/* 82246630h case    1:*/		return 0x82246634;
		  /* 82246634h */ case    2:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 82246634h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 82246634h case    2:*/		return 0x82246638;
		  /* 82246638h */ case    3:  		/* addi R11, R1, 112 */
		/* 82246638h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 82246638h case    3:*/		return 0x8224663C;
		  /* 8224663Ch */ case    4:  		/* li R4, 1 */
		/* 8224663Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224663Ch case    4:*/		return 0x82246640;
		  /* 82246640h */ case    5:  		/* add R3, R10, R11 */
		/* 82246640h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82246640h case    5:*/		return 0x82246644;
		  /* 82246644h */ case    6:  		/* bl -6508 */
		/* 82246644h case    6:*/		regs.LR = 0x82246648; return 0x82244CD8;
		/* 82246644h case    6:*/		return 0x82246648;
		  /* 82246648h */ case    7:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246648h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246648h case    7:*/		return 0x8224664C;
		  /* 8224664Ch */ case    8:  		/* rlwinm R10, R6, 5, 0, 26 */
		/* 8224664Ch case    8:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R6);
		/* 8224664Ch case    8:*/		return 0x82246650;
		  /* 82246650h */ case    9:  		/* cmplw CR6, R22, R11 */
		/* 82246650h case    9:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82246650h case    9:*/		return 0x82246654;
		  /* 82246654h */ case   10:  		/* add R31, R3, R10 */
		/* 82246654h case   10:*/		cpu::op::add<0>(regs,&regs.R31,regs.R3,regs.R10);
		/* 82246654h case   10:*/		return 0x82246658;
		  /* 82246658h */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 82246658h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82246668;  }
		/* 82246658h case   11:*/		return 0x8224665C;
		  /* 8224665Ch */ case   12:  		/* lwz R11, <#[R23 + 8]> */
		/* 8224665Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8224665Ch case   12:*/		return 0x82246660;
		  /* 82246660h */ case   13:  		/* add R30, R11, R26 */
		/* 82246660h case   13:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R26);
		/* 82246660h case   13:*/		return 0x82246664;
		  /* 82246664h */ case   14:  		/* b 20 */
		/* 82246664h case   14:*/		return 0x82246678;
		/* 82246664h case   14:*/		return 0x82246668;
	}
	return 0x82246668;
} // Block from 8224662Ch-82246668h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82246668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246668);
		  /* 82246668h */ case    0:  		/* mr R4, R22 */
		/* 82246668h case    0:*/		regs.R4 = regs.R22;
		/* 82246668h case    0:*/		return 0x8224666C;
		  /* 8224666Ch */ case    1:  		/* mr R3, R23 */
		/* 8224666Ch case    1:*/		regs.R3 = regs.R23;
		/* 8224666Ch case    1:*/		return 0x82246670;
		  /* 82246670h */ case    2:  		/* bl 54352 */
		/* 82246670h case    2:*/		regs.LR = 0x82246674; return 0x82253AC0;
		/* 82246670h case    2:*/		return 0x82246674;
		  /* 82246674h */ case    3:  		/* mr R30, R3 */
		/* 82246674h case    3:*/		regs.R30 = regs.R3;
		/* 82246674h case    3:*/		return 0x82246678;
	}
	return 0x82246678;
} // Block from 82246668h-82246678h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82246678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246678);
		  /* 82246678h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246678h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246678h case    0:*/		return 0x8224667C;
		  /* 8224667Ch */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 8224667Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8224667Ch case    1:*/		return 0x82246680;
	}
	return 0x82246680;
} // Block from 82246678h-82246680h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82246680h
// Function '?FindOrCreateInst@VRegTable@XGRAPHICS@@AAAPAVIRInst@2@Ukonst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246680);
		  /* 82246680h */ case    0:  		/* bc 4, CR6_LT, 20 */
		/* 82246680h case    0:*/		if ( !regs.CR[6].lt ) { return 0x82246694;  }
		/* 82246680h case    0:*/		return 0x82246684;
		  /* 82246684h */ case    1:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246684h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246684h case    1:*/		return 0x82246688;
		  /* 82246688h */ case    2:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82246688h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82246688h case    2:*/		return 0x8224668C;
		  /* 8224668Ch */ case    3:  		/* add R3, R10, R11 */
		/* 8224668Ch case    3:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8224668Ch case    3:*/		return 0x82246690;
		  /* 82246690h */ case    4:  		/* b 16 */
		/* 82246690h case    4:*/		return 0x822466A0;
		/* 82246690h case    4:*/		return 0x82246694;
	}
	return 0x82246694;
} // Block from 82246680h-82246694h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82246694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246694);
		  /* 82246694h */ case    0:  		/* mr R4, R31 */
		/* 82246694h case    0:*/		regs.R4 = regs.R31;
		/* 82246694h case    0:*/		return 0x82246698;
		  /* 82246698h */ case    1:  		/* mr R3, R23 */
		/* 82246698h case    1:*/		regs.R3 = regs.R23;
		/* 82246698h case    1:*/		return 0x8224669C;
		  /* 8224669Ch */ case    2:  		/* bl 54308 */
		/* 8224669Ch case    2:*/		regs.LR = 0x822466A0; return 0x82253AC0;
		/* 8224669Ch case    2:*/		return 0x822466A0;
	}
	return 0x822466A0;
} // Block from 82246694h-822466A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822466A0h
// Function '?FindOrCreateInst@VRegTable@XGRAPHICS@@AAAPAVIRInst@2@Ukonst@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822466A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822466A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822466A0);
		  /* 822466A0h */ case    0:  		/* subfic R9, R29, 114 */
		/* 822466A0h case    0:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R29,0x72);
		/* 822466A0h case    0:*/		return 0x822466A4;
		  /* 822466A4h */ case    1:  		/* lwz R11, <#[R30]> */
		/* 822466A4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822466A4h case    1:*/		return 0x822466A8;
		  /* 822466A8h */ case    2:  		/* lwz R10, <#[R3]> */
		/* 822466A8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 822466A8h case    2:*/		return 0x822466AC;
		  /* 822466ACh */ case    3:  		/* rlwinm R9, R9, 3, 0, 28 */
		/* 822466ACh case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R9);
		/* 822466ACh case    3:*/		return 0x822466B0;
		  /* 822466B0h */ case    4:  		/* add R11, R9, R11 */
		/* 822466B0h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 822466B0h case    4:*/		return 0x822466B4;
		  /* 822466B4h */ case    5:  		/* lwz R9, <#[R11]> */
		/* 822466B4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822466B4h case    5:*/		return 0x822466B8;
		  /* 822466B8h */ case    6:  		/* stw R9, <#[R10 + 920]> */
		/* 822466B8h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000398) );
		/* 822466B8h case    6:*/		return 0x822466BC;
		  /* 822466BCh */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 822466BCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822466BCh case    7:*/		return 0x822466C0;
	}
	return 0x822466C0;
} // Block from 822466A0h-822466C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822466C0h
// Function '?FindOrCreateInst@VRegTable@XGRAPHICS@@AAAPAVIRInst@2@Ukonst@2@00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822466C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822466C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822466C0);
		  /* 822466C0h */ case    0:  		/* stw R11, <#[R10 + 924]> */
		/* 822466C0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000039C) );
		/* 822466C0h case    0:*/		return 0x822466C4;
		  /* 822466C4h */ case    1:  		/* lwz R11, <#[R23 + 4]> */
		/* 822466C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 822466C4h case    1:*/		return 0x822466C8;
		  /* 822466C8h */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 822466C8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 822466C8h case    2:*/		return 0x822466CC;
		  /* 822466CCh */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 822466CCh case    3:*/		if ( !regs.CR[6].lt ) { return 0x822466E0;  }
		/* 822466CCh case    3:*/		return 0x822466D0;
		  /* 822466D0h */ case    4:  		/* lwz R11, <#[R23 + 8]> */
		/* 822466D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 822466D0h case    4:*/		return 0x822466D4;
		  /* 822466D4h */ case    5:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 822466D4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 822466D4h case    5:*/		return 0x822466D8;
		  /* 822466D8h */ case    6:  		/* add R3, R10, R11 */
		/* 822466D8h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 822466D8h case    6:*/		return 0x822466DC;
		  /* 822466DCh */ case    7:  		/* b 16 */
		/* 822466DCh case    7:*/		return 0x822466EC;
		/* 822466DCh case    7:*/		return 0x822466E0;
	}
	return 0x822466E0;
} // Block from 822466C0h-822466E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822466E0h
// Function '?FindOrCreateInst@VRegTable@XGRAPHICS@@AAAPAVIRInst@2@Ukonst@2@000@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822466E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822466E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822466E0);
		  /* 822466E0h */ case    0:  		/* mr R4, R31 */
		/* 822466E0h case    0:*/		regs.R4 = regs.R31;
		/* 822466E0h case    0:*/		return 0x822466E4;
		  /* 822466E4h */ case    1:  		/* mr R3, R23 */
		/* 822466E4h case    1:*/		regs.R3 = regs.R23;
		/* 822466E4h case    1:*/		return 0x822466E8;
		  /* 822466E8h */ case    2:  		/* bl 54232 */
		/* 822466E8h case    2:*/		regs.LR = 0x822466EC; return 0x82253AC0;
		/* 822466E8h case    2:*/		return 0x822466EC;
	}
	return 0x822466EC;
} // Block from 822466E0h-822466ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822466ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822466EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822466EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822466EC);
		  /* 822466ECh */ case    0:  		/* lwz R8, <#[R3]> */
		/* 822466ECh case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 822466ECh case    0:*/		return 0x822466F0;
		  /* 822466F0h */ case    1:  		/* li R10, 1 */
		/* 822466F0h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 822466F0h case    1:*/		return 0x822466F4;
		  /* 822466F4h */ case    2:  		/* srawi R7, R31, 5 */
		/* 822466F4h case    2:*/		cpu::op::srawi<0,5>(regs,&regs.R7,regs.R31);
		/* 822466F4h case    2:*/		return 0x822466F8;
	}
	return 0x822466F8;
} // Block from 822466ECh-822466F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822466F8h
// Function '?get_index@XGRAPHICS@@YAHPAV?$Vector@PAUkonst@XGRAPHICS@@@1@Ukonst@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822466F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822466F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822466F8);
		  /* 822466F8h */ case    0:  		/* lwz R9, <#[R1 + 92]> */
		/* 822466F8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 822466F8h case    0:*/		return 0x822466FC;
		  /* 822466FCh */ case    1:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 822466FCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 822466FCh case    1:*/		return 0x82246700;
		  /* 82246700h */ case    2:  		/* lwz R6, <#[R1 + 84]> */
		/* 82246700h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 82246700h case    2:*/		return 0x82246704;
		  /* 82246704h */ case    3:  		/* addze R7, R7 */
		/* 82246704h case    3:*/		cpu::op::addze<0>(regs,&regs.R7,regs.R7);
		/* 82246704h case    3:*/		return 0x82246708;
		  /* 82246708h */ case    4:  		/* srawi R5, R31, 5 */
		/* 82246708h case    4:*/		cpu::op::srawi<0,5>(regs,&regs.R5,regs.R31);
		/* 82246708h case    4:*/		return 0x8224670C;
		  /* 8224670Ch */ case    5:  		/* stw R10, <#[R8 + 940]> */
		/* 8224670Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x000003AC) );
		/* 8224670Ch case    5:*/		return 0x82246710;
		  /* 82246710h */ case    6:  		/* rlwinm R8, R7, 5, 0, 26 */
		/* 82246710h case    6:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R8,regs.R7);
		/* 82246710h case    6:*/		return 0x82246714;
		  /* 82246714h */ case    7:  		/* addi R7, R27, 112 */
		/* 82246714h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R27,0x70);
		/* 82246714h case    7:*/		return 0x82246718;
		  /* 82246718h */ case    8:  		/* subf R8, R8, R31 */
		/* 82246718h case    8:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R31);
		/* 82246718h case    8:*/		return 0x8224671C;
		  /* 8224671Ch */ case    9:  		/* addze R5, R5 */
		/* 8224671Ch case    9:*/		cpu::op::addze<0>(regs,&regs.R5,regs.R5);
		/* 8224671Ch case    9:*/		return 0x82246720;
		  /* 82246720h */ case   10:  		/* slw R28, R10, R8 */
		/* 82246720h case   10:*/		cpu::op::slw<0>(regs,&regs.R28,regs.R10,regs.R8);
		/* 82246720h case   10:*/		return 0x82246724;
		  /* 82246724h */ case   11:  		/* lwzx R10, <#[R11 + R9]> */
		/* 82246724h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82246724h case   11:*/		return 0x82246728;
		  /* 82246728h */ case   12:  		/* li R30, 0 */
		/* 82246728h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82246728h case   12:*/		return 0x8224672C;
		  /* 8224672Ch */ case   13:  		/* rlwinm R27, R7, 3, 0, 28 */
		/* 8224672Ch case   13:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R27,regs.R7);
		/* 8224672Ch case   13:*/		return 0x82246730;
		  /* 82246730h */ case   14:  		/* addi R10, R10, -1 */
		/* 82246730h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82246730h case   14:*/		return 0x82246734;
		  /* 82246734h */ case   15:  		/* rlwinm R29, R5, 2, 0, 29 */
		/* 82246734h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R5);
		/* 82246734h case   15:*/		return 0x82246738;
		  /* 82246738h */ case   16:  		/* stwx R10, <#[R11 + R9]> */
		/* 82246738h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82246738h case   16:*/		return 0x8224673C;
		  /* 8224673Ch */ case   17:  		/* stwx R31, <#[R26 + R6]> */
		/* 8224673Ch case   17:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R26 + regs.R6 + 0x00000000) );
		/* 8224673Ch case   17:*/		return 0x82246740;
		  /* 82246740h */ case   18:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246740h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246740h case   18:*/		return 0x82246744;
		  /* 82246744h */ case   19:  		/* cmplw CR6, R22, R11 */
		/* 82246744h case   19:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82246744h case   19:*/		return 0x82246748;
		  /* 82246748h */ case   20:  		/* bc 4, CR6_LT, 16 */
		/* 82246748h case   20:*/		if ( !regs.CR[6].lt ) { return 0x82246758;  }
		/* 82246748h case   20:*/		return 0x8224674C;
		  /* 8224674Ch */ case   21:  		/* lwz R11, <#[R23 + 8]> */
		/* 8224674Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8224674Ch case   21:*/		return 0x82246750;
		  /* 82246750h */ case   22:  		/* add R3, R11, R26 */
		/* 82246750h case   22:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82246750h case   22:*/		return 0x82246754;
		  /* 82246754h */ case   23:  		/* b 16 */
		/* 82246754h case   23:*/		return 0x82246764;
		/* 82246754h case   23:*/		return 0x82246758;
	}
	return 0x82246758;
} // Block from 822466F8h-82246758h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82246758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246758);
		  /* 82246758h */ case    0:  		/* mr R4, R22 */
		/* 82246758h case    0:*/		regs.R4 = regs.R22;
		/* 82246758h case    0:*/		return 0x8224675C;
		  /* 8224675Ch */ case    1:  		/* mr R3, R23 */
		/* 8224675Ch case    1:*/		regs.R3 = regs.R23;
		/* 8224675Ch case    1:*/		return 0x82246760;
		  /* 82246760h */ case    2:  		/* bl 54112 */
		/* 82246760h case    2:*/		regs.LR = 0x82246764; return 0x82253AC0;
		/* 82246760h case    2:*/		return 0x82246764;
	}
	return 0x82246764;
} // Block from 82246758h-82246764h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246764);
		  /* 82246764h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246764h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246764h case    0:*/		return 0x82246768;
		  /* 82246768h */ case    1:  		/* mr R3, R18 */
		/* 82246768h case    1:*/		regs.R3 = regs.R18;
		/* 82246768h case    1:*/		return 0x8224676C;
		  /* 8224676Ch */ case    2:  		/* ldx R4, <#[R11 + R27]> */
		/* 8224676Ch case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8224676Ch case    2:*/		return 0x82246770;
		  /* 82246770h */ case    3:  		/* bl -3040 */
		/* 82246770h case    3:*/		regs.LR = 0x82246774; return 0x82245B90;
		/* 82246770h case    3:*/		return 0x82246774;
		  /* 82246774h */ case    4:  		/* lwz R10, <#[R1 + 100]> */
		/* 82246774h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 82246774h case    4:*/		return 0x82246778;
		  /* 82246778h */ case    5:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 82246778h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 82246778h case    5:*/		return 0x8224677C;
		  /* 8224677Ch */ case    6:  		/* cmpwi CR6, R30, 3 */
		/* 8224677Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000003);
		/* 8224677Ch case    6:*/		return 0x82246780;
		  /* 82246780h */ case    7:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82246780h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82246780h case    7:*/		return 0x82246784;
		  /* 82246784h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 82246784h case    8:*/		if ( regs.CR[6].eq ) { return 0x8224679C;  }
		/* 82246784h case    8:*/		return 0x82246788;
		  /* 82246788h */ case    9:  		/* lwz R9, <#[R1 + 80]> */
		/* 82246788h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82246788h case    9:*/		return 0x8224678C;
		  /* 8224678Ch */ case   10:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8224678Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8224678Ch case   10:*/		return 0x82246790;
		  /* 82246790h */ case   11:  		/* lwzx R9, <#[R29 + R11]> */
		/* 82246790h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82246790h case   11:*/		return 0x82246794;
		  /* 82246794h */ case   12:  		/* andc R9, R9, R28 */
		/* 82246794h case   12:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R9,regs.R28);
		/* 82246794h case   12:*/		return 0x82246798;
		  /* 82246798h */ case   13:  		/* stwx R9, <#[R29 + R11]> */
		/* 82246798h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82246798h case   13:*/		return 0x8224679C;
	}
	return 0x8224679C;
} // Block from 82246764h-8224679Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224679Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224679C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224679C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224679C);
		  /* 8224679Ch */ case    0:  		/* lwzx R11, <#[R29 + R10]> */
		/* 8224679Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 8224679Ch case    0:*/		return 0x822467A0;
		  /* 822467A0h */ case    1:  		/* addi R30, R30, 1 */
		/* 822467A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822467A0h case    1:*/		return 0x822467A4;
		  /* 822467A4h */ case    2:  		/* or R11, R28, R11 */
		/* 822467A4h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 822467A4h case    2:*/		return 0x822467A8;
		  /* 822467A8h */ case    3:  		/* cmpwi CR6, R30, 4 */
		/* 822467A8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 822467A8h case    3:*/		return 0x822467AC;
		  /* 822467ACh */ case    4:  		/* stwx R11, <#[R29 + R10]> */
		/* 822467ACh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 822467ACh case    4:*/		return 0x822467B0;
		  /* 822467B0h */ case    5:  		/* bc 12, CR6_LT, -112 */
		/* 822467B0h case    5:*/		if ( regs.CR[6].lt ) { return 0x82246740;  }
		/* 822467B0h case    5:*/		return 0x822467B4;
		  /* 822467B4h */ case    6:  		/* b 1216 */
		/* 822467B4h case    6:*/		return 0x82246C74;
		/* 822467B4h case    6:*/		return 0x822467B8;
	}
	return 0x822467B8;
} // Block from 8224679Ch-822467B8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822467B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822467B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822467B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822467B8);
		  /* 822467B8h */ case    0:  		/* cmpwi CR6, R31, 2 */
		/* 822467B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000002);
		/* 822467B8h case    0:*/		return 0x822467BC;
		  /* 822467BCh */ case    1:  		/* bc 4, CR6_EQ, 1072 */
		/* 822467BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82246BEC;  }
		/* 822467BCh case    1:*/		return 0x822467C0;
	}
	return 0x822467C0;
} // Block from 822467B8h-822467C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822467C0h
// Function '?AssignKonstantRegisters@VRegTable@XGRAPHICS@@QAAXPAVCFG@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822467C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822467C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822467C0);
		  /* 822467C0h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 822467C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 822467C0h case    0:*/		return 0x822467C4;
		  /* 822467C4h */ case    1:  		/* cmplw CR6, R22, R11 */
		/* 822467C4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 822467C4h case    1:*/		return 0x822467C8;
		  /* 822467C8h */ case    2:  		/* bc 4, CR6_LT, 16 */
		/* 822467C8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x822467D8;  }
		/* 822467C8h case    2:*/		return 0x822467CC;
		  /* 822467CCh */ case    3:  		/* lwz R11, <#[R23 + 8]> */
		/* 822467CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 822467CCh case    3:*/		return 0x822467D0;
		  /* 822467D0h */ case    4:  		/* add R3, R11, R26 */
		/* 822467D0h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 822467D0h case    4:*/		return 0x822467D4;
		  /* 822467D4h */ case    5:  		/* b 16 */
		/* 822467D4h case    5:*/		return 0x822467E4;
		/* 822467D4h case    5:*/		return 0x822467D8;
	}
	return 0x822467D8;
} // Block from 822467C0h-822467D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822467D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822467D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822467D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822467D8);
		  /* 822467D8h */ case    0:  		/* mr R4, R22 */
		/* 822467D8h case    0:*/		regs.R4 = regs.R22;
		/* 822467D8h case    0:*/		return 0x822467DC;
		  /* 822467DCh */ case    1:  		/* mr R3, R23 */
		/* 822467DCh case    1:*/		regs.R3 = regs.R23;
		/* 822467DCh case    1:*/		return 0x822467E0;
		  /* 822467E0h */ case    2:  		/* bl 53984 */
		/* 822467E0h case    2:*/		regs.LR = 0x822467E4; return 0x82253AC0;
		/* 822467E0h case    2:*/		return 0x822467E4;
	}
	return 0x822467E4;
} // Block from 822467D8h-822467E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822467E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822467E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822467E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822467E4);
		  /* 822467E4h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 822467E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822467E4h case    0:*/		return 0x822467E8;
		  /* 822467E8h */ case    1:  		/* mr R3, R18 */
		/* 822467E8h case    1:*/		regs.R3 = regs.R18;
		/* 822467E8h case    1:*/		return 0x822467EC;
		  /* 822467ECh */ case    2:  		/* ld R4, <#[R11 + 896]> */
		/* 822467ECh case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + 0x00000380) );
		/* 822467ECh case    2:*/		return 0x822467F0;
		  /* 822467F0h */ case    3:  		/* bl -3168 */
		/* 822467F0h case    3:*/		regs.LR = 0x822467F4; return 0x82245B90;
		/* 822467F0h case    3:*/		return 0x822467F4;
		  /* 822467F4h */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 822467F4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822467F4h case    4:*/		return 0x822467F8;
		  /* 822467F8h */ case    5:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 822467F8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 822467F8h case    5:*/		return 0x822467FC;
		  /* 822467FCh */ case    6:  		/* lwz R9, <#[R23 + 4]> */
		/* 822467FCh case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000004) );
		/* 822467FCh case    6:*/		return 0x82246800;
		  /* 82246800h */ case    7:  		/* cmplw CR6, R22, R9 */
		/* 82246800h case    7:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R9);
		/* 82246800h case    7:*/		return 0x82246804;
		  /* 82246804h */ case    8:  		/* lwzx R28, <#[R10 + R11]> */
		/* 82246804h case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82246804h case    8:*/		return 0x82246808;
		  /* 82246808h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 82246808h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82246818;  }
		/* 82246808h case    9:*/		return 0x8224680C;
		  /* 8224680Ch */ case   10:  		/* lwz R11, <#[R23 + 8]> */
		/* 8224680Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8224680Ch case   10:*/		return 0x82246810;
		  /* 82246810h */ case   11:  		/* add R3, R11, R26 */
		/* 82246810h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82246810h case   11:*/		return 0x82246814;
		  /* 82246814h */ case   12:  		/* b 16 */
		/* 82246814h case   12:*/		return 0x82246824;
		/* 82246814h case   12:*/		return 0x82246818;
	}
	return 0x82246818;
} // Block from 822467E4h-82246818h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82246818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246818);
		  /* 82246818h */ case    0:  		/* mr R4, R22 */
		/* 82246818h case    0:*/		regs.R4 = regs.R22;
		/* 82246818h case    0:*/		return 0x8224681C;
		  /* 8224681Ch */ case    1:  		/* mr R3, R23 */
		/* 8224681Ch case    1:*/		regs.R3 = regs.R23;
		/* 8224681Ch case    1:*/		return 0x82246820;
		  /* 82246820h */ case    2:  		/* bl 53920 */
		/* 82246820h case    2:*/		regs.LR = 0x82246824; return 0x82253AC0;
		/* 82246820h case    2:*/		return 0x82246824;
	}
	return 0x82246824;
} // Block from 82246818h-82246824h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246824);
		  /* 82246824h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246824h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246824h case    0:*/		return 0x82246828;
		  /* 82246828h */ case    1:  		/* mr R3, R18 */
		/* 82246828h case    1:*/		regs.R3 = regs.R18;
		/* 82246828h case    1:*/		return 0x8224682C;
		  /* 8224682Ch */ case    2:  		/* ld R4, <#[R11 + 904]> */
		/* 8224682Ch case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + 0x00000388) );
		/* 8224682Ch case    2:*/		return 0x82246830;
		  /* 82246830h */ case    3:  		/* bl -3232 */
		/* 82246830h case    3:*/		regs.LR = 0x82246834; return 0x82245B90;
		/* 82246830h case    3:*/		return 0x82246834;
		  /* 82246834h */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 82246834h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82246834h case    4:*/		return 0x82246838;
		  /* 82246838h */ case    5:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82246838h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82246838h case    5:*/		return 0x8224683C;
		  /* 8224683Ch */ case    6:  		/* lwz R9, <#[R23 + 4]> */
		/* 8224683Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000004) );
		/* 8224683Ch case    6:*/		return 0x82246840;
		  /* 82246840h */ case    7:  		/* cmplw CR6, R22, R9 */
		/* 82246840h case    7:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R9);
		/* 82246840h case    7:*/		return 0x82246844;
		  /* 82246844h */ case    8:  		/* lwzx R30, <#[R10 + R11]> */
		/* 82246844h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82246844h case    8:*/		return 0x82246848;
		  /* 82246848h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 82246848h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82246858;  }
		/* 82246848h case    9:*/		return 0x8224684C;
		  /* 8224684Ch */ case   10:  		/* lwz R11, <#[R23 + 8]> */
		/* 8224684Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8224684Ch case   10:*/		return 0x82246850;
		  /* 82246850h */ case   11:  		/* add R3, R11, R26 */
		/* 82246850h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82246850h case   11:*/		return 0x82246854;
		  /* 82246854h */ case   12:  		/* b 16 */
		/* 82246854h case   12:*/		return 0x82246864;
		/* 82246854h case   12:*/		return 0x82246858;
	}
	return 0x82246858;
} // Block from 82246824h-82246858h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82246858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246858);
		  /* 82246858h */ case    0:  		/* mr R4, R22 */
		/* 82246858h case    0:*/		regs.R4 = regs.R22;
		/* 82246858h case    0:*/		return 0x8224685C;
		  /* 8224685Ch */ case    1:  		/* mr R3, R23 */
		/* 8224685Ch case    1:*/		regs.R3 = regs.R23;
		/* 8224685Ch case    1:*/		return 0x82246860;
		  /* 82246860h */ case    2:  		/* bl 53856 */
		/* 82246860h case    2:*/		regs.LR = 0x82246864; return 0x82253AC0;
		/* 82246860h case    2:*/		return 0x82246864;
	}
	return 0x82246864;
} // Block from 82246858h-82246864h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246864);
		  /* 82246864h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246864h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246864h case    0:*/		return 0x82246868;
		  /* 82246868h */ case    1:  		/* mr R3, R18 */
		/* 82246868h case    1:*/		regs.R3 = regs.R18;
		/* 82246868h case    1:*/		return 0x8224686C;
		  /* 8224686Ch */ case    2:  		/* ld R4, <#[R11 + 896]> */
		/* 8224686Ch case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + 0x00000380) );
		/* 8224686Ch case    2:*/		return 0x82246870;
		  /* 82246870h */ case    3:  		/* bl -3296 */
		/* 82246870h case    3:*/		regs.LR = 0x82246874; return 0x82245B90;
		/* 82246870h case    3:*/		return 0x82246874;
		  /* 82246874h */ case    4:  		/* lwz R11, <#[R1 + 88]> */
		/* 82246874h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82246874h case    4:*/		return 0x82246878;
		  /* 82246878h */ case    5:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82246878h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82246878h case    5:*/		return 0x8224687C;
		  /* 8224687Ch */ case    6:  		/* lwz R9, <#[R23 + 4]> */
		/* 8224687Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000004) );
		/* 8224687Ch case    6:*/		return 0x82246880;
		  /* 82246880h */ case    7:  		/* cmplw CR6, R22, R9 */
		/* 82246880h case    7:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R9);
		/* 82246880h case    7:*/		return 0x82246884;
		  /* 82246884h */ case    8:  		/* lwzx R29, <#[R10 + R11]> */
		/* 82246884h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82246884h case    8:*/		return 0x82246888;
		  /* 82246888h */ case    9:  		/* bc 4, CR6_LT, 16 */
		/* 82246888h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82246898;  }
		/* 82246888h case    9:*/		return 0x8224688C;
		  /* 8224688Ch */ case   10:  		/* lwz R11, <#[R23 + 8]> */
		/* 8224688Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8224688Ch case   10:*/		return 0x82246890;
		  /* 82246890h */ case   11:  		/* add R3, R11, R26 */
		/* 82246890h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82246890h case   11:*/		return 0x82246894;
		  /* 82246894h */ case   12:  		/* b 16 */
		/* 82246894h case   12:*/		return 0x822468A4;
		/* 82246894h case   12:*/		return 0x82246898;
	}
	return 0x82246898;
} // Block from 82246864h-82246898h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82246898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246898);
		  /* 82246898h */ case    0:  		/* mr R4, R22 */
		/* 82246898h case    0:*/		regs.R4 = regs.R22;
		/* 82246898h case    0:*/		return 0x8224689C;
		  /* 8224689Ch */ case    1:  		/* mr R3, R23 */
		/* 8224689Ch case    1:*/		regs.R3 = regs.R23;
		/* 8224689Ch case    1:*/		return 0x822468A0;
		  /* 822468A0h */ case    2:  		/* bl 53792 */
		/* 822468A0h case    2:*/		regs.LR = 0x822468A4; return 0x82253AC0;
		/* 822468A0h case    2:*/		return 0x822468A4;
	}
	return 0x822468A4;
} // Block from 82246898h-822468A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822468A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822468A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822468A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822468A4);
		  /* 822468A4h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 822468A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822468A4h case    0:*/		return 0x822468A8;
		  /* 822468A8h */ case    1:  		/* mr R3, R18 */
		/* 822468A8h case    1:*/		regs.R3 = regs.R18;
		/* 822468A8h case    1:*/		return 0x822468AC;
		  /* 822468ACh */ case    2:  		/* ld R4, <#[R11 + 904]> */
		/* 822468ACh case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + 0x00000388) );
		/* 822468ACh case    2:*/		return 0x822468B0;
		  /* 822468B0h */ case    3:  		/* bl -3360 */
		/* 822468B0h case    3:*/		regs.LR = 0x822468B4; return 0x82245B90;
		/* 822468B0h case    3:*/		return 0x822468B4;
		  /* 822468B4h */ case    4:  		/* lwz R11, <#[R1 + 88]> */
		/* 822468B4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 822468B4h case    4:*/		return 0x822468B8;
		  /* 822468B8h */ case    5:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 822468B8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 822468B8h case    5:*/		return 0x822468BC;
		  /* 822468BCh */ case    6:  		/* li R27, 0 */
		/* 822468BCh case    6:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 822468BCh case    6:*/		return 0x822468C0;
		  /* 822468C0h */ case    7:  		/* li R6, 0 */
		/* 822468C0h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822468C0h case    7:*/		return 0x822468C4;
		  /* 822468C4h */ case    8:  		/* mr R25, R27 */
		/* 822468C4h case    8:*/		regs.R25 = regs.R27;
		/* 822468C4h case    8:*/		return 0x822468C8;
		  /* 822468C8h */ case    9:  		/* stw R27, <#[R1 + 124]> */
		/* 822468C8h case    9:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x0000007C) );
		/* 822468C8h case    9:*/		return 0x822468CC;
		  /* 822468CCh */ case   10:  		/* mr R24, R27 */
		/* 822468CCh case   10:*/		regs.R24 = regs.R27;
		/* 822468CCh case   10:*/		return 0x822468D0;
		  /* 822468D0h */ case   11:  		/* stw R27, <#[R1 + 112]> */
		/* 822468D0h case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000070) );
		/* 822468D0h case   11:*/		return 0x822468D4;
		  /* 822468D4h */ case   12:  		/* lwzx R10, <#[R10 + R11]> */
		/* 822468D4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822468D4h case   12:*/		return 0x822468D8;
		  /* 822468D8h */ case   13:  		/* mr R21, R27 */
		/* 822468D8h case   13:*/		regs.R21 = regs.R27;
		/* 822468D8h case   13:*/		return 0x822468DC;
		  /* 822468DCh */ case   14:  		/* stw R27, <#[R1 + 116]> */
		/* 822468DCh case   14:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000074) );
		/* 822468DCh case   14:*/		return 0x822468E0;
		  /* 822468E0h */ case   15:  		/* cmpwi CR6, R20, 0 */
		/* 822468E0h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 822468E0h case   15:*/		return 0x822468E4;
		  /* 822468E4h */ case   16:  		/* stw R27, <#[R1 + 120]> */
		/* 822468E4h case   16:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000078) );
		/* 822468E4h case   16:*/		return 0x822468E8;
		  /* 822468E8h */ case   17:  		/* bc 4, CR6_GT, 132 */
		/* 822468E8h case   17:*/		if ( !regs.CR[6].gt ) { return 0x8224696C;  }
		/* 822468E8h case   17:*/		return 0x822468EC;
		  /* 822468ECh */ case   18:  		/* mr R11, R30 */
		/* 822468ECh case   18:*/		regs.R11 = regs.R30;
		/* 822468ECh case   18:*/		return 0x822468F0;
		  /* 822468F0h */ case   19:  		/* subf R9, R30, R28 */
		/* 822468F0h case   19:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R30,regs.R28);
		/* 822468F0h case   19:*/		return 0x822468F4;
		  /* 822468F4h */ case   20:  		/* subf R8, R30, R29 */
		/* 822468F4h case   20:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R30,regs.R29);
		/* 822468F4h case   20:*/		return 0x822468F8;
		  /* 822468F8h */ case   21:  		/* subf R10, R30, R10 */
		/* 822468F8h case   21:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R30,regs.R10);
		/* 822468F8h case   21:*/		return 0x822468FC;
		  /* 822468FCh */ case   22:  		/* lwzx R25, <#[R9 + R11]> */
		/* 822468FCh case   22:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 822468FCh case   22:*/		return 0x82246900;
		  /* 82246900h */ case   23:  		/* lwz R24, <#[R11]> */
		/* 82246900h case   23:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R11 + 0x00000000) );
		/* 82246900h case   23:*/		return 0x82246904;
		  /* 82246904h */ case   24:  		/* lwzx R21, <#[R8 + R11]> */
		/* 82246904h case   24:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82246904h case   24:*/		return 0x82246908;
		  /* 82246908h */ case   25:  		/* cmpwi CR6, R25, 0 */
		/* 82246908h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82246908h case   25:*/		return 0x8224690C;
		  /* 8224690Ch */ case   26:  		/* lwzx R7, <#[R10 + R11]> */
		/* 8224690Ch case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224690Ch case   26:*/		return 0x82246910;
		  /* 82246910h */ case   27:  		/* stw R25, <#[R1 + 112]> */
		/* 82246910h case   27:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000070) );
		/* 82246910h case   27:*/		return 0x82246914;
		  /* 82246914h */ case   28:  		/* stw R24, <#[R1 + 116]> */
		/* 82246914h case   28:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000074) );
		/* 82246914h case   28:*/		return 0x82246918;
		  /* 82246918h */ case   29:  		/* stw R21, <#[R1 + 120]> */
		/* 82246918h case   29:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000078) );
		/* 82246918h case   29:*/		return 0x8224691C;
		  /* 8224691Ch */ case   30:  		/* stw R7, <#[R1 + 124]> */
		/* 8224691Ch case   30:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x0000007C) );
		/* 8224691Ch case   30:*/		return 0x82246920;
		  /* 82246920h */ case   31:  		/* bc 4, CR6_EQ, 48 */
		/* 82246920h case   31:*/		if ( !regs.CR[6].eq ) { return 0x82246950;  }
		/* 82246920h case   31:*/		return 0x82246924;
		  /* 82246924h */ case   32:  		/* cmpwi CR6, R24, 0 */
		/* 82246924h case   32:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82246924h case   32:*/		return 0x82246928;
		  /* 82246928h */ case   33:  		/* bc 4, CR6_EQ, 48 */
		/* 82246928h case   33:*/		if ( !regs.CR[6].eq ) { return 0x82246958;  }
		/* 82246928h case   33:*/		return 0x8224692C;
		  /* 8224692Ch */ case   34:  		/* cmpwi CR6, R21, 0 */
		/* 8224692Ch case   34:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8224692Ch case   34:*/		return 0x82246930;
		  /* 82246930h */ case   35:  		/* bc 4, CR6_EQ, 48 */
		/* 82246930h case   35:*/		if ( !regs.CR[6].eq ) { return 0x82246960;  }
		/* 82246930h case   35:*/		return 0x82246934;
		  /* 82246934h */ case   36:  		/* cmpwi CR6, R7, 0 */
		/* 82246934h case   36:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 82246934h case   36:*/		return 0x82246938;
		  /* 82246938h */ case   37:  		/* bc 4, CR6_EQ, 48 */
		/* 82246938h case   37:*/		if ( !regs.CR[6].eq ) { return 0x82246968;  }
		/* 82246938h case   37:*/		return 0x8224693C;
		  /* 8224693Ch */ case   38:  		/* addi R6, R6, 1 */
		/* 8224693Ch case   38:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8224693Ch case   38:*/		return 0x82246940;
		  /* 82246940h */ case   39:  		/* addi R11, R11, 4 */
		/* 82246940h case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82246940h case   39:*/		return 0x82246944;
		  /* 82246944h */ case   40:  		/* cmpw CR6, R6, R20 */
		/* 82246944h case   40:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R20);
		/* 82246944h case   40:*/		return 0x82246948;
		  /* 82246948h */ case   41:  		/* bc 12, CR6_LT, -76 */
		/* 82246948h case   41:*/		if ( regs.CR[6].lt ) { return 0x822468FC;  }
		/* 82246948h case   41:*/		return 0x8224694C;
		  /* 8224694Ch */ case   42:  		/* b 32 */
		/* 8224694Ch case   42:*/		return 0x8224696C;
		/* 8224694Ch case   42:*/		return 0x82246950;
	}
	return 0x82246950;
} // Block from 822468A4h-82246950h (43 instructions)

//////////////////////////////////////////////////////
// Block at 82246950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246950);
		  /* 82246950h */ case    0:  		/* li R27, 0 */
		/* 82246950h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82246950h case    0:*/		return 0x82246954;
		  /* 82246954h */ case    1:  		/* b 24 */
		/* 82246954h case    1:*/		return 0x8224696C;
		/* 82246954h case    1:*/		return 0x82246958;
	}
	return 0x82246958;
} // Block from 82246950h-82246958h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82246958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246958);
		  /* 82246958h */ case    0:  		/* li R27, 1 */
		/* 82246958h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82246958h case    0:*/		return 0x8224695C;
		  /* 8224695Ch */ case    1:  		/* b 16 */
		/* 8224695Ch case    1:*/		return 0x8224696C;
		/* 8224695Ch case    1:*/		return 0x82246960;
	}
	return 0x82246960;
} // Block from 82246958h-82246960h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82246960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246960);
		  /* 82246960h */ case    0:  		/* li R27, 2 */
		/* 82246960h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x2);
		/* 82246960h case    0:*/		return 0x82246964;
		  /* 82246964h */ case    1:  		/* b 8 */
		/* 82246964h case    1:*/		return 0x8224696C;
		/* 82246964h case    1:*/		return 0x82246968;
	}
	return 0x82246968;
} // Block from 82246960h-82246968h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82246968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246968);
		  /* 82246968h */ case    0:  		/* li R27, 3 */
		/* 82246968h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x3);
		/* 82246968h case    0:*/		return 0x8224696C;
	}
	return 0x8224696C;
} // Block from 82246968h-8224696Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224696Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224696C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224696C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224696C);
		  /* 8224696Ch */ case    0:  		/* cmpw CR6, R6, R20 */
		/* 8224696Ch case    0:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R20);
		/* 8224696Ch case    0:*/		return 0x82246970;
		  /* 82246970h */ case    1:  		/* bc 12, CR6_EQ, 636 */
		/* 82246970h case    1:*/		if ( regs.CR[6].eq ) { return 0x82246BEC;  }
		/* 82246970h case    1:*/		return 0x82246974;
		  /* 82246974h */ case    2:  		/* rlwinm R10, R27, 2, 0, 29 */
		/* 82246974h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R27);
		/* 82246974h case    2:*/		return 0x82246978;
		  /* 82246978h */ case    3:  		/* addi R11, R1, 112 */
		/* 82246978h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 82246978h case    3:*/		return 0x8224697C;
		  /* 8224697Ch */ case    4:  		/* li R4, 1 */
		/* 8224697Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224697Ch case    4:*/		return 0x82246980;
		  /* 82246980h */ case    5:  		/* add R3, R10, R11 */
		/* 82246980h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82246980h case    5:*/		return 0x82246984;
		  /* 82246984h */ case    6:  		/* bl -7340 */
		/* 82246984h case    6:*/		regs.LR = 0x82246988; return 0x82244CD8;
		/* 82246984h case    6:*/		return 0x82246988;
		  /* 82246988h */ case    7:  		/* rlwinm R11, R6, 5, 0, 26 */
		/* 82246988h case    7:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R6);
		/* 82246988h case    7:*/		return 0x8224698C;
		  /* 8224698Ch */ case    8:  		/* cmpwi CR6, R27, 2 */
		/* 8224698Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000002);
		/* 8224698Ch case    8:*/		return 0x82246990;
		  /* 82246990h */ case    9:  		/* add R31, R3, R11 */
		/* 82246990h case    9:*/		cpu::op::add<0>(regs,&regs.R31,regs.R3,regs.R11);
		/* 82246990h case    9:*/		return 0x82246994;
		  /* 82246994h */ case   10:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246994h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246994h case   10:*/		return 0x82246998;
		  /* 82246998h */ case   11:  		/* bc 4, CR6_LT, 172 */
		/* 82246998h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82246A44;  }
		/* 82246998h case   11:*/		return 0x8224699C;
		  /* 8224699Ch */ case   12:  		/* cmplw CR6, R22, R11 */
		/* 8224699Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 8224699Ch case   12:*/		return 0x822469A0;
		  /* 822469A0h */ case   13:  		/* bc 4, CR6_LT, 16 */
		/* 822469A0h case   13:*/		if ( !regs.CR[6].lt ) { return 0x822469B0;  }
		/* 822469A0h case   13:*/		return 0x822469A4;
		  /* 822469A4h */ case   14:  		/* lwz R11, <#[R23 + 8]> */
		/* 822469A4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 822469A4h case   14:*/		return 0x822469A8;
		  /* 822469A8h */ case   15:  		/* add R30, R11, R26 */
		/* 822469A8h case   15:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R26);
		/* 822469A8h case   15:*/		return 0x822469AC;
		  /* 822469ACh */ case   16:  		/* b 20 */
		/* 822469ACh case   16:*/		return 0x822469C0;
		/* 822469ACh case   16:*/		return 0x822469B0;
	}
	return 0x822469B0;
} // Block from 8224696Ch-822469B0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822469B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822469B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822469B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822469B0);
		  /* 822469B0h */ case    0:  		/* mr R4, R22 */
		/* 822469B0h case    0:*/		regs.R4 = regs.R22;
		/* 822469B0h case    0:*/		return 0x822469B4;
		  /* 822469B4h */ case    1:  		/* mr R3, R23 */
		/* 822469B4h case    1:*/		regs.R3 = regs.R23;
		/* 822469B4h case    1:*/		return 0x822469B8;
		  /* 822469B8h */ case    2:  		/* bl 53512 */
		/* 822469B8h case    2:*/		regs.LR = 0x822469BC; return 0x82253AC0;
		/* 822469B8h case    2:*/		return 0x822469BC;
		  /* 822469BCh */ case    3:  		/* mr R30, R3 */
		/* 822469BCh case    3:*/		regs.R30 = regs.R3;
		/* 822469BCh case    3:*/		return 0x822469C0;
	}
	return 0x822469C0;
} // Block from 822469B0h-822469C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822469C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822469C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822469C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822469C0);
		  /* 822469C0h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 822469C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 822469C0h case    0:*/		return 0x822469C4;
		  /* 822469C4h */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 822469C4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 822469C4h case    1:*/		return 0x822469C8;
		  /* 822469C8h */ case    2:  		/* bc 4, CR6_LT, 20 */
		/* 822469C8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x822469DC;  }
		/* 822469C8h case    2:*/		return 0x822469CC;
		  /* 822469CCh */ case    3:  		/* lwz R11, <#[R23 + 8]> */
		/* 822469CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 822469CCh case    3:*/		return 0x822469D0;
		  /* 822469D0h */ case    4:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 822469D0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 822469D0h case    4:*/		return 0x822469D4;
		  /* 822469D4h */ case    5:  		/* add R3, R10, R11 */
		/* 822469D4h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 822469D4h case    5:*/		return 0x822469D8;
		  /* 822469D8h */ case    6:  		/* b 16 */
		/* 822469D8h case    6:*/		return 0x822469E8;
		/* 822469D8h case    6:*/		return 0x822469DC;
	}
	return 0x822469DC;
} // Block from 822469C0h-822469DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 822469DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822469DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822469DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822469DC);
		  /* 822469DCh */ case    0:  		/* mr R4, R31 */
		/* 822469DCh case    0:*/		regs.R4 = regs.R31;
		/* 822469DCh case    0:*/		return 0x822469E0;
		  /* 822469E0h */ case    1:  		/* mr R3, R23 */
		/* 822469E0h case    1:*/		regs.R3 = regs.R23;
		/* 822469E0h case    1:*/		return 0x822469E4;
		  /* 822469E4h */ case    2:  		/* bl 53468 */
		/* 822469E4h case    2:*/		regs.LR = 0x822469E8; return 0x82253AC0;
		/* 822469E4h case    2:*/		return 0x822469E8;
	}
	return 0x822469E8;
} // Block from 822469DCh-822469E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822469E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822469E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822469E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822469E8);
		  /* 822469E8h */ case    0:  		/* subfic R9, R27, 113 */
		/* 822469E8h case    0:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R27,0x71);
		/* 822469E8h case    0:*/		return 0x822469EC;
		  /* 822469ECh */ case    1:  		/* lwz R11, <#[R30]> */
		/* 822469ECh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822469ECh case    1:*/		return 0x822469F0;
		  /* 822469F0h */ case    2:  		/* lwz R10, <#[R3]> */
		/* 822469F0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 822469F0h case    2:*/		return 0x822469F4;
		  /* 822469F4h */ case    3:  		/* rlwinm R9, R9, 3, 0, 28 */
		/* 822469F4h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R9);
		/* 822469F4h case    3:*/		return 0x822469F8;
		  /* 822469F8h */ case    4:  		/* add R11, R9, R11 */
		/* 822469F8h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 822469F8h case    4:*/		return 0x822469FC;
		  /* 822469FCh */ case    5:  		/* lwz R9, <#[R11]> */
		/* 822469FCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822469FCh case    5:*/		return 0x82246A00;
		  /* 82246A00h */ case    6:  		/* stw R9, <#[R10 + 920]> */
		/* 82246A00h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000398) );
		/* 82246A00h case    6:*/		return 0x82246A04;
		  /* 82246A04h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 82246A04h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82246A04h case    7:*/		return 0x82246A08;
		  /* 82246A08h */ case    8:  		/* stw R11, <#[R10 + 924]> */
		/* 82246A08h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000039C) );
		/* 82246A08h case    8:*/		return 0x82246A0C;
		  /* 82246A0Ch */ case    9:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246A0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246A0Ch case    9:*/		return 0x82246A10;
		  /* 82246A10h */ case   10:  		/* cmplw CR6, R31, R11 */
		/* 82246A10h case   10:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82246A10h case   10:*/		return 0x82246A14;
		  /* 82246A14h */ case   11:  		/* bc 4, CR6_LT, 20 */
		/* 82246A14h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82246A28;  }
		/* 82246A14h case   11:*/		return 0x82246A18;
		  /* 82246A18h */ case   12:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246A18h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246A18h case   12:*/		return 0x82246A1C;
		  /* 82246A1Ch */ case   13:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82246A1Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82246A1Ch case   13:*/		return 0x82246A20;
		  /* 82246A20h */ case   14:  		/* add R3, R10, R11 */
		/* 82246A20h case   14:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82246A20h case   14:*/		return 0x82246A24;
		  /* 82246A24h */ case   15:  		/* b 16 */
		/* 82246A24h case   15:*/		return 0x82246A34;
		/* 82246A24h case   15:*/		return 0x82246A28;
	}
	return 0x82246A28;
} // Block from 822469E8h-82246A28h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82246A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246A28);
		  /* 82246A28h */ case    0:  		/* mr R4, R31 */
		/* 82246A28h case    0:*/		regs.R4 = regs.R31;
		/* 82246A28h case    0:*/		return 0x82246A2C;
		  /* 82246A2Ch */ case    1:  		/* mr R3, R23 */
		/* 82246A2Ch case    1:*/		regs.R3 = regs.R23;
		/* 82246A2Ch case    1:*/		return 0x82246A30;
		  /* 82246A30h */ case    2:  		/* bl 53392 */
		/* 82246A30h case    2:*/		regs.LR = 0x82246A34; return 0x82253AC0;
		/* 82246A30h case    2:*/		return 0x82246A34;
	}
	return 0x82246A34;
} // Block from 82246A28h-82246A34h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246A34);
		  /* 82246A34h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246A34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246A34h case    0:*/		return 0x82246A38;
		  /* 82246A38h */ case    1:  		/* li R10, 1 */
		/* 82246A38h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82246A38h case    1:*/		return 0x82246A3C;
		  /* 82246A3Ch */ case    2:  		/* stw R10, <#[R11 + 940]> */
		/* 82246A3Ch case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000003AC) );
		/* 82246A3Ch case    2:*/		return 0x82246A40;
		  /* 82246A40h */ case    3:  		/* b 168 */
		/* 82246A40h case    3:*/		return 0x82246AE8;
		/* 82246A40h case    3:*/		return 0x82246A44;
	}
	return 0x82246A44;
} // Block from 82246A34h-82246A44h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82246A44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246A44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246A44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246A44);
		  /* 82246A44h */ case    0:  		/* cmplw CR6, R22, R11 */
		/* 82246A44h case    0:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82246A44h case    0:*/		return 0x82246A48;
		  /* 82246A48h */ case    1:  		/* bc 4, CR6_LT, 16 */
		/* 82246A48h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82246A58;  }
		/* 82246A48h case    1:*/		return 0x82246A4C;
		  /* 82246A4Ch */ case    2:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246A4Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246A4Ch case    2:*/		return 0x82246A50;
		  /* 82246A50h */ case    3:  		/* add R30, R11, R26 */
		/* 82246A50h case    3:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R26);
		/* 82246A50h case    3:*/		return 0x82246A54;
		  /* 82246A54h */ case    4:  		/* b 20 */
		/* 82246A54h case    4:*/		return 0x82246A68;
		/* 82246A54h case    4:*/		return 0x82246A58;
	}
	return 0x82246A58;
} // Block from 82246A44h-82246A58h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82246A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246A58);
		  /* 82246A58h */ case    0:  		/* mr R4, R22 */
		/* 82246A58h case    0:*/		regs.R4 = regs.R22;
		/* 82246A58h case    0:*/		return 0x82246A5C;
		  /* 82246A5Ch */ case    1:  		/* mr R3, R23 */
		/* 82246A5Ch case    1:*/		regs.R3 = regs.R23;
		/* 82246A5Ch case    1:*/		return 0x82246A60;
		  /* 82246A60h */ case    2:  		/* bl 53344 */
		/* 82246A60h case    2:*/		regs.LR = 0x82246A64; return 0x82253AC0;
		/* 82246A60h case    2:*/		return 0x82246A64;
		  /* 82246A64h */ case    3:  		/* mr R30, R3 */
		/* 82246A64h case    3:*/		regs.R30 = regs.R3;
		/* 82246A64h case    3:*/		return 0x82246A68;
	}
	return 0x82246A68;
} // Block from 82246A58h-82246A68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82246A68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246A68);
		  /* 82246A68h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246A68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246A68h case    0:*/		return 0x82246A6C;
		  /* 82246A6Ch */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 82246A6Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82246A6Ch case    1:*/		return 0x82246A70;
		  /* 82246A70h */ case    2:  		/* bc 4, CR6_LT, 20 */
		/* 82246A70h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82246A84;  }
		/* 82246A70h case    2:*/		return 0x82246A74;
		  /* 82246A74h */ case    3:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246A74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246A74h case    3:*/		return 0x82246A78;
		  /* 82246A78h */ case    4:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82246A78h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82246A78h case    4:*/		return 0x82246A7C;
		  /* 82246A7Ch */ case    5:  		/* add R3, R10, R11 */
		/* 82246A7Ch case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82246A7Ch case    5:*/		return 0x82246A80;
		  /* 82246A80h */ case    6:  		/* b 16 */
		/* 82246A80h case    6:*/		return 0x82246A90;
		/* 82246A80h case    6:*/		return 0x82246A84;
	}
	return 0x82246A84;
} // Block from 82246A68h-82246A84h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82246A84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246A84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246A84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246A84);
		  /* 82246A84h */ case    0:  		/* mr R4, R31 */
		/* 82246A84h case    0:*/		regs.R4 = regs.R31;
		/* 82246A84h case    0:*/		return 0x82246A88;
		  /* 82246A88h */ case    1:  		/* mr R3, R23 */
		/* 82246A88h case    1:*/		regs.R3 = regs.R23;
		/* 82246A88h case    1:*/		return 0x82246A8C;
		  /* 82246A8Ch */ case    2:  		/* bl 53300 */
		/* 82246A8Ch case    2:*/		regs.LR = 0x82246A90; return 0x82253AC0;
		/* 82246A8Ch case    2:*/		return 0x82246A90;
	}
	return 0x82246A90;
} // Block from 82246A84h-82246A90h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246A90);
		  /* 82246A90h */ case    0:  		/* subfic R9, R27, 115 */
		/* 82246A90h case    0:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R27,0x73);
		/* 82246A90h case    0:*/		return 0x82246A94;
		  /* 82246A94h */ case    1:  		/* lwz R11, <#[R30]> */
		/* 82246A94h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82246A94h case    1:*/		return 0x82246A98;
		  /* 82246A98h */ case    2:  		/* lwz R10, <#[R3]> */
		/* 82246A98h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82246A98h case    2:*/		return 0x82246A9C;
		  /* 82246A9Ch */ case    3:  		/* rlwinm R9, R9, 3, 0, 28 */
		/* 82246A9Ch case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R9);
		/* 82246A9Ch case    3:*/		return 0x82246AA0;
		  /* 82246AA0h */ case    4:  		/* add R11, R9, R11 */
		/* 82246AA0h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82246AA0h case    4:*/		return 0x82246AA4;
		  /* 82246AA4h */ case    5:  		/* lwz R9, <#[R11]> */
		/* 82246AA4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82246AA4h case    5:*/		return 0x82246AA8;
		  /* 82246AA8h */ case    6:  		/* stw R9, <#[R10 + 912]> */
		/* 82246AA8h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000390) );
		/* 82246AA8h case    6:*/		return 0x82246AAC;
		  /* 82246AACh */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 82246AACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82246AACh case    7:*/		return 0x82246AB0;
		  /* 82246AB0h */ case    8:  		/* stw R11, <#[R10 + 916]> */
		/* 82246AB0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000394) );
		/* 82246AB0h case    8:*/		return 0x82246AB4;
		  /* 82246AB4h */ case    9:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246AB4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246AB4h case    9:*/		return 0x82246AB8;
		  /* 82246AB8h */ case   10:  		/* cmplw CR6, R31, R11 */
		/* 82246AB8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82246AB8h case   10:*/		return 0x82246ABC;
		  /* 82246ABCh */ case   11:  		/* bc 4, CR6_LT, 20 */
		/* 82246ABCh case   11:*/		if ( !regs.CR[6].lt ) { return 0x82246AD0;  }
		/* 82246ABCh case   11:*/		return 0x82246AC0;
		  /* 82246AC0h */ case   12:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246AC0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246AC0h case   12:*/		return 0x82246AC4;
		  /* 82246AC4h */ case   13:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82246AC4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82246AC4h case   13:*/		return 0x82246AC8;
		  /* 82246AC8h */ case   14:  		/* add R3, R10, R11 */
		/* 82246AC8h case   14:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82246AC8h case   14:*/		return 0x82246ACC;
		  /* 82246ACCh */ case   15:  		/* b 16 */
		/* 82246ACCh case   15:*/		return 0x82246ADC;
		/* 82246ACCh case   15:*/		return 0x82246AD0;
	}
	return 0x82246AD0;
} // Block from 82246A90h-82246AD0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82246AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246AD0);
		  /* 82246AD0h */ case    0:  		/* mr R4, R31 */
		/* 82246AD0h case    0:*/		regs.R4 = regs.R31;
		/* 82246AD0h case    0:*/		return 0x82246AD4;
		  /* 82246AD4h */ case    1:  		/* mr R3, R23 */
		/* 82246AD4h case    1:*/		regs.R3 = regs.R23;
		/* 82246AD4h case    1:*/		return 0x82246AD8;
		  /* 82246AD8h */ case    2:  		/* bl 53224 */
		/* 82246AD8h case    2:*/		regs.LR = 0x82246ADC; return 0x82253AC0;
		/* 82246AD8h case    2:*/		return 0x82246ADC;
	}
	return 0x82246ADC;
} // Block from 82246AD0h-82246ADCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246ADC);
		  /* 82246ADCh */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246ADCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246ADCh case    0:*/		return 0x82246AE0;
		  /* 82246AE0h */ case    1:  		/* li R10, 1 */
		/* 82246AE0h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82246AE0h case    1:*/		return 0x82246AE4;
		  /* 82246AE4h */ case    2:  		/* stw R10, <#[R11 + 936]> */
		/* 82246AE4h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000003A8) );
		/* 82246AE4h case    2:*/		return 0x82246AE8;
	}
	return 0x82246AE8;
} // Block from 82246ADCh-82246AE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246AE8);
		  /* 82246AE8h */ case    0:  		/* lwz R9, <#[R1 + 92]> */
		/* 82246AE8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 82246AE8h case    0:*/		return 0x82246AEC;
		  /* 82246AECh */ case    1:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 82246AECh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 82246AECh case    1:*/		return 0x82246AF0;
		  /* 82246AF0h */ case    2:  		/* lwz R8, <#[R1 + 84]> */
		/* 82246AF0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 82246AF0h case    2:*/		return 0x82246AF4;
		  /* 82246AF4h */ case    3:  		/* li R30, 896 */
		/* 82246AF4h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x380);
		/* 82246AF4h case    3:*/		return 0x82246AF8;
		  /* 82246AF8h */ case    4:  		/* li R29, 928 */
		/* 82246AF8h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x3A0);
		/* 82246AF8h case    4:*/		return 0x82246AFC;
		  /* 82246AFCh */ case    5:  		/* lwzx R10, <#[R11 + R9]> */
		/* 82246AFCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82246AFCh case    5:*/		return 0x82246B00;
		  /* 82246B00h */ case    6:  		/* addi R10, R10, -1 */
		/* 82246B00h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82246B00h case    6:*/		return 0x82246B04;
		  /* 82246B04h */ case    7:  		/* stwx R10, <#[R11 + R9]> */
		/* 82246B04h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82246B04h case    7:*/		return 0x82246B08;
		  /* 82246B08h */ case    8:  		/* stwx R31, <#[R26 + R8]> */
		/* 82246B08h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R26 + regs.R8 + 0x00000000) );
		/* 82246B08h case    8:*/		return 0x82246B0C;
		  /* 82246B0Ch */ case    9:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246B0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246B0Ch case    9:*/		return 0x82246B10;
		  /* 82246B10h */ case   10:  		/* cmplw CR6, R22, R11 */
		/* 82246B10h case   10:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82246B10h case   10:*/		return 0x82246B14;
		  /* 82246B14h */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 82246B14h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82246B24;  }
		/* 82246B14h case   11:*/		return 0x82246B18;
		  /* 82246B18h */ case   12:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246B18h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246B18h case   12:*/		return 0x82246B1C;
		  /* 82246B1Ch */ case   13:  		/* add R3, R11, R26 */
		/* 82246B1Ch case   13:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82246B1Ch case   13:*/		return 0x82246B20;
		  /* 82246B20h */ case   14:  		/* b 16 */
		/* 82246B20h case   14:*/		return 0x82246B30;
		/* 82246B20h case   14:*/		return 0x82246B24;
	}
	return 0x82246B24;
} // Block from 82246AE8h-82246B24h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82246B24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246B24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246B24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246B24);
		  /* 82246B24h */ case    0:  		/* mr R4, R22 */
		/* 82246B24h case    0:*/		regs.R4 = regs.R22;
		/* 82246B24h case    0:*/		return 0x82246B28;
		  /* 82246B28h */ case    1:  		/* mr R3, R23 */
		/* 82246B28h case    1:*/		regs.R3 = regs.R23;
		/* 82246B28h case    1:*/		return 0x82246B2C;
		  /* 82246B2Ch */ case    2:  		/* bl 53140 */
		/* 82246B2Ch case    2:*/		regs.LR = 0x82246B30; return 0x82253AC0;
		/* 82246B2Ch case    2:*/		return 0x82246B30;
	}
	return 0x82246B30;
} // Block from 82246B24h-82246B30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246B30);
		  /* 82246B30h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246B30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246B30h case    0:*/		return 0x82246B34;
		  /* 82246B34h */ case    1:  		/* lwzx R11, <#[R11 + R29]> */
		/* 82246B34h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82246B34h case    1:*/		return 0x82246B38;
		  /* 82246B38h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82246B38h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82246B38h case    2:*/		return 0x82246B3C;
		  /* 82246B3Ch */ case    3:  		/* bc 12, CR6_EQ, 312 */
		/* 82246B3Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82246C74;  }
		/* 82246B3Ch case    3:*/		return 0x82246B40;
		  /* 82246B40h */ case    4:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246B40h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246B40h case    4:*/		return 0x82246B44;
		  /* 82246B44h */ case    5:  		/* cmplw CR6, R22, R11 */
		/* 82246B44h case    5:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82246B44h case    5:*/		return 0x82246B48;
		  /* 82246B48h */ case    6:  		/* bc 4, CR6_LT, 16 */
		/* 82246B48h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82246B58;  }
		/* 82246B48h case    6:*/		return 0x82246B4C;
		  /* 82246B4Ch */ case    7:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246B4Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246B4Ch case    7:*/		return 0x82246B50;
		  /* 82246B50h */ case    8:  		/* add R3, R11, R26 */
		/* 82246B50h case    8:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82246B50h case    8:*/		return 0x82246B54;
		  /* 82246B54h */ case    9:  		/* b 16 */
		/* 82246B54h case    9:*/		return 0x82246B64;
		/* 82246B54h case    9:*/		return 0x82246B58;
	}
	return 0x82246B58;
} // Block from 82246B30h-82246B58h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82246B58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246B58);
		  /* 82246B58h */ case    0:  		/* mr R4, R22 */
		/* 82246B58h case    0:*/		regs.R4 = regs.R22;
		/* 82246B58h case    0:*/		return 0x82246B5C;
		  /* 82246B5Ch */ case    1:  		/* mr R3, R23 */
		/* 82246B5Ch case    1:*/		regs.R3 = regs.R23;
		/* 82246B5Ch case    1:*/		return 0x82246B60;
		  /* 82246B60h */ case    2:  		/* bl 53088 */
		/* 82246B60h case    2:*/		regs.LR = 0x82246B64; return 0x82253AC0;
		/* 82246B60h case    2:*/		return 0x82246B64;
	}
	return 0x82246B64;
} // Block from 82246B58h-82246B64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246B64);
		  /* 82246B64h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246B64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246B64h case    0:*/		return 0x82246B68;
		  /* 82246B68h */ case    1:  		/* mr R3, R18 */
		/* 82246B68h case    1:*/		regs.R3 = regs.R18;
		/* 82246B68h case    1:*/		return 0x82246B6C;
		  /* 82246B6Ch */ case    2:  		/* ldx R4, <#[R11 + R30]> */
		/* 82246B6Ch case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82246B6Ch case    2:*/		return 0x82246B70;
		  /* 82246B70h */ case    3:  		/* bl -4064 */
		/* 82246B70h case    3:*/		regs.LR = 0x82246B74; return 0x82245B90;
		/* 82246B70h case    3:*/		return 0x82246B74;
		  /* 82246B74h */ case    4:  		/* srawi R11, R31, 5 */
		/* 82246B74h case    4:*/		cpu::op::srawi<0,5>(regs,&regs.R11,regs.R31);
		/* 82246B74h case    4:*/		return 0x82246B78;
		  /* 82246B78h */ case    5:  		/* cmpwi CR6, R27, 1 */
		/* 82246B78h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000001);
		/* 82246B78h case    5:*/		return 0x82246B7C;
		  /* 82246B7Ch */ case    6:  		/* addze R11, R11 */
		/* 82246B7Ch case    6:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 82246B7Ch case    6:*/		return 0x82246B80;
		  /* 82246B80h */ case    7:  		/* srawi R7, R31, 5 */
		/* 82246B80h case    7:*/		cpu::op::srawi<0,5>(regs,&regs.R7,regs.R31);
		/* 82246B80h case    7:*/		return 0x82246B84;
		  /* 82246B84h */ case    8:  		/* rlwinm R9, R3, 2, 0, 29 */
		/* 82246B84h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R3);
		/* 82246B84h case    8:*/		return 0x82246B88;
		  /* 82246B88h */ case    9:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 82246B88h case    9:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 82246B88h case    9:*/		return 0x82246B8C;
		  /* 82246B8Ch */ case   10:  		/* addze R7, R7 */
		/* 82246B8Ch case   10:*/		cpu::op::addze<0>(regs,&regs.R7,regs.R7);
		/* 82246B8Ch case   10:*/		return 0x82246B90;
		  /* 82246B90h */ case   11:  		/* bc 4, CR6_GT, 16 */
		/* 82246B90h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82246BA0;  }
		/* 82246B90h case   11:*/		return 0x82246B94;
		  /* 82246B94h */ case   12:  		/* lwz R10, <#[R1 + 88]> */
		/* 82246B94h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82246B94h case   12:*/		return 0x82246B98;
		  /* 82246B98h */ case   13:  		/* lwz R8, <#[R1 + 80]> */
		/* 82246B98h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 82246B98h case   13:*/		return 0x82246B9C;
		  /* 82246B9Ch */ case   14:  		/* b 12 */
		/* 82246B9Ch case   14:*/		return 0x82246BA8;
		/* 82246B9Ch case   14:*/		return 0x82246BA0;
	}
	return 0x82246BA0;
} // Block from 82246B64h-82246BA0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82246BA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246BA0);
		  /* 82246BA0h */ case    0:  		/* lwz R10, <#[R1 + 80]> */
		/* 82246BA0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82246BA0h case    0:*/		return 0x82246BA4;
		  /* 82246BA4h */ case    1:  		/* lwz R8, <#[R1 + 100]> */
		/* 82246BA4h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000064) );
		/* 82246BA4h case    1:*/		return 0x82246BA8;
	}
	return 0x82246BA8;
} // Block from 82246BA0h-82246BA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82246BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246BA8);
		  /* 82246BA8h */ case    0:  		/* lwzx R6, <#[R9 + R10]> */
		/* 82246BA8h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82246BA8h case    0:*/		return 0x82246BAC;
		  /* 82246BACh */ case    1:  		/* subf R10, R11, R31 */
		/* 82246BACh case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R31);
		/* 82246BACh case    1:*/		return 0x82246BB0;
		  /* 82246BB0h */ case    2:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 82246BB0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 82246BB0h case    2:*/		return 0x82246BB4;
		  /* 82246BB4h */ case    3:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82246BB4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82246BB4h case    3:*/		return 0x82246BB8;
		  /* 82246BB8h */ case    4:  		/* li R8, 1 */
		/* 82246BB8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82246BB8h case    4:*/		return 0x82246BBC;
		  /* 82246BBCh */ case    5:  		/* addi R29, R29, 4 */
		/* 82246BBCh case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82246BBCh case    5:*/		return 0x82246BC0;
		  /* 82246BC0h */ case    6:  		/* slw R10, R8, R10 */
		/* 82246BC0h case    6:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82246BC0h case    6:*/		return 0x82246BC4;
		  /* 82246BC4h */ case    7:  		/* lwzx R8, <#[R6 + R11]> */
		/* 82246BC4h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82246BC4h case    7:*/		return 0x82246BC8;
		  /* 82246BC8h */ case    8:  		/* addi R30, R30, 8 */
		/* 82246BC8h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x8);
		/* 82246BC8h case    8:*/		return 0x82246BCC;
		  /* 82246BCCh */ case    9:  		/* cmpwi CR6, R29, 944 */
		/* 82246BCCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x000003B0);
		/* 82246BCCh case    9:*/		return 0x82246BD0;
		  /* 82246BD0h */ case   10:  		/* andc R8, R8, R10 */
		/* 82246BD0h case   10:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 82246BD0h case   10:*/		return 0x82246BD4;
		  /* 82246BD4h */ case   11:  		/* stwx R8, <#[R6 + R11]> */
		/* 82246BD4h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82246BD4h case   11:*/		return 0x82246BD8;
		  /* 82246BD8h */ case   12:  		/* lwzx R8, <#[R9 + R11]> */
		/* 82246BD8h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82246BD8h case   12:*/		return 0x82246BDC;
		  /* 82246BDCh */ case   13:  		/* or R10, R8, R10 */
		/* 82246BDCh case   13:*/		cpu::op::or<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82246BDCh case   13:*/		return 0x82246BE0;
		  /* 82246BE0h */ case   14:  		/* stwx R10, <#[R9 + R11]> */
		/* 82246BE0h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82246BE0h case   14:*/		return 0x82246BE4;
		  /* 82246BE4h */ case   15:  		/* bc 12, CR6_LT, -216 */
		/* 82246BE4h case   15:*/		if ( regs.CR[6].lt ) { return 0x82246B0C;  }
		/* 82246BE4h case   15:*/		return 0x82246BE8;
		  /* 82246BE8h */ case   16:  		/* b 140 */
		/* 82246BE8h case   16:*/		return 0x82246C74;
		/* 82246BE8h case   16:*/		return 0x82246BEC;
	}
	return 0x82246BEC;
} // Block from 82246BA8h-82246BECh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82246BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246BEC);
		  /* 82246BECh */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 82246BECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82246BECh case    0:*/		return 0x82246BF0;
		  /* 82246BF0h */ case    1:  		/* cmpwi CR6, R31, 0 */
		/* 82246BF0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82246BF0h case    1:*/		return 0x82246BF4;
		  /* 82246BF4h */ case    2:  		/* stwx R22, <#[R26 + R11]> */
		/* 82246BF4h case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 82246BF4h case    2:*/		return 0x82246BF8;
		  /* 82246BF8h */ case    3:  		/* bc 4, CR6_GT, 124 */
		/* 82246BF8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82246C74;  }
		/* 82246BF8h case    3:*/		return 0x82246BFC;
		  /* 82246BFCh */ case    4:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82246BFCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82246BFCh case    4:*/		return 0x82246C00;
		  /* 82246C00h */ case    5:  		/* addi R11, R1, 144 */
		/* 82246C00h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 82246C00h case    5:*/		return 0x82246C04;
		  /* 82246C04h */ case    6:  		/* rlwinm R9, R22, 0, 27, 31 */
		/* 82246C04h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R22);
		/* 82246C04h case    6:*/		return 0x82246C08;
		  /* 82246C08h */ case    7:  		/* add R11, R10, R11 */
		/* 82246C08h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82246C08h case    7:*/		return 0x82246C0C;
		  /* 82246C0Ch */ case    8:  		/* li R10, 1 */
		/* 82246C0Ch case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82246C0Ch case    8:*/		return 0x82246C10;
		  /* 82246C10h */ case    9:  		/* rlwinm R29, R22, 29, 3, 29 */
		/* 82246C10h case    9:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R29,regs.R22);
		/* 82246C10h case    9:*/		return 0x82246C14;
		  /* 82246C14h */ case   10:  		/* slw R28, R10, R9 */
		/* 82246C14h case   10:*/		cpu::op::slw<0>(regs,&regs.R28,regs.R10,regs.R9);
		/* 82246C14h case   10:*/		return 0x82246C18;
		  /* 82246C18h */ case   11:  		/* lwz R27, <#[R11 - 4]> */
		/* 82246C18h case   11:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82246C18h case   11:*/		return 0x82246C1C;
		  /* 82246C1Ch */ case   12:  		/* li R30, 896 */
		/* 82246C1Ch case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x380);
		/* 82246C1Ch case   12:*/		return 0x82246C20;
		  /* 82246C20h */ case   13:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246C20h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246C20h case   13:*/		return 0x82246C24;
		  /* 82246C24h */ case   14:  		/* cmplw CR6, R22, R11 */
		/* 82246C24h case   14:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82246C24h case   14:*/		return 0x82246C28;
		  /* 82246C28h */ case   15:  		/* bc 4, CR6_LT, 16 */
		/* 82246C28h case   15:*/		if ( !regs.CR[6].lt ) { return 0x82246C38;  }
		/* 82246C28h case   15:*/		return 0x82246C2C;
		  /* 82246C2Ch */ case   16:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246C2Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246C2Ch case   16:*/		return 0x82246C30;
		  /* 82246C30h */ case   17:  		/* add R3, R11, R26 */
		/* 82246C30h case   17:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82246C30h case   17:*/		return 0x82246C34;
		  /* 82246C34h */ case   18:  		/* b 16 */
		/* 82246C34h case   18:*/		return 0x82246C44;
		/* 82246C34h case   18:*/		return 0x82246C38;
	}
	return 0x82246C38;
} // Block from 82246BECh-82246C38h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82246C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246C38);
		  /* 82246C38h */ case    0:  		/* mr R4, R22 */
		/* 82246C38h case    0:*/		regs.R4 = regs.R22;
		/* 82246C38h case    0:*/		return 0x82246C3C;
		  /* 82246C3Ch */ case    1:  		/* mr R3, R23 */
		/* 82246C3Ch case    1:*/		regs.R3 = regs.R23;
		/* 82246C3Ch case    1:*/		return 0x82246C40;
		  /* 82246C40h */ case    2:  		/* bl 52864 */
		/* 82246C40h case    2:*/		regs.LR = 0x82246C44; return 0x82253AC0;
		/* 82246C40h case    2:*/		return 0x82246C44;
	}
	return 0x82246C44;
} // Block from 82246C38h-82246C44h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246C44);
		  /* 82246C44h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246C44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246C44h case    0:*/		return 0x82246C48;
		  /* 82246C48h */ case    1:  		/* mr R3, R18 */
		/* 82246C48h case    1:*/		regs.R3 = regs.R18;
		/* 82246C48h case    1:*/		return 0x82246C4C;
		  /* 82246C4Ch */ case    2:  		/* ldx R4, <#[R11 + R30]> */
		/* 82246C4Ch case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82246C4Ch case    2:*/		return 0x82246C50;
		  /* 82246C50h */ case    3:  		/* bl -4288 */
		/* 82246C50h case    3:*/		regs.LR = 0x82246C54; return 0x82245B90;
		/* 82246C50h case    3:*/		return 0x82246C54;
		  /* 82246C54h */ case    4:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 82246C54h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 82246C54h case    4:*/		return 0x82246C58;
		  /* 82246C58h */ case    5:  		/* addic. R31, R31, -1 */
		/* 82246C58h case    5:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82246C58h case    5:*/		return 0x82246C5C;
		  /* 82246C5Ch */ case    6:  		/* addi R30, R30, 8 */
		/* 82246C5Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x8);
		/* 82246C5Ch case    6:*/		return 0x82246C60;
		  /* 82246C60h */ case    7:  		/* lwzx R11, <#[R11 + R27]> */
		/* 82246C60h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82246C60h case    7:*/		return 0x82246C64;
		  /* 82246C64h */ case    8:  		/* lwzx R10, <#[R29 + R11]> */
		/* 82246C64h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82246C64h case    8:*/		return 0x82246C68;
		  /* 82246C68h */ case    9:  		/* or R10, R28, R10 */
		/* 82246C68h case    9:*/		cpu::op::or<0>(regs,&regs.R10,regs.R28,regs.R10);
		/* 82246C68h case    9:*/		return 0x82246C6C;
		  /* 82246C6Ch */ case   10:  		/* stwx R10, <#[R29 + R11]> */
		/* 82246C6Ch case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82246C6Ch case   10:*/		return 0x82246C70;
		  /* 82246C70h */ case   11:  		/* bc 4, CR0_EQ, -80 */
		/* 82246C70h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82246C20;  }
		/* 82246C70h case   11:*/		return 0x82246C74;
	}
	return 0x82246C74;
} // Block from 82246C44h-82246C74h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82246C74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246C74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246C74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246C74);
		  /* 82246C74h */ case    0:  		/* lwz R6, <#[R23 + 4]> */
		/* 82246C74h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R23 + 0x00000004) );
		/* 82246C74h case    0:*/		return 0x82246C78;
		  /* 82246C78h */ case    1:  		/* addi R22, R22, 1 */
		/* 82246C78h case    1:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 82246C78h case    1:*/		return 0x82246C7C;
		  /* 82246C7Ch */ case    2:  		/* cmplw CR6, R22, R6 */
		/* 82246C7Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R6);
		/* 82246C7Ch case    2:*/		return 0x82246C80;
		  /* 82246C80h */ case    3:  		/* bc 12, CR6_LT, -2652 */
		/* 82246C80h case    3:*/		if ( regs.CR[6].lt ) { return 0x82246224;  }
		/* 82246C80h case    3:*/		return 0x82246C84;
	}
	return 0x82246C84;
} // Block from 82246C74h-82246C84h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82246C84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246C84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246C84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246C84);
		  /* 82246C84h */ case    0:  		/* mr R24, R15 */
		/* 82246C84h case    0:*/		regs.R24 = regs.R15;
		/* 82246C84h case    0:*/		return 0x82246C88;
		  /* 82246C88h */ case    1:  		/* cmplw CR6, R15, R6 */
		/* 82246C88h case    1:*/		cpu::op::cmplw<6>(regs,regs.R15,regs.R6);
		/* 82246C88h case    1:*/		return 0x82246C8C;
		  /* 82246C8Ch */ case    2:  		/* bc 4, CR6_LT, 524 */
		/* 82246C8Ch case    2:*/		if ( !regs.CR[6].lt ) { return 0x82246E98;  }
		/* 82246C8Ch case    2:*/		return 0x82246C90;
		  /* 82246C90h */ case    3:  		/* lwz R10, <#[R1 + 92]> */
		/* 82246C90h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82246C90h case    3:*/		return 0x82246C94;
		  /* 82246C94h */ case    4:  		/* rlwinm R11, R15, 2, 0, 29 */
		/* 82246C94h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R15);
		/* 82246C94h case    4:*/		return 0x82246C98;
		  /* 82246C98h */ case    5:  		/* lwz R9, <#[R1 + 84]> */
		/* 82246C98h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82246C98h case    5:*/		return 0x82246C9C;
		  /* 82246C9Ch */ case    6:  		/* add R19, R11, R10 */
		/* 82246C9Ch case    6:*/		cpu::op::add<0>(regs,&regs.R19,regs.R11,regs.R10);
		/* 82246C9Ch case    6:*/		return 0x82246CA0;
		  /* 82246CA0h */ case    7:  		/* subf R18, R10, R9 */
		/* 82246CA0h case    7:*/		cpu::op::subf<0>(regs,&regs.R18,regs.R10,regs.R9);
		/* 82246CA0h case    7:*/		return 0x82246CA4;
		  /* 82246CA4h */ case    8:  		/* lwz R11, <#[R19]> */
		/* 82246CA4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82246CA4h case    8:*/		return 0x82246CA8;
		  /* 82246CA8h */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 82246CA8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82246CA8h case    9:*/		return 0x82246CAC;
		  /* 82246CACh */ case   10:  		/* bc 4, CR6_GT, 476 */
		/* 82246CACh case   10:*/		if ( !regs.CR[6].gt ) { return 0x82246E88;  }
		/* 82246CACh case   10:*/		return 0x82246CB0;
		  /* 82246CB0h */ case   11:  		/* lwzx R10, <#[R18 + R19]> */
		/* 82246CB0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + regs.R19 + 0x00000000) );
		/* 82246CB0h case   11:*/		return 0x82246CB4;
		  /* 82246CB4h */ case   12:  		/* cmplw CR6, R10, R24 */
		/* 82246CB4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 82246CB4h case   12:*/		return 0x82246CB8;
		  /* 82246CB8h */ case   13:  		/* bc 4, CR6_EQ, 464 */
		/* 82246CB8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82246E88;  }
		/* 82246CB8h case   13:*/		return 0x82246CBC;
		  /* 82246CBCh */ case   14:  		/* cmpwi CR6, R11, 1 */
		/* 82246CBCh case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82246CBCh case   14:*/		return 0x82246CC0;
		  /* 82246CC0h */ case   15:  		/* bc 4, CR6_EQ, 12 */
		/* 82246CC0h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82246CCC;  }
		/* 82246CC0h case   15:*/		return 0x82246CC4;
		  /* 82246CC4h */ case   16:  		/* mr R30, R14 */
		/* 82246CC4h case   16:*/		regs.R30 = regs.R14;
		/* 82246CC4h case   16:*/		return 0x82246CC8;
		  /* 82246CC8h */ case   17:  		/* b 20 */
		/* 82246CC8h case   17:*/		return 0x82246CDC;
		/* 82246CC8h case   17:*/		return 0x82246CCC;
	}
	return 0x82246CCC;
} // Block from 82246C84h-82246CCCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 82246CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246CCC);
		  /* 82246CCCh */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 82246CCCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 82246CCCh case    0:*/		return 0x82246CD0;
		  /* 82246CD0h */ case    1:  		/* mr R30, R16 */
		/* 82246CD0h case    1:*/		regs.R30 = regs.R16;
		/* 82246CD0h case    1:*/		return 0x82246CD4;
		  /* 82246CD4h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 82246CD4h case    2:*/		if ( regs.CR[6].eq ) { return 0x82246CDC;  }
		/* 82246CD4h case    2:*/		return 0x82246CD8;
		  /* 82246CD8h */ case    3:  		/* mr R30, R15 */
		/* 82246CD8h case    3:*/		regs.R30 = regs.R15;
		/* 82246CD8h case    3:*/		return 0x82246CDC;
	}
	return 0x82246CDC;
} // Block from 82246CCCh-82246CDCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82246CDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246CDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246CDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246CDC);
		  /* 82246CDCh */ case    0:  		/* cmplw CR6, R30, R6 */
		/* 82246CDCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R6);
		/* 82246CDCh case    0:*/		return 0x82246CE0;
		  /* 82246CE0h */ case    1:  		/* bc 4, CR6_LT, 424 */
		/* 82246CE0h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82246E88;  }
		/* 82246CE0h case    1:*/		return 0x82246CE4;
		  /* 82246CE4h */ case    2:  		/* lwz R10, <#[R1 + 128]> */
		/* 82246CE4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 82246CE4h case    2:*/		return 0x82246CE8;
		  /* 82246CE8h */ case    3:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 82246CE8h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 82246CE8h case    3:*/		return 0x82246CEC;
		  /* 82246CECh */ case    4:  		/* lwz R9, <#[R1 + 84]> */
		/* 82246CECh case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82246CECh case    4:*/		return 0x82246CF0;
		  /* 82246CF0h */ case    5:  		/* rlwinm R21, R24, 2, 0, 29 */
		/* 82246CF0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R21,regs.R24);
		/* 82246CF0h case    5:*/		return 0x82246CF4;
		  /* 82246CF4h */ case    6:  		/* add R22, R11, R10 */
		/* 82246CF4h case    6:*/		cpu::op::add<0>(regs,&regs.R22,regs.R11,regs.R10);
		/* 82246CF4h case    6:*/		return 0x82246CF8;
		  /* 82246CF8h */ case    7:  		/* subf R20, R10, R9 */
		/* 82246CF8h case    7:*/		cpu::op::subf<0>(regs,&regs.R20,regs.R10,regs.R9);
		/* 82246CF8h case    7:*/		return 0x82246CFC;
		  /* 82246CFCh */ case    8:  		/* cmplw CR6, R30, R24 */
		/* 82246CFCh case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R24);
		/* 82246CFCh case    8:*/		return 0x82246D00;
		  /* 82246D00h */ case    9:  		/* bc 4, CR6_GT, 372 */
		/* 82246D00h case    9:*/		if ( !regs.CR[6].gt ) { return 0x82246E74;  }
		/* 82246D00h case    9:*/		return 0x82246D04;
		  /* 82246D04h */ case   10:  		/* lwzx R11, <#[R20 + R22]> */
		/* 82246D04h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + regs.R22 + 0x00000000) );
		/* 82246D04h case   10:*/		return 0x82246D08;
		  /* 82246D08h */ case   11:  		/* cmplw CR6, R11, R30 */
		/* 82246D08h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 82246D08h case   11:*/		return 0x82246D0C;
		  /* 82246D0Ch */ case   12:  		/* bc 4, CR6_EQ, 360 */
		/* 82246D0Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x82246E74;  }
		/* 82246D0Ch case   12:*/		return 0x82246D10;
		  /* 82246D10h */ case   13:  		/* lwz R11, <#[R19]> */
		/* 82246D10h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82246D10h case   13:*/		return 0x82246D14;
		  /* 82246D14h */ case   14:  		/* lwz R10, <#[R22]> */
		/* 82246D14h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000000) );
		/* 82246D14h case   14:*/		return 0x82246D18;
		  /* 82246D18h */ case   15:  		/* cmpw CR6, R11, R10 */
		/* 82246D18h case   15:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82246D18h case   15:*/		return 0x82246D1C;
		  /* 82246D1Ch */ case   16:  		/* bc 12, CR6_LT, 344 */
		/* 82246D1Ch case   16:*/		if ( regs.CR[6].lt ) { return 0x82246E74;  }
		/* 82246D1Ch case   16:*/		return 0x82246D20;
		  /* 82246D20h */ case   17:  		/* stwx R24, <#[R20 + R22]> */
		/* 82246D20h case   17:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R20 + regs.R22 + 0x00000000) );
		/* 82246D20h case   17:*/		return 0x82246D24;
		  /* 82246D24h */ case   18:  		/* lwz R11, <#[R19]> */
		/* 82246D24h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82246D24h case   18:*/		return 0x82246D28;
		  /* 82246D28h */ case   19:  		/* subfic R11, R11, 4 */
		/* 82246D28h case   19:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82246D28h case   19:*/		return 0x82246D2C;
		  /* 82246D2Ch */ case   20:  		/* cmpwi CR6, R11, 4 */
		/* 82246D2Ch case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 82246D2Ch case   20:*/		return 0x82246D30;
		  /* 82246D30h */ case   21:  		/* bc 4, CR6_LT, 308 */
		/* 82246D30h case   21:*/		if ( !regs.CR[6].lt ) { return 0x82246E64;  }
		/* 82246D30h case   21:*/		return 0x82246D34;
		  /* 82246D34h */ case   22:  		/* addi R10, R11, 232 */
		/* 82246D34h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xE8);
		/* 82246D34h case   22:*/		return 0x82246D38;
		  /* 82246D38h */ case   23:  		/* addi R11, R11, 112 */
		/* 82246D38h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x70);
		/* 82246D38h case   23:*/		return 0x82246D3C;
		  /* 82246D3Ch */ case   24:  		/* rlwinm R25, R30, 2, 0, 29 */
		/* 82246D3Ch case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R25,regs.R30);
		/* 82246D3Ch case   24:*/		return 0x82246D40;
		  /* 82246D40h */ case   25:  		/* rlwinm R27, R10, 2, 0, 29 */
		/* 82246D40h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R10);
		/* 82246D40h case   25:*/		return 0x82246D44;
		  /* 82246D44h */ case   26:  		/* li R26, 928 */
		/* 82246D44h case   26:*/		cpu::op::li<0>(regs,&regs.R26,0x3A0);
		/* 82246D44h case   26:*/		return 0x82246D48;
		  /* 82246D48h */ case   27:  		/* rlwinm R28, R11, 3, 0, 28 */
		/* 82246D48h case   27:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R28,regs.R11);
		/* 82246D48h case   27:*/		return 0x82246D4C;
		  /* 82246D4Ch */ case   28:  		/* li R29, 896 */
		/* 82246D4Ch case   28:*/		cpu::op::li<0>(regs,&regs.R29,0x380);
		/* 82246D4Ch case   28:*/		return 0x82246D50;
		  /* 82246D50h */ case   29:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246D50h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246D50h case   29:*/		return 0x82246D54;
		  /* 82246D54h */ case   30:  		/* cmplw CR6, R24, R11 */
		/* 82246D54h case   30:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 82246D54h case   30:*/		return 0x82246D58;
		  /* 82246D58h */ case   31:  		/* bc 4, CR6_LT, 16 */
		/* 82246D58h case   31:*/		if ( !regs.CR[6].lt ) { return 0x82246D68;  }
		/* 82246D58h case   31:*/		return 0x82246D5C;
		  /* 82246D5Ch */ case   32:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246D5Ch case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246D5Ch case   32:*/		return 0x82246D60;
		  /* 82246D60h */ case   33:  		/* add R3, R11, R21 */
		/* 82246D60h case   33:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R21);
		/* 82246D60h case   33:*/		return 0x82246D64;
		  /* 82246D64h */ case   34:  		/* b 16 */
		/* 82246D64h case   34:*/		return 0x82246D74;
		/* 82246D64h case   34:*/		return 0x82246D68;
	}
	return 0x82246D68;
} // Block from 82246CDCh-82246D68h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82246D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246D68);
		  /* 82246D68h */ case    0:  		/* mr R4, R24 */
		/* 82246D68h case    0:*/		regs.R4 = regs.R24;
		/* 82246D68h case    0:*/		return 0x82246D6C;
		  /* 82246D6Ch */ case    1:  		/* mr R3, R23 */
		/* 82246D6Ch case    1:*/		regs.R3 = regs.R23;
		/* 82246D6Ch case    1:*/		return 0x82246D70;
		  /* 82246D70h */ case    2:  		/* bl 52560 */
		/* 82246D70h case    2:*/		regs.LR = 0x82246D74; return 0x82253AC0;
		/* 82246D70h case    2:*/		return 0x82246D74;
	}
	return 0x82246D74;
} // Block from 82246D68h-82246D74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246D74);
		  /* 82246D74h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246D74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246D74h case    0:*/		return 0x82246D78;
		  /* 82246D78h */ case    1:  		/* lwzx R11, <#[R27 + R11]> */
		/* 82246D78h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 82246D78h case    1:*/		return 0x82246D7C;
		  /* 82246D7Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82246D7Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82246D7Ch case    2:*/		return 0x82246D80;
		  /* 82246D80h */ case    3:  		/* bc 4, CR6_EQ, 212 */
		/* 82246D80h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82246E54;  }
		/* 82246D80h case    3:*/		return 0x82246D84;
		  /* 82246D84h */ case    4:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246D84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246D84h case    4:*/		return 0x82246D88;
		  /* 82246D88h */ case    5:  		/* cmplw CR6, R30, R11 */
		/* 82246D88h case    5:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82246D88h case    5:*/		return 0x82246D8C;
		  /* 82246D8Ch */ case    6:  		/* bc 4, CR6_LT, 16 */
		/* 82246D8Ch case    6:*/		if ( !regs.CR[6].lt ) { return 0x82246D9C;  }
		/* 82246D8Ch case    6:*/		return 0x82246D90;
		  /* 82246D90h */ case    7:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246D90h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246D90h case    7:*/		return 0x82246D94;
		  /* 82246D94h */ case    8:  		/* add R31, R11, R25 */
		/* 82246D94h case    8:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R25);
		/* 82246D94h case    8:*/		return 0x82246D98;
		  /* 82246D98h */ case    9:  		/* b 20 */
		/* 82246D98h case    9:*/		return 0x82246DAC;
		/* 82246D98h case    9:*/		return 0x82246D9C;
	}
	return 0x82246D9C;
} // Block from 82246D74h-82246D9Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82246D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246D9C);
		  /* 82246D9Ch */ case    0:  		/* mr R4, R30 */
		/* 82246D9Ch case    0:*/		regs.R4 = regs.R30;
		/* 82246D9Ch case    0:*/		return 0x82246DA0;
		  /* 82246DA0h */ case    1:  		/* mr R3, R23 */
		/* 82246DA0h case    1:*/		regs.R3 = regs.R23;
		/* 82246DA0h case    1:*/		return 0x82246DA4;
		  /* 82246DA4h */ case    2:  		/* bl 52508 */
		/* 82246DA4h case    2:*/		regs.LR = 0x82246DA8; return 0x82253AC0;
		/* 82246DA4h case    2:*/		return 0x82246DA8;
		  /* 82246DA8h */ case    3:  		/* mr R31, R3 */
		/* 82246DA8h case    3:*/		regs.R31 = regs.R3;
		/* 82246DA8h case    3:*/		return 0x82246DAC;
	}
	return 0x82246DAC;
} // Block from 82246D9Ch-82246DACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82246DACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246DAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246DAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246DAC);
		  /* 82246DACh */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246DACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246DACh case    0:*/		return 0x82246DB0;
		  /* 82246DB0h */ case    1:  		/* cmplw CR6, R24, R11 */
		/* 82246DB0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 82246DB0h case    1:*/		return 0x82246DB4;
		  /* 82246DB4h */ case    2:  		/* bc 4, CR6_LT, 16 */
		/* 82246DB4h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82246DC4;  }
		/* 82246DB4h case    2:*/		return 0x82246DB8;
		  /* 82246DB8h */ case    3:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246DB8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246DB8h case    3:*/		return 0x82246DBC;
		  /* 82246DBCh */ case    4:  		/* add R3, R11, R21 */
		/* 82246DBCh case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R21);
		/* 82246DBCh case    4:*/		return 0x82246DC0;
		  /* 82246DC0h */ case    5:  		/* b 16 */
		/* 82246DC0h case    5:*/		return 0x82246DD0;
		/* 82246DC0h case    5:*/		return 0x82246DC4;
	}
	return 0x82246DC4;
} // Block from 82246DACh-82246DC4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82246DC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246DC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246DC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246DC4);
		  /* 82246DC4h */ case    0:  		/* mr R4, R24 */
		/* 82246DC4h case    0:*/		regs.R4 = regs.R24;
		/* 82246DC4h case    0:*/		return 0x82246DC8;
		  /* 82246DC8h */ case    1:  		/* mr R3, R23 */
		/* 82246DC8h case    1:*/		regs.R3 = regs.R23;
		/* 82246DC8h case    1:*/		return 0x82246DCC;
		  /* 82246DCCh */ case    2:  		/* bl 52468 */
		/* 82246DCCh case    2:*/		regs.LR = 0x82246DD0; return 0x82253AC0;
		/* 82246DCCh case    2:*/		return 0x82246DD0;
	}
	return 0x82246DD0;
} // Block from 82246DC4h-82246DD0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246DD0);
		  /* 82246DD0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82246DD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82246DD0h case    0:*/		return 0x82246DD4;
		  /* 82246DD4h */ case    1:  		/* lwz R10, <#[R3]> */
		/* 82246DD4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82246DD4h case    1:*/		return 0x82246DD8;
		  /* 82246DD8h */ case    2:  		/* add R11, R29, R11 */
		/* 82246DD8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82246DD8h case    2:*/		return 0x82246DDC;
		  /* 82246DDCh */ case    3:  		/* add R10, R28, R10 */
		/* 82246DDCh case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R28,regs.R10);
		/* 82246DDCh case    3:*/		return 0x82246DE0;
		  /* 82246DE0h */ case    4:  		/* lwz R9, <#[R11]> */
		/* 82246DE0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82246DE0h case    4:*/		return 0x82246DE4;
		  /* 82246DE4h */ case    5:  		/* stw R9, <#[R10]> */
		/* 82246DE4h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82246DE4h case    5:*/		return 0x82246DE8;
		  /* 82246DE8h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 82246DE8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82246DE8h case    6:*/		return 0x82246DEC;
		  /* 82246DECh */ case    7:  		/* stw R11, <#[R10 + 4]> */
		/* 82246DECh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82246DECh case    7:*/		return 0x82246DF0;
		  /* 82246DF0h */ case    8:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246DF0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246DF0h case    8:*/		return 0x82246DF4;
		  /* 82246DF4h */ case    9:  		/* cmplw CR6, R30, R11 */
		/* 82246DF4h case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82246DF4h case    9:*/		return 0x82246DF8;
		  /* 82246DF8h */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 82246DF8h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82246E08;  }
		/* 82246DF8h case   10:*/		return 0x82246DFC;
		  /* 82246DFCh */ case   11:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246DFCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246DFCh case   11:*/		return 0x82246E00;
		  /* 82246E00h */ case   12:  		/* add R31, R11, R25 */
		/* 82246E00h case   12:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R25);
		/* 82246E00h case   12:*/		return 0x82246E04;
		  /* 82246E04h */ case   13:  		/* b 20 */
		/* 82246E04h case   13:*/		return 0x82246E18;
		/* 82246E04h case   13:*/		return 0x82246E08;
	}
	return 0x82246E08;
} // Block from 82246DD0h-82246E08h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82246E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246E08);
		  /* 82246E08h */ case    0:  		/* mr R4, R30 */
		/* 82246E08h case    0:*/		regs.R4 = regs.R30;
		/* 82246E08h case    0:*/		return 0x82246E0C;
		  /* 82246E0Ch */ case    1:  		/* mr R3, R23 */
		/* 82246E0Ch case    1:*/		regs.R3 = regs.R23;
		/* 82246E0Ch case    1:*/		return 0x82246E10;
		  /* 82246E10h */ case    2:  		/* bl 52400 */
		/* 82246E10h case    2:*/		regs.LR = 0x82246E14; return 0x82253AC0;
		/* 82246E10h case    2:*/		return 0x82246E14;
		  /* 82246E14h */ case    3:  		/* mr R31, R3 */
		/* 82246E14h case    3:*/		regs.R31 = regs.R3;
		/* 82246E14h case    3:*/		return 0x82246E18;
	}
	return 0x82246E18;
} // Block from 82246E08h-82246E18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82246E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246E18);
		  /* 82246E18h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246E18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246E18h case    0:*/		return 0x82246E1C;
		  /* 82246E1Ch */ case    1:  		/* cmplw CR6, R24, R11 */
		/* 82246E1Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 82246E1Ch case    1:*/		return 0x82246E20;
		  /* 82246E20h */ case    2:  		/* bc 4, CR6_LT, 16 */
		/* 82246E20h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82246E30;  }
		/* 82246E20h case    2:*/		return 0x82246E24;
		  /* 82246E24h */ case    3:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246E24h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246E24h case    3:*/		return 0x82246E28;
		  /* 82246E28h */ case    4:  		/* add R3, R11, R21 */
		/* 82246E28h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R21);
		/* 82246E28h case    4:*/		return 0x82246E2C;
		  /* 82246E2Ch */ case    5:  		/* b 16 */
		/* 82246E2Ch case    5:*/		return 0x82246E3C;
		/* 82246E2Ch case    5:*/		return 0x82246E30;
	}
	return 0x82246E30;
} // Block from 82246E18h-82246E30h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82246E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246E30);
		  /* 82246E30h */ case    0:  		/* mr R4, R24 */
		/* 82246E30h case    0:*/		regs.R4 = regs.R24;
		/* 82246E30h case    0:*/		return 0x82246E34;
		  /* 82246E34h */ case    1:  		/* mr R3, R23 */
		/* 82246E34h case    1:*/		regs.R3 = regs.R23;
		/* 82246E34h case    1:*/		return 0x82246E38;
		  /* 82246E38h */ case    2:  		/* bl 52360 */
		/* 82246E38h case    2:*/		regs.LR = 0x82246E3C; return 0x82253AC0;
		/* 82246E38h case    2:*/		return 0x82246E3C;
	}
	return 0x82246E3C;
} // Block from 82246E30h-82246E3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246E3C);
		  /* 82246E3Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82246E3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82246E3Ch case    0:*/		return 0x82246E40;
		  /* 82246E40h */ case    1:  		/* addi R29, R29, 8 */
		/* 82246E40h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x8);
		/* 82246E40h case    1:*/		return 0x82246E44;
		  /* 82246E44h */ case    2:  		/* lwz R10, <#[R3]> */
		/* 82246E44h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82246E44h case    2:*/		return 0x82246E48;
		  /* 82246E48h */ case    3:  		/* lwzx R11, <#[R11 + R26]> */
		/* 82246E48h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82246E48h case    3:*/		return 0x82246E4C;
		  /* 82246E4Ch */ case    4:  		/* addi R26, R26, 4 */
		/* 82246E4Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 82246E4Ch case    4:*/		return 0x82246E50;
		  /* 82246E50h */ case    5:  		/* stwx R11, <#[R10 + R27]> */
		/* 82246E50h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 82246E50h case    5:*/		return 0x82246E54;
	}
	return 0x82246E54;
} // Block from 82246E3Ch-82246E54h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82246E54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246E54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246E54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246E54);
		  /* 82246E54h */ case    0:  		/* addi R28, R28, 8 */
		/* 82246E54h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 82246E54h case    0:*/		return 0x82246E58;
		  /* 82246E58h */ case    1:  		/* addi R27, R27, 4 */
		/* 82246E58h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 82246E58h case    1:*/		return 0x82246E5C;
		  /* 82246E5Ch */ case    2:  		/* cmpwi CR6, R28, 928 */
		/* 82246E5Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x000003A0);
		/* 82246E5Ch case    2:*/		return 0x82246E60;
		  /* 82246E60h */ case    3:  		/* bc 12, CR6_LT, -272 */
		/* 82246E60h case    3:*/		if ( regs.CR[6].lt ) { return 0x82246D50;  }
		/* 82246E60h case    3:*/		return 0x82246E64;
	}
	return 0x82246E64;
} // Block from 82246E54h-82246E64h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82246E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246E64);
		  /* 82246E64h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 82246E64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82246E64h case    0:*/		return 0x82246E68;
		  /* 82246E68h */ case    1:  		/* lwz R10, <#[R22]> */
		/* 82246E68h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000000) );
		/* 82246E68h case    1:*/		return 0x82246E6C;
		  /* 82246E6Ch */ case    2:  		/* subf R11, R10, R11 */
		/* 82246E6Ch case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82246E6Ch case    2:*/		return 0x82246E70;
		  /* 82246E70h */ case    3:  		/* stw R11, <#[R19]> */
		/* 82246E70h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82246E70h case    3:*/		return 0x82246E74;
	}
	return 0x82246E74;
} // Block from 82246E64h-82246E74h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82246E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246E74);
		  /* 82246E74h */ case    0:  		/* lwz R6, <#[R23 + 4]> */
		/* 82246E74h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R23 + 0x00000004) );
		/* 82246E74h case    0:*/		return 0x82246E78;
		  /* 82246E78h */ case    1:  		/* addi R30, R30, 1 */
		/* 82246E78h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82246E78h case    1:*/		return 0x82246E7C;
		  /* 82246E7Ch */ case    2:  		/* addi R22, R22, 4 */
		/* 82246E7Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x4);
		/* 82246E7Ch case    2:*/		return 0x82246E80;
		  /* 82246E80h */ case    3:  		/* cmplw CR6, R30, R6 */
		/* 82246E80h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R6);
		/* 82246E80h case    3:*/		return 0x82246E84;
		  /* 82246E84h */ case    4:  		/* bc 12, CR6_LT, -392 */
		/* 82246E84h case    4:*/		if ( regs.CR[6].lt ) { return 0x82246CFC;  }
		/* 82246E84h case    4:*/		return 0x82246E88;
	}
	return 0x82246E88;
} // Block from 82246E74h-82246E88h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82246E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246E88);
		  /* 82246E88h */ case    0:  		/* addi R24, R24, 1 */
		/* 82246E88h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 82246E88h case    0:*/		return 0x82246E8C;
		  /* 82246E8Ch */ case    1:  		/* addi R19, R19, 4 */
		/* 82246E8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x4);
		/* 82246E8Ch case    1:*/		return 0x82246E90;
		  /* 82246E90h */ case    2:  		/* cmplw CR6, R24, R6 */
		/* 82246E90h case    2:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R6);
		/* 82246E90h case    2:*/		return 0x82246E94;
		  /* 82246E94h */ case    3:  		/* bc 12, CR6_LT, -496 */
		/* 82246E94h case    3:*/		if ( regs.CR[6].lt ) { return 0x82246CA4;  }
		/* 82246E94h case    3:*/		return 0x82246E98;
	}
	return 0x82246E98;
} // Block from 82246E88h-82246E98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82246E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246E98);
		  /* 82246E98h */ case    0:  		/* li R26, 0 */
		/* 82246E98h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82246E98h case    0:*/		return 0x82246E9C;
		  /* 82246E9Ch */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 82246E9Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82246E9Ch case    1:*/		return 0x82246EA0;
		  /* 82246EA0h */ case    2:  		/* bc 12, CR6_EQ, 720 */
		/* 82246EA0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82247170;  }
		/* 82246EA0h case    2:*/		return 0x82246EA4;
		  /* 82246EA4h */ case    3:  		/* lis R7, -32256 */
		/* 82246EA4h case    3:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8200);
		/* 82246EA4h case    3:*/		return 0x82246EA8;
		  /* 82246EA8h */ case    4:  		/* lis R8, -32252 */
		/* 82246EA8h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 82246EA8h case    4:*/		return 0x82246EAC;
		  /* 82246EACh */ case    5:  		/* lis R9, -32252 */
		/* 82246EACh case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82246EACh case    5:*/		return 0x82246EB0;
		  /* 82246EB0h */ case    6:  		/* lis R10, -32252 */
		/* 82246EB0h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82246EB0h case    6:*/		return 0x82246EB4;
		  /* 82246EB4h */ case    7:  		/* lis R11, -32252 */
		/* 82246EB4h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82246EB4h case    7:*/		return 0x82246EB8;
		  /* 82246EB8h */ case    8:  		/* li R25, 0 */
		/* 82246EB8h case    8:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82246EB8h case    8:*/		return 0x82246EBC;
		  /* 82246EBCh */ case    9:  		/* li R18, 11 */
		/* 82246EBCh case    9:*/		cpu::op::li<0>(regs,&regs.R18,0xB);
		/* 82246EBCh case    9:*/		return 0x82246EC0;
		  /* 82246EC0h */ case   10:  		/* addi R20, R7, 17768 */
		/* 82246EC0h case   10:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R7,0x4568);
		/* 82246EC0h case   10:*/		return 0x82246EC4;
		  /* 82246EC4h */ case   11:  		/* addi R24, R8, 12784 */
		/* 82246EC4h case   11:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R8,0x31F0);
		/* 82246EC4h case   11:*/		return 0x82246EC8;
		  /* 82246EC8h */ case   12:  		/* addi R21, R9, 12752 */
		/* 82246EC8h case   12:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R9,0x31D0);
		/* 82246EC8h case   12:*/		return 0x82246ECC;
		  /* 82246ECCh */ case   13:  		/* addi R19, R10, 12744 */
		/* 82246ECCh case   13:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R10,0x31C8);
		/* 82246ECCh case   13:*/		return 0x82246ED0;
		  /* 82246ED0h */ case   14:  		/* addi R22, R11, 12732 */
		/* 82246ED0h case   14:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R11,0x31BC);
		/* 82246ED0h case   14:*/		return 0x82246ED4;
		  /* 82246ED4h */ case   15:  		/* cmplw CR6, R26, R6 */
		/* 82246ED4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R6);
		/* 82246ED4h case   15:*/		return 0x82246ED8;
		  /* 82246ED8h */ case   16:  		/* bc 4, CR6_LT, 16 */
		/* 82246ED8h case   16:*/		if ( !regs.CR[6].lt ) { return 0x82246EE8;  }
		/* 82246ED8h case   16:*/		return 0x82246EDC;
		  /* 82246EDCh */ case   17:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246EDCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246EDCh case   17:*/		return 0x82246EE0;
		  /* 82246EE0h */ case   18:  		/* add R3, R11, R25 */
		/* 82246EE0h case   18:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 82246EE0h case   18:*/		return 0x82246EE4;
		  /* 82246EE4h */ case   19:  		/* b 16 */
		/* 82246EE4h case   19:*/		return 0x82246EF4;
		/* 82246EE4h case   19:*/		return 0x82246EE8;
	}
	return 0x82246EE8;
} // Block from 82246E98h-82246EE8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82246EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246EE8);
		  /* 82246EE8h */ case    0:  		/* mr R4, R26 */
		/* 82246EE8h case    0:*/		regs.R4 = regs.R26;
		/* 82246EE8h case    0:*/		return 0x82246EEC;
		  /* 82246EECh */ case    1:  		/* mr R3, R23 */
		/* 82246EECh case    1:*/		regs.R3 = regs.R23;
		/* 82246EECh case    1:*/		return 0x82246EF0;
		  /* 82246EF0h */ case    2:  		/* bl 52176 */
		/* 82246EF0h case    2:*/		regs.LR = 0x82246EF4; return 0x82253AC0;
		/* 82246EF0h case    2:*/		return 0x82246EF4;
	}
	return 0x82246EF4;
} // Block from 82246EE8h-82246EF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246EF4);
		  /* 82246EF4h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246EF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246EF4h case    0:*/		return 0x82246EF8;
		  /* 82246EF8h */ case    1:  		/* mr R4, R22 */
		/* 82246EF8h case    1:*/		regs.R4 = regs.R22;
		/* 82246EF8h case    1:*/		return 0x82246EFC;
		  /* 82246EFCh */ case    2:  		/* mr R6, R26 */
		/* 82246EFCh case    2:*/		regs.R6 = regs.R26;
		/* 82246EFCh case    2:*/		return 0x82246F00;
		  /* 82246F00h */ case    3:  		/* lwz R3, <#[R17]> */
		/* 82246F00h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 82246F00h case    3:*/		return 0x82246F04;
		  /* 82246F04h */ case    4:  		/* lwz R5, <#[R11 + 224]> */
		/* 82246F04h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x000000E0) );
		/* 82246F04h case    4:*/		return 0x82246F08;
		  /* 82246F08h */ case    5:  		/* bl -170824 */
		/* 82246F08h case    5:*/		regs.LR = 0x82246F0C; return 0x8221D3C0;
		/* 82246F08h case    5:*/		return 0x82246F0C;
		  /* 82246F0Ch */ case    6:  		/* li R29, 928 */
		/* 82246F0Ch case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x3A0);
		/* 82246F0Ch case    6:*/		return 0x82246F10;
		  /* 82246F10h */ case    7:  		/* li R31, 896 */
		/* 82246F10h case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x380);
		/* 82246F10h case    7:*/		return 0x82246F14;
		  /* 82246F14h */ case    8:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246F14h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246F14h case    8:*/		return 0x82246F18;
		  /* 82246F18h */ case    9:  		/* cmplw CR6, R26, R11 */
		/* 82246F18h case    9:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82246F18h case    9:*/		return 0x82246F1C;
		  /* 82246F1Ch */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 82246F1Ch case   10:*/		if ( !regs.CR[6].lt ) { return 0x82246F2C;  }
		/* 82246F1Ch case   10:*/		return 0x82246F20;
		  /* 82246F20h */ case   11:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246F20h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246F20h case   11:*/		return 0x82246F24;
		  /* 82246F24h */ case   12:  		/* add R3, R11, R25 */
		/* 82246F24h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 82246F24h case   12:*/		return 0x82246F28;
		  /* 82246F28h */ case   13:  		/* b 16 */
		/* 82246F28h case   13:*/		return 0x82246F38;
		/* 82246F28h case   13:*/		return 0x82246F2C;
	}
	return 0x82246F2C;
} // Block from 82246EF4h-82246F2Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 82246F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246F2C);
		  /* 82246F2Ch */ case    0:  		/* mr R4, R26 */
		/* 82246F2Ch case    0:*/		regs.R4 = regs.R26;
		/* 82246F2Ch case    0:*/		return 0x82246F30;
		  /* 82246F30h */ case    1:  		/* mr R3, R23 */
		/* 82246F30h case    1:*/		regs.R3 = regs.R23;
		/* 82246F30h case    1:*/		return 0x82246F34;
		  /* 82246F34h */ case    2:  		/* bl 52108 */
		/* 82246F34h case    2:*/		regs.LR = 0x82246F38; return 0x82253AC0;
		/* 82246F34h case    2:*/		return 0x82246F38;
	}
	return 0x82246F38;
} // Block from 82246F2Ch-82246F38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246F38);
		  /* 82246F38h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246F38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246F38h case    0:*/		return 0x82246F3C;
		  /* 82246F3Ch */ case    1:  		/* lwz R10, <#[R23 + 4]> */
		/* 82246F3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000004) );
		/* 82246F3Ch case    1:*/		return 0x82246F40;
		  /* 82246F40h */ case    2:  		/* cmplw CR6, R26, R10 */
		/* 82246F40h case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 82246F40h case    2:*/		return 0x82246F44;
		  /* 82246F44h */ case    3:  		/* ldx R30, <#[R31 + R11]> */
		/* 82246F44h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82246F44h case    3:*/		return 0x82246F48;
		  /* 82246F48h */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 82246F48h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82246F58;  }
		/* 82246F48h case    4:*/		return 0x82246F4C;
		  /* 82246F4Ch */ case    5:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246F4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246F4Ch case    5:*/		return 0x82246F50;
		  /* 82246F50h */ case    6:  		/* add R3, R11, R25 */
		/* 82246F50h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 82246F50h case    6:*/		return 0x82246F54;
		  /* 82246F54h */ case    7:  		/* b 16 */
		/* 82246F54h case    7:*/		return 0x82246F64;
		/* 82246F54h case    7:*/		return 0x82246F58;
	}
	return 0x82246F58;
} // Block from 82246F38h-82246F58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82246F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246F58);
		  /* 82246F58h */ case    0:  		/* mr R4, R26 */
		/* 82246F58h case    0:*/		regs.R4 = regs.R26;
		/* 82246F58h case    0:*/		return 0x82246F5C;
		  /* 82246F5Ch */ case    1:  		/* mr R3, R23 */
		/* 82246F5Ch case    1:*/		regs.R3 = regs.R23;
		/* 82246F5Ch case    1:*/		return 0x82246F60;
		  /* 82246F60h */ case    2:  		/* bl 52064 */
		/* 82246F60h case    2:*/		regs.LR = 0x82246F64; return 0x82253AC0;
		/* 82246F60h case    2:*/		return 0x82246F64;
	}
	return 0x82246F64;
} // Block from 82246F58h-82246F64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82246F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246F64);
		  /* 82246F64h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82246F64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82246F64h case    0:*/		return 0x82246F68;
		  /* 82246F68h */ case    1:  		/* lwzx R11, <#[R29 + R11]> */
		/* 82246F68h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82246F68h case    1:*/		return 0x82246F6C;
		  /* 82246F6Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82246F6Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82246F6Ch case    2:*/		return 0x82246F70;
		  /* 82246F70h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 82246F70h case    3:*/		if ( regs.CR[6].eq ) { return 0x82246FA0;  }
		/* 82246F70h case    3:*/		return 0x82246F74;
		  /* 82246F74h */ case    4:  		/* addi R4, R1, 160 */
		/* 82246F74h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xA0);
		/* 82246F74h case    4:*/		return 0x82246F78;
		  /* 82246F78h */ case    5:  		/* mr R3, R30 */
		/* 82246F78h case    5:*/		regs.R3 = regs.R30;
		/* 82246F78h case    5:*/		return 0x82246F7C;
		  /* 82246F7Ch */ case    6:  		/* bl -8764 */
		/* 82246F7Ch case    6:*/		regs.LR = 0x82246F80; return 0x82244D40;
		/* 82246F7Ch case    6:*/		return 0x82246F80;
		  /* 82246F80h */ case    7:  		/* mr R4, R19 */
		/* 82246F80h case    7:*/		regs.R4 = regs.R19;
		/* 82246F80h case    7:*/		return 0x82246F84;
		  /* 82246F84h */ case    8:  		/* addi R5, R1, 160 */
		/* 82246F84h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xA0);
		/* 82246F84h case    8:*/		return 0x82246F88;
		  /* 82246F88h */ case    9:  		/* lwz R3, <#[R17]> */
		/* 82246F88h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 82246F88h case    9:*/		return 0x82246F8C;
		  /* 82246F8Ch */ case   10:  		/* bl -170956 */
		/* 82246F8Ch case   10:*/		regs.LR = 0x82246F90; return 0x8221D3C0;
		/* 82246F8Ch case   10:*/		return 0x82246F90;
		  /* 82246F90h */ case   11:  		/* addi R31, R31, 8 */
		/* 82246F90h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 82246F90h case   11:*/		return 0x82246F94;
		  /* 82246F94h */ case   12:  		/* addi R29, R29, 4 */
		/* 82246F94h case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82246F94h case   12:*/		return 0x82246F98;
		  /* 82246F98h */ case   13:  		/* cmpwi CR6, R31, 928 */
		/* 82246F98h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x000003A0);
		/* 82246F98h case   13:*/		return 0x82246F9C;
		  /* 82246F9Ch */ case   14:  		/* bc 12, CR6_LT, -136 */
		/* 82246F9Ch case   14:*/		if ( regs.CR[6].lt ) { return 0x82246F14;  }
		/* 82246F9Ch case   14:*/		return 0x82246FA0;
	}
	return 0x82246FA0;
} // Block from 82246F64h-82246FA0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82246FA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246FA0);
		  /* 82246FA0h */ case    0:  		/* lwz R31, <#[R1 + 84]> */
		/* 82246FA0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 82246FA0h case    0:*/		return 0x82246FA4;
		  /* 82246FA4h */ case    1:  		/* lwz R3, <#[R17]> */
		/* 82246FA4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 82246FA4h case    1:*/		return 0x82246FA8;
		  /* 82246FA8h */ case    2:  		/* lwzx R5, <#[R25 + R31]> */
		/* 82246FA8h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R25 + regs.R31 + 0x00000000) );
		/* 82246FA8h case    2:*/		return 0x82246FAC;
		  /* 82246FACh */ case    3:  		/* cmplw CR6, R5, R26 */
		/* 82246FACh case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R26);
		/* 82246FACh case    3:*/		return 0x82246FB0;
		  /* 82246FB0h */ case    4:  		/* bc 12, CR6_EQ, 300 */
		/* 82246FB0h case    4:*/		if ( regs.CR[6].eq ) { return 0x822470DC;  }
		/* 82246FB0h case    4:*/		return 0x82246FB4;
		  /* 82246FB4h */ case    5:  		/* mr R4, R21 */
		/* 82246FB4h case    5:*/		regs.R4 = regs.R21;
		/* 82246FB4h case    5:*/		return 0x82246FB8;
		  /* 82246FB8h */ case    6:  		/* bl -171000 */
		/* 82246FB8h case    6:*/		regs.LR = 0x82246FBC; return 0x8221D3C0;
		/* 82246FB8h case    6:*/		return 0x82246FBC;
		  /* 82246FBCh */ case    7:  		/* lwzx R4, <#[R25 + R31]> */
		/* 82246FBCh case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + regs.R31 + 0x00000000) );
		/* 82246FBCh case    7:*/		return 0x82246FC0;
		  /* 82246FC0h */ case    8:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246FC0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246FC0h case    8:*/		return 0x82246FC4;
		  /* 82246FC4h */ case    9:  		/* cmplw CR6, R4, R11 */
		/* 82246FC4h case    9:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82246FC4h case    9:*/		return 0x82246FC8;
		  /* 82246FC8h */ case   10:  		/* bc 4, CR6_LT, 20 */
		/* 82246FC8h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82246FDC;  }
		/* 82246FC8h case   10:*/		return 0x82246FCC;
		  /* 82246FCCh */ case   11:  		/* lwz R10, <#[R23 + 8]> */
		/* 82246FCCh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 82246FCCh case   11:*/		return 0x82246FD0;
		  /* 82246FD0h */ case   12:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82246FD0h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82246FD0h case   12:*/		return 0x82246FD4;
		  /* 82246FD4h */ case   13:  		/* add R3, R11, R10 */
		/* 82246FD4h case   13:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82246FD4h case   13:*/		return 0x82246FD8;
		  /* 82246FD8h */ case   14:  		/* b 12 */
		/* 82246FD8h case   14:*/		return 0x82246FE4;
		/* 82246FD8h case   14:*/		return 0x82246FDC;
	}
	return 0x82246FDC;
} // Block from 82246FA0h-82246FDCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 82246FDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246FDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246FDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246FDC);
		  /* 82246FDCh */ case    0:  		/* mr R3, R23 */
		/* 82246FDCh case    0:*/		regs.R3 = regs.R23;
		/* 82246FDCh case    0:*/		return 0x82246FE0;
		  /* 82246FE0h */ case    1:  		/* bl 51936 */
		/* 82246FE0h case    1:*/		regs.LR = 0x82246FE4; return 0x82253AC0;
		/* 82246FE0h case    1:*/		return 0x82246FE4;
	}
	return 0x82246FE4;
} // Block from 82246FDCh-82246FE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82246FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82246FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82246FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82246FE4);
		  /* 82246FE4h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 82246FE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82246FE4h case    0:*/		return 0x82246FE8;
		  /* 82246FE8h */ case    1:  		/* lwz R27, <#[R3]> */
		/* 82246FE8h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82246FE8h case    1:*/		return 0x82246FEC;
		  /* 82246FECh */ case    2:  		/* cmplw CR6, R26, R11 */
		/* 82246FECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82246FECh case    2:*/		return 0x82246FF0;
		  /* 82246FF0h */ case    3:  		/* bc 4, CR6_LT, 16 */
		/* 82246FF0h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82247000;  }
		/* 82246FF0h case    3:*/		return 0x82246FF4;
		  /* 82246FF4h */ case    4:  		/* lwz R11, <#[R23 + 8]> */
		/* 82246FF4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82246FF4h case    4:*/		return 0x82246FF8;
		  /* 82246FF8h */ case    5:  		/* add R3, R11, R25 */
		/* 82246FF8h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 82246FF8h case    5:*/		return 0x82246FFC;
		  /* 82246FFCh */ case    6:  		/* b 16 */
		/* 82246FFCh case    6:*/		return 0x8224700C;
		/* 82246FFCh case    6:*/		return 0x82247000;
	}
	return 0x82247000;
} // Block from 82246FE4h-82247000h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82247000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247000);
		  /* 82247000h */ case    0:  		/* mr R4, R26 */
		/* 82247000h case    0:*/		regs.R4 = regs.R26;
		/* 82247000h case    0:*/		return 0x82247004;
		  /* 82247004h */ case    1:  		/* mr R3, R23 */
		/* 82247004h case    1:*/		regs.R3 = regs.R23;
		/* 82247004h case    1:*/		return 0x82247008;
		  /* 82247008h */ case    2:  		/* bl 51896 */
		/* 82247008h case    2:*/		regs.LR = 0x8224700C; return 0x82253AC0;
		/* 82247008h case    2:*/		return 0x8224700C;
	}
	return 0x8224700C;
} // Block from 82247000h-8224700Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224700Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224700C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224700C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224700C);
		  /* 8224700Ch */ case    0:  		/* lwz R31, <#[R3]> */
		/* 8224700Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 8224700Ch case    0:*/		return 0x82247010;
		  /* 82247010h */ case    1:  		/* li R30, 0 */
		/* 82247010h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82247010h case    1:*/		return 0x82247014;
		  /* 82247014h */ case    2:  		/* addi R28, R31, 896 */
		/* 82247014h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x380);
		/* 82247014h case    2:*/		return 0x82247018;
		  /* 82247018h */ case    3:  		/* addi R29, R31, 928 */
		/* 82247018h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x3A0);
		/* 82247018h case    3:*/		return 0x8224701C;
		  /* 8224701Ch */ case    4:  		/* lwz R11, <#[R29]> */
		/* 8224701Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224701Ch case    4:*/		return 0x82247020;
		  /* 82247020h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82247020h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82247020h case    5:*/		return 0x82247024;
		  /* 82247024h */ case    6:  		/* bc 12, CR6_EQ, 168 */
		/* 82247024h case    6:*/		if ( regs.CR[6].eq ) { return 0x822470CC;  }
		/* 82247024h case    6:*/		return 0x82247028;
		  /* 82247028h */ case    7:  		/* li R11, 0 */
		/* 82247028h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82247028h case    7:*/		return 0x8224702C;
		  /* 8224702Ch */ case    8:  		/* li R10, 0 */
		/* 8224702Ch case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8224702Ch case    8:*/		return 0x82247030;
		  /* 82247030h */ case    9:  		/* stw R11, <#[R29]> */
		/* 82247030h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82247030h case    9:*/		return 0x82247034;
		  /* 82247034h */ case   10:  		/* addi R11, R27, 896 */
		/* 82247034h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x380);
		/* 82247034h case   10:*/		return 0x82247038;
		  /* 82247038h */ case   11:  		/* addi R8, R27, 928 */
		/* 82247038h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R27,0x3A0);
		/* 82247038h case   11:*/		return 0x8224703C;
		  /* 8224703Ch */ case   12:  		/* lwz R9, <#[R8]> */
		/* 8224703Ch case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 8224703Ch case   12:*/		return 0x82247040;
		  /* 82247040h */ case   13:  		/* cmplwi CR6, R9, 0 */
		/* 82247040h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82247040h case   13:*/		return 0x82247044;
		  /* 82247044h */ case   14:  		/* bc 12, CR6_EQ, 84 */
		/* 82247044h case   14:*/		if ( regs.CR[6].eq ) { return 0x82247098;  }
		/* 82247044h case   14:*/		return 0x82247048;
		  /* 82247048h */ case   15:  		/* lwz R9, <#[R11]> */
		/* 82247048h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82247048h case   15:*/		return 0x8224704C;
		  /* 8224704Ch */ case   16:  		/* lwz R7, <#[R28]> */
		/* 8224704Ch case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + 0x00000000) );
		/* 8224704Ch case   16:*/		return 0x82247050;
		  /* 82247050h */ case   17:  		/* cmplw CR6, R9, R7 */
		/* 82247050h case   17:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82247050h case   17:*/		return 0x82247054;
		  /* 82247054h */ case   18:  		/* bc 4, CR6_EQ, 24 */
		/* 82247054h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8224706C;  }
		/* 82247054h case   18:*/		return 0x82247058;
		  /* 82247058h */ case   19:  		/* lwz R9, <#[R11 + 4]> */
		/* 82247058h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82247058h case   19:*/		return 0x8224705C;
		  /* 8224705Ch */ case   20:  		/* lwz R7, <#[R28 + 4]> */
		/* 8224705Ch case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + 0x00000004) );
		/* 8224705Ch case   20:*/		return 0x82247060;
		  /* 82247060h */ case   21:  		/* cmplw CR6, R9, R7 */
		/* 82247060h case   21:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82247060h case   21:*/		return 0x82247064;
		  /* 82247064h */ case   22:  		/* li R9, 1 */
		/* 82247064h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82247064h case   22:*/		return 0x82247068;
		  /* 82247068h */ case   23:  		/* bc 12, CR6_EQ, 8 */
		/* 82247068h case   23:*/		if ( regs.CR[6].eq ) { return 0x82247070;  }
		/* 82247068h case   23:*/		return 0x8224706C;
	}
	return 0x8224706C;
} // Block from 8224700Ch-8224706Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 8224706Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224706C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224706C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224706C);
		  /* 8224706Ch */ case    0:  		/* li R9, 0 */
		/* 8224706Ch case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8224706Ch case    0:*/		return 0x82247070;
	}
	return 0x82247070;
} // Block from 8224706Ch-82247070h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247070);
		  /* 82247070h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 82247070h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 82247070h case    0:*/		return 0x82247074;
		  /* 82247074h */ case    1:  		/* bc 4, CR0_EQ, 28 */
		/* 82247074h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82247090;  }
		/* 82247074h case    1:*/		return 0x82247078;
		  /* 82247078h */ case    2:  		/* addi R10, R10, 1 */
		/* 82247078h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82247078h case    2:*/		return 0x8224707C;
		  /* 8224707Ch */ case    3:  		/* addi R8, R8, 4 */
		/* 8224707Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8224707Ch case    3:*/		return 0x82247080;
		  /* 82247080h */ case    4:  		/* addi R11, R11, 8 */
		/* 82247080h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82247080h case    4:*/		return 0x82247084;
		  /* 82247084h */ case    5:  		/* cmpwi CR6, R10, 4 */
		/* 82247084h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000004);
		/* 82247084h case    5:*/		return 0x82247088;
		  /* 82247088h */ case    6:  		/* bc 12, CR6_LT, -76 */
		/* 82247088h case    6:*/		if ( regs.CR[6].lt ) { return 0x8224703C;  }
		/* 82247088h case    6:*/		return 0x8224708C;
		  /* 8224708Ch */ case    7:  		/* b 12 */
		/* 8224708Ch case    7:*/		return 0x82247098;
		/* 8224708Ch case    7:*/		return 0x82247090;
	}
	return 0x82247090;
} // Block from 82247070h-82247090h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82247090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247090);
		  /* 82247090h */ case    0:  		/* add R11, R31, R30 */
		/* 82247090h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R30);
		/* 82247090h case    0:*/		return 0x82247094;
		  /* 82247094h */ case    1:  		/* stb R10, <#[R11 + 944]> */
		/* 82247094h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x000003B0) );
		/* 82247094h case    1:*/		return 0x82247098;
	}
	return 0x82247098;
} // Block from 82247090h-82247098h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82247098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247098);
		  /* 82247098h */ case    0:  		/* lwz R11, <#[R27 + 56]> */
		/* 82247098h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000038) );
		/* 82247098h case    0:*/		return 0x8224709C;
		  /* 8224709Ch */ case    1:  		/* add R10, R31, R30 */
		/* 8224709Ch case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R31,regs.R30);
		/* 8224709Ch case    1:*/		return 0x822470A0;
		  /* 822470A0h */ case    2:  		/* stw R18, <#[R31 + 80]> */
		/* 822470A0h case    2:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R31 + 0x00000050) );
		/* 822470A0h case    2:*/		return 0x822470A4;
		  /* 822470A4h */ case    3:  		/* mr R4, R24 */
		/* 822470A4h case    3:*/		regs.R4 = regs.R24;
		/* 822470A4h case    3:*/		return 0x822470A8;
		  /* 822470A8h */ case    4:  		/* stw R11, <#[R31 + 56]> */
		/* 822470A8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 822470A8h case    4:*/		return 0x822470AC;
		  /* 822470ACh */ case    5:  		/* lbz R5, <#[R10 + 944]> */
		/* 822470ACh case    5:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R10 + 0x000003B0) );
		/* 822470ACh case    5:*/		return 0x822470B0;
		  /* 822470B0h */ case    6:  		/* lwz R3, <#[R17]> */
		/* 822470B0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 822470B0h case    6:*/		return 0x822470B4;
		  /* 822470B4h */ case    7:  		/* bl -171252 */
		/* 822470B4h case    7:*/		regs.LR = 0x822470B8; return 0x8221D3C0;
		/* 822470B4h case    7:*/		return 0x822470B8;
		  /* 822470B8h */ case    8:  		/* addi R30, R30, 1 */
		/* 822470B8h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822470B8h case    8:*/		return 0x822470BC;
		  /* 822470BCh */ case    9:  		/* addi R29, R29, 4 */
		/* 822470BCh case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 822470BCh case    9:*/		return 0x822470C0;
		  /* 822470C0h */ case   10:  		/* addi R28, R28, 8 */
		/* 822470C0h case   10:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 822470C0h case   10:*/		return 0x822470C4;
		  /* 822470C4h */ case   11:  		/* cmpwi CR6, R30, 4 */
		/* 822470C4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 822470C4h case   11:*/		return 0x822470C8;
		  /* 822470C8h */ case   12:  		/* bc 12, CR6_LT, -172 */
		/* 822470C8h case   12:*/		if ( regs.CR[6].lt ) { return 0x8224701C;  }
		/* 822470C8h case   12:*/		return 0x822470CC;
	}
	return 0x822470CC;
} // Block from 82247098h-822470CCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 822470CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822470CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822470CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822470CC);
		  /* 822470CCh */ case    0:  		/* mr R4, R20 */
		/* 822470CCh case    0:*/		regs.R4 = regs.R20;
		/* 822470CCh case    0:*/		return 0x822470D0;
		  /* 822470D0h */ case    1:  		/* lwz R3, <#[R17]> */
		/* 822470D0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 822470D0h case    1:*/		return 0x822470D4;
		  /* 822470D4h */ case    2:  		/* bl -171284 */
		/* 822470D4h case    2:*/		regs.LR = 0x822470D8; return 0x8221D3C0;
		/* 822470D4h case    2:*/		return 0x822470D8;
		  /* 822470D8h */ case    3:  		/* b 132 */
		/* 822470D8h case    3:*/		return 0x8224715C;
		/* 822470D8h case    3:*/		return 0x822470DC;
	}
	return 0x822470DC;
} // Block from 822470CCh-822470DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822470DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822470DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822470DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822470DC);
		  /* 822470DCh */ case    0:  		/* mr R4, R20 */
		/* 822470DCh case    0:*/		regs.R4 = regs.R20;
		/* 822470DCh case    0:*/		return 0x822470E0;
		  /* 822470E0h */ case    1:  		/* bl -171296 */
		/* 822470E0h case    1:*/		regs.LR = 0x822470E4; return 0x8221D3C0;
		/* 822470E0h case    1:*/		return 0x822470E4;
		  /* 822470E4h */ case    2:  		/* lwz R11, <#[R23 + 4]> */
		/* 822470E4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 822470E4h case    2:*/		return 0x822470E8;
		  /* 822470E8h */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 822470E8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 822470E8h case    3:*/		return 0x822470EC;
		  /* 822470ECh */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 822470ECh case    4:*/		if ( !regs.CR[6].lt ) { return 0x822470FC;  }
		/* 822470ECh case    4:*/		return 0x822470F0;
		  /* 822470F0h */ case    5:  		/* lwz R11, <#[R23 + 8]> */
		/* 822470F0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 822470F0h case    5:*/		return 0x822470F4;
		  /* 822470F4h */ case    6:  		/* add R3, R11, R25 */
		/* 822470F4h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 822470F4h case    6:*/		return 0x822470F8;
		  /* 822470F8h */ case    7:  		/* b 16 */
		/* 822470F8h case    7:*/		return 0x82247108;
		/* 822470F8h case    7:*/		return 0x822470FC;
	}
	return 0x822470FC;
} // Block from 822470DCh-822470FCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 822470FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822470FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822470FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822470FC);
		  /* 822470FCh */ case    0:  		/* mr R4, R26 */
		/* 822470FCh case    0:*/		regs.R4 = regs.R26;
		/* 822470FCh case    0:*/		return 0x82247100;
		  /* 82247100h */ case    1:  		/* mr R3, R23 */
		/* 82247100h case    1:*/		regs.R3 = regs.R23;
		/* 82247100h case    1:*/		return 0x82247104;
		  /* 82247104h */ case    2:  		/* bl 51644 */
		/* 82247104h case    2:*/		regs.LR = 0x82247108; return 0x82253AC0;
		/* 82247104h case    2:*/		return 0x82247108;
	}
	return 0x82247108;
} // Block from 822470FCh-82247108h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82247108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247108);
		  /* 82247108h */ case    0:  		/* lwz R31, <#[R3]> */
		/* 82247108h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82247108h case    0:*/		return 0x8224710C;
		  /* 8224710Ch */ case    1:  		/* mr R3, R17 */
		/* 8224710Ch case    1:*/		regs.R3 = regs.R17;
		/* 8224710Ch case    1:*/		return 0x82247110;
		  /* 82247110h */ case    2:  		/* bl -8864 */
		/* 82247110h case    2:*/		regs.LR = 0x82247114; return 0x82244E70;
		/* 82247110h case    2:*/		return 0x82247114;
		  /* 82247114h */ case    3:  		/* stw R3, <#[R31 + 56]> */
		/* 82247114h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 82247114h case    3:*/		return 0x82247118;
		  /* 82247118h */ case    4:  		/* li R30, 0 */
		/* 82247118h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82247118h case    4:*/		return 0x8224711C;
		  /* 8224711Ch */ case    5:  		/* stw R18, <#[R31 + 80]> */
		/* 8224711Ch case    5:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R31 + 0x00000050) );
		/* 8224711Ch case    5:*/		return 0x82247120;
		  /* 82247120h */ case    6:  		/* addi R29, R31, 896 */
		/* 82247120h case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x380);
		/* 82247120h case    6:*/		return 0x82247124;
		  /* 82247124h */ case    7:  		/* addi R28, R31, 928 */
		/* 82247124h case    7:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x3A0);
		/* 82247124h case    7:*/		return 0x82247128;
		  /* 82247128h */ case    8:  		/* lwz R11, <#[R28]> */
		/* 82247128h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82247128h case    8:*/		return 0x8224712C;
		  /* 8224712Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8224712Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224712Ch case    9:*/		return 0x82247130;
		  /* 82247130h */ case   10:  		/* bc 12, CR6_EQ, 44 */
		/* 82247130h case   10:*/		if ( regs.CR[6].eq ) { return 0x8224715C;  }
		/* 82247130h case   10:*/		return 0x82247134;
		  /* 82247134h */ case   11:  		/* mr R5, R30 */
		/* 82247134h case   11:*/		regs.R5 = regs.R30;
		/* 82247134h case   11:*/		return 0x82247138;
		  /* 82247138h */ case   12:  		/* ld R6, <#[R29]> */
		/* 82247138h case   12:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R29 + 0x00000000) );
		/* 82247138h case   12:*/		return 0x8224713C;
		  /* 8224713Ch */ case   13:  		/* lwz R4, <#[R31 + 56]> */
		/* 8224713Ch case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000038) );
		/* 8224713Ch case   13:*/		return 0x82247140;
		  /* 82247140h */ case   14:  		/* lwz R3, <#[R17]> */
		/* 82247140h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 82247140h case   14:*/		return 0x82247144;
		  /* 82247144h */ case   15:  		/* bl -173060 */
		/* 82247144h case   15:*/		regs.LR = 0x82247148; return 0x8221CD40;
		/* 82247144h case   15:*/		return 0x82247148;
		  /* 82247148h */ case   16:  		/* addi R30, R30, 1 */
		/* 82247148h case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82247148h case   16:*/		return 0x8224714C;
		  /* 8224714Ch */ case   17:  		/* addi R28, R28, 4 */
		/* 8224714Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8224714Ch case   17:*/		return 0x82247150;
		  /* 82247150h */ case   18:  		/* addi R29, R29, 8 */
		/* 82247150h case   18:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x8);
		/* 82247150h case   18:*/		return 0x82247154;
		  /* 82247154h */ case   19:  		/* cmpwi CR6, R30, 4 */
		/* 82247154h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 82247154h case   19:*/		return 0x82247158;
		  /* 82247158h */ case   20:  		/* bc 12, CR6_LT, -48 */
		/* 82247158h case   20:*/		if ( regs.CR[6].lt ) { return 0x82247128;  }
		/* 82247158h case   20:*/		return 0x8224715C;
	}
	return 0x8224715C;
} // Block from 82247108h-8224715Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224715Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224715C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224715C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224715C);
		  /* 8224715Ch */ case    0:  		/* lwz R6, <#[R23 + 4]> */
		/* 8224715Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R23 + 0x00000004) );
		/* 8224715Ch case    0:*/		return 0x82247160;
		  /* 82247160h */ case    1:  		/* addi R26, R26, 1 */
		/* 82247160h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82247160h case    1:*/		return 0x82247164;
		  /* 82247164h */ case    2:  		/* addi R25, R25, 4 */
		/* 82247164h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82247164h case    2:*/		return 0x82247168;
		  /* 82247168h */ case    3:  		/* cmplw CR6, R26, R6 */
		/* 82247168h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R6);
		/* 82247168h case    3:*/		return 0x8224716C;
		  /* 8224716Ch */ case    4:  		/* bc 12, CR6_LT, -656 */
		/* 8224716Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82246EDC;  }
		/* 8224716Ch case    4:*/		return 0x82247170;
	}
	return 0x82247170;
} // Block from 8224715Ch-82247170h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82247170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247170);
		  /* 82247170h */ case    0:  		/* lwz R11, <#[R17]> */
		/* 82247170h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247170h case    0:*/		return 0x82247174;
		  /* 82247174h */ case    1:  		/* lwz R4, <#[R1 + 108]> */
		/* 82247174h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000006C) );
		/* 82247174h case    1:*/		return 0x82247178;
		  /* 82247178h */ case    2:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82247178h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82247178h case    2:*/		return 0x8224717C;
		  /* 8224717Ch */ case    3:  		/* bl -174908 */
		/* 8224717Ch case    3:*/		regs.LR = 0x82247180; return 0x8221C640;
		/* 8224717Ch case    3:*/		return 0x82247180;
		  /* 82247180h */ case    4:  		/* lwz R11, <#[R17]> */
		/* 82247180h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247180h case    4:*/		return 0x82247184;
		  /* 82247184h */ case    5:  		/* lwz R4, <#[R1 + 104]> */
		/* 82247184h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 82247184h case    5:*/		return 0x82247188;
		  /* 82247188h */ case    6:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82247188h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82247188h case    6:*/		return 0x8224718C;
		  /* 8224718Ch */ case    7:  		/* bl -174924 */
		/* 8224718Ch case    7:*/		regs.LR = 0x82247190; return 0x8221C640;
		/* 8224718Ch case    7:*/		return 0x82247190;
		  /* 82247190h */ case    8:  		/* lwz R11, <#[R17]> */
		/* 82247190h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247190h case    8:*/		return 0x82247194;
		  /* 82247194h */ case    9:  		/* lwz R4, <#[R1 + 96]> */
		/* 82247194h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 82247194h case    9:*/		return 0x82247198;
		  /* 82247198h */ case   10:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82247198h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82247198h case   10:*/		return 0x8224719C;
		  /* 8224719Ch */ case   11:  		/* bl -174940 */
		/* 8224719Ch case   11:*/		regs.LR = 0x822471A0; return 0x8221C640;
		/* 8224719Ch case   11:*/		return 0x822471A0;
		  /* 822471A0h */ case   12:  		/* lwz R11, <#[R17]> */
		/* 822471A0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 822471A0h case   12:*/		return 0x822471A4;
		  /* 822471A4h */ case   13:  		/* lwz R4, <#[R1 + 136]> */
		/* 822471A4h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 822471A4h case   13:*/		return 0x822471A8;
		  /* 822471A8h */ case   14:  		/* lwz R3, <#[R11 + 1456]> */
		/* 822471A8h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 822471A8h case   14:*/		return 0x822471AC;
		  /* 822471ACh */ case   15:  		/* bl -174956 */
		/* 822471ACh case   15:*/		regs.LR = 0x822471B0; return 0x8221C640;
		/* 822471ACh case   15:*/		return 0x822471B0;
		  /* 822471B0h */ case   16:  		/* lwz R25, <#[R1 + 132]> */
		/* 822471B0h case   16:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000084) );
		/* 822471B0h case   16:*/		return 0x822471B4;
		  /* 822471B4h */ case   17:  		/* li R30, 0 */
		/* 822471B4h case   17:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822471B4h case   17:*/		return 0x822471B8;
		  /* 822471B8h */ case   18:  		/* lwz R26, <#[R1 + 88]> */
		/* 822471B8h case   18:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000058) );
		/* 822471B8h case   18:*/		return 0x822471BC;
		  /* 822471BCh */ case   19:  		/* lwz R11, <#[R25 + 4]> */
		/* 822471BCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 822471BCh case   19:*/		return 0x822471C0;
		  /* 822471C0h */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 822471C0h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822471C0h case   20:*/		return 0x822471C4;
		  /* 822471C4h */ case   21:  		/* bc 4, CR6_GT, 116 */
		/* 822471C4h case   21:*/		if ( !regs.CR[6].gt ) { return 0x82247238;  }
		/* 822471C4h case   21:*/		return 0x822471C8;
		  /* 822471C8h */ case   22:  		/* lwz R11, <#[R1 + 140]> */
		/* 822471C8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 822471C8h case   22:*/		return 0x822471CC;
		  /* 822471CCh */ case   23:  		/* mr R31, R26 */
		/* 822471CCh case   23:*/		regs.R31 = regs.R26;
		/* 822471CCh case   23:*/		return 0x822471D0;
		  /* 822471D0h */ case   24:  		/* lwz R10, <#[R1 + 80]> */
		/* 822471D0h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 822471D0h case   24:*/		return 0x822471D4;
		  /* 822471D4h */ case   25:  		/* lwz R9, <#[R1 + 100]> */
		/* 822471D4h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000064) );
		/* 822471D4h case   25:*/		return 0x822471D8;
		  /* 822471D8h */ case   26:  		/* subf R29, R26, R11 */
		/* 822471D8h case   26:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R26,regs.R11);
		/* 822471D8h case   26:*/		return 0x822471DC;
		  /* 822471DCh */ case   27:  		/* subf R28, R26, R10 */
		/* 822471DCh case   27:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R26,regs.R10);
		/* 822471DCh case   27:*/		return 0x822471E0;
		  /* 822471E0h */ case   28:  		/* subf R27, R26, R9 */
		/* 822471E0h case   28:*/		cpu::op::subf<0>(regs,&regs.R27,regs.R26,regs.R9);
		/* 822471E0h case   28:*/		return 0x822471E4;
		  /* 822471E4h */ case   29:  		/* lwz R11, <#[R17]> */
		/* 822471E4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 822471E4h case   29:*/		return 0x822471E8;
		  /* 822471E8h */ case   30:  		/* lwzx R4, <#[R29 + R31]> */
		/* 822471E8h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 822471E8h case   30:*/		return 0x822471EC;
		  /* 822471ECh */ case   31:  		/* lwz R3, <#[R11 + 1456]> */
		/* 822471ECh case   31:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 822471ECh case   31:*/		return 0x822471F0;
		  /* 822471F0h */ case   32:  		/* bl -175024 */
		/* 822471F0h case   32:*/		regs.LR = 0x822471F4; return 0x8221C640;
		/* 822471F0h case   32:*/		return 0x822471F4;
		  /* 822471F4h */ case   33:  		/* lwz R11, <#[R17]> */
		/* 822471F4h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 822471F4h case   33:*/		return 0x822471F8;
		  /* 822471F8h */ case   34:  		/* lwz R4, <#[R31]> */
		/* 822471F8h case   34:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 822471F8h case   34:*/		return 0x822471FC;
		  /* 822471FCh */ case   35:  		/* lwz R3, <#[R11 + 1456]> */
		/* 822471FCh case   35:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 822471FCh case   35:*/		return 0x82247200;
		  /* 82247200h */ case   36:  		/* bl -175040 */
		/* 82247200h case   36:*/		regs.LR = 0x82247204; return 0x8221C640;
		/* 82247200h case   36:*/		return 0x82247204;
		  /* 82247204h */ case   37:  		/* lwz R11, <#[R17]> */
		/* 82247204h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247204h case   37:*/		return 0x82247208;
		  /* 82247208h */ case   38:  		/* lwzx R4, <#[R28 + R31]> */
		/* 82247208h case   38:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + regs.R31 + 0x00000000) );
		/* 82247208h case   38:*/		return 0x8224720C;
		  /* 8224720Ch */ case   39:  		/* lwz R3, <#[R11 + 1456]> */
		/* 8224720Ch case   39:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224720Ch case   39:*/		return 0x82247210;
		  /* 82247210h */ case   40:  		/* bl -175056 */
		/* 82247210h case   40:*/		regs.LR = 0x82247214; return 0x8221C640;
		/* 82247210h case   40:*/		return 0x82247214;
		  /* 82247214h */ case   41:  		/* lwz R11, <#[R17]> */
		/* 82247214h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247214h case   41:*/		return 0x82247218;
		  /* 82247218h */ case   42:  		/* lwzx R4, <#[R27 + R31]> */
		/* 82247218h case   42:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + regs.R31 + 0x00000000) );
		/* 82247218h case   42:*/		return 0x8224721C;
		  /* 8224721Ch */ case   43:  		/* lwz R3, <#[R11 + 1456]> */
		/* 8224721Ch case   43:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224721Ch case   43:*/		return 0x82247220;
		  /* 82247220h */ case   44:  		/* bl -175072 */
		/* 82247220h case   44:*/		regs.LR = 0x82247224; return 0x8221C640;
		/* 82247220h case   44:*/		return 0x82247224;
		  /* 82247224h */ case   45:  		/* lwz R11, <#[R25 + 4]> */
		/* 82247224h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 82247224h case   45:*/		return 0x82247228;
		  /* 82247228h */ case   46:  		/* addi R30, R30, 1 */
		/* 82247228h case   46:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82247228h case   46:*/		return 0x8224722C;
		  /* 8224722Ch */ case   47:  		/* addi R31, R31, 4 */
		/* 8224722Ch case   47:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8224722Ch case   47:*/		return 0x82247230;
		  /* 82247230h */ case   48:  		/* cmplw CR6, R30, R11 */
		/* 82247230h case   48:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82247230h case   48:*/		return 0x82247234;
		  /* 82247234h */ case   49:  		/* bc 12, CR6_LT, -80 */
		/* 82247234h case   49:*/		if ( regs.CR[6].lt ) { return 0x822471E4;  }
		/* 82247234h case   49:*/		return 0x82247238;
	}
	return 0x82247238;
} // Block from 82247170h-82247238h (50 instructions)

//////////////////////////////////////////////////////
// Block at 82247238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247238);
		  /* 82247238h */ case    0:  		/* lwz R11, <#[R17]> */
		/* 82247238h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247238h case    0:*/		return 0x8224723C;
		  /* 8224723Ch */ case    1:  		/* lwz R4, <#[R1 + 92]> */
		/* 8224723Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000005C) );
		/* 8224723Ch case    1:*/		return 0x82247240;
		  /* 82247240h */ case    2:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82247240h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82247240h case    2:*/		return 0x82247244;
		  /* 82247244h */ case    3:  		/* bl -175108 */
		/* 82247244h case    3:*/		regs.LR = 0x82247248; return 0x8221C640;
		/* 82247244h case    3:*/		return 0x82247248;
		  /* 82247248h */ case    4:  		/* lwz R11, <#[R17]> */
		/* 82247248h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247248h case    4:*/		return 0x8224724C;
		  /* 8224724Ch */ case    5:  		/* lwz R4, <#[R1 + 84]> */
		/* 8224724Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 8224724Ch case    5:*/		return 0x82247250;
		  /* 82247250h */ case    6:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82247250h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82247250h case    6:*/		return 0x82247254;
		  /* 82247254h */ case    7:  		/* bl -175124 */
		/* 82247254h case    7:*/		regs.LR = 0x82247258; return 0x8221C640;
		/* 82247254h case    7:*/		return 0x82247258;
		  /* 82247258h */ case    8:  		/* lwz R11, <#[R17]> */
		/* 82247258h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247258h case    8:*/		return 0x8224725C;
		  /* 8224725Ch */ case    9:  		/* lwz R4, <#[R1 + 128]> */
		/* 8224725Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000080) );
		/* 8224725Ch case    9:*/		return 0x82247260;
		  /* 82247260h */ case   10:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82247260h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82247260h case   10:*/		return 0x82247264;
		  /* 82247264h */ case   11:  		/* bl -175140 */
		/* 82247264h case   11:*/		regs.LR = 0x82247268; return 0x8221C640;
		/* 82247264h case   11:*/		return 0x82247268;
		  /* 82247268h */ case   12:  		/* lwz R11, <#[R17]> */
		/* 82247268h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247268h case   12:*/		return 0x8224726C;
		  /* 8224726Ch */ case   13:  		/* lwz R4, <#[R1 + 140]> */
		/* 8224726Ch case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000008C) );
		/* 8224726Ch case   13:*/		return 0x82247270;
		  /* 82247270h */ case   14:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82247270h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82247270h case   14:*/		return 0x82247274;
		  /* 82247274h */ case   15:  		/* bl -175156 */
		/* 82247274h case   15:*/		regs.LR = 0x82247278; return 0x8221C640;
		/* 82247274h case   15:*/		return 0x82247278;
		  /* 82247278h */ case   16:  		/* lwz R11, <#[R17]> */
		/* 82247278h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247278h case   16:*/		return 0x8224727C;
		  /* 8224727Ch */ case   17:  		/* mr R4, R26 */
		/* 8224727Ch case   17:*/		regs.R4 = regs.R26;
		/* 8224727Ch case   17:*/		return 0x82247280;
		  /* 82247280h */ case   18:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82247280h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82247280h case   18:*/		return 0x82247284;
		  /* 82247284h */ case   19:  		/* bl -175172 */
		/* 82247284h case   19:*/		regs.LR = 0x82247288; return 0x8221C640;
		/* 82247284h case   19:*/		return 0x82247288;
		  /* 82247288h */ case   20:  		/* lwz R11, <#[R17]> */
		/* 82247288h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247288h case   20:*/		return 0x8224728C;
		  /* 8224728Ch */ case   21:  		/* lwz R4, <#[R1 + 80]> */
		/* 8224728Ch case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8224728Ch case   21:*/		return 0x82247290;
		  /* 82247290h */ case   22:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82247290h case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82247290h case   22:*/		return 0x82247294;
		  /* 82247294h */ case   23:  		/* bl -175188 */
		/* 82247294h case   23:*/		regs.LR = 0x82247298; return 0x8221C640;
		/* 82247294h case   23:*/		return 0x82247298;
		  /* 82247298h */ case   24:  		/* lwz R11, <#[R17]> */
		/* 82247298h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82247298h case   24:*/		return 0x8224729C;
		  /* 8224729Ch */ case   25:  		/* lwz R4, <#[R1 + 100]> */
		/* 8224729Ch case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 8224729Ch case   25:*/		return 0x822472A0;
		  /* 822472A0h */ case   26:  		/* lwz R3, <#[R11 + 1456]> */
		/* 822472A0h case   26:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 822472A0h case   26:*/		return 0x822472A4;
		  /* 822472A4h */ case   27:  		/* bl -175204 */
		/* 822472A4h case   27:*/		regs.LR = 0x822472A8; return 0x8221C640;
		/* 822472A4h case   27:*/		return 0x822472A8;
		  /* 822472A8h */ case   28:  		/* b 408 */
		/* 822472A8h case   28:*/		return 0x82247440;
		/* 822472A8h case   28:*/		return 0x822472AC;
	}
	return 0x822472AC;
} // Block from 82247238h-822472ACh (29 instructions)

//////////////////////////////////////////////////////
// Block at 822472ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822472AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822472AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822472AC);
		  /* 822472ACh */ case    0:  		/* lwz R8, <#[R23 + 4]> */
		/* 822472ACh case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000004) );
		/* 822472ACh case    0:*/		return 0x822472B0;
		  /* 822472B0h */ case    1:  		/* mr R27, R24 */
		/* 822472B0h case    1:*/		regs.R27 = regs.R24;
		/* 822472B0h case    1:*/		return 0x822472B4;
		  /* 822472B4h */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 822472B4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 822472B4h case    2:*/		return 0x822472B8;
		  /* 822472B8h */ case    3:  		/* bc 12, CR6_EQ, 392 */
		/* 822472B8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82247440;  }
		/* 822472B8h case    3:*/		return 0x822472BC;
		  /* 822472BCh */ case    4:  		/* mr R26, R24 */
		/* 822472BCh case    4:*/		regs.R26 = regs.R24;
		/* 822472BCh case    4:*/		return 0x822472C0;
		  /* 822472C0h */ case    5:  		/* lis R9, -32256 */
		/* 822472C0h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 822472C0h case    5:*/		return 0x822472C4;
		  /* 822472C4h */ case    6:  		/* lis R10, -32252 */
		/* 822472C4h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822472C4h case    6:*/		return 0x822472C8;
		  /* 822472C8h */ case    7:  		/* lis R11, -32252 */
		/* 822472C8h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822472C8h case    7:*/		return 0x822472CC;
		  /* 822472CCh */ case    8:  		/* li R18, 11 */
		/* 822472CCh case    8:*/		cpu::op::li<0>(regs,&regs.R18,0xB);
		/* 822472CCh case    8:*/		return 0x822472D0;
		  /* 822472D0h */ case    9:  		/* addi R22, R9, 17768 */
		/* 822472D0h case    9:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R9,0x4568);
		/* 822472D0h case    9:*/		return 0x822472D4;
		  /* 822472D4h */ case   10:  		/* addi R24, R10, 12744 */
		/* 822472D4h case   10:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R10,0x31C8);
		/* 822472D4h case   10:*/		return 0x822472D8;
		  /* 822472D8h */ case   11:  		/* addi R25, R11, 12732 */
		/* 822472D8h case   11:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0x31BC);
		/* 822472D8h case   11:*/		return 0x822472DC;
		  /* 822472DCh */ case   12:  		/* cmplw CR6, R26, R8 */
		/* 822472DCh case   12:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R8);
		/* 822472DCh case   12:*/		return 0x822472E0;
		  /* 822472E0h */ case   13:  		/* bc 4, CR6_LT, 16 */
		/* 822472E0h case   13:*/		if ( !regs.CR[6].lt ) { return 0x822472F0;  }
		/* 822472E0h case   13:*/		return 0x822472E4;
		  /* 822472E4h */ case   14:  		/* lwz R11, <#[R23 + 8]> */
		/* 822472E4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 822472E4h case   14:*/		return 0x822472E8;
		  /* 822472E8h */ case   15:  		/* add R3, R11, R26 */
		/* 822472E8h case   15:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 822472E8h case   15:*/		return 0x822472EC;
		  /* 822472ECh */ case   16:  		/* b 16 */
		/* 822472ECh case   16:*/		return 0x822472FC;
		/* 822472ECh case   16:*/		return 0x822472F0;
	}
	return 0x822472F0;
} // Block from 822472ACh-822472F0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822472F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822472F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822472F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822472F0);
		  /* 822472F0h */ case    0:  		/* mr R4, R27 */
		/* 822472F0h case    0:*/		regs.R4 = regs.R27;
		/* 822472F0h case    0:*/		return 0x822472F4;
		  /* 822472F4h */ case    1:  		/* mr R3, R23 */
		/* 822472F4h case    1:*/		regs.R3 = regs.R23;
		/* 822472F4h case    1:*/		return 0x822472F8;
		  /* 822472F8h */ case    2:  		/* bl 51144 */
		/* 822472F8h case    2:*/		regs.LR = 0x822472FC; return 0x82253AC0;
		/* 822472F8h case    2:*/		return 0x822472FC;
	}
	return 0x822472FC;
} // Block from 822472F0h-822472FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822472FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822472FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822472FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822472FC);
		  /* 822472FCh */ case    0:  		/* lwz R11, <#[R3]> */
		/* 822472FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822472FCh case    0:*/		return 0x82247300;
		  /* 82247300h */ case    1:  		/* mr R4, R25 */
		/* 82247300h case    1:*/		regs.R4 = regs.R25;
		/* 82247300h case    1:*/		return 0x82247304;
		  /* 82247304h */ case    2:  		/* mr R6, R27 */
		/* 82247304h case    2:*/		regs.R6 = regs.R27;
		/* 82247304h case    2:*/		return 0x82247308;
		  /* 82247308h */ case    3:  		/* lwz R3, <#[R17]> */
		/* 82247308h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 82247308h case    3:*/		return 0x8224730C;
		  /* 8224730Ch */ case    4:  		/* lwz R5, <#[R11 + 224]> */
		/* 8224730Ch case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x000000E0) );
		/* 8224730Ch case    4:*/		return 0x82247310;
		  /* 82247310h */ case    5:  		/* bl -171856 */
		/* 82247310h case    5:*/		regs.LR = 0x82247314; return 0x8221D3C0;
		/* 82247310h case    5:*/		return 0x82247314;
		  /* 82247314h */ case    6:  		/* li R29, 928 */
		/* 82247314h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x3A0);
		/* 82247314h case    6:*/		return 0x82247318;
		  /* 82247318h */ case    7:  		/* li R31, 896 */
		/* 82247318h case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x380);
		/* 82247318h case    7:*/		return 0x8224731C;
		  /* 8224731Ch */ case    8:  		/* lwz R11, <#[R23 + 4]> */
		/* 8224731Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8224731Ch case    8:*/		return 0x82247320;
		  /* 82247320h */ case    9:  		/* cmplw CR6, R27, R11 */
		/* 82247320h case    9:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82247320h case    9:*/		return 0x82247324;
		  /* 82247324h */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 82247324h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82247334;  }
		/* 82247324h case   10:*/		return 0x82247328;
		  /* 82247328h */ case   11:  		/* lwz R11, <#[R23 + 8]> */
		/* 82247328h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82247328h case   11:*/		return 0x8224732C;
		  /* 8224732Ch */ case   12:  		/* add R3, R11, R26 */
		/* 8224732Ch case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 8224732Ch case   12:*/		return 0x82247330;
		  /* 82247330h */ case   13:  		/* b 16 */
		/* 82247330h case   13:*/		return 0x82247340;
		/* 82247330h case   13:*/		return 0x82247334;
	}
	return 0x82247334;
} // Block from 822472FCh-82247334h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82247334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247334);
		  /* 82247334h */ case    0:  		/* mr R4, R27 */
		/* 82247334h case    0:*/		regs.R4 = regs.R27;
		/* 82247334h case    0:*/		return 0x82247338;
		  /* 82247338h */ case    1:  		/* mr R3, R23 */
		/* 82247338h case    1:*/		regs.R3 = regs.R23;
		/* 82247338h case    1:*/		return 0x8224733C;
		  /* 8224733Ch */ case    2:  		/* bl 51076 */
		/* 8224733Ch case    2:*/		regs.LR = 0x82247340; return 0x82253AC0;
		/* 8224733Ch case    2:*/		return 0x82247340;
	}
	return 0x82247340;
} // Block from 82247334h-82247340h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82247340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247340);
		  /* 82247340h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82247340h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82247340h case    0:*/		return 0x82247344;
		  /* 82247344h */ case    1:  		/* lwz R10, <#[R23 + 4]> */
		/* 82247344h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000004) );
		/* 82247344h case    1:*/		return 0x82247348;
		  /* 82247348h */ case    2:  		/* cmplw CR6, R27, R10 */
		/* 82247348h case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R10);
		/* 82247348h case    2:*/		return 0x8224734C;
		  /* 8224734Ch */ case    3:  		/* ldx R30, <#[R11 + R31]> */
		/* 8224734Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8224734Ch case    3:*/		return 0x82247350;
		  /* 82247350h */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 82247350h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82247360;  }
		/* 82247350h case    4:*/		return 0x82247354;
		  /* 82247354h */ case    5:  		/* lwz R11, <#[R23 + 8]> */
		/* 82247354h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82247354h case    5:*/		return 0x82247358;
		  /* 82247358h */ case    6:  		/* add R3, R11, R26 */
		/* 82247358h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82247358h case    6:*/		return 0x8224735C;
		  /* 8224735Ch */ case    7:  		/* b 16 */
		/* 8224735Ch case    7:*/		return 0x8224736C;
		/* 8224735Ch case    7:*/		return 0x82247360;
	}
	return 0x82247360;
} // Block from 82247340h-82247360h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82247360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247360);
		  /* 82247360h */ case    0:  		/* mr R4, R27 */
		/* 82247360h case    0:*/		regs.R4 = regs.R27;
		/* 82247360h case    0:*/		return 0x82247364;
		  /* 82247364h */ case    1:  		/* mr R3, R23 */
		/* 82247364h case    1:*/		regs.R3 = regs.R23;
		/* 82247364h case    1:*/		return 0x82247368;
		  /* 82247368h */ case    2:  		/* bl 51032 */
		/* 82247368h case    2:*/		regs.LR = 0x8224736C; return 0x82253AC0;
		/* 82247368h case    2:*/		return 0x8224736C;
	}
	return 0x8224736C;
} // Block from 82247360h-8224736Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224736Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224736C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224736C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224736C);
		  /* 8224736Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224736Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224736Ch case    0:*/		return 0x82247370;
		  /* 82247370h */ case    1:  		/* lwzx R11, <#[R11 + R29]> */
		/* 82247370h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82247370h case    1:*/		return 0x82247374;
		  /* 82247374h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82247374h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82247374h case    2:*/		return 0x82247378;
		  /* 82247378h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 82247378h case    3:*/		if ( regs.CR[6].eq ) { return 0x822473A8;  }
		/* 82247378h case    3:*/		return 0x8224737C;
		  /* 8224737Ch */ case    4:  		/* addi R4, R1, 160 */
		/* 8224737Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xA0);
		/* 8224737Ch case    4:*/		return 0x82247380;
		  /* 82247380h */ case    5:  		/* mr R3, R30 */
		/* 82247380h case    5:*/		regs.R3 = regs.R30;
		/* 82247380h case    5:*/		return 0x82247384;
		  /* 82247384h */ case    6:  		/* bl -9796 */
		/* 82247384h case    6:*/		regs.LR = 0x82247388; return 0x82244D40;
		/* 82247384h case    6:*/		return 0x82247388;
		  /* 82247388h */ case    7:  		/* mr R4, R24 */
		/* 82247388h case    7:*/		regs.R4 = regs.R24;
		/* 82247388h case    7:*/		return 0x8224738C;
		  /* 8224738Ch */ case    8:  		/* addi R5, R1, 160 */
		/* 8224738Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xA0);
		/* 8224738Ch case    8:*/		return 0x82247390;
		  /* 82247390h */ case    9:  		/* lwz R3, <#[R17]> */
		/* 82247390h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 82247390h case    9:*/		return 0x82247394;
		  /* 82247394h */ case   10:  		/* bl -171988 */
		/* 82247394h case   10:*/		regs.LR = 0x82247398; return 0x8221D3C0;
		/* 82247394h case   10:*/		return 0x82247398;
		  /* 82247398h */ case   11:  		/* addi R31, R31, 8 */
		/* 82247398h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 82247398h case   11:*/		return 0x8224739C;
		  /* 8224739Ch */ case   12:  		/* addi R29, R29, 4 */
		/* 8224739Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8224739Ch case   12:*/		return 0x822473A0;
		  /* 822473A0h */ case   13:  		/* cmpwi CR6, R31, 928 */
		/* 822473A0h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x000003A0);
		/* 822473A0h case   13:*/		return 0x822473A4;
		  /* 822473A4h */ case   14:  		/* bc 12, CR6_LT, -136 */
		/* 822473A4h case   14:*/		if ( regs.CR[6].lt ) { return 0x8224731C;  }
		/* 822473A4h case   14:*/		return 0x822473A8;
	}
	return 0x822473A8;
} // Block from 8224736Ch-822473A8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822473A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822473A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822473A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822473A8);
		  /* 822473A8h */ case    0:  		/* mr R4, R22 */
		/* 822473A8h case    0:*/		regs.R4 = regs.R22;
		/* 822473A8h case    0:*/		return 0x822473AC;
		  /* 822473ACh */ case    1:  		/* lwz R3, <#[R17]> */
		/* 822473ACh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 822473ACh case    1:*/		return 0x822473B0;
		  /* 822473B0h */ case    2:  		/* bl -172016 */
		/* 822473B0h case    2:*/		regs.LR = 0x822473B4; return 0x8221D3C0;
		/* 822473B0h case    2:*/		return 0x822473B4;
		  /* 822473B4h */ case    3:  		/* lwz R11, <#[R23 + 4]> */
		/* 822473B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 822473B4h case    3:*/		return 0x822473B8;
		  /* 822473B8h */ case    4:  		/* cmplw CR6, R27, R11 */
		/* 822473B8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 822473B8h case    4:*/		return 0x822473BC;
		  /* 822473BCh */ case    5:  		/* bc 4, CR6_LT, 16 */
		/* 822473BCh case    5:*/		if ( !regs.CR[6].lt ) { return 0x822473CC;  }
		/* 822473BCh case    5:*/		return 0x822473C0;
		  /* 822473C0h */ case    6:  		/* lwz R11, <#[R23 + 8]> */
		/* 822473C0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 822473C0h case    6:*/		return 0x822473C4;
		  /* 822473C4h */ case    7:  		/* add R3, R11, R26 */
		/* 822473C4h case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 822473C4h case    7:*/		return 0x822473C8;
		  /* 822473C8h */ case    8:  		/* b 16 */
		/* 822473C8h case    8:*/		return 0x822473D8;
		/* 822473C8h case    8:*/		return 0x822473CC;
	}
	return 0x822473CC;
} // Block from 822473A8h-822473CCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 822473CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822473CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822473CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822473CC);
		  /* 822473CCh */ case    0:  		/* mr R4, R27 */
		/* 822473CCh case    0:*/		regs.R4 = regs.R27;
		/* 822473CCh case    0:*/		return 0x822473D0;
		  /* 822473D0h */ case    1:  		/* mr R3, R23 */
		/* 822473D0h case    1:*/		regs.R3 = regs.R23;
		/* 822473D0h case    1:*/		return 0x822473D4;
		  /* 822473D4h */ case    2:  		/* bl 50924 */
		/* 822473D4h case    2:*/		regs.LR = 0x822473D8; return 0x82253AC0;
		/* 822473D4h case    2:*/		return 0x822473D8;
	}
	return 0x822473D8;
} // Block from 822473CCh-822473D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822473D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822473D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822473D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822473D8);
		  /* 822473D8h */ case    0:  		/* lwz R31, <#[R3]> */
		/* 822473D8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 822473D8h case    0:*/		return 0x822473DC;
		  /* 822473DCh */ case    1:  		/* mr R3, R17 */
		/* 822473DCh case    1:*/		regs.R3 = regs.R17;
		/* 822473DCh case    1:*/		return 0x822473E0;
		  /* 822473E0h */ case    2:  		/* bl -9584 */
		/* 822473E0h case    2:*/		regs.LR = 0x822473E4; return 0x82244E70;
		/* 822473E0h case    2:*/		return 0x822473E4;
		  /* 822473E4h */ case    3:  		/* stw R3, <#[R31 + 56]> */
		/* 822473E4h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 822473E4h case    3:*/		return 0x822473E8;
		  /* 822473E8h */ case    4:  		/* li R30, 0 */
		/* 822473E8h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822473E8h case    4:*/		return 0x822473EC;
		  /* 822473ECh */ case    5:  		/* stw R18, <#[R31 + 80]> */
		/* 822473ECh case    5:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R31 + 0x00000050) );
		/* 822473ECh case    5:*/		return 0x822473F0;
		  /* 822473F0h */ case    6:  		/* addi R29, R31, 896 */
		/* 822473F0h case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x380);
		/* 822473F0h case    6:*/		return 0x822473F4;
		  /* 822473F4h */ case    7:  		/* addi R28, R31, 928 */
		/* 822473F4h case    7:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x3A0);
		/* 822473F4h case    7:*/		return 0x822473F8;
		  /* 822473F8h */ case    8:  		/* lwz R11, <#[R28]> */
		/* 822473F8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 822473F8h case    8:*/		return 0x822473FC;
		  /* 822473FCh */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 822473FCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822473FCh case    9:*/		return 0x82247400;
		  /* 82247400h */ case   10:  		/* bc 12, CR6_EQ, 44 */
		/* 82247400h case   10:*/		if ( regs.CR[6].eq ) { return 0x8224742C;  }
		/* 82247400h case   10:*/		return 0x82247404;
		  /* 82247404h */ case   11:  		/* mr R5, R30 */
		/* 82247404h case   11:*/		regs.R5 = regs.R30;
		/* 82247404h case   11:*/		return 0x82247408;
		  /* 82247408h */ case   12:  		/* ld R6, <#[R29]> */
		/* 82247408h case   12:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R29 + 0x00000000) );
		/* 82247408h case   12:*/		return 0x8224740C;
		  /* 8224740Ch */ case   13:  		/* lwz R4, <#[R31 + 56]> */
		/* 8224740Ch case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000038) );
		/* 8224740Ch case   13:*/		return 0x82247410;
		  /* 82247410h */ case   14:  		/* lwz R3, <#[R17]> */
		/* 82247410h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 82247410h case   14:*/		return 0x82247414;
		  /* 82247414h */ case   15:  		/* bl -173780 */
		/* 82247414h case   15:*/		regs.LR = 0x82247418; return 0x8221CD40;
		/* 82247414h case   15:*/		return 0x82247418;
		  /* 82247418h */ case   16:  		/* addi R30, R30, 1 */
		/* 82247418h case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82247418h case   16:*/		return 0x8224741C;
		  /* 8224741Ch */ case   17:  		/* addi R28, R28, 4 */
		/* 8224741Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8224741Ch case   17:*/		return 0x82247420;
		  /* 82247420h */ case   18:  		/* addi R29, R29, 8 */
		/* 82247420h case   18:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x8);
		/* 82247420h case   18:*/		return 0x82247424;
		  /* 82247424h */ case   19:  		/* cmpwi CR6, R30, 4 */
		/* 82247424h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 82247424h case   19:*/		return 0x82247428;
		  /* 82247428h */ case   20:  		/* bc 12, CR6_LT, -48 */
		/* 82247428h case   20:*/		if ( regs.CR[6].lt ) { return 0x822473F8;  }
		/* 82247428h case   20:*/		return 0x8224742C;
	}
	return 0x8224742C;
} // Block from 822473D8h-8224742Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224742Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224742C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224742C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224742C);
		  /* 8224742Ch */ case    0:  		/* lwz R8, <#[R23 + 4]> */
		/* 8224742Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000004) );
		/* 8224742Ch case    0:*/		return 0x82247430;
		  /* 82247430h */ case    1:  		/* addi R27, R27, 1 */
		/* 82247430h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82247430h case    1:*/		return 0x82247434;
		  /* 82247434h */ case    2:  		/* addi R26, R26, 4 */
		/* 82247434h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 82247434h case    2:*/		return 0x82247438;
		  /* 82247438h */ case    3:  		/* cmplw CR6, R27, R8 */
		/* 82247438h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R8);
		/* 82247438h case    3:*/		return 0x8224743C;
		  /* 8224743Ch */ case    4:  		/* bc 12, CR6_LT, -344 */
		/* 8224743Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x822472E4;  }
		/* 8224743Ch case    4:*/		return 0x82247440;
	}
	return 0x82247440;
} // Block from 8224742Ch-82247440h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82247440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247440);
		  /* 82247440h */ case    0:  		/* addi R1, R1, 432 */
		/* 82247440h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1B0);
		/* 82247440h case    0:*/		return 0x82247444;
		  /* 82247444h */ case    1:  		/* b -1794516 */
		/* 82247444h case    1:*/		return 0x82091270;
		/* 82247444h case    1:*/		return 0x82247448;
		  /* 82247448h */ case    2:  		/* lis R11, -32252 */
		/* 82247448h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82247448h case    2:*/		return 0x8224744C;
		  /* 8224744Ch */ case    3:  		/* mr R5, R4 */
		/* 8224744Ch case    3:*/		regs.R5 = regs.R4;
		/* 8224744Ch case    3:*/		return 0x82247450;
		  /* 82247450h */ case    4:  		/* li R4, 1 */
		/* 82247450h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82247450h case    4:*/		return 0x82247454;
		  /* 82247454h */ case    5:  		/* ld R8, <#[R11 + 27576]> */
		/* 82247454h case    5:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R11 + 0x00006BB8) );
		/* 82247454h case    5:*/		return 0x82247458;
		  /* 82247458h */ case    6:  		/* mr R7, R8 */
		/* 82247458h case    6:*/		regs.R7 = regs.R8;
		/* 82247458h case    6:*/		return 0x8224745C;
		  /* 8224745Ch */ case    7:  		/* mr R6, R8 */
		/* 8224745Ch case    7:*/		regs.R6 = regs.R8;
		/* 8224745Ch case    7:*/		return 0x82247460;
		  /* 82247460h */ case    8:  		/* b -7064 */
		/* 82247460h case    8:*/		return 0x822458C8;
		/* 82247460h case    8:*/		return 0x82247464;
		  /* 82247464h */ case    9:  		/* nop */
		/* 82247464h case    9:*/		cpu::op::nop();
		/* 82247464h case    9:*/		return 0x82247468;
		  /* 82247468h */ case   10:  		/* lis R11, -32252 */
		/* 82247468h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82247468h case   10:*/		return 0x8224746C;
		  /* 8224746Ch */ case   11:  		/* mr R6, R5 */
		/* 8224746Ch case   11:*/		regs.R6 = regs.R5;
		/* 8224746Ch case   11:*/		return 0x82247470;
		  /* 82247470h */ case   12:  		/* mr R5, R4 */
		/* 82247470h case   12:*/		regs.R5 = regs.R4;
		/* 82247470h case   12:*/		return 0x82247474;
		  /* 82247474h */ case   13:  		/* li R4, 2 */
		/* 82247474h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82247474h case   13:*/		return 0x82247478;
		  /* 82247478h */ case   14:  		/* ld R8, <#[R11 + 27576]> */
		/* 82247478h case   14:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R11 + 0x00006BB8) );
		/* 82247478h case   14:*/		return 0x8224747C;
		  /* 8224747Ch */ case   15:  		/* mr R7, R8 */
		/* 8224747Ch case   15:*/		regs.R7 = regs.R8;
		/* 8224747Ch case   15:*/		return 0x82247480;
		  /* 82247480h */ case   16:  		/* b -7096 */
		/* 82247480h case   16:*/		return 0x822458C8;
		/* 82247480h case   16:*/		return 0x82247484;
		  /* 82247484h */ case   17:  		/* nop */
		/* 82247484h case   17:*/		cpu::op::nop();
		/* 82247484h case   17:*/		return 0x82247488;
		  /* 82247488h */ case   18:  		/* lis R11, -32252 */
		/* 82247488h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82247488h case   18:*/		return 0x8224748C;
		  /* 8224748Ch */ case   19:  		/* mr R7, R6 */
		/* 8224748Ch case   19:*/		regs.R7 = regs.R6;
		/* 8224748Ch case   19:*/		return 0x82247490;
		  /* 82247490h */ case   20:  		/* mr R6, R5 */
		/* 82247490h case   20:*/		regs.R6 = regs.R5;
		/* 82247490h case   20:*/		return 0x82247494;
		  /* 82247494h */ case   21:  		/* mr R5, R4 */
		/* 82247494h case   21:*/		regs.R5 = regs.R4;
		/* 82247494h case   21:*/		return 0x82247498;
		  /* 82247498h */ case   22:  		/* li R4, 3 */
		/* 82247498h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 82247498h case   22:*/		return 0x8224749C;
		  /* 8224749Ch */ case   23:  		/* ld R8, <#[R11 + 27576]> */
		/* 8224749Ch case   23:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R11 + 0x00006BB8) );
		/* 8224749Ch case   23:*/		return 0x822474A0;
		  /* 822474A0h */ case   24:  		/* b -7128 */
		/* 822474A0h case   24:*/		return 0x822458C8;
		/* 822474A0h case   24:*/		return 0x822474A4;
		  /* 822474A4h */ case   25:  		/* nop */
		/* 822474A4h case   25:*/		cpu::op::nop();
		/* 822474A4h case   25:*/		return 0x822474A8;
		  /* 822474A8h */ case   26:  		/* mr R8, R7 */
		/* 822474A8h case   26:*/		regs.R8 = regs.R7;
		/* 822474A8h case   26:*/		return 0x822474AC;
		  /* 822474ACh */ case   27:  		/* mr R7, R6 */
		/* 822474ACh case   27:*/		regs.R7 = regs.R6;
		/* 822474ACh case   27:*/		return 0x822474B0;
		  /* 822474B0h */ case   28:  		/* mr R6, R5 */
		/* 822474B0h case   28:*/		regs.R6 = regs.R5;
		/* 822474B0h case   28:*/		return 0x822474B4;
		  /* 822474B4h */ case   29:  		/* mr R5, R4 */
		/* 822474B4h case   29:*/		regs.R5 = regs.R4;
		/* 822474B4h case   29:*/		return 0x822474B8;
		  /* 822474B8h */ case   30:  		/* li R4, 4 */
		/* 822474B8h case   30:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 822474B8h case   30:*/		return 0x822474BC;
		  /* 822474BCh */ case   31:  		/* b -7156 */
		/* 822474BCh case   31:*/		return 0x822458C8;
		/* 822474BCh case   31:*/		return 0x822474C0;
	}
	return 0x822474C0;
} // Block from 82247440h-822474C0h (32 instructions)

//////////////////////////////////////////////////////
// Block at 822474C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822474C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822474C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822474C0);
		  /* 822474C0h */ case    0:  		/* mfspr R12, LR */
		/* 822474C0h case    0:*/		regs.R12 = regs.LR;
		/* 822474C0h case    0:*/		return 0x822474C4;
		  /* 822474C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822474C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822474C4h case    1:*/		return 0x822474C8;
		  /* 822474C8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 822474C8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822474C8h case    2:*/		return 0x822474CC;
		  /* 822474CCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 822474CCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822474CCh case    3:*/		return 0x822474D0;
		  /* 822474D0h */ case    4:  		/* mr R4, R3 */
		/* 822474D0h case    4:*/		regs.R4 = regs.R3;
		/* 822474D0h case    4:*/		return 0x822474D4;
		  /* 822474D4h */ case    5:  		/* mr R31, R3 */
		/* 822474D4h case    5:*/		regs.R31 = regs.R3;
		/* 822474D4h case    5:*/		return 0x822474D8;
		  /* 822474D8h */ case    6:  		/* lwz R3, <#[R3 + 172]> */
		/* 822474D8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000000AC) );
		/* 822474D8h case    6:*/		return 0x822474DC;
		  /* 822474DCh */ case    7:  		/* bl -6276 */
		/* 822474DCh case    7:*/		regs.LR = 0x822474E0; return 0x82245C58;
		/* 822474DCh case    7:*/		return 0x822474E0;
		  /* 822474E0h */ case    8:  		/* lwz R10, <#[R31 + 12]> */
		/* 822474E0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 822474E0h case    8:*/		return 0x822474E4;
		  /* 822474E4h */ case    9:  		/* li R11, 1 */
		/* 822474E4h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822474E4h case    9:*/		return 0x822474E8;
		  /* 822474E8h */ case   10:  		/* stb R11, <#[R10 + 1392]> */
		/* 822474E8h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000570) );
		/* 822474E8h case   10:*/		return 0x822474EC;
		  /* 822474ECh */ case   11:  		/* addi R1, R1, 96 */
		/* 822474ECh case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822474ECh case   11:*/		return 0x822474F0;
		  /* 822474F0h */ case   12:  		/* lwz R12, <#[R1 - 8]> */
		/* 822474F0h case   12:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822474F0h case   12:*/		return 0x822474F4;
		  /* 822474F4h */ case   13:  		/* mtspr LR, R12 */
		/* 822474F4h case   13:*/		regs.LR = regs.R12;
		/* 822474F4h case   13:*/		return 0x822474F8;
		  /* 822474F8h */ case   14:  		/* ld R31, <#[R1 - 16]> */
		/* 822474F8h case   14:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822474F8h case   14:*/		return 0x822474FC;
		  /* 822474FCh */ case   15:  		/* bclr 20, CR0_LT */
		/* 822474FCh case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822474FCh case   15:*/		return 0x82247500;
	}
	return 0x82247500;
} // Block from 822474C0h-82247500h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82247500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247500);
		  /* 82247500h */ case    0:  		/* lwz R9, <#[R3 + 4]> */
		/* 82247500h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 82247500h case    0:*/		return 0x82247504;
		  /* 82247504h */ case    1:  		/* li R11, 0 */
		/* 82247504h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82247504h case    1:*/		return 0x82247508;
		  /* 82247508h */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 82247508h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82247508h case    2:*/		return 0x8224750C;
		  /* 8224750Ch */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 8224750Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8224753C;  }
		/* 8224750Ch case    3:*/		return 0x82247510;
		  /* 82247510h */ case    4:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 82247510h case    4:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 82247510h case    4:*/		return 0x82247514;
		  /* 82247514h */ case    5:  		/* rlwinm R8, R11, 0, 27, 31 */
		/* 82247514h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R11);
		/* 82247514h case    5:*/		return 0x82247518;
		  /* 82247518h */ case    6:  		/* addi R10, R10, 2 */
		/* 82247518h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82247518h case    6:*/		return 0x8224751C;
		  /* 8224751Ch */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8224751Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8224751Ch case    7:*/		return 0x82247520;
		  /* 82247520h */ case    8:  		/* lwzx R10, <#[R10 + R3]> */
		/* 82247520h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82247520h case    8:*/		return 0x82247524;
		  /* 82247524h */ case    9:  		/* srw R10, R10, R8 */
		/* 82247524h case    9:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82247524h case    9:*/		return 0x82247528;
		  /* 82247528h */ case   10:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82247528h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82247528h case   10:*/		return 0x8224752C;
		  /* 8224752Ch */ case   11:  		/* bc 4, CR0_EQ, 24 */
		/* 8224752Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x82247544;  }
		/* 8224752Ch case   11:*/		return 0x82247530;
		  /* 82247530h */ case   12:  		/* addi R11, R11, 1 */
		/* 82247530h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82247530h case   12:*/		return 0x82247534;
		  /* 82247534h */ case   13:  		/* cmplw CR6, R11, R9 */
		/* 82247534h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82247534h case   13:*/		return 0x82247538;
		  /* 82247538h */ case   14:  		/* bc 12, CR6_LT, -40 */
		/* 82247538h case   14:*/		if ( regs.CR[6].lt ) { return 0x82247510;  }
		/* 82247538h case   14:*/		return 0x8224753C;
	}
	return 0x8224753C;
} // Block from 82247500h-8224753Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224753Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224753C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224753C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224753C);
		  /* 8224753Ch */ case    0:  		/* li R3, -1 */
		/* 8224753Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8224753Ch case    0:*/		return 0x82247540;
		  /* 82247540h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82247540h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82247540h case    1:*/		return 0x82247544;
	}
	return 0x82247544;
} // Block from 8224753Ch-82247544h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82247544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247544);
		  /* 82247544h */ case    0:  		/* mr R3, R11 */
		/* 82247544h case    0:*/		regs.R3 = regs.R11;
		/* 82247544h case    0:*/		return 0x82247548;
		  /* 82247548h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82247548h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82247548h case    1:*/		return 0x8224754C;
	}
	return 0x8224754C;
} // Block from 82247544h-8224754Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224754Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224754C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224754C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224754C);
		  /* 8224754Ch */ case    0:  		/* nop */
		/* 8224754Ch case    0:*/		cpu::op::nop();
		/* 8224754Ch case    0:*/		return 0x82247550;
		  /* 82247550h */ case    1:  		/* rlwinm R10, R4, 27, 5, 31 */
		/* 82247550h case    1:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R4);
		/* 82247550h case    1:*/		return 0x82247554;
		  /* 82247554h */ case    2:  		/* lwz R11, <#[R3 + 2140]> */
		/* 82247554h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000085C) );
		/* 82247554h case    2:*/		return 0x82247558;
		  /* 82247558h */ case    3:  		/* li R8, 1 */
		/* 82247558h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82247558h case    3:*/		return 0x8224755C;
		  /* 8224755Ch */ case    4:  		/* addi R10, R10, 2 */
		/* 8224755Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8224755Ch case    4:*/		return 0x82247560;
		  /* 82247560h */ case    5:  		/* rlwinm R9, R4, 0, 27, 31 */
		/* 82247560h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R4);
		/* 82247560h case    5:*/		return 0x82247564;
		  /* 82247564h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82247564h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82247564h case    6:*/		return 0x82247568;
		  /* 82247568h */ case    7:  		/* slw R9, R8, R9 */
		/* 82247568h case    7:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82247568h case    7:*/		return 0x8224756C;
		  /* 8224756Ch */ case    8:  		/* lwzx R8, <#[R10 + R11]> */
		/* 8224756Ch case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224756Ch case    8:*/		return 0x82247570;
		  /* 82247570h */ case    9:  		/* andc R9, R8, R9 */
		/* 82247570h case    9:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82247570h case    9:*/		return 0x82247574;
		  /* 82247574h */ case   10:  		/* stwx R9, <#[R10 + R11]> */
		/* 82247574h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82247574h case   10:*/		return 0x82247578;
		  /* 82247578h */ case   11:  		/* bclr 20, CR0_LT */
		/* 82247578h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82247578h case   11:*/		return 0x8224757C;
	}
	return 0x8224757C;
} // Block from 8224754Ch-8224757Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224757Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224757C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224757C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224757C);
		  /* 8224757Ch */ case    0:  		/* nop */
		/* 8224757Ch case    0:*/		cpu::op::nop();
		/* 8224757Ch case    0:*/		return 0x82247580;
		  /* 82247580h */ case    1:  		/* rlwinm R11, R4, 27, 5, 31 */
		/* 82247580h case    1:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R4);
		/* 82247580h case    1:*/		return 0x82247584;
		  /* 82247584h */ case    2:  		/* lwz R10, <#[R3 + 2140]> */
		/* 82247584h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000085C) );
		/* 82247584h case    2:*/		return 0x82247588;
		  /* 82247588h */ case    3:  		/* rlwinm R9, R4, 0, 27, 31 */
		/* 82247588h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R4);
		/* 82247588h case    3:*/		return 0x8224758C;
		  /* 8224758Ch */ case    4:  		/* addi R11, R11, 2 */
		/* 8224758Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8224758Ch case    4:*/		return 0x82247590;
		  /* 82247590h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82247590h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82247590h case    5:*/		return 0x82247594;
		  /* 82247594h */ case    6:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82247594h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82247594h case    6:*/		return 0x82247598;
		  /* 82247598h */ case    7:  		/* srw R11, R11, R9 */
		/* 82247598h case    7:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82247598h case    7:*/		return 0x8224759C;
		  /* 8224759Ch */ case    8:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 8224759Ch case    8:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224759Ch case    8:*/		return 0x822475A0;
		  /* 822475A0h */ case    9:  		/* neg R10, R11 */
		/* 822475A0h case    9:*/		cpu::op::neg<0>(regs,&regs.R10,regs.R11);
		/* 822475A0h case    9:*/		return 0x822475A4;
		  /* 822475A4h */ case   10:  		/* andc R11, R10, R11 */
		/* 822475A4h case   10:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822475A4h case   10:*/		return 0x822475A8;
		  /* 822475A8h */ case   11:  		/* rlwinm R3, R11, 1, 31, 31 */
		/* 822475A8h case   11:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R3,regs.R11);
		/* 822475A8h case   11:*/		return 0x822475AC;
		  /* 822475ACh */ case   12:  		/* bclr 20, CR0_LT */
		/* 822475ACh case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822475ACh case   12:*/		return 0x822475B0;
	}
	return 0x822475B0;
} // Block from 8224757Ch-822475B0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822475B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822475B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822475B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822475B0);
		  /* 822475B0h */ case    0:  		/* rlwinm R10, R4, 27, 5, 31 */
		/* 822475B0h case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R4);
		/* 822475B0h case    0:*/		return 0x822475B4;
		  /* 822475B4h */ case    1:  		/* lwz R11, <#[R3 + 2136]> */
		/* 822475B4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000858) );
		/* 822475B4h case    1:*/		return 0x822475B8;
		  /* 822475B8h */ case    2:  		/* li R8, 1 */
		/* 822475B8h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 822475B8h case    2:*/		return 0x822475BC;
		  /* 822475BCh */ case    3:  		/* addi R10, R10, 2 */
		/* 822475BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 822475BCh case    3:*/		return 0x822475C0;
		  /* 822475C0h */ case    4:  		/* rlwinm R9, R4, 0, 27, 31 */
		/* 822475C0h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R4);
		/* 822475C0h case    4:*/		return 0x822475C4;
		  /* 822475C4h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822475C4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822475C4h case    5:*/		return 0x822475C8;
		  /* 822475C8h */ case    6:  		/* slw R9, R8, R9 */
		/* 822475C8h case    6:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 822475C8h case    6:*/		return 0x822475CC;
		  /* 822475CCh */ case    7:  		/* lwzx R8, <#[R10 + R11]> */
		/* 822475CCh case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822475CCh case    7:*/		return 0x822475D0;
		  /* 822475D0h */ case    8:  		/* andc R9, R8, R9 */
		/* 822475D0h case    8:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 822475D0h case    8:*/		return 0x822475D4;
		  /* 822475D4h */ case    9:  		/* stwx R9, <#[R10 + R11]> */
		/* 822475D4h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822475D4h case    9:*/		return 0x822475D8;
		  /* 822475D8h */ case   10:  		/* bclr 20, CR0_LT */
		/* 822475D8h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822475D8h case   10:*/		return 0x822475DC;
	}
	return 0x822475DC;
} // Block from 822475B0h-822475DCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 822475DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822475DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822475DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822475DC);
		  /* 822475DCh */ case    0:  		/* nop */
		/* 822475DCh case    0:*/		cpu::op::nop();
		/* 822475DCh case    0:*/		return 0x822475E0;
		  /* 822475E0h */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 822475E0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822475E0h case    1:*/		return 0x822475E4;
		  /* 822475E4h */ case    2:  		/* lwz R9, <#[R3]> */
		/* 822475E4h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 822475E4h case    2:*/		return 0x822475E8;
		  /* 822475E8h */ case    3:  		/* add R10, R4, R11 */
		/* 822475E8h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R4,regs.R11);
		/* 822475E8h case    3:*/		return 0x822475EC;
		  /* 822475ECh */ case    4:  		/* addi R11, R10, 31 */
		/* 822475ECh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1F);
		/* 822475ECh case    4:*/		return 0x822475F0;
		  /* 822475F0h */ case    5:  		/* rlwinm R11, R11, 27, 5, 31 */
		/* 822475F0h case    5:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R11);
		/* 822475F0h case    5:*/		return 0x822475F4;
		  /* 822475F4h */ case    6:  		/* cmplw CR6, R11, R9 */
		/* 822475F4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 822475F4h case    6:*/		return 0x822475F8;
		  /* 822475F8h */ case    7:  		/* bc 4, CR6_EQ, 76 */
		/* 822475F8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82247644;  }
		/* 822475F8h case    7:*/		return 0x822475FC;
		  /* 822475FCh */ case    8:  		/* subf R11, R4, R10 */
		/* 822475FCh case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R4,regs.R10);
		/* 822475FCh case    8:*/		return 0x82247600;
		  /* 82247600h */ case    9:  		/* stw R10, <#[R3 + 4]> */
		/* 82247600h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82247600h case    9:*/		return 0x82247604;
		  /* 82247604h */ case   10:  		/* b 48 */
		/* 82247604h case   10:*/		return 0x82247634;
		/* 82247604h case   10:*/		return 0x82247608;
		  /* 82247608h */ case   11:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 82247608h case   11:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 82247608h case   11:*/		return 0x8224760C;
		  /* 8224760Ch */ case   12:  		/* rlwinm R9, R11, 0, 27, 31 */
		/* 8224760Ch case   12:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R11);
		/* 8224760Ch case   12:*/		return 0x82247610;
		  /* 82247610h */ case   13:  		/* addi R10, R10, 2 */
		/* 82247610h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82247610h case   13:*/		return 0x82247614;
		  /* 82247614h */ case   14:  		/* li R8, 1 */
		/* 82247614h case   14:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82247614h case   14:*/		return 0x82247618;
		  /* 82247618h */ case   15:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82247618h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82247618h case   15:*/		return 0x8224761C;
		  /* 8224761Ch */ case   16:  		/* slw R9, R8, R9 */
		/* 8224761Ch case   16:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8224761Ch case   16:*/		return 0x82247620;
		  /* 82247620h */ case   17:  		/* lwzx R8, <#[R10 + R3]> */
		/* 82247620h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82247620h case   17:*/		return 0x82247624;
		  /* 82247624h */ case   18:  		/* addi R11, R11, 1 */
		/* 82247624h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82247624h case   18:*/		return 0x82247628;
		  /* 82247628h */ case   19:  		/* andc R9, R8, R9 */
		/* 82247628h case   19:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82247628h case   19:*/		return 0x8224762C;
		  /* 8224762Ch */ case   20:  		/* stwx R9, <#[R10 + R3]> */
		/* 8224762Ch case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8224762Ch case   20:*/		return 0x82247630;
		  /* 82247630h */ case   21:  		/* lwz R10, <#[R3 + 4]> */
		/* 82247630h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82247630h case   21:*/		return 0x82247634;
	}
	return 0x82247634;
} // Block from 822475DCh-82247634h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82247634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247634);
		  /* 82247634h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 82247634h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82247634h case    0:*/		return 0x82247638;
		  /* 82247638h */ case    1:  		/* bc 12, CR6_LT, -48 */
		/* 82247638h case    1:*/		if ( regs.CR[6].lt ) { return 0x82247608;  }
		/* 82247638h case    1:*/		return 0x8224763C;
		  /* 8224763Ch */ case    2:  		/* li R3, 1 */
		/* 8224763Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8224763Ch case    2:*/		return 0x82247640;
		  /* 82247640h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82247640h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82247640h case    3:*/		return 0x82247644;
	}
	return 0x82247644;
} // Block from 82247634h-82247644h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82247644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247644);
		  /* 82247644h */ case    0:  		/* li R3, 0 */
		/* 82247644h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82247644h case    0:*/		return 0x82247648;
		  /* 82247648h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82247648h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82247648h case    1:*/		return 0x8224764C;
	}
	return 0x8224764C;
} // Block from 82247644h-8224764Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224764Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224764C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224764C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224764C);
		  /* 8224764Ch */ case    0:  		/* nop */
		/* 8224764Ch case    0:*/		cpu::op::nop();
		/* 8224764Ch case    0:*/		return 0x82247650;
	}
	return 0x82247650;
} // Block from 8224764Ch-82247650h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247650);
		  /* 82247650h */ case    0:  		/* mfspr R12, LR */
		/* 82247650h case    0:*/		regs.R12 = regs.LR;
		/* 82247650h case    0:*/		return 0x82247654;
		  /* 82247654h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82247654h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82247654h case    1:*/		return 0x82247658;
		  /* 82247658h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82247658h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82247658h case    2:*/		return 0x8224765C;
		  /* 8224765Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8224765Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8224765Ch case    3:*/		return 0x82247660;
		  /* 82247660h */ case    4:  		/* rlwinm R11, R4, 27, 5, 31 */
		/* 82247660h case    4:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R4);
		/* 82247660h case    4:*/		return 0x82247664;
		  /* 82247664h */ case    5:  		/* lwz R10, <#[R3 + 16]> */
		/* 82247664h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82247664h case    5:*/		return 0x82247668;
		  /* 82247668h */ case    6:  		/* rlwinm R9, R4, 0, 27, 31 */
		/* 82247668h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R4);
		/* 82247668h case    6:*/		return 0x8224766C;
		  /* 8224766Ch */ case    7:  		/* addi R11, R11, 2 */
		/* 8224766Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8224766Ch case    7:*/		return 0x82247670;
		  /* 82247670h */ case    8:  		/* mr R31, R4 */
		/* 82247670h case    8:*/		regs.R31 = regs.R4;
		/* 82247670h case    8:*/		return 0x82247674;
		  /* 82247674h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82247674h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82247674h case    9:*/		return 0x82247678;
		  /* 82247678h */ case   10:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82247678h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82247678h case   10:*/		return 0x8224767C;
		  /* 8224767Ch */ case   11:  		/* srw R11, R11, R9 */
		/* 8224767Ch case   11:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8224767Ch case   11:*/		return 0x82247680;
		  /* 82247680h */ case   12:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82247680h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82247680h case   12:*/		return 0x82247684;
		  /* 82247684h */ case   13:  		/* bc 4, CR0_EQ, 16 */
		/* 82247684h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82247694;  }
		/* 82247684h case   13:*/		return 0x82247688;
		  /* 82247688h */ case   14:  		/* lwz R4, <#[R3 + 4]> */
		/* 82247688h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82247688h case   14:*/		return 0x8224768C;
		  /* 8224768Ch */ case   15:  		/* bl 50228 */
		/* 8224768Ch case   15:*/		regs.LR = 0x82247690; return 0x82253AC0;
		/* 8224768Ch case   15:*/		return 0x82247690;
		  /* 82247690h */ case   16:  		/* stw R31, <#[R3]> */
		/* 82247690h case   16:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82247690h case   16:*/		return 0x82247694;
	}
	return 0x82247694;
} // Block from 82247650h-82247694h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82247694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247694);
		  /* 82247694h */ case    0:  		/* addi R1, R1, 96 */
		/* 82247694h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82247694h case    0:*/		return 0x82247698;
		  /* 82247698h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82247698h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82247698h case    1:*/		return 0x8224769C;
		  /* 8224769Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8224769Ch case    2:*/		regs.LR = regs.R12;
		/* 8224769Ch case    2:*/		return 0x822476A0;
		  /* 822476A0h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 822476A0h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822476A0h case    3:*/		return 0x822476A4;
		  /* 822476A4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 822476A4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822476A4h case    4:*/		return 0x822476A8;
	}
	return 0x822476A8;
} // Block from 82247694h-822476A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822476A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822476A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822476A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822476A8);
		  /* 822476A8h */ case    0:  		/* mfspr R12, LR */
		/* 822476A8h case    0:*/		regs.R12 = regs.LR;
		/* 822476A8h case    0:*/		return 0x822476AC;
		  /* 822476ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822476ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822476ACh case    1:*/		return 0x822476B0;
		  /* 822476B0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 822476B0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822476B0h case    2:*/		return 0x822476B4;
		  /* 822476B4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 822476B4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822476B4h case    3:*/		return 0x822476B8;
		  /* 822476B8h */ case    4:  		/* mr R31, R3 */
		/* 822476B8h case    4:*/		regs.R31 = regs.R3;
		/* 822476B8h case    4:*/		return 0x822476BC;
		  /* 822476BCh */ case    5:  		/* bl 79508 */
		/* 822476BCh case    5:*/		regs.LR = 0x822476C0; return 0x8225AD50;
		/* 822476BCh case    5:*/		return 0x822476C0;
		  /* 822476C0h */ case    6:  		/* rlwinm R10, R3, 27, 5, 31 */
		/* 822476C0h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R3);
		/* 822476C0h case    6:*/		return 0x822476C4;
		  /* 822476C4h */ case    7:  		/* lwz R11, <#[R31 + 16]> */
		/* 822476C4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 822476C4h case    7:*/		return 0x822476C8;
		  /* 822476C8h */ case    8:  		/* rlwinm R8, R3, 0, 27, 31 */
		/* 822476C8h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R3);
		/* 822476C8h case    8:*/		return 0x822476CC;
		  /* 822476CCh */ case    9:  		/* addi R10, R10, 2 */
		/* 822476CCh case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 822476CCh case    9:*/		return 0x822476D0;
		  /* 822476D0h */ case   10:  		/* li R9, 1 */
		/* 822476D0h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 822476D0h case   10:*/		return 0x822476D4;
		  /* 822476D4h */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822476D4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822476D4h case   11:*/		return 0x822476D8;
		  /* 822476D8h */ case   12:  		/* slw R9, R9, R8 */
		/* 822476D8h case   12:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 822476D8h case   12:*/		return 0x822476DC;
		  /* 822476DCh */ case   13:  		/* lwzx R8, <#[R10 + R11]> */
		/* 822476DCh case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822476DCh case   13:*/		return 0x822476E0;
		  /* 822476E0h */ case   14:  		/* andc R9, R8, R9 */
		/* 822476E0h case   14:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 822476E0h case   14:*/		return 0x822476E4;
		  /* 822476E4h */ case   15:  		/* stwx R9, <#[R10 + R11]> */
		/* 822476E4h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822476E4h case   15:*/		return 0x822476E8;
		  /* 822476E8h */ case   16:  		/* addi R1, R1, 96 */
		/* 822476E8h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822476E8h case   16:*/		return 0x822476EC;
		  /* 822476ECh */ case   17:  		/* lwz R12, <#[R1 - 8]> */
		/* 822476ECh case   17:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822476ECh case   17:*/		return 0x822476F0;
		  /* 822476F0h */ case   18:  		/* mtspr LR, R12 */
		/* 822476F0h case   18:*/		regs.LR = regs.R12;
		/* 822476F0h case   18:*/		return 0x822476F4;
		  /* 822476F4h */ case   19:  		/* ld R31, <#[R1 - 16]> */
		/* 822476F4h case   19:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822476F4h case   19:*/		return 0x822476F8;
		  /* 822476F8h */ case   20:  		/* bclr 20, CR0_LT */
		/* 822476F8h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822476F8h case   20:*/		return 0x822476FC;
	}
	return 0x822476FC;
} // Block from 822476A8h-822476FCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 822476FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822476FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822476FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822476FC);
		  /* 822476FCh */ case    0:  		/* nop */
		/* 822476FCh case    0:*/		cpu::op::nop();
		/* 822476FCh case    0:*/		return 0x82247700;
	}
	return 0x82247700;
} // Block from 822476FCh-82247700h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247700h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247700);
		  /* 82247700h */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 82247700h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82247700h case    0:*/		return 0x82247704;
		  /* 82247704h */ case    1:  		/* li R9, -1 */
		/* 82247704h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 82247704h case    1:*/		return 0x82247708;
		  /* 82247708h */ case    2:  		/* li R10, 0 */
		/* 82247708h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82247708h case    2:*/		return 0x8224770C;
		  /* 8224770Ch */ case    3:  		/* stw R9, <#[R3 + 2080]> */
		/* 8224770Ch case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000820) );
		/* 8224770Ch case    3:*/		return 0x82247710;
		  /* 82247710h */ case    4:  		/* lwz R11, <#[R11 + 1360]> */
		/* 82247710h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000550) );
		/* 82247710h case    4:*/		return 0x82247714;
		  /* 82247714h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82247714h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82247714h case    5:*/		return 0x82247718;
		  /* 82247718h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82247718h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82247718h case    6:*/		return 0x8224771C;
		  /* 8224771Ch */ case    7:  		/* bclr 4, CR6_GT */
		/* 8224771Ch case    7:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 8224771Ch case    7:*/		return 0x82247720;
	}
	return 0x82247720;
} // Block from 82247700h-82247720h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82247720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247720);
		  /* 82247720h */ case    0:  		/* lwz R9, <#[R3 + 2136]> */
		/* 82247720h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000858) );
		/* 82247720h case    0:*/		return 0x82247724;
		  /* 82247724h */ case    1:  		/* mtspr CTR, R11 */
		/* 82247724h case    1:*/		regs.CTR = regs.R11;
		/* 82247724h case    1:*/		return 0x82247728;
		  /* 82247728h */ case    2:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 82247728h case    2:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 82247728h case    2:*/		return 0x8224772C;
		  /* 8224772Ch */ case    3:  		/* rlwinm R8, R10, 0, 27, 31 */
		/* 8224772Ch case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R10);
		/* 8224772Ch case    3:*/		return 0x82247730;
		  /* 82247730h */ case    4:  		/* addi R11, R11, 2 */
		/* 82247730h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82247730h case    4:*/		return 0x82247734;
		  /* 82247734h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82247734h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82247734h case    5:*/		return 0x82247738;
		  /* 82247738h */ case    6:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82247738h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82247738h case    6:*/		return 0x8224773C;
		  /* 8224773Ch */ case    7:  		/* srw R11, R11, R8 */
		/* 8224773Ch case    7:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8224773Ch case    7:*/		return 0x82247740;
		  /* 82247740h */ case    8:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82247740h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82247740h case    8:*/		return 0x82247744;
		  /* 82247744h */ case    9:  		/* bc 12, CR0_GT, 24 */
		/* 82247744h case    9:*/		if ( regs.CR[0].gt ) { return 0x8224775C;  }
		/* 82247744h case    9:*/		return 0x82247748;
		  /* 82247748h */ case   10:  		/* lwz R11, <#[R3 + 2080]> */
		/* 82247748h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000820) );
		/* 82247748h case   10:*/		return 0x8224774C;
		  /* 8224774Ch */ case   11:  		/* cmpw CR6, R10, R11 */
		/* 8224774Ch case   11:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 8224774Ch case   11:*/		return 0x82247750;
		  /* 82247750h */ case   12:  		/* bc 4, CR6_GT, 8 */
		/* 82247750h case   12:*/		if ( !regs.CR[6].gt ) { return 0x82247758;  }
		/* 82247750h case   12:*/		return 0x82247754;
		  /* 82247754h */ case   13:  		/* mr R11, R10 */
		/* 82247754h case   13:*/		regs.R11 = regs.R10;
		/* 82247754h case   13:*/		return 0x82247758;
	}
	return 0x82247758;
} // Block from 82247720h-82247758h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82247758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247758);
		  /* 82247758h */ case    0:  		/* stw R11, <#[R3 + 2080]> */
		/* 82247758h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000820) );
		/* 82247758h case    0:*/		return 0x8224775C;
	}
	return 0x8224775C;
} // Block from 82247758h-8224775Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224775Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224775C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224775C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224775C);
		  /* 8224775Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 8224775Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8224775Ch case    0:*/		return 0x82247760;
		  /* 82247760h */ case    1:  		/* bc 16, CR0_LT, -56 */
		/* 82247760h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82247728;  }
		/* 82247760h case    1:*/		return 0x82247764;
		  /* 82247764h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82247764h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82247764h case    2:*/		return 0x82247768;
	}
	return 0x82247768;
} // Block from 8224775Ch-82247768h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82247768h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247768);
		  /* 82247768h */ case    0:  		/* mfspr R12, LR */
		/* 82247768h case    0:*/		regs.R12 = regs.LR;
		/* 82247768h case    0:*/		return 0x8224776C;
		  /* 8224776Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224776Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224776Ch case    1:*/		return 0x82247770;
		  /* 82247770h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82247770h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82247770h case    2:*/		return 0x82247774;
		  /* 82247774h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82247774h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82247774h case    3:*/		return 0x82247778;
		  /* 82247778h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82247778h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82247778h case    4:*/		return 0x8224777C;
		  /* 8224777Ch */ case    5:  		/* mr R30, R3 */
		/* 8224777Ch case    5:*/		regs.R30 = regs.R3;
		/* 8224777Ch case    5:*/		return 0x82247780;
		  /* 82247780h */ case    6:  		/* lwz R3, <#[R3 + 2136]> */
		/* 82247780h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000858) );
		/* 82247780h case    6:*/		return 0x82247784;
		  /* 82247784h */ case    7:  		/* bl -644 */
		/* 82247784h case    7:*/		regs.LR = 0x82247788; return 0x82247500;
		/* 82247784h case    7:*/		return 0x82247788;
		  /* 82247788h */ case    8:  		/* mr R31, R3 */
		/* 82247788h case    8:*/		regs.R31 = regs.R3;
		/* 82247788h case    8:*/		return 0x8224778C;
		  /* 8224778Ch */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 8224778Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8224778Ch case    9:*/		return 0x82247790;
		  /* 82247790h */ case   10:  		/* bc 4, CR6_EQ, 40 */
		/* 82247790h case   10:*/		if ( !regs.CR[6].eq ) { return 0x822477B8;  }
		/* 82247790h case   10:*/		return 0x82247794;
		  /* 82247794h */ case   11:  		/* lis R11, -32252 */
		/* 82247794h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82247794h case   11:*/		return 0x82247798;
		  /* 82247798h */ case   12:  		/* lis R10, -32252 */
		/* 82247798h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82247798h case   12:*/		return 0x8224779C;
		  /* 8224779Ch */ case   13:  		/* lis R9, -32253 */
		/* 8224779Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224779Ch case   13:*/		return 0x822477A0;
		  /* 822477A0h */ case   14:  		/* addi R6, R11, 12848 */
		/* 822477A0h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3230);
		/* 822477A0h case   14:*/		return 0x822477A4;
		  /* 822477A4h */ case   15:  		/* addi R5, R10, 12840 */
		/* 822477A4h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x3228);
		/* 822477A4h case   15:*/		return 0x822477A8;
		  /* 822477A8h */ case   16:  		/* addi R4, R9, 27460 */
		/* 822477A8h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 822477A8h case   16:*/		return 0x822477AC;
		  /* 822477ACh */ case   17:  		/* li R7, 550 */
		/* 822477ACh case   17:*/		cpu::op::li<0>(regs,&regs.R7,0x226);
		/* 822477ACh case   17:*/		return 0x822477B0;
		  /* 822477B0h */ case   18:  		/* li R3, 0 */
		/* 822477B0h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822477B0h case   18:*/		return 0x822477B4;
		  /* 822477B4h */ case   19:  		/* bl -981932 */
		/* 822477B4h case   19:*/		regs.LR = 0x822477B8; return 0x82157C08;
		/* 822477B4h case   19:*/		return 0x822477B8;
	}
	return 0x822477B8;
} // Block from 82247768h-822477B8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822477B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822477B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822477B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822477B8);
		  /* 822477B8h */ case    0:  		/* rlwinm R10, R31, 27, 5, 31 */
		/* 822477B8h case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R31);
		/* 822477B8h case    0:*/		return 0x822477BC;
		  /* 822477BCh */ case    1:  		/* lwz R11, <#[R30 + 2136]> */
		/* 822477BCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000858) );
		/* 822477BCh case    1:*/		return 0x822477C0;
		  /* 822477C0h */ case    2:  		/* li R8, 1 */
		/* 822477C0h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 822477C0h case    2:*/		return 0x822477C4;
		  /* 822477C4h */ case    3:  		/* addi R10, R10, 2 */
		/* 822477C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 822477C4h case    3:*/		return 0x822477C8;
		  /* 822477C8h */ case    4:  		/* rlwinm R9, R31, 0, 27, 31 */
		/* 822477C8h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R31);
		/* 822477C8h case    4:*/		return 0x822477CC;
		  /* 822477CCh */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822477CCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822477CCh case    5:*/		return 0x822477D0;
		  /* 822477D0h */ case    6:  		/* slw R9, R8, R9 */
		/* 822477D0h case    6:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 822477D0h case    6:*/		return 0x822477D4;
		  /* 822477D4h */ case    7:  		/* lwzx R8, <#[R10 + R11]> */
		/* 822477D4h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822477D4h case    7:*/		return 0x822477D8;
		  /* 822477D8h */ case    8:  		/* mr R3, R31 */
		/* 822477D8h case    8:*/		regs.R3 = regs.R31;
		/* 822477D8h case    8:*/		return 0x822477DC;
		  /* 822477DCh */ case    9:  		/* andc R9, R8, R9 */
		/* 822477DCh case    9:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 822477DCh case    9:*/		return 0x822477E0;
		  /* 822477E0h */ case   10:  		/* stwx R9, <#[R10 + R11]> */
		/* 822477E0h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822477E0h case   10:*/		return 0x822477E4;
		  /* 822477E4h */ case   11:  		/* addi R1, R1, 112 */
		/* 822477E4h case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822477E4h case   11:*/		return 0x822477E8;
		  /* 822477E8h */ case   12:  		/* lwz R12, <#[R1 - 8]> */
		/* 822477E8h case   12:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822477E8h case   12:*/		return 0x822477EC;
		  /* 822477ECh */ case   13:  		/* mtspr LR, R12 */
		/* 822477ECh case   13:*/		regs.LR = regs.R12;
		/* 822477ECh case   13:*/		return 0x822477F0;
		  /* 822477F0h */ case   14:  		/* ld R30, <#[R1 - 24]> */
		/* 822477F0h case   14:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822477F0h case   14:*/		return 0x822477F4;
		  /* 822477F4h */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 822477F4h case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822477F4h case   15:*/		return 0x822477F8;
		  /* 822477F8h */ case   16:  		/* bclr 20, CR0_LT */
		/* 822477F8h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822477F8h case   16:*/		return 0x822477FC;
	}
	return 0x822477FC;
} // Block from 822477B8h-822477FCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 822477FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822477FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822477FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822477FC);
		  /* 822477FCh */ case    0:  		/* nop */
		/* 822477FCh case    0:*/		cpu::op::nop();
		/* 822477FCh case    0:*/		return 0x82247800;
	}
	return 0x82247800;
} // Block from 822477FCh-82247800h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247800);
		  /* 82247800h */ case    0:  		/* mfspr R12, LR */
		/* 82247800h case    0:*/		regs.R12 = regs.LR;
		/* 82247800h case    0:*/		return 0x82247804;
		  /* 82247804h */ case    1:  		/* bl -1795496 */
		/* 82247804h case    1:*/		regs.LR = 0x82247808; return 0x8209125C;
		/* 82247804h case    1:*/		return 0x82247808;
		  /* 82247808h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82247808h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82247808h case    2:*/		return 0x8224780C;
		  /* 8224780Ch */ case    3:  		/* rlwinm R11, R4, 27, 5, 31 */
		/* 8224780Ch case    3:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R4);
		/* 8224780Ch case    3:*/		return 0x82247810;
		  /* 82247810h */ case    4:  		/* lwz R10, <#[R3 + 2136]> */
		/* 82247810h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000858) );
		/* 82247810h case    4:*/		return 0x82247814;
		  /* 82247814h */ case    5:  		/* rlwinm R30, R4, 0, 27, 31 */
		/* 82247814h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R30,regs.R4);
		/* 82247814h case    5:*/		return 0x82247818;
		  /* 82247818h */ case    6:  		/* addi R11, R11, 2 */
		/* 82247818h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82247818h case    6:*/		return 0x8224781C;
		  /* 8224781Ch */ case    7:  		/* mr R29, R3 */
		/* 8224781Ch case    7:*/		regs.R29 = regs.R3;
		/* 8224781Ch case    7:*/		return 0x82247820;
		  /* 82247820h */ case    8:  		/* rlwinm R31, R11, 2, 0, 29 */
		/* 82247820h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R11);
		/* 82247820h case    8:*/		return 0x82247824;
		  /* 82247824h */ case    9:  		/* lwzx R11, <#[R10 + R31]> */
		/* 82247824h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82247824h case    9:*/		return 0x82247828;
		  /* 82247828h */ case   10:  		/* srw R11, R11, R30 */
		/* 82247828h case   10:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82247828h case   10:*/		return 0x8224782C;
		  /* 8224782Ch */ case   11:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224782Ch case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224782Ch case   11:*/		return 0x82247830;
		  /* 82247830h */ case   12:  		/* bc 4, CR0_GT, 40 */
		/* 82247830h case   12:*/		if ( !regs.CR[0].gt ) { return 0x82247858;  }
		/* 82247830h case   12:*/		return 0x82247834;
		  /* 82247834h */ case   13:  		/* lis R11, -32252 */
		/* 82247834h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82247834h case   13:*/		return 0x82247838;
		  /* 82247838h */ case   14:  		/* lis R10, -32252 */
		/* 82247838h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82247838h case   14:*/		return 0x8224783C;
		  /* 8224783Ch */ case   15:  		/* lis R9, -32253 */
		/* 8224783Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224783Ch case   15:*/		return 0x82247840;
		  /* 82247840h */ case   16:  		/* addi R6, R11, 12848 */
		/* 82247840h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3230);
		/* 82247840h case   16:*/		return 0x82247844;
		  /* 82247844h */ case   17:  		/* addi R5, R10, 12948 */
		/* 82247844h case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x3294);
		/* 82247844h case   17:*/		return 0x82247848;
		  /* 82247848h */ case   18:  		/* addi R4, R9, 27460 */
		/* 82247848h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82247848h case   18:*/		return 0x8224784C;
		  /* 8224784Ch */ case   19:  		/* li R7, 564 */
		/* 8224784Ch case   19:*/		cpu::op::li<0>(regs,&regs.R7,0x234);
		/* 8224784Ch case   19:*/		return 0x82247850;
		  /* 82247850h */ case   20:  		/* li R3, 0 */
		/* 82247850h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82247850h case   20:*/		return 0x82247854;
		  /* 82247854h */ case   21:  		/* bl -982092 */
		/* 82247854h case   21:*/		regs.LR = 0x82247858; return 0x82157C08;
		/* 82247854h case   21:*/		return 0x82247858;
	}
	return 0x82247858;
} // Block from 82247800h-82247858h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82247858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247858);
		  /* 82247858h */ case    0:  		/* lwz R11, <#[R29 + 2136]> */
		/* 82247858h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000858) );
		/* 82247858h case    0:*/		return 0x8224785C;
		  /* 8224785Ch */ case    1:  		/* li R10, 1 */
		/* 8224785Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8224785Ch case    1:*/		return 0x82247860;
		  /* 82247860h */ case    2:  		/* slw R10, R10, R30 */
		/* 82247860h case    2:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 82247860h case    2:*/		return 0x82247864;
		  /* 82247864h */ case    3:  		/* lwzx R9, <#[R31 + R11]> */
		/* 82247864h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82247864h case    3:*/		return 0x82247868;
		  /* 82247868h */ case    4:  		/* or R10, R10, R9 */
		/* 82247868h case    4:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82247868h case    4:*/		return 0x8224786C;
		  /* 8224786Ch */ case    5:  		/* stwx R10, <#[R31 + R11]> */
		/* 8224786Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8224786Ch case    5:*/		return 0x82247870;
		  /* 82247870h */ case    6:  		/* addi R1, R1, 112 */
		/* 82247870h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82247870h case    6:*/		return 0x82247874;
		  /* 82247874h */ case    7:  		/* b -1795528 */
		/* 82247874h case    7:*/		return 0x820912AC;
		/* 82247874h case    7:*/		return 0x82247878;
	}
	return 0x82247878;
} // Block from 82247858h-82247878h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82247878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247878);
		  /* 82247878h */ case    0:  		/* mfspr R12, LR */
		/* 82247878h case    0:*/		regs.R12 = regs.LR;
		/* 82247878h case    0:*/		return 0x8224787C;
		  /* 8224787Ch */ case    1:  		/* bl -1795660 */
		/* 8224787Ch case    1:*/		regs.LR = 0x82247880; return 0x82091230;
		/* 8224787Ch case    1:*/		return 0x82247880;
		  /* 82247880h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 82247880h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 82247880h case    2:*/		return 0x82247884;
		  /* 82247884h */ case    3:  		/* mr R29, R3 */
		/* 82247884h case    3:*/		regs.R29 = regs.R3;
		/* 82247884h case    3:*/		return 0x82247888;
		  /* 82247888h */ case    4:  		/* mr R25, R4 */
		/* 82247888h case    4:*/		regs.R25 = regs.R4;
		/* 82247888h case    4:*/		return 0x8224788C;
		  /* 8224788Ch */ case    5:  		/* mr R28, R5 */
		/* 8224788Ch case    5:*/		regs.R28 = regs.R5;
		/* 8224788Ch case    5:*/		return 0x82247890;
		  /* 82247890h */ case    6:  		/* mr R19, R6 */
		/* 82247890h case    6:*/		regs.R19 = regs.R6;
		/* 82247890h case    6:*/		return 0x82247894;
		  /* 82247894h */ case    7:  		/* mr R24, R7 */
		/* 82247894h case    7:*/		regs.R24 = regs.R7;
		/* 82247894h case    7:*/		return 0x82247898;
		  /* 82247898h */ case    8:  		/* li R31, 0 */
		/* 82247898h case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82247898h case    8:*/		return 0x8224789C;
		  /* 8224789Ch */ case    9:  		/* cmpwi CR6, R5, 0 */
		/* 8224789Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8224789Ch case    9:*/		return 0x822478A0;
		  /* 822478A0h */ case   10:  		/* bc 4, CR6_GT, 56 */
		/* 822478A0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x822478D8;  }
		/* 822478A0h case   10:*/		return 0x822478A4;
		  /* 822478A4h */ case   11:  		/* li R30, 0 */
		/* 822478A4h case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822478A4h case   11:*/		return 0x822478A8;
		  /* 822478A8h */ case   12:  		/* cmpwi CR6, R31, 0 */
		/* 822478A8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 822478A8h case   12:*/		return 0x822478AC;
		  /* 822478ACh */ case   13:  		/* bc 4, CR6_GT, 32 */
		/* 822478ACh case   13:*/		if ( !regs.CR[6].gt ) { return 0x822478CC;  }
		/* 822478ACh case   13:*/		return 0x822478B0;
		  /* 822478B0h */ case   14:  		/* mr R5, R30 */
		/* 822478B0h case   14:*/		regs.R5 = regs.R30;
		/* 822478B0h case   14:*/		return 0x822478B4;
		  /* 822478B4h */ case   15:  		/* mr R4, R31 */
		/* 822478B4h case   15:*/		regs.R4 = regs.R31;
		/* 822478B4h case   15:*/		return 0x822478B8;
		  /* 822478B8h */ case   16:  		/* mr R3, R25 */
		/* 822478B8h case   16:*/		regs.R3 = regs.R25;
		/* 822478B8h case   16:*/		return 0x822478BC;
		  /* 822478BCh */ case   17:  		/* bl 118884 */
		/* 822478BCh case   17:*/		regs.LR = 0x822478C0; return 0x82264920;
		/* 822478BCh case   17:*/		return 0x822478C0;
		  /* 822478C0h */ case   18:  		/* addi R30, R30, 1 */
		/* 822478C0h case   18:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822478C0h case   18:*/		return 0x822478C4;
		  /* 822478C4h */ case   19:  		/* cmpw CR6, R30, R31 */
		/* 822478C4h case   19:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R31);
		/* 822478C4h case   19:*/		return 0x822478C8;
		  /* 822478C8h */ case   20:  		/* bc 12, CR6_LT, -24 */
		/* 822478C8h case   20:*/		if ( regs.CR[6].lt ) { return 0x822478B0;  }
		/* 822478C8h case   20:*/		return 0x822478CC;
	}
	return 0x822478CC;
} // Block from 82247878h-822478CCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 822478CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822478CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822478CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822478CC);
		  /* 822478CCh */ case    0:  		/* addi R31, R31, 1 */
		/* 822478CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 822478CCh case    0:*/		return 0x822478D0;
		  /* 822478D0h */ case    1:  		/* cmpw CR6, R31, R28 */
		/* 822478D0h case    1:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R28);
		/* 822478D0h case    1:*/		return 0x822478D4;
		  /* 822478D4h */ case    2:  		/* bc 12, CR6_LT, -48 */
		/* 822478D4h case    2:*/		if ( regs.CR[6].lt ) { return 0x822478A4;  }
		/* 822478D4h case    2:*/		return 0x822478D8;
	}
	return 0x822478D8;
} // Block from 822478CCh-822478D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822478D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822478D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822478D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822478D8);
		  /* 822478D8h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 822478D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 822478D8h case    0:*/		return 0x822478DC;
		  /* 822478DCh */ case    1:  		/* mr R3, R19 */
		/* 822478DCh case    1:*/		regs.R3 = regs.R19;
		/* 822478DCh case    1:*/		return 0x822478E0;
		  /* 822478E0h */ case    2:  		/* lwz R4, <#[R11 + 1456]> */
		/* 822478E0h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 822478E0h case    2:*/		return 0x822478E4;
		  /* 822478E4h */ case    3:  		/* bl -69540 */
		/* 822478E4h case    3:*/		regs.LR = 0x822478E8; return 0x82236940;
		/* 822478E4h case    3:*/		return 0x822478E8;
		  /* 822478E8h */ case    4:  		/* lwz R11, <#[R29 + 12]> */
		/* 822478E8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 822478E8h case    4:*/		return 0x822478EC;
		  /* 822478ECh */ case    5:  		/* mr R27, R3 */
		/* 822478ECh case    5:*/		regs.R27 = regs.R3;
		/* 822478ECh case    5:*/		return 0x822478F0;
		  /* 822478F0h */ case    6:  		/* li R4, 24 */
		/* 822478F0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 822478F0h case    6:*/		return 0x822478F4;
		  /* 822478F4h */ case    7:  		/* lwz R30, <#[R11 + 1456]> */
		/* 822478F4h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 822478F4h case    7:*/		return 0x822478F8;
		  /* 822478F8h */ case    8:  		/* mr R3, R30 */
		/* 822478F8h case    8:*/		regs.R3 = regs.R30;
		/* 822478F8h case    8:*/		return 0x822478FC;
		  /* 822478FCh */ case    9:  		/* bl -177220 */
		/* 822478FCh case    9:*/		regs.LR = 0x82247900; return 0x8221C4B8;
		/* 822478FCh case    9:*/		return 0x82247900;
		  /* 82247900h */ case   10:  		/* addic. R31, R3, 4 */
		/* 82247900h case   10:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82247900h case   10:*/		return 0x82247904;
		  /* 82247904h */ case   11:  		/* stw R30, <#[R3]> */
		/* 82247904h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82247904h case   11:*/		return 0x82247908;
		  /* 82247908h */ case   12:  		/* bc 12, CR0_EQ, 48 */
		/* 82247908h case   12:*/		if ( regs.CR[0].eq ) { return 0x82247938;  }
		/* 82247908h case   12:*/		return 0x8224790C;
		  /* 8224790Ch */ case   13:  		/* lwz R11, <#[R29 + 12]> */
		/* 8224790Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 8224790Ch case   13:*/		return 0x82247910;
		  /* 82247910h */ case   14:  		/* mr R3, R31 */
		/* 82247910h case   14:*/		regs.R3 = regs.R31;
		/* 82247910h case   14:*/		return 0x82247914;
		  /* 82247914h */ case   15:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82247914h case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82247914h case   15:*/		return 0x82247918;
		  /* 82247918h */ case   16:  		/* mr R4, R30 */
		/* 82247918h case   16:*/		regs.R4 = regs.R30;
		/* 82247918h case   16:*/		return 0x8224791C;
		  /* 8224791Ch */ case   17:  		/* bl -72636 */
		/* 8224791Ch case   17:*/		regs.LR = 0x82247920; return 0x82235D60;
		/* 8224791Ch case   17:*/		return 0x82247920;
		  /* 82247920h */ case   18:  		/* mr R4, R30 */
		/* 82247920h case   18:*/		regs.R4 = regs.R30;
		/* 82247920h case   18:*/		return 0x82247924;
		  /* 82247924h */ case   19:  		/* mr R3, R19 */
		/* 82247924h case   19:*/		regs.R3 = regs.R19;
		/* 82247924h case   19:*/		return 0x82247928;
		  /* 82247928h */ case   20:  		/* bl -69608 */
		/* 82247928h case   20:*/		regs.LR = 0x8224792C; return 0x82236940;
		/* 82247928h case   20:*/		return 0x8224792C;
		  /* 8224792Ch */ case   21:  		/* stw R3, <#[R31 + 16]> */
		/* 8224792Ch case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224792Ch case   21:*/		return 0x82247930;
		  /* 82247930h */ case   22:  		/* mr R20, R31 */
		/* 82247930h case   22:*/		regs.R20 = regs.R31;
		/* 82247930h case   22:*/		return 0x82247934;
		  /* 82247934h */ case   23:  		/* b 8 */
		/* 82247934h case   23:*/		return 0x8224793C;
		/* 82247934h case   23:*/		return 0x82247938;
	}
	return 0x82247938;
} // Block from 822478D8h-82247938h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82247938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247938);
		  /* 82247938h */ case    0:  		/* li R20, 0 */
		/* 82247938h case    0:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 82247938h case    0:*/		return 0x8224793C;
	}
	return 0x8224793C;
} // Block from 82247938h-8224793Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224793Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224793C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224793C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224793C);
		  /* 8224793Ch */ case    0:  		/* lwz R22, <#[R29 + 136]> */
		/* 8224793Ch case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R29 + 0x00000088) );
		/* 8224793Ch case    0:*/		return 0x82247940;
		  /* 82247940h */ case    1:  		/* lwz R11, <#[R22 + 8]> */
		/* 82247940h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 82247940h case    1:*/		return 0x82247944;
		  /* 82247944h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 82247944h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82247944h case    2:*/		return 0x82247948;
		  /* 82247948h */ case    3:  		/* bc 12, CR6_EQ, 1408 */
		/* 82247948h case    3:*/		if ( regs.CR[6].eq ) { return 0x82247EC8;  }
		/* 82247948h case    3:*/		return 0x8224794C;
		  /* 8224794Ch */ case    4:  		/* lis R11, -32251 */
		/* 8224794Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8224794Ch case    4:*/		return 0x82247950;
		  /* 82247950h */ case    5:  		/* rlwinm R18, R24, 0, 24, 31 */
		/* 82247950h case    5:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R18,regs.R24);
		/* 82247950h case    5:*/		return 0x82247954;
		  /* 82247954h */ case    6:  		/* li R23, 1 */
		/* 82247954h case    6:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 82247954h case    6:*/		return 0x82247958;
		  /* 82247958h */ case    7:  		/* addi R21, R11, -19064 */
		/* 82247958h case    7:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R11,0xFFFFB588);
		/* 82247958h case    7:*/		return 0x8224795C;
		  /* 8224795Ch */ case    8:  		/* lwz R11, <#[R27]> */
		/* 8224795Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224795Ch case    8:*/		return 0x82247960;
		  /* 82247960h */ case    9:  		/* li R10, 0 */
		/* 82247960h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82247960h case    9:*/		return 0x82247964;
		  /* 82247964h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82247964h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82247964h case   10:*/		return 0x82247968;
		  /* 82247968h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 82247968h case   11:*/		if ( regs.CR[6].eq ) { return 0x82247988;  }
		/* 82247968h case   11:*/		return 0x8224796C;
		  /* 8224796Ch */ case   12:  		/* addi R9, R27, 4 */
		/* 8224796Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x4);
		/* 8224796Ch case   12:*/		return 0x82247970;
		  /* 82247970h */ case   13:  		/* li R11, 0 */
		/* 82247970h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82247970h case   13:*/		return 0x82247974;
		  /* 82247974h */ case   14:  		/* addi R10, R10, 1 */
		/* 82247974h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82247974h case   14:*/		return 0x82247978;
		  /* 82247978h */ case   15:  		/* stwu R11, <#[R9 + 4]> */
		/* 82247978h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 82247978h case   15:*/		return 0x8224797C;
		  /* 8224797Ch */ case   16:  		/* lwz R11, <#[R27]> */
		/* 8224797Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224797Ch case   16:*/		return 0x82247980;
		  /* 82247980h */ case   17:  		/* cmplw CR6, R10, R11 */
		/* 82247980h case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82247980h case   17:*/		return 0x82247984;
		  /* 82247984h */ case   18:  		/* bc 12, CR6_LT, -20 */
		/* 82247984h case   18:*/		if ( regs.CR[6].lt ) { return 0x82247970;  }
		/* 82247984h case   18:*/		return 0x82247988;
	}
	return 0x82247988;
} // Block from 8224793Ch-82247988h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82247988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247988);
		  /* 82247988h */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 82247988h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82247988h case    0:*/		return 0x8224798C;
		  /* 8224798Ch */ case    1:  		/* bc 12, CR6_EQ, 116 */
		/* 8224798Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82247A00;  }
		/* 8224798Ch case    1:*/		return 0x82247990;
		  /* 82247990h */ case    2:  		/* li R31, 0 */
		/* 82247990h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82247990h case    2:*/		return 0x82247994;
		  /* 82247994h */ case    3:  		/* cmpwi CR6, R19, 0 */
		/* 82247994h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 82247994h case    3:*/		return 0x82247998;
		  /* 82247998h */ case    4:  		/* bc 4, CR6_GT, 156 */
		/* 82247998h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82247A34;  }
		/* 82247998h case    4:*/		return 0x8224799C;
		  /* 8224799Ch */ case    5:  		/* rlwinm R11, R31, 27, 5, 31 */
		/* 8224799Ch case    5:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R31);
		/* 8224799Ch case    5:*/		return 0x822479A0;
		  /* 822479A0h */ case    6:  		/* lwz R10, <#[R22 + 104]> */
		/* 822479A0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000068) );
		/* 822479A0h case    6:*/		return 0x822479A4;
		  /* 822479A4h */ case    7:  		/* rlwinm R9, R31, 0, 27, 31 */
		/* 822479A4h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R31);
		/* 822479A4h case    7:*/		return 0x822479A8;
		  /* 822479A8h */ case    8:  		/* addi R11, R11, 2 */
		/* 822479A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 822479A8h case    8:*/		return 0x822479AC;
		  /* 822479ACh */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822479ACh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822479ACh case    9:*/		return 0x822479B0;
		  /* 822479B0h */ case   10:  		/* lwzx R11, <#[R11 + R10]> */
		/* 822479B0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822479B0h case   10:*/		return 0x822479B4;
		  /* 822479B4h */ case   11:  		/* srw R11, R11, R9 */
		/* 822479B4h case   11:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 822479B4h case   11:*/		return 0x822479B8;
		  /* 822479B8h */ case   12:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 822479B8h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 822479B8h case   12:*/		return 0x822479BC;
		  /* 822479BCh */ case   13:  		/* bc 12, CR0_EQ, 52 */
		/* 822479BCh case   13:*/		if ( regs.CR[0].eq ) { return 0x822479F0;  }
		/* 822479BCh case   13:*/		return 0x822479C0;
		  /* 822479C0h */ case   14:  		/* mr R5, R24 */
		/* 822479C0h case   14:*/		regs.R5 = regs.R24;
		/* 822479C0h case   14:*/		return 0x822479C4;
		  /* 822479C4h */ case   15:  		/* mr R4, R31 */
		/* 822479C4h case   15:*/		regs.R4 = regs.R31;
		/* 822479C4h case   15:*/		return 0x822479C8;
		  /* 822479C8h */ case   16:  		/* mr R3, R25 */
		/* 822479C8h case   16:*/		regs.R3 = regs.R25;
		/* 822479C8h case   16:*/		return 0x822479CC;
		  /* 822479CCh */ case   17:  		/* bl 116572 */
		/* 822479CCh case   17:*/		regs.LR = 0x822479D0; return 0x82264128;
		/* 822479CCh case   17:*/		return 0x822479D0;
		  /* 822479D0h */ case   18:  		/* rlwinm R11, R3, 27, 5, 31 */
		/* 822479D0h case   18:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R3);
		/* 822479D0h case   18:*/		return 0x822479D4;
		  /* 822479D4h */ case   19:  		/* rlwinm R10, R3, 0, 27, 31 */
		/* 822479D4h case   19:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R3);
		/* 822479D4h case   19:*/		return 0x822479D8;
		  /* 822479D8h */ case   20:  		/* addi R11, R11, 2 */
		/* 822479D8h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 822479D8h case   20:*/		return 0x822479DC;
		  /* 822479DCh */ case   21:  		/* slw R10, R23, R10 */
		/* 822479DCh case   21:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R23,regs.R10);
		/* 822479DCh case   21:*/		return 0x822479E0;
		  /* 822479E0h */ case   22:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822479E0h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822479E0h case   22:*/		return 0x822479E4;
		  /* 822479E4h */ case   23:  		/* lwzx R9, <#[R11 + R27]> */
		/* 822479E4h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 822479E4h case   23:*/		return 0x822479E8;
		  /* 822479E8h */ case   24:  		/* or R10, R10, R9 */
		/* 822479E8h case   24:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 822479E8h case   24:*/		return 0x822479EC;
		  /* 822479ECh */ case   25:  		/* stwx R10, <#[R11 + R27]> */
		/* 822479ECh case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 822479ECh case   25:*/		return 0x822479F0;
	}
	return 0x822479F0;
} // Block from 82247988h-822479F0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 822479F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822479F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822479F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822479F0);
		  /* 822479F0h */ case    0:  		/* addi R31, R31, 1 */
		/* 822479F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 822479F0h case    0:*/		return 0x822479F4;
		  /* 822479F4h */ case    1:  		/* cmpw CR6, R31, R19 */
		/* 822479F4h case    1:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R19);
		/* 822479F4h case    1:*/		return 0x822479F8;
		  /* 822479F8h */ case    2:  		/* bc 12, CR6_LT, -92 */
		/* 822479F8h case    2:*/		if ( regs.CR[6].lt ) { return 0x8224799C;  }
		/* 822479F8h case    2:*/		return 0x822479FC;
		  /* 822479FCh */ case    3:  		/* b 56 */
		/* 822479FCh case    3:*/		return 0x82247A34;
		/* 822479FCh case    3:*/		return 0x82247A00;
	}
	return 0x82247A00;
} // Block from 822479F0h-82247A00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82247A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247A00);
		  /* 82247A00h */ case    0:  		/* lwz R9, <#[R22 + 104]> */
		/* 82247A00h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000068) );
		/* 82247A00h case    0:*/		return 0x82247A04;
		  /* 82247A04h */ case    1:  		/* li R10, 0 */
		/* 82247A04h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82247A04h case    1:*/		return 0x82247A08;
		  /* 82247A08h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82247A08h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82247A08h case    2:*/		return 0x82247A0C;
		  /* 82247A0Ch */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 82247A0Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82247A34;  }
		/* 82247A0Ch case    3:*/		return 0x82247A10;
		  /* 82247A10h */ case    4:  		/* addi R11, R27, 8 */
		/* 82247A10h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x8);
		/* 82247A10h case    4:*/		return 0x82247A14;
		  /* 82247A14h */ case    5:  		/* subf R9, R27, R9 */
		/* 82247A14h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R27,regs.R9);
		/* 82247A14h case    5:*/		return 0x82247A18;
		  /* 82247A18h */ case    6:  		/* lwzx R8, <#[R9 + R11]> */
		/* 82247A18h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82247A18h case    6:*/		return 0x82247A1C;
		  /* 82247A1Ch */ case    7:  		/* addi R10, R10, 1 */
		/* 82247A1Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82247A1Ch case    7:*/		return 0x82247A20;
		  /* 82247A20h */ case    8:  		/* stw R8, <#[R11]> */
		/* 82247A20h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82247A20h case    8:*/		return 0x82247A24;
		  /* 82247A24h */ case    9:  		/* addi R11, R11, 4 */
		/* 82247A24h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82247A24h case    9:*/		return 0x82247A28;
		  /* 82247A28h */ case   10:  		/* lwz R8, <#[R27]> */
		/* 82247A28h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000000) );
		/* 82247A28h case   10:*/		return 0x82247A2C;
		  /* 82247A2Ch */ case   11:  		/* cmplw CR6, R10, R8 */
		/* 82247A2Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82247A2Ch case   11:*/		return 0x82247A30;
		  /* 82247A30h */ case   12:  		/* bc 12, CR6_LT, -24 */
		/* 82247A30h case   12:*/		if ( regs.CR[6].lt ) { return 0x82247A18;  }
		/* 82247A30h case   12:*/		return 0x82247A34;
	}
	return 0x82247A34;
} // Block from 82247A00h-82247A34h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82247A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247A34);
		  /* 82247A34h */ case    0:  		/* lwz R26, <#[R22 + 36]> */
		/* 82247A34h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R22 + 0x00000024) );
		/* 82247A34h case    0:*/		return 0x82247A38;
		  /* 82247A38h */ case    1:  		/* b 1140 */
		/* 82247A38h case    1:*/		return 0x82247EAC;
		/* 82247A38h case    1:*/		return 0x82247A3C;
		  /* 82247A3Ch */ case    2:  		/* lwz R10, <#[R22 + 28]> */
		/* 82247A3Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x0000001C) );
		/* 82247A3Ch case    2:*/		return 0x82247A40;
		  /* 82247A40h */ case    3:  		/* cmplw CR6, R26, R10 */
		/* 82247A40h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 82247A40h case    3:*/		return 0x82247A44;
		  /* 82247A44h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82247A44h case    4:*/		if ( regs.CR[6].eq ) { return 0x82247A54;  }
		/* 82247A44h case    4:*/		return 0x82247A48;
		  /* 82247A48h */ case    5:  		/* lwz R11, <#[R11 + 228]> */
		/* 82247A48h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000E4) );
		/* 82247A48h case    5:*/		return 0x82247A4C;
		  /* 82247A4Ch */ case    6:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 82247A4Ch case    6:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82247A4Ch case    6:*/		return 0x82247A50;
		  /* 82247A50h */ case    7:  		/* bc 4, CR0_EQ, 1112 */
		/* 82247A50h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82247EA8;  }
		/* 82247A50h case    7:*/		return 0x82247A54;
	}
	return 0x82247A54;
} // Block from 82247A34h-82247A54h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82247A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247A54);
		  /* 82247A54h */ case    0:  		/* li R11, 0 */
		/* 82247A54h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82247A54h case    0:*/		return 0x82247A58;
		  /* 82247A58h */ case    1:  		/* mr R29, R26 */
		/* 82247A58h case    1:*/		regs.R29 = regs.R26;
		/* 82247A58h case    1:*/		return 0x82247A5C;
		  /* 82247A5Ch */ case    2:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82247A5Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82247A5Ch case    2:*/		return 0x82247A60;
		  /* 82247A60h */ case    3:  		/* bc 4, CR0_EQ, 524 */
		/* 82247A60h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82247C6C;  }
		/* 82247A60h case    3:*/		return 0x82247A64;
		  /* 82247A64h */ case    4:  		/* lwz R11, <#[R29 + 228]> */
		/* 82247A64h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000E4) );
		/* 82247A64h case    4:*/		return 0x82247A68;
		  /* 82247A68h */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82247A68h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82247A68h case    5:*/		return 0x82247A6C;
		  /* 82247A6Ch */ case    6:  		/* bc 12, CR0_EQ, 488 */
		/* 82247A6Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82247C54;  }
		/* 82247A6Ch case    6:*/		return 0x82247A70;
		  /* 82247A70h */ case    7:  		/* lwz R11, <#[R29]> */
		/* 82247A70h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82247A70h case    7:*/		return 0x82247A74;
		  /* 82247A74h */ case    8:  		/* mr R3, R29 */
		/* 82247A74h case    8:*/		regs.R3 = regs.R29;
		/* 82247A74h case    8:*/		return 0x82247A78;
		  /* 82247A78h */ case    9:  		/* lwz R11, <#[R11 + 44]> */
		/* 82247A78h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 82247A78h case    9:*/		return 0x82247A7C;
		  /* 82247A7Ch */ case   10:  		/* mtspr CTR, R11 */
		/* 82247A7Ch case   10:*/		regs.CTR = regs.R11;
		/* 82247A7Ch case   10:*/		return 0x82247A80;
		  /* 82247A80h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 82247A80h case   11:*/		if ( 1 ) { regs.LR = 0x82247A84; return (uint32)regs.CTR; }
		/* 82247A80h case   11:*/		return 0x82247A84;
		  /* 82247A84h */ case   12:  		/* cmplwi CR0, R3, 0 */
		/* 82247A84h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82247A84h case   12:*/		return 0x82247A88;
		  /* 82247A88h */ case   13:  		/* bc 4, CR0_EQ, 460 */
		/* 82247A88h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82247C54;  }
		/* 82247A88h case   13:*/		return 0x82247A8C;
		  /* 82247A8Ch */ case   14:  		/* lwz R11, <#[R29 + 16]> */
		/* 82247A8Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82247A8Ch case   14:*/		return 0x82247A90;
		  /* 82247A90h */ case   15:  		/* cmpwi CR6, R11, 0 */
		/* 82247A90h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82247A90h case   15:*/		return 0x82247A94;
		  /* 82247A94h */ case   16:  		/* bc 12, CR6_EQ, 44 */
		/* 82247A94h case   16:*/		if ( regs.CR[6].eq ) { return 0x82247AC0;  }
		/* 82247A94h case   16:*/		return 0x82247A98;
		  /* 82247A98h */ case   17:  		/* lwz R11, <#[R29 + 228]> */
		/* 82247A98h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000E4) );
		/* 82247A98h case   17:*/		return 0x82247A9C;
		  /* 82247A9Ch */ case   18:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82247A9Ch case   18:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82247A9Ch case   18:*/		return 0x82247AA0;
		  /* 82247AA0h */ case   19:  		/* bc 4, CR0_EQ, 32 */
		/* 82247AA0h case   19:*/		if ( !regs.CR[0].eq ) { return 0x82247AC0;  }
		/* 82247AA0h case   19:*/		return 0x82247AA4;
		  /* 82247AA4h */ case   20:  		/* lwz R11, <#[R29 + 80]> */
		/* 82247AA4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000050) );
		/* 82247AA4h case   20:*/		return 0x82247AA8;
		  /* 82247AA8h */ case   21:  		/* addi R10, R21, 4 */
		/* 82247AA8h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R21,0x4);
		/* 82247AA8h case   21:*/		return 0x82247AAC;
		  /* 82247AACh */ case   22:  		/* mulli R11, R11, 12 */
		/* 82247AACh case   22:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82247AACh case   22:*/		return 0x82247AB0;
		  /* 82247AB0h */ case   23:  		/* lbzx R11, <#[R11 + R10]> */
		/* 82247AB0h case   23:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82247AB0h case   23:*/		return 0x82247AB4;
		  /* 82247AB4h */ case   24:  		/* cmplwi CR0, R11, 0 */
		/* 82247AB4h case   24:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82247AB4h case   24:*/		return 0x82247AB8;
		  /* 82247AB8h */ case   25:  		/* mr R11, R23 */
		/* 82247AB8h case   25:*/		regs.R11 = regs.R23;
		/* 82247AB8h case   25:*/		return 0x82247ABC;
		  /* 82247ABCh */ case   26:  		/* bc 4, CR0_EQ, 8 */
		/* 82247ABCh case   26:*/		if ( !regs.CR[0].eq ) { return 0x82247AC4;  }
		/* 82247ABCh case   26:*/		return 0x82247AC0;
	}
	return 0x82247AC0;
} // Block from 82247A54h-82247AC0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82247AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247AC0);
		  /* 82247AC0h */ case    0:  		/* li R11, 0 */
		/* 82247AC0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82247AC0h case    0:*/		return 0x82247AC4;
	}
	return 0x82247AC4;
} // Block from 82247AC0h-82247AC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247AC4);
		  /* 82247AC4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82247AC4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82247AC4h case    0:*/		return 0x82247AC8;
		  /* 82247AC8h */ case    1:  		/* bc 12, CR0_EQ, 396 */
		/* 82247AC8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82247C54;  }
		/* 82247AC8h case    1:*/		return 0x82247ACC;
		  /* 82247ACCh */ case    2:  		/* mr R5, R24 */
		/* 82247ACCh case    2:*/		regs.R5 = regs.R24;
		/* 82247ACCh case    2:*/		return 0x82247AD0;
		  /* 82247AD0h */ case    3:  		/* lwz R4, <#[R29 + 56]> */
		/* 82247AD0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000038) );
		/* 82247AD0h case    3:*/		return 0x82247AD4;
		  /* 82247AD4h */ case    4:  		/* mr R3, R25 */
		/* 82247AD4h case    4:*/		regs.R3 = regs.R25;
		/* 82247AD4h case    4:*/		return 0x82247AD8;
		  /* 82247AD8h */ case    5:  		/* li R30, -1 */
		/* 82247AD8h case    5:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 82247AD8h case    5:*/		return 0x82247ADC;
		  /* 82247ADCh */ case    6:  		/* bl 116300 */
		/* 82247ADCh case    6:*/		regs.LR = 0x82247AE0; return 0x82264128;
		/* 82247ADCh case    6:*/		return 0x82247AE0;
		  /* 82247AE0h */ case    7:  		/* mr R28, R3 */
		/* 82247AE0h case    7:*/		regs.R28 = regs.R3;
		/* 82247AE0h case    7:*/		return 0x82247AE4;
		  /* 82247AE4h */ case    8:  		/* mr R3, R29 */
		/* 82247AE4h case    8:*/		regs.R3 = regs.R29;
		/* 82247AE4h case    8:*/		return 0x82247AE8;
		  /* 82247AE8h */ case    9:  		/* bl -25584 */
		/* 82247AE8h case    9:*/		regs.LR = 0x82247AEC; return 0x822416F8;
		/* 82247AE8h case    9:*/		return 0x82247AEC;
		  /* 82247AECh */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82247AECh case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82247AECh case   10:*/		return 0x82247AF0;
		  /* 82247AF0h */ case   11:  		/* bc 12, CR0_EQ, 92 */
		/* 82247AF0h case   11:*/		if ( regs.CR[0].eq ) { return 0x82247B4C;  }
		/* 82247AF0h case   11:*/		return 0x82247AF4;
		  /* 82247AF4h */ case   12:  		/* lwz R11, <#[R29 + 236]> */
		/* 82247AF4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000EC) );
		/* 82247AF4h case   12:*/		return 0x82247AF8;
		  /* 82247AF8h */ case   13:  		/* lwz R10, <#[R11 + 16]> */
		/* 82247AF8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82247AF8h case   13:*/		return 0x82247AFC;
		  /* 82247AFCh */ case   14:  		/* cmpwi CR6, R10, 0 */
		/* 82247AFCh case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82247AFCh case   14:*/		return 0x82247B00;
		  /* 82247B00h */ case   15:  		/* bc 12, CR6_EQ, 44 */
		/* 82247B00h case   15:*/		if ( regs.CR[6].eq ) { return 0x82247B2C;  }
		/* 82247B00h case   15:*/		return 0x82247B04;
		  /* 82247B04h */ case   16:  		/* lwz R10, <#[R11 + 228]> */
		/* 82247B04h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 82247B04h case   16:*/		return 0x82247B08;
		  /* 82247B08h */ case   17:  		/* rlwinm. R10, R10, 31, 31, 31 */
		/* 82247B08h case   17:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R10,regs.R10);
		/* 82247B08h case   17:*/		return 0x82247B0C;
		  /* 82247B0Ch */ case   18:  		/* bc 4, CR0_EQ, 32 */
		/* 82247B0Ch case   18:*/		if ( !regs.CR[0].eq ) { return 0x82247B2C;  }
		/* 82247B0Ch case   18:*/		return 0x82247B10;
		  /* 82247B10h */ case   19:  		/* lwz R10, <#[R11 + 80]> */
		/* 82247B10h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 82247B10h case   19:*/		return 0x82247B14;
		  /* 82247B14h */ case   20:  		/* addi R9, R21, 4 */
		/* 82247B14h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R21,0x4);
		/* 82247B14h case   20:*/		return 0x82247B18;
		  /* 82247B18h */ case   21:  		/* mulli R10, R10, 12 */
		/* 82247B18h case   21:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82247B18h case   21:*/		return 0x82247B1C;
		  /* 82247B1Ch */ case   22:  		/* lbzx R10, <#[R10 + R9]> */
		/* 82247B1Ch case   22:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82247B1Ch case   22:*/		return 0x82247B20;
		  /* 82247B20h */ case   23:  		/* cmplwi CR0, R10, 0 */
		/* 82247B20h case   23:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82247B20h case   23:*/		return 0x82247B24;
		  /* 82247B24h */ case   24:  		/* mr R10, R23 */
		/* 82247B24h case   24:*/		regs.R10 = regs.R23;
		/* 82247B24h case   24:*/		return 0x82247B28;
		  /* 82247B28h */ case   25:  		/* bc 4, CR0_EQ, 8 */
		/* 82247B28h case   25:*/		if ( !regs.CR[0].eq ) { return 0x82247B30;  }
		/* 82247B28h case   25:*/		return 0x82247B2C;
	}
	return 0x82247B2C;
} // Block from 82247AC4h-82247B2Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 82247B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247B2C);
		  /* 82247B2Ch */ case    0:  		/* li R10, 0 */
		/* 82247B2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82247B2Ch case    0:*/		return 0x82247B30;
	}
	return 0x82247B30;
} // Block from 82247B2Ch-82247B30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247B30);
		  /* 82247B30h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82247B30h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82247B30h case    0:*/		return 0x82247B34;
		  /* 82247B34h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82247B34h case    1:*/		if ( regs.CR[0].eq ) { return 0x82247B4C;  }
		/* 82247B34h case    1:*/		return 0x82247B38;
		  /* 82247B38h */ case    2:  		/* mr R5, R24 */
		/* 82247B38h case    2:*/		regs.R5 = regs.R24;
		/* 82247B38h case    2:*/		return 0x82247B3C;
		  /* 82247B3Ch */ case    3:  		/* lwz R4, <#[R11 + 56]> */
		/* 82247B3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000038) );
		/* 82247B3Ch case    3:*/		return 0x82247B40;
		  /* 82247B40h */ case    4:  		/* mr R3, R25 */
		/* 82247B40h case    4:*/		regs.R3 = regs.R25;
		/* 82247B40h case    4:*/		return 0x82247B44;
		  /* 82247B44h */ case    5:  		/* bl 116196 */
		/* 82247B44h case    5:*/		regs.LR = 0x82247B48; return 0x82264128;
		/* 82247B44h case    5:*/		return 0x82247B48;
		  /* 82247B48h */ case    6:  		/* mr R30, R3 */
		/* 82247B48h case    6:*/		regs.R30 = regs.R3;
		/* 82247B48h case    6:*/		return 0x82247B4C;
	}
	return 0x82247B4C;
} // Block from 82247B30h-82247B4Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82247B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247B4C);
		  /* 82247B4Ch */ case    0:  		/* rlwinm R11, R28, 27, 5, 31 */
		/* 82247B4Ch case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R28);
		/* 82247B4Ch case    0:*/		return 0x82247B50;
		  /* 82247B50h */ case    1:  		/* rlwinm R10, R28, 0, 27, 31 */
		/* 82247B50h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R28);
		/* 82247B50h case    1:*/		return 0x82247B54;
		  /* 82247B54h */ case    2:  		/* addi R11, R11, 2 */
		/* 82247B54h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82247B54h case    2:*/		return 0x82247B58;
		  /* 82247B58h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82247B58h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82247B58h case    3:*/		return 0x82247B5C;
		  /* 82247B5Ch */ case    4:  		/* lwzx R11, <#[R11 + R27]> */
		/* 82247B5Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82247B5Ch case    4:*/		return 0x82247B60;
		  /* 82247B60h */ case    5:  		/* srw R11, R11, R10 */
		/* 82247B60h case    5:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82247B60h case    5:*/		return 0x82247B64;
		  /* 82247B64h */ case    6:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82247B64h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82247B64h case    6:*/		return 0x82247B68;
		  /* 82247B68h */ case    7:  		/* bc 12, CR0_EQ, 224 */
		/* 82247B68h case    7:*/		if ( regs.CR[0].eq ) { return 0x82247C48;  }
		/* 82247B68h case    7:*/		return 0x82247B6C;
		  /* 82247B6Ch */ case    8:  		/* lwz R11, <#[R27 + 4]> */
		/* 82247B6Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82247B6Ch case    8:*/		return 0x82247B70;
		  /* 82247B70h */ case    9:  		/* li R31, 0 */
		/* 82247B70h case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82247B70h case    9:*/		return 0x82247B74;
		  /* 82247B74h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82247B74h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82247B74h case   10:*/		return 0x82247B78;
		  /* 82247B78h */ case   11:  		/* bc 4, CR6_GT, 92 */
		/* 82247B78h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82247BD4;  }
		/* 82247B78h case   11:*/		return 0x82247B7C;
		  /* 82247B7Ch */ case   12:  		/* rlwinm R11, R31, 27, 5, 31 */
		/* 82247B7Ch case   12:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R31);
		/* 82247B7Ch case   12:*/		return 0x82247B80;
		  /* 82247B80h */ case   13:  		/* rlwinm R10, R31, 0, 27, 31 */
		/* 82247B80h case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R31);
		/* 82247B80h case   13:*/		return 0x82247B84;
		  /* 82247B84h */ case   14:  		/* addi R11, R11, 2 */
		/* 82247B84h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82247B84h case   14:*/		return 0x82247B88;
		  /* 82247B88h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82247B88h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82247B88h case   15:*/		return 0x82247B8C;
		  /* 82247B8Ch */ case   16:  		/* lwzx R11, <#[R11 + R27]> */
		/* 82247B8Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82247B8Ch case   16:*/		return 0x82247B90;
		  /* 82247B90h */ case   17:  		/* srw R11, R11, R10 */
		/* 82247B90h case   17:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82247B90h case   17:*/		return 0x82247B94;
		  /* 82247B94h */ case   18:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82247B94h case   18:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82247B94h case   18:*/		return 0x82247B98;
		  /* 82247B98h */ case   19:  		/* bc 12, CR0_EQ, 44 */
		/* 82247B98h case   19:*/		if ( regs.CR[0].eq ) { return 0x82247BC4;  }
		/* 82247B98h case   19:*/		return 0x82247B9C;
		  /* 82247B9Ch */ case   20:  		/* mr R5, R24 */
		/* 82247B9Ch case   20:*/		regs.R5 = regs.R24;
		/* 82247B9Ch case   20:*/		return 0x82247BA0;
		  /* 82247BA0h */ case   21:  		/* mr R4, R31 */
		/* 82247BA0h case   21:*/		regs.R4 = regs.R31;
		/* 82247BA0h case   21:*/		return 0x82247BA4;
		  /* 82247BA4h */ case   22:  		/* mr R3, R25 */
		/* 82247BA4h case   22:*/		regs.R3 = regs.R25;
		/* 82247BA4h case   22:*/		return 0x82247BA8;
		  /* 82247BA8h */ case   23:  		/* bl 116096 */
		/* 82247BA8h case   23:*/		regs.LR = 0x82247BAC; return 0x82264128;
		/* 82247BA8h case   23:*/		return 0x82247BAC;
		  /* 82247BACh */ case   24:  		/* mr R5, R3 */
		/* 82247BACh case   24:*/		regs.R5 = regs.R3;
		/* 82247BACh case   24:*/		return 0x82247BB0;
		  /* 82247BB0h */ case   25:  		/* cmpw CR6, R3, R30 */
		/* 82247BB0h case   25:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R30);
		/* 82247BB0h case   25:*/		return 0x82247BB4;
		  /* 82247BB4h */ case   26:  		/* bc 12, CR6_EQ, 16 */
		/* 82247BB4h case   26:*/		if ( regs.CR[6].eq ) { return 0x82247BC4;  }
		/* 82247BB4h case   26:*/		return 0x82247BB8;
		  /* 82247BB8h */ case   27:  		/* mr R4, R28 */
		/* 82247BB8h case   27:*/		regs.R4 = regs.R28;
		/* 82247BB8h case   27:*/		return 0x82247BBC;
		  /* 82247BBCh */ case   28:  		/* mr R3, R25 */
		/* 82247BBCh case   28:*/		regs.R3 = regs.R25;
		/* 82247BBCh case   28:*/		return 0x82247BC0;
		  /* 82247BC0h */ case   29:  		/* bl 118112 */
		/* 82247BC0h case   29:*/		regs.LR = 0x82247BC4; return 0x82264920;
		/* 82247BC0h case   29:*/		return 0x82247BC4;
	}
	return 0x82247BC4;
} // Block from 82247B4Ch-82247BC4h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82247BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247BC4);
		  /* 82247BC4h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 82247BC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82247BC4h case    0:*/		return 0x82247BC8;
		  /* 82247BC8h */ case    1:  		/* addi R31, R31, 1 */
		/* 82247BC8h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82247BC8h case    1:*/		return 0x82247BCC;
		  /* 82247BCCh */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 82247BCCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82247BCCh case    2:*/		return 0x82247BD0;
		  /* 82247BD0h */ case    3:  		/* bc 12, CR6_LT, -84 */
		/* 82247BD0h case    3:*/		if ( regs.CR[6].lt ) { return 0x82247B7C;  }
		/* 82247BD0h case    3:*/		return 0x82247BD4;
	}
	return 0x82247BD4;
} // Block from 82247BC4h-82247BD4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82247BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247BD4);
		  /* 82247BD4h */ case    0:  		/* lwz R11, <#[R29 + 24]> */
		/* 82247BD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 82247BD4h case    0:*/		return 0x82247BD8;
		  /* 82247BD8h */ case    1:  		/* cmpwi CR6, R11, 50 */
		/* 82247BD8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000032);
		/* 82247BD8h case    1:*/		return 0x82247BDC;
		  /* 82247BDCh */ case    2:  		/* bc 4, CR6_EQ, 120 */
		/* 82247BDCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x82247C54;  }
		/* 82247BDCh case    2:*/		return 0x82247BE0;
		  /* 82247BE0h */ case    3:  		/* lwz R11, <#[R29 + 236]> */
		/* 82247BE0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000EC) );
		/* 82247BE0h case    3:*/		return 0x82247BE4;
		  /* 82247BE4h */ case    4:  		/* lwz R10, <#[R11 + 16]> */
		/* 82247BE4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82247BE4h case    4:*/		return 0x82247BE8;
		  /* 82247BE8h */ case    5:  		/* cmpwi CR6, R10, 0 */
		/* 82247BE8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82247BE8h case    5:*/		return 0x82247BEC;
		  /* 82247BECh */ case    6:  		/* bc 12, CR6_EQ, 44 */
		/* 82247BECh case    6:*/		if ( regs.CR[6].eq ) { return 0x82247C18;  }
		/* 82247BECh case    6:*/		return 0x82247BF0;
		  /* 82247BF0h */ case    7:  		/* lwz R10, <#[R11 + 228]> */
		/* 82247BF0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 82247BF0h case    7:*/		return 0x82247BF4;
		  /* 82247BF4h */ case    8:  		/* rlwinm. R10, R10, 31, 31, 31 */
		/* 82247BF4h case    8:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R10,regs.R10);
		/* 82247BF4h case    8:*/		return 0x82247BF8;
		  /* 82247BF8h */ case    9:  		/* bc 4, CR0_EQ, 32 */
		/* 82247BF8h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82247C18;  }
		/* 82247BF8h case    9:*/		return 0x82247BFC;
		  /* 82247BFCh */ case   10:  		/* lwz R10, <#[R11 + 80]> */
		/* 82247BFCh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 82247BFCh case   10:*/		return 0x82247C00;
		  /* 82247C00h */ case   11:  		/* addi R9, R21, 4 */
		/* 82247C00h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R21,0x4);
		/* 82247C00h case   11:*/		return 0x82247C04;
		  /* 82247C04h */ case   12:  		/* mulli R10, R10, 12 */
		/* 82247C04h case   12:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82247C04h case   12:*/		return 0x82247C08;
		  /* 82247C08h */ case   13:  		/* lbzx R10, <#[R10 + R9]> */
		/* 82247C08h case   13:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82247C08h case   13:*/		return 0x82247C0C;
		  /* 82247C0Ch */ case   14:  		/* cmplwi CR0, R10, 0 */
		/* 82247C0Ch case   14:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82247C0Ch case   14:*/		return 0x82247C10;
		  /* 82247C10h */ case   15:  		/* mr R10, R23 */
		/* 82247C10h case   15:*/		regs.R10 = regs.R23;
		/* 82247C10h case   15:*/		return 0x82247C14;
		  /* 82247C14h */ case   16:  		/* bc 4, CR0_EQ, 8 */
		/* 82247C14h case   16:*/		if ( !regs.CR[0].eq ) { return 0x82247C1C;  }
		/* 82247C14h case   16:*/		return 0x82247C18;
	}
	return 0x82247C18;
} // Block from 82247BD4h-82247C18h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82247C18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247C18);
		  /* 82247C18h */ case    0:  		/* li R10, 0 */
		/* 82247C18h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82247C18h case    0:*/		return 0x82247C1C;
	}
	return 0x82247C1C;
} // Block from 82247C18h-82247C1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247C1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247C1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247C1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247C1C);
		  /* 82247C1Ch */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82247C1Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82247C1Ch case    0:*/		return 0x82247C20;
		  /* 82247C20h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 82247C20h case    1:*/		if ( regs.CR[0].eq ) { return 0x82247C54;  }
		/* 82247C20h case    1:*/		return 0x82247C24;
		  /* 82247C24h */ case    2:  		/* mr R5, R24 */
		/* 82247C24h case    2:*/		regs.R5 = regs.R24;
		/* 82247C24h case    2:*/		return 0x82247C28;
		  /* 82247C28h */ case    3:  		/* lwz R4, <#[R11 + 56]> */
		/* 82247C28h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000038) );
		/* 82247C28h case    3:*/		return 0x82247C2C;
		  /* 82247C2Ch */ case    4:  		/* mr R3, R25 */
		/* 82247C2Ch case    4:*/		regs.R3 = regs.R25;
		/* 82247C2Ch case    4:*/		return 0x82247C30;
		  /* 82247C30h */ case    5:  		/* bl 115960 */
		/* 82247C30h case    5:*/		regs.LR = 0x82247C34; return 0x82264128;
		/* 82247C30h case    5:*/		return 0x82247C34;
		  /* 82247C34h */ case    6:  		/* mr R5, R3 */
		/* 82247C34h case    6:*/		regs.R5 = regs.R3;
		/* 82247C34h case    6:*/		return 0x82247C38;
		  /* 82247C38h */ case    7:  		/* mr R4, R28 */
		/* 82247C38h case    7:*/		regs.R4 = regs.R28;
		/* 82247C38h case    7:*/		return 0x82247C3C;
		  /* 82247C3Ch */ case    8:  		/* mr R3, R25 */
		/* 82247C3Ch case    8:*/		regs.R3 = regs.R25;
		/* 82247C3Ch case    8:*/		return 0x82247C40;
		  /* 82247C40h */ case    9:  		/* bl 117984 */
		/* 82247C40h case    9:*/		regs.LR = 0x82247C44; return 0x82264920;
		/* 82247C40h case    9:*/		return 0x82247C44;
		  /* 82247C44h */ case   10:  		/* b 16 */
		/* 82247C44h case   10:*/		return 0x82247C54;
		/* 82247C44h case   10:*/		return 0x82247C48;
	}
	return 0x82247C48;
} // Block from 82247C1Ch-82247C48h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82247C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247C48);
		  /* 82247C48h */ case    0:  		/* mr R4, R28 */
		/* 82247C48h case    0:*/		regs.R4 = regs.R28;
		/* 82247C48h case    0:*/		return 0x82247C4C;
		  /* 82247C4Ch */ case    1:  		/* mr R3, R20 */
		/* 82247C4Ch case    1:*/		regs.R3 = regs.R20;
		/* 82247C4Ch case    1:*/		return 0x82247C50;
		  /* 82247C50h */ case    2:  		/* bl -1536 */
		/* 82247C50h case    2:*/		regs.LR = 0x82247C54; return 0x82247650;
		/* 82247C50h case    2:*/		return 0x82247C54;
	}
	return 0x82247C54;
} // Block from 82247C48h-82247C54h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82247C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247C54);
		  /* 82247C54h */ case    0:  		/* lwz R11, <#[R29 + 228]> */
		/* 82247C54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000E4) );
		/* 82247C54h case    0:*/		return 0x82247C58;
		  /* 82247C58h */ case    1:  		/* lwz R29, <#[R29 + 8]> */
		/* 82247C58h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 82247C58h case    1:*/		return 0x82247C5C;
		  /* 82247C5Ch */ case    2:  		/* nor R11, R11, R11 */
		/* 82247C5Ch case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82247C5Ch case    2:*/		return 0x82247C60;
		  /* 82247C60h */ case    3:  		/* cmplwi CR6, R29, 0 */
		/* 82247C60h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82247C60h case    3:*/		return 0x82247C64;
		  /* 82247C64h */ case    4:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 82247C64h case    4:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82247C64h case    4:*/		return 0x82247C68;
		  /* 82247C68h */ case    5:  		/* bc 4, CR6_EQ, -524 */
		/* 82247C68h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82247A5C;  }
		/* 82247C68h case    5:*/		return 0x82247C6C;
	}
	return 0x82247C6C;
} // Block from 82247C54h-82247C6Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82247C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247C6C);
		  /* 82247C6Ch */ case    0:  		/* li R11, 0 */
		/* 82247C6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82247C6Ch case    0:*/		return 0x82247C70;
		  /* 82247C70h */ case    1:  		/* mr R31, R26 */
		/* 82247C70h case    1:*/		regs.R31 = regs.R26;
		/* 82247C70h case    1:*/		return 0x82247C74;
		  /* 82247C74h */ case    2:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82247C74h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82247C74h case    2:*/		return 0x82247C78;
		  /* 82247C78h */ case    3:  		/* bc 4, CR0_EQ, 292 */
		/* 82247C78h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82247D9C;  }
		/* 82247C78h case    3:*/		return 0x82247C7C;
		  /* 82247C7Ch */ case    4:  		/* lwz R11, <#[R31 + 228]> */
		/* 82247C7Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82247C7Ch case    4:*/		return 0x82247C80;
		  /* 82247C80h */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82247C80h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82247C80h case    5:*/		return 0x82247C84;
		  /* 82247C84h */ case    6:  		/* bc 12, CR0_EQ, 144 */
		/* 82247C84h case    6:*/		if ( regs.CR[0].eq ) { return 0x82247D14;  }
		/* 82247C84h case    6:*/		return 0x82247C88;
		  /* 82247C88h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82247C88h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82247C88h case    7:*/		return 0x82247C8C;
		  /* 82247C8Ch */ case    8:  		/* mr R3, R31 */
		/* 82247C8Ch case    8:*/		regs.R3 = regs.R31;
		/* 82247C8Ch case    8:*/		return 0x82247C90;
		  /* 82247C90h */ case    9:  		/* lwz R11, <#[R11 + 44]> */
		/* 82247C90h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 82247C90h case    9:*/		return 0x82247C94;
		  /* 82247C94h */ case   10:  		/* mtspr CTR, R11 */
		/* 82247C94h case   10:*/		regs.CTR = regs.R11;
		/* 82247C94h case   10:*/		return 0x82247C98;
		  /* 82247C98h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 82247C98h case   11:*/		if ( 1 ) { regs.LR = 0x82247C9C; return (uint32)regs.CTR; }
		/* 82247C98h case   11:*/		return 0x82247C9C;
		  /* 82247C9Ch */ case   12:  		/* cmplwi CR0, R3, 0 */
		/* 82247C9Ch case   12:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82247C9Ch case   12:*/		return 0x82247CA0;
		  /* 82247CA0h */ case   13:  		/* bc 4, CR0_EQ, 116 */
		/* 82247CA0h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82247D14;  }
		/* 82247CA0h case   13:*/		return 0x82247CA4;
		  /* 82247CA4h */ case   14:  		/* lwz R11, <#[R31 + 16]> */
		/* 82247CA4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82247CA4h case   14:*/		return 0x82247CA8;
		  /* 82247CA8h */ case   15:  		/* cmpwi CR6, R11, 0 */
		/* 82247CA8h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82247CA8h case   15:*/		return 0x82247CAC;
		  /* 82247CACh */ case   16:  		/* bc 12, CR6_EQ, 44 */
		/* 82247CACh case   16:*/		if ( regs.CR[6].eq ) { return 0x82247CD8;  }
		/* 82247CACh case   16:*/		return 0x82247CB0;
		  /* 82247CB0h */ case   17:  		/* lwz R11, <#[R31 + 228]> */
		/* 82247CB0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82247CB0h case   17:*/		return 0x82247CB4;
		  /* 82247CB4h */ case   18:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82247CB4h case   18:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82247CB4h case   18:*/		return 0x82247CB8;
		  /* 82247CB8h */ case   19:  		/* bc 4, CR0_EQ, 32 */
		/* 82247CB8h case   19:*/		if ( !regs.CR[0].eq ) { return 0x82247CD8;  }
		/* 82247CB8h case   19:*/		return 0x82247CBC;
		  /* 82247CBCh */ case   20:  		/* lwz R11, <#[R31 + 80]> */
		/* 82247CBCh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 82247CBCh case   20:*/		return 0x82247CC0;
		  /* 82247CC0h */ case   21:  		/* addi R10, R21, 4 */
		/* 82247CC0h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R21,0x4);
		/* 82247CC0h case   21:*/		return 0x82247CC4;
		  /* 82247CC4h */ case   22:  		/* mulli R11, R11, 12 */
		/* 82247CC4h case   22:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82247CC4h case   22:*/		return 0x82247CC8;
		  /* 82247CC8h */ case   23:  		/* lbzx R11, <#[R11 + R10]> */
		/* 82247CC8h case   23:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82247CC8h case   23:*/		return 0x82247CCC;
		  /* 82247CCCh */ case   24:  		/* cmplwi CR0, R11, 0 */
		/* 82247CCCh case   24:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82247CCCh case   24:*/		return 0x82247CD0;
		  /* 82247CD0h */ case   25:  		/* mr R11, R23 */
		/* 82247CD0h case   25:*/		regs.R11 = regs.R23;
		/* 82247CD0h case   25:*/		return 0x82247CD4;
		  /* 82247CD4h */ case   26:  		/* bc 4, CR0_EQ, 8 */
		/* 82247CD4h case   26:*/		if ( !regs.CR[0].eq ) { return 0x82247CDC;  }
		/* 82247CD4h case   26:*/		return 0x82247CD8;
	}
	return 0x82247CD8;
} // Block from 82247C6Ch-82247CD8h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82247CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247CD8);
		  /* 82247CD8h */ case    0:  		/* li R11, 0 */
		/* 82247CD8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82247CD8h case    0:*/		return 0x82247CDC;
	}
	return 0x82247CDC;
} // Block from 82247CD8h-82247CDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247CDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247CDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247CDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247CDC);
		  /* 82247CDCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82247CDCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82247CDCh case    0:*/		return 0x82247CE0;
		  /* 82247CE0h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 82247CE0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82247D14;  }
		/* 82247CE0h case    1:*/		return 0x82247CE4;
		  /* 82247CE4h */ case    2:  		/* mr R5, R24 */
		/* 82247CE4h case    2:*/		regs.R5 = regs.R24;
		/* 82247CE4h case    2:*/		return 0x82247CE8;
		  /* 82247CE8h */ case    3:  		/* lwz R4, <#[R31 + 56]> */
		/* 82247CE8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000038) );
		/* 82247CE8h case    3:*/		return 0x82247CEC;
		  /* 82247CECh */ case    4:  		/* mr R3, R25 */
		/* 82247CECh case    4:*/		regs.R3 = regs.R25;
		/* 82247CECh case    4:*/		return 0x82247CF0;
		  /* 82247CF0h */ case    5:  		/* bl 115768 */
		/* 82247CF0h case    5:*/		regs.LR = 0x82247CF4; return 0x82264128;
		/* 82247CF0h case    5:*/		return 0x82247CF4;
		  /* 82247CF4h */ case    6:  		/* rlwinm R11, R3, 27, 5, 31 */
		/* 82247CF4h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R3);
		/* 82247CF4h case    6:*/		return 0x82247CF8;
		  /* 82247CF8h */ case    7:  		/* rlwinm R10, R3, 0, 27, 31 */
		/* 82247CF8h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R3);
		/* 82247CF8h case    7:*/		return 0x82247CFC;
		  /* 82247CFCh */ case    8:  		/* addi R11, R11, 2 */
		/* 82247CFCh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82247CFCh case    8:*/		return 0x82247D00;
		  /* 82247D00h */ case    9:  		/* slw R10, R23, R10 */
		/* 82247D00h case    9:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R23,regs.R10);
		/* 82247D00h case    9:*/		return 0x82247D04;
		  /* 82247D04h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82247D04h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82247D04h case   10:*/		return 0x82247D08;
		  /* 82247D08h */ case   11:  		/* lwzx R9, <#[R11 + R27]> */
		/* 82247D08h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82247D08h case   11:*/		return 0x82247D0C;
		  /* 82247D0Ch */ case   12:  		/* andc R10, R9, R10 */
		/* 82247D0Ch case   12:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82247D0Ch case   12:*/		return 0x82247D10;
		  /* 82247D10h */ case   13:  		/* stwx R10, <#[R11 + R27]> */
		/* 82247D10h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82247D10h case   13:*/		return 0x82247D14;
	}
	return 0x82247D14;
} // Block from 82247CDCh-82247D14h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82247D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247D14);
		  /* 82247D14h */ case    0:  		/* lwz R11, <#[R31 + 228]> */
		/* 82247D14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82247D14h case    0:*/		return 0x82247D18;
		  /* 82247D18h */ case    1:  		/* lwz R31, <#[R31 + 8]> */
		/* 82247D18h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82247D18h case    1:*/		return 0x82247D1C;
		  /* 82247D1Ch */ case    2:  		/* nor R11, R11, R11 */
		/* 82247D1Ch case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82247D1Ch case    2:*/		return 0x82247D20;
		  /* 82247D20h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82247D20h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82247D20h case    3:*/		return 0x82247D24;
		  /* 82247D24h */ case    4:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 82247D24h case    4:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82247D24h case    4:*/		return 0x82247D28;
		  /* 82247D28h */ case    5:  		/* bc 4, CR6_EQ, -180 */
		/* 82247D28h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82247C74;  }
		/* 82247D28h case    5:*/		return 0x82247D2C;
		  /* 82247D2Ch */ case    6:  		/* b 112 */
		/* 82247D2Ch case    6:*/		return 0x82247D9C;
		/* 82247D2Ch case    6:*/		return 0x82247D30;
		  /* 82247D30h */ case    7:  		/* mr R3, R20 */
		/* 82247D30h case    7:*/		regs.R3 = regs.R20;
		/* 82247D30h case    7:*/		return 0x82247D34;
		  /* 82247D34h */ case    8:  		/* bl -1676 */
		/* 82247D34h case    8:*/		regs.LR = 0x82247D38; return 0x822476A8;
		/* 82247D34h case    8:*/		return 0x82247D38;
		  /* 82247D38h */ case    9:  		/* lwz R11, <#[R27 + 4]> */
		/* 82247D38h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82247D38h case    9:*/		return 0x82247D3C;
		  /* 82247D3Ch */ case   10:  		/* mr R30, R3 */
		/* 82247D3Ch case   10:*/		regs.R30 = regs.R3;
		/* 82247D3Ch case   10:*/		return 0x82247D40;
		  /* 82247D40h */ case   11:  		/* li R31, 0 */
		/* 82247D40h case   11:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82247D40h case   11:*/		return 0x82247D44;
		  /* 82247D44h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 82247D44h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82247D44h case   12:*/		return 0x82247D48;
		  /* 82247D48h */ case   13:  		/* bc 4, CR6_GT, 84 */
		/* 82247D48h case   13:*/		if ( !regs.CR[6].gt ) { return 0x82247D9C;  }
		/* 82247D48h case   13:*/		return 0x82247D4C;
		  /* 82247D4Ch */ case   14:  		/* rlwinm R11, R31, 27, 5, 31 */
		/* 82247D4Ch case   14:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R31);
		/* 82247D4Ch case   14:*/		return 0x82247D50;
		  /* 82247D50h */ case   15:  		/* rlwinm R10, R31, 0, 27, 31 */
		/* 82247D50h case   15:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R31);
		/* 82247D50h case   15:*/		return 0x82247D54;
		  /* 82247D54h */ case   16:  		/* addi R11, R11, 2 */
		/* 82247D54h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82247D54h case   16:*/		return 0x82247D58;
		  /* 82247D58h */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82247D58h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82247D58h case   17:*/		return 0x82247D5C;
		  /* 82247D5Ch */ case   18:  		/* lwzx R11, <#[R11 + R27]> */
		/* 82247D5Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82247D5Ch case   18:*/		return 0x82247D60;
		  /* 82247D60h */ case   19:  		/* srw R11, R11, R10 */
		/* 82247D60h case   19:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82247D60h case   19:*/		return 0x82247D64;
		  /* 82247D64h */ case   20:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82247D64h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82247D64h case   20:*/		return 0x82247D68;
		  /* 82247D68h */ case   21:  		/* bc 12, CR0_EQ, 36 */
		/* 82247D68h case   21:*/		if ( regs.CR[0].eq ) { return 0x82247D8C;  }
		/* 82247D68h case   21:*/		return 0x82247D6C;
		  /* 82247D6Ch */ case   22:  		/* mr R5, R24 */
		/* 82247D6Ch case   22:*/		regs.R5 = regs.R24;
		/* 82247D6Ch case   22:*/		return 0x82247D70;
		  /* 82247D70h */ case   23:  		/* mr R4, R31 */
		/* 82247D70h case   23:*/		regs.R4 = regs.R31;
		/* 82247D70h case   23:*/		return 0x82247D74;
		  /* 82247D74h */ case   24:  		/* mr R3, R25 */
		/* 82247D74h case   24:*/		regs.R3 = regs.R25;
		/* 82247D74h case   24:*/		return 0x82247D78;
		  /* 82247D78h */ case   25:  		/* bl 115632 */
		/* 82247D78h case   25:*/		regs.LR = 0x82247D7C; return 0x82264128;
		/* 82247D78h case   25:*/		return 0x82247D7C;
		  /* 82247D7Ch */ case   26:  		/* mr R5, R3 */
		/* 82247D7Ch case   26:*/		regs.R5 = regs.R3;
		/* 82247D7Ch case   26:*/		return 0x82247D80;
		  /* 82247D80h */ case   27:  		/* mr R4, R30 */
		/* 82247D80h case   27:*/		regs.R4 = regs.R30;
		/* 82247D80h case   27:*/		return 0x82247D84;
		  /* 82247D84h */ case   28:  		/* mr R3, R25 */
		/* 82247D84h case   28:*/		regs.R3 = regs.R25;
		/* 82247D84h case   28:*/		return 0x82247D88;
		  /* 82247D88h */ case   29:  		/* bl 117656 */
		/* 82247D88h case   29:*/		regs.LR = 0x82247D8C; return 0x82264920;
		/* 82247D88h case   29:*/		return 0x82247D8C;
	}
	return 0x82247D8C;
} // Block from 82247D14h-82247D8Ch (30 instructions)

//////////////////////////////////////////////////////
// Block at 82247D8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247D8C);
		  /* 82247D8Ch */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 82247D8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82247D8Ch case    0:*/		return 0x82247D90;
		  /* 82247D90h */ case    1:  		/* addi R31, R31, 1 */
		/* 82247D90h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82247D90h case    1:*/		return 0x82247D94;
		  /* 82247D94h */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 82247D94h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82247D94h case    2:*/		return 0x82247D98;
		  /* 82247D98h */ case    3:  		/* bc 12, CR6_LT, -76 */
		/* 82247D98h case    3:*/		if ( regs.CR[6].lt ) { return 0x82247D4C;  }
		/* 82247D98h case    3:*/		return 0x82247D9C;
	}
	return 0x82247D9C;
} // Block from 82247D8Ch-82247D9Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82247D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247D9C);
		  /* 82247D9Ch */ case    0:  		/* lwz R11, <#[R20 + 4]> */
		/* 82247D9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 82247D9Ch case    0:*/		return 0x82247DA0;
		  /* 82247DA0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82247DA0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82247DA0h case    1:*/		return 0x82247DA4;
		  /* 82247DA4h */ case    2:  		/* bc 4, CR6_EQ, -116 */
		/* 82247DA4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82247D30;  }
		/* 82247DA4h case    2:*/		return 0x82247DA8;
		  /* 82247DA8h */ case    3:  		/* mr R31, R26 */
		/* 82247DA8h case    3:*/		regs.R31 = regs.R26;
		/* 82247DA8h case    3:*/		return 0x82247DAC;
		  /* 82247DACh */ case    4:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82247DACh case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82247DACh case    4:*/		return 0x82247DB0;
		  /* 82247DB0h */ case    5:  		/* bc 4, CR0_EQ, 248 */
		/* 82247DB0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82247EA8;  }
		/* 82247DB0h case    5:*/		return 0x82247DB4;
		  /* 82247DB4h */ case    6:  		/* lwz R11, <#[R31 + 228]> */
		/* 82247DB4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82247DB4h case    6:*/		return 0x82247DB8;
		  /* 82247DB8h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82247DB8h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82247DB8h case    7:*/		return 0x82247DBC;
		  /* 82247DBCh */ case    8:  		/* bc 12, CR0_EQ, 212 */
		/* 82247DBCh case    8:*/		if ( regs.CR[0].eq ) { return 0x82247E90;  }
		/* 82247DBCh case    8:*/		return 0x82247DC0;
		  /* 82247DC0h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 82247DC0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82247DC0h case    9:*/		return 0x82247DC4;
		  /* 82247DC4h */ case   10:  		/* mr R3, R31 */
		/* 82247DC4h case   10:*/		regs.R3 = regs.R31;
		/* 82247DC4h case   10:*/		return 0x82247DC8;
		  /* 82247DC8h */ case   11:  		/* lwz R11, <#[R11 + 44]> */
		/* 82247DC8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 82247DC8h case   11:*/		return 0x82247DCC;
		  /* 82247DCCh */ case   12:  		/* mtspr CTR, R11 */
		/* 82247DCCh case   12:*/		regs.CTR = regs.R11;
		/* 82247DCCh case   12:*/		return 0x82247DD0;
		  /* 82247DD0h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 82247DD0h case   13:*/		if ( 1 ) { regs.LR = 0x82247DD4; return (uint32)regs.CTR; }
		/* 82247DD0h case   13:*/		return 0x82247DD4;
		  /* 82247DD4h */ case   14:  		/* cmplwi CR0, R3, 0 */
		/* 82247DD4h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82247DD4h case   14:*/		return 0x82247DD8;
		  /* 82247DD8h */ case   15:  		/* bc 4, CR0_EQ, 184 */
		/* 82247DD8h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82247E90;  }
		/* 82247DD8h case   15:*/		return 0x82247DDC;
		  /* 82247DDCh */ case   16:  		/* lwz R11, <#[R31 + 20]> */
		/* 82247DDCh case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82247DDCh case   16:*/		return 0x82247DE0;
		  /* 82247DE0h */ case   17:  		/* mr R29, R23 */
		/* 82247DE0h case   17:*/		regs.R29 = regs.R23;
		/* 82247DE0h case   17:*/		return 0x82247DE4;
		  /* 82247DE4h */ case   18:  		/* cmpwi CR6, R11, 1 */
		/* 82247DE4h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82247DE4h case   18:*/		return 0x82247DE8;
		  /* 82247DE8h */ case   19:  		/* bc 12, CR6_LT, 168 */
		/* 82247DE8h case   19:*/		if ( regs.CR[6].lt ) { return 0x82247E90;  }
		/* 82247DE8h case   19:*/		return 0x82247DEC;
		  /* 82247DECh */ case   20:  		/* addi R28, R31, 236 */
		/* 82247DECh case   20:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0xEC);
		/* 82247DECh case   20:*/		return 0x82247DF0;
		  /* 82247DF0h */ case   21:  		/* lwz R30, <#[R28]> */
		/* 82247DF0h case   21:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 82247DF0h case   21:*/		return 0x82247DF4;
		  /* 82247DF4h */ case   22:  		/* lwz R11, <#[R30 + 16]> */
		/* 82247DF4h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82247DF4h case   22:*/		return 0x82247DF8;
		  /* 82247DF8h */ case   23:  		/* cmpwi CR6, R11, 0 */
		/* 82247DF8h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82247DF8h case   23:*/		return 0x82247DFC;
		  /* 82247DFCh */ case   24:  		/* bc 12, CR6_EQ, 44 */
		/* 82247DFCh case   24:*/		if ( regs.CR[6].eq ) { return 0x82247E28;  }
		/* 82247DFCh case   24:*/		return 0x82247E00;
		  /* 82247E00h */ case   25:  		/* lwz R11, <#[R30 + 228]> */
		/* 82247E00h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 82247E00h case   25:*/		return 0x82247E04;
		  /* 82247E04h */ case   26:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82247E04h case   26:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82247E04h case   26:*/		return 0x82247E08;
		  /* 82247E08h */ case   27:  		/* bc 4, CR0_EQ, 32 */
		/* 82247E08h case   27:*/		if ( !regs.CR[0].eq ) { return 0x82247E28;  }
		/* 82247E08h case   27:*/		return 0x82247E0C;
		  /* 82247E0Ch */ case   28:  		/* lwz R11, <#[R30 + 80]> */
		/* 82247E0Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000050) );
		/* 82247E0Ch case   28:*/		return 0x82247E10;
		  /* 82247E10h */ case   29:  		/* addi R10, R21, 4 */
		/* 82247E10h case   29:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R21,0x4);
		/* 82247E10h case   29:*/		return 0x82247E14;
		  /* 82247E14h */ case   30:  		/* mulli R11, R11, 12 */
		/* 82247E14h case   30:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82247E14h case   30:*/		return 0x82247E18;
		  /* 82247E18h */ case   31:  		/* lbzx R11, <#[R11 + R10]> */
		/* 82247E18h case   31:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82247E18h case   31:*/		return 0x82247E1C;
		  /* 82247E1Ch */ case   32:  		/* cmplwi CR0, R11, 0 */
		/* 82247E1Ch case   32:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82247E1Ch case   32:*/		return 0x82247E20;
		  /* 82247E20h */ case   33:  		/* mr R11, R23 */
		/* 82247E20h case   33:*/		regs.R11 = regs.R23;
		/* 82247E20h case   33:*/		return 0x82247E24;
		  /* 82247E24h */ case   34:  		/* bc 4, CR0_EQ, 8 */
		/* 82247E24h case   34:*/		if ( !regs.CR[0].eq ) { return 0x82247E2C;  }
		/* 82247E24h case   34:*/		return 0x82247E28;
	}
	return 0x82247E28;
} // Block from 82247D9Ch-82247E28h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82247E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247E28);
		  /* 82247E28h */ case    0:  		/* li R11, 0 */
		/* 82247E28h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82247E28h case    0:*/		return 0x82247E2C;
	}
	return 0x82247E2C;
} // Block from 82247E28h-82247E2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247E2C);
		  /* 82247E2Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82247E2Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82247E2Ch case    0:*/		return 0x82247E30;
		  /* 82247E30h */ case    1:  		/* bc 12, CR0_EQ, 76 */
		/* 82247E30h case    1:*/		if ( regs.CR[0].eq ) { return 0x82247E7C;  }
		/* 82247E30h case    1:*/		return 0x82247E34;
		  /* 82247E34h */ case    2:  		/* mr R5, R26 */
		/* 82247E34h case    2:*/		regs.R5 = regs.R26;
		/* 82247E34h case    2:*/		return 0x82247E38;
		  /* 82247E38h */ case    3:  		/* mr R4, R29 */
		/* 82247E38h case    3:*/		regs.R4 = regs.R29;
		/* 82247E38h case    3:*/		return 0x82247E3C;
		  /* 82247E3Ch */ case    4:  		/* mr R3, R31 */
		/* 82247E3Ch case    4:*/		regs.R3 = regs.R31;
		/* 82247E3Ch case    4:*/		return 0x82247E40;
		  /* 82247E40h */ case    5:  		/* bl 60328 */
		/* 82247E40h case    5:*/		regs.LR = 0x82247E44; return 0x822569E8;
		/* 82247E40h case    5:*/		return 0x82247E44;
		  /* 82247E44h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82247E44h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82247E44h case    6:*/		return 0x82247E48;
		  /* 82247E48h */ case    7:  		/* bc 4, CR0_EQ, 52 */
		/* 82247E48h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82247E7C;  }
		/* 82247E48h case    7:*/		return 0x82247E4C;
		  /* 82247E4Ch */ case    8:  		/* mr R5, R24 */
		/* 82247E4Ch case    8:*/		regs.R5 = regs.R24;
		/* 82247E4Ch case    8:*/		return 0x82247E50;
		  /* 82247E50h */ case    9:  		/* lwz R4, <#[R30 + 56]> */
		/* 82247E50h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000038) );
		/* 82247E50h case    9:*/		return 0x82247E54;
		  /* 82247E54h */ case   10:  		/* mr R3, R25 */
		/* 82247E54h case   10:*/		regs.R3 = regs.R25;
		/* 82247E54h case   10:*/		return 0x82247E58;
		  /* 82247E58h */ case   11:  		/* bl 115408 */
		/* 82247E58h case   11:*/		regs.LR = 0x82247E5C; return 0x82264128;
		/* 82247E58h case   11:*/		return 0x82247E5C;
		  /* 82247E5Ch */ case   12:  		/* rlwinm R11, R3, 27, 5, 31 */
		/* 82247E5Ch case   12:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R3);
		/* 82247E5Ch case   12:*/		return 0x82247E60;
		  /* 82247E60h */ case   13:  		/* rlwinm R10, R3, 0, 27, 31 */
		/* 82247E60h case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R3);
		/* 82247E60h case   13:*/		return 0x82247E64;
		  /* 82247E64h */ case   14:  		/* addi R11, R11, 2 */
		/* 82247E64h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82247E64h case   14:*/		return 0x82247E68;
		  /* 82247E68h */ case   15:  		/* slw R10, R23, R10 */
		/* 82247E68h case   15:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R23,regs.R10);
		/* 82247E68h case   15:*/		return 0x82247E6C;
		  /* 82247E6Ch */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82247E6Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82247E6Ch case   16:*/		return 0x82247E70;
		  /* 82247E70h */ case   17:  		/* lwzx R9, <#[R11 + R27]> */
		/* 82247E70h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82247E70h case   17:*/		return 0x82247E74;
		  /* 82247E74h */ case   18:  		/* or R10, R10, R9 */
		/* 82247E74h case   18:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82247E74h case   18:*/		return 0x82247E78;
		  /* 82247E78h */ case   19:  		/* stwx R10, <#[R11 + R27]> */
		/* 82247E78h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82247E78h case   19:*/		return 0x82247E7C;
	}
	return 0x82247E7C;
} // Block from 82247E2Ch-82247E7Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 82247E7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247E7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247E7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247E7C);
		  /* 82247E7Ch */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 82247E7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82247E7Ch case    0:*/		return 0x82247E80;
		  /* 82247E80h */ case    1:  		/* addi R29, R29, 1 */
		/* 82247E80h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82247E80h case    1:*/		return 0x82247E84;
		  /* 82247E84h */ case    2:  		/* addi R28, R28, 4 */
		/* 82247E84h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82247E84h case    2:*/		return 0x82247E88;
		  /* 82247E88h */ case    3:  		/* cmpw CR6, R29, R11 */
		/* 82247E88h case    3:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 82247E88h case    3:*/		return 0x82247E8C;
		  /* 82247E8Ch */ case    4:  		/* bc 4, CR6_GT, -156 */
		/* 82247E8Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x82247DF0;  }
		/* 82247E8Ch case    4:*/		return 0x82247E90;
	}
	return 0x82247E90;
} // Block from 82247E7Ch-82247E90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82247E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247E90);
		  /* 82247E90h */ case    0:  		/* lwz R11, <#[R31 + 228]> */
		/* 82247E90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82247E90h case    0:*/		return 0x82247E94;
		  /* 82247E94h */ case    1:  		/* lwz R31, <#[R31 + 8]> */
		/* 82247E94h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82247E94h case    1:*/		return 0x82247E98;
		  /* 82247E98h */ case    2:  		/* nor R11, R11, R11 */
		/* 82247E98h case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82247E98h case    2:*/		return 0x82247E9C;
		  /* 82247E9Ch */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82247E9Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82247E9Ch case    3:*/		return 0x82247EA0;
		  /* 82247EA0h */ case    4:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 82247EA0h case    4:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82247EA0h case    4:*/		return 0x82247EA4;
		  /* 82247EA4h */ case    5:  		/* bc 4, CR6_EQ, -248 */
		/* 82247EA4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82247DAC;  }
		/* 82247EA4h case    5:*/		return 0x82247EA8;
	}
	return 0x82247EA8;
} // Block from 82247E90h-82247EA8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82247EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247EA8);
		  /* 82247EA8h */ case    0:  		/* lwz R26, <#[R26 + 4]> */
		/* 82247EA8h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R26 + 0x00000004) );
		/* 82247EA8h case    0:*/		return 0x82247EAC;
	}
	return 0x82247EAC;
} // Block from 82247EA8h-82247EACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247EAC);
		  /* 82247EACh */ case    0:  		/* lwz R11, <#[R26 + 4]> */
		/* 82247EACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82247EACh case    0:*/		return 0x82247EB0;
		  /* 82247EB0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82247EB0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82247EB0h case    1:*/		return 0x82247EB4;
		  /* 82247EB4h */ case    2:  		/* bc 4, CR6_EQ, -1144 */
		/* 82247EB4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82247A3C;  }
		/* 82247EB4h case    2:*/		return 0x82247EB8;
		  /* 82247EB8h */ case    3:  		/* lwz R22, <#[R22 + 8]> */
		/* 82247EB8h case    3:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R22 + 0x00000008) );
		/* 82247EB8h case    3:*/		return 0x82247EBC;
		  /* 82247EBCh */ case    4:  		/* lwz R11, <#[R22 + 8]> */
		/* 82247EBCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 82247EBCh case    4:*/		return 0x82247EC0;
		  /* 82247EC0h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 82247EC0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82247EC0h case    5:*/		return 0x82247EC4;
		  /* 82247EC4h */ case    6:  		/* bc 4, CR6_EQ, -1384 */
		/* 82247EC4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8224795C;  }
		/* 82247EC4h case    6:*/		return 0x82247EC8;
	}
	return 0x82247EC8;
} // Block from 82247EACh-82247EC8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82247EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247EC8);
		  /* 82247EC8h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 82247EC8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82247EC8h case    0:*/		return 0x82247ECC;
		  /* 82247ECCh */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 82247ECCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82247EDC;  }
		/* 82247ECCh case    1:*/		return 0x82247ED0;
		  /* 82247ED0h */ case    2:  		/* addi R4, R27, -4 */
		/* 82247ED0h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R27,0xFFFFFFFC);
		/* 82247ED0h case    2:*/		return 0x82247ED4;
		  /* 82247ED4h */ case    3:  		/* lwz R3, <#[R27 - 4]> */
		/* 82247ED4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFFFFFC) );
		/* 82247ED4h case    3:*/		return 0x82247ED8;
		  /* 82247ED8h */ case    4:  		/* bl -178328 */
		/* 82247ED8h case    4:*/		regs.LR = 0x82247EDC; return 0x8221C640;
		/* 82247ED8h case    4:*/		return 0x82247EDC;
	}
	return 0x82247EDC;
} // Block from 82247EC8h-82247EDCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82247EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247EDC);
		  /* 82247EDCh */ case    0:  		/* addi R1, R1, 208 */
		/* 82247EDCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 82247EDCh case    0:*/		return 0x82247EE0;
		  /* 82247EE0h */ case    1:  		/* b -1797216 */
		/* 82247EE0h case    1:*/		return 0x82091280;
		/* 82247EE0h case    1:*/		return 0x82247EE4;
		  /* 82247EE4h */ case    2:  		/* nop */
		/* 82247EE4h case    2:*/		cpu::op::nop();
		/* 82247EE4h case    2:*/		return 0x82247EE8;
	}
	return 0x82247EE8;
} // Block from 82247EDCh-82247EE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82247EE8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247EE8);
		  /* 82247EE8h */ case    0:  		/* mfspr R12, LR */
		/* 82247EE8h case    0:*/		regs.R12 = regs.LR;
		/* 82247EE8h case    0:*/		return 0x82247EEC;
		  /* 82247EECh */ case    1:  		/* bl -1797324 */
		/* 82247EECh case    1:*/		regs.LR = 0x82247EF0; return 0x82091220;
		/* 82247EECh case    1:*/		return 0x82247EF0;
		  /* 82247EF0h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 82247EF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 82247EF0h case    2:*/		return 0x82247EF4;
		  /* 82247EF4h */ case    3:  		/* mr R31, R3 */
		/* 82247EF4h case    3:*/		regs.R31 = regs.R3;
		/* 82247EF4h case    3:*/		return 0x82247EF8;
		  /* 82247EF8h */ case    4:  		/* bl -2040 */
		/* 82247EF8h case    4:*/		regs.LR = 0x82247EFC; return 0x82247700;
		/* 82247EF8h case    4:*/		return 0x82247EFC;
		  /* 82247EFCh */ case    5:  		/* lwz R9, <#[R3 + 2080]> */
		/* 82247EFCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000820) );
		/* 82247EFCh case    5:*/		return 0x82247F00;
		  /* 82247F00h */ case    6:  		/* lis R11, -32215 */
		/* 82247F00h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82247F00h case    6:*/		return 0x82247F04;
		  /* 82247F04h */ case    7:  		/* li R18, 0 */
		/* 82247F04h case    7:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 82247F04h case    7:*/		return 0x82247F08;
		  /* 82247F08h */ case    8:  		/* addi R16, R9, 1 */
		/* 82247F08h case    8:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R9,0x1);
		/* 82247F08h case    8:*/		return 0x82247F0C;
		  /* 82247F0Ch */ case    9:  		/* mr R10, R18 */
		/* 82247F0Ch case    9:*/		regs.R10 = regs.R18;
		/* 82247F0Ch case    9:*/		return 0x82247F10;
		  /* 82247F10h */ case   10:  		/* lwz R9, <#[R3 + 12]> */
		/* 82247F10h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 82247F10h case   10:*/		return 0x82247F14;
		  /* 82247F14h */ case   11:  		/* lwz R9, <#[R9 + 1524]> */
		/* 82247F14h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x000005F4) );
		/* 82247F14h case   11:*/		return 0x82247F18;
		  /* 82247F18h */ case   12:  		/* stw R18, <#[R11 - 25560]> */
		/* 82247F18h case   12:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0xFFFF9C28) );
		/* 82247F18h case   12:*/		return 0x82247F1C;
		  /* 82247F1Ch */ case   13:  		/* lwz R10, <#[R3 + 12]> */
		/* 82247F1Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82247F1Ch case   13:*/		return 0x82247F20;
		  /* 82247F20h */ case   14:  		/* addi R6, R9, 1 */
		/* 82247F20h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R9,0x1);
		/* 82247F20h case   14:*/		return 0x82247F24;
		  /* 82247F24h */ case   15:  		/* add R24, R16, R6 */
		/* 82247F24h case   15:*/		cpu::op::add<0>(regs,&regs.R24,regs.R16,regs.R6);
		/* 82247F24h case   15:*/		return 0x82247F28;
		  /* 82247F28h */ case   16:  		/* lwz R10, <#[R10 + 2136]> */
		/* 82247F28h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000858) );
		/* 82247F28h case   16:*/		return 0x82247F2C;
		  /* 82247F2Ch */ case   17:  		/* rlwinm. R10, R10, 21, 31, 31 */
		/* 82247F2Ch case   17:*/		cpu::op::rlwinm<1,21,31,31>(regs,&regs.R10,regs.R10);
		/* 82247F2Ch case   17:*/		return 0x82247F30;
		  /* 82247F30h */ case   18:  		/* bc 12, CR0_EQ, 40 */
		/* 82247F30h case   18:*/		if ( regs.CR[0].eq ) { return 0x82247F58;  }
		/* 82247F30h case   18:*/		return 0x82247F34;
		  /* 82247F34h */ case   19:  		/* cmpwi CR6, R6, 0 */
		/* 82247F34h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 82247F34h case   19:*/		return 0x82247F38;
		  /* 82247F38h */ case   20:  		/* bc 4, CR6_EQ, 32 */
		/* 82247F38h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82247F58;  }
		/* 82247F38h case   20:*/		return 0x82247F3C;
		  /* 82247F3Ch */ case   21:  		/* stw R18, <#[R11 - 25560]> */
		/* 82247F3Ch case   21:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0xFFFF9C28) );
		/* 82247F3Ch case   21:*/		return 0x82247F40;
		  /* 82247F40h */ case   22:  		/* lis R9, -32252 */
		/* 82247F40h case   22:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82247F40h case   22:*/		return 0x82247F44;
		  /* 82247F44h */ case   23:  		/* lwz R3, <#[R3 + 12]> */
		/* 82247F44h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 82247F44h case   23:*/		return 0x82247F48;
		  /* 82247F48h */ case   24:  		/* mr R10, R18 */
		/* 82247F48h case   24:*/		regs.R10 = regs.R18;
		/* 82247F48h case   24:*/		return 0x82247F4C;
		  /* 82247F4Ch */ case   25:  		/* addi R4, R9, 13312 */
		/* 82247F4Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x3400);
		/* 82247F4Ch case   25:*/		return 0x82247F50;
		  /* 82247F50h */ case   26:  		/* bl -174992 */
		/* 82247F50h case   26:*/		regs.LR = 0x82247F54; return 0x8221D3C0;
		/* 82247F50h case   26:*/		return 0x82247F54;
		  /* 82247F54h */ case   27:  		/* b 1620 */
		/* 82247F54h case   27:*/		return 0x822485A8;
		/* 82247F54h case   27:*/		return 0x82247F58;
	}
	return 0x82247F58;
} // Block from 82247EE8h-82247F58h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82247F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247F58);
		  /* 82247F58h */ case    0:  		/* lis R11, -32251 */
		/* 82247F58h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82247F58h case    0:*/		return 0x82247F5C;
		  /* 82247F5Ch */ case    1:  		/* lwz R8, <#[R31 + 136]> */
		/* 82247F5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000088) );
		/* 82247F5Ch case    1:*/		return 0x82247F60;
		  /* 82247F60h */ case    2:  		/* addi R7, R11, -19064 */
		/* 82247F60h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFB588);
		/* 82247F60h case    2:*/		return 0x82247F64;
		  /* 82247F64h */ case    3:  		/* stw R7, <#[R1 + 88]> */
		/* 82247F64h case    3:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 82247F64h case    3:*/		return 0x82247F68;
		  /* 82247F68h */ case    4:  		/* b 136 */
		/* 82247F68h case    4:*/		return 0x82247FF0;
		/* 82247F68h case    4:*/		return 0x82247F6C;
		  /* 82247F6Ch */ case    5:  		/* lwz R11, <#[R8 + 28]> */
		/* 82247F6Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000001C) );
		/* 82247F6Ch case    5:*/		return 0x82247F70;
		  /* 82247F70h */ case    6:  		/* b 112 */
		/* 82247F70h case    6:*/		return 0x82247FE0;
		/* 82247F70h case    6:*/		return 0x82247F74;
		  /* 82247F74h */ case    7:  		/* lwz R9, <#[R11 + 228]> */
		/* 82247F74h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x000000E4) );
		/* 82247F74h case    7:*/		return 0x82247F78;
		  /* 82247F78h */ case    8:  		/* rlwinm. R10, R9, 0, 31, 31 */
		/* 82247F78h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R9);
		/* 82247F78h case    8:*/		return 0x82247F7C;
		  /* 82247F7Ch */ case    9:  		/* bc 12, CR0_EQ, 96 */
		/* 82247F7Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82247FDC;  }
		/* 82247F7Ch case    9:*/		return 0x82247F80;
		  /* 82247F80h */ case   10:  		/* rlwinm. R10, R9, 26, 31, 31 */
		/* 82247F80h case   10:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R10,regs.R9);
		/* 82247F80h case   10:*/		return 0x82247F84;
		  /* 82247F84h */ case   11:  		/* bc 4, CR0_EQ, 88 */
		/* 82247F84h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82247FDC;  }
		/* 82247F84h case   11:*/		return 0x82247F88;
		  /* 82247F88h */ case   12:  		/* lwz R10, <#[R11 + 16]> */
		/* 82247F88h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82247F88h case   12:*/		return 0x82247F8C;
		  /* 82247F8Ch */ case   13:  		/* cmpwi CR6, R10, 0 */
		/* 82247F8Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82247F8Ch case   13:*/		return 0x82247F90;
		  /* 82247F90h */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 82247F90h case   14:*/		if ( regs.CR[6].eq ) { return 0x82247FB8;  }
		/* 82247F90h case   14:*/		return 0x82247F94;
		  /* 82247F94h */ case   15:  		/* rlwinm. R10, R9, 31, 31, 31 */
		/* 82247F94h case   15:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R10,regs.R9);
		/* 82247F94h case   15:*/		return 0x82247F98;
		  /* 82247F98h */ case   16:  		/* bc 4, CR0_EQ, 32 */
		/* 82247F98h case   16:*/		if ( !regs.CR[0].eq ) { return 0x82247FB8;  }
		/* 82247F98h case   16:*/		return 0x82247F9C;
		  /* 82247F9Ch */ case   17:  		/* lwz R10, <#[R11 + 80]> */
		/* 82247F9Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 82247F9Ch case   17:*/		return 0x82247FA0;
		  /* 82247FA0h */ case   18:  		/* addi R5, R7, 4 */
		/* 82247FA0h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R7,0x4);
		/* 82247FA0h case   18:*/		return 0x82247FA4;
		  /* 82247FA4h */ case   19:  		/* mulli R10, R10, 12 */
		/* 82247FA4h case   19:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82247FA4h case   19:*/		return 0x82247FA8;
		  /* 82247FA8h */ case   20:  		/* lbzx R10, <#[R10 + R5]> */
		/* 82247FA8h case   20:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 82247FA8h case   20:*/		return 0x82247FAC;
		  /* 82247FACh */ case   21:  		/* cmplwi CR0, R10, 0 */
		/* 82247FACh case   21:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82247FACh case   21:*/		return 0x82247FB0;
	}
	return 0x82247FB0;
} // Block from 82247F58h-82247FB0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82247FB0h
// Function '?FindOrCreateVReg@VRegTable@XGRAPHICS@@AAAPAVVRegInfo@2@Ukonst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247FB0);
		  /* 82247FB0h */ case    0:  		/* li R10, 1 */
		/* 82247FB0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82247FB0h case    0:*/		return 0x82247FB4;
		  /* 82247FB4h */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 82247FB4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82247FBC;  }
		/* 82247FB4h case    1:*/		return 0x82247FB8;
	}
	return 0x82247FB8;
} // Block from 82247FB0h-82247FB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82247FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247FB8);
		  /* 82247FB8h */ case    0:  		/* mr R10, R18 */
		/* 82247FB8h case    0:*/		regs.R10 = regs.R18;
		/* 82247FB8h case    0:*/		return 0x82247FBC;
	}
	return 0x82247FBC;
} // Block from 82247FB8h-82247FBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247FBC);
		  /* 82247FBCh */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82247FBCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82247FBCh case    0:*/		return 0x82247FC0;
		  /* 82247FC0h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 82247FC0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82247FDC;  }
		/* 82247FC0h case    1:*/		return 0x82247FC4;
		  /* 82247FC4h */ case    2:  		/* lwz R10, <#[R11 + 56]> */
		/* 82247FC4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 82247FC4h case    2:*/		return 0x82247FC8;
		  /* 82247FC8h */ case    3:  		/* ori R9, R9, 128 */
		/* 82247FC8h case    3:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x80);
		/* 82247FC8h case    3:*/		return 0x82247FCC;
		  /* 82247FCCh */ case    4:  		/* stw R18, <#[R11 + 80]> */
		/* 82247FCCh case    4:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000050) );
		/* 82247FCCh case    4:*/		return 0x82247FD0;
	}
	return 0x82247FD0;
} // Block from 82247FBCh-82247FD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82247FD0h
// Function '?FindOrCreateVReg@VRegTable@XGRAPHICS@@AAAPAVVRegInfo@2@Ukonst@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247FD0);
		  /* 82247FD0h */ case    0:  		/* add R10, R10, R16 */
		/* 82247FD0h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R16);
		/* 82247FD0h case    0:*/		return 0x82247FD4;
		  /* 82247FD4h */ case    1:  		/* stw R9, <#[R11 + 228]> */
		/* 82247FD4h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x000000E4) );
		/* 82247FD4h case    1:*/		return 0x82247FD8;
		  /* 82247FD8h */ case    2:  		/* stw R10, <#[R11 + 56]> */
		/* 82247FD8h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 82247FD8h case    2:*/		return 0x82247FDC;
	}
	return 0x82247FDC;
} // Block from 82247FD0h-82247FDCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82247FDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247FDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247FDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247FDC);
		  /* 82247FDCh */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82247FDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82247FDCh case    0:*/		return 0x82247FE0;
	}
	return 0x82247FE0;
} // Block from 82247FDCh-82247FE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82247FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247FE0);
		  /* 82247FE0h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82247FE0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82247FE0h case    0:*/		return 0x82247FE4;
		  /* 82247FE4h */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 82247FE4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82247FE4h case    1:*/		return 0x82247FE8;
		  /* 82247FE8h */ case    2:  		/* bc 4, CR6_EQ, -116 */
		/* 82247FE8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82247F74;  }
		/* 82247FE8h case    2:*/		return 0x82247FEC;
		  /* 82247FECh */ case    3:  		/* lwz R8, <#[R8 + 8]> */
		/* 82247FECh case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 82247FECh case    3:*/		return 0x82247FF0;
	}
	return 0x82247FF0;
} // Block from 82247FE0h-82247FF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82247FF0h
// Function '?FindOrCreateVReg@VRegTable@XGRAPHICS@@AAAPAVVRegInfo@2@Ukonst@2@00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82247FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82247FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82247FF0);
		  /* 82247FF0h */ case    0:  		/* lwz R11, <#[R8 + 8]> */
		/* 82247FF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 82247FF0h case    0:*/		return 0x82247FF4;
		  /* 82247FF4h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82247FF4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82247FF4h case    1:*/		return 0x82247FF8;
		  /* 82247FF8h */ case    2:  		/* bc 4, CR6_EQ, -140 */
		/* 82247FF8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82247F6C;  }
		/* 82247FF8h case    2:*/		return 0x82247FFC;
		  /* 82247FFCh */ case    3:  		/* lis R11, -32252 */
		/* 82247FFCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82247FFCh case    3:*/		return 0x82248000;
		  /* 82248000h */ case    4:  		/* lwz R3, <#[R31 + 12]> */
		/* 82248000h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 82248000h case    4:*/		return 0x82248004;
		  /* 82248004h */ case    5:  		/* mr R7, R24 */
		/* 82248004h case    5:*/		regs.R7 = regs.R24;
		/* 82248004h case    5:*/		return 0x82248008;
		  /* 82248008h */ case    6:  		/* addi R4, R11, 13232 */
		/* 82248008h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x33B0);
		/* 82248008h case    6:*/		return 0x8224800C;
		  /* 8224800Ch */ case    7:  		/* mr R5, R16 */
		/* 8224800Ch case    7:*/		regs.R5 = regs.R16;
		/* 8224800Ch case    7:*/		return 0x82248010;
	}
	return 0x82248010;
} // Block from 82247FF0h-82248010h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82248010h
// Function '?FindOrCreateVReg@VRegTable@XGRAPHICS@@AAAPAVVRegInfo@2@Ukonst@2@000@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248010);
		  /* 82248010h */ case    0:  		/* bl -175184 */
		/* 82248010h case    0:*/		regs.LR = 0x82248014; return 0x8221D3C0;
		/* 82248010h case    0:*/		return 0x82248014;
		  /* 82248014h */ case    1:  		/* mr R4, R24 */
		/* 82248014h case    1:*/		regs.R4 = regs.R24;
		/* 82248014h case    1:*/		return 0x82248018;
		  /* 82248018h */ case    2:  		/* mr R3, R31 */
		/* 82248018h case    2:*/		regs.R3 = regs.R31;
		/* 82248018h case    2:*/		return 0x8224801C;
		  /* 8224801Ch */ case    3:  		/* bl 112316 */
		/* 8224801Ch case    3:*/		regs.LR = 0x82248020; return 0x822636D8;
		/* 8224801Ch case    3:*/		return 0x82248020;
		  /* 82248020h */ case    4:  		/* lwz R11, <#[R31 + 12]> */
		/* 82248020h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82248020h case    4:*/		return 0x82248024;
		  /* 82248024h */ case    5:  		/* li R4, 24 */
		/* 82248024h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 82248024h case    5:*/		return 0x82248028;
	}
	return 0x82248028;
} // Block from 82248010h-82248028h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82248028h
// Function '?AssignKonstantRegisters@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248028);
		  /* 82248028h */ case    0:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82248028h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82248028h case    0:*/		return 0x8224802C;
		  /* 8224802Ch */ case    1:  		/* mr R3, R30 */
		/* 8224802Ch case    1:*/		regs.R3 = regs.R30;
		/* 8224802Ch case    1:*/		return 0x82248030;
		  /* 82248030h */ case    2:  		/* bl -179064 */
		/* 82248030h case    2:*/		regs.LR = 0x82248034; return 0x8221C4B8;
		/* 82248030h case    2:*/		return 0x82248034;
		  /* 82248034h */ case    3:  		/* mr R11, R3 */
		/* 82248034h case    3:*/		regs.R11 = regs.R3;
		/* 82248034h case    3:*/		return 0x82248038;
		  /* 82248038h */ case    4:  		/* addic. R3, R3, 4 */
		/* 82248038h case    4:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82248038h case    4:*/		return 0x8224803C;
		  /* 8224803Ch */ case    5:  		/* stw R30, <#[R11]> */
		/* 8224803Ch case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 8224803Ch case    5:*/		return 0x82248040;
		  /* 82248040h */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 82248040h case    6:*/		if ( regs.CR[0].eq ) { return 0x8224805C;  }
		/* 82248040h case    6:*/		return 0x82248044;
		  /* 82248044h */ case    7:  		/* mr R5, R24 */
		/* 82248044h case    7:*/		regs.R5 = regs.R24;
		/* 82248044h case    7:*/		return 0x82248048;
		  /* 82248048h */ case    8:  		/* lwz R6, <#[R31 + 12]> */
		/* 82248048h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000000C) );
		/* 82248048h case    8:*/		return 0x8224804C;
		  /* 8224804Ch */ case    9:  		/* mr R4, R16 */
		/* 8224804Ch case    9:*/		regs.R4 = regs.R16;
		/* 8224804Ch case    9:*/		return 0x82248050;
		  /* 82248050h */ case   10:  		/* bl 116152 */
		/* 82248050h case   10:*/		regs.LR = 0x82248054; return 0x82264608;
		/* 82248050h case   10:*/		return 0x82248054;
		  /* 82248054h */ case   11:  		/* mr R11, R3 */
		/* 82248054h case   11:*/		regs.R11 = regs.R3;
		/* 82248054h case   11:*/		return 0x82248058;
		  /* 82248058h */ case   12:  		/* b 8 */
		/* 82248058h case   12:*/		return 0x82248060;
		/* 82248058h case   12:*/		return 0x8224805C;
	}
	return 0x8224805C;
} // Block from 82248028h-8224805Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224805Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224805C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224805C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224805C);
		  /* 8224805Ch */ case    0:  		/* mr R11, R18 */
		/* 8224805Ch case    0:*/		regs.R11 = regs.R18;
		/* 8224805Ch case    0:*/		return 0x82248060;
	}
	return 0x82248060;
} // Block from 8224805Ch-82248060h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82248060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248060);
		  /* 82248060h */ case    0:  		/* stw R11, <#[R31 + 2064]> */
		/* 82248060h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000810) );
		/* 82248060h case    0:*/		return 0x82248064;
		  /* 82248064h */ case    1:  		/* mr R3, R31 */
		/* 82248064h case    1:*/		regs.R3 = regs.R31;
		/* 82248064h case    1:*/		return 0x82248068;
	}
	return 0x82248068;
} // Block from 82248060h-82248068h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82248068h
// Function '?first@bitset@XGRAPHICS@@QBAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248068);
		  /* 82248068h */ case    0:  		/* mr R29, R18 */
		/* 82248068h case    0:*/		regs.R29 = regs.R18;
		/* 82248068h case    0:*/		return 0x8224806C;
		  /* 8224806Ch */ case    1:  		/* stw R18, <#[R1 + 80]> */
		/* 8224806Ch case    1:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000050) );
		/* 8224806Ch case    1:*/		return 0x82248070;
		  /* 82248070h */ case    2:  		/* mr R26, R18 */
		/* 82248070h case    2:*/		regs.R26 = regs.R18;
		/* 82248070h case    2:*/		return 0x82248074;
		  /* 82248074h */ case    3:  		/* mr R17, R18 */
		/* 82248074h case    3:*/		regs.R17 = regs.R18;
		/* 82248074h case    3:*/		return 0x82248078;
		  /* 82248078h */ case    4:  		/* mr R14, R18 */
		/* 82248078h case    4:*/		regs.R14 = regs.R18;
		/* 82248078h case    4:*/		return 0x8224807C;
		  /* 8224807Ch */ case    5:  		/* mr R20, R18 */
		/* 8224807Ch case    5:*/		regs.R20 = regs.R18;
		/* 8224807Ch case    5:*/		return 0x82248080;
		  /* 82248080h */ case    6:  		/* bl -73136 */
		/* 82248080h case    6:*/		regs.LR = 0x82248084; return 0x822362D0;
		/* 82248080h case    6:*/		return 0x82248084;
		  /* 82248084h */ case    7:  		/* mr R15, R3 */
		/* 82248084h case    7:*/		regs.R15 = regs.R3;
		/* 82248084h case    7:*/		return 0x82248088;
		  /* 82248088h */ case    8:  		/* addi R19, R31, 128 */
		/* 82248088h case    8:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R31,0x80);
		/* 82248088h case    8:*/		return 0x8224808C;
		  /* 8224808Ch */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 8224808Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224808Ch case    9:*/		return 0x82248090;
		  /* 82248090h */ case   10:  		/* mr R27, R18 */
		/* 82248090h case   10:*/		regs.R27 = regs.R18;
		/* 82248090h case   10:*/		return 0x82248094;
		  /* 82248094h */ case   11:  		/* cmpwi CR6, R17, 0 */
		/* 82248094h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R17,0x00000000);
		/* 82248094h case   11:*/		return 0x82248098;
		  /* 82248098h */ case   12:  		/* stw R18, <#[R1 + 84]> */
		/* 82248098h case   12:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000054) );
		/* 82248098h case   12:*/		return 0x8224809C;
		  /* 8224809Ch */ case   13:  		/* lwz R10, <#[R11 + 1492]> */
		/* 8224809Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000005D4) );
		/* 8224809Ch case   13:*/		return 0x822480A0;
		  /* 822480A0h */ case   14:  		/* addi R10, R10, 1 */
		/* 822480A0h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822480A0h case   14:*/		return 0x822480A4;
		  /* 822480A4h */ case   15:  		/* stw R10, <#[R11 + 1492]> */
		/* 822480A4h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000005D4) );
		/* 822480A4h case   15:*/		return 0x822480A8;
		  /* 822480A8h */ case   16:  		/* bc 4, CR6_GT, 20 */
		/* 822480A8h case   16:*/		if ( !regs.CR[6].gt ) { return 0x822480BC;  }
		/* 822480A8h case   16:*/		return 0x822480AC;
		  /* 822480ACh */ case   17:  		/* lwz R3, <#[R31 + 2064]> */
		/* 822480ACh case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 822480ACh case   17:*/		return 0x822480B0;
		  /* 822480B0h */ case   18:  		/* bl 117184 */
		/* 822480B0h case   18:*/		regs.LR = 0x822480B4; return 0x82264A70;
		/* 822480B0h case   18:*/		return 0x822480B4;
		  /* 822480B4h */ case   19:  		/* lwz R3, <#[R31 + 2064]> */
		/* 822480B4h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 822480B4h case   19:*/		return 0x822480B8;
	}
	return 0x822480B8;
} // Block from 82248068h-822480B8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822480B8h
// Function '?MakeRegisterNonAllocatable@CFG@XGRAPHICS@@QAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822480B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822480B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822480B8);
		  /* 822480B8h */ case    0:  		/* bl 115280 */
		/* 822480B8h case    0:*/		regs.LR = 0x822480BC; return 0x82264308;
		/* 822480B8h case    0:*/		return 0x822480BC;
	}
	return 0x822480BC;
} // Block from 822480B8h-822480BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822480BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822480BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822480BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822480BC);
		  /* 822480BCh */ case    0:  		/* mr R7, R26 */
		/* 822480BCh case    0:*/		regs.R7 = regs.R26;
		/* 822480BCh case    0:*/		return 0x822480C0;
		  /* 822480C0h */ case    1:  		/* lwz R4, <#[R31 + 2064]> */
		/* 822480C0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000810) );
		/* 822480C0h case    1:*/		return 0x822480C4;
		  /* 822480C4h */ case    2:  		/* mr R6, R24 */
		/* 822480C4h case    2:*/		regs.R6 = regs.R24;
		/* 822480C4h case    2:*/		return 0x822480C8;
		  /* 822480C8h */ case    3:  		/* mr R5, R16 */
		/* 822480C8h case    3:*/		regs.R5 = regs.R16;
		/* 822480C8h case    3:*/		return 0x822480CC;
		  /* 822480CCh */ case    4:  		/* mr R3, R31 */
		/* 822480CCh case    4:*/		regs.R3 = regs.R31;
		/* 822480CCh case    4:*/		return 0x822480D0;
		  /* 822480D0h */ case    5:  		/* bl -2136 */
		/* 822480D0h case    5:*/		regs.LR = 0x822480D4; return 0x82247878;
		/* 822480D0h case    5:*/		return 0x822480D4;
		  /* 822480D4h */ case    6:  		/* mr R3, R19 */
		/* 822480D4h case    6:*/		regs.R3 = regs.R19;
		/* 822480D4h case    6:*/		return 0x822480D8;
		  /* 822480D8h */ case    7:  		/* mr R26, R18 */
		/* 822480D8h case    7:*/		regs.R26 = regs.R18;
		/* 822480D8h case    7:*/		return 0x822480DC;
		  /* 822480DCh */ case    8:  		/* mr R21, R18 */
		/* 822480DCh case    8:*/		regs.R21 = regs.R18;
		/* 822480DCh case    8:*/		return 0x822480E0;
		  /* 822480E0h */ case    9:  		/* bl 46976 */
		/* 822480E0h case    9:*/		regs.LR = 0x822480E4; return 0x82253860;
		/* 822480E0h case    9:*/		return 0x822480E4;
		  /* 822480E4h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 822480E4h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822480E4h case   10:*/		return 0x822480E8;
	}
	return 0x822480E8;
} // Block from 822480BCh-822480E8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822480E8h
// Function '?IsRegisterAllocatable@CFG@XGRAPHICS@@QBA_NH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822480E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822480E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822480E8);
		  /* 822480E8h */ case    0:  		/* bc 4, CR0_GT, 940 */
		/* 822480E8h case    0:*/		if ( !regs.CR[0].gt ) { return 0x82248494;  }
		/* 822480E8h case    0:*/		return 0x822480EC;
		  /* 822480ECh */ case    1:  		/* mr R22, R15 */
		/* 822480ECh case    1:*/		regs.R22 = regs.R15;
		/* 822480ECh case    1:*/		return 0x822480F0;
		  /* 822480F0h */ case    2:  		/* lwz R23, <#[R22]> */
		/* 822480F0h case    2:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R22 + 0x00000000) );
		/* 822480F0h case    2:*/		return 0x822480F4;
		  /* 822480F4h */ case    3:  		/* li R11, 1 */
		/* 822480F4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822480F4h case    3:*/		return 0x822480F8;
		  /* 822480F8h */ case    4:  		/* lwz R25, <#[R23 + 28]> */
		/* 822480F8h case    4:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R23 + 0x0000001C) );
		/* 822480F8h case    4:*/		return 0x822480FC;
		  /* 822480FCh */ case    5:  		/* b 884 */
		/* 822480FCh case    5:*/		return 0x82248470;
		/* 822480FCh case    5:*/		return 0x82248100;
		  /* 82248100h */ case    6:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82248100h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82248100h case    6:*/		return 0x82248104;
		  /* 82248104h */ case    7:  		/* bc 12, CR0_EQ, 860 */
		/* 82248104h case    7:*/		if ( regs.CR[0].eq ) { return 0x82248460;  }
		/* 82248104h case    7:*/		return 0x82248108;
		  /* 82248108h */ case    8:  		/* mr R11, R18 */
		/* 82248108h case    8:*/		regs.R11 = regs.R18;
		/* 82248108h case    8:*/		return 0x8224810C;
		  /* 8224810Ch */ case    9:  		/* mr R28, R25 */
		/* 8224810Ch case    9:*/		regs.R28 = regs.R25;
		/* 8224810Ch case    9:*/		return 0x82248110;
		  /* 82248110h */ case   10:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82248110h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82248110h case   10:*/		return 0x82248114;
		  /* 82248114h */ case   11:  		/* bc 4, CR0_EQ, 844 */
		/* 82248114h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82248460;  }
		/* 82248114h case   11:*/		return 0x82248118;
	}
	return 0x82248118;
} // Block from 822480E8h-82248118h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82248118h
// Function '?ReservePhysicalRegister@CFG@XGRAPHICS@@QAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248118);
		  /* 82248118h */ case    0:  		/* lwz R11, <#[R28 + 228]> */
		/* 82248118h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82248118h case    0:*/		return 0x8224811C;
		  /* 8224811Ch */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224811Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224811Ch case    1:*/		return 0x82248120;
		  /* 82248120h */ case    2:  		/* bc 12, CR0_EQ, 800 */
		/* 82248120h case    2:*/		if ( regs.CR[0].eq ) { return 0x82248440;  }
		/* 82248120h case    2:*/		return 0x82248124;
		  /* 82248124h */ case    3:  		/* lwz R11, <#[R28]> */
		/* 82248124h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82248124h case    3:*/		return 0x82248128;
		  /* 82248128h */ case    4:  		/* mr R3, R28 */
		/* 82248128h case    4:*/		regs.R3 = regs.R28;
		/* 82248128h case    4:*/		return 0x8224812C;
		  /* 8224812Ch */ case    5:  		/* lwz R11, <#[R11 + 44]> */
		/* 8224812Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 8224812Ch case    5:*/		return 0x82248130;
		  /* 82248130h */ case    6:  		/* mtspr CTR, R11 */
		/* 82248130h case    6:*/		regs.CTR = regs.R11;
		/* 82248130h case    6:*/		return 0x82248134;
		  /* 82248134h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82248134h case    7:*/		if ( 1 ) { regs.LR = 0x82248138; return (uint32)regs.CTR; }
		/* 82248134h case    7:*/		return 0x82248138;
		  /* 82248138h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 82248138h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82248138h case    8:*/		return 0x8224813C;
		  /* 8224813Ch */ case    9:  		/* bc 4, CR0_EQ, 772 */
		/* 8224813Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x82248440;  }
		/* 8224813Ch case    9:*/		return 0x82248140;
		  /* 82248140h */ case   10:  		/* lwz R11, <#[R28 + 228]> */
		/* 82248140h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82248140h case   10:*/		return 0x82248144;
		  /* 82248144h */ case   11:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 82248144h case   11:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 82248144h case   11:*/		return 0x82248148;
	}
	return 0x82248148;
} // Block from 82248118h-82248148h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82248148h
// Function '?grow@bitset@XGRAPHICS@@QAA_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248148);
		  /* 82248148h */ case    0:  		/* bc 12, CR0_EQ, 504 */
		/* 82248148h case    0:*/		if ( regs.CR[0].eq ) { return 0x82248340;  }
		/* 82248148h case    0:*/		return 0x8224814C;
		  /* 8224814Ch */ case    1:  		/* mr R5, R26 */
		/* 8224814Ch case    1:*/		regs.R5 = regs.R26;
		/* 8224814Ch case    1:*/		return 0x82248150;
		  /* 82248150h */ case    2:  		/* lwz R4, <#[R28 + 56]> */
		/* 82248150h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000038) );
		/* 82248150h case    2:*/		return 0x82248154;
		  /* 82248154h */ case    3:  		/* lwz R3, <#[R31 + 2064]> */
		/* 82248154h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 82248154h case    3:*/		return 0x82248158;
		  /* 82248158h */ case    4:  		/* bl 114640 */
		/* 82248158h case    4:*/		regs.LR = 0x8224815C; return 0x82264128;
		/* 82248158h case    4:*/		return 0x8224815C;
		  /* 8224815Ch */ case    5:  		/* mr R30, R3 */
		/* 8224815Ch case    5:*/		regs.R30 = regs.R3;
		/* 8224815Ch case    5:*/		return 0x82248160;
		  /* 82248160h */ case    6:  		/* mr R3, R28 */
		/* 82248160h case    6:*/		regs.R3 = regs.R28;
		/* 82248160h case    6:*/		return 0x82248164;
		  /* 82248164h */ case    7:  		/* bl -74668 */
		/* 82248164h case    7:*/		regs.LR = 0x82248168; return 0x82235DB8;
		/* 82248164h case    7:*/		return 0x82248168;
		  /* 82248168h */ case    8:  		/* mr R29, R3 */
		/* 82248168h case    8:*/		regs.R29 = regs.R3;
		/* 82248168h case    8:*/		return 0x8224816C;
		  /* 8224816Ch */ case    9:  		/* mr R5, R26 */
		/* 8224816Ch case    9:*/		regs.R5 = regs.R26;
		/* 8224816Ch case    9:*/		return 0x82248170;
		  /* 82248170h */ case   10:  		/* lwz R3, <#[R31 + 2064]> */
		/* 82248170h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 82248170h case   10:*/		return 0x82248174;
		  /* 82248174h */ case   11:  		/* lwz R4, <#[R29 + 56]> */
		/* 82248174h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000038) );
		/* 82248174h case   11:*/		return 0x82248178;
		  /* 82248178h */ case   12:  		/* bl 114608 */
		/* 82248178h case   12:*/		regs.LR = 0x8224817C; return 0x82264128;
		/* 82248178h case   12:*/		return 0x8224817C;
		  /* 8224817Ch */ case   13:  		/* mr R5, R3 */
		/* 8224817Ch case   13:*/		regs.R5 = regs.R3;
		/* 8224817Ch case   13:*/		return 0x82248180;
		  /* 82248180h */ case   14:  		/* cmpw CR6, R3, R30 */
		/* 82248180h case   14:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R30);
		/* 82248180h case   14:*/		return 0x82248184;
		  /* 82248184h */ case   15:  		/* bc 12, CR6_EQ, 700 */
		/* 82248184h case   15:*/		if ( regs.CR[6].eq ) { return 0x82248440;  }
		/* 82248184h case   15:*/		return 0x82248188;
		  /* 82248188h */ case   16:  		/* lwz R11, <#[R28 + 228]> */
		/* 82248188h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82248188h case   16:*/		return 0x8224818C;
		  /* 8224818Ch */ case   17:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8224818Ch case   17:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8224818Ch case   17:*/		return 0x82248190;
		  /* 82248190h */ case   18:  		/* bc 12, CR0_EQ, 380 */
		/* 82248190h case   18:*/		if ( regs.CR[0].eq ) { return 0x8224830C;  }
		/* 82248190h case   18:*/		return 0x82248194;
		  /* 82248194h */ case   19:  		/* lwz R11, <#[R29 + 228]> */
		/* 82248194h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000E4) );
		/* 82248194h case   19:*/		return 0x82248198;
		  /* 82248198h */ case   20:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 82248198h case   20:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 82248198h case   20:*/		return 0x8224819C;
		  /* 8224819Ch */ case   21:  		/* bc 12, CR0_EQ, 368 */
		/* 8224819Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x8224830C;  }
		/* 8224819Ch case   21:*/		return 0x822481A0;
		  /* 822481A0h */ case   22:  		/* li R3, 49 */
		/* 822481A0h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 822481A0h case   22:*/		return 0x822481A4;
		  /* 822481A4h */ case   23:  		/* lwz R4, <#[R31 + 12]> */
		/* 822481A4h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 822481A4h case   23:*/		return 0x822481A8;
		  /* 822481A8h */ case   24:  		/* mr R27, R24 */
		/* 822481A8h case   24:*/		regs.R27 = regs.R24;
		/* 822481A8h case   24:*/		return 0x822481AC;
		  /* 822481ACh */ case   25:  		/* bl 56708 */
		/* 822481ACh case   25:*/		regs.LR = 0x822481B0; return 0x82255F30;
		/* 822481ACh case   25:*/		return 0x822481B0;
		  /* 822481B0h */ case   26:  		/* stw R24, <#[R3 + 56]> */
		/* 822481B0h case   26:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000038) );
		/* 822481B0h case   26:*/		return 0x822481B4;
		  /* 822481B4h */ case   27:  		/* stw R18, <#[R3 + 80]> */
		/* 822481B4h case   27:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x00000050) );
		/* 822481B4h case   27:*/		return 0x822481B8;
	}
	return 0x822481B8;
} // Block from 82248148h-822481B8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 822481B8h
// Function '?Add@SparseIntSet@XGRAPHICS@@QAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822481B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822481B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822481B8);
		  /* 822481B8h */ case    0:  		/* mr R5, R29 */
		/* 822481B8h case    0:*/		regs.R5 = regs.R29;
		/* 822481B8h case    0:*/		return 0x822481BC;
		  /* 822481BCh */ case    1:  		/* li R4, 1 */
		/* 822481BCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822481BCh case    1:*/		return 0x822481C0;
		  /* 822481C0h */ case    2:  		/* mr R30, R3 */
		/* 822481C0h case    2:*/		regs.R30 = regs.R3;
		/* 822481C0h case    2:*/		return 0x822481C4;
		  /* 822481C4h */ case    3:  		/* bl -74356 */
		/* 822481C4h case    3:*/		regs.LR = 0x822481C8; return 0x82235F50;
		/* 822481C4h case    3:*/		return 0x822481C8;
		  /* 822481C8h */ case    4:  		/* lwz R11, <#[R30 + 228]> */
		/* 822481C8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 822481C8h case    4:*/		return 0x822481CC;
		  /* 822481CCh */ case    5:  		/* mr R4, R25 */
		/* 822481CCh case    5:*/		regs.R4 = regs.R25;
		/* 822481CCh case    5:*/		return 0x822481D0;
		  /* 822481D0h */ case    6:  		/* ori R11, R11, 2176 */
		/* 822481D0h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x880);
		/* 822481D0h case    6:*/		return 0x822481D4;
		  /* 822481D4h */ case    7:  		/* mr R3, R23 */
		/* 822481D4h case    7:*/		regs.R3 = regs.R23;
		/* 822481D4h case    7:*/		return 0x822481D8;
		  /* 822481D8h */ case    8:  		/* stw R11, <#[R30 + 228]> */
		/* 822481D8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 822481D8h case    8:*/		return 0x822481DC;
		  /* 822481DCh */ case    9:  		/* mr R5, R30 */
		/* 822481DCh case    9:*/		regs.R5 = regs.R30;
		/* 822481DCh case    9:*/		return 0x822481E0;
		  /* 822481E0h */ case   10:  		/* bl 69184 */
		/* 822481E0h case   10:*/		regs.LR = 0x822481E4; return 0x82259020;
		/* 822481E0h case   10:*/		return 0x822481E4;
		  /* 822481E4h */ case   11:  		/* lwz R11, <#[R28 + 228]> */
		/* 822481E4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 822481E4h case   11:*/		return 0x822481E8;
		  /* 822481E8h */ case   12:  		/* addi R20, R20, 1 */
		/* 822481E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 822481E8h case   12:*/		return 0x822481EC;
		  /* 822481ECh */ case   13:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 822481ECh case   13:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 822481ECh case   13:*/		return 0x822481F0;
		  /* 822481F0h */ case   14:  		/* lwz R11, <#[R28 + 20]> */
		/* 822481F0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 822481F0h case   14:*/		return 0x822481F4;
		  /* 822481F4h */ case   15:  		/* bc 12, CR0_EQ, 20 */
		/* 822481F4h case   15:*/		if ( regs.CR[0].eq ) { return 0x82248208;  }
		/* 822481F4h case   15:*/		return 0x822481F8;
		  /* 822481F8h */ case   16:  		/* addi R11, R11, 58 */
		/* 822481F8h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3A);
		/* 822481F8h case   16:*/		return 0x822481FC;
		  /* 822481FCh */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822481FCh case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822481FCh case   17:*/		return 0x82248200;
		  /* 82248200h */ case   18:  		/* stwx R30, <#[R11 + R28]> */
		/* 82248200h case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82248200h case   18:*/		return 0x82248204;
		  /* 82248204h */ case   19:  		/* b 36 */
		/* 82248204h case   19:*/		return 0x82248228;
		/* 82248204h case   19:*/		return 0x82248208;
	}
	return 0x82248208;
} // Block from 822481B8h-82248208h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82248208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248208);
		  /* 82248208h */ case    0:  		/* addi R11, R11, 1 */
		/* 82248208h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82248208h case    0:*/		return 0x8224820C;
		  /* 8224820Ch */ case    1:  		/* addi R10, R11, 58 */
		/* 8224820Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3A);
		/* 8224820Ch case    1:*/		return 0x82248210;
	}
	return 0x82248210;
} // Block from 82248208h-82248210h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82248210h
// Function '?Remove@SparseIntSet@XGRAPHICS@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248210);
		  /* 82248210h */ case    0:  		/* stw R11, <#[R28 + 20]> */
		/* 82248210h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 82248210h case    0:*/		return 0x82248214;
		  /* 82248214h */ case    1:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82248214h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82248214h case    1:*/		return 0x82248218;
		  /* 82248218h */ case    2:  		/* stwx R30, <#[R11 + R28]> */
		/* 82248218h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82248218h case    2:*/		return 0x8224821C;
		  /* 8224821Ch */ case    3:  		/* lwz R11, <#[R28 + 228]> */
		/* 8224821Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 8224821Ch case    3:*/		return 0x82248220;
		  /* 82248220h */ case    4:  		/* ori R11, R11, 512 */
		/* 82248220h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82248220h case    4:*/		return 0x82248224;
		  /* 82248224h */ case    5:  		/* stw R11, <#[R28 + 228]> */
		/* 82248224h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82248224h case    5:*/		return 0x82248228;
	}
	return 0x82248228;
} // Block from 82248210h-82248228h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82248228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248228);
		  /* 82248228h */ case    0:  		/* lwz R3, <#[R31 + 2064]> */
		/* 82248228h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 82248228h case    0:*/		return 0x8224822C;
		  /* 8224822Ch */ case    1:  		/* addi R24, R24, 1 */
		/* 8224822Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 8224822Ch case    1:*/		return 0x82248230;
		  /* 82248230h */ case    2:  		/* bl 116096 */
		/* 82248230h case    2:*/		regs.LR = 0x82248234; return 0x822647B0;
		/* 82248230h case    2:*/		return 0x82248234;
		  /* 82248234h */ case    3:  		/* lwz R29, <#[R31 + 136]> */
		/* 82248234h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000088) );
		/* 82248234h case    3:*/		return 0x82248238;
		  /* 82248238h */ case    4:  		/* b 104 */
		/* 82248238h case    4:*/		return 0x822482A0;
		/* 82248238h case    4:*/		return 0x8224823C;
		  /* 8224823Ch */ case    5:  		/* li R4, 1 */
		/* 8224823Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224823Ch case    5:*/		return 0x82248240;
		  /* 82248240h */ case    6:  		/* lwz R3, <#[R29 + 104]> */
		/* 82248240h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000068) );
		/* 82248240h case    6:*/		return 0x82248244;
		  /* 82248244h */ case    7:  		/* bl -3172 */
		/* 82248244h case    7:*/		regs.LR = 0x82248248; return 0x822475E0;
		/* 82248244h case    7:*/		return 0x82248248;
		  /* 82248248h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82248248h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82248248h case    8:*/		return 0x8224824C;
		  /* 8224824Ch */ case    9:  		/* bc 4, CR0_EQ, 80 */
		/* 8224824Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x8224829C;  }
		/* 8224824Ch case    9:*/		return 0x82248250;
		  /* 82248250h */ case   10:  		/* lwz R11, <#[R31 + 12]> */
		/* 82248250h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82248250h case   10:*/		return 0x82248254;
		  /* 82248254h */ case   11:  		/* mr R3, R24 */
		/* 82248254h case   11:*/		regs.R3 = regs.R24;
		/* 82248254h case   11:*/		return 0x82248258;
		  /* 82248258h */ case   12:  		/* lwz R30, <#[R29 + 104]> */
		/* 82248258h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000068) );
		/* 82248258h case   12:*/		return 0x8224825C;
		  /* 8224825Ch */ case   13:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8224825Ch case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224825Ch case   13:*/		return 0x82248260;
		  /* 82248260h */ case   14:  		/* bl -71968 */
		/* 82248260h case   14:*/		regs.LR = 0x82248264; return 0x82236940;
		/* 82248260h case   14:*/		return 0x82248264;
		  /* 82248264h */ case   15:  		/* stw R3, <#[R29 + 104]> */
		/* 82248264h case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000068) );
		/* 82248264h case   15:*/		return 0x82248268;
	}
	return 0x82248268;
} // Block from 82248228h-82248268h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82248268h
// Function '?SetMaxTempNumber@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248268);
		  /* 82248268h */ case    0:  		/* mr R10, R18 */
		/* 82248268h case    0:*/		regs.R10 = regs.R18;
		/* 82248268h case    0:*/		return 0x8224826C;
		  /* 8224826Ch */ case    1:  		/* lwz R11, <#[R30]> */
		/* 8224826Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8224826Ch case    1:*/		return 0x82248270;
		  /* 82248270h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82248270h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82248270h case    2:*/		return 0x82248274;
		  /* 82248274h */ case    3:  		/* bc 4, CR6_GT, 40 */
		/* 82248274h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8224829C;  }
		/* 82248274h case    3:*/		return 0x82248278;
		  /* 82248278h */ case    4:  		/* addi R11, R3, 8 */
		/* 82248278h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x8);
		/* 82248278h case    4:*/		return 0x8224827C;
		  /* 8224827Ch */ case    5:  		/* subf R9, R3, R30 */
		/* 8224827Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R3,regs.R30);
		/* 8224827Ch case    5:*/		return 0x82248280;
		  /* 82248280h */ case    6:  		/* lwzx R8, <#[R9 + R11]> */
		/* 82248280h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82248280h case    6:*/		return 0x82248284;
		  /* 82248284h */ case    7:  		/* addi R10, R10, 1 */
		/* 82248284h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82248284h case    7:*/		return 0x82248288;
		  /* 82248288h */ case    8:  		/* stw R8, <#[R11]> */
		/* 82248288h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82248288h case    8:*/		return 0x8224828C;
		  /* 8224828Ch */ case    9:  		/* addi R11, R11, 4 */
		/* 8224828Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8224828Ch case    9:*/		return 0x82248290;
		  /* 82248290h */ case   10:  		/* lwz R8, <#[R30]> */
		/* 82248290h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 82248290h case   10:*/		return 0x82248294;
		  /* 82248294h */ case   11:  		/* cmplw CR6, R10, R8 */
		/* 82248294h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82248294h case   11:*/		return 0x82248298;
		  /* 82248298h */ case   12:  		/* bc 12, CR6_LT, -24 */
		/* 82248298h case   12:*/		if ( regs.CR[6].lt ) { return 0x82248280;  }
		/* 82248298h case   12:*/		return 0x8224829C;
	}
	return 0x8224829C;
} // Block from 82248268h-8224829Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224829Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224829C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224829C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224829C);
		  /* 8224829Ch */ case    0:  		/* lwz R29, <#[R29 + 8]> */
		/* 8224829Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 8224829Ch case    0:*/		return 0x822482A0;
	}
	return 0x822482A0;
} // Block from 8224829Ch-822482A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822482A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822482A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822482A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822482A0);
		  /* 822482A0h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 822482A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 822482A0h case    0:*/		return 0x822482A4;
		  /* 822482A4h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 822482A4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822482A4h case    1:*/		return 0x822482A8;
		  /* 822482A8h */ case    2:  		/* bc 4, CR6_EQ, -108 */
		/* 822482A8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224823C;  }
		/* 822482A8h case    2:*/		return 0x822482AC;
		  /* 822482ACh */ case    3:  		/* mr R30, R18 */
		/* 822482ACh case    3:*/		regs.R30 = regs.R18;
		/* 822482ACh case    3:*/		return 0x822482B0;
		  /* 822482B0h */ case    4:  		/* cmpwi CR6, R24, 0 */
		/* 822482B0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 822482B0h case    4:*/		return 0x822482B4;
		  /* 822482B4h */ case    5:  		/* bc 4, CR6_GT, 396 */
		/* 822482B4h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82248440;  }
		/* 822482B4h case    5:*/		return 0x822482B8;
		  /* 822482B8h */ case    6:  		/* rlwinm R11, R30, 27, 5, 31 */
		/* 822482B8h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R30);
		/* 822482B8h case    6:*/		return 0x822482BC;
		  /* 822482BCh */ case    7:  		/* lwz R10, <#[R23 + 104]> */
		/* 822482BCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000068) );
		/* 822482BCh case    7:*/		return 0x822482C0;
		  /* 822482C0h */ case    8:  		/* rlwinm R9, R30, 0, 27, 31 */
		/* 822482C0h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R30);
		/* 822482C0h case    8:*/		return 0x822482C4;
		  /* 822482C4h */ case    9:  		/* addi R11, R11, 2 */
		/* 822482C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 822482C4h case    9:*/		return 0x822482C8;
		  /* 822482C8h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822482C8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822482C8h case   10:*/		return 0x822482CC;
		  /* 822482CCh */ case   11:  		/* lwzx R11, <#[R11 + R10]> */
		/* 822482CCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822482CCh case   11:*/		return 0x822482D0;
	}
	return 0x822482D0;
} // Block from 822482A0h-822482D0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822482D0h
// Function '?AllocatePhysicalRegister@CFG@XGRAPHICS@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822482D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822482D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822482D0);
		  /* 822482D0h */ case    0:  		/* srw R11, R11, R9 */
		/* 822482D0h case    0:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 822482D0h case    0:*/		return 0x822482D4;
		  /* 822482D4h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 822482D4h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 822482D4h case    1:*/		return 0x822482D8;
		  /* 822482D8h */ case    2:  		/* bc 12, CR0_EQ, 36 */
		/* 822482D8h case    2:*/		if ( regs.CR[0].eq ) { return 0x822482FC;  }
		/* 822482D8h case    2:*/		return 0x822482DC;
		  /* 822482DCh */ case    3:  		/* li R5, 1 */
		/* 822482DCh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 822482DCh case    3:*/		return 0x822482E0;
		  /* 822482E0h */ case    4:  		/* lwz R3, <#[R31 + 2064]> */
		/* 822482E0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 822482E0h case    4:*/		return 0x822482E4;
		  /* 822482E4h */ case    5:  		/* mr R4, R30 */
		/* 822482E4h case    5:*/		regs.R4 = regs.R30;
		/* 822482E4h case    5:*/		return 0x822482E8;
		  /* 822482E8h */ case    6:  		/* bl 114240 */
		/* 822482E8h case    6:*/		regs.LR = 0x822482EC; return 0x82264128;
		/* 822482E8h case    6:*/		return 0x822482EC;
		  /* 822482ECh */ case    7:  		/* mr R5, R3 */
		/* 822482ECh case    7:*/		regs.R5 = regs.R3;
		/* 822482ECh case    7:*/		return 0x822482F0;
		  /* 822482F0h */ case    8:  		/* mr R4, R27 */
		/* 822482F0h case    8:*/		regs.R4 = regs.R27;
		/* 822482F0h case    8:*/		return 0x822482F4;
		  /* 822482F4h */ case    9:  		/* lwz R3, <#[R31 + 2064]> */
		/* 822482F4h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 822482F4h case    9:*/		return 0x822482F8;
		  /* 822482F8h */ case   10:  		/* bl 116264 */
		/* 822482F8h case   10:*/		regs.LR = 0x822482FC; return 0x82264920;
		/* 822482F8h case   10:*/		return 0x822482FC;
	}
	return 0x822482FC;
} // Block from 822482D0h-822482FCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 822482FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822482FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822482FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822482FC);
		  /* 822482FCh */ case    0:  		/* addi R30, R30, 1 */
		/* 822482FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822482FCh case    0:*/		return 0x82248300;
		  /* 82248300h */ case    1:  		/* cmpw CR6, R30, R24 */
		/* 82248300h case    1:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R24);
		/* 82248300h case    1:*/		return 0x82248304;
		  /* 82248304h */ case    2:  		/* bc 12, CR6_LT, -76 */
		/* 82248304h case    2:*/		if ( regs.CR[6].lt ) { return 0x822482B8;  }
		/* 82248304h case    2:*/		return 0x82248308;
		  /* 82248308h */ case    3:  		/* b 312 */
		/* 82248308h case    3:*/		return 0x82248440;
		/* 82248308h case    3:*/		return 0x8224830C;
	}
	return 0x8224830C;
} // Block from 822482FCh-8224830Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224830Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224830C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224830C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224830C);
		  /* 8224830Ch */ case    0:  		/* mr R4, R30 */
		/* 8224830Ch case    0:*/		regs.R4 = regs.R30;
		/* 8224830Ch case    0:*/		return 0x82248310;
		  /* 82248310h */ case    1:  		/* lwz R3, <#[R31 + 2064]> */
		/* 82248310h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 82248310h case    1:*/		return 0x82248314;
		  /* 82248314h */ case    2:  		/* bl 116684 */
		/* 82248314h case    2:*/		regs.LR = 0x82248318; return 0x82264AE0;
		/* 82248314h case    2:*/		return 0x82248318;
		  /* 82248318h */ case    3:  		/* rlwinm R11, R26, 0, 24, 31 */
		/* 82248318h case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R26);
		/* 82248318h case    3:*/		return 0x8224831C;
		  /* 8224831Ch */ case    4:  		/* rlwinm. R10, R3, 0, 24, 31 */
		/* 8224831Ch case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R3);
		/* 8224831Ch case    4:*/		return 0x82248320;
		  /* 82248320h */ case    5:  		/* or R11, R11, R10 */
		/* 82248320h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82248320h case    5:*/		return 0x82248324;
		  /* 82248324h */ case    6:  		/* rlwinm R26, R11, 0, 24, 31 */
		/* 82248324h case    6:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R26,regs.R11);
		/* 82248324h case    6:*/		return 0x82248328;
		  /* 82248328h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 82248328h case    7:*/		if ( regs.CR[0].eq ) { return 0x82248334;  }
		/* 82248328h case    7:*/		return 0x8224832C;
		  /* 8224832Ch */ case    8:  		/* addi R14, R14, 1 */
		/* 8224832Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R14,0x1);
		/* 8224832Ch case    8:*/		return 0x82248330;
		  /* 82248330h */ case    9:  		/* b 272 */
		/* 82248330h case    9:*/		return 0x82248440;
		/* 82248330h case    9:*/		return 0x82248334;
	}
	return 0x82248334;
} // Block from 8224830Ch-82248334h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82248334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248334);
		  /* 82248334h */ case    0:  		/* addi R11, R27, 1 */
		/* 82248334h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x1);
		/* 82248334h case    0:*/		return 0x82248338;
		  /* 82248338h */ case    1:  		/* stw R11, <#[R1 + 84]> */
		/* 82248338h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82248338h case    1:*/		return 0x8224833C;
		  /* 8224833Ch */ case    2:  		/* b 260 */
		/* 8224833Ch case    2:*/		return 0x82248440;
		/* 8224833Ch case    2:*/		return 0x82248340;
	}
	return 0x82248340;
} // Block from 82248334h-82248340h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82248340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248340);
		  /* 82248340h */ case    0:  		/* mr R3, R28 */
		/* 82248340h case    0:*/		regs.R3 = regs.R28;
		/* 82248340h case    0:*/		return 0x82248344;
		  /* 82248344h */ case    1:  		/* bl -27724 */
		/* 82248344h case    1:*/		regs.LR = 0x82248348; return 0x822416F8;
		/* 82248344h case    1:*/		return 0x82248348;
		  /* 82248348h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82248348h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82248348h case    2:*/		return 0x8224834C;
		  /* 8224834Ch */ case    3:  		/* bc 12, CR0_EQ, 244 */
		/* 8224834Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82248440;  }
		/* 8224834Ch case    3:*/		return 0x82248350;
		  /* 82248350h */ case    4:  		/* lwz R11, <#[R28 + 228]> */
		/* 82248350h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82248350h case    4:*/		return 0x82248354;
		  /* 82248354h */ case    5:  		/* rlwinm. R11, R11, 21, 31, 31 */
		/* 82248354h case    5:*/		cpu::op::rlwinm<1,21,31,31>(regs,&regs.R11,regs.R11);
		/* 82248354h case    5:*/		return 0x82248358;
		  /* 82248358h */ case    6:  		/* bc 4, CR0_EQ, 232 */
		/* 82248358h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82248440;  }
		/* 82248358h case    6:*/		return 0x8224835C;
		  /* 8224835Ch */ case    7:  		/* mr R5, R26 */
		/* 8224835Ch case    7:*/		regs.R5 = regs.R26;
		/* 8224835Ch case    7:*/		return 0x82248360;
		  /* 82248360h */ case    8:  		/* lwz R4, <#[R28 + 56]> */
		/* 82248360h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000038) );
		/* 82248360h case    8:*/		return 0x82248364;
		  /* 82248364h */ case    9:  		/* lwz R3, <#[R31 + 2064]> */
		/* 82248364h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 82248364h case    9:*/		return 0x82248368;
	}
	return 0x82248368;
} // Block from 82248340h-82248368h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82248368h
// Function '?ReleasePhysicalRegister@CFG@XGRAPHICS@@QAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248368);
		  /* 82248368h */ case    0:  		/* bl 114112 */
		/* 82248368h case    0:*/		regs.LR = 0x8224836C; return 0x82264128;
		/* 82248368h case    0:*/		return 0x8224836C;
		  /* 8224836Ch */ case    1:  		/* lwz R11, <#[R28 + 236]> */
		/* 8224836Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000EC) );
		/* 8224836Ch case    1:*/		return 0x82248370;
		  /* 82248370h */ case    2:  		/* mr R29, R3 */
		/* 82248370h case    2:*/		regs.R29 = regs.R3;
		/* 82248370h case    2:*/		return 0x82248374;
		  /* 82248374h */ case    3:  		/* lwz R10, <#[R11 + 16]> */
		/* 82248374h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82248374h case    3:*/		return 0x82248378;
		  /* 82248378h */ case    4:  		/* cmpwi CR6, R10, 0 */
		/* 82248378h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82248378h case    4:*/		return 0x8224837C;
		  /* 8224837Ch */ case    5:  		/* bc 12, CR6_EQ, 48 */
		/* 8224837Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x822483AC;  }
		/* 8224837Ch case    5:*/		return 0x82248380;
		  /* 82248380h */ case    6:  		/* lwz R10, <#[R11 + 228]> */
		/* 82248380h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 82248380h case    6:*/		return 0x82248384;
		  /* 82248384h */ case    7:  		/* rlwinm. R10, R10, 31, 31, 31 */
		/* 82248384h case    7:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R10,regs.R10);
		/* 82248384h case    7:*/		return 0x82248388;
		  /* 82248388h */ case    8:  		/* bc 4, CR0_EQ, 36 */
		/* 82248388h case    8:*/		if ( !regs.CR[0].eq ) { return 0x822483AC;  }
		/* 82248388h case    8:*/		return 0x8224838C;
		  /* 8224838Ch */ case    9:  		/* lwz R10, <#[R11 + 80]> */
		/* 8224838Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 8224838Ch case    9:*/		return 0x82248390;
		  /* 82248390h */ case   10:  		/* lwz R9, <#[R1 + 88]> */
		/* 82248390h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 82248390h case   10:*/		return 0x82248394;
		  /* 82248394h */ case   11:  		/* mulli R10, R10, 12 */
		/* 82248394h case   11:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82248394h case   11:*/		return 0x82248398;
		  /* 82248398h */ case   12:  		/* addi R9, R9, 4 */
		/* 82248398h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82248398h case   12:*/		return 0x8224839C;
		  /* 8224839Ch */ case   13:  		/* lbzx R10, <#[R10 + R9]> */
		/* 8224839Ch case   13:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8224839Ch case   13:*/		return 0x822483A0;
		  /* 822483A0h */ case   14:  		/* cmplwi CR0, R10, 0 */
		/* 822483A0h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 822483A0h case   14:*/		return 0x822483A4;
		  /* 822483A4h */ case   15:  		/* li R10, 1 */
		/* 822483A4h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 822483A4h case   15:*/		return 0x822483A8;
		  /* 822483A8h */ case   16:  		/* bc 4, CR0_EQ, 8 */
		/* 822483A8h case   16:*/		if ( !regs.CR[0].eq ) { return 0x822483B0;  }
		/* 822483A8h case   16:*/		return 0x822483AC;
	}
	return 0x822483AC;
} // Block from 82248368h-822483ACh (17 instructions)

//////////////////////////////////////////////////////
// Block at 822483ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822483AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822483AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822483AC);
		  /* 822483ACh */ case    0:  		/* mr R10, R18 */
		/* 822483ACh case    0:*/		regs.R10 = regs.R18;
		/* 822483ACh case    0:*/		return 0x822483B0;
	}
	return 0x822483B0;
} // Block from 822483ACh-822483B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822483B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822483B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822483B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822483B0);
		  /* 822483B0h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 822483B0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 822483B0h case    0:*/		return 0x822483B4;
		  /* 822483B4h */ case    1:  		/* bc 12, CR0_EQ, 140 */
		/* 822483B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82248440;  }
		/* 822483B4h case    1:*/		return 0x822483B8;
		  /* 822483B8h */ case    2:  		/* mr R5, R26 */
		/* 822483B8h case    2:*/		regs.R5 = regs.R26;
		/* 822483B8h case    2:*/		return 0x822483BC;
		  /* 822483BCh */ case    3:  		/* lwz R4, <#[R11 + 56]> */
		/* 822483BCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000038) );
		/* 822483BCh case    3:*/		return 0x822483C0;
		  /* 822483C0h */ case    4:  		/* lwz R3, <#[R31 + 2064]> */
		/* 822483C0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 822483C0h case    4:*/		return 0x822483C4;
		  /* 822483C4h */ case    5:  		/* bl 114020 */
		/* 822483C4h case    5:*/		regs.LR = 0x822483C8; return 0x82264128;
		/* 822483C4h case    5:*/		return 0x822483C8;
		  /* 822483C8h */ case    6:  		/* lwz R11, <#[R31 + 12]> */
		/* 822483C8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822483C8h case    6:*/		return 0x822483CC;
		  /* 822483CCh */ case    7:  		/* mr R30, R3 */
		/* 822483CCh case    7:*/		regs.R30 = regs.R3;
		/* 822483CCh case    7:*/		return 0x822483D0;
		  /* 822483D0h */ case    8:  		/* mr R3, R18 */
		/* 822483D0h case    8:*/		regs.R3 = regs.R18;
		/* 822483D0h case    8:*/		return 0x822483D4;
		  /* 822483D4h */ case    9:  		/* lwz R11, <#[R11 + 2712]> */
		/* 822483D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000A98) );
		/* 822483D4h case    9:*/		return 0x822483D8;
		  /* 822483D8h */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 822483D8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822483D8h case   10:*/		return 0x822483DC;
		  /* 822483DCh */ case   11:  		/* bc 4, CR6_GT, 20 */
		/* 822483DCh case   11:*/		if ( !regs.CR[6].gt ) { return 0x822483F0;  }
		/* 822483DCh case   11:*/		return 0x822483E0;
	}
	return 0x822483E0;
} // Block from 822483B0h-822483E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822483E0h
// Function '?BuildIGraph@CFG@XGRAPHICS@@QAAXPAVInterference@2@HH_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822483E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822483E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822483E0);
		  /* 822483E0h */ case    0:  		/* mr R5, R30 */
		/* 822483E0h case    0:*/		regs.R5 = regs.R30;
		/* 822483E0h case    0:*/		return 0x822483E4;
		  /* 822483E4h */ case    1:  		/* lwz R3, <#[R31 + 2064]> */
		/* 822483E4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 822483E4h case    1:*/		return 0x822483E8;
		  /* 822483E8h */ case    2:  		/* mr R4, R29 */
		/* 822483E8h case    2:*/		regs.R4 = regs.R29;
		/* 822483E8h case    2:*/		return 0x822483EC;
		  /* 822483ECh */ case    3:  		/* bl 116468 */
		/* 822483ECh case    3:*/		regs.LR = 0x822483F0; return 0x82264AE0;
		/* 822483ECh case    3:*/		return 0x822483F0;
	}
	return 0x822483F0;
} // Block from 822483E0h-822483F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822483F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822483F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822483F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822483F0);
		  /* 822483F0h */ case    0:  		/* rlwinm R10, R26, 0, 24, 31 */
		/* 822483F0h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R26);
		/* 822483F0h case    0:*/		return 0x822483F4;
		  /* 822483F4h */ case    1:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822483F4h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822483F4h case    1:*/		return 0x822483F8;
		  /* 822483F8h */ case    2:  		/* or R11, R10, R11 */
		/* 822483F8h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822483F8h case    2:*/		return 0x822483FC;
		  /* 822483FCh */ case    3:  		/* rlwinm R26, R11, 0, 24, 31 */
		/* 822483FCh case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R26,regs.R11);
		/* 822483FCh case    3:*/		return 0x82248400;
		  /* 82248400h */ case    4:  		/* bc 12, CR0_EQ, 40 */
		/* 82248400h case    4:*/		if ( regs.CR[0].eq ) { return 0x82248428;  }
		/* 82248400h case    4:*/		return 0x82248404;
		  /* 82248404h */ case    5:  		/* lwz R11, <#[R28]> */
		/* 82248404h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82248404h case    5:*/		return 0x82248408;
		  /* 82248408h */ case    6:  		/* mr R3, R28 */
		/* 82248408h case    6:*/		regs.R3 = regs.R28;
		/* 82248408h case    6:*/		return 0x8224840C;
		  /* 8224840Ch */ case    7:  		/* lwz R10, <#[R1 + 80]> */
		/* 8224840Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8224840Ch case    7:*/		return 0x82248410;
		  /* 82248410h */ case    8:  		/* addi R10, R10, 1 */
		/* 82248410h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82248410h case    8:*/		return 0x82248414;
		  /* 82248414h */ case    9:  		/* lwz R11, <#[R11 + 96]> */
		/* 82248414h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 82248414h case    9:*/		return 0x82248418;
		  /* 82248418h */ case   10:  		/* stw R10, <#[R1 + 80]> */
		/* 82248418h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82248418h case   10:*/		return 0x8224841C;
		  /* 8224841Ch */ case   11:  		/* mtspr CTR, R11 */
		/* 8224841Ch case   11:*/		regs.CTR = regs.R11;
		/* 8224841Ch case   11:*/		return 0x82248420;
		  /* 82248420h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 82248420h case   12:*/		if ( 1 ) { regs.LR = 0x82248424; return (uint32)regs.CTR; }
		/* 82248420h case   12:*/		return 0x82248424;
		  /* 82248424h */ case   13:  		/* b 28 */
		/* 82248424h case   13:*/		return 0x82248440;
		/* 82248424h case   13:*/		return 0x82248428;
	}
	return 0x82248428;
} // Block from 822483F0h-82248428h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82248428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248428);
		  /* 82248428h */ case    0:  		/* cmpw CR6, R29, R16 */
		/* 82248428h case    0:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R16);
		/* 82248428h case    0:*/		return 0x8224842C;
		  /* 8224842Ch */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 8224842Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x82248440;  }
		/* 8224842Ch case    1:*/		return 0x82248430;
		  /* 82248430h */ case    2:  		/* mr R5, R30 */
		/* 82248430h case    2:*/		regs.R5 = regs.R30;
		/* 82248430h case    2:*/		return 0x82248434;
		  /* 82248434h */ case    3:  		/* lwz R3, <#[R31 + 2064]> */
		/* 82248434h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 82248434h case    3:*/		return 0x82248438;
		  /* 82248438h */ case    4:  		/* mr R4, R29 */
		/* 82248438h case    4:*/		regs.R4 = regs.R29;
		/* 82248438h case    4:*/		return 0x8224843C;
		  /* 8224843Ch */ case    5:  		/* bl 115436 */
		/* 8224843Ch case    5:*/		regs.LR = 0x82248440; return 0x82264728;
		/* 8224843Ch case    5:*/		return 0x82248440;
	}
	return 0x82248440;
} // Block from 82248428h-82248440h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82248440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248440);
		  /* 82248440h */ case    0:  		/* lwz R11, <#[R28 + 228]> */
		/* 82248440h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82248440h case    0:*/		return 0x82248444;
		  /* 82248444h */ case    1:  		/* lwz R28, <#[R28 + 8]> */
		/* 82248444h case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000008) );
		/* 82248444h case    1:*/		return 0x82248448;
		  /* 82248448h */ case    2:  		/* nor R11, R11, R11 */
		/* 82248448h case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82248448h case    2:*/		return 0x8224844C;
		  /* 8224844Ch */ case    3:  		/* lwz R27, <#[R1 + 84]> */
		/* 8224844Ch case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 8224844Ch case    3:*/		return 0x82248450;
		  /* 82248450h */ case    4:  		/* lwz R29, <#[R1 + 80]> */
		/* 82248450h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 82248450h case    4:*/		return 0x82248454;
		  /* 82248454h */ case    5:  		/* cmplwi CR6, R28, 0 */
		/* 82248454h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82248454h case    5:*/		return 0x82248458;
		  /* 82248458h */ case    6:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 82248458h case    6:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82248458h case    6:*/		return 0x8224845C;
		  /* 8224845Ch */ case    7:  		/* bc 4, CR6_EQ, -844 */
		/* 8224845Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82248110;  }
		/* 8224845Ch case    7:*/		return 0x82248460;
	}
	return 0x82248460;
} // Block from 82248440h-82248460h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82248460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248460);
		  /* 82248460h */ case    0:  		/* lwz R11, <#[R25 + 228]> */
		/* 82248460h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x000000E4) );
		/* 82248460h case    0:*/		return 0x82248464;
		  /* 82248464h */ case    1:  		/* lwz R25, <#[R25 + 8]> */
		/* 82248464h case    1:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R25 + 0x00000008) );
		/* 82248464h case    1:*/		return 0x82248468;
		  /* 82248468h */ case    2:  		/* nor R11, R11, R11 */
		/* 82248468h case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82248468h case    2:*/		return 0x8224846C;
		  /* 8224846Ch */ case    3:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 8224846Ch case    3:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8224846Ch case    3:*/		return 0x82248470;
	}
	return 0x82248470;
} // Block from 82248460h-82248470h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82248470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248470);
		  /* 82248470h */ case    0:  		/* lwz R10, <#[R25 + 8]> */
		/* 82248470h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 82248470h case    0:*/		return 0x82248474;
		  /* 82248474h */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 82248474h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82248474h case    1:*/		return 0x82248478;
		  /* 82248478h */ case    2:  		/* bc 4, CR6_EQ, -888 */
		/* 82248478h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82248100;  }
		/* 82248478h case    2:*/		return 0x8224847C;
		  /* 8224847Ch */ case    3:  		/* mr R3, R19 */
		/* 8224847Ch case    3:*/		regs.R3 = regs.R19;
		/* 8224847Ch case    3:*/		return 0x82248480;
		  /* 82248480h */ case    4:  		/* addi R21, R21, 1 */
		/* 82248480h case    4:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 82248480h case    4:*/		return 0x82248484;
		  /* 82248484h */ case    5:  		/* addi R22, R22, 4 */
		/* 82248484h case    5:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x4);
		/* 82248484h case    5:*/		return 0x82248488;
		  /* 82248488h */ case    6:  		/* bl 46040 */
		/* 82248488h case    6:*/		regs.LR = 0x8224848C; return 0x82253860;
		/* 82248488h case    6:*/		return 0x8224848C;
		  /* 8224848Ch */ case    7:  		/* cmpw CR6, R21, R3 */
		/* 8224848Ch case    7:*/		cpu::op::cmpw<6>(regs,regs.R21,regs.R3);
		/* 8224848Ch case    7:*/		return 0x82248490;
		  /* 82248490h */ case    8:  		/* bc 12, CR6_LT, -928 */
		/* 82248490h case    8:*/		if ( regs.CR[6].lt ) { return 0x822480F0;  }
		/* 82248490h case    8:*/		return 0x82248494;
	}
	return 0x82248494;
} // Block from 82248470h-82248494h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82248494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248494);
		  /* 82248494h */ case    0:  		/* rlwinm. R11, R26, 0, 24, 31 */
		/* 82248494h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R26);
		/* 82248494h case    0:*/		return 0x82248498;
		  /* 82248498h */ case    1:  		/* addi R17, R17, 1 */
		/* 82248498h case    1:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 82248498h case    1:*/		return 0x8224849C;
		  /* 8224849Ch */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 8224849Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x822484B0;  }
		/* 8224849Ch case    2:*/		return 0x822484A0;
		  /* 822484A0h */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 822484A0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822484A0h case    3:*/		return 0x822484A4;
		  /* 822484A4h */ case    4:  		/* lwz R11, <#[R11 + 2712]> */
		/* 822484A4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000A98) );
		/* 822484A4h case    4:*/		return 0x822484A8;
		  /* 822484A8h */ case    5:  		/* cmpw CR6, R17, R11 */
		/* 822484A8h case    5:*/		cpu::op::cmpw<6>(regs,regs.R17,regs.R11);
		/* 822484A8h case    5:*/		return 0x822484AC;
		  /* 822484ACh */ case    6:  		/* bc 12, CR6_LT, -1056 */
		/* 822484ACh case    6:*/		if ( regs.CR[6].lt ) { return 0x8224808C;  }
		/* 822484ACh case    6:*/		return 0x822484B0;
	}
	return 0x822484B0;
} // Block from 82248494h-822484B0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822484B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822484B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822484B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822484B0);
		  /* 822484B0h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 822484B0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 822484B0h case    0:*/		return 0x822484B4;
		  /* 822484B4h */ case    1:  		/* bc 12, CR6_GT, 20 */
		/* 822484B4h case    1:*/		if ( regs.CR[6].gt ) { return 0x822484C8;  }
		/* 822484B4h case    1:*/		return 0x822484B8;
		  /* 822484B8h */ case    2:  		/* cmpwi CR6, R29, 0 */
		/* 822484B8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 822484B8h case    2:*/		return 0x822484BC;
		  /* 822484BCh */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 822484BCh case    3:*/		if ( regs.CR[6].gt ) { return 0x822484C8;  }
		/* 822484BCh case    3:*/		return 0x822484C0;
		  /* 822484C0h */ case    4:  		/* cmpwi CR6, R20, 0 */
		/* 822484C0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 822484C0h case    4:*/		return 0x822484C4;
		  /* 822484C4h */ case    5:  		/* bc 12, CR6_EQ, 72 */
		/* 822484C4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8224850C;  }
		/* 822484C4h case    5:*/		return 0x822484C8;
	}
	return 0x822484C8;
} // Block from 822484B0h-822484C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822484C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822484C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822484C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822484C8);
		  /* 822484C8h */ case    0:  		/* mr R30, R18 */
		/* 822484C8h case    0:*/		regs.R30 = regs.R18;
		/* 822484C8h case    0:*/		return 0x822484CC;
		  /* 822484CCh */ case    1:  		/* cmpwi CR6, R24, 0 */
		/* 822484CCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 822484CCh case    1:*/		return 0x822484D0;
		  /* 822484D0h */ case    2:  		/* bc 4, CR6_GT, 32 */
		/* 822484D0h case    2:*/		if ( !regs.CR[6].gt ) { return 0x822484F0;  }
		/* 822484D0h case    2:*/		return 0x822484D4;
		  /* 822484D4h */ case    3:  		/* li R5, 1 */
		/* 822484D4h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 822484D4h case    3:*/		return 0x822484D8;
		  /* 822484D8h */ case    4:  		/* lwz R3, <#[R31 + 2064]> */
		/* 822484D8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 822484D8h case    4:*/		return 0x822484DC;
		  /* 822484DCh */ case    5:  		/* mr R4, R30 */
		/* 822484DCh case    5:*/		regs.R4 = regs.R30;
		/* 822484DCh case    5:*/		return 0x822484E0;
		  /* 822484E0h */ case    6:  		/* bl 113736 */
		/* 822484E0h case    6:*/		regs.LR = 0x822484E4; return 0x82264128;
		/* 822484E0h case    6:*/		return 0x822484E4;
		  /* 822484E4h */ case    7:  		/* addi R30, R30, 1 */
		/* 822484E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822484E4h case    7:*/		return 0x822484E8;
		  /* 822484E8h */ case    8:  		/* cmpw CR6, R30, R24 */
		/* 822484E8h case    8:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R24);
		/* 822484E8h case    8:*/		return 0x822484EC;
		  /* 822484ECh */ case    9:  		/* bc 12, CR6_LT, -24 */
		/* 822484ECh case    9:*/		if ( regs.CR[6].lt ) { return 0x822484D4;  }
		/* 822484ECh case    9:*/		return 0x822484F0;
	}
	return 0x822484F0;
} // Block from 822484C8h-822484F0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822484F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822484F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822484F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822484F0);
		  /* 822484F0h */ case    0:  		/* cmpwi CR6, R20, 0 */
		/* 822484F0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 822484F0h case    0:*/		return 0x822484F4;
		  /* 822484F4h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 822484F4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8224850C;  }
		/* 822484F4h case    1:*/		return 0x822484F8;
		  /* 822484F8h */ case    2:  		/* lis R11, -32252 */
		/* 822484F8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822484F8h case    2:*/		return 0x822484FC;
		  /* 822484FCh */ case    3:  		/* lwz R3, <#[R31 + 12]> */
		/* 822484FCh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 822484FCh case    3:*/		return 0x82248500;
		  /* 82248500h */ case    4:  		/* mr R5, R20 */
		/* 82248500h case    4:*/		regs.R5 = regs.R20;
		/* 82248500h case    4:*/		return 0x82248504;
		  /* 82248504h */ case    5:  		/* addi R4, R11, 13152 */
		/* 82248504h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3360);
		/* 82248504h case    5:*/		return 0x82248508;
		  /* 82248508h */ case    6:  		/* bl -176456 */
		/* 82248508h case    6:*/		regs.LR = 0x8224850C; return 0x8221D3C0;
		/* 82248508h case    6:*/		return 0x8224850C;
	}
	return 0x8224850C;
} // Block from 822484F0h-8224850Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224850Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224850C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224850C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224850C);
		  /* 8224850Ch */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 8224850Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 8224850Ch case    0:*/		return 0x82248510;
		  /* 82248510h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82248510h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224851C;  }
		/* 82248510h case    1:*/		return 0x82248514;
		  /* 82248514h */ case    2:  		/* cmpwi CR6, R27, 0 */
		/* 82248514h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82248514h case    2:*/		return 0x82248518;
		  /* 82248518h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 82248518h case    3:*/		if ( regs.CR[6].eq ) { return 0x82248534;  }
		/* 82248518h case    3:*/		return 0x8224851C;
	}
	return 0x8224851C;
} // Block from 8224850Ch-8224851Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224851Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224851C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224851C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224851C);
		  /* 8224851Ch */ case    0:  		/* lis R11, -32252 */
		/* 8224851Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224851Ch case    0:*/		return 0x82248520;
		  /* 82248520h */ case    1:  		/* lwz R3, <#[R31 + 12]> */
		/* 82248520h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 82248520h case    1:*/		return 0x82248524;
		  /* 82248524h */ case    2:  		/* add R6, R27, R14 */
		/* 82248524h case    2:*/		cpu::op::add<0>(regs,&regs.R6,regs.R27,regs.R14);
		/* 82248524h case    2:*/		return 0x82248528;
		  /* 82248528h */ case    3:  		/* addi R4, R11, 13088 */
		/* 82248528h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3320);
		/* 82248528h case    3:*/		return 0x8224852C;
		  /* 8224852Ch */ case    4:  		/* mr R5, R14 */
		/* 8224852Ch case    4:*/		regs.R5 = regs.R14;
		/* 8224852Ch case    4:*/		return 0x82248530;
		  /* 82248530h */ case    5:  		/* bl -176496 */
		/* 82248530h case    5:*/		regs.LR = 0x82248534; return 0x8221D3C0;
		/* 82248530h case    5:*/		return 0x82248534;
	}
	return 0x82248534;
} // Block from 8224851Ch-82248534h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82248534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248534);
		  /* 82248534h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 82248534h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82248534h case    0:*/		return 0x82248538;
		  /* 82248538h */ case    1:  		/* bc 4, CR6_GT, 28 */
		/* 82248538h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82248554;  }
		/* 82248538h case    1:*/		return 0x8224853C;
		  /* 8224853Ch */ case    2:  		/* lis R11, -32252 */
		/* 8224853Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224853Ch case    2:*/		return 0x82248540;
		  /* 82248540h */ case    3:  		/* lwz R3, <#[R31 + 12]> */
		/* 82248540h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 82248540h case    3:*/		return 0x82248544;
		  /* 82248544h */ case    4:  		/* mr R6, R17 */
		/* 82248544h case    4:*/		regs.R6 = regs.R17;
		/* 82248544h case    4:*/		return 0x82248548;
		  /* 82248548h */ case    5:  		/* addi R4, R11, 13024 */
		/* 82248548h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x32E0);
		/* 82248548h case    5:*/		return 0x8224854C;
		  /* 8224854Ch */ case    6:  		/* mr R5, R29 */
		/* 8224854Ch case    6:*/		regs.R5 = regs.R29;
		/* 8224854Ch case    6:*/		return 0x82248550;
		  /* 82248550h */ case    7:  		/* bl -176528 */
		/* 82248550h case    7:*/		regs.LR = 0x82248554; return 0x8221D3C0;
		/* 82248550h case    7:*/		return 0x82248554;
	}
	return 0x82248554;
} // Block from 82248534h-82248554h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82248554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248554);
		  /* 82248554h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82248554h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82248554h case    0:*/		return 0x82248558;
		  /* 82248558h */ case    1:  		/* lwz R3, <#[R11 + 2736]> */
		/* 82248558h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000AB0) );
		/* 82248558h case    1:*/		return 0x8224855C;
		  /* 8224855Ch */ case    2:  		/* bl 110628 */
		/* 8224855Ch case    2:*/		regs.LR = 0x82248560; return 0x82263580;
		/* 8224855Ch case    2:*/		return 0x82248560;
		  /* 82248560h */ case    3:  		/* lwz R3, <#[R31 + 2064]> */
		/* 82248560h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000810) );
		/* 82248560h case    3:*/		return 0x82248564;
		  /* 82248564h */ case    4:  		/* bl 116716 */
		/* 82248564h case    4:*/		regs.LR = 0x82248568; return 0x82264D50;
		/* 82248564h case    4:*/		return 0x82248568;
		  /* 82248568h */ case    5:  		/* mr R3, R31 */
		/* 82248568h case    5:*/		regs.R3 = regs.R31;
		/* 82248568h case    5:*/		return 0x8224856C;
		  /* 8224856Ch */ case    6:  		/* bl -3692 */
		/* 8224856Ch case    6:*/		regs.LR = 0x82248570; return 0x82247700;
		/* 8224856Ch case    6:*/		return 0x82248570;
		  /* 82248570h */ case    7:  		/* lwz R11, <#[R31 + 2080]> */
		/* 82248570h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000820) );
		/* 82248570h case    7:*/		return 0x82248574;
		  /* 82248574h */ case    8:  		/* lis R10, -32252 */
		/* 82248574h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82248574h case    8:*/		return 0x82248578;
		  /* 82248578h */ case    9:  		/* addi R5, R11, 1 */
		/* 82248578h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 82248578h case    9:*/		return 0x8224857C;
		  /* 8224857Ch */ case   10:  		/* addi R4, R10, 12972 */
		/* 8224857Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x32AC);
		/* 8224857Ch case   10:*/		return 0x82248580;
		  /* 82248580h */ case   11:  		/* lwz R3, <#[R31 + 12]> */
		/* 82248580h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 82248580h case   11:*/		return 0x82248584;
		  /* 82248584h */ case   12:  		/* bl -176580 */
		/* 82248584h case   12:*/		regs.LR = 0x82248588; return 0x8221D3C0;
		/* 82248584h case   12:*/		return 0x82248588;
		  /* 82248588h */ case   13:  		/* lwz R31, <#[R31 + 2064]> */
		/* 82248588h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000810) );
		/* 82248588h case   13:*/		return 0x8224858C;
		  /* 8224858Ch */ case   14:  		/* cmplwi CR6, R31, 0 */
		/* 8224858Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8224858Ch case   14:*/		return 0x82248590;
		  /* 82248590h */ case   15:  		/* bc 12, CR6_EQ, 24 */
		/* 82248590h case   15:*/		if ( regs.CR[6].eq ) { return 0x822485A8;  }
		/* 82248590h case   15:*/		return 0x82248594;
		  /* 82248594h */ case   16:  		/* mr R3, R31 */
		/* 82248594h case   16:*/		regs.R3 = regs.R31;
		/* 82248594h case   16:*/		return 0x82248598;
		  /* 82248598h */ case   17:  		/* bl 118360 */
		/* 82248598h case   17:*/		regs.LR = 0x8224859C; return 0x822653F0;
		/* 82248598h case   17:*/		return 0x8224859C;
		  /* 8224859Ch */ case   18:  		/* addi R4, R31, -4 */
		/* 8224859Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xFFFFFFFC);
		/* 8224859Ch case   18:*/		return 0x822485A0;
		  /* 822485A0h */ case   19:  		/* lwz R3, <#[R31 - 4]> */
		/* 822485A0h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 822485A0h case   19:*/		return 0x822485A4;
		  /* 822485A4h */ case   20:  		/* bl -180068 */
		/* 822485A4h case   20:*/		regs.LR = 0x822485A8; return 0x8221C640;
		/* 822485A4h case   20:*/		return 0x822485A8;
	}
	return 0x822485A8;
} // Block from 82248554h-822485A8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 822485A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822485A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822485A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822485A8);
		  /* 822485A8h */ case    0:  		/* addi R1, R1, 256 */
		/* 822485A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 822485A8h case    0:*/		return 0x822485AC;
		  /* 822485ACh */ case    1:  		/* b -1798972 */
		/* 822485ACh case    1:*/		return 0x82091270;
		/* 822485ACh case    1:*/		return 0x822485B0;
		  /* 822485B0h */ case    2:  		/* addi R11, R3, 20 */
		/* 822485B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x14);
		/* 822485B0h case    2:*/		return 0x822485B4;
		  /* 822485B4h */ case    3:  		/* addi R10, R4, 20 */
		/* 822485B4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x14);
		/* 822485B4h case    3:*/		return 0x822485B8;
		  /* 822485B8h */ case    4:  		/* addi R9, R11, 240 */
		/* 822485B8h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xF0);
		/* 822485B8h case    4:*/		return 0x822485BC;
		  /* 822485BCh */ case    5:  		/* lbz R8, <#[R11]> */
		/* 822485BCh case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 822485BCh case    5:*/		return 0x822485C0;
		  /* 822485C0h */ case    6:  		/* lbz R7, <#[R10]> */
		/* 822485C0h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 822485C0h case    6:*/		return 0x822485C4;
		  /* 822485C4h */ case    7:  		/* subf. R8, R7, R8 */
		/* 822485C4h case    7:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R7,regs.R8);
		/* 822485C4h case    7:*/		return 0x822485C8;
		  /* 822485C8h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 822485C8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x822485DC;  }
		/* 822485C8h case    8:*/		return 0x822485CC;
		  /* 822485CCh */ case    9:  		/* addi R11, R11, 1 */
		/* 822485CCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822485CCh case    9:*/		return 0x822485D0;
		  /* 822485D0h */ case   10:  		/* addi R10, R10, 1 */
		/* 822485D0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822485D0h case   10:*/		return 0x822485D4;
		  /* 822485D4h */ case   11:  		/* cmpw CR6, R11, R9 */
		/* 822485D4h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 822485D4h case   11:*/		return 0x822485D8;
		  /* 822485D8h */ case   12:  		/* bc 4, CR6_EQ, -28 */
		/* 822485D8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x822485BC;  }
		/* 822485D8h case   12:*/		return 0x822485DC;
	}
	return 0x822485DC;
} // Block from 822485A8h-822485DCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 822485DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822485DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822485DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822485DC);
		  /* 822485DCh */ case    0:  		/* subfic R11, R8, 0 */
		/* 822485DCh case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R8,0x0);
		/* 822485DCh case    0:*/		return 0x822485E0;
		  /* 822485E0h */ case    1:  		/* subfe R3, R11, R11 */
		/* 822485E0h case    1:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R11,regs.R11);
		/* 822485E0h case    1:*/		return 0x822485E4;
		  /* 822485E4h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822485E4h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822485E4h case    2:*/		return 0x822485E8;
	}
	return 0x822485E8;
} // Block from 822485DCh-822485E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822485E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822485E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822485E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822485E8);
		  /* 822485E8h */ case    0:  		/* mfspr R12, LR */
		/* 822485E8h case    0:*/		regs.R12 = regs.LR;
		/* 822485E8h case    0:*/		return 0x822485EC;
		  /* 822485ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822485ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822485ECh case    1:*/		return 0x822485F0;
		  /* 822485F0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822485F0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822485F0h case    2:*/		return 0x822485F4;
		  /* 822485F4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822485F4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822485F4h case    3:*/		return 0x822485F8;
		  /* 822485F8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822485F8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822485F8h case    4:*/		return 0x822485FC;
		  /* 822485FCh */ case    5:  		/* mr R30, R3 */
		/* 822485FCh case    5:*/		regs.R30 = regs.R3;
		/* 822485FCh case    5:*/		return 0x82248600;
		  /* 82248600h */ case    6:  		/* mr R31, R4 */
		/* 82248600h case    6:*/		regs.R31 = regs.R4;
		/* 82248600h case    6:*/		return 0x82248604;
		  /* 82248604h */ case    7:  		/* cmpwi CR6, R4, 0 */
		/* 82248604h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82248604h case    7:*/		return 0x82248608;
		  /* 82248608h */ case    8:  		/* bc 12, CR6_LT, 12 */
		/* 82248608h case    8:*/		if ( regs.CR[6].lt ) { return 0x82248614;  }
		/* 82248608h case    8:*/		return 0x8224860C;
		  /* 8224860Ch */ case    9:  		/* cmpwi CR6, R4, 4 */
		/* 8224860Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000004);
		/* 8224860Ch case    9:*/		return 0x82248610;
		  /* 82248610h */ case   10:  		/* bc 12, CR6_LT, 40 */
		/* 82248610h case   10:*/		if ( regs.CR[6].lt ) { return 0x82248638;  }
		/* 82248610h case   10:*/		return 0x82248614;
	}
	return 0x82248614;
} // Block from 822485E8h-82248614h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82248614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248614);
		  /* 82248614h */ case    0:  		/* lis R11, -32252 */
		/* 82248614h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82248614h case    0:*/		return 0x82248618;
		  /* 82248618h */ case    1:  		/* lis R10, -32252 */
		/* 82248618h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82248618h case    1:*/		return 0x8224861C;
		  /* 8224861Ch */ case    2:  		/* lis R9, -32253 */
		/* 8224861Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224861Ch case    2:*/		return 0x82248620;
		  /* 82248620h */ case    3:  		/* addi R6, R11, 8704 */
		/* 82248620h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2200);
		/* 82248620h case    3:*/		return 0x82248624;
		  /* 82248624h */ case    4:  		/* addi R5, R10, 13368 */
		/* 82248624h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x3438);
		/* 82248624h case    4:*/		return 0x82248628;
		  /* 82248628h */ case    5:  		/* addi R4, R9, 27460 */
		/* 82248628h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82248628h case    5:*/		return 0x8224862C;
		  /* 8224862Ch */ case    6:  		/* li R7, 190 */
		/* 8224862Ch case    6:*/		cpu::op::li<0>(regs,&regs.R7,0xBE);
		/* 8224862Ch case    6:*/		return 0x82248630;
		  /* 82248630h */ case    7:  		/* li R3, 0 */
		/* 82248630h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82248630h case    7:*/		return 0x82248634;
		  /* 82248634h */ case    8:  		/* bl -985644 */
		/* 82248634h case    8:*/		regs.LR = 0x82248638; return 0x82157C08;
		/* 82248634h case    8:*/		return 0x82248638;
	}
	return 0x82248638;
} // Block from 82248614h-82248638h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82248638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248638);
		  /* 82248638h */ case    0:  		/* lbzx R3, <#[R31 + R30]> */
		/* 82248638h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R31 + regs.R30 + 0x00000000) );
		/* 82248638h case    0:*/		return 0x8224863C;
		  /* 8224863Ch */ case    1:  		/* addi R1, R1, 112 */
		/* 8224863Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224863Ch case    1:*/		return 0x82248640;
		  /* 82248640h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82248640h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82248640h case    2:*/		return 0x82248644;
		  /* 82248644h */ case    3:  		/* mtspr LR, R12 */
		/* 82248644h case    3:*/		regs.LR = regs.R12;
		/* 82248644h case    3:*/		return 0x82248648;
		  /* 82248648h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82248648h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82248648h case    4:*/		return 0x8224864C;
		  /* 8224864Ch */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8224864Ch case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224864Ch case    5:*/		return 0x82248650;
		  /* 82248650h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82248650h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82248650h case    6:*/		return 0x82248654;
	}
	return 0x82248654;
} // Block from 82248638h-82248654h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82248654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248654);
		  /* 82248654h */ case    0:  		/* nop */
		/* 82248654h case    0:*/		cpu::op::nop();
		/* 82248654h case    0:*/		return 0x82248658;
		  /* 82248658h */ case    1:  		/* lwz R7, <#[R3 + 20]> */
		/* 82248658h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000014) );
		/* 82248658h case    1:*/		return 0x8224865C;
		  /* 8224865Ch */ case    2:  		/* li R8, 0 */
		/* 8224865Ch case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8224865Ch case    2:*/		return 0x82248660;
		  /* 82248660h */ case    3:  		/* li R9, 1 */
		/* 82248660h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82248660h case    3:*/		return 0x82248664;
		  /* 82248664h */ case    4:  		/* cmpwi CR6, R7, 1 */
		/* 82248664h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000001);
		/* 82248664h case    4:*/		return 0x82248668;
		  /* 82248668h */ case    5:  		/* bc 12, CR6_LT, 68 */
		/* 82248668h case    5:*/		if ( regs.CR[6].lt ) { return 0x822486AC;  }
		/* 82248668h case    5:*/		return 0x8224866C;
		  /* 8224866Ch */ case    6:  		/* addi R10, R3, 236 */
		/* 8224866Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0xEC);
		/* 8224866Ch case    6:*/		return 0x82248670;
		  /* 82248670h */ case    7:  		/* lwz R11, <#[R10]> */
		/* 82248670h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82248670h case    7:*/		return 0x82248674;
		  /* 82248674h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82248674h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82248674h case    8:*/		return 0x82248678;
		  /* 82248678h */ case    9:  		/* bc 12, CR6_EQ, 36 */
		/* 82248678h case    9:*/		if ( regs.CR[6].eq ) { return 0x8224869C;  }
		/* 82248678h case    9:*/		return 0x8224867C;
		  /* 8224867Ch */ case   10:  		/* cmplw CR6, R11, R3 */
		/* 8224867Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 8224867Ch case   10:*/		return 0x82248680;
		  /* 82248680h */ case   11:  		/* bc 12, CR6_EQ, 28 */
		/* 82248680h case   11:*/		if ( regs.CR[6].eq ) { return 0x8224869C;  }
		/* 82248680h case   11:*/		return 0x82248684;
		  /* 82248684h */ case   12:  		/* cmplwi CR6, R8, 0 */
		/* 82248684h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82248684h case   12:*/		return 0x82248688;
		  /* 82248688h */ case   13:  		/* bc 4, CR6_EQ, 12 */
		/* 82248688h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82248694;  }
		/* 82248688h case   13:*/		return 0x8224868C;
		  /* 8224868Ch */ case   14:  		/* mr R8, R11 */
		/* 8224868Ch case   14:*/		regs.R8 = regs.R11;
		/* 8224868Ch case   14:*/		return 0x82248690;
		  /* 82248690h */ case   15:  		/* b 12 */
		/* 82248690h case   15:*/		return 0x8224869C;
		/* 82248690h case   15:*/		return 0x82248694;
	}
	return 0x82248694;
} // Block from 82248654h-82248694h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82248694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248694);
		  /* 82248694h */ case    0:  		/* cmplw CR6, R8, R11 */
		/* 82248694h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82248694h case    0:*/		return 0x82248698;
		  /* 82248698h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82248698h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822486B4;  }
		/* 82248698h case    1:*/		return 0x8224869C;
	}
	return 0x8224869C;
} // Block from 82248694h-8224869Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224869Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224869C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224869C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224869C);
		  /* 8224869Ch */ case    0:  		/* addi R9, R9, 1 */
		/* 8224869Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8224869Ch case    0:*/		return 0x822486A0;
		  /* 822486A0h */ case    1:  		/* addi R10, R10, 4 */
		/* 822486A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 822486A0h case    1:*/		return 0x822486A4;
		  /* 822486A4h */ case    2:  		/* cmpw CR6, R9, R7 */
		/* 822486A4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R7);
		/* 822486A4h case    2:*/		return 0x822486A8;
		  /* 822486A8h */ case    3:  		/* bc 4, CR6_GT, -56 */
		/* 822486A8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82248670;  }
		/* 822486A8h case    3:*/		return 0x822486AC;
	}
	return 0x822486AC;
} // Block from 8224869Ch-822486ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822486ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822486AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822486AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822486AC);
		  /* 822486ACh */ case    0:  		/* li R3, 1 */
		/* 822486ACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822486ACh case    0:*/		return 0x822486B0;
		  /* 822486B0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 822486B0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822486B0h case    1:*/		return 0x822486B4;
	}
	return 0x822486B4;
} // Block from 822486ACh-822486B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822486B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822486B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822486B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822486B4);
		  /* 822486B4h */ case    0:  		/* li R3, 0 */
		/* 822486B4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822486B4h case    0:*/		return 0x822486B8;
		  /* 822486B8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 822486B8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822486B8h case    1:*/		return 0x822486BC;
	}
	return 0x822486BC;
} // Block from 822486B4h-822486BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822486BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822486BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822486BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822486BC);
		  /* 822486BCh */ case    0:  		/* nop */
		/* 822486BCh case    0:*/		cpu::op::nop();
		/* 822486BCh case    0:*/		return 0x822486C0;
		  /* 822486C0h */ case    1:  		/* lwz R11, <#[R3 + 16]> */
		/* 822486C0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 822486C0h case    1:*/		return 0x822486C4;
		  /* 822486C4h */ case    2:  		/* li R9, 1 */
		/* 822486C4h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 822486C4h case    2:*/		return 0x822486C8;
		  /* 822486C8h */ case    3:  		/* lwz R11, <#[R11 + 20]> */
		/* 822486C8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 822486C8h case    3:*/		return 0x822486CC;
		  /* 822486CCh */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 822486CCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822486CCh case    4:*/		return 0x822486D0;
		  /* 822486D0h */ case    5:  		/* bc 4, CR6_GT, 60 */
		/* 822486D0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8224870C;  }
		/* 822486D0h case    5:*/		return 0x822486D4;
		  /* 822486D4h */ case    6:  		/* li R10, 25 */
		/* 822486D4h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x19);
		/* 822486D4h case    6:*/		return 0x822486D8;
		  /* 822486D8h */ case    7:  		/* mr R7, R11 */
		/* 822486D8h case    7:*/		regs.R7 = regs.R11;
		/* 822486D8h case    7:*/		return 0x822486DC;
		  /* 822486DCh */ case    8:  		/* li R8, 4 */
		/* 822486DCh case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 822486DCh case    8:*/		return 0x822486E0;
		  /* 822486E0h */ case    9:  		/* li R11, 0 */
		/* 822486E0h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822486E0h case    9:*/		return 0x822486E4;
		  /* 822486E4h */ case   10:  		/* mtspr CTR, R8 */
		/* 822486E4h case   10:*/		regs.CTR = regs.R8;
		/* 822486E4h case   10:*/		return 0x822486E8;
		  /* 822486E8h */ case   11:  		/* add R8, R10, R11 */
		/* 822486E8h case   11:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 822486E8h case   11:*/		return 0x822486EC;
		  /* 822486ECh */ case   12:  		/* addi R11, R11, 1 */
		/* 822486ECh case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822486ECh case   12:*/		return 0x822486F0;
		  /* 822486F0h */ case   13:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 822486F0h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 822486F0h case   13:*/		return 0x822486F4;
		  /* 822486F4h */ case   14:  		/* lwzx R8, <#[R8 + R3]> */
		/* 822486F4h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 822486F4h case   14:*/		return 0x822486F8;
		  /* 822486F8h */ case   15:  		/* mullw R9, R8, R9 */
		/* 822486F8h case   15:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 822486F8h case   15:*/		return 0x822486FC;
		  /* 822486FCh */ case   16:  		/* bc 16, CR0_LT, -20 */
		/* 822486FCh case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822486E8;  }
		/* 822486FCh case   16:*/		return 0x82248700;
		  /* 82248700h */ case   17:  		/* addic. R7, R7, -1 */
		/* 82248700h case   17:*/		cpu::op::addic<1>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 82248700h case   17:*/		return 0x82248704;
		  /* 82248704h */ case   18:  		/* addi R10, R10, 4 */
		/* 82248704h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82248704h case   18:*/		return 0x82248708;
		  /* 82248708h */ case   19:  		/* bc 4, CR0_EQ, -44 */
		/* 82248708h case   19:*/		if ( !regs.CR[0].eq ) { return 0x822486DC;  }
		/* 82248708h case   19:*/		return 0x8224870C;
	}
	return 0x8224870C;
} // Block from 822486BCh-8224870Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8224870Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224870C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224870C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224870C);
		  /* 8224870Ch */ case    0:  		/* lwz R11, <#[R3 + 20]> */
		/* 8224870Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8224870Ch case    0:*/		return 0x82248710;
		  /* 82248710h */ case    1:  		/* li R10, 101 */
		/* 82248710h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x65);
		/* 82248710h case    1:*/		return 0x82248714;
		  /* 82248714h */ case    2:  		/* add R11, R11, R9 */
		/* 82248714h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82248714h case    2:*/		return 0x82248718;
		  /* 82248718h */ case    3:  		/* divw R10, R11, R10 */
		/* 82248718h case    3:*/		cpu::op::divw<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82248718h case    3:*/		return 0x8224871C;
		  /* 8224871Ch */ case    4:  		/* mulli R10, R10, 101 */
		/* 8224871Ch case    4:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x65);
		/* 8224871Ch case    4:*/		return 0x82248720;
		  /* 82248720h */ case    5:  		/* subf R3, R10, R11 */
		/* 82248720h case    5:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82248720h case    5:*/		return 0x82248724;
		  /* 82248724h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82248724h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82248724h case    6:*/		return 0x82248728;
	}
	return 0x82248728;
} // Block from 8224870Ch-82248728h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82248728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248728);
		  /* 82248728h */ case    0:  		/* mfspr R12, LR */
		/* 82248728h case    0:*/		regs.R12 = regs.LR;
		/* 82248728h case    0:*/		return 0x8224872C;
		  /* 8224872Ch */ case    1:  		/* bl -1799392 */
		/* 8224872Ch case    1:*/		regs.LR = 0x82248730; return 0x8209124C;
		/* 8224872Ch case    1:*/		return 0x82248730;
		  /* 82248730h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82248730h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82248730h case    2:*/		return 0x82248734;
		  /* 82248734h */ case    3:  		/* mr R31, R3 */
		/* 82248734h case    3:*/		regs.R31 = regs.R3;
		/* 82248734h case    3:*/		return 0x82248738;
		  /* 82248738h */ case    4:  		/* lwz R3, <#[R3 + 16]> */
		/* 82248738h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 82248738h case    4:*/		return 0x8224873C;
		  /* 8224873Ch */ case    5:  		/* li R25, 1 */
		/* 8224873Ch case    5:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8224873Ch case    5:*/		return 0x82248740;
		  /* 82248740h */ case    6:  		/* mr R30, R25 */
		/* 82248740h case    6:*/		regs.R30 = regs.R25;
		/* 82248740h case    6:*/		return 0x82248744;
		  /* 82248744h */ case    7:  		/* lwz R11, <#[R3 + 24]> */
		/* 82248744h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82248744h case    7:*/		return 0x82248748;
		  /* 82248748h */ case    8:  		/* stw R11, <#[R31 + 20]> */
		/* 82248748h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82248748h case    8:*/		return 0x8224874C;
		  /* 8224874Ch */ case    9:  		/* lbz R11, <#[R3 + 164]> */
		/* 8224874Ch case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000A4) );
		/* 8224874Ch case    9:*/		return 0x82248750;
		  /* 82248750h */ case   10:  		/* stw R11, <#[R31 + 24]> */
		/* 82248750h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82248750h case   10:*/		return 0x82248754;
		  /* 82248754h */ case   11:  		/* lwz R11, <#[R3]> */
		/* 82248754h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82248754h case   11:*/		return 0x82248758;
		  /* 82248758h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 82248758h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82248758h case   12:*/		return 0x8224875C;
		  /* 8224875Ch */ case   13:  		/* mtspr CTR, R11 */
		/* 8224875Ch case   13:*/		regs.CTR = regs.R11;
		/* 8224875Ch case   13:*/		return 0x82248760;
		  /* 82248760h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 82248760h case   14:*/		if ( 1 ) { regs.LR = 0x82248764; return (uint32)regs.CTR; }
		/* 82248760h case   14:*/		return 0x82248764;
		  /* 82248764h */ case   15:  		/* cmpwi CR6, R3, 1 */
		/* 82248764h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82248764h case   15:*/		return 0x82248768;
		  /* 82248768h */ case   16:  		/* bc 12, CR6_LT, 96 */
		/* 82248768h case   16:*/		if ( regs.CR[6].lt ) { return 0x822487C8;  }
		/* 82248768h case   16:*/		return 0x8224876C;
		  /* 8224876Ch */ case   17:  		/* li R29, 204 */
		/* 8224876Ch case   17:*/		cpu::op::li<0>(regs,&regs.R29,0xCC);
		/* 8224876Ch case   17:*/		return 0x82248770;
		  /* 82248770h */ case   18:  		/* addi R28, R31, 32 */
		/* 82248770h case   18:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x20);
		/* 82248770h case   18:*/		return 0x82248774;
		  /* 82248774h */ case   19:  		/* addi R27, R31, -124 */
		/* 82248774h case   19:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R31,0xFFFFFF84);
		/* 82248774h case   19:*/		return 0x82248778;
		  /* 82248778h */ case   20:  		/* lwz R11, <#[R31 + 16]> */
		/* 82248778h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82248778h case   20:*/		return 0x8224877C;
		  /* 8224877Ch */ case   21:  		/* add R11, R30, R11 */
		/* 8224877Ch case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8224877Ch case   21:*/		return 0x82248780;
		  /* 82248780h */ case   22:  		/* lbz R11, <#[R11 + 152]> */
		/* 82248780h case   22:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000098) );
		/* 82248780h case   22:*/		return 0x82248784;
		  /* 82248784h */ case   23:  		/* stw R11, <#[R28 + 4]> */
		/* 82248784h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82248784h case   23:*/		return 0x82248788;
		  /* 82248788h */ case   24:  		/* lwz R11, <#[R31 + 16]> */
		/* 82248788h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82248788h case   24:*/		return 0x8224878C;
		  /* 8224878Ch */ case   25:  		/* add R11, R30, R11 */
		/* 8224878Ch case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8224878Ch case   25:*/		return 0x82248790;
		  /* 82248790h */ case   26:  		/* lbz R11, <#[R11 + 158]> */
		/* 82248790h case   26:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000009E) );
		/* 82248790h case   26:*/		return 0x82248794;
		  /* 82248794h */ case   27:  		/* addi R30, R30, 1 */
		/* 82248794h case   27:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82248794h case   27:*/		return 0x82248798;
		  /* 82248798h */ case   28:  		/* stwu R11, <#[R28 + 8]> */
		/* 82248798h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		regs.R28 = (uint32)(regs.R28 + 0x00000008);
		/* 82248798h case   28:*/		return 0x8224879C;
		  /* 8224879Ch */ case   29:  		/* lwz R11, <#[R31 + 16]> */
		/* 8224879Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8224879Ch case   29:*/		return 0x822487A0;
		  /* 822487A0h */ case   30:  		/* lwzx R11, <#[R29 + R11]> */
		/* 822487A0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 822487A0h case   30:*/		return 0x822487A4;
		  /* 822487A4h */ case   31:  		/* stwx R11, <#[R27 + R29]> */
		/* 822487A4h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + regs.R29 + 0x00000000) );
		/* 822487A4h case   31:*/		return 0x822487A8;
		  /* 822487A8h */ case   32:  		/* addi R29, R29, 4 */
		/* 822487A8h case   32:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 822487A8h case   32:*/		return 0x822487AC;
		  /* 822487ACh */ case   33:  		/* lwz R3, <#[R31 + 16]> */
		/* 822487ACh case   33:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 822487ACh case   33:*/		return 0x822487B0;
		  /* 822487B0h */ case   34:  		/* lwz R11, <#[R3]> */
		/* 822487B0h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822487B0h case   34:*/		return 0x822487B4;
		  /* 822487B4h */ case   35:  		/* lwz R11, <#[R11 + 4]> */
		/* 822487B4h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822487B4h case   35:*/		return 0x822487B8;
		  /* 822487B8h */ case   36:  		/* mtspr CTR, R11 */
		/* 822487B8h case   36:*/		regs.CTR = regs.R11;
		/* 822487B8h case   36:*/		return 0x822487BC;
		  /* 822487BCh */ case   37:  		/* bcctrl 20, CR0_LT */
		/* 822487BCh case   37:*/		if ( 1 ) { regs.LR = 0x822487C0; return (uint32)regs.CTR; }
		/* 822487BCh case   37:*/		return 0x822487C0;
		  /* 822487C0h */ case   38:  		/* cmpw CR6, R30, R3 */
		/* 822487C0h case   38:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R3);
		/* 822487C0h case   38:*/		return 0x822487C4;
		  /* 822487C4h */ case   39:  		/* bc 4, CR6_GT, -76 */
		/* 822487C4h case   39:*/		if ( !regs.CR[6].gt ) { return 0x82248778;  }
		/* 822487C4h case   39:*/		return 0x822487C8;
	}
	return 0x822487C8;
} // Block from 82248728h-822487C8h (40 instructions)

//////////////////////////////////////////////////////
// Block at 822487C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822487C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822487C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822487C8);
		  /* 822487C8h */ case    0:  		/* lwz R3, <#[R31 + 16]> */
		/* 822487C8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 822487C8h case    0:*/		return 0x822487CC;
		  /* 822487CCh */ case    1:  		/* lwz R11, <#[R3]> */
		/* 822487CCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822487CCh case    1:*/		return 0x822487D0;
		  /* 822487D0h */ case    2:  		/* lwz R11, <#[R11 + 44]> */
		/* 822487D0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 822487D0h case    2:*/		return 0x822487D4;
		  /* 822487D4h */ case    3:  		/* mtspr CTR, R11 */
		/* 822487D4h case    3:*/		regs.CTR = regs.R11;
		/* 822487D4h case    3:*/		return 0x822487D8;
		  /* 822487D8h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 822487D8h case    4:*/		if ( 1 ) { regs.LR = 0x822487DC; return (uint32)regs.CTR; }
		/* 822487D8h case    4:*/		return 0x822487DC;
		  /* 822487DCh */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 822487DCh case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 822487DCh case    5:*/		return 0x822487E0;
		  /* 822487E0h */ case    6:  		/* bc 12, CR0_EQ, 224 */
		/* 822487E0h case    6:*/		if ( regs.CR[0].eq ) { return 0x822488C0;  }
		/* 822487E0h case    6:*/		return 0x822487E4;
		  /* 822487E4h */ case    7:  		/* lwz R11, <#[R31 + 16]> */
		/* 822487E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 822487E4h case    7:*/		return 0x822487E8;
		  /* 822487E8h */ case    8:  		/* mr R10, R25 */
		/* 822487E8h case    8:*/		regs.R10 = regs.R25;
		/* 822487E8h case    8:*/		return 0x822487EC;
		  /* 822487ECh */ case    9:  		/* li R26, 0 */
		/* 822487ECh case    9:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 822487ECh case    9:*/		return 0x822487F0;
		  /* 822487F0h */ case   10:  		/* lwz R9, <#[R11 + 20]> */
		/* 822487F0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 822487F0h case   10:*/		return 0x822487F4;
		  /* 822487F4h */ case   11:  		/* cmpwi CR6, R9, 1 */
		/* 822487F4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000001);
		/* 822487F4h case   11:*/		return 0x822487F8;
		  /* 822487F8h */ case   12:  		/* bc 12, CR6_LT, 36 */
		/* 822487F8h case   12:*/		if ( regs.CR[6].lt ) { return 0x8224881C;  }
		/* 822487F8h case   12:*/		return 0x822487FC;
		  /* 822487FCh */ case   13:  		/* addi R11, R11, 236 */
		/* 822487FCh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xEC);
		/* 822487FCh case   13:*/		return 0x82248800;
		  /* 82248800h */ case   14:  		/* lwz R8, <#[R11]> */
		/* 82248800h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82248800h case   14:*/		return 0x82248804;
		  /* 82248804h */ case   15:  		/* cmplwi CR6, R8, 0 */
		/* 82248804h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82248804h case   15:*/		return 0x82248808;
		  /* 82248808h */ case   16:  		/* bc 12, CR6_EQ, 176 */
		/* 82248808h case   16:*/		if ( regs.CR[6].eq ) { return 0x822488B8;  }
		/* 82248808h case   16:*/		return 0x8224880C;
		  /* 8224880Ch */ case   17:  		/* addi R10, R10, 1 */
		/* 8224880Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8224880Ch case   17:*/		return 0x82248810;
		  /* 82248810h */ case   18:  		/* addi R11, R11, 4 */
		/* 82248810h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82248810h case   18:*/		return 0x82248814;
		  /* 82248814h */ case   19:  		/* cmpw CR6, R10, R9 */
		/* 82248814h case   19:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 82248814h case   19:*/		return 0x82248818;
		  /* 82248818h */ case   20:  		/* bc 4, CR6_GT, -24 */
		/* 82248818h case   20:*/		if ( !regs.CR[6].gt ) { return 0x82248800;  }
		/* 82248818h case   20:*/		return 0x8224881C;
	}
	return 0x8224881C;
} // Block from 822487C8h-8224881Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224881Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224881C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224881C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224881C);
		  /* 8224881Ch */ case    0:  		/* mr R11, R25 */
		/* 8224881Ch case    0:*/		regs.R11 = regs.R25;
		/* 8224881Ch case    0:*/		return 0x82248820;
		  /* 82248820h */ case    1:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82248820h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82248820h case    1:*/		return 0x82248824;
		  /* 82248824h */ case    2:  		/* bc 4, CR0_EQ, 40 */
		/* 82248824h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8224884C;  }
		/* 82248824h case    2:*/		return 0x82248828;
		  /* 82248828h */ case    3:  		/* lis R11, -32252 */
		/* 82248828h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82248828h case    3:*/		return 0x8224882C;
		  /* 8224882Ch */ case    4:  		/* lis R10, -32252 */
		/* 8224882Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224882Ch case    4:*/		return 0x82248830;
		  /* 82248830h */ case    5:  		/* lis R9, -32253 */
		/* 82248830h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82248830h case    5:*/		return 0x82248834;
		  /* 82248834h */ case    6:  		/* addi R6, R11, 13424 */
		/* 82248834h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3470);
		/* 82248834h case    6:*/		return 0x82248838;
		  /* 82248838h */ case    7:  		/* addi R5, R10, 13384 */
		/* 82248838h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x3448);
		/* 82248838h case    7:*/		return 0x8224883C;
		  /* 8224883Ch */ case    8:  		/* addi R4, R9, 27460 */
		/* 8224883Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8224883Ch case    8:*/		return 0x82248840;
		  /* 82248840h */ case    9:  		/* li R7, 677 */
		/* 82248840h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x2A5);
		/* 82248840h case    9:*/		return 0x82248844;
		  /* 82248844h */ case   10:  		/* li R3, 0 */
		/* 82248844h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82248844h case   10:*/		return 0x82248848;
		  /* 82248848h */ case   11:  		/* bl -986176 */
		/* 82248848h case   11:*/		regs.LR = 0x8224884C; return 0x82157C08;
		/* 82248848h case   11:*/		return 0x8224884C;
	}
	return 0x8224884C;
} // Block from 8224881Ch-8224884Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224884Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224884C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224884C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224884C);
		  /* 8224884Ch */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 8224884Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8224884Ch case    0:*/		return 0x82248850;
		  /* 82248850h */ case    1:  		/* mr R7, R25 */
		/* 82248850h case    1:*/		regs.R7 = regs.R25;
		/* 82248850h case    1:*/		return 0x82248854;
		  /* 82248854h */ case    2:  		/* lwz R11, <#[R11 + 20]> */
		/* 82248854h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82248854h case    2:*/		return 0x82248858;
		  /* 82248858h */ case    3:  		/* cmpwi CR6, R11, 1 */
		/* 82248858h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82248858h case    3:*/		return 0x8224885C;
		  /* 8224885Ch */ case    4:  		/* bc 12, CR6_LT, 608 */
		/* 8224885Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82248ABC;  }
		/* 8224885Ch case    4:*/		return 0x82248860;
		  /* 82248860h */ case    5:  		/* li R10, 4 */
		/* 82248860h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82248860h case    5:*/		return 0x82248864;
		  /* 82248864h */ case    6:  		/* li R9, 4 */
		/* 82248864h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 82248864h case    6:*/		return 0x82248868;
		  /* 82248868h */ case    7:  		/* mr R11, R26 */
		/* 82248868h case    7:*/		regs.R11 = regs.R26;
		/* 82248868h case    7:*/		return 0x8224886C;
		  /* 8224886Ch */ case    8:  		/* addi R8, R10, 25 */
		/* 8224886Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x19);
		/* 8224886Ch case    8:*/		return 0x82248870;
		  /* 82248870h */ case    9:  		/* mtspr CTR, R9 */
		/* 82248870h case    9:*/		regs.CTR = regs.R9;
		/* 82248870h case    9:*/		return 0x82248874;
		  /* 82248874h */ case   10:  		/* add R9, R10, R11 */
		/* 82248874h case   10:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 82248874h case   10:*/		return 0x82248878;
		  /* 82248878h */ case   11:  		/* lwz R6, <#[R31 + 16]> */
		/* 82248878h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 82248878h case   11:*/		return 0x8224887C;
		  /* 8224887Ch */ case   12:  		/* add R5, R8, R11 */
		/* 8224887Ch case   12:*/		cpu::op::add<0>(regs,&regs.R5,regs.R8,regs.R11);
		/* 8224887Ch case   12:*/		return 0x82248880;
		  /* 82248880h */ case   13:  		/* addi R9, R9, 91 */
		/* 82248880h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x5B);
		/* 82248880h case   13:*/		return 0x82248884;
		  /* 82248884h */ case   14:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82248884h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82248884h case   14:*/		return 0x82248888;
		  /* 82248888h */ case   15:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82248888h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82248888h case   15:*/		return 0x8224888C;
		  /* 8224888Ch */ case   16:  		/* addi R11, R11, 1 */
		/* 8224888Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224888Ch case   16:*/		return 0x82248890;
		  /* 82248890h */ case   17:  		/* lwzx R9, <#[R9 + R6]> */
		/* 82248890h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 82248890h case   17:*/		return 0x82248894;
		  /* 82248894h */ case   18:  		/* stwx R9, <#[R5 + R31]> */
		/* 82248894h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R5 + regs.R31 + 0x00000000) );
		/* 82248894h case   18:*/		return 0x82248898;
		  /* 82248898h */ case   19:  		/* bc 16, CR0_LT, -36 */
		/* 82248898h case   19:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82248874;  }
		/* 82248898h case   19:*/		return 0x8224889C;
		  /* 8224889Ch */ case   20:  		/* lwz R11, <#[R31 + 16]> */
		/* 8224889Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8224889Ch case   20:*/		return 0x822488A0;
		  /* 822488A0h */ case   21:  		/* addi R7, R7, 1 */
		/* 822488A0h case   21:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 822488A0h case   21:*/		return 0x822488A4;
		  /* 822488A4h */ case   22:  		/* addi R10, R10, 4 */
		/* 822488A4h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 822488A4h case   22:*/		return 0x822488A8;
		  /* 822488A8h */ case   23:  		/* lwz R11, <#[R11 + 20]> */
		/* 822488A8h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 822488A8h case   23:*/		return 0x822488AC;
		  /* 822488ACh */ case   24:  		/* cmpw CR6, R7, R11 */
		/* 822488ACh case   24:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R11);
		/* 822488ACh case   24:*/		return 0x822488B0;
		  /* 822488B0h */ case   25:  		/* bc 4, CR6_GT, -76 */
		/* 822488B0h case   25:*/		if ( !regs.CR[6].gt ) { return 0x82248864;  }
		/* 822488B0h case   25:*/		return 0x822488B4;
		  /* 822488B4h */ case   26:  		/* b 520 */
		/* 822488B4h case   26:*/		return 0x82248ABC;
		/* 822488B4h case   26:*/		return 0x822488B8;
	}
	return 0x822488B8;
} // Block from 8224884Ch-822488B8h (27 instructions)

//////////////////////////////////////////////////////
// Block at 822488B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822488B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822488B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822488B8);
		  /* 822488B8h */ case    0:  		/* mr R11, R26 */
		/* 822488B8h case    0:*/		regs.R11 = regs.R26;
		/* 822488B8h case    0:*/		return 0x822488BC;
		  /* 822488BCh */ case    1:  		/* b -156 */
		/* 822488BCh case    1:*/		return 0x82248820;
		/* 822488BCh case    1:*/		return 0x822488C0;
	}
	return 0x822488C0;
} // Block from 822488B8h-822488C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822488C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822488C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822488C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822488C0);
		  /* 822488C0h */ case    0:  		/* lwz R3, <#[R31 + 16]> */
		/* 822488C0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 822488C0h case    0:*/		return 0x822488C4;
		  /* 822488C4h */ case    1:  		/* mr R28, R25 */
		/* 822488C4h case    1:*/		regs.R28 = regs.R25;
		/* 822488C4h case    1:*/		return 0x822488C8;
		  /* 822488C8h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 822488C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822488C8h case    2:*/		return 0x822488CC;
		  /* 822488CCh */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 822488CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822488CCh case    3:*/		return 0x822488D0;
		  /* 822488D0h */ case    4:  		/* mtspr CTR, R11 */
		/* 822488D0h case    4:*/		regs.CTR = regs.R11;
		/* 822488D0h case    4:*/		return 0x822488D4;
		  /* 822488D4h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 822488D4h case    5:*/		if ( 1 ) { regs.LR = 0x822488D8; return (uint32)regs.CTR; }
		/* 822488D4h case    5:*/		return 0x822488D8;
		  /* 822488D8h */ case    6:  		/* li R26, 0 */
		/* 822488D8h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 822488D8h case    6:*/		return 0x822488DC;
		  /* 822488DCh */ case    7:  		/* cmpwi CR6, R3, 1 */
		/* 822488DCh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 822488DCh case    7:*/		return 0x822488E0;
		  /* 822488E0h */ case    8:  		/* bc 12, CR6_LT, 216 */
		/* 822488E0h case    8:*/		if ( regs.CR[6].lt ) { return 0x822489B8;  }
		/* 822488E0h case    8:*/		return 0x822488E4;
		  /* 822488E4h */ case    9:  		/* li R29, 29 */
		/* 822488E4h case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x1D);
		/* 822488E4h case    9:*/		return 0x822488E8;
		  /* 822488E8h */ case   10:  		/* lwz R11, <#[R31 + 16]> */
		/* 822488E8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 822488E8h case   10:*/		return 0x822488EC;
		  /* 822488ECh */ case   11:  		/* add R10, R11, R29 */
		/* 822488ECh case   11:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R29);
		/* 822488ECh case   11:*/		return 0x822488F0;
		  /* 822488F0h */ case   12:  		/* lwz R3, <#[R11 + 128]> */
		/* 822488F0h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000080) );
		/* 822488F0h case   12:*/		return 0x822488F4;
		  /* 822488F4h */ case   13:  		/* lwz R11, <#[R10 + 3]> */
		/* 822488F4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000003) );
		/* 822488F4h case   13:*/		return 0x822488F8;
		  /* 822488F8h */ case   14:  		/* lwz R11, <#[R11 + 44]> */
		/* 822488F8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 822488F8h case   14:*/		return 0x822488FC;
		  /* 822488FCh */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 822488FCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822488FCh case   15:*/		return 0x82248900;
		  /* 82248900h */ case   16:  		/* lwz R27, <#[R11]> */
		/* 82248900h case   16:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 82248900h case   16:*/		return 0x82248904;
		  /* 82248904h */ case   17:  		/* bl 28548 */
		/* 82248904h case   17:*/		regs.LR = 0x82248908; return 0x8224F888;
		/* 82248904h case   17:*/		return 0x82248908;
		  /* 82248908h */ case   18:  		/* lwz R11, <#[R31 + 16]> */
		/* 82248908h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82248908h case   18:*/		return 0x8224890C;
		  /* 8224890Ch */ case   19:  		/* mr R4, R28 */
		/* 8224890Ch case   19:*/		regs.R4 = regs.R28;
		/* 8224890Ch case   19:*/		return 0x82248910;
		  /* 82248910h */ case   20:  		/* stw R3, <#[R11 + 12]> */
		/* 82248910h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 82248910h case   20:*/		return 0x82248914;
		  /* 82248914h */ case   21:  		/* lwz R11, <#[R31 + 260]> */
		/* 82248914h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000104) );
		/* 82248914h case   21:*/		return 0x82248918;
		  /* 82248918h */ case   22:  		/* lwz R5, <#[R11 + 2736]> */
		/* 82248918h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000AB0) );
		/* 82248918h case   22:*/		return 0x8224891C;
		  /* 8224891Ch */ case   23:  		/* lwz R3, <#[R31 + 16]> */
		/* 8224891Ch case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8224891Ch case   23:*/		return 0x82248920;
		  /* 82248920h */ case   24:  		/* bl 29848 */
		/* 82248920h case   24:*/		regs.LR = 0x82248924; return 0x8224FDB8;
		/* 82248920h case   24:*/		return 0x82248924;
		  /* 82248924h */ case   25:  		/* lwz R11, <#[R31 + 16]> */
		/* 82248924h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82248924h case   25:*/		return 0x82248928;
		  /* 82248928h */ case   26:  		/* mr R30, R26 */
		/* 82248928h case   26:*/		regs.R30 = regs.R26;
		/* 82248928h case   26:*/		return 0x8224892C;
		  /* 8224892Ch */ case   27:  		/* stw R3, <#[R1 + 80]> */
		/* 8224892Ch case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 8224892Ch case   27:*/		return 0x82248930;
		  /* 82248930h */ case   28:  		/* stw R26, <#[R11 + 12]> */
		/* 82248930h case   28:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000000C) );
		/* 82248930h case   28:*/		return 0x82248934;
		  /* 82248934h */ case   29:  		/* mr R4, R30 */
		/* 82248934h case   29:*/		regs.R4 = regs.R30;
		/* 82248934h case   29:*/		return 0x82248938;
		  /* 82248938h */ case   30:  		/* addi R3, R1, 80 */
		/* 82248938h case   30:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82248938h case   30:*/		return 0x8224893C;
		  /* 8224893Ch */ case   31:  		/* bl -852 */
		/* 8224893Ch case   31:*/		regs.LR = 0x82248940; return 0x822485E8;
		/* 8224893Ch case   31:*/		return 0x82248940;
		  /* 82248940h */ case   32:  		/* cmpwi CR0, R3, 0 */
		/* 82248940h case   32:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82248940h case   32:*/		return 0x82248944;
		  /* 82248944h */ case   33:  		/* bc 12, CR0_EQ, 56 */
		/* 82248944h case   33:*/		if ( regs.CR[0].eq ) { return 0x8224897C;  }
		/* 82248944h case   33:*/		return 0x82248948;
		  /* 82248948h */ case   34:  		/* lwz R3, <#[R31 + 16]> */
		/* 82248948h case   34:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82248948h case   34:*/		return 0x8224894C;
		  /* 8224894Ch */ case   35:  		/* mr R5, R30 */
		/* 8224894Ch case   35:*/		regs.R5 = regs.R30;
		/* 8224894Ch case   35:*/		return 0x82248950;
		  /* 82248950h */ case   36:  		/* mr R4, R28 */
		/* 82248950h case   36:*/		regs.R4 = regs.R28;
		/* 82248950h case   36:*/		return 0x82248954;
		  /* 82248954h */ case   37:  		/* lwz R11, <#[R3]> */
		/* 82248954h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82248954h case   37:*/		return 0x82248958;
		  /* 82248958h */ case   38:  		/* lwz R11, <#[R11 + 80]> */
		/* 82248958h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82248958h case   38:*/		return 0x8224895C;
		  /* 8224895Ch */ case   39:  		/* mtspr CTR, R11 */
		/* 8224895Ch case   39:*/		regs.CTR = regs.R11;
		/* 8224895Ch case   39:*/		return 0x82248960;
		  /* 82248960h */ case   40:  		/* bcctrl 20, CR0_LT */
		/* 82248960h case   40:*/		if ( 1 ) { regs.LR = 0x82248964; return (uint32)regs.CTR; }
		/* 82248960h case   40:*/		return 0x82248964;
		  /* 82248964h */ case   41:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 82248964h case   41:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 82248964h case   41:*/		return 0x82248968;
		  /* 82248968h */ case   42:  		/* add R10, R29, R30 */
		/* 82248968h case   42:*/		cpu::op::add<0>(regs,&regs.R10,regs.R29,regs.R30);
		/* 82248968h case   42:*/		return 0x8224896C;
		  /* 8224896Ch */ case   43:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8224896Ch case   43:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8224896Ch case   43:*/		return 0x82248970;
		  /* 82248970h */ case   44:  		/* lwzx R11, <#[R11 + R27]> */
		/* 82248970h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82248970h case   44:*/		return 0x82248974;
		  /* 82248974h */ case   45:  		/* stwx R11, <#[R10 + R31]> */
		/* 82248974h case   45:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82248974h case   45:*/		return 0x82248978;
		  /* 82248978h */ case   46:  		/* b 16 */
		/* 82248978h case   46:*/		return 0x82248988;
		/* 82248978h case   46:*/		return 0x8224897C;
	}
	return 0x8224897C;
} // Block from 822488C0h-8224897Ch (47 instructions)

//////////////////////////////////////////////////////
// Block at 8224897Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224897C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224897C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224897C);
		  /* 8224897Ch */ case    0:  		/* add R11, R29, R30 */
		/* 8224897Ch case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R29,regs.R30);
		/* 8224897Ch case    0:*/		return 0x82248980;
		  /* 82248980h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82248980h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82248980h case    1:*/		return 0x82248984;
		  /* 82248984h */ case    2:  		/* stwx R26, <#[R11 + R31]> */
		/* 82248984h case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82248984h case    2:*/		return 0x82248988;
	}
	return 0x82248988;
} // Block from 8224897Ch-82248988h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82248988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248988);
		  /* 82248988h */ case    0:  		/* addi R30, R30, 1 */
		/* 82248988h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82248988h case    0:*/		return 0x8224898C;
		  /* 8224898Ch */ case    1:  		/* cmpwi CR6, R30, 4 */
		/* 8224898Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8224898Ch case    1:*/		return 0x82248990;
		  /* 82248990h */ case    2:  		/* bc 12, CR6_LT, -92 */
		/* 82248990h case    2:*/		if ( regs.CR[6].lt ) { return 0x82248934;  }
		/* 82248990h case    2:*/		return 0x82248994;
		  /* 82248994h */ case    3:  		/* lwz R3, <#[R31 + 16]> */
		/* 82248994h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82248994h case    3:*/		return 0x82248998;
		  /* 82248998h */ case    4:  		/* addi R28, R28, 1 */
		/* 82248998h case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82248998h case    4:*/		return 0x8224899C;
		  /* 8224899Ch */ case    5:  		/* addi R29, R29, 4 */
		/* 8224899Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8224899Ch case    5:*/		return 0x822489A0;
		  /* 822489A0h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 822489A0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822489A0h case    6:*/		return 0x822489A4;
		  /* 822489A4h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 822489A4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822489A4h case    7:*/		return 0x822489A8;
		  /* 822489A8h */ case    8:  		/* mtspr CTR, R11 */
		/* 822489A8h case    8:*/		regs.CTR = regs.R11;
		/* 822489A8h case    8:*/		return 0x822489AC;
		  /* 822489ACh */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 822489ACh case    9:*/		if ( 1 ) { regs.LR = 0x822489B0; return (uint32)regs.CTR; }
		/* 822489ACh case    9:*/		return 0x822489B0;
		  /* 822489B0h */ case   10:  		/* cmpw CR6, R28, R3 */
		/* 822489B0h case   10:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R3);
		/* 822489B0h case   10:*/		return 0x822489B4;
		  /* 822489B4h */ case   11:  		/* bc 4, CR6_GT, -204 */
		/* 822489B4h case   11:*/		if ( !regs.CR[6].gt ) { return 0x822488E8;  }
		/* 822489B4h case   11:*/		return 0x822489B8;
	}
	return 0x822489B8;
} // Block from 82248988h-822489B8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822489B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822489B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822489B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822489B8);
		  /* 822489B8h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 822489B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 822489B8h case    0:*/		return 0x822489BC;
		  /* 822489BCh */ case    1:  		/* lwz R10, <#[R11 + 228]> */
		/* 822489BCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 822489BCh case    1:*/		return 0x822489C0;
		  /* 822489C0h */ case    2:  		/* rlwinm. R10, R10, 23, 31, 31 */
		/* 822489C0h case    2:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R10,regs.R10);
		/* 822489C0h case    2:*/		return 0x822489C4;
		  /* 822489C4h */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 822489C4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82248A08;  }
		/* 822489C4h case    3:*/		return 0x822489C8;
		  /* 822489C8h */ case    4:  		/* lwz R10, <#[R11 + 20]> */
		/* 822489C8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 822489C8h case    4:*/		return 0x822489CC;
		  /* 822489CCh */ case    5:  		/* addi R9, R1, 96 */
		/* 822489CCh case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 822489CCh case    5:*/		return 0x822489D0;
		  /* 822489D0h */ case    6:  		/* addi R10, R10, 7 */
		/* 822489D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x7);
		/* 822489D0h case    6:*/		return 0x822489D4;
		  /* 822489D4h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822489D4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822489D4h case    7:*/		return 0x822489D8;
		  /* 822489D8h */ case    8:  		/* lwzx R11, <#[R10 + R11]> */
		/* 822489D8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822489D8h case    8:*/		return 0x822489DC;
		  /* 822489DCh */ case    9:  		/* lwz R11, <#[R11 + 44]> */
		/* 822489DCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 822489DCh case    9:*/		return 0x822489E0;
		  /* 822489E0h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 822489E0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822489E0h case   10:*/		return 0x822489E4;
		  /* 822489E4h */ case   11:  		/* lwz R11, <#[R11]> */
		/* 822489E4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822489E4h case   11:*/		return 0x822489E8;
		  /* 822489E8h */ case   12:  		/* lwz R10, <#[R11]> */
		/* 822489E8h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 822489E8h case   12:*/		return 0x822489EC;
		  /* 822489ECh */ case   13:  		/* lwz R8, <#[R11 + 4]> */
		/* 822489ECh case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 822489ECh case   13:*/		return 0x822489F0;
		  /* 822489F0h */ case   14:  		/* lwz R7, <#[R11 + 8]> */
		/* 822489F0h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 822489F0h case   14:*/		return 0x822489F4;
		  /* 822489F4h */ case   15:  		/* lwz R11, <#[R11 + 12]> */
		/* 822489F4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 822489F4h case   15:*/		return 0x822489F8;
		  /* 822489F8h */ case   16:  		/* stw R10, <#[R9]> */
		/* 822489F8h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 822489F8h case   16:*/		return 0x822489FC;
		  /* 822489FCh */ case   17:  		/* stw R8, <#[R9 + 4]> */
		/* 822489FCh case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000004) );
		/* 822489FCh case   17:*/		return 0x82248A00;
		  /* 82248A00h */ case   18:  		/* stw R7, <#[R9 + 8]> */
		/* 82248A00h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000008) );
		/* 82248A00h case   18:*/		return 0x82248A04;
		  /* 82248A04h */ case   19:  		/* stw R11, <#[R9 + 12]> */
		/* 82248A04h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 82248A04h case   19:*/		return 0x82248A08;
	}
	return 0x82248A08;
} // Block from 822489B8h-82248A08h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82248A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248A08);
		  /* 82248A08h */ case    0:  		/* mr R30, R26 */
		/* 82248A08h case    0:*/		regs.R30 = regs.R26;
		/* 82248A08h case    0:*/		return 0x82248A0C;
		  /* 82248A0Ch */ case    1:  		/* addi R29, R31, 100 */
		/* 82248A0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x64);
		/* 82248A0Ch case    1:*/		return 0x82248A10;
		  /* 82248A10h */ case    2:  		/* lwz R3, <#[R31 + 16]> */
		/* 82248A10h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82248A10h case    2:*/		return 0x82248A14;
		  /* 82248A14h */ case    3:  		/* mr R5, R30 */
		/* 82248A14h case    3:*/		regs.R5 = regs.R30;
		/* 82248A14h case    3:*/		return 0x82248A18;
		  /* 82248A18h */ case    4:  		/* li R4, 0 */
		/* 82248A18h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82248A18h case    4:*/		return 0x82248A1C;
		  /* 82248A1Ch */ case    5:  		/* lwz R11, <#[R3]> */
		/* 82248A1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82248A1Ch case    5:*/		return 0x82248A20;
		  /* 82248A20h */ case    6:  		/* lwz R11, <#[R11 + 80]> */
		/* 82248A20h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82248A20h case    6:*/		return 0x82248A24;
		  /* 82248A24h */ case    7:  		/* mtspr CTR, R11 */
		/* 82248A24h case    7:*/		regs.CTR = regs.R11;
		/* 82248A24h case    7:*/		return 0x82248A28;
		  /* 82248A28h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 82248A28h case    8:*/		if ( 1 ) { regs.LR = 0x82248A2C; return (uint32)regs.CTR; }
		/* 82248A28h case    8:*/		return 0x82248A2C;
		  /* 82248A2Ch */ case    9:  		/* cmpwi CR6, R3, 1 */
		/* 82248A2Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82248A2Ch case    9:*/		return 0x82248A30;
		  /* 82248A30h */ case   10:  		/* bc 12, CR6_EQ, 60 */
		/* 82248A30h case   10:*/		if ( regs.CR[6].eq ) { return 0x82248A6C;  }
		/* 82248A30h case   10:*/		return 0x82248A34;
		  /* 82248A34h */ case   11:  		/* cmpwi CR6, R3, 2 */
		/* 82248A34h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82248A34h case   11:*/		return 0x82248A38;
		  /* 82248A38h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 82248A38h case   12:*/		if ( regs.CR[6].eq ) { return 0x82248A60;  }
		/* 82248A38h case   12:*/		return 0x82248A3C;
		  /* 82248A3Ch */ case   13:  		/* cmpwi CR6, R3, 3 */
		/* 82248A3Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 82248A3Ch case   13:*/		return 0x82248A40;
		  /* 82248A40h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 82248A40h case   14:*/		if ( regs.CR[6].eq ) { return 0x82248A58;  }
		/* 82248A40h case   14:*/		return 0x82248A44;
		  /* 82248A44h */ case   15:  		/* bc 4, CR6_GT, 104 */
		/* 82248A44h case   15:*/		if ( !regs.CR[6].gt ) { return 0x82248AAC;  }
		/* 82248A44h case   15:*/		return 0x82248A48;
		  /* 82248A48h */ case   16:  		/* cmpwi CR6, R3, 7 */
		/* 82248A48h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000007);
		/* 82248A48h case   16:*/		return 0x82248A4C;
		  /* 82248A4Ch */ case   17:  		/* bc 12, CR6_GT, 96 */
		/* 82248A4Ch case   17:*/		if ( regs.CR[6].gt ) { return 0x82248AAC;  }
		/* 82248A4Ch case   17:*/		return 0x82248A50;
	}
	return 0x82248A50;
} // Block from 82248A08h-82248A50h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82248A50h
// Function '?AllocateGlobalRegisters@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248A50);
		  /* 82248A50h */ case    0:  		/* stw R3, <#[R29]> */
		/* 82248A50h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 82248A50h case    0:*/		return 0x82248A54;
		  /* 82248A54h */ case    1:  		/* b 88 */
		/* 82248A54h case    1:*/		return 0x82248AAC;
		/* 82248A54h case    1:*/		return 0x82248A58;
	}
	return 0x82248A58;
} // Block from 82248A50h-82248A58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82248A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248A58);
		  /* 82248A58h */ case    0:  		/* stw R25, <#[R29]> */
		/* 82248A58h case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R29 + 0x00000000) );
		/* 82248A58h case    0:*/		return 0x82248A5C;
		  /* 82248A5Ch */ case    1:  		/* b 80 */
		/* 82248A5Ch case    1:*/		return 0x82248AAC;
		/* 82248A5Ch case    1:*/		return 0x82248A60;
	}
	return 0x82248A60;
} // Block from 82248A58h-82248A60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82248A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248A60);
		  /* 82248A60h */ case    0:  		/* li R11, 2 */
		/* 82248A60h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 82248A60h case    0:*/		return 0x82248A64;
		  /* 82248A64h */ case    1:  		/* stw R11, <#[R29]> */
		/* 82248A64h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82248A64h case    1:*/		return 0x82248A68;
		  /* 82248A68h */ case    2:  		/* b 68 */
		/* 82248A68h case    2:*/		return 0x82248AAC;
		/* 82248A68h case    2:*/		return 0x82248A6C;
	}
	return 0x82248A6C;
} // Block from 82248A60h-82248A6Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82248A6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248A6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248A6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248A6C);
		  /* 82248A6Ch */ case    0:  		/* lwz R3, <#[R31 + 16]> */
		/* 82248A6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82248A6Ch case    0:*/		return 0x82248A70;
		  /* 82248A70h */ case    1:  		/* mr R5, R30 */
		/* 82248A70h case    1:*/		regs.R5 = regs.R30;
		/* 82248A70h case    1:*/		return 0x82248A74;
		  /* 82248A74h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 82248A74h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82248A74h case    2:*/		return 0x82248A78;
		  /* 82248A78h */ case    3:  		/* lwz R28, <#[R3 + 20]> */
		/* 82248A78h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000014) );
		/* 82248A78h case    3:*/		return 0x82248A7C;
		  /* 82248A7Ch */ case    4:  		/* mr R4, R28 */
		/* 82248A7Ch case    4:*/		regs.R4 = regs.R28;
		/* 82248A7Ch case    4:*/		return 0x82248A80;
		  /* 82248A80h */ case    5:  		/* lwz R11, <#[R11 + 80]> */
		/* 82248A80h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82248A80h case    5:*/		return 0x82248A84;
		  /* 82248A84h */ case    6:  		/* mtspr CTR, R11 */
		/* 82248A84h case    6:*/		regs.CTR = regs.R11;
		/* 82248A84h case    6:*/		return 0x82248A88;
		  /* 82248A88h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82248A88h case    7:*/		if ( 1 ) { regs.LR = 0x82248A8C; return (uint32)regs.CTR; }
		/* 82248A88h case    7:*/		return 0x82248A8C;
		  /* 82248A8Ch */ case    8:  		/* rlwinm R11, R28, 2, 0, 29 */
		/* 82248A8Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R28);
		/* 82248A8Ch case    8:*/		return 0x82248A90;
		  /* 82248A90h */ case    9:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82248A90h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82248A90h case    9:*/		return 0x82248A94;
		  /* 82248A94h */ case   10:  		/* add R11, R11, R30 */
		/* 82248A94h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82248A94h case   10:*/		return 0x82248A98;
		  /* 82248A98h */ case   11:  		/* addi R9, R1, 96 */
		/* 82248A98h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 82248A98h case   11:*/		return 0x82248A9C;
		  /* 82248A9Ch */ case   12:  		/* addi R11, R11, 25 */
		/* 82248A9Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x19);
		/* 82248A9Ch case   12:*/		return 0x82248AA0;
		  /* 82248AA0h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82248AA0h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82248AA0h case   13:*/		return 0x82248AA4;
		  /* 82248AA4h */ case   14:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82248AA4h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82248AA4h case   14:*/		return 0x82248AA8;
		  /* 82248AA8h */ case   15:  		/* stwx R10, <#[R11 + R31]> */
		/* 82248AA8h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82248AA8h case   15:*/		return 0x82248AAC;
	}
	return 0x82248AAC;
} // Block from 82248A6Ch-82248AACh (16 instructions)

//////////////////////////////////////////////////////
// Block at 82248AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248AAC);
		  /* 82248AACh */ case    0:  		/* addi R30, R30, 1 */
		/* 82248AACh case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82248AACh case    0:*/		return 0x82248AB0;
		  /* 82248AB0h */ case    1:  		/* addi R29, R29, 4 */
		/* 82248AB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82248AB0h case    1:*/		return 0x82248AB4;
		  /* 82248AB4h */ case    2:  		/* cmpwi CR6, R30, 4 */
		/* 82248AB4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 82248AB4h case    2:*/		return 0x82248AB8;
		  /* 82248AB8h */ case    3:  		/* bc 12, CR6_LT, -168 */
		/* 82248AB8h case    3:*/		if ( regs.CR[6].lt ) { return 0x82248A10;  }
		/* 82248AB8h case    3:*/		return 0x82248ABC;
	}
	return 0x82248ABC;
} // Block from 82248AACh-82248ABCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82248ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248ABC);
		  /* 82248ABCh */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82248ABCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82248ABCh case    0:*/		return 0x82248AC0;
		  /* 82248AC0h */ case    1:  		/* addi R3, R31, 196 */
		/* 82248AC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xC4);
		/* 82248AC0h case    1:*/		return 0x82248AC4;
		  /* 82248AC4h */ case    2:  		/* li R5, 32 */
		/* 82248AC4h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 82248AC4h case    2:*/		return 0x82248AC8;
		  /* 82248AC8h */ case    3:  		/* addi R4, R11, 168 */
		/* 82248AC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA8);
		/* 82248AC8h case    3:*/		return 0x82248ACC;
		  /* 82248ACCh */ case    4:  		/* bl -1798428 */
		/* 82248ACCh case    4:*/		regs.LR = 0x82248AD0; return 0x820919B0;
		/* 82248ACCh case    4:*/		return 0x82248AD0;
		  /* 82248AD0h */ case    5:  		/* lwz R3, <#[R31 + 16]> */
		/* 82248AD0h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82248AD0h case    5:*/		return 0x82248AD4;
		  /* 82248AD4h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 82248AD4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82248AD4h case    6:*/		return 0x82248AD8;
		  /* 82248AD8h */ case    7:  		/* lwz R11, <#[R11 + 32]> */
		/* 82248AD8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82248AD8h case    7:*/		return 0x82248ADC;
		  /* 82248ADCh */ case    8:  		/* mtspr CTR, R11 */
		/* 82248ADCh case    8:*/		regs.CTR = regs.R11;
		/* 82248ADCh case    8:*/		return 0x82248AE0;
		  /* 82248AE0h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 82248AE0h case    9:*/		if ( 1 ) { regs.LR = 0x82248AE4; return (uint32)regs.CTR; }
		/* 82248AE0h case    9:*/		return 0x82248AE4;
		  /* 82248AE4h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82248AE4h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82248AE4h case   10:*/		return 0x82248AE8;
		  /* 82248AE8h */ case   11:  		/* bc 12, CR0_EQ, 28 */
		/* 82248AE8h case   11:*/		if ( regs.CR[0].eq ) { return 0x82248B04;  }
		/* 82248AE8h case   11:*/		return 0x82248AEC;
		  /* 82248AECh */ case   12:  		/* stw R26, <#[R31 + 212]> */
		/* 82248AECh case   12:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000D4) );
		/* 82248AECh case   12:*/		return 0x82248AF0;
		  /* 82248AF0h */ case   13:  		/* addi R3, R31, 228 */
		/* 82248AF0h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xE4);
		/* 82248AF0h case   13:*/		return 0x82248AF4;
		  /* 82248AF4h */ case   14:  		/* lwz R11, <#[R31 + 16]> */
		/* 82248AF4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82248AF4h case   14:*/		return 0x82248AF8;
		  /* 82248AF8h */ case   15:  		/* li R5, 30 */
		/* 82248AF8h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x1E);
		/* 82248AF8h case   15:*/		return 0x82248AFC;
		  /* 82248AFCh */ case   16:  		/* lwz R4, <#[R11 + 184]> */
		/* 82248AFCh case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000000B8) );
		/* 82248AFCh case   16:*/		return 0x82248B00;
		  /* 82248B00h */ case   17:  		/* bl -1798480 */
		/* 82248B00h case   17:*/		regs.LR = 0x82248B04; return 0x820919B0;
		/* 82248B00h case   17:*/		return 0x82248B04;
	}
	return 0x82248B04;
} // Block from 82248ABCh-82248B04h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82248B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248B04);
		  /* 82248B04h */ case    0:  		/* stb R25, <#[R31 + 264]> */
		/* 82248B04h case    0:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R31 + 0x00000108) );
		/* 82248B04h case    0:*/		return 0x82248B08;
		  /* 82248B08h */ case    1:  		/* addi R1, R1, 176 */
		/* 82248B08h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82248B08h case    1:*/		return 0x82248B0C;
		  /* 82248B0Ch */ case    2:  		/* b -1800304 */
		/* 82248B0Ch case    2:*/		return 0x8209129C;
		/* 82248B0Ch case    2:*/		return 0x82248B10;
	}
	return 0x82248B10;
} // Block from 82248B04h-82248B10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82248B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248B10);
		  /* 82248B10h */ case    0:  		/* mfspr R12, LR */
		/* 82248B10h case    0:*/		regs.R12 = regs.LR;
		/* 82248B10h case    0:*/		return 0x82248B14;
		  /* 82248B14h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82248B14h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82248B14h case    1:*/		return 0x82248B18;
		  /* 82248B18h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82248B18h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82248B18h case    2:*/		return 0x82248B1C;
		  /* 82248B1Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82248B1Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82248B1Ch case    3:*/		return 0x82248B20;
		  /* 82248B20h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82248B20h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82248B20h case    4:*/		return 0x82248B24;
		  /* 82248B24h */ case    5:  		/* lbz R11, <#[R4 + 264]> */
		/* 82248B24h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000108) );
		/* 82248B24h case    5:*/		return 0x82248B28;
		  /* 82248B28h */ case    6:  		/* mr R30, R3 */
		/* 82248B28h case    6:*/		regs.R30 = regs.R3;
		/* 82248B28h case    6:*/		return 0x82248B2C;
		  /* 82248B2Ch */ case    7:  		/* mr R31, R4 */
		/* 82248B2Ch case    7:*/		regs.R31 = regs.R4;
		/* 82248B2Ch case    7:*/		return 0x82248B30;
		  /* 82248B30h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 82248B30h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82248B30h case    8:*/		return 0x82248B34;
		  /* 82248B34h */ case    9:  		/* bc 4, CR0_EQ, 12 */
		/* 82248B34h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82248B40;  }
		/* 82248B34h case    9:*/		return 0x82248B38;
		  /* 82248B38h */ case   10:  		/* mr R3, R4 */
		/* 82248B38h case   10:*/		regs.R3 = regs.R4;
		/* 82248B38h case   10:*/		return 0x82248B3C;
		  /* 82248B3Ch */ case   11:  		/* bl -1044 */
		/* 82248B3Ch case   11:*/		regs.LR = 0x82248B40; return 0x82248728;
		/* 82248B3Ch case   11:*/		return 0x82248B40;
	}
	return 0x82248B40;
} // Block from 82248B10h-82248B40h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82248B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248B40);
		  /* 82248B40h */ case    0:  		/* mr R4, R31 */
		/* 82248B40h case    0:*/		regs.R4 = regs.R31;
		/* 82248B40h case    0:*/		return 0x82248B44;
		  /* 82248B44h */ case    1:  		/* mr R3, R30 */
		/* 82248B44h case    1:*/		regs.R3 = regs.R30;
		/* 82248B44h case    1:*/		return 0x82248B48;
		  /* 82248B48h */ case    2:  		/* bl 45616 */
		/* 82248B48h case    2:*/		regs.LR = 0x82248B4C; return 0x82253D78;
		/* 82248B48h case    2:*/		return 0x82248B4C;
		  /* 82248B4Ch */ case    3:  		/* addi R1, R1, 112 */
		/* 82248B4Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82248B4Ch case    3:*/		return 0x82248B50;
		  /* 82248B50h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 82248B50h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82248B50h case    4:*/		return 0x82248B54;
		  /* 82248B54h */ case    5:  		/* mtspr LR, R12 */
		/* 82248B54h case    5:*/		regs.LR = regs.R12;
		/* 82248B54h case    5:*/		return 0x82248B58;
		  /* 82248B58h */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 82248B58h case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82248B58h case    6:*/		return 0x82248B5C;
		  /* 82248B5Ch */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 82248B5Ch case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82248B5Ch case    7:*/		return 0x82248B60;
		  /* 82248B60h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82248B60h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82248B60h case    8:*/		return 0x82248B64;
	}
	return 0x82248B64;
} // Block from 82248B40h-82248B64h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82248B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248B64);
		  /* 82248B64h */ case    0:  		/* nop */
		/* 82248B64h case    0:*/		cpu::op::nop();
		/* 82248B64h case    0:*/		return 0x82248B68;
	}
	return 0x82248B68;
} // Block from 82248B64h-82248B68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82248B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248B68);
		  /* 82248B68h */ case    0:  		/* mfspr R12, LR */
		/* 82248B68h case    0:*/		regs.R12 = regs.LR;
		/* 82248B68h case    0:*/		return 0x82248B6C;
		  /* 82248B6Ch */ case    1:  		/* bl -1800488 */
		/* 82248B6Ch case    1:*/		regs.LR = 0x82248B70; return 0x82091244;
		/* 82248B6Ch case    1:*/		return 0x82248B70;
		  /* 82248B70h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82248B70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82248B70h case    2:*/		return 0x82248B74;
		  /* 82248B74h */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 82248B74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82248B74h case    3:*/		return 0x82248B78;
		  /* 82248B78h */ case    4:  		/* mr R31, R3 */
		/* 82248B78h case    4:*/		regs.R31 = regs.R3;
		/* 82248B78h case    4:*/		return 0x82248B7C;
		  /* 82248B7Ch */ case    5:  		/* lwz R11, <#[R11 + 28]> */
		/* 82248B7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82248B7Ch case    5:*/		return 0x82248B80;
		  /* 82248B80h */ case    6:  		/* lwz R11, <#[R11 + 44]> */
		/* 82248B80h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 82248B80h case    6:*/		return 0x82248B84;
		  /* 82248B84h */ case    7:  		/* lwz R10, <#[R11 + 4]> */
		/* 82248B84h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82248B84h case    7:*/		return 0x82248B88;
		  /* 82248B88h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 82248B88h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82248B88h case    8:*/		return 0x82248B8C;
		  /* 82248B8Ch */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 82248B8Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82248B9C;  }
		/* 82248B8Ch case    9:*/		return 0x82248B90;
		  /* 82248B90h */ case   10:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 82248B90h case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 82248B90h case   10:*/		return 0x82248B94;
		  /* 82248B94h */ case   11:  		/* lwz R24, <#[R11]> */
		/* 82248B94h case   11:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R11 + 0x00000000) );
		/* 82248B94h case   11:*/		return 0x82248B98;
		  /* 82248B98h */ case   12:  		/* b 8 */
		/* 82248B98h case   12:*/		return 0x82248BA0;
		/* 82248B98h case   12:*/		return 0x82248B9C;
	}
	return 0x82248B9C;
} // Block from 82248B68h-82248B9Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82248B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248B9C);
		  /* 82248B9Ch */ case    0:  		/* li R24, 0 */
		/* 82248B9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82248B9Ch case    0:*/		return 0x82248BA0;
	}
	return 0x82248BA0;
} // Block from 82248B9Ch-82248BA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82248BA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248BA0);
		  /* 82248BA0h */ case    0:  		/* lis R11, -32253 */
		/* 82248BA0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82248BA0h case    0:*/		return 0x82248BA4;
		  /* 82248BA4h */ case    1:  		/* lis R10, -32252 */
		/* 82248BA4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82248BA4h case    1:*/		return 0x82248BA8;
		  /* 82248BA8h */ case    2:  		/* lis R9, -32252 */
		/* 82248BA8h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82248BA8h case    2:*/		return 0x82248BAC;
		  /* 82248BACh */ case    3:  		/* li R29, 0 */
		/* 82248BACh case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82248BACh case    3:*/		return 0x82248BB0;
		  /* 82248BB0h */ case    4:  		/* li R28, 0 */
		/* 82248BB0h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82248BB0h case    4:*/		return 0x82248BB4;
		  /* 82248BB4h */ case    5:  		/* mr R30, R31 */
		/* 82248BB4h case    5:*/		regs.R30 = regs.R31;
		/* 82248BB4h case    5:*/		return 0x82248BB8;
		  /* 82248BB8h */ case    6:  		/* subf R23, R31, R24 */
		/* 82248BB8h case    6:*/		cpu::op::subf<0>(regs,&regs.R23,regs.R31,regs.R24);
		/* 82248BB8h case    6:*/		return 0x82248BBC;
		  /* 82248BBCh */ case    7:  		/* addi R27, R11, 27460 */
		/* 82248BBCh case    7:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x6B44);
		/* 82248BBCh case    7:*/		return 0x82248BC0;
		  /* 82248BC0h */ case    8:  		/* addi R26, R10, 13516 */
		/* 82248BC0h case    8:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R10,0x34CC);
		/* 82248BC0h case    8:*/		return 0x82248BC4;
		  /* 82248BC4h */ case    9:  		/* addi R25, R9, 13424 */
		/* 82248BC4h case    9:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R9,0x3470);
		/* 82248BC4h case    9:*/		return 0x82248BC8;
		  /* 82248BC8h */ case   10:  		/* lwz R3, <#[R31 + 16]> */
		/* 82248BC8h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82248BC8h case   10:*/		return 0x82248BCC;
		  /* 82248BCCh */ case   11:  		/* mr R5, R29 */
		/* 82248BCCh case   11:*/		regs.R5 = regs.R29;
		/* 82248BCCh case   11:*/		return 0x82248BD0;
		  /* 82248BD0h */ case   12:  		/* li R4, 0 */
		/* 82248BD0h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82248BD0h case   12:*/		return 0x82248BD4;
		  /* 82248BD4h */ case   13:  		/* lwz R11, <#[R3]> */
		/* 82248BD4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82248BD4h case   13:*/		return 0x82248BD8;
		  /* 82248BD8h */ case   14:  		/* lwz R11, <#[R11 + 80]> */
		/* 82248BD8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82248BD8h case   14:*/		return 0x82248BDC;
		  /* 82248BDCh */ case   15:  		/* mtspr CTR, R11 */
		/* 82248BDCh case   15:*/		regs.CTR = regs.R11;
		/* 82248BDCh case   15:*/		return 0x82248BE0;
		  /* 82248BE0h */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 82248BE0h case   16:*/		if ( 1 ) { regs.LR = 0x82248BE4; return (uint32)regs.CTR; }
		/* 82248BE0h case   16:*/		return 0x82248BE4;
		  /* 82248BE4h */ case   17:  		/* cmplwi CR6, R3, 1 */
		/* 82248BE4h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 82248BE4h case   17:*/		return 0x82248BE8;
		  /* 82248BE8h */ case   18:  		/* bc 12, CR6_LT, 28 */
		/* 82248BE8h case   18:*/		if ( regs.CR[6].lt ) { return 0x82248C04;  }
		/* 82248BE8h case   18:*/		return 0x82248BEC;
		  /* 82248BECh */ case   19:  		/* bc 12, CR6_EQ, 128 */
		/* 82248BECh case   19:*/		if ( regs.CR[6].eq ) { return 0x82248C6C;  }
		/* 82248BECh case   19:*/		return 0x82248BF0;
		  /* 82248BF0h */ case   20:  		/* cmplwi CR6, R3, 3 */
		/* 82248BF0h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000003);
		/* 82248BF0h case   20:*/		return 0x82248BF4;
		  /* 82248BF4h */ case   21:  		/* bc 12, CR6_LT, 112 */
		/* 82248BF4h case   21:*/		if ( regs.CR[6].lt ) { return 0x82248C64;  }
		/* 82248BF4h case   21:*/		return 0x82248BF8;
		  /* 82248BF8h */ case   22:  		/* bc 12, CR6_EQ, 100 */
		/* 82248BF8h case   22:*/		if ( regs.CR[6].eq ) { return 0x82248C5C;  }
		/* 82248BF8h case   22:*/		return 0x82248BFC;
		  /* 82248BFCh */ case   23:  		/* cmplwi CR6, R3, 8 */
		/* 82248BFCh case   23:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000008);
		/* 82248BFCh case   23:*/		return 0x82248C00;
		  /* 82248C00h */ case   24:  		/* bc 4, CR6_LT, 256 */
		/* 82248C00h case   24:*/		if ( !regs.CR[6].lt ) { return 0x82248D00;  }
		/* 82248C00h case   24:*/		return 0x82248C04;
	}
	return 0x82248C04;
} // Block from 82248BA0h-82248C04h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82248C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248C04);
		  /* 82248C04h */ case    0:  		/* lwz R3, <#[R31 + 16]> */
		/* 82248C04h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82248C04h case    0:*/		return 0x82248C08;
		  /* 82248C08h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 82248C08h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82248C08h case    1:*/		return 0x82248C0C;
		  /* 82248C0Ch */ case    2:  		/* lwz R11, <#[R11 + 76]> */
		/* 82248C0Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 82248C0Ch case    2:*/		return 0x82248C10;
		  /* 82248C10h */ case    3:  		/* mtspr CTR, R11 */
		/* 82248C10h case    3:*/		regs.CTR = regs.R11;
		/* 82248C10h case    3:*/		return 0x82248C14;
		  /* 82248C14h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82248C14h case    4:*/		if ( 1 ) { regs.LR = 0x82248C18; return (uint32)regs.CTR; }
		/* 82248C14h case    4:*/		return 0x82248C18;
		  /* 82248C18h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82248C18h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82248C18h case    5:*/		return 0x82248C1C;
		  /* 82248C1Ch */ case    6:  		/* bc 12, CR0_EQ, 208 */
		/* 82248C1Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82248CEC;  }
		/* 82248C1Ch case    6:*/		return 0x82248C20;
		  /* 82248C20h */ case    7:  		/* lwz R3, <#[R31 + 16]> */
		/* 82248C20h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82248C20h case    7:*/		return 0x82248C24;
		  /* 82248C24h */ case    8:  		/* mr R5, R29 */
		/* 82248C24h case    8:*/		regs.R5 = regs.R29;
		/* 82248C24h case    8:*/		return 0x82248C28;
		  /* 82248C28h */ case    9:  		/* li R4, 1 */
		/* 82248C28h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82248C28h case    9:*/		return 0x82248C2C;
		  /* 82248C2Ch */ case   10:  		/* lwz R11, <#[R3]> */
		/* 82248C2Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82248C2Ch case   10:*/		return 0x82248C30;
		  /* 82248C30h */ case   11:  		/* lwz R11, <#[R11 + 80]> */
		/* 82248C30h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82248C30h case   11:*/		return 0x82248C34;
		  /* 82248C34h */ case   12:  		/* mtspr CTR, R11 */
		/* 82248C34h case   12:*/		regs.CTR = regs.R11;
		/* 82248C34h case   12:*/		return 0x82248C38;
		  /* 82248C38h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 82248C38h case   13:*/		if ( 1 ) { regs.LR = 0x82248C3C; return (uint32)regs.CTR; }
		/* 82248C38h case   13:*/		return 0x82248C3C;
		  /* 82248C3Ch */ case   14:  		/* lwz R11, <#[R31 + 16]> */
		/* 82248C3Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82248C3Ch case   14:*/		return 0x82248C40;
		  /* 82248C40h */ case   15:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82248C40h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82248C40h case   15:*/		return 0x82248C44;
		  /* 82248C44h */ case   16:  		/* lwz R11, <#[R11 + 32]> */
		/* 82248C44h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82248C44h case   16:*/		return 0x82248C48;
		  /* 82248C48h */ case   17:  		/* lwz R11, <#[R11 + 44]> */
		/* 82248C48h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 82248C48h case   17:*/		return 0x82248C4C;
		  /* 82248C4Ch */ case   18:  		/* lwz R11, <#[R11 + 4]> */
		/* 82248C4Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82248C4Ch case   18:*/		return 0x82248C50;
		  /* 82248C50h */ case   19:  		/* lwz R11, <#[R11]> */
		/* 82248C50h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82248C50h case   19:*/		return 0x82248C54;
		  /* 82248C54h */ case   20:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82248C54h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82248C54h case   20:*/		return 0x82248C58;
		  /* 82248C58h */ case   21:  		/* b 164 */
		/* 82248C58h case   21:*/		return 0x82248CFC;
		/* 82248C58h case   21:*/		return 0x82248C5C;
	}
	return 0x82248C5C;
} // Block from 82248C04h-82248C5Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 82248C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248C5C);
		  /* 82248C5Ch */ case    0:  		/* li R11, 1 */
		/* 82248C5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82248C5Ch case    0:*/		return 0x82248C60;
		  /* 82248C60h */ case    1:  		/* b 156 */
		/* 82248C60h case    1:*/		return 0x82248CFC;
		/* 82248C60h case    1:*/		return 0x82248C64;
	}
	return 0x82248C64;
} // Block from 82248C5Ch-82248C64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82248C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248C64);
		  /* 82248C64h */ case    0:  		/* li R11, 2 */
		/* 82248C64h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 82248C64h case    0:*/		return 0x82248C68;
		  /* 82248C68h */ case    1:  		/* b 148 */
		/* 82248C68h case    1:*/		return 0x82248CFC;
		/* 82248C68h case    1:*/		return 0x82248C6C;
	}
	return 0x82248C6C;
} // Block from 82248C64h-82248C6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82248C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248C6C);
		  /* 82248C6Ch */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82248C6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82248C6Ch case    0:*/		return 0x82248C70;
		  /* 82248C70h */ case    1:  		/* lwz R10, <#[R11 + 228]> */
		/* 82248C70h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 82248C70h case    1:*/		return 0x82248C74;
		  /* 82248C74h */ case    2:  		/* rlwinm. R10, R10, 23, 31, 31 */
		/* 82248C74h case    2:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R10,regs.R10);
		/* 82248C74h case    2:*/		return 0x82248C78;
		  /* 82248C78h */ case    3:  		/* bc 12, CR0_EQ, 44 */
		/* 82248C78h case    3:*/		if ( regs.CR[0].eq ) { return 0x82248CA4;  }
		/* 82248C78h case    3:*/		return 0x82248C7C;
		  /* 82248C7Ch */ case    4:  		/* rlwinm R10, R11, 0, 0, 31 */
		/* 82248C7Ch case    4:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R11);
		/* 82248C7Ch case    4:*/		return 0x82248C80;
		  /* 82248C80h */ case    5:  		/* lwz R11, <#[R10 + 20]> */
		/* 82248C80h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 82248C80h case    5:*/		return 0x82248C84;
		  /* 82248C84h */ case    6:  		/* addi R11, R11, 7 */
		/* 82248C84h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7);
		/* 82248C84h case    6:*/		return 0x82248C88;
		  /* 82248C88h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82248C88h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82248C88h case    7:*/		return 0x82248C8C;
		  /* 82248C8Ch */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82248C8Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82248C8Ch case    8:*/		return 0x82248C90;
		  /* 82248C90h */ case    9:  		/* lwz R11, <#[R11 + 44]> */
		/* 82248C90h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 82248C90h case    9:*/		return 0x82248C94;
		  /* 82248C94h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 82248C94h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82248C94h case   10:*/		return 0x82248C98;
		  /* 82248C98h */ case   11:  		/* lwz R11, <#[R11]> */
		/* 82248C98h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82248C98h case   11:*/		return 0x82248C9C;
		  /* 82248C9Ch */ case   12:  		/* lwzx R11, <#[R11 + R28]> */
		/* 82248C9Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82248C9Ch case   12:*/		return 0x82248CA0;
		  /* 82248CA0h */ case   13:  		/* b 92 */
		/* 82248CA0h case   13:*/		return 0x82248CFC;
		/* 82248CA0h case   13:*/		return 0x82248CA4;
	}
	return 0x82248CA4;
} // Block from 82248C6Ch-82248CA4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82248CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248CA4);
		  /* 82248CA4h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 82248CA4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82248CA4h case    0:*/		return 0x82248CA8;
		  /* 82248CA8h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 82248CA8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82248CC0;  }
		/* 82248CA8h case    1:*/		return 0x82248CAC;
		  /* 82248CACh */ case    2:  		/* lwz R10, <#[R11 + 24]> */
		/* 82248CACh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 82248CACh case    2:*/		return 0x82248CB0;
		  /* 82248CB0h */ case    3:  		/* cmpwi CR6, R10, 137 */
		/* 82248CB0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000089);
		/* 82248CB0h case    3:*/		return 0x82248CB4;
		  /* 82248CB4h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82248CB4h case    4:*/		if ( regs.CR[6].eq ) { return 0x82248CC0;  }
		/* 82248CB4h case    4:*/		return 0x82248CB8;
		  /* 82248CB8h */ case    5:  		/* lwzx R11, <#[R23 + R30]> */
		/* 82248CB8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + regs.R30 + 0x00000000) );
		/* 82248CB8h case    5:*/		return 0x82248CBC;
		  /* 82248CBCh */ case    6:  		/* b 64 */
		/* 82248CBCh case    6:*/		return 0x82248CFC;
		/* 82248CBCh case    6:*/		return 0x82248CC0;
	}
	return 0x82248CC0;
} // Block from 82248CA4h-82248CC0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82248CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248CC0);
		  /* 82248CC0h */ case    0:  		/* lwz R11, <#[R11 + 24]> */
		/* 82248CC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82248CC0h case    0:*/		return 0x82248CC4;
		  /* 82248CC4h */ case    1:  		/* cmpwi CR6, R11, 137 */
		/* 82248CC4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000089);
		/* 82248CC4h case    1:*/		return 0x82248CC8;
		  /* 82248CC8h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 82248CC8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82248CE4;  }
		/* 82248CC8h case    2:*/		return 0x82248CCC;
		  /* 82248CCCh */ case    3:  		/* mr R6, R25 */
		/* 82248CCCh case    3:*/		regs.R6 = regs.R25;
		/* 82248CCCh case    3:*/		return 0x82248CD0;
		  /* 82248CD0h */ case    4:  		/* mr R5, R26 */
		/* 82248CD0h case    4:*/		regs.R5 = regs.R26;
		/* 82248CD0h case    4:*/		return 0x82248CD4;
		  /* 82248CD4h */ case    5:  		/* mr R4, R27 */
		/* 82248CD4h case    5:*/		regs.R4 = regs.R27;
		/* 82248CD4h case    5:*/		return 0x82248CD8;
		  /* 82248CD8h */ case    6:  		/* li R7, 871 */
		/* 82248CD8h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x367);
		/* 82248CD8h case    6:*/		return 0x82248CDC;
		  /* 82248CDCh */ case    7:  		/* li R3, 0 */
		/* 82248CDCh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82248CDCh case    7:*/		return 0x82248CE0;
		  /* 82248CE0h */ case    8:  		/* bl -987352 */
		/* 82248CE0h case    8:*/		regs.LR = 0x82248CE4; return 0x82157C08;
		/* 82248CE0h case    8:*/		return 0x82248CE4;
	}
	return 0x82248CE4;
} // Block from 82248CC0h-82248CE4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82248CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248CE4);
		  /* 82248CE4h */ case    0:  		/* li R11, 3 */
		/* 82248CE4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 82248CE4h case    0:*/		return 0x82248CE8;
		  /* 82248CE8h */ case    1:  		/* b 20 */
		/* 82248CE8h case    1:*/		return 0x82248CFC;
		/* 82248CE8h case    1:*/		return 0x82248CEC;
	}
	return 0x82248CEC;
} // Block from 82248CE4h-82248CECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82248CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248CEC);
		  /* 82248CECh */ case    0:  		/* lwz R10, <#[R31 + 260]> */
		/* 82248CECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000104) );
		/* 82248CECh case    0:*/		return 0x82248CF0;
		  /* 82248CF0h */ case    1:  		/* lwz R11, <#[R10 + 1528]> */
		/* 82248CF0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005F8) );
		/* 82248CF0h case    1:*/		return 0x82248CF4;
		  /* 82248CF4h */ case    2:  		/* addi R11, R11, 1 */
		/* 82248CF4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82248CF4h case    2:*/		return 0x82248CF8;
		  /* 82248CF8h */ case    3:  		/* stw R11, <#[R10 + 1528]> */
		/* 82248CF8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x000005F8) );
		/* 82248CF8h case    3:*/		return 0x82248CFC;
	}
	return 0x82248CFC;
} // Block from 82248CECh-82248CFCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82248CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248CFC);
		  /* 82248CFCh */ case    0:  		/* stw R11, <#[R30]> */
		/* 82248CFCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82248CFCh case    0:*/		return 0x82248D00;
	}
	return 0x82248D00;
} // Block from 82248CFCh-82248D00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82248D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248D00);
		  /* 82248D00h */ case    0:  		/* addi R28, R28, 4 */
		/* 82248D00h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82248D00h case    0:*/		return 0x82248D04;
		  /* 82248D04h */ case    1:  		/* addi R29, R29, 1 */
		/* 82248D04h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82248D04h case    1:*/		return 0x82248D08;
		  /* 82248D08h */ case    2:  		/* addi R30, R30, 4 */
		/* 82248D08h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82248D08h case    2:*/		return 0x82248D0C;
		  /* 82248D0Ch */ case    3:  		/* cmpwi CR6, R28, 16 */
		/* 82248D0Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000010);
		/* 82248D0Ch case    3:*/		return 0x82248D10;
		  /* 82248D10h */ case    4:  		/* bc 12, CR6_LT, -328 */
		/* 82248D10h case    4:*/		if ( regs.CR[6].lt ) { return 0x82248BC8;  }
		/* 82248D10h case    4:*/		return 0x82248D14;
		  /* 82248D14h */ case    5:  		/* addi R1, R1, 160 */
		/* 82248D14h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82248D14h case    5:*/		return 0x82248D18;
		  /* 82248D18h */ case    6:  		/* b -1800836 */
		/* 82248D18h case    6:*/		return 0x82091294;
		/* 82248D18h case    6:*/		return 0x82248D1C;
		  /* 82248D1Ch */ case    7:  		/* nop */
		/* 82248D1Ch case    7:*/		cpu::op::nop();
		/* 82248D1Ch case    7:*/		return 0x82248D20;
	}
	return 0x82248D20;
} // Block from 82248D00h-82248D20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82248D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248D20);
		  /* 82248D20h */ case    0:  		/* mfspr R12, LR */
		/* 82248D20h case    0:*/		regs.R12 = regs.LR;
		/* 82248D20h case    0:*/		return 0x82248D24;
		  /* 82248D24h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82248D24h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82248D24h case    1:*/		return 0x82248D28;
		  /* 82248D28h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82248D28h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82248D28h case    2:*/		return 0x82248D2C;
		  /* 82248D2Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82248D2Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82248D2Ch case    3:*/		return 0x82248D30;
		  /* 82248D30h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82248D30h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82248D30h case    4:*/		return 0x82248D34;
		  /* 82248D34h */ case    5:  		/* mr R31, R3 */
		/* 82248D34h case    5:*/		regs.R31 = regs.R3;
		/* 82248D34h case    5:*/		return 0x82248D38;
		  /* 82248D38h */ case    6:  		/* mr R3, R4 */
		/* 82248D38h case    6:*/		regs.R3 = regs.R4;
		/* 82248D38h case    6:*/		return 0x82248D3C;
		  /* 82248D3Ch */ case    7:  		/* mr R30, R4 */
		/* 82248D3Ch case    7:*/		regs.R30 = regs.R4;
		/* 82248D3Ch case    7:*/		return 0x82248D40;
		  /* 82248D40h */ case    8:  		/* bl -472 */
		/* 82248D40h case    8:*/		regs.LR = 0x82248D44; return 0x82248B68;
		/* 82248D40h case    8:*/		return 0x82248D44;
		  /* 82248D44h */ case    9:  		/* mr R4, R30 */
		/* 82248D44h case    9:*/		regs.R4 = regs.R30;
		/* 82248D44h case    9:*/		return 0x82248D48;
		  /* 82248D48h */ case   10:  		/* mr R3, R31 */
		/* 82248D48h case   10:*/		regs.R3 = regs.R31;
		/* 82248D48h case   10:*/		return 0x82248D4C;
		  /* 82248D4Ch */ case   11:  		/* bl 45292 */
		/* 82248D4Ch case   11:*/		regs.LR = 0x82248D50; return 0x82253E38;
		/* 82248D4Ch case   11:*/		return 0x82248D50;
		  /* 82248D50h */ case   12:  		/* addi R1, R1, 112 */
		/* 82248D50h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82248D50h case   12:*/		return 0x82248D54;
		  /* 82248D54h */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 82248D54h case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82248D54h case   13:*/		return 0x82248D58;
		  /* 82248D58h */ case   14:  		/* mtspr LR, R12 */
		/* 82248D58h case   14:*/		regs.LR = regs.R12;
		/* 82248D58h case   14:*/		return 0x82248D5C;
		  /* 82248D5Ch */ case   15:  		/* ld R30, <#[R1 - 24]> */
		/* 82248D5Ch case   15:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82248D5Ch case   15:*/		return 0x82248D60;
		  /* 82248D60h */ case   16:  		/* ld R31, <#[R1 - 16]> */
		/* 82248D60h case   16:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82248D60h case   16:*/		return 0x82248D64;
		  /* 82248D64h */ case   17:  		/* bclr 20, CR0_LT */
		/* 82248D64h case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82248D64h case   17:*/		return 0x82248D68;
	}
	return 0x82248D68;
} // Block from 82248D20h-82248D68h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82248D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248D68);
		  /* 82248D68h */ case    0:  		/* mfspr R12, LR */
		/* 82248D68h case    0:*/		regs.R12 = regs.LR;
		/* 82248D68h case    0:*/		return 0x82248D6C;
		  /* 82248D6Ch */ case    1:  		/* bl -1800980 */
		/* 82248D6Ch case    1:*/		regs.LR = 0x82248D70; return 0x82091258;
		/* 82248D6Ch case    1:*/		return 0x82248D70;
		  /* 82248D70h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82248D70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82248D70h case    2:*/		return 0x82248D74;
		  /* 82248D74h */ case    3:  		/* lwz R11, <#[R4]> */
		/* 82248D74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82248D74h case    3:*/		return 0x82248D78;
		  /* 82248D78h */ case    4:  		/* mr R29, R3 */
		/* 82248D78h case    4:*/		regs.R29 = regs.R3;
		/* 82248D78h case    4:*/		return 0x82248D7C;
		  /* 82248D7Ch */ case    5:  		/* mr R3, R4 */
		/* 82248D7Ch case    5:*/		regs.R3 = regs.R4;
		/* 82248D7Ch case    5:*/		return 0x82248D80;
		  /* 82248D80h */ case    6:  		/* mr R30, R4 */
		/* 82248D80h case    6:*/		regs.R30 = regs.R4;
		/* 82248D80h case    6:*/		return 0x82248D84;
		  /* 82248D84h */ case    7:  		/* mr R28, R5 */
		/* 82248D84h case    7:*/		regs.R28 = regs.R5;
		/* 82248D84h case    7:*/		return 0x82248D88;
		  /* 82248D88h */ case    8:  		/* lwz R11, <#[R11 + 76]> */
		/* 82248D88h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 82248D88h case    8:*/		return 0x82248D8C;
		  /* 82248D8Ch */ case    9:  		/* mtspr CTR, R11 */
		/* 82248D8Ch case    9:*/		regs.CTR = regs.R11;
		/* 82248D8Ch case    9:*/		return 0x82248D90;
		  /* 82248D90h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 82248D90h case   10:*/		if ( 1 ) { regs.LR = 0x82248D94; return (uint32)regs.CTR; }
		/* 82248D90h case   10:*/		return 0x82248D94;
		  /* 82248D94h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82248D94h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82248D94h case   11:*/		return 0x82248D98;
		  /* 82248D98h */ case   12:  		/* bc 12, CR0_EQ, 180 */
		/* 82248D98h case   12:*/		if ( regs.CR[0].eq ) { return 0x82248E4C;  }
		/* 82248D98h case   12:*/		return 0x82248D9C;
		  /* 82248D9Ch */ case   13:  		/* lwz R11, <#[R30 + 236]> */
		/* 82248D9Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000EC) );
		/* 82248D9Ch case   13:*/		return 0x82248DA0;
		  /* 82248DA0h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82248DA0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82248DA0h case   14:*/		return 0x82248DA4;
		  /* 82248DA4h */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 82248DA4h case   15:*/		if ( regs.CR[6].eq ) { return 0x82248DB0;  }
		/* 82248DA4h case   15:*/		return 0x82248DA8;
		  /* 82248DA8h */ case   16:  		/* lwz R11, <#[R11 + 80]> */
		/* 82248DA8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82248DA8h case   16:*/		return 0x82248DAC;
		  /* 82248DACh */ case   17:  		/* b 8 */
		/* 82248DACh case   17:*/		return 0x82248DB4;
		/* 82248DACh case   17:*/		return 0x82248DB0;
	}
	return 0x82248DB0;
} // Block from 82248D68h-82248DB0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82248DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248DB0);
		  /* 82248DB0h */ case    0:  		/* lwz R11, <#[R30 + 84]> */
		/* 82248DB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000054) );
		/* 82248DB0h case    0:*/		return 0x82248DB4;
	}
	return 0x82248DB4;
} // Block from 82248DB0h-82248DB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82248DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248DB4);
		  /* 82248DB4h */ case    0:  		/* lis R10, -32251 */
		/* 82248DB4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82248DB4h case    0:*/		return 0x82248DB8;
		  /* 82248DB8h */ case    1:  		/* mulli R9, R11, 12 */
		/* 82248DB8h case    1:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R11,0xC);
		/* 82248DB8h case    1:*/		return 0x82248DBC;
		  /* 82248DBCh */ case    2:  		/* addi R11, R10, -19064 */
		/* 82248DBCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFB588);
		/* 82248DBCh case    2:*/		return 0x82248DC0;
		  /* 82248DC0h */ case    3:  		/* addi R11, R11, 6 */
		/* 82248DC0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6);
		/* 82248DC0h case    3:*/		return 0x82248DC4;
		  /* 82248DC4h */ case    4:  		/* lbzx R11, <#[R9 + R11]> */
		/* 82248DC4h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82248DC4h case    4:*/		return 0x82248DC8;
		  /* 82248DC8h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 82248DC8h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82248DC8h case    5:*/		return 0x82248DCC;
		  /* 82248DCCh */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82248DCCh case    6:*/		if ( regs.CR[0].eq ) { return 0x82248DDC;  }
		/* 82248DCCh case    6:*/		return 0x82248DD0;
		  /* 82248DD0h */ case    7:  		/* cmplwi CR6, R11, 4 */
		/* 82248DD0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82248DD0h case    7:*/		return 0x82248DD4;
		  /* 82248DD4h */ case    8:  		/* li R11, 1 */
		/* 82248DD4h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82248DD4h case    8:*/		return 0x82248DD8;
		  /* 82248DD8h */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 82248DD8h case    9:*/		if ( !regs.CR[6].gt ) { return 0x82248DE0;  }
		/* 82248DD8h case    9:*/		return 0x82248DDC;
	}
	return 0x82248DDC;
} // Block from 82248DB4h-82248DDCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 82248DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248DDC);
		  /* 82248DDCh */ case    0:  		/* li R11, 0 */
		/* 82248DDCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82248DDCh case    0:*/		return 0x82248DE0;
	}
	return 0x82248DE0;
} // Block from 82248DDCh-82248DE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82248DE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248DE0);
		  /* 82248DE0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82248DE0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82248DE0h case    0:*/		return 0x82248DE4;
		  /* 82248DE4h */ case    1:  		/* bc 12, CR0_EQ, 104 */
		/* 82248DE4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82248E4C;  }
		/* 82248DE4h case    1:*/		return 0x82248DE8;
		  /* 82248DE8h */ case    2:  		/* li R31, 0 */
		/* 82248DE8h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82248DE8h case    2:*/		return 0x82248DEC;
		  /* 82248DECh */ case    3:  		/* lwz R11, <#[R29]> */
		/* 82248DECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82248DECh case    3:*/		return 0x82248DF0;
		  /* 82248DF0h */ case    4:  		/* mr R5, R31 */
		/* 82248DF0h case    4:*/		regs.R5 = regs.R31;
		/* 82248DF0h case    4:*/		return 0x82248DF4;
		  /* 82248DF4h */ case    5:  		/* mr R4, R28 */
		/* 82248DF4h case    5:*/		regs.R4 = regs.R28;
		/* 82248DF4h case    5:*/		return 0x82248DF8;
		  /* 82248DF8h */ case    6:  		/* mr R3, R29 */
		/* 82248DF8h case    6:*/		regs.R3 = regs.R29;
		/* 82248DF8h case    6:*/		return 0x82248DFC;
		  /* 82248DFCh */ case    7:  		/* lwz R11, <#[R11 + 80]> */
		/* 82248DFCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82248DFCh case    7:*/		return 0x82248E00;
		  /* 82248E00h */ case    8:  		/* mtspr CTR, R11 */
		/* 82248E00h case    8:*/		regs.CTR = regs.R11;
		/* 82248E00h case    8:*/		return 0x82248E04;
		  /* 82248E04h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 82248E04h case    9:*/		if ( 1 ) { regs.LR = 0x82248E08; return (uint32)regs.CTR; }
		/* 82248E04h case    9:*/		return 0x82248E08;
		  /* 82248E08h */ case   10:  		/* or. R5, R3, R3 */
		/* 82248E08h case   10:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 82248E08h case   10:*/		return 0x82248E0C;
		  /* 82248E0Ch */ case   11:  		/* bc 12, CR0_LT, 44 */
		/* 82248E0Ch case   11:*/		if ( regs.CR[0].lt ) { return 0x82248E38;  }
		/* 82248E0Ch case   11:*/		return 0x82248E10;
		  /* 82248E10h */ case   12:  		/* cmpwi CR6, R5, 3 */
		/* 82248E10h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000003);
		/* 82248E10h case   12:*/		return 0x82248E14;
		  /* 82248E14h */ case   13:  		/* bc 12, CR6_GT, 36 */
		/* 82248E14h case   13:*/		if ( regs.CR[6].gt ) { return 0x82248E38;  }
		/* 82248E14h case   13:*/		return 0x82248E18;
		  /* 82248E18h */ case   14:  		/* lwz R11, <#[R30]> */
		/* 82248E18h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82248E18h case   14:*/		return 0x82248E1C;
		  /* 82248E1Ch */ case   15:  		/* li R4, 0 */
		/* 82248E1Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82248E1Ch case   15:*/		return 0x82248E20;
		  /* 82248E20h */ case   16:  		/* mr R3, R30 */
		/* 82248E20h case   16:*/		regs.R3 = regs.R30;
		/* 82248E20h case   16:*/		return 0x82248E24;
		  /* 82248E24h */ case   17:  		/* lwz R11, <#[R11 + 80]> */
		/* 82248E24h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82248E24h case   17:*/		return 0x82248E28;
		  /* 82248E28h */ case   18:  		/* mtspr CTR, R11 */
		/* 82248E28h case   18:*/		regs.CTR = regs.R11;
		/* 82248E28h case   18:*/		return 0x82248E2C;
		  /* 82248E2Ch */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 82248E2Ch case   19:*/		if ( 1 ) { regs.LR = 0x82248E30; return (uint32)regs.CTR; }
		/* 82248E2Ch case   19:*/		return 0x82248E30;
		  /* 82248E30h */ case   20:  		/* cmpwi CR6, R3, 1 */
		/* 82248E30h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82248E30h case   20:*/		return 0x82248E34;
		  /* 82248E34h */ case   21:  		/* bc 12, CR6_EQ, 24 */
		/* 82248E34h case   21:*/		if ( regs.CR[6].eq ) { return 0x82248E4C;  }
		/* 82248E34h case   21:*/		return 0x82248E38;
	}
	return 0x82248E38;
} // Block from 82248DE0h-82248E38h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82248E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248E38);
		  /* 82248E38h */ case    0:  		/* addi R31, R31, 1 */
		/* 82248E38h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82248E38h case    0:*/		return 0x82248E3C;
		  /* 82248E3Ch */ case    1:  		/* cmpwi CR6, R31, 4 */
		/* 82248E3Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 82248E3Ch case    1:*/		return 0x82248E40;
		  /* 82248E40h */ case    2:  		/* bc 12, CR6_LT, -84 */
		/* 82248E40h case    2:*/		if ( regs.CR[6].lt ) { return 0x82248DEC;  }
		/* 82248E40h case    2:*/		return 0x82248E44;
		  /* 82248E44h */ case    3:  		/* li R3, 1 */
		/* 82248E44h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82248E44h case    3:*/		return 0x82248E48;
		  /* 82248E48h */ case    4:  		/* b 8 */
		/* 82248E48h case    4:*/		return 0x82248E50;
		/* 82248E48h case    4:*/		return 0x82248E4C;
	}
	return 0x82248E4C;
} // Block from 82248E38h-82248E4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82248E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248E4C);
		  /* 82248E4Ch */ case    0:  		/* li R3, 0 */
		/* 82248E4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82248E4Ch case    0:*/		return 0x82248E50;
	}
	return 0x82248E50;
} // Block from 82248E4Ch-82248E50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82248E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248E50);
		  /* 82248E50h */ case    0:  		/* addi R1, R1, 128 */
		/* 82248E50h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82248E50h case    0:*/		return 0x82248E54;
		  /* 82248E54h */ case    1:  		/* b -1801132 */
		/* 82248E54h case    1:*/		return 0x820912A8;
		/* 82248E54h case    1:*/		return 0x82248E58;
	}
	return 0x82248E58;
} // Block from 82248E50h-82248E58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82248E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248E58);
		  /* 82248E58h */ case    0:  		/* mfspr R12, LR */
		/* 82248E58h case    0:*/		regs.R12 = regs.LR;
		/* 82248E58h case    0:*/		return 0x82248E5C;
		  /* 82248E5Ch */ case    1:  		/* bl -1801276 */
		/* 82248E5Ch case    1:*/		regs.LR = 0x82248E60; return 0x82091220;
		/* 82248E5Ch case    1:*/		return 0x82248E60;
		  /* 82248E60h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 82248E60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 82248E60h case    2:*/		return 0x82248E64;
		  /* 82248E64h */ case    3:  		/* li R18, 0 */
		/* 82248E64h case    3:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 82248E64h case    3:*/		return 0x82248E68;
		  /* 82248E68h */ case    4:  		/* lwz R17, <#[R1 + 80]> */
		/* 82248E68h case    4:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x00000050) );
		/* 82248E68h case    4:*/		return 0x82248E6C;
		  /* 82248E6Ch */ case    5:  		/* mr R16, R3 */
		/* 82248E6Ch case    5:*/		regs.R16 = regs.R3;
		/* 82248E6Ch case    5:*/		return 0x82248E70;
		  /* 82248E70h */ case    6:  		/* stw R18, <#[R5 + 4]> */
		/* 82248E70h case    6:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R5 + 0x00000004) );
		/* 82248E70h case    6:*/		return 0x82248E74;
		  /* 82248E74h */ case    7:  		/* mr R15, R4 */
		/* 82248E74h case    7:*/		regs.R15 = regs.R4;
		/* 82248E74h case    7:*/		return 0x82248E78;
		  /* 82248E78h */ case    8:  		/* stw R18, <#[R6 + 4]> */
		/* 82248E78h case    8:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R6 + 0x00000004) );
		/* 82248E78h case    8:*/		return 0x82248E7C;
		  /* 82248E7Ch */ case    9:  		/* mr R27, R5 */
		/* 82248E7Ch case    9:*/		regs.R27 = regs.R5;
		/* 82248E7Ch case    9:*/		return 0x82248E80;
		  /* 82248E80h */ case   10:  		/* stw R18, <#[R7 + 4]> */
		/* 82248E80h case   10:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R7 + 0x00000004) );
		/* 82248E80h case   10:*/		return 0x82248E84;
		  /* 82248E84h */ case   11:  		/* mr R21, R6 */
		/* 82248E84h case   11:*/		regs.R21 = regs.R6;
		/* 82248E84h case   11:*/		return 0x82248E88;
		  /* 82248E88h */ case   12:  		/* stw R18, <#[R8 + 4]> */
		/* 82248E88h case   12:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R8 + 0x00000004) );
		/* 82248E88h case   12:*/		return 0x82248E8C;
		  /* 82248E8Ch */ case   13:  		/* mr R20, R7 */
		/* 82248E8Ch case   13:*/		regs.R20 = regs.R7;
		/* 82248E8Ch case   13:*/		return 0x82248E90;
		  /* 82248E90h */ case   14:  		/* mr R19, R8 */
		/* 82248E90h case   14:*/		regs.R19 = regs.R8;
		/* 82248E90h case   14:*/		return 0x82248E94;
		  /* 82248E94h */ case   15:  		/* stw R18, <#[R9 + 4]> */
		/* 82248E94h case   15:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R9 + 0x00000004) );
		/* 82248E94h case   15:*/		return 0x82248E98;
		  /* 82248E98h */ case   16:  		/* mr R22, R9 */
		/* 82248E98h case   16:*/		regs.R22 = regs.R9;
		/* 82248E98h case   16:*/		return 0x82248E9C;
		  /* 82248E9Ch */ case   17:  		/* mr R14, R10 */
		/* 82248E9Ch case   17:*/		regs.R14 = regs.R10;
		/* 82248E9Ch case   17:*/		return 0x82248EA0;
		  /* 82248EA0h */ case   18:  		/* li R23, 1 */
		/* 82248EA0h case   18:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 82248EA0h case   18:*/		return 0x82248EA4;
		  /* 82248EA4h */ case   19:  		/* mr R26, R18 */
		/* 82248EA4h case   19:*/		regs.R26 = regs.R18;
		/* 82248EA4h case   19:*/		return 0x82248EA8;
		  /* 82248EA8h */ case   20:  		/* mr R24, R18 */
		/* 82248EA8h case   20:*/		regs.R24 = regs.R18;
		/* 82248EA8h case   20:*/		return 0x82248EAC;
		  /* 82248EACh */ case   21:  		/* lwz R11, <#[R15 + 56]> */
		/* 82248EACh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000038) );
		/* 82248EACh case   21:*/		return 0x82248EB0;
		  /* 82248EB0h */ case   22:  		/* lwz R10, <#[R11 + 4]> */
		/* 82248EB0h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82248EB0h case   22:*/		return 0x82248EB4;
		  /* 82248EB4h */ case   23:  		/* cmplw CR6, R23, R10 */
		/* 82248EB4h case   23:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R10);
		/* 82248EB4h case   23:*/		return 0x82248EB8;
		  /* 82248EB8h */ case   24:  		/* bc 4, CR6_GT, 12 */
		/* 82248EB8h case   24:*/		if ( !regs.CR[6].gt ) { return 0x82248EC4;  }
		/* 82248EB8h case   24:*/		return 0x82248EBC;
		  /* 82248EBCh */ case   25:  		/* mr R11, R18 */
		/* 82248EBCh case   25:*/		regs.R11 = regs.R18;
		/* 82248EBCh case   25:*/		return 0x82248EC0;
		  /* 82248EC0h */ case   26:  		/* b 16 */
		/* 82248EC0h case   26:*/		return 0x82248ED0;
		/* 82248EC0h case   26:*/		return 0x82248EC4;
	}
	return 0x82248EC4;
} // Block from 82248E58h-82248EC4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82248EC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248EC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248EC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248EC4);
		  /* 82248EC4h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82248EC4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82248EC4h case    0:*/		return 0x82248EC8;
		  /* 82248EC8h */ case    1:  		/* li R11, 1 */
		/* 82248EC8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82248EC8h case    1:*/		return 0x82248ECC;
		  /* 82248ECCh */ case    2:  		/* lwzx R26, <#[R10 + R24]> */
		/* 82248ECCh case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R10 + regs.R24 + 0x00000000) );
		/* 82248ECCh case    2:*/		return 0x82248ED0;
	}
	return 0x82248ED0;
} // Block from 82248EC4h-82248ED0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82248ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248ED0);
		  /* 82248ED0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82248ED0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82248ED0h case    0:*/		return 0x82248ED4;
		  /* 82248ED4h */ case    1:  		/* bc 12, CR0_EQ, 424 */
		/* 82248ED4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8224907C;  }
		/* 82248ED4h case    1:*/		return 0x82248ED8;
		  /* 82248ED8h */ case    2:  		/* mr R4, R15 */
		/* 82248ED8h case    2:*/		regs.R4 = regs.R15;
		/* 82248ED8h case    2:*/		return 0x82248EDC;
		  /* 82248EDCh */ case    3:  		/* mr R3, R26 */
		/* 82248EDCh case    3:*/		regs.R3 = regs.R26;
		/* 82248EDCh case    3:*/		return 0x82248EE0;
		  /* 82248EE0h */ case    4:  		/* bl 66784 */
		/* 82248EE0h case    4:*/		regs.LR = 0x82248EE4; return 0x822593C0;
		/* 82248EE0h case    4:*/		return 0x82248EE4;
		  /* 82248EE4h */ case    5:  		/* lwz R28, <#[R26 + 28]> */
		/* 82248EE4h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R26 + 0x0000001C) );
		/* 82248EE4h case    5:*/		return 0x82248EE8;
		  /* 82248EE8h */ case    6:  		/* lwz R17, <#[R16 + 2148]> */
		/* 82248EE8h case    6:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R16 + 0x00000864) );
		/* 82248EE8h case    6:*/		return 0x82248EEC;
		  /* 82248EECh */ case    7:  		/* mr R25, R3 */
		/* 82248EECh case    7:*/		regs.R25 = regs.R3;
		/* 82248EECh case    7:*/		return 0x82248EF0;
		  /* 82248EF0h */ case    8:  		/* b 372 */
		/* 82248EF0h case    8:*/		return 0x82249064;
		/* 82248EF0h case    8:*/		return 0x82248EF4;
		  /* 82248EF4h */ case    9:  		/* lwz R11, <#[R28 + 228]> */
		/* 82248EF4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82248EF4h case    9:*/		return 0x82248EF8;
		  /* 82248EF8h */ case   10:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82248EF8h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82248EF8h case   10:*/		return 0x82248EFC;
		  /* 82248EFCh */ case   11:  		/* bc 12, CR0_EQ, 356 */
		/* 82248EFCh case   11:*/		if ( regs.CR[0].eq ) { return 0x82249060;  }
		/* 82248EFCh case   11:*/		return 0x82248F00;
		  /* 82248F00h */ case   12:  		/* lwz R11, <#[R28]> */
		/* 82248F00h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82248F00h case   12:*/		return 0x82248F04;
		  /* 82248F04h */ case   13:  		/* mr R3, R28 */
		/* 82248F04h case   13:*/		regs.R3 = regs.R28;
		/* 82248F04h case   13:*/		return 0x82248F08;
		  /* 82248F08h */ case   14:  		/* lwz R11, <#[R11 + 44]> */
		/* 82248F08h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 82248F08h case   14:*/		return 0x82248F0C;
		  /* 82248F0Ch */ case   15:  		/* mtspr CTR, R11 */
		/* 82248F0Ch case   15:*/		regs.CTR = regs.R11;
		/* 82248F0Ch case   15:*/		return 0x82248F10;
		  /* 82248F10h */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 82248F10h case   16:*/		if ( 1 ) { regs.LR = 0x82248F14; return (uint32)regs.CTR; }
		/* 82248F10h case   16:*/		return 0x82248F14;
		  /* 82248F14h */ case   17:  		/* or. R31, R3, R3 */
		/* 82248F14h case   17:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82248F14h case   17:*/		return 0x82248F18;
		  /* 82248F18h */ case   18:  		/* bc 12, CR0_EQ, 328 */
		/* 82248F18h case   18:*/		if ( regs.CR[0].eq ) { return 0x82249060;  }
		/* 82248F18h case   18:*/		return 0x82248F1C;
		  /* 82248F1Ch */ case   19:  		/* addi R11, R25, 58 */
		/* 82248F1Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0x3A);
		/* 82248F1Ch case   19:*/		return 0x82248F20;
		  /* 82248F20h */ case   20:  		/* lwz R10, <#[R31 + 56]> */
		/* 82248F20h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 82248F20h case   20:*/		return 0x82248F24;
		  /* 82248F24h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82248F24h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82248F24h case   21:*/		return 0x82248F28;
		  /* 82248F28h */ case   22:  		/* lwzx R29, <#[R11 + R31]> */
		/* 82248F28h case   22:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82248F28h case   22:*/		return 0x82248F2C;
		  /* 82248F2Ch */ case   23:  		/* lwz R11, <#[R29 + 56]> */
		/* 82248F2Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000038) );
		/* 82248F2Ch case   23:*/		return 0x82248F30;
		  /* 82248F30h */ case   24:  		/* cmpw CR6, R10, R11 */
		/* 82248F30h case   24:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82248F30h case   24:*/		return 0x82248F34;
		  /* 82248F34h */ case   25:  		/* bc 4, CR6_EQ, 20 */
		/* 82248F34h case   25:*/		if ( !regs.CR[6].eq ) { return 0x82248F48;  }
		/* 82248F34h case   25:*/		return 0x82248F38;
		  /* 82248F38h */ case   26:  		/* lwz R11, <#[R31 + 80]> */
		/* 82248F38h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 82248F38h case   26:*/		return 0x82248F3C;
		  /* 82248F3Ch */ case   27:  		/* lwz R10, <#[R29 + 80]> */
		/* 82248F3Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000050) );
		/* 82248F3Ch case   27:*/		return 0x82248F40;
		  /* 82248F40h */ case   28:  		/* cmpw CR6, R11, R10 */
		/* 82248F40h case   28:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82248F40h case   28:*/		return 0x82248F44;
		  /* 82248F44h */ case   29:  		/* bc 12, CR6_EQ, 284 */
		/* 82248F44h case   29:*/		if ( regs.CR[6].eq ) { return 0x82249060;  }
		/* 82248F44h case   29:*/		return 0x82248F48;
	}
	return 0x82248F48;
} // Block from 82248ED0h-82248F48h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82248F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248F48);
		  /* 82248F48h */ case    0:  		/* lwz R11, <#[R31 + 892]> */
		/* 82248F48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000037C) );
		/* 82248F48h case    0:*/		return 0x82248F4C;
		  /* 82248F4Ch */ case    1:  		/* cmpw CR6, R11, R17 */
		/* 82248F4Ch case    1:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R17);
		/* 82248F4Ch case    1:*/		return 0x82248F50;
		  /* 82248F50h */ case    2:  		/* bc 12, CR6_GT, 44 */
		/* 82248F50h case    2:*/		if ( regs.CR[6].gt ) { return 0x82248F7C;  }
		/* 82248F50h case    2:*/		return 0x82248F54;
		  /* 82248F54h */ case    3:  		/* mr R3, R22 */
		/* 82248F54h case    3:*/		regs.R3 = regs.R22;
		/* 82248F54h case    3:*/		return 0x82248F58;
		  /* 82248F58h */ case    4:  		/* lwz R4, <#[R22 + 4]> */
		/* 82248F58h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x00000004) );
		/* 82248F58h case    4:*/		return 0x82248F5C;
		  /* 82248F5Ch */ case    5:  		/* bl 43876 */
		/* 82248F5Ch case    5:*/		regs.LR = 0x82248F60; return 0x82253AC0;
		/* 82248F5Ch case    5:*/		return 0x82248F60;
		  /* 82248F60h */ case    6:  		/* stw R31, <#[R3]> */
		/* 82248F60h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82248F60h case    6:*/		return 0x82248F64;
		  /* 82248F64h */ case    7:  		/* lwz R11, <#[R22 + 4]> */
		/* 82248F64h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 82248F64h case    7:*/		return 0x82248F68;
		  /* 82248F68h */ case    8:  		/* addi R30, R11, -1 */
		/* 82248F68h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFF);
		/* 82248F68h case    8:*/		return 0x82248F6C;
		  /* 82248F6Ch */ case    9:  		/* add R11, R30, R17 */
		/* 82248F6Ch case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R17);
		/* 82248F6Ch case    9:*/		return 0x82248F70;
		  /* 82248F70h */ case   10:  		/* addi R11, R11, 1 */
		/* 82248F70h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82248F70h case   10:*/		return 0x82248F74;
		  /* 82248F74h */ case   11:  		/* stw R11, <#[R31 + 892]> */
		/* 82248F74h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000037C) );
		/* 82248F74h case   11:*/		return 0x82248F78;
		  /* 82248F78h */ case   12:  		/* b 12 */
		/* 82248F78h case   12:*/		return 0x82248F84;
		/* 82248F78h case   12:*/		return 0x82248F7C;
	}
	return 0x82248F7C;
} // Block from 82248F48h-82248F7Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82248F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248F7C);
		  /* 82248F7Ch */ case    0:  		/* subf R11, R17, R11 */
		/* 82248F7Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R17,regs.R11);
		/* 82248F7Ch case    0:*/		return 0x82248F80;
		  /* 82248F80h */ case    1:  		/* addi R30, R11, -1 */
		/* 82248F80h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFF);
		/* 82248F80h case    1:*/		return 0x82248F84;
	}
	return 0x82248F84;
} // Block from 82248F7Ch-82248F84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82248F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248F84);
		  /* 82248F84h */ case    0:  		/* lwz R11, <#[R29 + 892]> */
		/* 82248F84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000037C) );
		/* 82248F84h case    0:*/		return 0x82248F88;
		  /* 82248F88h */ case    1:  		/* cmpw CR6, R11, R17 */
		/* 82248F88h case    1:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R17);
		/* 82248F88h case    1:*/		return 0x82248F8C;
		  /* 82248F8Ch */ case    2:  		/* bc 12, CR6_GT, 44 */
		/* 82248F8Ch case    2:*/		if ( regs.CR[6].gt ) { return 0x82248FB8;  }
		/* 82248F8Ch case    2:*/		return 0x82248F90;
		  /* 82248F90h */ case    3:  		/* mr R3, R22 */
		/* 82248F90h case    3:*/		regs.R3 = regs.R22;
		/* 82248F90h case    3:*/		return 0x82248F94;
		  /* 82248F94h */ case    4:  		/* lwz R4, <#[R22 + 4]> */
		/* 82248F94h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x00000004) );
		/* 82248F94h case    4:*/		return 0x82248F98;
		  /* 82248F98h */ case    5:  		/* bl 43816 */
		/* 82248F98h case    5:*/		regs.LR = 0x82248F9C; return 0x82253AC0;
		/* 82248F98h case    5:*/		return 0x82248F9C;
		  /* 82248F9Ch */ case    6:  		/* stw R29, <#[R3]> */
		/* 82248F9Ch case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82248F9Ch case    6:*/		return 0x82248FA0;
		  /* 82248FA0h */ case    7:  		/* lwz R11, <#[R22 + 4]> */
		/* 82248FA0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 82248FA0h case    7:*/		return 0x82248FA4;
		  /* 82248FA4h */ case    8:  		/* addi R31, R11, -1 */
		/* 82248FA4h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFFF);
		/* 82248FA4h case    8:*/		return 0x82248FA8;
		  /* 82248FA8h */ case    9:  		/* add R11, R31, R17 */
		/* 82248FA8h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R17);
		/* 82248FA8h case    9:*/		return 0x82248FAC;
		  /* 82248FACh */ case   10:  		/* addi R11, R11, 1 */
		/* 82248FACh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82248FACh case   10:*/		return 0x82248FB0;
		  /* 82248FB0h */ case   11:  		/* stw R11, <#[R29 + 892]> */
		/* 82248FB0h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x0000037C) );
		/* 82248FB0h case   11:*/		return 0x82248FB4;
		  /* 82248FB4h */ case   12:  		/* b 12 */
		/* 82248FB4h case   12:*/		return 0x82248FC0;
		/* 82248FB4h case   12:*/		return 0x82248FB8;
	}
	return 0x82248FB8;
} // Block from 82248F84h-82248FB8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82248FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248FB8);
		  /* 82248FB8h */ case    0:  		/* subf R11, R17, R11 */
		/* 82248FB8h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R17,regs.R11);
		/* 82248FB8h case    0:*/		return 0x82248FBC;
		  /* 82248FBCh */ case    1:  		/* addi R31, R11, -1 */
		/* 82248FBCh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFFF);
		/* 82248FBCh case    1:*/		return 0x82248FC0;
	}
	return 0x82248FC0;
} // Block from 82248FB8h-82248FC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82248FC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248FC0);
		  /* 82248FC0h */ case    0:  		/* rlwinm R11, R31, 16, 0, 15 */
		/* 82248FC0h case    0:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R11,regs.R31);
		/* 82248FC0h case    0:*/		return 0x82248FC4;
		  /* 82248FC4h */ case    1:  		/* lwz R4, <#[R21 + 4]> */
		/* 82248FC4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R21 + 0x00000004) );
		/* 82248FC4h case    1:*/		return 0x82248FC8;
		  /* 82248FC8h */ case    2:  		/* mr R3, R21 */
		/* 82248FC8h case    2:*/		regs.R3 = regs.R21;
		/* 82248FC8h case    2:*/		return 0x82248FCC;
		  /* 82248FCCh */ case    3:  		/* add R29, R11, R30 */
		/* 82248FCCh case    3:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R30);
		/* 82248FCCh case    3:*/		return 0x82248FD0;
		  /* 82248FD0h */ case    4:  		/* bl 43760 */
		/* 82248FD0h case    4:*/		regs.LR = 0x82248FD4; return 0x82253AC0;
		/* 82248FD0h case    4:*/		return 0x82248FD4;
		  /* 82248FD4h */ case    5:  		/* stw R29, <#[R3]> */
		/* 82248FD4h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82248FD4h case    5:*/		return 0x82248FD8;
		  /* 82248FD8h */ case    6:  		/* lwz R11, <#[R20 + 4]> */
		/* 82248FD8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 82248FD8h case    6:*/		return 0x82248FDC;
		  /* 82248FDCh */ case    7:  		/* cmplw CR6, R31, R11 */
		/* 82248FDCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82248FDCh case    7:*/		return 0x82248FE0;
		  /* 82248FE0h */ case    8:  		/* bc 4, CR6_LT, 20 */
		/* 82248FE0h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82248FF4;  }
		/* 82248FE0h case    8:*/		return 0x82248FE4;
		  /* 82248FE4h */ case    9:  		/* lwz R11, <#[R20 + 8]> */
		/* 82248FE4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000008) );
		/* 82248FE4h case    9:*/		return 0x82248FE8;
		  /* 82248FE8h */ case   10:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82248FE8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82248FE8h case   10:*/		return 0x82248FEC;
		  /* 82248FECh */ case   11:  		/* add R3, R10, R11 */
		/* 82248FECh case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82248FECh case   11:*/		return 0x82248FF0;
		  /* 82248FF0h */ case   12:  		/* b 16 */
		/* 82248FF0h case   12:*/		return 0x82249000;
		/* 82248FF0h case   12:*/		return 0x82248FF4;
	}
	return 0x82248FF4;
} // Block from 82248FC0h-82248FF4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82248FF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82248FF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82248FF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82248FF4);
		  /* 82248FF4h */ case    0:  		/* mr R4, R31 */
		/* 82248FF4h case    0:*/		regs.R4 = regs.R31;
		/* 82248FF4h case    0:*/		return 0x82248FF8;
		  /* 82248FF8h */ case    1:  		/* mr R3, R20 */
		/* 82248FF8h case    1:*/		regs.R3 = regs.R20;
		/* 82248FF8h case    1:*/		return 0x82248FFC;
		  /* 82248FFCh */ case    2:  		/* bl 43716 */
		/* 82248FFCh case    2:*/		regs.LR = 0x82249000; return 0x82253AC0;
		/* 82248FFCh case    2:*/		return 0x82249000;
	}
	return 0x82249000;
} // Block from 82248FF4h-82249000h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249000);
		  /* 82249000h */ case    0:  		/* stw R31, <#[R3]> */
		/* 82249000h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82249000h case    0:*/		return 0x82249004;
		  /* 82249004h */ case    1:  		/* lwz R11, <#[R20 + 4]> */
		/* 82249004h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 82249004h case    1:*/		return 0x82249008;
		  /* 82249008h */ case    2:  		/* cmplw CR6, R30, R11 */
		/* 82249008h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82249008h case    2:*/		return 0x8224900C;
		  /* 8224900Ch */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 8224900Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x82249020;  }
		/* 8224900Ch case    3:*/		return 0x82249010;
		  /* 82249010h */ case    4:  		/* lwz R11, <#[R20 + 8]> */
		/* 82249010h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000008) );
		/* 82249010h case    4:*/		return 0x82249014;
		  /* 82249014h */ case    5:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 82249014h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 82249014h case    5:*/		return 0x82249018;
		  /* 82249018h */ case    6:  		/* add R3, R10, R11 */
		/* 82249018h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82249018h case    6:*/		return 0x8224901C;
		  /* 8224901Ch */ case    7:  		/* b 16 */
		/* 8224901Ch case    7:*/		return 0x8224902C;
		/* 8224901Ch case    7:*/		return 0x82249020;
	}
	return 0x82249020;
} // Block from 82249000h-82249020h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82249020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249020);
		  /* 82249020h */ case    0:  		/* mr R4, R30 */
		/* 82249020h case    0:*/		regs.R4 = regs.R30;
		/* 82249020h case    0:*/		return 0x82249024;
		  /* 82249024h */ case    1:  		/* mr R3, R20 */
		/* 82249024h case    1:*/		regs.R3 = regs.R20;
		/* 82249024h case    1:*/		return 0x82249028;
		  /* 82249028h */ case    2:  		/* bl 43672 */
		/* 82249028h case    2:*/		regs.LR = 0x8224902C; return 0x82253AC0;
		/* 82249028h case    2:*/		return 0x8224902C;
	}
	return 0x8224902C;
} // Block from 82249020h-8224902Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224902Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224902C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224902C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224902C);
		  /* 8224902Ch */ case    0:  		/* stw R30, <#[R3]> */
		/* 8224902Ch case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224902Ch case    0:*/		return 0x82249030;
		  /* 82249030h */ case    1:  		/* lwz R11, <#[R27 + 4]> */
		/* 82249030h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82249030h case    1:*/		return 0x82249034;
		  /* 82249034h */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 82249034h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82249034h case    2:*/		return 0x82249038;
		  /* 82249038h */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 82249038h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8224904C;  }
		/* 82249038h case    3:*/		return 0x8224903C;
		  /* 8224903Ch */ case    4:  		/* lwz R11, <#[R27 + 8]> */
		/* 8224903Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8224903Ch case    4:*/		return 0x82249040;
		  /* 82249040h */ case    5:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82249040h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82249040h case    5:*/		return 0x82249044;
		  /* 82249044h */ case    6:  		/* add R3, R10, R11 */
		/* 82249044h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82249044h case    6:*/		return 0x82249048;
		  /* 82249048h */ case    7:  		/* b 16 */
		/* 82249048h case    7:*/		return 0x82249058;
		/* 82249048h case    7:*/		return 0x8224904C;
	}
	return 0x8224904C;
} // Block from 8224902Ch-8224904Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224904Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224904C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224904C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224904C);
		  /* 8224904Ch */ case    0:  		/* mr R4, R31 */
		/* 8224904Ch case    0:*/		regs.R4 = regs.R31;
		/* 8224904Ch case    0:*/		return 0x82249050;
		  /* 82249050h */ case    1:  		/* mr R3, R27 */
		/* 82249050h case    1:*/		regs.R3 = regs.R27;
		/* 82249050h case    1:*/		return 0x82249054;
		  /* 82249054h */ case    2:  		/* bl 43628 */
		/* 82249054h case    2:*/		regs.LR = 0x82249058; return 0x82253AC0;
		/* 82249054h case    2:*/		return 0x82249058;
	}
	return 0x82249058;
} // Block from 8224904Ch-82249058h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249058);
		  /* 82249058h */ case    0:  		/* li R11, 1 */
		/* 82249058h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82249058h case    0:*/		return 0x8224905C;
		  /* 8224905Ch */ case    1:  		/* stb R11, <#[R3]> */
		/* 8224905Ch case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224905Ch case    1:*/		return 0x82249060;
	}
	return 0x82249060;
} // Block from 82249058h-82249060h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82249060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249060);
		  /* 82249060h */ case    0:  		/* lwz R28, <#[R28 + 8]> */
		/* 82249060h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000008) );
		/* 82249060h case    0:*/		return 0x82249064;
	}
	return 0x82249064;
} // Block from 82249060h-82249064h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249064);
		  /* 82249064h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 82249064h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82249064h case    0:*/		return 0x82249068;
		  /* 82249068h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82249068h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82249068h case    1:*/		return 0x8224906C;
		  /* 8224906Ch */ case    2:  		/* bc 4, CR6_EQ, -376 */
		/* 8224906Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82248EF4;  }
		/* 8224906Ch case    2:*/		return 0x82249070;
		  /* 82249070h */ case    3:  		/* addi R23, R23, 1 */
		/* 82249070h case    3:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 82249070h case    3:*/		return 0x82249074;
		  /* 82249074h */ case    4:  		/* addi R24, R24, 4 */
		/* 82249074h case    4:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 82249074h case    4:*/		return 0x82249078;
		  /* 82249078h */ case    5:  		/* b -460 */
		/* 82249078h case    5:*/		return 0x82248EAC;
		/* 82249078h case    5:*/		return 0x8224907C;
	}
	return 0x8224907C;
} // Block from 82249064h-8224907Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224907Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224907C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224907C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224907C);
		  /* 8224907Ch */ case    0:  		/* lwz R11, <#[R21 + 4]> */
		/* 8224907Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 8224907Ch case    0:*/		return 0x82249080;
		  /* 82249080h */ case    1:  		/* addic. R31, R11, -1 */
		/* 82249080h case    1:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFFF);
		/* 82249080h case    1:*/		return 0x82249084;
		  /* 82249084h */ case    2:  		/* bc 12, CR0_LT, 144 */
		/* 82249084h case    2:*/		if ( regs.CR[0].lt ) { return 0x82249114;  }
		/* 82249084h case    2:*/		return 0x82249088;
		  /* 82249088h */ case    3:  		/* rlwinm R29, R31, 2, 0, 29 */
		/* 82249088h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R31);
		/* 82249088h case    3:*/		return 0x8224908C;
		  /* 8224908Ch */ case    4:  		/* lwz R11, <#[R21 + 4]> */
		/* 8224908Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 8224908Ch case    4:*/		return 0x82249090;
		  /* 82249090h */ case    5:  		/* cmplw CR6, R31, R11 */
		/* 82249090h case    5:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82249090h case    5:*/		return 0x82249094;
		  /* 82249094h */ case    6:  		/* bc 4, CR6_LT, 16 */
		/* 82249094h case    6:*/		if ( !regs.CR[6].lt ) { return 0x822490A4;  }
		/* 82249094h case    6:*/		return 0x82249098;
		  /* 82249098h */ case    7:  		/* lwz R11, <#[R21 + 8]> */
		/* 82249098h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 82249098h case    7:*/		return 0x8224909C;
		  /* 8224909Ch */ case    8:  		/* add R3, R11, R29 */
		/* 8224909Ch case    8:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 8224909Ch case    8:*/		return 0x822490A0;
		  /* 822490A0h */ case    9:  		/* b 16 */
		/* 822490A0h case    9:*/		return 0x822490B0;
		/* 822490A0h case    9:*/		return 0x822490A4;
	}
	return 0x822490A4;
} // Block from 8224907Ch-822490A4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822490A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822490A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822490A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822490A4);
		  /* 822490A4h */ case    0:  		/* mr R4, R31 */
		/* 822490A4h case    0:*/		regs.R4 = regs.R31;
		/* 822490A4h case    0:*/		return 0x822490A8;
		  /* 822490A8h */ case    1:  		/* mr R3, R21 */
		/* 822490A8h case    1:*/		regs.R3 = regs.R21;
		/* 822490A8h case    1:*/		return 0x822490AC;
		  /* 822490ACh */ case    2:  		/* bl 43540 */
		/* 822490ACh case    2:*/		regs.LR = 0x822490B0; return 0x82253AC0;
		/* 822490ACh case    2:*/		return 0x822490B0;
	}
	return 0x822490B0;
} // Block from 822490A4h-822490B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822490B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822490B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822490B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822490B0);
		  /* 822490B0h */ case    0:  		/* lwz R30, <#[R3]> */
		/* 822490B0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 822490B0h case    0:*/		return 0x822490B4;
		  /* 822490B4h */ case    1:  		/* lwz R11, <#[R27 + 4]> */
		/* 822490B4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 822490B4h case    1:*/		return 0x822490B8;
		  /* 822490B8h */ case    2:  		/* rlwinm R4, R30, 0, 16, 31 */
		/* 822490B8h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R4,regs.R30);
		/* 822490B8h case    2:*/		return 0x822490BC;
		  /* 822490BCh */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 822490BCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 822490BCh case    3:*/		return 0x822490C0;
		  /* 822490C0h */ case    4:  		/* bc 4, CR6_LT, 20 */
		/* 822490C0h case    4:*/		if ( !regs.CR[6].lt ) { return 0x822490D4;  }
		/* 822490C0h case    4:*/		return 0x822490C4;
		  /* 822490C4h */ case    5:  		/* lwz R11, <#[R27 + 8]> */
		/* 822490C4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 822490C4h case    5:*/		return 0x822490C8;
		  /* 822490C8h */ case    6:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 822490C8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 822490C8h case    6:*/		return 0x822490CC;
		  /* 822490CCh */ case    7:  		/* add R3, R10, R11 */
		/* 822490CCh case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 822490CCh case    7:*/		return 0x822490D0;
		  /* 822490D0h */ case    8:  		/* b 12 */
		/* 822490D0h case    8:*/		return 0x822490DC;
		/* 822490D0h case    8:*/		return 0x822490D4;
	}
	return 0x822490D4;
} // Block from 822490B0h-822490D4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822490D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822490D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822490D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822490D4);
		  /* 822490D4h */ case    0:  		/* mr R3, R27 */
		/* 822490D4h case    0:*/		regs.R3 = regs.R27;
		/* 822490D4h case    0:*/		return 0x822490D8;
		  /* 822490D8h */ case    1:  		/* bl 43496 */
		/* 822490D8h case    1:*/		regs.LR = 0x822490DC; return 0x82253AC0;
		/* 822490D8h case    1:*/		return 0x822490DC;
	}
	return 0x822490DC;
} // Block from 822490D4h-822490DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822490DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822490DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822490DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822490DC);
		  /* 822490DCh */ case    0:  		/* lbz R11, <#[R3]> */
		/* 822490DCh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822490DCh case    0:*/		return 0x822490E0;
		  /* 822490E0h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 822490E0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 822490E0h case    1:*/		return 0x822490E4;
		  /* 822490E4h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 822490E4h case    2:*/		if ( regs.CR[6].eq ) { return 0x82249108;  }
		/* 822490E4h case    2:*/		return 0x822490E8;
		  /* 822490E8h */ case    3:  		/* mr R3, R19 */
		/* 822490E8h case    3:*/		regs.R3 = regs.R19;
		/* 822490E8h case    3:*/		return 0x822490EC;
		  /* 822490ECh */ case    4:  		/* lwz R4, <#[R19 + 4]> */
		/* 822490ECh case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R19 + 0x00000004) );
		/* 822490ECh case    4:*/		return 0x822490F0;
		  /* 822490F0h */ case    5:  		/* bl 43472 */
		/* 822490F0h case    5:*/		regs.LR = 0x822490F4; return 0x82253AC0;
		/* 822490F0h case    5:*/		return 0x822490F4;
		  /* 822490F4h */ case    6:  		/* mr R11, R3 */
		/* 822490F4h case    6:*/		regs.R11 = regs.R3;
		/* 822490F4h case    6:*/		return 0x822490F8;
		  /* 822490F8h */ case    7:  		/* mr R4, R31 */
		/* 822490F8h case    7:*/		regs.R4 = regs.R31;
		/* 822490F8h case    7:*/		return 0x822490FC;
		  /* 822490FCh */ case    8:  		/* mr R3, R21 */
		/* 822490FCh case    8:*/		regs.R3 = regs.R21;
		/* 822490FCh case    8:*/		return 0x82249100;
		  /* 82249100h */ case    9:  		/* stw R30, <#[R11]> */
		/* 82249100h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82249100h case    9:*/		return 0x82249104;
		  /* 82249104h */ case   10:  		/* bl 43260 */
		/* 82249104h case   10:*/		regs.LR = 0x82249108; return 0x82253A00;
		/* 82249104h case   10:*/		return 0x82249108;
	}
	return 0x82249108;
} // Block from 822490DCh-82249108h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82249108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249108);
		  /* 82249108h */ case    0:  		/* addic. R31, R31, -1 */
		/* 82249108h case    0:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82249108h case    0:*/		return 0x8224910C;
		  /* 8224910Ch */ case    1:  		/* addi R29, R29, -4 */
		/* 8224910Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0xFFFFFFFC);
		/* 8224910Ch case    1:*/		return 0x82249110;
		  /* 82249110h */ case    2:  		/* bc 4, CR0_LT, -132 */
		/* 82249110h case    2:*/		if ( !regs.CR[0].lt ) { return 0x8224908C;  }
		/* 82249110h case    2:*/		return 0x82249114;
	}
	return 0x82249114;
} // Block from 82249108h-82249114h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249114);
		  /* 82249114h */ case    0:  		/* lwz R11, <#[R19 + 4]> */
		/* 82249114h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82249114h case    0:*/		return 0x82249118;
	}
	return 0x82249118;
} // Block from 82249114h-82249118h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249118h
// Function '?CmpExpr@XGRAPHICS@@YAHPAX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249118);
		  /* 82249118h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82249118h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82249118h case    0:*/		return 0x8224911C;
		  /* 8224911Ch */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 8224911Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82249144;  }
		/* 8224911Ch case    1:*/		return 0x82249120;
		  /* 82249120h */ case    2:  		/* lwz R11, <#[R21 + 4]> */
		/* 82249120h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 82249120h case    2:*/		return 0x82249124;
		  /* 82249124h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82249124h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82249124h case    3:*/		return 0x82249128;
		  /* 82249128h */ case    4:  		/* bc 4, CR6_EQ, 456 */
		/* 82249128h case    4:*/		if ( !regs.CR[6].eq ) { return 0x822492F0;  }
		/* 82249128h case    4:*/		return 0x8224912C;
		  /* 8224912Ch */ case    5:  		/* lwz R10, <#[R22 + 4]> */
		/* 8224912Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000004) );
		/* 8224912Ch case    5:*/		return 0x82249130;
		  /* 82249130h */ case    6:  		/* lwz R11, <#[R16 + 2148]> */
		/* 82249130h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000864) );
		/* 82249130h case    6:*/		return 0x82249134;
		  /* 82249134h */ case    7:  		/* add R11, R11, R10 */
		/* 82249134h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82249134h case    7:*/		return 0x82249138;
		  /* 82249138h */ case    8:  		/* stw R11, <#[R16 + 2148]> */
		/* 82249138h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000864) );
		/* 82249138h case    8:*/		return 0x8224913C;
		  /* 8224913Ch */ case    9:  		/* addi R1, R1, 240 */
		/* 8224913Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 8224913Ch case    9:*/		return 0x82249140;
		  /* 82249140h */ case   10:  		/* b -1801936 */
		/* 82249140h case   10:*/		return 0x82091270;
		/* 82249140h case   10:*/		return 0x82249144;
	}
	return 0x82249144;
} // Block from 82249118h-82249144h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82249144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249144);
		  /* 82249144h */ case    0:  		/* lwz R11, <#[R19 + 4]> */
		/* 82249144h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82249144h case    0:*/		return 0x82249148;
		  /* 82249148h */ case    1:  		/* addi R31, R11, -1 */
		/* 82249148h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFFF);
		/* 82249148h case    1:*/		return 0x8224914C;
		  /* 8224914Ch */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 8224914Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8224914Ch case    2:*/		return 0x82249150;
	}
	return 0x82249150;
} // Block from 82249144h-82249150h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249150h
// Function '??ASwizzleOrMaskInfo@XGRAPHICS@@QBA?BHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249150);
		  /* 82249150h */ case    0:  		/* bc 4, CR6_LT, 20 */
		/* 82249150h case    0:*/		if ( !regs.CR[6].lt ) { return 0x82249164;  }
		/* 82249150h case    0:*/		return 0x82249154;
		  /* 82249154h */ case    1:  		/* lwz R11, <#[R19 + 8]> */
		/* 82249154h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000008) );
		/* 82249154h case    1:*/		return 0x82249158;
		  /* 82249158h */ case    2:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82249158h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82249158h case    2:*/		return 0x8224915C;
		  /* 8224915Ch */ case    3:  		/* add R3, R10, R11 */
		/* 8224915Ch case    3:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8224915Ch case    3:*/		return 0x82249160;
		  /* 82249160h */ case    4:  		/* b 16 */
		/* 82249160h case    4:*/		return 0x82249170;
		/* 82249160h case    4:*/		return 0x82249164;
	}
	return 0x82249164;
} // Block from 82249150h-82249164h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82249164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249164);
		  /* 82249164h */ case    0:  		/* mr R4, R31 */
		/* 82249164h case    0:*/		regs.R4 = regs.R31;
		/* 82249164h case    0:*/		return 0x82249168;
		  /* 82249168h */ case    1:  		/* mr R3, R19 */
		/* 82249168h case    1:*/		regs.R3 = regs.R19;
		/* 82249168h case    1:*/		return 0x8224916C;
		  /* 8224916Ch */ case    2:  		/* bl 43348 */
		/* 8224916Ch case    2:*/		regs.LR = 0x82249170; return 0x82253AC0;
		/* 8224916Ch case    2:*/		return 0x82249170;
	}
	return 0x82249170;
} // Block from 82249164h-82249170h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249170);
		  /* 82249170h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82249170h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82249170h case    0:*/		return 0x82249174;
		  /* 82249174h */ case    1:  		/* mr R4, R31 */
		/* 82249174h case    1:*/		regs.R4 = regs.R31;
		/* 82249174h case    1:*/		return 0x82249178;
		  /* 82249178h */ case    2:  		/* mr R3, R19 */
		/* 82249178h case    2:*/		regs.R3 = regs.R19;
		/* 82249178h case    2:*/		return 0x8224917C;
		  /* 8224917Ch */ case    3:  		/* srawi R28, R11, 16 */
		/* 8224917Ch case    3:*/		cpu::op::srawi<0,16>(regs,&regs.R28,regs.R11);
		/* 8224917Ch case    3:*/		return 0x82249180;
		  /* 82249180h */ case    4:  		/* rlwinm R27, R11, 0, 16, 31 */
		/* 82249180h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R27,regs.R11);
		/* 82249180h case    4:*/		return 0x82249184;
		  /* 82249184h */ case    5:  		/* bl 43132 */
		/* 82249184h case    5:*/		regs.LR = 0x82249188; return 0x82253A00;
		/* 82249184h case    5:*/		return 0x82249188;
		  /* 82249188h */ case    6:  		/* lwz R11, <#[R22 + 4]> */
		/* 82249188h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 82249188h case    6:*/		return 0x8224918C;
		  /* 8224918Ch */ case    7:  		/* cmplw CR6, R27, R11 */
		/* 8224918Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8224918Ch case    7:*/		return 0x82249190;
		  /* 82249190h */ case    8:  		/* bc 4, CR6_LT, 20 */
		/* 82249190h case    8:*/		if ( !regs.CR[6].lt ) { return 0x822491A4;  }
		/* 82249190h case    8:*/		return 0x82249194;
		  /* 82249194h */ case    9:  		/* lwz R11, <#[R22 + 8]> */
		/* 82249194h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 82249194h case    9:*/		return 0x82249198;
		  /* 82249198h */ case   10:  		/* rlwinm R10, R27, 2, 0, 29 */
		/* 82249198h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R27);
		/* 82249198h case   10:*/		return 0x8224919C;
		  /* 8224919Ch */ case   11:  		/* add R3, R10, R11 */
		/* 8224919Ch case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8224919Ch case   11:*/		return 0x822491A0;
		  /* 822491A0h */ case   12:  		/* b 16 */
		/* 822491A0h case   12:*/		return 0x822491B0;
		/* 822491A0h case   12:*/		return 0x822491A4;
	}
	return 0x822491A4;
} // Block from 82249170h-822491A4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822491A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822491A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822491A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822491A4);
		  /* 822491A4h */ case    0:  		/* mr R4, R27 */
		/* 822491A4h case    0:*/		regs.R4 = regs.R27;
		/* 822491A4h case    0:*/		return 0x822491A8;
		  /* 822491A8h */ case    1:  		/* mr R3, R22 */
		/* 822491A8h case    1:*/		regs.R3 = regs.R22;
		/* 822491A8h case    1:*/		return 0x822491AC;
		  /* 822491ACh */ case    2:  		/* bl 43284 */
		/* 822491ACh case    2:*/		regs.LR = 0x822491B0; return 0x82253AC0;
		/* 822491ACh case    2:*/		return 0x822491B0;
	}
	return 0x822491B0;
} // Block from 822491A4h-822491B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822491B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822491B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822491B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822491B0);
		  /* 822491B0h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 822491B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822491B0h case    0:*/		return 0x822491B4;
		  /* 822491B4h */ case    1:  		/* lwz R10, <#[R20 + 4]> */
		/* 822491B4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000004) );
		/* 822491B4h case    1:*/		return 0x822491B8;
		  /* 822491B8h */ case    2:  		/* cmplw CR6, R28, R10 */
		/* 822491B8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 822491B8h case    2:*/		return 0x822491BC;
		  /* 822491BCh */ case    3:  		/* lwz R29, <#[R11 + 56]> */
		/* 822491BCh case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000038) );
		/* 822491BCh case    3:*/		return 0x822491C0;
	}
	return 0x822491C0;
} // Block from 822491B0h-822491C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822491C0h
// Function '?ParmCmp@IRInst@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822491C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822491C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822491C0);
		  /* 822491C0h */ case    0:  		/* bc 4, CR6_LT, 20 */
		/* 822491C0h case    0:*/		if ( !regs.CR[6].lt ) { return 0x822491D4;  }
		/* 822491C0h case    0:*/		return 0x822491C4;
		  /* 822491C4h */ case    1:  		/* lwz R11, <#[R20 + 8]> */
		/* 822491C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000008) );
		/* 822491C4h case    1:*/		return 0x822491C8;
		  /* 822491C8h */ case    2:  		/* rlwinm R10, R28, 2, 0, 29 */
		/* 822491C8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R28);
		/* 822491C8h case    2:*/		return 0x822491CC;
		  /* 822491CCh */ case    3:  		/* add R11, R10, R11 */
		/* 822491CCh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822491CCh case    3:*/		return 0x822491D0;
		  /* 822491D0h */ case    4:  		/* b 20 */
		/* 822491D0h case    4:*/		return 0x822491E4;
		/* 822491D0h case    4:*/		return 0x822491D4;
	}
	return 0x822491D4;
} // Block from 822491C0h-822491D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822491D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822491D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822491D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822491D4);
		  /* 822491D4h */ case    0:  		/* mr R4, R28 */
		/* 822491D4h case    0:*/		regs.R4 = regs.R28;
		/* 822491D4h case    0:*/		return 0x822491D8;
		  /* 822491D8h */ case    1:  		/* mr R3, R20 */
		/* 822491D8h case    1:*/		regs.R3 = regs.R20;
		/* 822491D8h case    1:*/		return 0x822491DC;
		  /* 822491DCh */ case    2:  		/* bl 43236 */
		/* 822491DCh case    2:*/		regs.LR = 0x822491E0; return 0x82253AC0;
		/* 822491DCh case    2:*/		return 0x822491E0;
		  /* 822491E0h */ case    3:  		/* mr R11, R3 */
		/* 822491E0h case    3:*/		regs.R11 = regs.R3;
		/* 822491E0h case    3:*/		return 0x822491E4;
	}
	return 0x822491E4;
} // Block from 822491D4h-822491E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822491E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822491E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822491E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822491E4);
		  /* 822491E4h */ case    0:  		/* li R3, 49 */
		/* 822491E4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 822491E4h case    0:*/		return 0x822491E8;
		  /* 822491E8h */ case    1:  		/* lwz R4, <#[R16 + 12]> */
		/* 822491E8h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R16 + 0x0000000C) );
		/* 822491E8h case    1:*/		return 0x822491EC;
		  /* 822491ECh */ case    2:  		/* lwz R30, <#[R11]> */
		/* 822491ECh case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822491ECh case    2:*/		return 0x822491F0;
		  /* 822491F0h */ case    3:  		/* bl 52544 */
		/* 822491F0h case    3:*/		regs.LR = 0x822491F4; return 0x82255F30;
		/* 822491F0h case    3:*/		return 0x822491F4;
		  /* 822491F4h */ case    4:  		/* stw R18, <#[R3 + 80]> */
		/* 822491F4h case    4:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x00000050) );
		/* 822491F4h case    4:*/		return 0x822491F8;
		  /* 822491F8h */ case    5:  		/* stw R29, <#[R3 + 56]> */
		/* 822491F8h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000038) );
		/* 822491F8h case    5:*/		return 0x822491FC;
		  /* 822491FCh */ case    6:  		/* mr R31, R3 */
		/* 822491FCh case    6:*/		regs.R31 = regs.R3;
		/* 822491FCh case    6:*/		return 0x82249200;
		  /* 82249200h */ case    7:  		/* lwz R11, <#[R22 + 4]> */
		/* 82249200h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 82249200h case    7:*/		return 0x82249204;
		  /* 82249204h */ case    8:  		/* cmplw CR6, R30, R11 */
		/* 82249204h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82249204h case    8:*/		return 0x82249208;
		  /* 82249208h */ case    9:  		/* bc 4, CR6_LT, 20 */
		/* 82249208h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8224921C;  }
		/* 82249208h case    9:*/		return 0x8224920C;
		  /* 8224920Ch */ case   10:  		/* lwz R11, <#[R22 + 8]> */
		/* 8224920Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 8224920Ch case   10:*/		return 0x82249210;
		  /* 82249210h */ case   11:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 82249210h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 82249210h case   11:*/		return 0x82249214;
		  /* 82249214h */ case   12:  		/* add R3, R10, R11 */
		/* 82249214h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82249214h case   12:*/		return 0x82249218;
		  /* 82249218h */ case   13:  		/* b 16 */
		/* 82249218h case   13:*/		return 0x82249228;
		/* 82249218h case   13:*/		return 0x8224921C;
	}
	return 0x8224921C;
} // Block from 822491E4h-8224921Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224921Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224921C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224921C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224921C);
		  /* 8224921Ch */ case    0:  		/* mr R4, R30 */
		/* 8224921Ch case    0:*/		regs.R4 = regs.R30;
		/* 8224921Ch case    0:*/		return 0x82249220;
		  /* 82249220h */ case    1:  		/* mr R3, R22 */
		/* 82249220h case    1:*/		regs.R3 = regs.R22;
		/* 82249220h case    1:*/		return 0x82249224;
		  /* 82249224h */ case    2:  		/* bl 43164 */
		/* 82249224h case    2:*/		regs.LR = 0x82249228; return 0x82253AC0;
		/* 82249224h case    2:*/		return 0x82249228;
	}
	return 0x82249228;
} // Block from 8224921Ch-82249228h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249228h
// Function '?HashExpr@XGRAPHICS@@YAHPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249228);
		  /* 82249228h */ case    0:  		/* lwz R5, <#[R3]> */
		/* 82249228h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000000) );
		/* 82249228h case    0:*/		return 0x8224922C;
		  /* 8224922Ch */ case    1:  		/* li R4, 1 */
		/* 8224922Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224922Ch case    1:*/		return 0x82249230;
		  /* 82249230h */ case    2:  		/* mr R3, R31 */
		/* 82249230h case    2:*/		regs.R3 = regs.R31;
		/* 82249230h case    2:*/		return 0x82249234;
		  /* 82249234h */ case    3:  		/* bl -78564 */
		/* 82249234h case    3:*/		regs.LR = 0x82249238; return 0x82235F50;
		/* 82249234h case    3:*/		return 0x82249238;
		  /* 82249238h */ case    4:  		/* mr R4, R31 */
		/* 82249238h case    4:*/		regs.R4 = regs.R31;
		/* 82249238h case    4:*/		return 0x8224923C;
		  /* 8224923Ch */ case    5:  		/* mr R3, R15 */
		/* 8224923Ch case    5:*/		regs.R3 = regs.R15;
		/* 8224923Ch case    5:*/		return 0x82249240;
		  /* 82249240h */ case    6:  		/* bl 64752 */
		/* 82249240h case    6:*/		regs.LR = 0x82249244; return 0x82258F30;
		/* 82249240h case    6:*/		return 0x82249244;
		  /* 82249244h */ case    7:  		/* lwz R11, <#[R20 + 4]> */
		/* 82249244h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 82249244h case    7:*/		return 0x82249248;
		  /* 82249248h */ case    8:  		/* cmplw CR6, R28, R11 */
		/* 82249248h case    8:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82249248h case    8:*/		return 0x8224924C;
		  /* 8224924Ch */ case    9:  		/* bc 4, CR6_LT, 20 */
		/* 8224924Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x82249260;  }
		/* 8224924Ch case    9:*/		return 0x82249250;
		  /* 82249250h */ case   10:  		/* lwz R11, <#[R20 + 8]> */
		/* 82249250h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000008) );
		/* 82249250h case   10:*/		return 0x82249254;
		  /* 82249254h */ case   11:  		/* rlwinm R10, R28, 2, 0, 29 */
		/* 82249254h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R28);
		/* 82249254h case   11:*/		return 0x82249258;
		  /* 82249258h */ case   12:  		/* add R3, R10, R11 */
		/* 82249258h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82249258h case   12:*/		return 0x8224925C;
		  /* 8224925Ch */ case   13:  		/* b 16 */
		/* 8224925Ch case   13:*/		return 0x8224926C;
		/* 8224925Ch case   13:*/		return 0x82249260;
	}
	return 0x82249260;
} // Block from 82249228h-82249260h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82249260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249260);
		  /* 82249260h */ case    0:  		/* mr R4, R28 */
		/* 82249260h case    0:*/		regs.R4 = regs.R28;
		/* 82249260h case    0:*/		return 0x82249264;
		  /* 82249264h */ case    1:  		/* mr R3, R20 */
		/* 82249264h case    1:*/		regs.R3 = regs.R20;
		/* 82249264h case    1:*/		return 0x82249268;
		  /* 82249268h */ case    2:  		/* bl 43096 */
		/* 82249268h case    2:*/		regs.LR = 0x8224926C; return 0x82253AC0;
		/* 82249268h case    2:*/		return 0x8224926C;
	}
	return 0x8224926C;
} // Block from 82249260h-8224926Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224926Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224926C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224926C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224926C);
		  /* 8224926Ch */ case    0:  		/* stw R27, <#[R3]> */
		/* 8224926Ch case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8224926Ch case    0:*/		return 0x82249270;
		  /* 82249270h */ case    1:  		/* lwz R11, <#[R21 + 4]> */
		/* 82249270h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 82249270h case    1:*/		return 0x82249274;
		  /* 82249274h */ case    2:  		/* addic. R31, R11, -1 */
		/* 82249274h case    2:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFFF);
		/* 82249274h case    2:*/		return 0x82249278;
		  /* 82249278h */ case    3:  		/* bc 12, CR0_LT, 108 */
		/* 82249278h case    3:*/		if ( regs.CR[0].lt ) { return 0x822492E4;  }
		/* 82249278h case    3:*/		return 0x8224927C;
		  /* 8224927Ch */ case    4:  		/* rlwinm R29, R31, 2, 0, 29 */
		/* 8224927Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R31);
		/* 8224927Ch case    4:*/		return 0x82249280;
		  /* 82249280h */ case    5:  		/* lwz R11, <#[R21 + 4]> */
		/* 82249280h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 82249280h case    5:*/		return 0x82249284;
		  /* 82249284h */ case    6:  		/* cmplw CR6, R31, R11 */
		/* 82249284h case    6:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82249284h case    6:*/		return 0x82249288;
		  /* 82249288h */ case    7:  		/* bc 4, CR6_LT, 16 */
		/* 82249288h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82249298;  }
		/* 82249288h case    7:*/		return 0x8224928C;
		  /* 8224928Ch */ case    8:  		/* lwz R11, <#[R21 + 8]> */
		/* 8224928Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 8224928Ch case    8:*/		return 0x82249290;
	}
	return 0x82249290;
} // Block from 8224926Ch-82249290h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82249290h
// Function '?MakeRHS@CurrentValue@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249290);
		  /* 82249290h */ case    0:  		/* add R3, R11, R29 */
		/* 82249290h case    0:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 82249290h case    0:*/		return 0x82249294;
		  /* 82249294h */ case    1:  		/* b 16 */
		/* 82249294h case    1:*/		return 0x822492A4;
		/* 82249294h case    1:*/		return 0x82249298;
	}
	return 0x82249298;
} // Block from 82249290h-82249298h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82249298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249298);
		  /* 82249298h */ case    0:  		/* mr R4, R31 */
		/* 82249298h case    0:*/		regs.R4 = regs.R31;
		/* 82249298h case    0:*/		return 0x8224929C;
		  /* 8224929Ch */ case    1:  		/* mr R3, R21 */
		/* 8224929Ch case    1:*/		regs.R3 = regs.R21;
		/* 8224929Ch case    1:*/		return 0x822492A0;
		  /* 822492A0h */ case    2:  		/* bl 43040 */
		/* 822492A0h case    2:*/		regs.LR = 0x822492A4; return 0x82253AC0;
		/* 822492A0h case    2:*/		return 0x822492A4;
	}
	return 0x822492A4;
} // Block from 82249298h-822492A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822492A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822492A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822492A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822492A4);
		  /* 822492A4h */ case    0:  		/* lwz R30, <#[R3]> */
		/* 822492A4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 822492A4h case    0:*/		return 0x822492A8;
		  /* 822492A8h */ case    1:  		/* rlwinm R11, R30, 0, 16, 31 */
		/* 822492A8h case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R30);
		/* 822492A8h case    1:*/		return 0x822492AC;
		  /* 822492ACh */ case    2:  		/* cmpw CR6, R28, R11 */
		/* 822492ACh case    2:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R11);
		/* 822492ACh case    2:*/		return 0x822492B0;
		  /* 822492B0h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 822492B0h case    3:*/		if ( regs.CR[6].eq ) { return 0x822492C4;  }
		/* 822492B0h case    3:*/		return 0x822492B4;
		  /* 822492B4h */ case    4:  		/* addic. R31, R31, -1 */
		/* 822492B4h case    4:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 822492B4h case    4:*/		return 0x822492B8;
		  /* 822492B8h */ case    5:  		/* addi R29, R29, -4 */
		/* 822492B8h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0xFFFFFFFC);
		/* 822492B8h case    5:*/		return 0x822492BC;
		  /* 822492BCh */ case    6:  		/* bc 4, CR0_LT, -60 */
		/* 822492BCh case    6:*/		if ( !regs.CR[0].lt ) { return 0x82249280;  }
		/* 822492BCh case    6:*/		return 0x822492C0;
		  /* 822492C0h */ case    7:  		/* b 36 */
		/* 822492C0h case    7:*/		return 0x822492E4;
		/* 822492C0h case    7:*/		return 0x822492C4;
	}
	return 0x822492C4;
} // Block from 822492A4h-822492C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822492C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822492C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822492C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822492C4);
		  /* 822492C4h */ case    0:  		/* mr R3, R19 */
		/* 822492C4h case    0:*/		regs.R3 = regs.R19;
		/* 822492C4h case    0:*/		return 0x822492C8;
		  /* 822492C8h */ case    1:  		/* lwz R4, <#[R19 + 4]> */
		/* 822492C8h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R19 + 0x00000004) );
		/* 822492C8h case    1:*/		return 0x822492CC;
		  /* 822492CCh */ case    2:  		/* bl 42996 */
		/* 822492CCh case    2:*/		regs.LR = 0x822492D0; return 0x82253AC0;
		/* 822492CCh case    2:*/		return 0x822492D0;
		  /* 822492D0h */ case    3:  		/* mr R11, R3 */
		/* 822492D0h case    3:*/		regs.R11 = regs.R3;
		/* 822492D0h case    3:*/		return 0x822492D4;
		  /* 822492D4h */ case    4:  		/* mr R4, R31 */
		/* 822492D4h case    4:*/		regs.R4 = regs.R31;
		/* 822492D4h case    4:*/		return 0x822492D8;
		  /* 822492D8h */ case    5:  		/* mr R3, R21 */
		/* 822492D8h case    5:*/		regs.R3 = regs.R21;
		/* 822492D8h case    5:*/		return 0x822492DC;
		  /* 822492DCh */ case    6:  		/* stw R30, <#[R11]> */
		/* 822492DCh case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822492DCh case    6:*/		return 0x822492E0;
		  /* 822492E0h */ case    7:  		/* bl 42784 */
		/* 822492E0h case    7:*/		regs.LR = 0x822492E4; return 0x82253A00;
		/* 822492E0h case    7:*/		return 0x822492E4;
	}
	return 0x822492E4;
} // Block from 822492C4h-822492E4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822492E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822492E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822492E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822492E4);
		  /* 822492E4h */ case    0:  		/* lwz R11, <#[R19 + 4]> */
		/* 822492E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 822492E4h case    0:*/		return 0x822492E8;
		  /* 822492E8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 822492E8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822492E8h case    1:*/		return 0x822492EC;
		  /* 822492ECh */ case    2:  		/* bc 4, CR6_EQ, -424 */
		/* 822492ECh case    2:*/		if ( !regs.CR[6].eq ) { return 0x82249144;  }
		/* 822492ECh case    2:*/		return 0x822492F0;
	}
	return 0x822492F0;
} // Block from 822492E4h-822492F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822492F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822492F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822492F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822492F0);
		  /* 822492F0h */ case    0:  		/* lwz R11, <#[R21 + 4]> */
		/* 822492F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 822492F0h case    0:*/		return 0x822492F4;
		  /* 822492F4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 822492F4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822492F4h case    1:*/		return 0x822492F8;
		  /* 822492F8h */ case    2:  		/* bc 12, CR6_EQ, -484 */
		/* 822492F8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82249114;  }
		/* 822492F8h case    2:*/		return 0x822492FC;
		  /* 822492FCh */ case    3:  		/* addi R31, R11, -1 */
		/* 822492FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFFF);
		/* 822492FCh case    3:*/		return 0x82249300;
		  /* 82249300h */ case    4:  		/* cmplw CR6, R31, R11 */
		/* 82249300h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82249300h case    4:*/		return 0x82249304;
		  /* 82249304h */ case    5:  		/* bc 4, CR6_LT, 20 */
		/* 82249304h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82249318;  }
		/* 82249304h case    5:*/		return 0x82249308;
		  /* 82249308h */ case    6:  		/* lwz R11, <#[R21 + 8]> */
		/* 82249308h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 82249308h case    6:*/		return 0x8224930C;
		  /* 8224930Ch */ case    7:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 8224930Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 8224930Ch case    7:*/		return 0x82249310;
		  /* 82249310h */ case    8:  		/* add R3, R10, R11 */
		/* 82249310h case    8:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82249310h case    8:*/		return 0x82249314;
		  /* 82249314h */ case    9:  		/* b 16 */
		/* 82249314h case    9:*/		return 0x82249324;
		/* 82249314h case    9:*/		return 0x82249318;
	}
	return 0x82249318;
} // Block from 822492F0h-82249318h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82249318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249318);
		  /* 82249318h */ case    0:  		/* mr R4, R31 */
		/* 82249318h case    0:*/		regs.R4 = regs.R31;
		/* 82249318h case    0:*/		return 0x8224931C;
		  /* 8224931Ch */ case    1:  		/* mr R3, R21 */
		/* 8224931Ch case    1:*/		regs.R3 = regs.R21;
		/* 8224931Ch case    1:*/		return 0x82249320;
		  /* 82249320h */ case    2:  		/* bl 42912 */
		/* 82249320h case    2:*/		regs.LR = 0x82249324; return 0x82253AC0;
		/* 82249320h case    2:*/		return 0x82249324;
	}
	return 0x82249324;
} // Block from 82249318h-82249324h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249324);
		  /* 82249324h */ case    0:  		/* lwz R28, <#[R3]> */
		/* 82249324h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 82249324h case    0:*/		return 0x82249328;
		  /* 82249328h */ case    1:  		/* mr R4, R31 */
		/* 82249328h case    1:*/		regs.R4 = regs.R31;
		/* 82249328h case    1:*/		return 0x8224932C;
		  /* 8224932Ch */ case    2:  		/* mr R3, R21 */
		/* 8224932Ch case    2:*/		regs.R3 = regs.R21;
		/* 8224932Ch case    2:*/		return 0x82249330;
		  /* 82249330h */ case    3:  		/* rlwinm R29, R28, 0, 16, 31 */
		/* 82249330h case    3:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R29,regs.R28);
		/* 82249330h case    3:*/		return 0x82249334;
		  /* 82249334h */ case    4:  		/* bl 42700 */
		/* 82249334h case    4:*/		regs.LR = 0x82249338; return 0x82253A00;
		/* 82249334h case    4:*/		return 0x82249338;
		  /* 82249338h */ case    5:  		/* lwz R10, <#[R16 + 12]> */
		/* 82249338h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x0000000C) );
		/* 82249338h case    5:*/		return 0x8224933C;
		  /* 8224933Ch */ case    6:  		/* li R3, 49 */
		/* 8224933Ch case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8224933Ch case    6:*/		return 0x82249340;
		  /* 82249340h */ case    7:  		/* lwz R11, <#[R10 + 1524]> */
		/* 82249340h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005F4) );
		/* 82249340h case    7:*/		return 0x82249344;
		  /* 82249344h */ case    8:  		/* addi R30, R11, 1 */
		/* 82249344h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1);
		/* 82249344h case    8:*/		return 0x82249348;
		  /* 82249348h */ case    9:  		/* stw R30, <#[R10 + 1524]> */
		/* 82249348h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x000005F4) );
		/* 82249348h case    9:*/		return 0x8224934C;
		  /* 8224934Ch */ case   10:  		/* lwz R4, <#[R16 + 12]> */
		/* 8224934Ch case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R16 + 0x0000000C) );
		/* 8224934Ch case   10:*/		return 0x82249350;
		  /* 82249350h */ case   11:  		/* bl 52192 */
		/* 82249350h case   11:*/		regs.LR = 0x82249354; return 0x82255F30;
		/* 82249350h case   11:*/		return 0x82249354;
		  /* 82249354h */ case   12:  		/* stw R30, <#[R3 + 56]> */
		/* 82249354h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000038) );
		/* 82249354h case   12:*/		return 0x82249358;
		  /* 82249358h */ case   13:  		/* stw R18, <#[R3 + 80]> */
		/* 82249358h case   13:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x00000050) );
		/* 82249358h case   13:*/		return 0x8224935C;
		  /* 8224935Ch */ case   14:  		/* mr R31, R3 */
		/* 8224935Ch case   14:*/		regs.R31 = regs.R3;
		/* 8224935Ch case   14:*/		return 0x82249360;
		  /* 82249360h */ case   15:  		/* lwz R11, <#[R22 + 4]> */
		/* 82249360h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 82249360h case   15:*/		return 0x82249364;
		  /* 82249364h */ case   16:  		/* cmplw CR6, R29, R11 */
		/* 82249364h case   16:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82249364h case   16:*/		return 0x82249368;
		  /* 82249368h */ case   17:  		/* bc 4, CR6_LT, 20 */
		/* 82249368h case   17:*/		if ( !regs.CR[6].lt ) { return 0x8224937C;  }
		/* 82249368h case   17:*/		return 0x8224936C;
		  /* 8224936Ch */ case   18:  		/* lwz R11, <#[R22 + 8]> */
		/* 8224936Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 8224936Ch case   18:*/		return 0x82249370;
		  /* 82249370h */ case   19:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 82249370h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 82249370h case   19:*/		return 0x82249374;
		  /* 82249374h */ case   20:  		/* add R3, R10, R11 */
		/* 82249374h case   20:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82249374h case   20:*/		return 0x82249378;
		  /* 82249378h */ case   21:  		/* b 16 */
		/* 82249378h case   21:*/		return 0x82249388;
		/* 82249378h case   21:*/		return 0x8224937C;
	}
	return 0x8224937C;
} // Block from 82249324h-8224937Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 8224937Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224937C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224937C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224937C);
		  /* 8224937Ch */ case    0:  		/* mr R4, R29 */
		/* 8224937Ch case    0:*/		regs.R4 = regs.R29;
		/* 8224937Ch case    0:*/		return 0x82249380;
		  /* 82249380h */ case    1:  		/* mr R3, R22 */
		/* 82249380h case    1:*/		regs.R3 = regs.R22;
		/* 82249380h case    1:*/		return 0x82249384;
		  /* 82249384h */ case    2:  		/* bl 42812 */
		/* 82249384h case    2:*/		regs.LR = 0x82249388; return 0x82253AC0;
		/* 82249384h case    2:*/		return 0x82249388;
	}
	return 0x82249388;
} // Block from 8224937Ch-82249388h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249388);
		  /* 82249388h */ case    0:  		/* lwz R5, <#[R3]> */
		/* 82249388h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000000) );
		/* 82249388h case    0:*/		return 0x8224938C;
		  /* 8224938Ch */ case    1:  		/* li R4, 1 */
		/* 8224938Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224938Ch case    1:*/		return 0x82249390;
		  /* 82249390h */ case    2:  		/* mr R3, R31 */
		/* 82249390h case    2:*/		regs.R3 = regs.R31;
		/* 82249390h case    2:*/		return 0x82249394;
		  /* 82249394h */ case    3:  		/* bl -78916 */
		/* 82249394h case    3:*/		regs.LR = 0x82249398; return 0x82235F50;
		/* 82249394h case    3:*/		return 0x82249398;
		  /* 82249398h */ case    4:  		/* mr R4, R31 */
		/* 82249398h case    4:*/		regs.R4 = regs.R31;
		/* 82249398h case    4:*/		return 0x8224939C;
		  /* 8224939Ch */ case    5:  		/* mr R3, R15 */
		/* 8224939Ch case    5:*/		regs.R3 = regs.R15;
		/* 8224939Ch case    5:*/		return 0x822493A0;
		  /* 822493A0h */ case    6:  		/* bl 64400 */
		/* 822493A0h case    6:*/		regs.LR = 0x822493A4; return 0x82258F30;
		/* 822493A0h case    6:*/		return 0x822493A4;
		  /* 822493A4h */ case    7:  		/* lwz R11, <#[R31 + 892]> */
		/* 822493A4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000037C) );
		/* 822493A4h case    7:*/		return 0x822493A8;
		  /* 822493A8h */ case    8:  		/* cmpw CR6, R11, R17 */
		/* 822493A8h case    8:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R17);
		/* 822493A8h case    8:*/		return 0x822493AC;
		  /* 822493ACh */ case    9:  		/* bc 12, CR6_GT, 44 */
		/* 822493ACh case    9:*/		if ( regs.CR[6].gt ) { return 0x822493D8;  }
		/* 822493ACh case    9:*/		return 0x822493B0;
		  /* 822493B0h */ case   10:  		/* mr R3, R22 */
		/* 822493B0h case   10:*/		regs.R3 = regs.R22;
		/* 822493B0h case   10:*/		return 0x822493B4;
		  /* 822493B4h */ case   11:  		/* lwz R4, <#[R22 + 4]> */
		/* 822493B4h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x00000004) );
		/* 822493B4h case   11:*/		return 0x822493B8;
		  /* 822493B8h */ case   12:  		/* bl 42760 */
		/* 822493B8h case   12:*/		regs.LR = 0x822493BC; return 0x82253AC0;
		/* 822493B8h case   12:*/		return 0x822493BC;
		  /* 822493BCh */ case   13:  		/* stw R31, <#[R3]> */
		/* 822493BCh case   13:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 822493BCh case   13:*/		return 0x822493C0;
		  /* 822493C0h */ case   14:  		/* lwz R11, <#[R22 + 4]> */
		/* 822493C0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 822493C0h case   14:*/		return 0x822493C4;
		  /* 822493C4h */ case   15:  		/* addi R30, R11, -1 */
		/* 822493C4h case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFF);
		/* 822493C4h case   15:*/		return 0x822493C8;
		  /* 822493C8h */ case   16:  		/* add R11, R30, R17 */
		/* 822493C8h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R17);
		/* 822493C8h case   16:*/		return 0x822493CC;
		  /* 822493CCh */ case   17:  		/* addi R11, R11, 1 */
		/* 822493CCh case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822493CCh case   17:*/		return 0x822493D0;
		  /* 822493D0h */ case   18:  		/* stw R11, <#[R31 + 892]> */
		/* 822493D0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000037C) );
		/* 822493D0h case   18:*/		return 0x822493D4;
		  /* 822493D4h */ case   19:  		/* b 12 */
		/* 822493D4h case   19:*/		return 0x822493E0;
		/* 822493D4h case   19:*/		return 0x822493D8;
	}
	return 0x822493D8;
} // Block from 82249388h-822493D8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822493D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822493D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822493D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822493D8);
		  /* 822493D8h */ case    0:  		/* subf R11, R17, R11 */
		/* 822493D8h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R17,regs.R11);
		/* 822493D8h case    0:*/		return 0x822493DC;
		  /* 822493DCh */ case    1:  		/* addi R30, R11, -1 */
		/* 822493DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFF);
		/* 822493DCh case    1:*/		return 0x822493E0;
	}
	return 0x822493E0;
} // Block from 822493D8h-822493E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822493E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822493E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822493E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822493E0);
		  /* 822493E0h */ case    0:  		/* lwz R11, <#[R20 + 4]> */
		/* 822493E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 822493E0h case    0:*/		return 0x822493E4;
		  /* 822493E4h */ case    1:  		/* cmplw CR6, R29, R11 */
		/* 822493E4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 822493E4h case    1:*/		return 0x822493E8;
		  /* 822493E8h */ case    2:  		/* bc 4, CR6_LT, 20 */
		/* 822493E8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x822493FC;  }
		/* 822493E8h case    2:*/		return 0x822493EC;
		  /* 822493ECh */ case    3:  		/* lwz R10, <#[R20 + 8]> */
		/* 822493ECh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000008) );
		/* 822493ECh case    3:*/		return 0x822493F0;
		  /* 822493F0h */ case    4:  		/* rlwinm R11, R29, 2, 0, 29 */
		/* 822493F0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R29);
		/* 822493F0h case    4:*/		return 0x822493F4;
		  /* 822493F4h */ case    5:  		/* add R3, R11, R10 */
		/* 822493F4h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 822493F4h case    5:*/		return 0x822493F8;
		  /* 822493F8h */ case    6:  		/* b 16 */
		/* 822493F8h case    6:*/		return 0x82249408;
		/* 822493F8h case    6:*/		return 0x822493FC;
	}
	return 0x822493FC;
} // Block from 822493E0h-822493FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 822493FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822493FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822493FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822493FC);
		  /* 822493FCh */ case    0:  		/* mr R4, R29 */
		/* 822493FCh case    0:*/		regs.R4 = regs.R29;
		/* 822493FCh case    0:*/		return 0x82249400;
		  /* 82249400h */ case    1:  		/* mr R3, R20 */
		/* 82249400h case    1:*/		regs.R3 = regs.R20;
		/* 82249400h case    1:*/		return 0x82249404;
		  /* 82249404h */ case    2:  		/* bl 42684 */
		/* 82249404h case    2:*/		regs.LR = 0x82249408; return 0x82253AC0;
		/* 82249404h case    2:*/		return 0x82249408;
	}
	return 0x82249408;
} // Block from 822493FCh-82249408h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249408);
		  /* 82249408h */ case    0:  		/* stw R30, <#[R3]> */
		/* 82249408h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82249408h case    0:*/		return 0x8224940C;
		  /* 8224940Ch */ case    1:  		/* mr R3, R19 */
		/* 8224940Ch case    1:*/		regs.R3 = regs.R19;
		/* 8224940Ch case    1:*/		return 0x82249410;
		  /* 82249410h */ case    2:  		/* lwz R4, <#[R19 + 4]> */
		/* 82249410h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R19 + 0x00000004) );
		/* 82249410h case    2:*/		return 0x82249414;
		  /* 82249414h */ case    3:  		/* bl 42668 */
		/* 82249414h case    3:*/		regs.LR = 0x82249418; return 0x82253AC0;
		/* 82249414h case    3:*/		return 0x82249418;
		  /* 82249418h */ case    4:  		/* stw R28, <#[R3]> */
		/* 82249418h case    4:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 82249418h case    4:*/		return 0x8224941C;
		  /* 8224941Ch */ case    5:  		/* lwz R11, <#[R14]> */
		/* 8224941Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 8224941Ch case    5:*/		return 0x82249420;
		  /* 82249420h */ case    6:  		/* addi R11, R11, 1 */
		/* 82249420h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82249420h case    6:*/		return 0x82249424;
		  /* 82249424h */ case    7:  		/* stw R11, <#[R14]> */
		/* 82249424h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 82249424h case    7:*/		return 0x82249428;
		  /* 82249428h */ case    8:  		/* b -788 */
		/* 82249428h case    8:*/		return 0x82249114;
		/* 82249428h case    8:*/		return 0x8224942C;
		  /* 8224942Ch */ case    9:  		/* nop */
		/* 8224942Ch case    9:*/		cpu::op::nop();
		/* 8224942Ch case    9:*/		return 0x82249430;
	}
	return 0x82249430;
} // Block from 82249408h-82249430h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82249430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249430);
		  /* 82249430h */ case    0:  		/* mfspr R12, LR */
		/* 82249430h case    0:*/		regs.R12 = regs.LR;
		/* 82249430h case    0:*/		return 0x82249434;
		  /* 82249434h */ case    1:  		/* bl -1802716 */
		/* 82249434h case    1:*/		regs.LR = 0x82249438; return 0x82091258;
		/* 82249434h case    1:*/		return 0x82249438;
		  /* 82249438h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82249438h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82249438h case    2:*/		return 0x8224943C;
		  /* 8224943Ch */ case    3:  		/* lwz R28, <#[R3 + 136]> */
		/* 8224943Ch case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000088) );
		/* 8224943Ch case    3:*/		return 0x82249440;
		  /* 82249440h */ case    4:  		/* b 108 */
		/* 82249440h case    4:*/		return 0x822494AC;
		/* 82249440h case    4:*/		return 0x82249444;
		  /* 82249444h */ case    5:  		/* mr R3, R28 */
		/* 82249444h case    5:*/		regs.R3 = regs.R28;
		/* 82249444h case    5:*/		return 0x82249448;
		  /* 82249448h */ case    6:  		/* bl 65608 */
		/* 82249448h case    6:*/		regs.LR = 0x8224944C; return 0x82259490;
		/* 82249448h case    6:*/		return 0x8224944C;
		  /* 8224944Ch */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224944Ch case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224944Ch case    7:*/		return 0x82249450;
		  /* 82249450h */ case    8:  		/* bc 12, CR0_EQ, 88 */
		/* 82249450h case    8:*/		if ( regs.CR[0].eq ) { return 0x822494A8;  }
		/* 82249450h case    8:*/		return 0x82249454;
		  /* 82249454h */ case    9:  		/* li R29, 0 */
		/* 82249454h case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82249454h case    9:*/		return 0x82249458;
		  /* 82249458h */ case   10:  		/* li R31, 0 */
		/* 82249458h case   10:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82249458h case   10:*/		return 0x8224945C;
		  /* 8224945Ch */ case   11:  		/* li R30, 1 */
		/* 8224945Ch case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8224945Ch case   11:*/		return 0x82249460;
		  /* 82249460h */ case   12:  		/* lwz R11, <#[R28 + 60]> */
		/* 82249460h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000003C) );
		/* 82249460h case   12:*/		return 0x82249464;
		  /* 82249464h */ case   13:  		/* lwz R10, <#[R11 + 4]> */
		/* 82249464h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82249464h case   13:*/		return 0x82249468;
		  /* 82249468h */ case   14:  		/* cmplw CR6, R30, R10 */
		/* 82249468h case   14:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 82249468h case   14:*/		return 0x8224946C;
		  /* 8224946Ch */ case   15:  		/* bc 4, CR6_GT, 12 */
		/* 8224946Ch case   15:*/		if ( !regs.CR[6].gt ) { return 0x82249478;  }
		/* 8224946Ch case   15:*/		return 0x82249470;
		  /* 82249470h */ case   16:  		/* li R11, 0 */
		/* 82249470h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82249470h case   16:*/		return 0x82249474;
		  /* 82249474h */ case   17:  		/* b 16 */
		/* 82249474h case   17:*/		return 0x82249484;
		/* 82249474h case   17:*/		return 0x82249478;
	}
	return 0x82249478;
} // Block from 82249430h-82249478h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82249478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249478);
		  /* 82249478h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82249478h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82249478h case    0:*/		return 0x8224947C;
		  /* 8224947Ch */ case    1:  		/* li R11, 1 */
		/* 8224947Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224947Ch case    1:*/		return 0x82249480;
		  /* 82249480h */ case    2:  		/* lwzx R29, <#[R10 + R31]> */
		/* 82249480h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82249480h case    2:*/		return 0x82249484;
	}
	return 0x82249484;
} // Block from 82249478h-82249484h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249484);
		  /* 82249484h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82249484h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82249484h case    0:*/		return 0x82249488;
		  /* 82249488h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 82249488h case    1:*/		if ( regs.CR[0].eq ) { return 0x822494A8;  }
		/* 82249488h case    1:*/		return 0x8224948C;
		  /* 8224948Ch */ case    2:  		/* mr R3, R29 */
		/* 8224948Ch case    2:*/		regs.R3 = regs.R29;
		/* 8224948Ch case    2:*/		return 0x82249490;
		  /* 82249490h */ case    3:  		/* bl 65512 */
		/* 82249490h case    3:*/		regs.LR = 0x82249494; return 0x82259478;
		/* 82249490h case    3:*/		return 0x82249494;
		  /* 82249494h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82249494h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82249494h case    4:*/		return 0x82249498;
		  /* 82249498h */ case    5:  		/* bc 4, CR0_EQ, 44 */
		/* 82249498h case    5:*/		if ( !regs.CR[0].eq ) { return 0x822494C4;  }
		/* 82249498h case    5:*/		return 0x8224949C;
		  /* 8224949Ch */ case    6:  		/* addi R30, R30, 1 */
		/* 8224949Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224949Ch case    6:*/		return 0x822494A0;
		  /* 822494A0h */ case    7:  		/* addi R31, R31, 4 */
		/* 822494A0h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 822494A0h case    7:*/		return 0x822494A4;
		  /* 822494A4h */ case    8:  		/* b -68 */
		/* 822494A4h case    8:*/		return 0x82249460;
		/* 822494A4h case    8:*/		return 0x822494A8;
	}
	return 0x822494A8;
} // Block from 82249484h-822494A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822494A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822494A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822494A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822494A8);
		  /* 822494A8h */ case    0:  		/* lwz R28, <#[R28 + 8]> */
		/* 822494A8h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000008) );
		/* 822494A8h case    0:*/		return 0x822494AC;
	}
	return 0x822494AC;
} // Block from 822494A8h-822494ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822494ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822494AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822494AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822494AC);
		  /* 822494ACh */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 822494ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 822494ACh case    0:*/		return 0x822494B0;
		  /* 822494B0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 822494B0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822494B0h case    1:*/		return 0x822494B4;
		  /* 822494B4h */ case    2:  		/* bc 4, CR6_EQ, -112 */
		/* 822494B4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82249444;  }
		/* 822494B4h case    2:*/		return 0x822494B8;
		  /* 822494B8h */ case    3:  		/* li R3, 1 */
		/* 822494B8h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822494B8h case    3:*/		return 0x822494BC;
		  /* 822494BCh */ case    4:  		/* addi R1, R1, 128 */
		/* 822494BCh case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822494BCh case    4:*/		return 0x822494C0;
		  /* 822494C0h */ case    5:  		/* b -1802776 */
		/* 822494C0h case    5:*/		return 0x820912A8;
		/* 822494C0h case    5:*/		return 0x822494C4;
	}
	return 0x822494C4;
} // Block from 822494ACh-822494C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822494C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822494C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822494C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822494C4);
		  /* 822494C4h */ case    0:  		/* li R3, 0 */
		/* 822494C4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822494C4h case    0:*/		return 0x822494C8;
		  /* 822494C8h */ case    1:  		/* b -12 */
		/* 822494C8h case    1:*/		return 0x822494BC;
		/* 822494C8h case    1:*/		return 0x822494CC;
		  /* 822494CCh */ case    2:  		/* nop */
		/* 822494CCh case    2:*/		cpu::op::nop();
		/* 822494CCh case    2:*/		return 0x822494D0;
	}
	return 0x822494D0;
} // Block from 822494C4h-822494D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822494D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822494D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822494D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822494D0);
		  /* 822494D0h */ case    0:  		/* mfspr R12, LR */
		/* 822494D0h case    0:*/		regs.R12 = regs.LR;
		/* 822494D0h case    0:*/		return 0x822494D4;
		  /* 822494D4h */ case    1:  		/* bl -1802932 */
		/* 822494D4h case    1:*/		regs.LR = 0x822494D8; return 0x82091220;
		/* 822494D4h case    1:*/		return 0x822494D8;
		  /* 822494D8h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 822494D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 822494D8h case    2:*/		return 0x822494DC;
		  /* 822494DCh */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 822494DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 822494DCh case    3:*/		return 0x822494E0;
		  /* 822494E0h */ case    4:  		/* mr R16, R3 */
		/* 822494E0h case    4:*/		regs.R16 = regs.R3;
		/* 822494E0h case    4:*/		return 0x822494E4;
		  /* 822494E4h */ case    5:  		/* li R3, 1024 */
		/* 822494E4h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x400);
		/* 822494E4h case    5:*/		return 0x822494E8;
		  /* 822494E8h */ case    6:  		/* lwz R4, <#[R11 + 1452]> */
		/* 822494E8h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 822494E8h case    6:*/		return 0x822494EC;
		  /* 822494ECh */ case    7:  		/* bl -76716 */
		/* 822494ECh case    7:*/		regs.LR = 0x822494F0; return 0x82236940;
		/* 822494ECh case    7:*/		return 0x822494F0;
		  /* 822494F0h */ case    8:  		/* lwz R11, <#[R16 + 12]> */
		/* 822494F0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x0000000C) );
		/* 822494F0h case    8:*/		return 0x822494F4;
		  /* 822494F4h */ case    9:  		/* mr R21, R3 */
		/* 822494F4h case    9:*/		regs.R21 = regs.R3;
		/* 822494F4h case    9:*/		return 0x822494F8;
		  /* 822494F8h */ case   10:  		/* li R3, 1024 */
		/* 822494F8h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x400);
		/* 822494F8h case   10:*/		return 0x822494FC;
		  /* 822494FCh */ case   11:  		/* lwz R4, <#[R11 + 1452]> */
		/* 822494FCh case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 822494FCh case   11:*/		return 0x82249500;
		  /* 82249500h */ case   12:  		/* bl -76736 */
		/* 82249500h case   12:*/		regs.LR = 0x82249504; return 0x82236940;
		/* 82249500h case   12:*/		return 0x82249504;
		  /* 82249504h */ case   13:  		/* lwz R11, <#[R16 + 172]> */
		/* 82249504h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x000000AC) );
		/* 82249504h case   13:*/		return 0x82249508;
		  /* 82249508h */ case   14:  		/* mr R17, R3 */
		/* 82249508h case   14:*/		regs.R17 = regs.R3;
		/* 82249508h case   14:*/		return 0x8224950C;
		  /* 8224950Ch */ case   15:  		/* addi R3, R1, 96 */
		/* 8224950Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8224950Ch case   15:*/		return 0x82249510;
		  /* 82249510h */ case   16:  		/* lwz R4, <#[R11 + 4]> */
		/* 82249510h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 82249510h case   16:*/		return 0x82249514;
		  /* 82249514h */ case   17:  		/* bl 44020 */
		/* 82249514h case   17:*/		regs.LR = 0x82249518; return 0x82254108;
		/* 82249514h case   17:*/		return 0x82249518;
		  /* 82249518h */ case   18:  		/* lwz R3, <#[R1 + 112]> */
		/* 82249518h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 82249518h case   18:*/		return 0x8224951C;
		  /* 8224951Ch */ case   19:  		/* cmplwi CR6, R3, 0 */
		/* 8224951Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8224951Ch case   19:*/		return 0x82249520;
		  /* 82249520h */ case   20:  		/* mr R18, R3 */
		/* 82249520h case   20:*/		regs.R18 = regs.R3;
		/* 82249520h case   20:*/		return 0x82249524;
		  /* 82249524h */ case   21:  		/* stw R3, <#[R1 + 116]> */
		/* 82249524h case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000074) );
		/* 82249524h case   21:*/		return 0x82249528;
		  /* 82249528h */ case   22:  		/* bc 12, CR6_EQ, 716 */
		/* 82249528h case   22:*/		if ( regs.CR[6].eq ) { return 0x822497F4;  }
		/* 82249528h case   22:*/		return 0x8224952C;
		  /* 8224952Ch */ case   23:  		/* lis R9, -32252 */
		/* 8224952Ch case   23:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8224952Ch case   23:*/		return 0x82249530;
		  /* 82249530h */ case   24:  		/* lis R11, -32253 */
		/* 82249530h case   24:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82249530h case   24:*/		return 0x82249534;
		  /* 82249534h */ case   25:  		/* lis R10, -32252 */
		/* 82249534h case   25:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82249534h case   25:*/		return 0x82249538;
		  /* 82249538h */ case   26:  		/* addi R9, R9, 13424 */
		/* 82249538h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x3470);
		/* 82249538h case   26:*/		return 0x8224953C;
		  /* 8224953Ch */ case   27:  		/* li R19, 0 */
		/* 8224953Ch case   27:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8224953Ch case   27:*/		return 0x82249540;
		  /* 82249540h */ case   28:  		/* li R20, 1 */
		/* 82249540h case   28:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 82249540h case   28:*/		return 0x82249544;
		  /* 82249544h */ case   29:  		/* stw R9, <#[R1 + 80]> */
		/* 82249544h case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82249544h case   29:*/		return 0x82249548;
		  /* 82249548h */ case   30:  		/* addi R15, R11, 27460 */
		/* 82249548h case   30:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R11,0x6B44);
		/* 82249548h case   30:*/		return 0x8224954C;
		  /* 8224954Ch */ case   31:  		/* addi R14, R10, 13564 */
		/* 8224954Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R10,0x34FC);
		/* 8224954Ch case   31:*/		return 0x82249550;
		  /* 82249550h */ case   32:  		/* lwz R11, <#[R3]> */
		/* 82249550h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82249550h case   32:*/		return 0x82249554;
		  /* 82249554h */ case   33:  		/* lwz R11, <#[R11 + 16]> */
		/* 82249554h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82249554h case   33:*/		return 0x82249558;
		  /* 82249558h */ case   34:  		/* mtspr CTR, R11 */
		/* 82249558h case   34:*/		regs.CTR = regs.R11;
		/* 82249558h case   34:*/		return 0x8224955C;
		  /* 8224955Ch */ case   35:  		/* bcctrl 20, CR0_LT */
		/* 8224955Ch case   35:*/		if ( 1 ) { regs.LR = 0x82249560; return (uint32)regs.CTR; }
		/* 8224955Ch case   35:*/		return 0x82249560;
		  /* 82249560h */ case   36:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82249560h case   36:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82249560h case   36:*/		return 0x82249564;
		  /* 82249564h */ case   37:  		/* bc 12, CR0_EQ, 628 */
		/* 82249564h case   37:*/		if ( regs.CR[0].eq ) { return 0x822497D8;  }
		/* 82249564h case   37:*/		return 0x82249568;
		  /* 82249568h */ case   38:  		/* lwz R10, <#[R18 + 48]> */
		/* 82249568h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000030) );
		/* 82249568h case   38:*/		return 0x8224956C;
		  /* 8224956Ch */ case   39:  		/* lwz R9, <#[R16 + 176]> */
		/* 8224956Ch case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R16 + 0x000000B0) );
		/* 8224956Ch case   39:*/		return 0x82249570;
		  /* 82249570h */ case   40:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 82249570h case   40:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 82249570h case   40:*/		return 0x82249574;
		  /* 82249574h */ case   41:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 82249574h case   41:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 82249574h case   41:*/		return 0x82249578;
		  /* 82249578h */ case   42:  		/* addi R11, R11, 2 */
		/* 82249578h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82249578h case   42:*/		return 0x8224957C;
		  /* 8224957Ch */ case   43:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224957Ch case   43:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224957Ch case   43:*/		return 0x82249580;
		  /* 82249580h */ case   44:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82249580h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82249580h case   44:*/		return 0x82249584;
		  /* 82249584h */ case   45:  		/* srw R11, R11, R10 */
		/* 82249584h case   45:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82249584h case   45:*/		return 0x82249588;
		  /* 82249588h */ case   46:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82249588h case   46:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82249588h case   46:*/		return 0x8224958C;
		  /* 8224958Ch */ case   47:  		/* bc 12, CR0_EQ, 588 */
		/* 8224958Ch case   47:*/		if ( regs.CR[0].eq ) { return 0x822497D8;  }
		/* 8224958Ch case   47:*/		return 0x82249590;
		  /* 82249590h */ case   48:  		/* lwz R10, <#[R17]> */
		/* 82249590h case   48:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000000) );
		/* 82249590h case   48:*/		return 0x82249594;
		  /* 82249594h */ case   49:  		/* mr R11, R19 */
		/* 82249594h case   49:*/		regs.R11 = regs.R19;
		/* 82249594h case   49:*/		return 0x82249598;
		  /* 82249598h */ case   50:  		/* cmplwi CR6, R10, 0 */
		/* 82249598h case   50:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82249598h case   50:*/		return 0x8224959C;
		  /* 8224959Ch */ case   51:  		/* bc 4, CR6_GT, 28 */
		/* 8224959Ch case   51:*/		if ( !regs.CR[6].gt ) { return 0x822495B8;  }
		/* 8224959Ch case   51:*/		return 0x822495A0;
		  /* 822495A0h */ case   52:  		/* addi R10, R17, 4 */
		/* 822495A0h case   52:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R17,0x4);
		/* 822495A0h case   52:*/		return 0x822495A4;
		  /* 822495A4h */ case   53:  		/* addi R11, R11, 1 */
		/* 822495A4h case   53:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822495A4h case   53:*/		return 0x822495A8;
		  /* 822495A8h */ case   54:  		/* stwu R19, <#[R10 + 4]> */
		/* 822495A8h case   54:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 822495A8h case   54:*/		return 0x822495AC;
		  /* 822495ACh */ case   55:  		/* lwz R9, <#[R17]> */
		/* 822495ACh case   55:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000000) );
		/* 822495ACh case   55:*/		return 0x822495B0;
		  /* 822495B0h */ case   56:  		/* cmplw CR6, R11, R9 */
		/* 822495B0h case   56:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 822495B0h case   56:*/		return 0x822495B4;
		  /* 822495B4h */ case   57:  		/* bc 12, CR6_LT, -16 */
		/* 822495B4h case   57:*/		if ( regs.CR[6].lt ) { return 0x822495A4;  }
		/* 822495B4h case   57:*/		return 0x822495B8;
	}
	return 0x822495B8;
} // Block from 822494D0h-822495B8h (58 instructions)

//////////////////////////////////////////////////////
// Block at 822495B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822495B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822495B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822495B8);
		  /* 822495B8h */ case    0:  		/* lwz R10, <#[R21]> */
		/* 822495B8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000000) );
		/* 822495B8h case    0:*/		return 0x822495BC;
		  /* 822495BCh */ case    1:  		/* mr R11, R19 */
		/* 822495BCh case    1:*/		regs.R11 = regs.R19;
		/* 822495BCh case    1:*/		return 0x822495C0;
		  /* 822495C0h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 822495C0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 822495C0h case    2:*/		return 0x822495C4;
		  /* 822495C4h */ case    3:  		/* bc 4, CR6_GT, 28 */
		/* 822495C4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x822495E0;  }
		/* 822495C4h case    3:*/		return 0x822495C8;
		  /* 822495C8h */ case    4:  		/* addi R10, R21, 4 */
		/* 822495C8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R21,0x4);
		/* 822495C8h case    4:*/		return 0x822495CC;
		  /* 822495CCh */ case    5:  		/* stwu R19, <#[R10 + 4]> */
		/* 822495CCh case    5:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 822495CCh case    5:*/		return 0x822495D0;
		  /* 822495D0h */ case    6:  		/* addi R11, R11, 1 */
		/* 822495D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822495D0h case    6:*/		return 0x822495D4;
		  /* 822495D4h */ case    7:  		/* lwz R9, <#[R21]> */
		/* 822495D4h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R21 + 0x00000000) );
		/* 822495D4h case    7:*/		return 0x822495D8;
		  /* 822495D8h */ case    8:  		/* cmplw CR6, R11, R9 */
		/* 822495D8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 822495D8h case    8:*/		return 0x822495DC;
		  /* 822495DCh */ case    9:  		/* bc 12, CR6_LT, -16 */
		/* 822495DCh case    9:*/		if ( regs.CR[6].lt ) { return 0x822495CC;  }
		/* 822495DCh case    9:*/		return 0x822495E0;
	}
	return 0x822495E0;
} // Block from 822495B8h-822495E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822495E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822495E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822495E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822495E0);
		  /* 822495E0h */ case    0:  		/* mr R10, R19 */
		/* 822495E0h case    0:*/		regs.R10 = regs.R19;
		/* 822495E0h case    0:*/		return 0x822495E4;
		  /* 822495E4h */ case    1:  		/* mr R9, R19 */
		/* 822495E4h case    1:*/		regs.R9 = regs.R19;
		/* 822495E4h case    1:*/		return 0x822495E8;
		  /* 822495E8h */ case    2:  		/* mr R8, R20 */
		/* 822495E8h case    2:*/		regs.R8 = regs.R20;
		/* 822495E8h case    2:*/		return 0x822495EC;
		  /* 822495ECh */ case    3:  		/* lwz R11, <#[R18 + 40]> */
		/* 822495ECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000028) );
		/* 822495ECh case    3:*/		return 0x822495F0;
		  /* 822495F0h */ case    4:  		/* lwz R7, <#[R11 + 4]> */
		/* 822495F0h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 822495F0h case    4:*/		return 0x822495F4;
		  /* 822495F4h */ case    5:  		/* cmplw CR6, R8, R7 */
		/* 822495F4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 822495F4h case    5:*/		return 0x822495F8;
		  /* 822495F8h */ case    6:  		/* bc 4, CR6_GT, 12 */
		/* 822495F8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82249604;  }
		/* 822495F8h case    6:*/		return 0x822495FC;
		  /* 822495FCh */ case    7:  		/* mr R11, R19 */
		/* 822495FCh case    7:*/		regs.R11 = regs.R19;
		/* 822495FCh case    7:*/		return 0x82249600;
		  /* 82249600h */ case    8:  		/* b 16 */
		/* 82249600h case    8:*/		return 0x82249610;
		/* 82249600h case    8:*/		return 0x82249604;
	}
	return 0x82249604;
} // Block from 822495E0h-82249604h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82249604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249604);
		  /* 82249604h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82249604h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82249604h case    0:*/		return 0x82249608;
		  /* 82249608h */ case    1:  		/* mr R11, R20 */
		/* 82249608h case    1:*/		regs.R11 = regs.R20;
		/* 82249608h case    1:*/		return 0x8224960C;
		  /* 8224960Ch */ case    2:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8224960Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8224960Ch case    2:*/		return 0x82249610;
	}
	return 0x82249610;
} // Block from 82249604h-82249610h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249610);
		  /* 82249610h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82249610h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82249610h case    0:*/		return 0x82249614;
		  /* 82249614h */ case    1:  		/* bc 12, CR0_EQ, 68 */
		/* 82249614h case    1:*/		if ( regs.CR[0].eq ) { return 0x82249658;  }
		/* 82249614h case    1:*/		return 0x82249618;
		  /* 82249618h */ case    2:  		/* lwz R11, <#[R10 + 228]> */
		/* 82249618h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000000E4) );
		/* 82249618h case    2:*/		return 0x8224961C;
		  /* 8224961Ch */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224961Ch case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224961Ch case    3:*/		return 0x82249620;
		  /* 82249620h */ case    4:  		/* bc 12, CR0_EQ, 44 */
		/* 82249620h case    4:*/		if ( regs.CR[0].eq ) { return 0x8224964C;  }
		/* 82249620h case    4:*/		return 0x82249624;
		  /* 82249624h */ case    5:  		/* lwz R11, <#[R10 + 948]> */
		/* 82249624h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000003B4) );
		/* 82249624h case    5:*/		return 0x82249628;
		  /* 82249628h */ case    6:  		/* lwz R7, <#[R11 + 48]> */
		/* 82249628h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000030) );
		/* 82249628h case    6:*/		return 0x8224962C;
		  /* 8224962Ch */ case    7:  		/* rlwinm R11, R7, 27, 5, 31 */
		/* 8224962Ch case    7:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R7);
		/* 8224962Ch case    7:*/		return 0x82249630;
		  /* 82249630h */ case    8:  		/* rlwinm R7, R7, 0, 27, 31 */
		/* 82249630h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R7);
		/* 82249630h case    8:*/		return 0x82249634;
		  /* 82249634h */ case    9:  		/* addi R11, R11, 2 */
		/* 82249634h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82249634h case    9:*/		return 0x82249638;
		  /* 82249638h */ case   10:  		/* slw R7, R20, R7 */
		/* 82249638h case   10:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R20,regs.R7);
		/* 82249638h case   10:*/		return 0x8224963C;
		  /* 8224963Ch */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8224963Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8224963Ch case   11:*/		return 0x82249640;
		  /* 82249640h */ case   12:  		/* lwzx R6, <#[R11 + R21]> */
		/* 82249640h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R21 + 0x00000000) );
		/* 82249640h case   12:*/		return 0x82249644;
		  /* 82249644h */ case   13:  		/* or R7, R7, R6 */
		/* 82249644h case   13:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R6);
		/* 82249644h case   13:*/		return 0x82249648;
		  /* 82249648h */ case   14:  		/* stwx R7, <#[R11 + R21]> */
		/* 82249648h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + regs.R21 + 0x00000000) );
		/* 82249648h case   14:*/		return 0x8224964C;
	}
	return 0x8224964C;
} // Block from 82249610h-8224964Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224964Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224964C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224964C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224964C);
		  /* 8224964Ch */ case    0:  		/* addi R8, R8, 1 */
		/* 8224964Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8224964Ch case    0:*/		return 0x82249650;
		  /* 82249650h */ case    1:  		/* addi R9, R9, 4 */
		/* 82249650h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82249650h case    1:*/		return 0x82249654;
		  /* 82249654h */ case    2:  		/* b -104 */
		/* 82249654h case    2:*/		return 0x822495EC;
		/* 82249654h case    2:*/		return 0x82249658;
	}
	return 0x82249658;
} // Block from 8224964Ch-82249658h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249658);
		  /* 82249658h */ case    0:  		/* mr R24, R19 */
		/* 82249658h case    0:*/		regs.R24 = regs.R19;
		/* 82249658h case    0:*/		return 0x8224965C;
		  /* 8224965Ch */ case    1:  		/* mr R23, R19 */
		/* 8224965Ch case    1:*/		regs.R23 = regs.R19;
		/* 8224965Ch case    1:*/		return 0x82249660;
		  /* 82249660h */ case    2:  		/* mr R22, R20 */
		/* 82249660h case    2:*/		regs.R22 = regs.R20;
		/* 82249660h case    2:*/		return 0x82249664;
		  /* 82249664h */ case    3:  		/* lwz R11, <#[R18 + 40]> */
		/* 82249664h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000028) );
		/* 82249664h case    3:*/		return 0x82249668;
		  /* 82249668h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 82249668h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82249668h case    4:*/		return 0x8224966C;
		  /* 8224966Ch */ case    5:  		/* cmplw CR6, R22, R10 */
		/* 8224966Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R10);
		/* 8224966Ch case    5:*/		return 0x82249670;
		  /* 82249670h */ case    6:  		/* bc 4, CR6_GT, 12 */
		/* 82249670h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8224967C;  }
		/* 82249670h case    6:*/		return 0x82249674;
		  /* 82249674h */ case    7:  		/* mr R11, R19 */
		/* 82249674h case    7:*/		regs.R11 = regs.R19;
		/* 82249674h case    7:*/		return 0x82249678;
	}
	return 0x82249678;
} // Block from 82249658h-82249678h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82249678h
// Function '?VNLookupInst@XGRAPHICS@@YAPAUCurrentValue@1@PAV?$HashTable@PAUCurrentValue@XGRAPHICS@@@1@PAU21@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249678);
		  /* 82249678h */ case    0:  		/* b 16 */
		/* 82249678h case    0:*/		return 0x82249688;
		/* 82249678h case    0:*/		return 0x8224967C;
	}
	return 0x8224967C;
} // Block from 82249678h-8224967Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224967Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224967C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224967C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224967C);
		  /* 8224967Ch */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 8224967Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8224967Ch case    0:*/		return 0x82249680;
		  /* 82249680h */ case    1:  		/* mr R11, R20 */
		/* 82249680h case    1:*/		regs.R11 = regs.R20;
		/* 82249680h case    1:*/		return 0x82249684;
		  /* 82249684h */ case    2:  		/* lwzx R24, <#[R10 + R23]> */
		/* 82249684h case    2:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R10 + regs.R23 + 0x00000000) );
		/* 82249684h case    2:*/		return 0x82249688;
	}
	return 0x82249688;
} // Block from 8224967Ch-82249688h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249688);
		  /* 82249688h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82249688h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82249688h case    0:*/		return 0x8224968C;
		  /* 8224968Ch */ case    1:  		/* bc 12, CR0_EQ, 332 */
		/* 8224968Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x822497D8;  }
		/* 8224968Ch case    1:*/		return 0x82249690;
		  /* 82249690h */ case    2:  		/* lwz R11, <#[R24 + 228]> */
		/* 82249690h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x000000E4) );
		/* 82249690h case    2:*/		return 0x82249694;
		  /* 82249694h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82249694h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82249694h case    3:*/		return 0x82249698;
		  /* 82249698h */ case    4:  		/* bc 12, CR0_EQ, 308 */
		/* 82249698h case    4:*/		if ( regs.CR[0].eq ) { return 0x822497CC;  }
		/* 82249698h case    4:*/		return 0x8224969C;
		  /* 8224969Ch */ case    5:  		/* lwz R25, <#[R24 + 948]> */
		/* 8224969Ch case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R24 + 0x000003B4) );
		/* 8224969Ch case    5:*/		return 0x822496A0;
		  /* 822496A0h */ case    6:  		/* mr R28, R19 */
		/* 822496A0h case    6:*/		regs.R28 = regs.R19;
		/* 822496A0h case    6:*/		return 0x822496A4;
		  /* 822496A4h */ case    7:  		/* mr R27, R19 */
		/* 822496A4h case    7:*/		regs.R27 = regs.R19;
		/* 822496A4h case    7:*/		return 0x822496A8;
		  /* 822496A8h */ case    8:  		/* mr R26, R20 */
		/* 822496A8h case    8:*/		regs.R26 = regs.R20;
		/* 822496A8h case    8:*/		return 0x822496AC;
		  /* 822496ACh */ case    9:  		/* lwz R11, <#[R25 + 92]> */
		/* 822496ACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000005C) );
		/* 822496ACh case    9:*/		return 0x822496B0;
		  /* 822496B0h */ case   10:  		/* lwz R10, <#[R11 + 4]> */
		/* 822496B0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 822496B0h case   10:*/		return 0x822496B4;
		  /* 822496B4h */ case   11:  		/* cmplw CR6, R26, R10 */
		/* 822496B4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 822496B4h case   11:*/		return 0x822496B8;
		  /* 822496B8h */ case   12:  		/* bc 4, CR6_GT, 12 */
		/* 822496B8h case   12:*/		if ( !regs.CR[6].gt ) { return 0x822496C4;  }
		/* 822496B8h case   12:*/		return 0x822496BC;
		  /* 822496BCh */ case   13:  		/* mr R11, R19 */
		/* 822496BCh case   13:*/		regs.R11 = regs.R19;
		/* 822496BCh case   13:*/		return 0x822496C0;
		  /* 822496C0h */ case   14:  		/* b 16 */
		/* 822496C0h case   14:*/		return 0x822496D0;
		/* 822496C0h case   14:*/		return 0x822496C4;
	}
	return 0x822496C4;
} // Block from 82249688h-822496C4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822496C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822496C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822496C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822496C4);
		  /* 822496C4h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 822496C4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 822496C4h case    0:*/		return 0x822496C8;
		  /* 822496C8h */ case    1:  		/* mr R11, R20 */
		/* 822496C8h case    1:*/		regs.R11 = regs.R20;
		/* 822496C8h case    1:*/		return 0x822496CC;
		  /* 822496CCh */ case    2:  		/* lwzx R28, <#[R10 + R27]> */
		/* 822496CCh case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 822496CCh case    2:*/		return 0x822496D0;
	}
	return 0x822496D0;
} // Block from 822496C4h-822496D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822496D0h
// Function '?MakeValue@CurrentValue@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822496D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822496D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822496D0);
		  /* 822496D0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822496D0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822496D0h case    0:*/		return 0x822496D4;
		  /* 822496D4h */ case    1:  		/* bc 12, CR0_EQ, 248 */
		/* 822496D4h case    1:*/		if ( regs.CR[0].eq ) { return 0x822497CC;  }
		/* 822496D4h case    1:*/		return 0x822496D8;
		  /* 822496D8h */ case    2:  		/* lwz R10, <#[R28 + 48]> */
		/* 822496D8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000030) );
		/* 822496D8h case    2:*/		return 0x822496DC;
		  /* 822496DCh */ case    3:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 822496DCh case    3:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 822496DCh case    3:*/		return 0x822496E0;
		  /* 822496E0h */ case    4:  		/* rlwinm R29, R10, 0, 27, 31 */
		/* 822496E0h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R29,regs.R10);
		/* 822496E0h case    4:*/		return 0x822496E4;
		  /* 822496E4h */ case    5:  		/* addi R11, R11, 2 */
		/* 822496E4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 822496E4h case    5:*/		return 0x822496E8;
		  /* 822496E8h */ case    6:  		/* rlwinm R30, R11, 2, 0, 29 */
		/* 822496E8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R11);
		/* 822496E8h case    6:*/		return 0x822496EC;
		  /* 822496ECh */ case    7:  		/* lwzx R11, <#[R30 + R17]> */
		/* 822496ECh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R17 + 0x00000000) );
		/* 822496ECh case    7:*/		return 0x822496F0;
		  /* 822496F0h */ case    8:  		/* srw R11, R11, R29 */
		/* 822496F0h case    8:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 822496F0h case    8:*/		return 0x822496F4;
		  /* 822496F4h */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 822496F4h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 822496F4h case    9:*/		return 0x822496F8;
		  /* 822496F8h */ case   10:  		/* bc 4, CR0_EQ, 200 */
		/* 822496F8h case   10:*/		if ( !regs.CR[0].eq ) { return 0x822497C0;  }
		/* 822496F8h case   10:*/		return 0x822496FC;
		  /* 822496FCh */ case   11:  		/* lwz R11, <#[R16 + 12]> */
		/* 822496FCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x0000000C) );
		/* 822496FCh case   11:*/		return 0x82249700;
		  /* 82249700h */ case   12:  		/* li R4, 964 */
		/* 82249700h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82249700h case   12:*/		return 0x82249704;
		  /* 82249704h */ case   13:  		/* lwz R31, <#[R11 + 1452]> */
		/* 82249704h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x000005AC) );
		/* 82249704h case   13:*/		return 0x82249708;
		  /* 82249708h */ case   14:  		/* mr R3, R31 */
		/* 82249708h case   14:*/		regs.R3 = regs.R31;
		/* 82249708h case   14:*/		return 0x8224970C;
		  /* 8224970Ch */ case   15:  		/* bl -184916 */
		/* 8224970Ch case   15:*/		regs.LR = 0x82249710; return 0x8221C4B8;
		/* 8224970Ch case   15:*/		return 0x82249710;
		  /* 82249710h */ case   16:  		/* mr R11, R3 */
		/* 82249710h case   16:*/		regs.R11 = regs.R3;
		/* 82249710h case   16:*/		return 0x82249714;
		  /* 82249714h */ case   17:  		/* addic. R3, R3, 4 */
		/* 82249714h case   17:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82249714h case   17:*/		return 0x82249718;
		  /* 82249718h */ case   18:  		/* stw R31, <#[R11]> */
		/* 82249718h case   18:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82249718h case   18:*/		return 0x8224971C;
		  /* 8224971Ch */ case   19:  		/* bc 12, CR0_EQ, 20 */
		/* 8224971Ch case   19:*/		if ( regs.CR[0].eq ) { return 0x82249730;  }
		/* 8224971Ch case   19:*/		return 0x82249720;
		  /* 82249720h */ case   20:  		/* lwz R4, <#[R16 + 12]> */
		/* 82249720h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R16 + 0x0000000C) );
		/* 82249720h case   20:*/		return 0x82249724;
		  /* 82249724h */ case   21:  		/* bl 56956 */
		/* 82249724h case   21:*/		regs.LR = 0x82249728; return 0x822575A0;
		/* 82249724h case   21:*/		return 0x82249728;
		  /* 82249728h */ case   22:  		/* mr R31, R3 */
		/* 82249728h case   22:*/		regs.R31 = regs.R3;
		/* 82249728h case   22:*/		return 0x8224972C;
		  /* 8224972Ch */ case   23:  		/* b 8 */
		/* 8224972Ch case   23:*/		return 0x82249734;
		/* 8224972Ch case   23:*/		return 0x82249730;
	}
	return 0x82249730;
} // Block from 822496D0h-82249730h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82249730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249730);
		  /* 82249730h */ case    0:  		/* mr R31, R19 */
		/* 82249730h case    0:*/		regs.R31 = regs.R19;
		/* 82249730h case    0:*/		return 0x82249734;
	}
	return 0x82249734;
} // Block from 82249730h-82249734h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249734);
		  /* 82249734h */ case    0:  		/* mr R3, R28 */
		/* 82249734h case    0:*/		regs.R3 = regs.R28;
		/* 82249734h case    0:*/		return 0x82249738;
		  /* 82249738h */ case    1:  		/* bl 64896 */
		/* 82249738h case    1:*/		regs.LR = 0x8224973C; return 0x822594B8;
		/* 82249738h case    1:*/		return 0x8224973C;
		  /* 8224973Ch */ case    2:  		/* stw R3, <#[R31 + 20]> */
		/* 8224973Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 8224973Ch case    2:*/		return 0x82249740;
		  /* 82249740h */ case    3:  		/* mr R5, R18 */
		/* 82249740h case    3:*/		regs.R5 = regs.R18;
		/* 82249740h case    3:*/		return 0x82249744;
		  /* 82249744h */ case    4:  		/* li R4, 0 */
		/* 82249744h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82249744h case    4:*/		return 0x82249748;
		  /* 82249748h */ case    5:  		/* mr R3, R31 */
		/* 82249748h case    5:*/		regs.R3 = regs.R31;
		/* 82249748h case    5:*/		return 0x8224974C;
		  /* 8224974Ch */ case    6:  		/* bl 52300 */
		/* 8224974Ch case    6:*/		regs.LR = 0x82249750; return 0x82256398;
		/* 8224974Ch case    6:*/		return 0x82249750;
		  /* 82249750h */ case    7:  		/* lwzx R11, <#[R30 + R21]> */
		/* 82249750h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R21 + 0x00000000) );
		/* 82249750h case    7:*/		return 0x82249754;
		  /* 82249754h */ case    8:  		/* srw R11, R11, R29 */
		/* 82249754h case    8:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82249754h case    8:*/		return 0x82249758;
		  /* 82249758h */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82249758h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82249758h case    9:*/		return 0x8224975C;
		  /* 8224975Ch */ case   10:  		/* bc 4, CR0_EQ, 32 */
		/* 8224975Ch case   10:*/		if ( !regs.CR[0].eq ) { return 0x8224977C;  }
		/* 8224975Ch case   10:*/		return 0x82249760;
		  /* 82249760h */ case   11:  		/* lwzx R11, <#[R30 + R21]> */
		/* 82249760h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R21 + 0x00000000) );
		/* 82249760h case   11:*/		return 0x82249764;
		  /* 82249764h */ case   12:  		/* slw R10, R20, R29 */
		/* 82249764h case   12:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R20,regs.R29);
		/* 82249764h case   12:*/		return 0x82249768;
		  /* 82249768h */ case   13:  		/* or R11, R10, R11 */
		/* 82249768h case   13:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82249768h case   13:*/		return 0x8224976C;
		  /* 8224976Ch */ case   14:  		/* mr R4, R31 */
		/* 8224976Ch case   14:*/		regs.R4 = regs.R31;
		/* 8224976Ch case   14:*/		return 0x82249770;
		  /* 82249770h */ case   15:  		/* stwx R11, <#[R30 + R21]> */
		/* 82249770h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + regs.R21 + 0x00000000) );
		/* 82249770h case   15:*/		return 0x82249774;
		  /* 82249774h */ case   16:  		/* mr R3, R18 */
		/* 82249774h case   16:*/		regs.R3 = regs.R18;
		/* 82249774h case   16:*/		return 0x82249778;
		  /* 82249778h */ case   17:  		/* bl 44272 */
		/* 82249778h case   17:*/		regs.LR = 0x8224977C; return 0x82254468;
		/* 82249778h case   17:*/		return 0x8224977C;
	}
	return 0x8224977C;
} // Block from 82249734h-8224977Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224977Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224977C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224977C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224977C);
		  /* 8224977Ch */ case    0:  		/* mr R4, R31 */
		/* 8224977Ch case    0:*/		regs.R4 = regs.R31;
		/* 8224977Ch case    0:*/		return 0x82249780;
		  /* 82249780h */ case    1:  		/* mr R3, R28 */
		/* 82249780h case    1:*/		regs.R3 = regs.R28;
		/* 82249780h case    1:*/		return 0x82249784;
		  /* 82249784h */ case    2:  		/* bl 63476 */
		/* 82249784h case    2:*/		regs.LR = 0x82249788; return 0x82258F78;
		/* 82249784h case    2:*/		return 0x82249788;
		  /* 82249788h */ case    3:  		/* mr R3, R28 */
		/* 82249788h case    3:*/		regs.R3 = regs.R28;
		/* 82249788h case    3:*/		return 0x8224978C;
		  /* 8224978Ch */ case    4:  		/* bl 63804 */
		/* 8224978Ch case    4:*/		regs.LR = 0x82249790; return 0x822590C8;
		/* 8224978Ch case    4:*/		return 0x82249790;
		  /* 82249790h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82249790h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82249790h case    5:*/		return 0x82249794;
		  /* 82249794h */ case    6:  		/* bc 4, CR0_EQ, 28 */
		/* 82249794h case    6:*/		if ( !regs.CR[0].eq ) { return 0x822497B0;  }
		/* 82249794h case    6:*/		return 0x82249798;
		  /* 82249798h */ case    7:  		/* mr R5, R14 */
		/* 82249798h case    7:*/		regs.R5 = regs.R14;
		/* 82249798h case    7:*/		return 0x8224979C;
		  /* 8224979Ch */ case    8:  		/* lwz R6, <#[R1 + 80]> */
		/* 8224979Ch case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8224979Ch case    8:*/		return 0x822497A0;
		  /* 822497A0h */ case    9:  		/* mr R4, R15 */
		/* 822497A0h case    9:*/		regs.R4 = regs.R15;
		/* 822497A0h case    9:*/		return 0x822497A4;
		  /* 822497A4h */ case   10:  		/* li R7, 517 */
		/* 822497A4h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x205);
		/* 822497A4h case   10:*/		return 0x822497A8;
		  /* 822497A8h */ case   11:  		/* li R3, 0 */
		/* 822497A8h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822497A8h case   11:*/		return 0x822497AC;
		  /* 822497ACh */ case   12:  		/* bl -990116 */
		/* 822497ACh case   12:*/		regs.LR = 0x822497B0; return 0x82157C08;
		/* 822497ACh case   12:*/		return 0x822497B0;
	}
	return 0x822497B0;
} // Block from 8224977Ch-822497B0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822497B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822497B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822497B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822497B0);
		  /* 822497B0h */ case    0:  		/* lwzx R11, <#[R30 + R17]> */
		/* 822497B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R17 + 0x00000000) );
		/* 822497B0h case    0:*/		return 0x822497B4;
		  /* 822497B4h */ case    1:  		/* slw R10, R20, R29 */
		/* 822497B4h case    1:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R20,regs.R29);
		/* 822497B4h case    1:*/		return 0x822497B8;
		  /* 822497B8h */ case    2:  		/* or R11, R10, R11 */
		/* 822497B8h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822497B8h case    2:*/		return 0x822497BC;
		  /* 822497BCh */ case    3:  		/* stwx R11, <#[R30 + R17]> */
		/* 822497BCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + regs.R17 + 0x00000000) );
		/* 822497BCh case    3:*/		return 0x822497C0;
	}
	return 0x822497C0;
} // Block from 822497B0h-822497C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822497C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822497C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822497C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822497C0);
		  /* 822497C0h */ case    0:  		/* addi R26, R26, 1 */
		/* 822497C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 822497C0h case    0:*/		return 0x822497C4;
		  /* 822497C4h */ case    1:  		/* addi R27, R27, 4 */
		/* 822497C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 822497C4h case    1:*/		return 0x822497C8;
		  /* 822497C8h */ case    2:  		/* b -284 */
		/* 822497C8h case    2:*/		return 0x822496AC;
		/* 822497C8h case    2:*/		return 0x822497CC;
	}
	return 0x822497CC;
} // Block from 822497C0h-822497CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822497CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822497CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822497CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822497CC);
		  /* 822497CCh */ case    0:  		/* addi R22, R22, 1 */
		/* 822497CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 822497CCh case    0:*/		return 0x822497D0;
		  /* 822497D0h */ case    1:  		/* addi R23, R23, 4 */
		/* 822497D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x4);
		/* 822497D0h case    1:*/		return 0x822497D4;
		  /* 822497D4h */ case    2:  		/* b -368 */
		/* 822497D4h case    2:*/		return 0x82249664;
		/* 822497D4h case    2:*/		return 0x822497D8;
	}
	return 0x822497D8;
} // Block from 822497CCh-822497D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822497D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822497D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822497D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822497D8);
		  /* 822497D8h */ case    0:  		/* addi R3, R1, 96 */
		/* 822497D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 822497D8h case    0:*/		return 0x822497DC;
		  /* 822497DCh */ case    1:  		/* bl 43124 */
		/* 822497DCh case    1:*/		regs.LR = 0x822497E0; return 0x82254050;
		/* 822497DCh case    1:*/		return 0x822497E0;
		  /* 822497E0h */ case    2:  		/* lwz R3, <#[R1 + 112]> */
		/* 822497E0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 822497E0h case    2:*/		return 0x822497E4;
		  /* 822497E4h */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 822497E4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 822497E4h case    3:*/		return 0x822497E8;
		  /* 822497E8h */ case    4:  		/* mr R18, R3 */
		/* 822497E8h case    4:*/		regs.R18 = regs.R3;
		/* 822497E8h case    4:*/		return 0x822497EC;
		  /* 822497ECh */ case    5:  		/* stw R3, <#[R1 + 116]> */
		/* 822497ECh case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000074) );
		/* 822497ECh case    5:*/		return 0x822497F0;
		  /* 822497F0h */ case    6:  		/* bc 4, CR6_EQ, -672 */
		/* 822497F0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82249550;  }
		/* 822497F0h case    6:*/		return 0x822497F4;
	}
	return 0x822497F4;
} // Block from 822497D8h-822497F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822497F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822497F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822497F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822497F4);
		  /* 822497F4h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 822497F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 822497F4h case    0:*/		return 0x822497F8;
		  /* 822497F8h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 822497F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82249808;  }
		/* 822497F8h case    1:*/		return 0x822497FC;
		  /* 822497FCh */ case    2:  		/* addi R4, R21, -4 */
		/* 822497FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R21,0xFFFFFFFC);
		/* 822497FCh case    2:*/		return 0x82249800;
		  /* 82249800h */ case    3:  		/* lwz R3, <#[R21 - 4]> */
		/* 82249800h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0xFFFFFFFC) );
		/* 82249800h case    3:*/		return 0x82249804;
		  /* 82249804h */ case    4:  		/* bl -184772 */
		/* 82249804h case    4:*/		regs.LR = 0x82249808; return 0x8221C640;
		/* 82249804h case    4:*/		return 0x82249808;
	}
	return 0x82249808;
} // Block from 822497F4h-82249808h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82249808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249808);
		  /* 82249808h */ case    0:  		/* cmplwi CR6, R17, 0 */
		/* 82249808h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 82249808h case    0:*/		return 0x8224980C;
		  /* 8224980Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8224980Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8224981C;  }
		/* 8224980Ch case    1:*/		return 0x82249810;
		  /* 82249810h */ case    2:  		/* addi R4, R17, -4 */
		/* 82249810h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R17,0xFFFFFFFC);
		/* 82249810h case    2:*/		return 0x82249814;
		  /* 82249814h */ case    3:  		/* lwz R3, <#[R17 - 4]> */
		/* 82249814h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0xFFFFFFFC) );
		/* 82249814h case    3:*/		return 0x82249818;
		  /* 82249818h */ case    4:  		/* bl -184792 */
		/* 82249818h case    4:*/		regs.LR = 0x8224981C; return 0x8221C640;
		/* 82249818h case    4:*/		return 0x8224981C;
	}
	return 0x8224981C;
} // Block from 82249808h-8224981Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224981Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224981C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224981C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224981C);
		  /* 8224981Ch */ case    0:  		/* addi R1, R1, 272 */
		/* 8224981Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 8224981Ch case    0:*/		return 0x82249820;
		  /* 82249820h */ case    1:  		/* b -1803696 */
		/* 82249820h case    1:*/		return 0x82091270;
		/* 82249820h case    1:*/		return 0x82249824;
		  /* 82249824h */ case    2:  		/* nop */
		/* 82249824h case    2:*/		cpu::op::nop();
		/* 82249824h case    2:*/		return 0x82249828;
	}
	return 0x82249828;
} // Block from 8224981Ch-82249828h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249828h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249828);
		  /* 82249828h */ case    0:  		/* mfspr R12, LR */
		/* 82249828h case    0:*/		regs.R12 = regs.LR;
		/* 82249828h case    0:*/		return 0x8224982C;
		  /* 8224982Ch */ case    1:  		/* bl -1803752 */
		/* 8224982Ch case    1:*/		regs.LR = 0x82249830; return 0x82091244;
		/* 8224982Ch case    1:*/		return 0x82249830;
		  /* 82249830h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82249830h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82249830h case    2:*/		return 0x82249834;
		  /* 82249834h */ case    3:  		/* mr R30, R3 */
		/* 82249834h case    3:*/		regs.R30 = regs.R3;
		/* 82249834h case    3:*/		return 0x82249838;
		  /* 82249838h */ case    4:  		/* bl -65312 */
		/* 82249838h case    4:*/		regs.LR = 0x8224983C; return 0x82239918;
		/* 82249838h case    4:*/		return 0x8224983C;
		  /* 8224983Ch */ case    5:  		/* mr R29, R3 */
		/* 8224983Ch case    5:*/		regs.R29 = regs.R3;
		/* 8224983Ch case    5:*/		return 0x82249840;
		  /* 82249840h */ case    6:  		/* addi R3, R30, 128 */
		/* 82249840h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x80);
		/* 82249840h case    6:*/		return 0x82249844;
		  /* 82249844h */ case    7:  		/* bl 40988 */
		/* 82249844h case    7:*/		regs.LR = 0x82249848; return 0x82253860;
		/* 82249844h case    7:*/		return 0x82249848;
		  /* 82249848h */ case    8:  		/* lwz R11, <#[R30 + 12]> */
		/* 82249848h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82249848h case    8:*/		return 0x8224984C;
		  /* 8224984Ch */ case    9:  		/* mr R31, R3 */
		/* 8224984Ch case    9:*/		regs.R31 = regs.R3;
		/* 8224984Ch case    9:*/		return 0x82249850;
		  /* 82249850h */ case   10:  		/* li R4, 20 */
		/* 82249850h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82249850h case   10:*/		return 0x82249854;
		  /* 82249854h */ case   11:  		/* lwz R27, <#[R11 + 1456]> */
		/* 82249854h case   11:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005B0) );
		/* 82249854h case   11:*/		return 0x82249858;
		  /* 82249858h */ case   12:  		/* mr R3, R27 */
		/* 82249858h case   12:*/		regs.R3 = regs.R27;
		/* 82249858h case   12:*/		return 0x8224985C;
		  /* 8224985Ch */ case   13:  		/* bl -185252 */
		/* 8224985Ch case   13:*/		regs.LR = 0x82249860; return 0x8221C4B8;
		/* 8224985Ch case   13:*/		return 0x82249860;
		  /* 82249860h */ case   14:  		/* addic. R28, R3, 4 */
		/* 82249860h case   14:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R3,0x4);
		/* 82249860h case   14:*/		return 0x82249864;
		  /* 82249864h */ case   15:  		/* stw R27, <#[R3]> */
		/* 82249864h case   15:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82249864h case   15:*/		return 0x82249868;
		  /* 82249868h */ case   16:  		/* bc 12, CR0_EQ, 24 */
		/* 82249868h case   16:*/		if ( regs.CR[0].eq ) { return 0x82249880;  }
		/* 82249868h case   16:*/		return 0x8224986C;
		  /* 8224986Ch */ case   17:  		/* lwz R11, <#[R30 + 12]> */
		/* 8224986Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224986Ch case   17:*/		return 0x82249870;
		  /* 82249870h */ case   18:  		/* mr R3, R28 */
		/* 82249870h case   18:*/		regs.R3 = regs.R28;
		/* 82249870h case   18:*/		return 0x82249874;
		  /* 82249874h */ case   19:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82249874h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82249874h case   19:*/		return 0x82249878;
		  /* 82249878h */ case   20:  		/* bl -80664 */
		/* 82249878h case   20:*/		regs.LR = 0x8224987C; return 0x82235D60;
		/* 82249878h case   20:*/		return 0x8224987C;
		  /* 8224987Ch */ case   21:  		/* b 8 */
		/* 8224987Ch case   21:*/		return 0x82249884;
		/* 8224987Ch case   21:*/		return 0x82249880;
	}
	return 0x82249880;
} // Block from 82249828h-82249880h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82249880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249880);
		  /* 82249880h */ case    0:  		/* li R28, 0 */
		/* 82249880h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82249880h case    0:*/		return 0x82249884;
	}
	return 0x82249884;
} // Block from 82249880h-82249884h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249884);
		  /* 82249884h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82249884h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82249884h case    0:*/		return 0x82249888;
	}
	return 0x82249888;
} // Block from 82249884h-82249888h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249888h
// Function '?VNInsert@XGRAPHICS@@YAXPAV?$HashTable@PAUCurrentValue@XGRAPHICS@@@1@PAUCurrentValue@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249888);
		  /* 82249888h */ case    0:  		/* li R4, 20 */
		/* 82249888h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82249888h case    0:*/		return 0x8224988C;
		  /* 8224988Ch */ case    1:  		/* lwz R26, <#[R11 + 1456]> */
		/* 8224988Ch case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x000005B0) );
		/* 8224988Ch case    1:*/		return 0x82249890;
		  /* 82249890h */ case    2:  		/* mr R3, R26 */
		/* 82249890h case    2:*/		regs.R3 = regs.R26;
		/* 82249890h case    2:*/		return 0x82249894;
		  /* 82249894h */ case    3:  		/* bl -185308 */
		/* 82249894h case    3:*/		regs.LR = 0x82249898; return 0x8221C4B8;
		/* 82249894h case    3:*/		return 0x82249898;
		  /* 82249898h */ case    4:  		/* addic. R27, R3, 4 */
		/* 82249898h case    4:*/		cpu::op::addic<1>(regs,&regs.R27,regs.R3,0x4);
		/* 82249898h case    4:*/		return 0x8224989C;
		  /* 8224989Ch */ case    5:  		/* stw R26, <#[R3]> */
		/* 8224989Ch case    5:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000000) );
		/* 8224989Ch case    5:*/		return 0x822498A0;
		  /* 822498A0h */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 822498A0h case    6:*/		if ( regs.CR[0].eq ) { return 0x822498BC;  }
		/* 822498A0h case    6:*/		return 0x822498A4;
		  /* 822498A4h */ case    7:  		/* lwz R11, <#[R30 + 12]> */
		/* 822498A4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 822498A4h case    7:*/		return 0x822498A8;
		  /* 822498A8h */ case    8:  		/* mr R3, R27 */
		/* 822498A8h case    8:*/		regs.R3 = regs.R27;
		/* 822498A8h case    8:*/		return 0x822498AC;
		  /* 822498ACh */ case    9:  		/* lwz R4, <#[R11 + 1456]> */
		/* 822498ACh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 822498ACh case    9:*/		return 0x822498B0;
		  /* 822498B0h */ case   10:  		/* bl -80720 */
		/* 822498B0h case   10:*/		regs.LR = 0x822498B4; return 0x82235D60;
		/* 822498B0h case   10:*/		return 0x822498B4;
		  /* 822498B4h */ case   11:  		/* mr R23, R27 */
		/* 822498B4h case   11:*/		regs.R23 = regs.R27;
		/* 822498B4h case   11:*/		return 0x822498B8;
		  /* 822498B8h */ case   12:  		/* b 8 */
		/* 822498B8h case   12:*/		return 0x822498C0;
		/* 822498B8h case   12:*/		return 0x822498BC;
	}
	return 0x822498BC;
} // Block from 82249888h-822498BCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 822498BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822498BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822498BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822498BC);
		  /* 822498BCh */ case    0:  		/* li R23, 0 */
		/* 822498BCh case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 822498BCh case    0:*/		return 0x822498C0;
	}
	return 0x822498C0;
} // Block from 822498BCh-822498C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822498C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822498C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822498C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822498C0);
		  /* 822498C0h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 822498C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 822498C0h case    0:*/		return 0x822498C4;
		  /* 822498C4h */ case    1:  		/* li R4, 20 */
		/* 822498C4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 822498C4h case    1:*/		return 0x822498C8;
		  /* 822498C8h */ case    2:  		/* lwz R26, <#[R11 + 1456]> */
		/* 822498C8h case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x000005B0) );
		/* 822498C8h case    2:*/		return 0x822498CC;
		  /* 822498CCh */ case    3:  		/* mr R3, R26 */
		/* 822498CCh case    3:*/		regs.R3 = regs.R26;
		/* 822498CCh case    3:*/		return 0x822498D0;
	}
	return 0x822498D0;
} // Block from 822498C0h-822498D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822498D0h
// Function '?SrcIsFromConstMov@IRInst@XGRAPHICS@@QBA_NPAV12@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822498D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822498D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822498D0);
		  /* 822498D0h */ case    0:  		/* bl -185368 */
		/* 822498D0h case    0:*/		regs.LR = 0x822498D4; return 0x8221C4B8;
		/* 822498D0h case    0:*/		return 0x822498D4;
		  /* 822498D4h */ case    1:  		/* addic. R27, R3, 4 */
		/* 822498D4h case    1:*/		cpu::op::addic<1>(regs,&regs.R27,regs.R3,0x4);
		/* 822498D4h case    1:*/		return 0x822498D8;
		  /* 822498D8h */ case    2:  		/* stw R26, <#[R3]> */
		/* 822498D8h case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000000) );
		/* 822498D8h case    2:*/		return 0x822498DC;
		  /* 822498DCh */ case    3:  		/* bc 12, CR0_EQ, 28 */
		/* 822498DCh case    3:*/		if ( regs.CR[0].eq ) { return 0x822498F8;  }
		/* 822498DCh case    3:*/		return 0x822498E0;
		  /* 822498E0h */ case    4:  		/* lwz R11, <#[R30 + 12]> */
		/* 822498E0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 822498E0h case    4:*/		return 0x822498E4;
		  /* 822498E4h */ case    5:  		/* mr R3, R27 */
		/* 822498E4h case    5:*/		regs.R3 = regs.R27;
		/* 822498E4h case    5:*/		return 0x822498E8;
		  /* 822498E8h */ case    6:  		/* lwz R4, <#[R11 + 1456]> */
		/* 822498E8h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 822498E8h case    6:*/		return 0x822498EC;
		  /* 822498ECh */ case    7:  		/* bl -80780 */
		/* 822498ECh case    7:*/		regs.LR = 0x822498F0; return 0x82235D60;
		/* 822498ECh case    7:*/		return 0x822498F0;
		  /* 822498F0h */ case    8:  		/* mr R24, R27 */
		/* 822498F0h case    8:*/		regs.R24 = regs.R27;
		/* 822498F0h case    8:*/		return 0x822498F4;
		  /* 822498F4h */ case    9:  		/* b 8 */
		/* 822498F4h case    9:*/		return 0x822498FC;
		/* 822498F4h case    9:*/		return 0x822498F8;
	}
	return 0x822498F8;
} // Block from 822498D0h-822498F8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822498F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822498F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822498F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822498F8);
		  /* 822498F8h */ case    0:  		/* li R24, 0 */
		/* 822498F8h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 822498F8h case    0:*/		return 0x822498FC;
	}
	return 0x822498FC;
} // Block from 822498F8h-822498FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822498FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822498FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822498FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822498FC);
		  /* 822498FCh */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 822498FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 822498FCh case    0:*/		return 0x82249900;
		  /* 82249900h */ case    1:  		/* li R4, 20 */
		/* 82249900h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82249900h case    1:*/		return 0x82249904;
		  /* 82249904h */ case    2:  		/* lwz R26, <#[R11 + 1456]> */
		/* 82249904h case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x000005B0) );
		/* 82249904h case    2:*/		return 0x82249908;
		  /* 82249908h */ case    3:  		/* mr R3, R26 */
		/* 82249908h case    3:*/		regs.R3 = regs.R26;
		/* 82249908h case    3:*/		return 0x8224990C;
		  /* 8224990Ch */ case    4:  		/* bl -185428 */
		/* 8224990Ch case    4:*/		regs.LR = 0x82249910; return 0x8221C4B8;
		/* 8224990Ch case    4:*/		return 0x82249910;
		  /* 82249910h */ case    5:  		/* addic. R27, R3, 4 */
		/* 82249910h case    5:*/		cpu::op::addic<1>(regs,&regs.R27,regs.R3,0x4);
		/* 82249910h case    5:*/		return 0x82249914;
		  /* 82249914h */ case    6:  		/* stw R26, <#[R3]> */
		/* 82249914h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000000) );
		/* 82249914h case    6:*/		return 0x82249918;
		  /* 82249918h */ case    7:  		/* bc 12, CR0_EQ, 28 */
		/* 82249918h case    7:*/		if ( regs.CR[0].eq ) { return 0x82249934;  }
		/* 82249918h case    7:*/		return 0x8224991C;
		  /* 8224991Ch */ case    8:  		/* lwz R11, <#[R30 + 12]> */
		/* 8224991Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8224991Ch case    8:*/		return 0x82249920;
		  /* 82249920h */ case    9:  		/* mr R3, R27 */
		/* 82249920h case    9:*/		regs.R3 = regs.R27;
		/* 82249920h case    9:*/		return 0x82249924;
		  /* 82249924h */ case   10:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82249924h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82249924h case   10:*/		return 0x82249928;
		  /* 82249928h */ case   11:  		/* bl -80840 */
		/* 82249928h case   11:*/		regs.LR = 0x8224992C; return 0x82235D60;
		/* 82249928h case   11:*/		return 0x8224992C;
		  /* 8224992Ch */ case   12:  		/* mr R26, R27 */
		/* 8224992Ch case   12:*/		regs.R26 = regs.R27;
		/* 8224992Ch case   12:*/		return 0x82249930;
		  /* 82249930h */ case   13:  		/* b 8 */
		/* 82249930h case   13:*/		return 0x82249938;
		/* 82249930h case   13:*/		return 0x82249934;
	}
	return 0x82249934;
} // Block from 822498FCh-82249934h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82249934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249934);
		  /* 82249934h */ case    0:  		/* li R26, 0 */
		/* 82249934h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82249934h case    0:*/		return 0x82249938;
	}
	return 0x82249938;
} // Block from 82249934h-82249938h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249938);
		  /* 82249938h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82249938h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82249938h case    0:*/		return 0x8224993C;
		  /* 8224993Ch */ case    1:  		/* li R4, 20 */
		/* 8224993Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8224993Ch case    1:*/		return 0x82249940;
		  /* 82249940h */ case    2:  		/* lwz R25, <#[R11 + 1456]> */
		/* 82249940h case    2:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x000005B0) );
		/* 82249940h case    2:*/		return 0x82249944;
		  /* 82249944h */ case    3:  		/* mr R3, R25 */
		/* 82249944h case    3:*/		regs.R3 = regs.R25;
		/* 82249944h case    3:*/		return 0x82249948;
		  /* 82249948h */ case    4:  		/* bl -185488 */
		/* 82249948h case    4:*/		regs.LR = 0x8224994C; return 0x8221C4B8;
		/* 82249948h case    4:*/		return 0x8224994C;
		  /* 8224994Ch */ case    5:  		/* addic. R27, R3, 4 */
		/* 8224994Ch case    5:*/		cpu::op::addic<1>(regs,&regs.R27,regs.R3,0x4);
		/* 8224994Ch case    5:*/		return 0x82249950;
		  /* 82249950h */ case    6:  		/* stw R25, <#[R3]> */
		/* 82249950h case    6:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000000) );
		/* 82249950h case    6:*/		return 0x82249954;
		  /* 82249954h */ case    7:  		/* bc 12, CR0_EQ, 24 */
		/* 82249954h case    7:*/		if ( regs.CR[0].eq ) { return 0x8224996C;  }
		/* 82249954h case    7:*/		return 0x82249958;
		  /* 82249958h */ case    8:  		/* lwz R11, <#[R30 + 12]> */
		/* 82249958h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82249958h case    8:*/		return 0x8224995C;
		  /* 8224995Ch */ case    9:  		/* mr R3, R27 */
		/* 8224995Ch case    9:*/		regs.R3 = regs.R27;
		/* 8224995Ch case    9:*/		return 0x82249960;
		  /* 82249960h */ case   10:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82249960h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82249960h case   10:*/		return 0x82249964;
		  /* 82249964h */ case   11:  		/* bl -80900 */
		/* 82249964h case   11:*/		regs.LR = 0x82249968; return 0x82235D60;
		/* 82249964h case   11:*/		return 0x82249968;
		  /* 82249968h */ case   12:  		/* b 8 */
		/* 82249968h case   12:*/		return 0x82249970;
		/* 82249968h case   12:*/		return 0x8224996C;
	}
	return 0x8224996C;
} // Block from 82249938h-8224996Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224996Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224996C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224996C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224996C);
		  /* 8224996Ch */ case    0:  		/* li R27, 0 */
		/* 8224996Ch case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8224996Ch case    0:*/		return 0x82249970;
	}
	return 0x82249970;
} // Block from 8224996Ch-82249970h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249970);
		  /* 82249970h */ case    0:  		/* li R25, 0 */
		/* 82249970h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82249970h case    0:*/		return 0x82249974;
		  /* 82249974h */ case    1:  		/* cmpwi CR6, R31, 1 */
		/* 82249974h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000001);
		/* 82249974h case    1:*/		return 0x82249978;
		  /* 82249978h */ case    2:  		/* stw R25, <#[R1 + 80]> */
		/* 82249978h case    2:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000050) );
		/* 82249978h case    2:*/		return 0x8224997C;
		  /* 8224997Ch */ case    3:  		/* bc 12, CR6_LT, 52 */
		/* 8224997Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x822499B0;  }
		/* 8224997Ch case    3:*/		return 0x82249980;
		  /* 82249980h */ case    4:  		/* addi R10, R1, 80 */
		/* 82249980h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82249980h case    4:*/		return 0x82249984;
		  /* 82249984h */ case    5:  		/* lwzu R4, <#[R29 + 4]> */
		/* 82249984h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000004) );
		regs.R29 = (uint32)(regs.R29 + 0x00000004);
		/* 82249984h case    5:*/		return 0x82249988;
		  /* 82249988h */ case    6:  		/* mr R9, R27 */
		/* 82249988h case    6:*/		regs.R9 = regs.R27;
		/* 82249988h case    6:*/		return 0x8224998C;
		  /* 8224998Ch */ case    7:  		/* mr R8, R26 */
		/* 8224998Ch case    7:*/		regs.R8 = regs.R26;
		/* 8224998Ch case    7:*/		return 0x82249990;
		  /* 82249990h */ case    8:  		/* mr R7, R24 */
		/* 82249990h case    8:*/		regs.R7 = regs.R24;
		/* 82249990h case    8:*/		return 0x82249994;
		  /* 82249994h */ case    9:  		/* mr R6, R23 */
		/* 82249994h case    9:*/		regs.R6 = regs.R23;
		/* 82249994h case    9:*/		return 0x82249998;
		  /* 82249998h */ case   10:  		/* mr R5, R28 */
		/* 82249998h case   10:*/		regs.R5 = regs.R28;
		/* 82249998h case   10:*/		return 0x8224999C;
		  /* 8224999Ch */ case   11:  		/* mr R3, R30 */
		/* 8224999Ch case   11:*/		regs.R3 = regs.R30;
		/* 8224999Ch case   11:*/		return 0x822499A0;
		  /* 822499A0h */ case   12:  		/* bl -2888 */
		/* 822499A0h case   12:*/		regs.LR = 0x822499A4; return 0x82248E58;
		/* 822499A0h case   12:*/		return 0x822499A4;
		  /* 822499A4h */ case   13:  		/* addic. R31, R31, -1 */
		/* 822499A4h case   13:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 822499A4h case   13:*/		return 0x822499A8;
		  /* 822499A8h */ case   14:  		/* bc 4, CR0_EQ, -40 */
		/* 822499A8h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82249980;  }
		/* 822499A8h case   14:*/		return 0x822499AC;
		  /* 822499ACh */ case   15:  		/* lwz R25, <#[R1 + 80]> */
		/* 822499ACh case   15:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000050) );
		/* 822499ACh case   15:*/		return 0x822499B0;
	}
	return 0x822499B0;
} // Block from 82249970h-822499B0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822499B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822499B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822499B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822499B0);
		  /* 822499B0h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 822499B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 822499B0h case    0:*/		return 0x822499B4;
		  /* 822499B4h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 822499B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x822499C4;  }
		/* 822499B4h case    1:*/		return 0x822499B8;
		  /* 822499B8h */ case    2:  		/* li R4, 1 */
		/* 822499B8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822499B8h case    2:*/		return 0x822499BC;
		  /* 822499BCh */ case    3:  		/* mr R3, R27 */
		/* 822499BCh case    3:*/		regs.R3 = regs.R27;
		/* 822499BCh case    3:*/		return 0x822499C0;
	}
	return 0x822499C0;
} // Block from 822499B0h-822499C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822499C0h
// Function '?ScheduleCopies@CFG@XGRAPHICS@@AAAXPAVBlock@2@PAV?$Vector@_N@2@PAV?$Vector@H@2@22PAV?$Vector@PAVIRInst@XGRAPHICS@@@2@AAH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822499C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822499C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822499C0);
		  /* 822499C0h */ case    0:  		/* bl -40488 */
		/* 822499C0h case    0:*/		regs.LR = 0x822499C4; return 0x8223FB98;
		/* 822499C0h case    0:*/		return 0x822499C4;
	}
	return 0x822499C4;
} // Block from 822499C0h-822499C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822499C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822499C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822499C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822499C4);
		  /* 822499C4h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 822499C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 822499C4h case    0:*/		return 0x822499C8;
		  /* 822499C8h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 822499C8h case    1:*/		if ( regs.CR[6].eq ) { return 0x822499D8;  }
		/* 822499C8h case    1:*/		return 0x822499CC;
		  /* 822499CCh */ case    2:  		/* li R4, 1 */
		/* 822499CCh case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822499CCh case    2:*/		return 0x822499D0;
		  /* 822499D0h */ case    3:  		/* mr R3, R26 */
		/* 822499D0h case    3:*/		regs.R3 = regs.R26;
		/* 822499D0h case    3:*/		return 0x822499D4;
		  /* 822499D4h */ case    4:  		/* bl -40508 */
		/* 822499D4h case    4:*/		regs.LR = 0x822499D8; return 0x8223FB98;
		/* 822499D4h case    4:*/		return 0x822499D8;
	}
	return 0x822499D8;
} // Block from 822499C4h-822499D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822499D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822499D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822499D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822499D8);
		  /* 822499D8h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 822499D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 822499D8h case    0:*/		return 0x822499DC;
		  /* 822499DCh */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 822499DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x822499EC;  }
		/* 822499DCh case    1:*/		return 0x822499E0;
		  /* 822499E0h */ case    2:  		/* li R4, 1 */
		/* 822499E0h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822499E0h case    2:*/		return 0x822499E4;
		  /* 822499E4h */ case    3:  		/* mr R3, R24 */
		/* 822499E4h case    3:*/		regs.R3 = regs.R24;
		/* 822499E4h case    3:*/		return 0x822499E8;
		  /* 822499E8h */ case    4:  		/* bl -40528 */
		/* 822499E8h case    4:*/		regs.LR = 0x822499EC; return 0x8223FB98;
		/* 822499E8h case    4:*/		return 0x822499EC;
	}
	return 0x822499EC;
} // Block from 822499D8h-822499ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822499ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822499EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822499EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822499EC);
		  /* 822499ECh */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 822499ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 822499ECh case    0:*/		return 0x822499F0;
		  /* 822499F0h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 822499F0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82249A00;  }
		/* 822499F0h case    1:*/		return 0x822499F4;
		  /* 822499F4h */ case    2:  		/* li R4, 1 */
		/* 822499F4h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822499F4h case    2:*/		return 0x822499F8;
		  /* 822499F8h */ case    3:  		/* mr R3, R23 */
		/* 822499F8h case    3:*/		regs.R3 = regs.R23;
		/* 822499F8h case    3:*/		return 0x822499FC;
		  /* 822499FCh */ case    4:  		/* bl -40548 */
		/* 822499FCh case    4:*/		regs.LR = 0x82249A00; return 0x8223FB98;
		/* 822499FCh case    4:*/		return 0x82249A00;
	}
	return 0x82249A00;
} // Block from 822499ECh-82249A00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82249A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249A00);
		  /* 82249A00h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 82249A00h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82249A00h case    0:*/		return 0x82249A04;
		  /* 82249A04h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 82249A04h case    1:*/		if ( regs.CR[6].eq ) { return 0x82249A14;  }
		/* 82249A04h case    1:*/		return 0x82249A08;
		  /* 82249A08h */ case    2:  		/* li R4, 1 */
		/* 82249A08h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82249A08h case    2:*/		return 0x82249A0C;
		  /* 82249A0Ch */ case    3:  		/* mr R3, R28 */
		/* 82249A0Ch case    3:*/		regs.R3 = regs.R28;
		/* 82249A0Ch case    3:*/		return 0x82249A10;
		  /* 82249A10h */ case    4:  		/* bl -40568 */
		/* 82249A10h case    4:*/		regs.LR = 0x82249A14; return 0x8223FB98;
		/* 82249A10h case    4:*/		return 0x82249A14;
	}
	return 0x82249A14;
} // Block from 82249A00h-82249A14h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82249A14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249A14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249A14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249A14);
		  /* 82249A14h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82249A14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82249A14h case    0:*/		return 0x82249A18;
		  /* 82249A18h */ case    1:  		/* li R10, 1 */
		/* 82249A18h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82249A18h case    1:*/		return 0x82249A1C;
		  /* 82249A1Ch */ case    2:  		/* cmpwi CR6, R25, 0 */
		/* 82249A1Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82249A1Ch case    2:*/		return 0x82249A20;
		  /* 82249A20h */ case    3:  		/* stb R10, <#[R11 + 1396]> */
		/* 82249A20h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000574) );
		/* 82249A20h case    3:*/		return 0x82249A24;
		  /* 82249A24h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82249A24h case    4:*/		if ( regs.CR[6].eq ) { return 0x82249A3C;  }
		/* 82249A24h case    4:*/		return 0x82249A28;
		  /* 82249A28h */ case    5:  		/* lis R11, -32252 */
		/* 82249A28h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82249A28h case    5:*/		return 0x82249A2C;
		  /* 82249A2Ch */ case    6:  		/* lwz R3, <#[R30 + 12]> */
		/* 82249A2Ch case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 82249A2Ch case    6:*/		return 0x82249A30;
		  /* 82249A30h */ case    7:  		/* mr R5, R25 */
		/* 82249A30h case    7:*/		regs.R5 = regs.R25;
		/* 82249A30h case    7:*/		return 0x82249A34;
		  /* 82249A34h */ case    8:  		/* addi R4, R11, 13584 */
		/* 82249A34h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3510);
		/* 82249A34h case    8:*/		return 0x82249A38;
		  /* 82249A38h */ case    9:  		/* bl -181880 */
		/* 82249A38h case    9:*/		regs.LR = 0x82249A3C; return 0x8221D3C0;
		/* 82249A38h case    9:*/		return 0x82249A3C;
	}
	return 0x82249A3C;
} // Block from 82249A14h-82249A3Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82249A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249A3C);
		  /* 82249A3Ch */ case    0:  		/* addi R1, R1, 176 */
		/* 82249A3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82249A3Ch case    0:*/		return 0x82249A40;
		  /* 82249A40h */ case    1:  		/* b -1804204 */
		/* 82249A40h case    1:*/		return 0x82091294;
		/* 82249A40h case    1:*/		return 0x82249A44;
		  /* 82249A44h */ case    2:  		/* nop */
		/* 82249A44h case    2:*/		cpu::op::nop();
		/* 82249A44h case    2:*/		return 0x82249A48;
	}
	return 0x82249A48;
} // Block from 82249A3Ch-82249A48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82249A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249A48);
		  /* 82249A48h */ case    0:  		/* mfspr R12, LR */
		/* 82249A48h case    0:*/		regs.R12 = regs.LR;
		/* 82249A48h case    0:*/		return 0x82249A4C;
		  /* 82249A4Ch */ case    1:  		/* bl -1804332 */
		/* 82249A4Ch case    1:*/		regs.LR = 0x82249A50; return 0x82091220;
		/* 82249A4Ch case    1:*/		return 0x82249A50;
		  /* 82249A50h */ case    2:  		/* stwu R1, <#[R1 - 336]> */
		/* 82249A50h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEB0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEB0);
		/* 82249A50h case    2:*/		return 0x82249A54;
		  /* 82249A54h */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 82249A54h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82249A54h case    3:*/		return 0x82249A58;
		  /* 82249A58h */ case    4:  		/* mr R22, R3 */
		/* 82249A58h case    4:*/		regs.R22 = regs.R3;
		/* 82249A58h case    4:*/		return 0x82249A5C;
		  /* 82249A5Ch */ case    5:  		/* addi R3, R1, 144 */
		/* 82249A5Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x90);
		/* 82249A5Ch case    5:*/		return 0x82249A60;
		  /* 82249A60h */ case    6:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82249A60h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82249A60h case    6:*/		return 0x82249A64;
		  /* 82249A64h */ case    7:  		/* bl -81156 */
		/* 82249A64h case    7:*/		regs.LR = 0x82249A68; return 0x82235D60;
		/* 82249A64h case    7:*/		return 0x82249A68;
		  /* 82249A68h */ case    8:  		/* addi R3, R1, 144 */
		/* 82249A68h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x90);
		/* 82249A68h case    8:*/		return 0x82249A6C;
		  /* 82249A6Ch */ case    9:  		/* lwz R4, <#[R1 + 148]> */
		/* 82249A6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000094) );
		/* 82249A6Ch case    9:*/		return 0x82249A70;
		  /* 82249A70h */ case   10:  		/* lwz R31, <#[R22 + 164]> */
		/* 82249A70h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R22 + 0x000000A4) );
		/* 82249A70h case   10:*/		return 0x82249A74;
		  /* 82249A74h */ case   11:  		/* bl 41036 */
		/* 82249A74h case   11:*/		regs.LR = 0x82249A78; return 0x82253AC0;
		/* 82249A74h case   11:*/		return 0x82249A78;
		  /* 82249A78h */ case   12:  		/* mr R11, R3 */
		/* 82249A78h case   12:*/		regs.R11 = regs.R3;
		/* 82249A78h case   12:*/		return 0x82249A7C;
		  /* 82249A7Ch */ case   13:  		/* li R20, 0 */
		/* 82249A7Ch case   13:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 82249A7Ch case   13:*/		return 0x82249A80;
		  /* 82249A80h */ case   14:  		/* li R10, -1 */
		/* 82249A80h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82249A80h case   14:*/		return 0x82249A84;
		  /* 82249A84h */ case   15:  		/* addi R3, R1, 128 */
		/* 82249A84h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 82249A84h case   15:*/		return 0x82249A88;
		  /* 82249A88h */ case   16:  		/* stw R20, <#[R1 + 92]> */
		/* 82249A88h case   16:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x0000005C) );
		/* 82249A88h case   16:*/		return 0x82249A8C;
		  /* 82249A8Ch */ case   17:  		/* stw R20, <#[R1 + 84]> */
		/* 82249A8Ch case   17:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000054) );
		/* 82249A8Ch case   17:*/		return 0x82249A90;
		  /* 82249A90h */ case   18:  		/* stw R31, <#[R11]> */
		/* 82249A90h case   18:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82249A90h case   18:*/		return 0x82249A94;
		  /* 82249A94h */ case   19:  		/* lwz R11, <#[R22 + 12]> */
		/* 82249A94h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 82249A94h case   19:*/		return 0x82249A98;
		  /* 82249A98h */ case   20:  		/* lwz R21, <#[R22 + 164]> */
		/* 82249A98h case   20:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R22 + 0x000000A4) );
		/* 82249A98h case   20:*/		return 0x82249A9C;
		  /* 82249A9Ch */ case   21:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82249A9Ch case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82249A9Ch case   21:*/		return 0x82249AA0;
		  /* 82249AA0h */ case   22:  		/* stw R20, <#[R1 + 96]> */
		/* 82249AA0h case   22:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000060) );
		/* 82249AA0h case   22:*/		return 0x82249AA4;
		  /* 82249AA4h */ case   23:  		/* stw R20, <#[R1 + 100]> */
		/* 82249AA4h case   23:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000064) );
		/* 82249AA4h case   23:*/		return 0x82249AA8;
		  /* 82249AA8h */ case   24:  		/* stw R10, <#[R1 + 80]> */
		/* 82249AA8h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82249AA8h case   24:*/		return 0x82249AAC;
		  /* 82249AACh */ case   25:  		/* bl -81228 */
		/* 82249AACh case   25:*/		regs.LR = 0x82249AB0; return 0x82235D60;
		/* 82249AACh case   25:*/		return 0x82249AB0;
		  /* 82249AB0h */ case   26:  		/* lis R11, -32216 */
		/* 82249AB0h case   26:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82249AB0h case   26:*/		return 0x82249AB4;
		  /* 82249AB4h */ case   27:  		/* lis R9, -32252 */
		/* 82249AB4h case   27:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82249AB4h case   27:*/		return 0x82249AB8;
		  /* 82249AB8h */ case   28:  		/* lwz R14, <#[R1 + 168]> */
		/* 82249AB8h case   28:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x000000A8) );
		/* 82249AB8h case   28:*/		return 0x82249ABC;
		  /* 82249ABCh */ case   29:  		/* lis R7, -32252 */
		/* 82249ABCh case   29:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8204);
		/* 82249ABCh case   29:*/		return 0x82249AC0;
		  /* 82249AC0h */ case   30:  		/* lwz R18, <#[R1 + 164]> */
		/* 82249AC0h case   30:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x000000A4) );
		/* 82249AC0h case   30:*/		return 0x82249AC4;
		  /* 82249AC4h */ case   31:  		/* lis R10, -32251 */
		/* 82249AC4h case   31:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82249AC4h case   31:*/		return 0x82249AC8;
		  /* 82249AC8h */ case   32:  		/* lis R8, -32253 */
		/* 82249AC8h case   32:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8203);
		/* 82249AC8h case   32:*/		return 0x82249ACC;
		  /* 82249ACCh */ case   33:  		/* lis R6, -32252 */
		/* 82249ACCh case   33:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8204);
		/* 82249ACCh case   33:*/		return 0x82249AD0;
		  /* 82249AD0h */ case   34:  		/* addi R11, R11, 17992 */
		/* 82249AD0h case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4648);
		/* 82249AD0h case   34:*/		return 0x82249AD4;
		  /* 82249AD4h */ case   35:  		/* addi R9, R9, 13876 */
		/* 82249AD4h case   35:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x3634);
		/* 82249AD4h case   35:*/		return 0x82249AD8;
		  /* 82249AD8h */ case   36:  		/* addi R7, R7, 13864 */
		/* 82249AD8h case   36:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x3628);
		/* 82249AD8h case   36:*/		return 0x82249ADC;
		  /* 82249ADCh */ case   37:  		/* stw R11, <#[R1 + 108]> */
		/* 82249ADCh case   37:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82249ADCh case   37:*/		return 0x82249AE0;
		  /* 82249AE0h */ case   38:  		/* lis R17, -32252 */
		/* 82249AE0h case   38:*/		cpu::op::lis<0>(regs,&regs.R17,0xFFFF8204);
		/* 82249AE0h case   38:*/		return 0x82249AE4;
		  /* 82249AE4h */ case   39:  		/* stw R9, <#[R1 + 112]> */
		/* 82249AE4h case   39:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000070) );
		/* 82249AE4h case   39:*/		return 0x82249AE8;
		  /* 82249AE8h */ case   40:  		/* addi R19, R10, -19064 */
		/* 82249AE8h case   40:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R10,0xFFFFB588);
		/* 82249AE8h case   40:*/		return 0x82249AEC;
		  /* 82249AECh */ case   41:  		/* stw R7, <#[R1 + 104]> */
		/* 82249AECh case   41:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000068) );
		/* 82249AECh case   41:*/		return 0x82249AF0;
		  /* 82249AF0h */ case   42:  		/* addi R16, R8, 27460 */
		/* 82249AF0h case   42:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R8,0x6B44);
		/* 82249AF0h case   42:*/		return 0x82249AF4;
		  /* 82249AF4h */ case   43:  		/* addi R15, R6, 13424 */
		/* 82249AF4h case   43:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R6,0x3470);
		/* 82249AF4h case   43:*/		return 0x82249AF8;
		  /* 82249AF8h */ case   44:  		/* lwz R11, <#[R22 + 12]> */
		/* 82249AF8h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 82249AF8h case   44:*/		return 0x82249AFC;
		  /* 82249AFCh */ case   45:  		/* lwz R10, <#[R11 + 2136]> */
		/* 82249AFCh case   45:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000858) );
		/* 82249AFCh case   45:*/		return 0x82249B00;
		  /* 82249B00h */ case   46:  		/* rlwinm. R10, R10, 30, 31, 31 */
		/* 82249B00h case   46:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R10,regs.R10);
		/* 82249B00h case   46:*/		return 0x82249B04;
		  /* 82249B04h */ case   47:  		/* bc 12, CR0_EQ, 112 */
		/* 82249B04h case   47:*/		if ( regs.CR[0].eq ) { return 0x82249B74;  }
		/* 82249B04h case   47:*/		return 0x82249B08;
		  /* 82249B08h */ case   48:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82249B08h case   48:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82249B08h case   48:*/		return 0x82249B0C;
		  /* 82249B0Ch */ case   49:  		/* li R4, 28 */
		/* 82249B0Ch case   49:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 82249B0Ch case   49:*/		return 0x82249B10;
		  /* 82249B10h */ case   50:  		/* mr R3, R30 */
		/* 82249B10h case   50:*/		regs.R3 = regs.R30;
		/* 82249B10h case   50:*/		return 0x82249B14;
		  /* 82249B14h */ case   51:  		/* bl -185948 */
		/* 82249B14h case   51:*/		regs.LR = 0x82249B18; return 0x8221C4B8;
		/* 82249B14h case   51:*/		return 0x82249B18;
		  /* 82249B18h */ case   52:  		/* addic. R31, R3, 4 */
		/* 82249B18h case   52:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82249B18h case   52:*/		return 0x82249B1C;
		  /* 82249B1Ch */ case   53:  		/* stw R30, <#[R3]> */
		/* 82249B1Ch case   53:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82249B1Ch case   53:*/		return 0x82249B20;
		  /* 82249B20h */ case   54:  		/* bc 12, CR0_EQ, 44 */
		/* 82249B20h case   54:*/		if ( regs.CR[0].eq ) { return 0x82249B4C;  }
		/* 82249B20h case   54:*/		return 0x82249B24;
		  /* 82249B24h */ case   55:  		/* lwz R11, <#[R22 + 12]> */
		/* 82249B24h case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 82249B24h case   55:*/		return 0x82249B28;
		  /* 82249B28h */ case   56:  		/* lis R10, -32219 */
		/* 82249B28h case   56:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8225);
		/* 82249B28h case   56:*/		return 0x82249B2C;
		  /* 82249B2Ch */ case   57:  		/* lis R9, -32219 */
		/* 82249B2Ch case   57:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8225);
		/* 82249B2Ch case   57:*/		return 0x82249B30;
		  /* 82249B30h */ case   58:  		/* li R7, 16 */
		/* 82249B30h case   58:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 82249B30h case   58:*/		return 0x82249B34;
		  /* 82249B34h */ case   59:  		/* addi R6, R10, -31040 */
		/* 82249B34h case   59:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFF86C0);
		/* 82249B34h case   59:*/		return 0x82249B38;
		  /* 82249B38h */ case   60:  		/* addi R5, R9, -31312 */
		/* 82249B38h case   60:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0xFFFF85B0);
		/* 82249B38h case   60:*/		return 0x82249B3C;
		  /* 82249B3Ch */ case   61:  		/* mr R3, R31 */
		/* 82249B3Ch case   61:*/		regs.R3 = regs.R31;
		/* 82249B3Ch case   61:*/		return 0x82249B40;
		  /* 82249B40h */ case   62:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82249B40h case   62:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82249B40h case   62:*/		return 0x82249B44;
		  /* 82249B44h */ case   63:  		/* bl -19876 */
		/* 82249B44h case   63:*/		regs.LR = 0x82249B48; return 0x82244DA0;
		/* 82249B44h case   63:*/		return 0x82249B48;
		  /* 82249B48h */ case   64:  		/* b 8 */
		/* 82249B48h case   64:*/		return 0x82249B50;
		/* 82249B48h case   64:*/		return 0x82249B4C;
	}
	return 0x82249B4C;
} // Block from 82249A48h-82249B4Ch (65 instructions)

//////////////////////////////////////////////////////
// Block at 82249B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249B4C);
		  /* 82249B4Ch */ case    0:  		/* mr R31, R20 */
		/* 82249B4Ch case    0:*/		regs.R31 = regs.R20;
		/* 82249B4Ch case    0:*/		return 0x82249B50;
	}
	return 0x82249B50;
} // Block from 82249B4Ch-82249B50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249B50);
		  /* 82249B50h */ case    0:  		/* addi R3, R1, 128 */
		/* 82249B50h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 82249B50h case    0:*/		return 0x82249B54;
		  /* 82249B54h */ case    1:  		/* lwz R4, <#[R1 + 132]> */
		/* 82249B54h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82249B54h case    1:*/		return 0x82249B58;
		  /* 82249B58h */ case    2:  		/* stw R31, <#[R1 + 88]> */
		/* 82249B58h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000058) );
		/* 82249B58h case    2:*/		return 0x82249B5C;
		  /* 82249B5Ch */ case    3:  		/* bl 40804 */
		/* 82249B5Ch case    3:*/		regs.LR = 0x82249B60; return 0x82253AC0;
		/* 82249B5Ch case    3:*/		return 0x82249B60;
		  /* 82249B60h */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 82249B60h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82249B60h case    4:*/		return 0x82249B64;
		  /* 82249B64h */ case    5:  		/* stw R31, <#[R3]> */
		/* 82249B64h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82249B64h case    5:*/		return 0x82249B68;
		  /* 82249B68h */ case    6:  		/* addi R26, R11, 1 */
		/* 82249B68h case    6:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x1);
		/* 82249B68h case    6:*/		return 0x82249B6C;
		  /* 82249B6Ch */ case    7:  		/* stw R26, <#[R1 + 80]> */
		/* 82249B6Ch case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 82249B6Ch case    7:*/		return 0x82249B70;
		  /* 82249B70h */ case    8:  		/* b 8 */
		/* 82249B70h case    8:*/		return 0x82249B78;
		/* 82249B70h case    8:*/		return 0x82249B74;
	}
	return 0x82249B74;
} // Block from 82249B50h-82249B74h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82249B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249B74);
		  /* 82249B74h */ case    0:  		/* lwz R26, <#[R1 + 80]> */
		/* 82249B74h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 82249B74h case    0:*/		return 0x82249B78;
	}
	return 0x82249B78;
} // Block from 82249B74h-82249B78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249B78);
		  /* 82249B78h */ case    0:  		/* lwz R31, <#[R21 + 28]> */
		/* 82249B78h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R21 + 0x0000001C) );
		/* 82249B78h case    0:*/		return 0x82249B7C;
		  /* 82249B7Ch */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 82249B7Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82249B7Ch case    1:*/		return 0x82249B80;
		  /* 82249B80h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 82249B80h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82249B80h case    2:*/		return 0x82249B84;
		  /* 82249B84h */ case    3:  		/* bc 12, CR6_EQ, 2188 */
		/* 82249B84h case    3:*/		if ( regs.CR[6].eq ) { return 0x8224A410;  }
		/* 82249B84h case    3:*/		return 0x82249B88;
		  /* 82249B88h */ case    4:  		/* b 8 */
		/* 82249B88h case    4:*/		return 0x82249B90;
		/* 82249B88h case    4:*/		return 0x82249B8C;
		  /* 82249B8Ch */ case    5:  		/* lwz R26, <#[R1 + 80]> */
		/* 82249B8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 82249B8Ch case    5:*/		return 0x82249B90;
	}
	return 0x82249B90;
} // Block from 82249B78h-82249B90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82249B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249B90);
		  /* 82249B90h */ case    0:  		/* lwz R11, <#[R31 + 228]> */
		/* 82249B90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82249B90h case    0:*/		return 0x82249B94;
		  /* 82249B94h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82249B94h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82249B94h case    1:*/		return 0x82249B98;
		  /* 82249B98h */ case    2:  		/* bc 12, CR0_EQ, 2152 */
		/* 82249B98h case    2:*/		if ( regs.CR[0].eq ) { return 0x8224A400;  }
		/* 82249B98h case    2:*/		return 0x82249B9C;
		  /* 82249B9Ch */ case    3:  		/* lwz R11, <#[R31]> */
		/* 82249B9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82249B9Ch case    3:*/		return 0x82249BA0;
		  /* 82249BA0h */ case    4:  		/* mr R3, R31 */
		/* 82249BA0h case    4:*/		regs.R3 = regs.R31;
		/* 82249BA0h case    4:*/		return 0x82249BA4;
		  /* 82249BA4h */ case    5:  		/* lwz R11, <#[R11 + 36]> */
		/* 82249BA4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82249BA4h case    5:*/		return 0x82249BA8;
		  /* 82249BA8h */ case    6:  		/* mtspr CTR, R11 */
		/* 82249BA8h case    6:*/		regs.CTR = regs.R11;
		/* 82249BA8h case    6:*/		return 0x82249BAC;
		  /* 82249BACh */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82249BACh case    7:*/		if ( 1 ) { regs.LR = 0x82249BB0; return (uint32)regs.CTR; }
		/* 82249BACh case    7:*/		return 0x82249BB0;
		  /* 82249BB0h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82249BB0h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82249BB0h case    8:*/		return 0x82249BB4;
		  /* 82249BB4h */ case    9:  		/* bc 4, CR0_EQ, 2124 */
		/* 82249BB4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8224A400;  }
		/* 82249BB4h case    9:*/		return 0x82249BB8;
		  /* 82249BB8h */ case   10:  		/* lwz R11, <#[R31]> */
		/* 82249BB8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82249BB8h case   10:*/		return 0x82249BBC;
		  /* 82249BBCh */ case   11:  		/* mr R3, R31 */
		/* 82249BBCh case   11:*/		regs.R3 = regs.R31;
		/* 82249BBCh case   11:*/		return 0x82249BC0;
		  /* 82249BC0h */ case   12:  		/* lwz R11, <#[R11 + 40]> */
		/* 82249BC0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82249BC0h case   12:*/		return 0x82249BC4;
		  /* 82249BC4h */ case   13:  		/* mtspr CTR, R11 */
		/* 82249BC4h case   13:*/		regs.CTR = regs.R11;
		/* 82249BC4h case   13:*/		return 0x82249BC8;
		  /* 82249BC8h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 82249BC8h case   14:*/		if ( 1 ) { regs.LR = 0x82249BCC; return (uint32)regs.CTR; }
		/* 82249BC8h case   14:*/		return 0x82249BCC;
		  /* 82249BCCh */ case   15:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82249BCCh case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82249BCCh case   15:*/		return 0x82249BD0;
		  /* 82249BD0h */ case   16:  		/* bc 4, CR0_EQ, 2096 */
		/* 82249BD0h case   16:*/		if ( !regs.CR[0].eq ) { return 0x8224A400;  }
		/* 82249BD0h case   16:*/		return 0x82249BD4;
		  /* 82249BD4h */ case   17:  		/* lwz R3, <#[R31 + 28]> */
		/* 82249BD4h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 82249BD4h case   17:*/		return 0x82249BD8;
		  /* 82249BD8h */ case   18:  		/* addi R23, R31, 28 */
		/* 82249BD8h case   18:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R31,0x1C);
		/* 82249BD8h case   18:*/		return 0x82249BDC;
		  /* 82249BDCh */ case   19:  		/* cmplwi CR6, R3, 0 */
		/* 82249BDCh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82249BDCh case   19:*/		return 0x82249BE0;
		  /* 82249BE0h */ case   20:  		/* bc 12, CR6_EQ, 80 */
		/* 82249BE0h case   20:*/		if ( regs.CR[6].eq ) { return 0x82249C30;  }
		/* 82249BE0h case   20:*/		return 0x82249BE4;
		  /* 82249BE4h */ case   21:  		/* lbz R11, <#[R3 + 5]> */
		/* 82249BE4h case   21:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000005) );
		/* 82249BE4h case   21:*/		return 0x82249BE8;
		  /* 82249BE8h */ case   22:  		/* cmplwi CR0, R11, 0 */
		/* 82249BE8h case   22:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82249BE8h case   22:*/		return 0x82249BEC;
		  /* 82249BECh */ case   23:  		/* bc 12, CR0_EQ, 32 */
		/* 82249BECh case   23:*/		if ( regs.CR[0].eq ) { return 0x82249C0C;  }
		/* 82249BECh case   23:*/		return 0x82249BF0;
		  /* 82249BF0h */ case   24:  		/* lwz R10, <#[R31 + 80]> */
		/* 82249BF0h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 82249BF0h case   24:*/		return 0x82249BF4;
		  /* 82249BF4h */ case   25:  		/* lwz R9, <#[R31 + 228]> */
		/* 82249BF4h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000000E4) );
		/* 82249BF4h case   25:*/		return 0x82249BF8;
		  /* 82249BF8h */ case   26:  		/* lwz R11, <#[R3 + 16]> */
		/* 82249BF8h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82249BF8h case   26:*/		return 0x82249BFC;
		  /* 82249BFCh */ case   27:  		/* ori R9, R9, 64 */
		/* 82249BFCh case   27:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x40);
		/* 82249BFCh case   27:*/		return 0x82249C00;
		  /* 82249C00h */ case   28:  		/* stw R9, <#[R31 + 228]> */
		/* 82249C00h case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x000000E4) );
		/* 82249C00h case   28:*/		return 0x82249C04;
		  /* 82249C04h */ case   29:  		/* stw R10, <#[R31 + 80]> */
		/* 82249C04h case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 82249C04h case   29:*/		return 0x82249C08;
		  /* 82249C08h */ case   30:  		/* b 36 */
		/* 82249C08h case   30:*/		return 0x82249C2C;
		/* 82249C08h case   30:*/		return 0x82249C0C;
	}
	return 0x82249C0C;
} // Block from 82249B90h-82249C0Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 82249C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249C0C);
		  /* 82249C0Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82249C0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82249C0Ch case    0:*/		return 0x82249C10;
		  /* 82249C10h */ case    1:  		/* lwz R11, <#[R11 + 16]> */
		/* 82249C10h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82249C10h case    1:*/		return 0x82249C14;
		  /* 82249C14h */ case    2:  		/* mtspr CTR, R11 */
		/* 82249C14h case    2:*/		regs.CTR = regs.R11;
		/* 82249C14h case    2:*/		return 0x82249C18;
		  /* 82249C18h */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 82249C18h case    3:*/		if ( 1 ) { regs.LR = 0x82249C1C; return (uint32)regs.CTR; }
		/* 82249C18h case    3:*/		return 0x82249C1C;
		  /* 82249C1Ch */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82249C1Ch case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82249C1Ch case    4:*/		return 0x82249C20;
		  /* 82249C20h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82249C20h case    5:*/		if ( regs.CR[0].eq ) { return 0x82249C30;  }
		/* 82249C20h case    5:*/		return 0x82249C24;
		  /* 82249C24h */ case    6:  		/* lwz R11, <#[R31 + 224]> */
		/* 82249C24h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E0) );
		/* 82249C24h case    6:*/		return 0x82249C28;
		  /* 82249C28h */ case    7:  		/* stw R20, <#[R31 + 80]> */
		/* 82249C28h case    7:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R31 + 0x00000050) );
		/* 82249C28h case    7:*/		return 0x82249C2C;
	}
	return 0x82249C2C;
} // Block from 82249C0Ch-82249C2Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82249C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249C2C);
		  /* 82249C2Ch */ case    0:  		/* stw R11, <#[R31 + 56]> */
		/* 82249C2Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82249C2Ch case    0:*/		return 0x82249C30;
	}
	return 0x82249C30;
} // Block from 82249C2Ch-82249C30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249C30);
		  /* 82249C30h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82249C30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82249C30h case    0:*/		return 0x82249C34;
		  /* 82249C34h */ case    1:  		/* mr R3, R31 */
		/* 82249C34h case    1:*/		regs.R3 = regs.R31;
		/* 82249C34h case    1:*/		return 0x82249C38;
		  /* 82249C38h */ case    2:  		/* lwz R11, <#[R11 + 24]> */
		/* 82249C38h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82249C38h case    2:*/		return 0x82249C3C;
		  /* 82249C3Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 82249C3Ch case    3:*/		regs.CTR = regs.R11;
		/* 82249C3Ch case    3:*/		return 0x82249C40;
		  /* 82249C40h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82249C40h case    4:*/		if ( 1 ) { regs.LR = 0x82249C44; return (uint32)regs.CTR; }
		/* 82249C40h case    4:*/		return 0x82249C44;
		  /* 82249C44h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82249C44h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82249C44h case    5:*/		return 0x82249C48;
		  /* 82249C48h */ case    6:  		/* bc 12, CR0_EQ, 36 */
		/* 82249C48h case    6:*/		if ( regs.CR[0].eq ) { return 0x82249C6C;  }
		/* 82249C48h case    6:*/		return 0x82249C4C;
		  /* 82249C4Ch */ case    7:  		/* lwz R11, <#[R31 + 948]> */
		/* 82249C4Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000003B4) );
		/* 82249C4Ch case    7:*/		return 0x82249C50;
		  /* 82249C50h */ case    8:  		/* lwz R10, <#[R11 + 132]> */
		/* 82249C50h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000084) );
		/* 82249C50h case    8:*/		return 0x82249C54;
		  /* 82249C54h */ case    9:  		/* ori R10, R10, 1 */
		/* 82249C54h case    9:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82249C54h case    9:*/		return 0x82249C58;
		  /* 82249C58h */ case   10:  		/* stw R10, <#[R11 + 132]> */
		/* 82249C58h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000084) );
		/* 82249C58h case   10:*/		return 0x82249C5C;
		  /* 82249C5Ch */ case   11:  		/* lwz R11, <#[R31 + 948]> */
		/* 82249C5Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000003B4) );
		/* 82249C5Ch case   11:*/		return 0x82249C60;
		  /* 82249C60h */ case   12:  		/* lwz R10, <#[R11 + 132]> */
		/* 82249C60h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000084) );
		/* 82249C60h case   12:*/		return 0x82249C64;
		  /* 82249C64h */ case   13:  		/* ori R10, R10, 2 */
		/* 82249C64h case   13:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82249C64h case   13:*/		return 0x82249C68;
		  /* 82249C68h */ case   14:  		/* stw R10, <#[R11 + 132]> */
		/* 82249C68h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000084) );
		/* 82249C68h case   14:*/		return 0x82249C6C;
	}
	return 0x82249C6C;
} // Block from 82249C30h-82249C6Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82249C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249C6C);
		  /* 82249C6Ch */ case    0:  		/* lwz R11, <#[R31 + 80]> */
		/* 82249C6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 82249C6Ch case    0:*/		return 0x82249C70;
		  /* 82249C70h */ case    1:  		/* cmpwi CR6, R11, 31 */
		/* 82249C70h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001F);
		/* 82249C70h case    1:*/		return 0x82249C74;
		  /* 82249C74h */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 82249C74h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82249C94;  }
		/* 82249C74h case    2:*/		return 0x82249C78;
		  /* 82249C78h */ case    3:  		/* lwz R11, <#[R31 + 56]> */
		/* 82249C78h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82249C78h case    3:*/		return 0x82249C7C;
		  /* 82249C7Ch */ case    4:  		/* cmpwi CR6, R11, 2 */
		/* 82249C7Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 82249C7Ch case    4:*/		return 0x82249C80;
		  /* 82249C80h */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 82249C80h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82249C94;  }
		/* 82249C80h case    5:*/		return 0x82249C84;
		  /* 82249C84h */ case    6:  		/* lwz R11, <#[R31 + 948]> */
		/* 82249C84h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000003B4) );
		/* 82249C84h case    6:*/		return 0x82249C88;
		  /* 82249C88h */ case    7:  		/* lwz R10, <#[R11 + 132]> */
		/* 82249C88h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000084) );
		/* 82249C88h case    7:*/		return 0x82249C8C;
		  /* 82249C8Ch */ case    8:  		/* ori R10, R10, 4 */
		/* 82249C8Ch case    8:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82249C8Ch case    8:*/		return 0x82249C90;
		  /* 82249C90h */ case    9:  		/* stw R10, <#[R11 + 132]> */
		/* 82249C90h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000084) );
		/* 82249C90h case    9:*/		return 0x82249C94;
	}
	return 0x82249C94;
} // Block from 82249C6Ch-82249C94h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82249C94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249C94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249C94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249C94);
		  /* 82249C94h */ case    0:  		/* lwz R11, <#[R22 + 12]> */
		/* 82249C94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 82249C94h case    0:*/		return 0x82249C98;
		  /* 82249C98h */ case    1:  		/* li R4, 272 */
		/* 82249C98h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x110);
		/* 82249C98h case    1:*/		return 0x82249C9C;
		  /* 82249C9Ch */ case    2:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82249C9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82249C9Ch case    2:*/		return 0x82249CA0;
		  /* 82249CA0h */ case    3:  		/* mr R3, R30 */
		/* 82249CA0h case    3:*/		regs.R3 = regs.R30;
		/* 82249CA0h case    3:*/		return 0x82249CA4;
		  /* 82249CA4h */ case    4:  		/* bl -186348 */
		/* 82249CA4h case    4:*/		regs.LR = 0x82249CA8; return 0x8221C4B8;
		/* 82249CA4h case    4:*/		return 0x82249CA8;
		  /* 82249CA8h */ case    5:  		/* addic. R11, R3, 4 */
		/* 82249CA8h case    5:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 82249CA8h case    5:*/		return 0x82249CAC;
		  /* 82249CACh */ case    6:  		/* stw R30, <#[R3]> */
		/* 82249CACh case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82249CACh case    6:*/		return 0x82249CB0;
		  /* 82249CB0h */ case    7:  		/* bc 12, CR0_EQ, 48 */
		/* 82249CB0h case    7:*/		if ( regs.CR[0].eq ) { return 0x82249CE0;  }
		/* 82249CB0h case    7:*/		return 0x82249CB4;
		  /* 82249CB4h */ case    8:  		/* lwz R9, <#[R22 + 12]> */
		/* 82249CB4h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x0000000C) );
		/* 82249CB4h case    8:*/		return 0x82249CB8;
		  /* 82249CB8h */ case    9:  		/* li R10, 3 */
		/* 82249CB8h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 82249CB8h case    9:*/		return 0x82249CBC;
		  /* 82249CBCh */ case   10:  		/* stw R31, <#[R11 + 16]> */
		/* 82249CBCh case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000010) );
		/* 82249CBCh case   10:*/		return 0x82249CC0;
		  /* 82249CC0h */ case   11:  		/* mr R24, R11 */
		/* 82249CC0h case   11:*/		regs.R24 = regs.R11;
		/* 82249CC0h case   11:*/		return 0x82249CC4;
		  /* 82249CC4h */ case   12:  		/* stb R20, <#[R11 + 264]> */
		/* 82249CC4h case   12:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R11 + 0x00000108) );
		/* 82249CC4h case   12:*/		return 0x82249CC8;
		  /* 82249CC8h */ case   13:  		/* stw R10, <#[R11]> */
		/* 82249CC8h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82249CC8h case   13:*/		return 0x82249CCC;
		  /* 82249CCCh */ case   14:  		/* stw R10, <#[R11 + 4]> */
		/* 82249CCCh case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82249CCCh case   14:*/		return 0x82249CD0;
		  /* 82249CD0h */ case   15:  		/* stw R9, <#[R11 + 260]> */
		/* 82249CD0h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000104) );
		/* 82249CD0h case   15:*/		return 0x82249CD4;
		  /* 82249CD4h */ case   16:  		/* stw R10, <#[R11 + 8]> */
		/* 82249CD4h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82249CD4h case   16:*/		return 0x82249CD8;
		  /* 82249CD8h */ case   17:  		/* stw R10, <#[R11 + 12]> */
		/* 82249CD8h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82249CD8h case   17:*/		return 0x82249CDC;
		  /* 82249CDCh */ case   18:  		/* b 8 */
		/* 82249CDCh case   18:*/		return 0x82249CE4;
		/* 82249CDCh case   18:*/		return 0x82249CE0;
	}
	return 0x82249CE0;
} // Block from 82249C94h-82249CE0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82249CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249CE0);
		  /* 82249CE0h */ case    0:  		/* mr R24, R20 */
		/* 82249CE0h case    0:*/		regs.R24 = regs.R20;
		/* 82249CE0h case    0:*/		return 0x82249CE4;
	}
	return 0x82249CE4;
} // Block from 82249CE0h-82249CE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249CE4);
		  /* 82249CE4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82249CE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82249CE4h case    0:*/		return 0x82249CE8;
		  /* 82249CE8h */ case    1:  		/* mr R3, R31 */
		/* 82249CE8h case    1:*/		regs.R3 = regs.R31;
		/* 82249CE8h case    1:*/		return 0x82249CEC;
		  /* 82249CECh */ case    2:  		/* lwz R11, <#[R11 + 44]> */
		/* 82249CECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 82249CECh case    2:*/		return 0x82249CF0;
		  /* 82249CF0h */ case    3:  		/* mtspr CTR, R11 */
		/* 82249CF0h case    3:*/		regs.CTR = regs.R11;
		/* 82249CF0h case    3:*/		return 0x82249CF4;
		  /* 82249CF4h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82249CF4h case    4:*/		if ( 1 ) { regs.LR = 0x82249CF8; return (uint32)regs.CTR; }
		/* 82249CF4h case    4:*/		return 0x82249CF8;
		  /* 82249CF8h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 82249CF8h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82249CF8h case    5:*/		return 0x82249CFC;
		  /* 82249CFCh */ case    6:  		/* bc 12, CR0_EQ, 316 */
		/* 82249CFCh case    6:*/		if ( regs.CR[0].eq ) { return 0x82249E38;  }
		/* 82249CFCh case    6:*/		return 0x82249D00;
		  /* 82249D00h */ case    7:  		/* lwz R9, <#[R22 + 12]> */
		/* 82249D00h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x0000000C) );
		/* 82249D00h case    7:*/		return 0x82249D04;
		  /* 82249D04h */ case    8:  		/* lwz R11, <#[R9 + 2136]> */
		/* 82249D04h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000858) );
		/* 82249D04h case    8:*/		return 0x82249D08;
		  /* 82249D08h */ case    9:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 82249D08h case    9:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82249D08h case    9:*/		return 0x82249D0C;
		  /* 82249D0Ch */ case   10:  		/* bc 12, CR0_EQ, 1644 */
		/* 82249D0Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x8224A378;  }
		/* 82249D0Ch case   10:*/		return 0x82249D10;
		  /* 82249D10h */ case   11:  		/* lwz R10, <#[R31 + 20]> */
		/* 82249D10h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82249D10h case   11:*/		return 0x82249D14;
		  /* 82249D14h */ case   12:  		/* li R11, 1 */
		/* 82249D14h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82249D14h case   12:*/		return 0x82249D18;
		  /* 82249D18h */ case   13:  		/* cmpwi CR6, R10, 1 */
		/* 82249D18h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 82249D18h case   13:*/		return 0x82249D1C;
		  /* 82249D1Ch */ case   14:  		/* bc 12, CR6_LT, 40 */
		/* 82249D1Ch case   14:*/		if ( regs.CR[6].lt ) { return 0x82249D44;  }
		/* 82249D1Ch case   14:*/		return 0x82249D20;
		  /* 82249D20h */ case   15:  		/* addi R10, R31, 236 */
		/* 82249D20h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xEC);
		/* 82249D20h case   15:*/		return 0x82249D24;
		  /* 82249D24h */ case   16:  		/* lwz R8, <#[R10]> */
		/* 82249D24h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82249D24h case   16:*/		return 0x82249D28;
		  /* 82249D28h */ case   17:  		/* cmplwi CR6, R8, 0 */
		/* 82249D28h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82249D28h case   17:*/		return 0x82249D2C;
		  /* 82249D2Ch */ case   18:  		/* bc 12, CR6_EQ, 144 */
		/* 82249D2Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x82249DBC;  }
		/* 82249D2Ch case   18:*/		return 0x82249D30;
		  /* 82249D30h */ case   19:  		/* lwz R8, <#[R31 + 20]> */
		/* 82249D30h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 82249D30h case   19:*/		return 0x82249D34;
		  /* 82249D34h */ case   20:  		/* addi R11, R11, 1 */
		/* 82249D34h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82249D34h case   20:*/		return 0x82249D38;
		  /* 82249D38h */ case   21:  		/* addi R10, R10, 4 */
		/* 82249D38h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82249D38h case   21:*/		return 0x82249D3C;
		  /* 82249D3Ch */ case   22:  		/* cmpw CR6, R11, R8 */
		/* 82249D3Ch case   22:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 82249D3Ch case   22:*/		return 0x82249D40;
		  /* 82249D40h */ case   23:  		/* bc 4, CR6_GT, -28 */
		/* 82249D40h case   23:*/		if ( !regs.CR[6].gt ) { return 0x82249D24;  }
		/* 82249D40h case   23:*/		return 0x82249D44;
	}
	return 0x82249D44;
} // Block from 82249CE4h-82249D44h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82249D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249D44);
		  /* 82249D44h */ case    0:  		/* li R11, 1 */
		/* 82249D44h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82249D44h case    0:*/		return 0x82249D48;
		  /* 82249D48h */ case    1:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82249D48h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82249D48h case    1:*/		return 0x82249D4C;
		  /* 82249D4Ch */ case    2:  		/* bc 12, CR0_EQ, 1580 */
		/* 82249D4Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8224A378;  }
		/* 82249D4Ch case    2:*/		return 0x82249D50;
		  /* 82249D50h */ case    3:  		/* lwz R11, <#[R9 + 2716]> */
		/* 82249D50h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000A9C) );
		/* 82249D50h case    3:*/		return 0x82249D54;
		  /* 82249D54h */ case    4:  		/* lwz R10, <#[R1 + 84]> */
		/* 82249D54h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82249D54h case    4:*/		return 0x82249D58;
		  /* 82249D58h */ case    5:  		/* cmpw CR6, R10, R11 */
		/* 82249D58h case    5:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82249D58h case    5:*/		return 0x82249D5C;
		  /* 82249D5Ch */ case    6:  		/* bc 4, CR6_LT, 1564 */
		/* 82249D5Ch case    6:*/		if ( !regs.CR[6].lt ) { return 0x8224A378;  }
		/* 82249D5Ch case    6:*/		return 0x82249D60;
		  /* 82249D60h */ case    7:  		/* mr R3, R31 */
		/* 82249D60h case    7:*/		regs.R3 = regs.R31;
		/* 82249D60h case    7:*/		return 0x82249D64;
		  /* 82249D64h */ case    8:  		/* bl -5900 */
		/* 82249D64h case    8:*/		regs.LR = 0x82249D68; return 0x82248658;
		/* 82249D64h case    8:*/		return 0x82249D68;
		  /* 82249D68h */ case    9:  		/* rlwinm. R29, R3, 0, 24, 31 */
		/* 82249D68h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R29,regs.R3);
		/* 82249D68h case    9:*/		return 0x82249D6C;
		  /* 82249D6Ch */ case   10:  		/* bc 12, CR0_EQ, 36 */
		/* 82249D6Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x82249D90;  }
		/* 82249D6Ch case   10:*/		return 0x82249D70;
		  /* 82249D70h */ case   11:  		/* lwz R11, <#[R31 + 236]> */
		/* 82249D70h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000EC) );
		/* 82249D70h case   11:*/		return 0x82249D74;
		  /* 82249D74h */ case   12:  		/* mr R3, R21 */
		/* 82249D74h case   12:*/		regs.R3 = regs.R21;
		/* 82249D74h case   12:*/		return 0x82249D78;
		  /* 82249D78h */ case   13:  		/* lwz R4, <#[R23]> */
		/* 82249D78h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000000) );
		/* 82249D78h case   13:*/		return 0x82249D7C;
		  /* 82249D7Ch */ case   14:  		/* lwz R11, <#[R11 + 28]> */
		/* 82249D7Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82249D7Ch case   14:*/		return 0x82249D80;
		  /* 82249D80h */ case   15:  		/* lwz R11, <#[R11 + 44]> */
		/* 82249D80h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 82249D80h case   15:*/		return 0x82249D84;
		  /* 82249D84h */ case   16:  		/* lwz R11, <#[R11 + 4]> */
		/* 82249D84h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82249D84h case   16:*/		return 0x82249D88;
		  /* 82249D88h */ case   17:  		/* lwz R5, <#[R11]> */
		/* 82249D88h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 82249D88h case   17:*/		return 0x82249D8C;
		  /* 82249D8Ch */ case   18:  		/* bl 64972 */
		/* 82249D8Ch case   18:*/		regs.LR = 0x82249D90; return 0x82259B58;
		/* 82249D8Ch case   18:*/		return 0x82249D90;
	}
	return 0x82249D90;
} // Block from 82249D44h-82249D90h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82249D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249D90);
		  /* 82249D90h */ case    0:  		/* mr R30, R20 */
		/* 82249D90h case    0:*/		regs.R30 = regs.R20;
		/* 82249D90h case    0:*/		return 0x82249D94;
		  /* 82249D94h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 82249D94h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82249D94h case    1:*/		return 0x82249D98;
		  /* 82249D98h */ case    2:  		/* bc 4, CR6_EQ, 124 */
		/* 82249D98h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82249E14;  }
		/* 82249D98h case    2:*/		return 0x82249D9C;
		  /* 82249D9Ch */ case    3:  		/* lwz R11, <#[R1 + 132]> */
		/* 82249D9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 82249D9Ch case    3:*/		return 0x82249DA0;
		  /* 82249DA0h */ case    4:  		/* lwz R4, <#[R1 + 80]> */
		/* 82249DA0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 82249DA0h case    4:*/		return 0x82249DA4;
		  /* 82249DA4h */ case    5:  		/* cmplw CR6, R4, R11 */
		/* 82249DA4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82249DA4h case    5:*/		return 0x82249DA8;
		  /* 82249DA8h */ case    6:  		/* bc 4, CR6_LT, 28 */
		/* 82249DA8h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82249DC4;  }
		/* 82249DA8h case    6:*/		return 0x82249DAC;
		  /* 82249DACh */ case    7:  		/* lwz R11, <#[R1 + 136]> */
		/* 82249DACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82249DACh case    7:*/		return 0x82249DB0;
		  /* 82249DB0h */ case    8:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 82249DB0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 82249DB0h case    8:*/		return 0x82249DB4;
		  /* 82249DB4h */ case    9:  		/* add R3, R10, R11 */
		/* 82249DB4h case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82249DB4h case    9:*/		return 0x82249DB8;
		  /* 82249DB8h */ case   10:  		/* b 20 */
		/* 82249DB8h case   10:*/		return 0x82249DCC;
		/* 82249DB8h case   10:*/		return 0x82249DBC;
	}
	return 0x82249DBC;
} // Block from 82249D90h-82249DBCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82249DBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249DBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249DBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249DBC);
		  /* 82249DBCh */ case    0:  		/* mr R11, R20 */
		/* 82249DBCh case    0:*/		regs.R11 = regs.R20;
		/* 82249DBCh case    0:*/		return 0x82249DC0;
		  /* 82249DC0h */ case    1:  		/* b -120 */
		/* 82249DC0h case    1:*/		return 0x82249D48;
		/* 82249DC0h case    1:*/		return 0x82249DC4;
	}
	return 0x82249DC4;
} // Block from 82249DBCh-82249DC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82249DC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249DC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249DC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249DC4);
		  /* 82249DC4h */ case    0:  		/* addi R3, R1, 128 */
		/* 82249DC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 82249DC4h case    0:*/		return 0x82249DC8;
		  /* 82249DC8h */ case    1:  		/* bl 40184 */
		/* 82249DC8h case    1:*/		regs.LR = 0x82249DCC; return 0x82253AC0;
		/* 82249DC8h case    1:*/		return 0x82249DCC;
	}
	return 0x82249DCC;
} // Block from 82249DC4h-82249DCCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82249DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249DCC);
		  /* 82249DCCh */ case    0:  		/* mr R4, R24 */
		/* 82249DCCh case    0:*/		regs.R4 = regs.R24;
		/* 82249DCCh case    0:*/		return 0x82249DD0;
		  /* 82249DD0h */ case    1:  		/* lwz R3, <#[R3]> */
		/* 82249DD0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 82249DD0h case    1:*/		return 0x82249DD4;
		  /* 82249DD4h */ case    2:  		/* lwz R5, <#[R22 + 12]> */
		/* 82249DD4h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R22 + 0x0000000C) );
		/* 82249DD4h case    2:*/		return 0x82249DD8;
		  /* 82249DD8h */ case    3:  		/* bl -4808 */
		/* 82249DD8h case    3:*/		regs.LR = 0x82249DDC; return 0x82248B10;
		/* 82249DD8h case    3:*/		return 0x82249DDC;
		  /* 82249DDCh */ case    4:  		/* or. R5, R3, R3 */
		/* 82249DDCh case    4:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 82249DDCh case    4:*/		return 0x82249DE0;
		  /* 82249DE0h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 82249DE0h case    5:*/		if ( regs.CR[0].eq ) { return 0x82249DF4;  }
		/* 82249DE0h case    5:*/		return 0x82249DE4;
		  /* 82249DE4h */ case    6:  		/* mr R3, R21 */
		/* 82249DE4h case    6:*/		regs.R3 = regs.R21;
		/* 82249DE4h case    6:*/		return 0x82249DE8;
		  /* 82249DE8h */ case    7:  		/* lwz R4, <#[R23]> */
		/* 82249DE8h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000000) );
		/* 82249DE8h case    7:*/		return 0x82249DEC;
		  /* 82249DECh */ case    8:  		/* li R30, 1 */
		/* 82249DECh case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82249DECh case    8:*/		return 0x82249DF0;
		  /* 82249DF0h */ case    9:  		/* bl 64872 */
		/* 82249DF0h case    9:*/		regs.LR = 0x82249DF4; return 0x82259B58;
		/* 82249DF0h case    9:*/		return 0x82249DF4;
	}
	return 0x82249DF4;
} // Block from 82249DCCh-82249DF4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82249DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249DF4);
		  /* 82249DF4h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82249DF4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82249DF4h case    0:*/		return 0x82249DF8;
		  /* 82249DF8h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82249DF8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82249E14;  }
		/* 82249DF8h case    1:*/		return 0x82249DFC;
		  /* 82249DFCh */ case    2:  		/* rlwinm. R11, R30, 0, 24, 31 */
		/* 82249DFCh case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R30);
		/* 82249DFCh case    2:*/		return 0x82249E00;
		  /* 82249E00h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 82249E00h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82249E14;  }
		/* 82249E00h case    3:*/		return 0x82249E04;
		  /* 82249E04h */ case    4:  		/* mr R4, R24 */
		/* 82249E04h case    4:*/		regs.R4 = regs.R24;
		/* 82249E04h case    4:*/		return 0x82249E08;
		  /* 82249E08h */ case    5:  		/* lwz R3, <#[R1 + 88]> */
		/* 82249E08h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 82249E08h case    5:*/		return 0x82249E0C;
		  /* 82249E0Ch */ case    6:  		/* bl -4332 */
		/* 82249E0Ch case    6:*/		regs.LR = 0x82249E10; return 0x82248D20;
		/* 82249E0Ch case    6:*/		return 0x82249E10;
		  /* 82249E10h */ case    7:  		/* b 1384 */
		/* 82249E10h case    7:*/		return 0x8224A378;
		/* 82249E10h case    7:*/		return 0x82249E14;
	}
	return 0x82249E14;
} // Block from 82249DF4h-82249E14h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82249E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249E14);
		  /* 82249E14h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82249E14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82249E14h case    0:*/		return 0x82249E18;
		  /* 82249E18h */ case    1:  		/* mr R3, R31 */
		/* 82249E18h case    1:*/		regs.R3 = regs.R31;
		/* 82249E18h case    1:*/		return 0x82249E1C;
		  /* 82249E1Ch */ case    2:  		/* lwz R11, <#[R11 + 96]> */
		/* 82249E1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 82249E1Ch case    2:*/		return 0x82249E20;
		  /* 82249E20h */ case    3:  		/* mtspr CTR, R11 */
		/* 82249E20h case    3:*/		regs.CTR = regs.R11;
		/* 82249E20h case    3:*/		return 0x82249E24;
		  /* 82249E24h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82249E24h case    4:*/		if ( 1 ) { regs.LR = 0x82249E28; return (uint32)regs.CTR; }
		/* 82249E24h case    4:*/		return 0x82249E28;
		  /* 82249E28h */ case    5:  		/* lwz R11, <#[R1 + 96]> */
		/* 82249E28h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82249E28h case    5:*/		return 0x82249E2C;
		  /* 82249E2Ch */ case    6:  		/* addi R11, R11, 1 */
		/* 82249E2Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82249E2Ch case    6:*/		return 0x82249E30;
		  /* 82249E30h */ case    7:  		/* stw R11, <#[R1 + 96]> */
		/* 82249E30h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82249E30h case    7:*/		return 0x82249E34;
		  /* 82249E34h */ case    8:  		/* b 1484 */
		/* 82249E34h case    8:*/		return 0x8224A400;
		/* 82249E34h case    8:*/		return 0x82249E38;
	}
	return 0x82249E38;
} // Block from 82249E14h-82249E38h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82249E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249E38);
		  /* 82249E38h */ case    0:  		/* lwz R11, <#[R22 + 12]> */
		/* 82249E38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 82249E38h case    0:*/		return 0x82249E3C;
		  /* 82249E3Ch */ case    1:  		/* lwz R11, <#[R11 + 2136]> */
		/* 82249E3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000858) );
		/* 82249E3Ch case    1:*/		return 0x82249E40;
		  /* 82249E40h */ case    2:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82249E40h case    2:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82249E40h case    2:*/		return 0x82249E44;
		  /* 82249E44h */ case    3:  		/* bc 12, CR0_EQ, 200 */
		/* 82249E44h case    3:*/		if ( regs.CR[0].eq ) { return 0x82249F0C;  }
		/* 82249E44h case    3:*/		return 0x82249E48;
		  /* 82249E48h */ case    4:  		/* mr R3, R31 */
		/* 82249E48h case    4:*/		regs.R3 = regs.R31;
		/* 82249E48h case    4:*/		return 0x82249E4C;
		  /* 82249E4Ch */ case    5:  		/* bl -34644 */
		/* 82249E4Ch case    5:*/		regs.LR = 0x82249E50; return 0x822416F8;
		/* 82249E4Ch case    5:*/		return 0x82249E50;
		  /* 82249E50h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82249E50h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82249E50h case    6:*/		return 0x82249E54;
		  /* 82249E54h */ case    7:  		/* bc 12, CR0_EQ, 184 */
		/* 82249E54h case    7:*/		if ( regs.CR[0].eq ) { return 0x82249F0C;  }
		/* 82249E54h case    7:*/		return 0x82249E58;
		  /* 82249E58h */ case    8:  		/* lwz R11, <#[R31 + 236]> */
		/* 82249E58h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000EC) );
		/* 82249E58h case    8:*/		return 0x82249E5C;
		  /* 82249E5Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82249E5Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82249E5Ch case    9:*/		return 0x82249E60;
		  /* 82249E60h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82249E60h case   10:*/		if ( regs.CR[6].eq ) { return 0x82249E6C;  }
		/* 82249E60h case   10:*/		return 0x82249E64;
		  /* 82249E64h */ case   11:  		/* lwz R11, <#[R11 + 80]> */
		/* 82249E64h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82249E64h case   11:*/		return 0x82249E68;
		  /* 82249E68h */ case   12:  		/* b 8 */
		/* 82249E68h case   12:*/		return 0x82249E70;
		/* 82249E68h case   12:*/		return 0x82249E6C;
	}
	return 0x82249E6C;
} // Block from 82249E38h-82249E6Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82249E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249E6C);
		  /* 82249E6Ch */ case    0:  		/* lwz R11, <#[R31 + 84]> */
		/* 82249E6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 82249E6Ch case    0:*/		return 0x82249E70;
	}
	return 0x82249E70;
} // Block from 82249E6Ch-82249E70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249E70);
		  /* 82249E70h */ case    0:  		/* mulli R11, R11, 12 */
		/* 82249E70h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82249E70h case    0:*/		return 0x82249E74;
		  /* 82249E74h */ case    1:  		/* addi R10, R19, 6 */
		/* 82249E74h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R19,0x6);
		/* 82249E74h case    1:*/		return 0x82249E78;
		  /* 82249E78h */ case    2:  		/* lbzx R11, <#[R11 + R10]> */
		/* 82249E78h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82249E78h case    2:*/		return 0x82249E7C;
		  /* 82249E7Ch */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 82249E7Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82249E7Ch case    3:*/		return 0x82249E80;
		  /* 82249E80h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82249E80h case    4:*/		if ( regs.CR[0].eq ) { return 0x82249E90;  }
		/* 82249E80h case    4:*/		return 0x82249E84;
		  /* 82249E84h */ case    5:  		/* cmplwi CR6, R11, 4 */
		/* 82249E84h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82249E84h case    5:*/		return 0x82249E88;
		  /* 82249E88h */ case    6:  		/* li R11, 1 */
		/* 82249E88h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82249E88h case    6:*/		return 0x82249E8C;
		  /* 82249E8Ch */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 82249E8Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x82249E94;  }
		/* 82249E8Ch case    7:*/		return 0x82249E90;
	}
	return 0x82249E90;
} // Block from 82249E70h-82249E90h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82249E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249E90);
		  /* 82249E90h */ case    0:  		/* mr R11, R20 */
		/* 82249E90h case    0:*/		regs.R11 = regs.R20;
		/* 82249E90h case    0:*/		return 0x82249E94;
	}
	return 0x82249E94;
} // Block from 82249E90h-82249E94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249E94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249E94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249E94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249E94);
		  /* 82249E94h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82249E94h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82249E94h case    0:*/		return 0x82249E98;
		  /* 82249E98h */ case    1:  		/* bc 4, CR0_EQ, 116 */
		/* 82249E98h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82249F0C;  }
		/* 82249E98h case    1:*/		return 0x82249E9C;
		  /* 82249E9Ch */ case    2:  		/* lwz R11, <#[R31 + 228]> */
		/* 82249E9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82249E9Ch case    2:*/		return 0x82249EA0;
		  /* 82249EA0h */ case    3:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 82249EA0h case    3:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 82249EA0h case    3:*/		return 0x82249EA4;
		  /* 82249EA4h */ case    4:  		/* bc 12, CR0_EQ, 24 */
		/* 82249EA4h case    4:*/		if ( regs.CR[0].eq ) { return 0x82249EBC;  }
		/* 82249EA4h case    4:*/		return 0x82249EA8;
		  /* 82249EA8h */ case    5:  		/* mr R3, R22 */
		/* 82249EA8h case    5:*/		regs.R3 = regs.R22;
		/* 82249EA8h case    5:*/		return 0x82249EAC;
		  /* 82249EACh */ case    6:  		/* lwz R4, <#[R31 + 56]> */
		/* 82249EACh case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000038) );
		/* 82249EACh case    6:*/		return 0x82249EB0;
		  /* 82249EB0h */ case    7:  		/* bl -10544 */
		/* 82249EB0h case    7:*/		regs.LR = 0x82249EB4; return 0x82247580;
		/* 82249EB0h case    7:*/		return 0x82249EB4;
		  /* 82249EB4h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82249EB4h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82249EB4h case    8:*/		return 0x82249EB8;
		  /* 82249EB8h */ case    9:  		/* bc 12, CR0_EQ, 84 */
		/* 82249EB8h case    9:*/		if ( regs.CR[0].eq ) { return 0x82249F0C;  }
		/* 82249EB8h case    9:*/		return 0x82249EBC;
	}
	return 0x82249EBC;
} // Block from 82249E94h-82249EBCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 82249EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249EBC);
		  /* 82249EBCh */ case    0:  		/* lwz R5, <#[R22 + 12]> */
		/* 82249EBCh case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R22 + 0x0000000C) );
		/* 82249EBCh case    0:*/		return 0x82249EC0;
		  /* 82249EC0h */ case    1:  		/* lwz R30, <#[R1 + 92]> */
		/* 82249EC0h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 82249EC0h case    1:*/		return 0x82249EC4;
		  /* 82249EC4h */ case    2:  		/* lwz R11, <#[R5 + 2720]> */
		/* 82249EC4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000AA0) );
		/* 82249EC4h case    2:*/		return 0x82249EC8;
		  /* 82249EC8h */ case    3:  		/* cmpw CR6, R30, R11 */
		/* 82249EC8h case    3:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 82249EC8h case    3:*/		return 0x82249ECC;
		  /* 82249ECCh */ case    4:  		/* bc 4, CR6_LT, 64 */
		/* 82249ECCh case    4:*/		if ( !regs.CR[6].lt ) { return 0x82249F0C;  }
		/* 82249ECCh case    4:*/		return 0x82249ED0;
		  /* 82249ED0h */ case    5:  		/* lwz R3, <#[R31 + 32]> */
		/* 82249ED0h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 82249ED0h case    5:*/		return 0x82249ED4;
		  /* 82249ED4h */ case    6:  		/* lwz R4, <#[R22 + 164]> */
		/* 82249ED4h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x000000A4) );
		/* 82249ED4h case    6:*/		return 0x82249ED8;
		  /* 82249ED8h */ case    7:  		/* bl 42592 */
		/* 82249ED8h case    7:*/		regs.LR = 0x82249EDC; return 0x82254538;
		/* 82249ED8h case    7:*/		return 0x82249EDC;
		  /* 82249EDCh */ case    8:  		/* mr R5, R3 */
		/* 82249EDCh case    8:*/		regs.R5 = regs.R3;
		/* 82249EDCh case    8:*/		return 0x82249EE0;
		  /* 82249EE0h */ case    9:  		/* lwz R4, <#[R23]> */
		/* 82249EE0h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000000) );
		/* 82249EE0h case    9:*/		return 0x82249EE4;
		  /* 82249EE4h */ case   10:  		/* mr R3, R21 */
		/* 82249EE4h case   10:*/		regs.R3 = regs.R21;
		/* 82249EE4h case   10:*/		return 0x82249EE8;
		  /* 82249EE8h */ case   11:  		/* bl 64624 */
		/* 82249EE8h case   11:*/		regs.LR = 0x82249EEC; return 0x82259B58;
		/* 82249EE8h case   11:*/		return 0x82249EEC;
		  /* 82249EECh */ case   12:  		/* lwz R11, <#[R31]> */
		/* 82249EECh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82249EECh case   12:*/		return 0x82249EF0;
		  /* 82249EF0h */ case   13:  		/* mr R3, R31 */
		/* 82249EF0h case   13:*/		regs.R3 = regs.R31;
		/* 82249EF0h case   13:*/		return 0x82249EF4;
		  /* 82249EF4h */ case   14:  		/* lwz R11, <#[R11 + 96]> */
		/* 82249EF4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 82249EF4h case   14:*/		return 0x82249EF8;
		  /* 82249EF8h */ case   15:  		/* mtspr CTR, R11 */
		/* 82249EF8h case   15:*/		regs.CTR = regs.R11;
		/* 82249EF8h case   15:*/		return 0x82249EFC;
		  /* 82249EFCh */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 82249EFCh case   16:*/		if ( 1 ) { regs.LR = 0x82249F00; return (uint32)regs.CTR; }
		/* 82249EFCh case   16:*/		return 0x82249F00;
		  /* 82249F00h */ case   17:  		/* addi R11, R30, 1 */
		/* 82249F00h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 82249F00h case   17:*/		return 0x82249F04;
		  /* 82249F04h */ case   18:  		/* stw R11, <#[R1 + 92]> */
		/* 82249F04h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82249F04h case   18:*/		return 0x82249F08;
		  /* 82249F08h */ case   19:  		/* b 1272 */
		/* 82249F08h case   19:*/		return 0x8224A400;
		/* 82249F08h case   19:*/		return 0x82249F0C;
	}
	return 0x82249F0C;
} // Block from 82249EBCh-82249F0Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 82249F0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249F0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249F0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249F0C);
		  /* 82249F0Ch */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 82249F0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82249F0Ch case    0:*/		return 0x82249F10;
		  /* 82249F10h */ case    1:  		/* li R29, 1 */
		/* 82249F10h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82249F10h case    1:*/		return 0x82249F14;
		  /* 82249F14h */ case    2:  		/* cmpwi CR6, R11, 1 */
		/* 82249F14h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82249F14h case    2:*/		return 0x82249F18;
		  /* 82249F18h */ case    3:  		/* bc 12, CR6_LT, 100 */
		/* 82249F18h case    3:*/		if ( regs.CR[6].lt ) { return 0x82249F7C;  }
		/* 82249F18h case    3:*/		return 0x82249F1C;
		  /* 82249F1Ch */ case    4:  		/* addi R28, R1, 160 */
		/* 82249F1Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0xA0);
		/* 82249F1Ch case    4:*/		return 0x82249F20;
		  /* 82249F20h */ case    5:  		/* addi R30, R31, 32 */
		/* 82249F20h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x20);
		/* 82249F20h case    5:*/		return 0x82249F24;
		  /* 82249F24h */ case    6:  		/* lwz R27, <#[R30]> */
		/* 82249F24h case    6:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R30 + 0x00000000) );
		/* 82249F24h case    6:*/		return 0x82249F28;
		  /* 82249F28h */ case    7:  		/* cmplwi CR6, R27, 0 */
		/* 82249F28h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82249F28h case    7:*/		return 0x82249F2C;
		  /* 82249F2Ch */ case    8:  		/* bc 4, CR6_EQ, 28 */
		/* 82249F2Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82249F48;  }
		/* 82249F2Ch case    8:*/		return 0x82249F30;
		  /* 82249F30h */ case    9:  		/* mr R6, R15 */
		/* 82249F30h case    9:*/		regs.R6 = regs.R15;
		/* 82249F30h case    9:*/		return 0x82249F34;
		  /* 82249F34h */ case   10:  		/* lwz R5, <#[R1 + 104]> */
		/* 82249F34h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 82249F34h case   10:*/		return 0x82249F38;
		  /* 82249F38h */ case   11:  		/* mr R4, R16 */
		/* 82249F38h case   11:*/		regs.R4 = regs.R16;
		/* 82249F38h case   11:*/		return 0x82249F3C;
		  /* 82249F3Ch */ case   12:  		/* li R7, 1158 */
		/* 82249F3Ch case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x486);
		/* 82249F3Ch case   12:*/		return 0x82249F40;
		  /* 82249F40h */ case   13:  		/* li R3, 0 */
		/* 82249F40h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82249F40h case   13:*/		return 0x82249F44;
		  /* 82249F44h */ case   14:  		/* bl -992060 */
		/* 82249F44h case   14:*/		regs.LR = 0x82249F48; return 0x82157C08;
		/* 82249F44h case   14:*/		return 0x82249F48;
	}
	return 0x82249F48;
} // Block from 82249F0Ch-82249F48h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82249F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249F48);
		  /* 82249F48h */ case    0:  		/* mr R3, R27 */
		/* 82249F48h case    0:*/		regs.R3 = regs.R27;
		/* 82249F48h case    0:*/		return 0x82249F4C;
		  /* 82249F4Ch */ case    1:  		/* lwz R5, <#[R22 + 12]> */
		/* 82249F4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R22 + 0x0000000C) );
		/* 82249F4Ch case    1:*/		return 0x82249F50;
		  /* 82249F50h */ case    2:  		/* lwz R4, <#[R22 + 164]> */
		/* 82249F50h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x000000A4) );
		/* 82249F50h case    2:*/		return 0x82249F54;
		  /* 82249F54h */ case    3:  		/* bl 42468 */
		/* 82249F54h case    3:*/		regs.LR = 0x82249F58; return 0x82254538;
		/* 82249F54h case    3:*/		return 0x82249F58;
		  /* 82249F58h */ case    4:  		/* lwz R11, <#[R3 + 16]> */
		/* 82249F58h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82249F58h case    4:*/		return 0x82249F5C;
		  /* 82249F5Ch */ case    5:  		/* lwz R10, <#[R31 + 20]> */
		/* 82249F5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82249F5Ch case    5:*/		return 0x82249F60;
		  /* 82249F60h */ case    6:  		/* addi R29, R29, 1 */
		/* 82249F60h case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82249F60h case    6:*/		return 0x82249F64;
		  /* 82249F64h */ case    7:  		/* addi R30, R30, 4 */
		/* 82249F64h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82249F64h case    7:*/		return 0x82249F68;
		  /* 82249F68h */ case    8:  		/* cmpw CR6, R29, R10 */
		/* 82249F68h case    8:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R10);
		/* 82249F68h case    8:*/		return 0x82249F6C;
		  /* 82249F6Ch */ case    9:  		/* stwu R11, <#[R28 + 4]> */
		/* 82249F6Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		regs.R28 = (uint32)(regs.R28 + 0x00000004);
		/* 82249F6Ch case    9:*/		return 0x82249F70;
		  /* 82249F70h */ case   10:  		/* bc 4, CR6_GT, -76 */
		/* 82249F70h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82249F24;  }
		/* 82249F70h case   10:*/		return 0x82249F74;
		  /* 82249F74h */ case   11:  		/* lwz R14, <#[R1 + 168]> */
		/* 82249F74h case   11:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x000000A8) );
		/* 82249F74h case   11:*/		return 0x82249F78;
		  /* 82249F78h */ case   12:  		/* lwz R18, <#[R1 + 164]> */
		/* 82249F78h case   12:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x000000A4) );
		/* 82249F78h case   12:*/		return 0x82249F7C;
	}
	return 0x82249F7C;
} // Block from 82249F48h-82249F7Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82249F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249F7C);
		  /* 82249F7Ch */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 82249F7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82249F7Ch case    0:*/		return 0x82249F80;
		  /* 82249F80h */ case    1:  		/* lwz R10, <#[R1 + 108]> */
		/* 82249F80h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000006C) );
		/* 82249F80h case    1:*/		return 0x82249F84;
		  /* 82249F84h */ case    2:  		/* mulli R11, R11, 52 */
		/* 82249F84h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 82249F84h case    2:*/		return 0x82249F88;
		  /* 82249F88h */ case    3:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82249F88h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82249F88h case    3:*/		return 0x82249F8C;
		  /* 82249F8Ch */ case    4:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82249F8Ch case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82249F8Ch case    4:*/		return 0x82249F90;
		  /* 82249F90h */ case    5:  		/* bc 12, CR0_EQ, 184 */
		/* 82249F90h case    5:*/		if ( regs.CR[0].eq ) { return 0x8224A048;  }
		/* 82249F90h case    5:*/		return 0x82249F94;
		  /* 82249F94h */ case    6:  		/* lwz R10, <#[R18 + 80]> */
		/* 82249F94h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000050) );
		/* 82249F94h case    6:*/		return 0x82249F98;
	}
	return 0x82249F98;
} // Block from 82249F7Ch-82249F98h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82249F98h
// Function '?EdgesAreSplit@CFG@XGRAPHICS@@AAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249F98);
		  /* 82249F98h */ case    0:  		/* addi R11, R19, 6 */
		/* 82249F98h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R19,0x6);
		/* 82249F98h case    0:*/		return 0x82249F9C;
		  /* 82249F9Ch */ case    1:  		/* mulli R9, R10, 12 */
		/* 82249F9Ch case    1:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R10,0xC);
		/* 82249F9Ch case    1:*/		return 0x82249FA0;
		  /* 82249FA0h */ case    2:  		/* lbzx R11, <#[R9 + R11]> */
		/* 82249FA0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82249FA0h case    2:*/		return 0x82249FA4;
		  /* 82249FA4h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 82249FA4h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82249FA4h case    3:*/		return 0x82249FA8;
		  /* 82249FA8h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82249FA8h case    4:*/		if ( regs.CR[0].eq ) { return 0x82249FB8;  }
		/* 82249FA8h case    4:*/		return 0x82249FAC;
		  /* 82249FACh */ case    5:  		/* cmplwi CR6, R11, 4 */
		/* 82249FACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82249FACh case    5:*/		return 0x82249FB0;
		  /* 82249FB0h */ case    6:  		/* li R11, 1 */
		/* 82249FB0h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82249FB0h case    6:*/		return 0x82249FB4;
		  /* 82249FB4h */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 82249FB4h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82249FBC;  }
		/* 82249FB4h case    7:*/		return 0x82249FB8;
	}
	return 0x82249FB8;
} // Block from 82249F98h-82249FB8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82249FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249FB8);
		  /* 82249FB8h */ case    0:  		/* mr R11, R20 */
		/* 82249FB8h case    0:*/		regs.R11 = regs.R20;
		/* 82249FB8h case    0:*/		return 0x82249FBC;
	}
	return 0x82249FBC;
} // Block from 82249FB8h-82249FBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82249FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249FBC);
		  /* 82249FBCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82249FBCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82249FBCh case    0:*/		return 0x82249FC0;
		  /* 82249FC0h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82249FC0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82249FD0;  }
		/* 82249FC0h case    1:*/		return 0x82249FC4;
		  /* 82249FC4h */ case    2:  		/* lwz R11, <#[R14 + 80]> */
		/* 82249FC4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000050) );
		/* 82249FC4h case    2:*/		return 0x82249FC8;
		  /* 82249FC8h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 82249FC8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82249FC8h case    3:*/		return 0x82249FCC;
		  /* 82249FCCh */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 82249FCCh case    4:*/		if ( regs.CR[6].eq ) { return 0x82249FF4;  }
		/* 82249FCCh case    4:*/		return 0x82249FD0;
	}
	return 0x82249FD0;
} // Block from 82249FBCh-82249FD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82249FD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249FD0);
		  /* 82249FD0h */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 82249FD0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82249FD0h case    0:*/		return 0x82249FD4;
		  /* 82249FD4h */ case    1:  		/* bc 4, CR6_EQ, 116 */
		/* 82249FD4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224A048;  }
		/* 82249FD4h case    1:*/		return 0x82249FD8;
		  /* 82249FD8h */ case    2:  		/* lwz R11, <#[R14 + 80]> */
		/* 82249FD8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000050) );
		/* 82249FD8h case    2:*/		return 0x82249FDC;
		  /* 82249FDCh */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 82249FDCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82249FDCh case    3:*/		return 0x82249FE0;
		  /* 82249FE0h */ case    4:  		/* bc 4, CR6_EQ, 104 */
		/* 82249FE0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8224A048;  }
		/* 82249FE0h case    4:*/		return 0x82249FE4;
		  /* 82249FE4h */ case    5:  		/* lwz R11, <#[R18 + 224]> */
		/* 82249FE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x000000E0) );
		/* 82249FE4h case    5:*/		return 0x82249FE8;
		  /* 82249FE8h */ case    6:  		/* lwz R10, <#[R14 + 224]> */
		/* 82249FE8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x000000E0) );
		/* 82249FE8h case    6:*/		return 0x82249FEC;
		  /* 82249FECh */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 82249FECh case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82249FECh case    7:*/		return 0x82249FF0;
		  /* 82249FF0h */ case    8:  		/* bc 4, CR6_GT, 88 */
		/* 82249FF0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8224A048;  }
		/* 82249FF0h case    8:*/		return 0x82249FF4;
	}
	return 0x82249FF4;
} // Block from 82249FD0h-82249FF4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82249FF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82249FF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82249FF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82249FF4);
		  /* 82249FF4h */ case    0:  		/* lwz R10, <#[R31 + 132]> */
		/* 82249FF4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 82249FF4h case    0:*/		return 0x82249FF8;
		  /* 82249FF8h */ case    1:  		/* mr R11, R18 */
		/* 82249FF8h case    1:*/		regs.R11 = regs.R18;
		/* 82249FF8h case    1:*/		return 0x82249FFC;
		  /* 82249FFCh */ case    2:  		/* lwz R9, <#[R31 + 136]> */
		/* 82249FFCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000088) );
		/* 82249FFCh case    2:*/		return 0x8224A000;
		  /* 8224A000h */ case    3:  		/* mr R18, R14 */
		/* 8224A000h case    3:*/		regs.R18 = regs.R14;
		/* 8224A000h case    3:*/		return 0x8224A004;
		  /* 8224A004h */ case    4:  		/* mr R14, R11 */
		/* 8224A004h case    4:*/		regs.R14 = regs.R11;
		/* 8224A004h case    4:*/		return 0x8224A008;
		  /* 8224A008h */ case    5:  		/* stw R11, <#[R1 + 168]> */
		/* 8224A008h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 8224A008h case    5:*/		return 0x8224A00C;
		  /* 8224A00Ch */ case    6:  		/* stw R18, <#[R1 + 164]> */
		/* 8224A00Ch case    6:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x000000A4) );
		/* 8224A00Ch case    6:*/		return 0x8224A010;
		  /* 8224A010h */ case    7:  		/* stw R10, <#[R31 + 136]> */
		/* 8224A010h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000088) );
		/* 8224A010h case    7:*/		return 0x8224A014;
		  /* 8224A014h */ case    8:  		/* stw R9, <#[R31 + 132]> */
		/* 8224A014h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000084) );
		/* 8224A014h case    8:*/		return 0x8224A018;
		  /* 8224A018h */ case    9:  		/* lbz R9, <#[R31 + 154]> */
		/* 8224A018h case    9:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000009A) );
		/* 8224A018h case    9:*/		return 0x8224A01C;
		  /* 8224A01Ch */ case   10:  		/* lbz R8, <#[R31 + 153]> */
		/* 8224A01Ch case   10:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000099) );
		/* 8224A01Ch case   10:*/		return 0x8224A020;
		  /* 8224A020h */ case   11:  		/* lbz R11, <#[R31 + 159]> */
		/* 8224A020h case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000009F) );
		/* 8224A020h case   11:*/		return 0x8224A024;
		  /* 8224A024h */ case   12:  		/* lbz R10, <#[R31 + 160]> */
		/* 8224A024h case   12:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000A0) );
		/* 8224A024h case   12:*/		return 0x8224A028;
		  /* 8224A028h */ case   13:  		/* stb R10, <#[R31 + 159]> */
		/* 8224A028h case   13:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x0000009F) );
		/* 8224A028h case   13:*/		return 0x8224A02C;
		  /* 8224A02Ch */ case   14:  		/* stb R8, <#[R31 + 154]> */
		/* 8224A02Ch case   14:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R31 + 0x0000009A) );
		/* 8224A02Ch case   14:*/		return 0x8224A030;
		  /* 8224A030h */ case   15:  		/* stb R9, <#[R31 + 153]> */
		/* 8224A030h case   15:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R31 + 0x00000099) );
		/* 8224A030h case   15:*/		return 0x8224A034;
		  /* 8224A034h */ case   16:  		/* stb R11, <#[R31 + 160]> */
		/* 8224A034h case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x000000A0) );
		/* 8224A034h case   16:*/		return 0x8224A038;
	}
	return 0x8224A038;
} // Block from 82249FF4h-8224A038h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224A038h
// Function '?PlacePhiNodes@CFG@XGRAPHICS@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A038);
		  /* 8224A038h */ case    0:  		/* lwz R11, <#[R31 + 204]> */
		/* 8224A038h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 8224A038h case    0:*/		return 0x8224A03C;
		  /* 8224A03Ch */ case    1:  		/* lwz R10, <#[R31 + 208]> */
		/* 8224A03Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000D0) );
		/* 8224A03Ch case    1:*/		return 0x8224A040;
		  /* 8224A040h */ case    2:  		/* stw R10, <#[R31 + 204]> */
		/* 8224A040h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000000CC) );
		/* 8224A040h case    2:*/		return 0x8224A044;
		  /* 8224A044h */ case    3:  		/* stw R11, <#[R31 + 208]> */
		/* 8224A044h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000D0) );
		/* 8224A044h case    3:*/		return 0x8224A048;
	}
	return 0x8224A048;
} // Block from 8224A038h-8224A048h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224A048h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A048);
		  /* 8224A048h */ case    0:  		/* lwz R11, <#[R22 + 12]> */
		/* 8224A048h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 8224A048h case    0:*/		return 0x8224A04C;
		  /* 8224A04Ch */ case    1:  		/* lwz R10, <#[R11 + 2136]> */
		/* 8224A04Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000858) );
		/* 8224A04Ch case    1:*/		return 0x8224A050;
		  /* 8224A050h */ case    2:  		/* rlwinm. R10, R10, 30, 31, 31 */
		/* 8224A050h case    2:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R10,regs.R10);
		/* 8224A050h case    2:*/		return 0x8224A054;
		  /* 8224A054h */ case    3:  		/* bc 12, CR0_EQ, 352 */
		/* 8224A054h case    3:*/		if ( regs.CR[0].eq ) { return 0x8224A1B4;  }
		/* 8224A054h case    3:*/		return 0x8224A058;
		  /* 8224A058h */ case    4:  		/* lwz R11, <#[R11 + 2716]> */
		/* 8224A058h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000A9C) );
		/* 8224A058h case    4:*/		return 0x8224A05C;
		  /* 8224A05Ch */ case    5:  		/* lwz R28, <#[R1 + 84]> */
		/* 8224A05Ch case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 8224A05Ch case    5:*/		return 0x8224A060;
		  /* 8224A060h */ case    6:  		/* cmpw CR6, R28, R11 */
		/* 8224A060h case    6:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R11);
		/* 8224A060h case    6:*/		return 0x8224A064;
		  /* 8224A064h */ case    7:  		/* bc 4, CR6_LT, 336 */
		/* 8224A064h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8224A1B4;  }
		/* 8224A064h case    7:*/		return 0x8224A068;
		  /* 8224A068h */ case    8:  		/* lwz R10, <#[R31 + 16]> */
		/* 8224A068h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 8224A068h case    8:*/		return 0x8224A06C;
		  /* 8224A06Ch */ case    9:  		/* cmpwi CR6, R10, 0 */
		/* 8224A06Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8224A06Ch case    9:*/		return 0x8224A070;
		  /* 8224A070h */ case   10:  		/* bc 12, CR6_EQ, 44 */
		/* 8224A070h case   10:*/		if ( regs.CR[6].eq ) { return 0x8224A09C;  }
		/* 8224A070h case   10:*/		return 0x8224A074;
		  /* 8224A074h */ case   11:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224A074h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224A074h case   11:*/		return 0x8224A078;
		  /* 8224A078h */ case   12:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 8224A078h case   12:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A078h case   12:*/		return 0x8224A07C;
		  /* 8224A07Ch */ case   13:  		/* bc 4, CR0_EQ, 32 */
		/* 8224A07Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x8224A09C;  }
		/* 8224A07Ch case   13:*/		return 0x8224A080;
		  /* 8224A080h */ case   14:  		/* lwz R11, <#[R31 + 80]> */
		/* 8224A080h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8224A080h case   14:*/		return 0x8224A084;
		  /* 8224A084h */ case   15:  		/* addi R9, R19, 4 */
		/* 8224A084h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R19,0x4);
		/* 8224A084h case   15:*/		return 0x8224A088;
		  /* 8224A088h */ case   16:  		/* mulli R11, R11, 12 */
		/* 8224A088h case   16:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8224A088h case   16:*/		return 0x8224A08C;
		  /* 8224A08Ch */ case   17:  		/* lbzx R11, <#[R11 + R9]> */
		/* 8224A08Ch case   17:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8224A08Ch case   17:*/		return 0x8224A090;
		  /* 8224A090h */ case   18:  		/* cmplwi CR0, R11, 0 */
		/* 8224A090h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224A090h case   18:*/		return 0x8224A094;
		  /* 8224A094h */ case   19:  		/* li R11, 1 */
		/* 8224A094h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224A094h case   19:*/		return 0x8224A098;
		  /* 8224A098h */ case   20:  		/* bc 4, CR0_EQ, 8 */
		/* 8224A098h case   20:*/		if ( !regs.CR[0].eq ) { return 0x8224A0A0;  }
		/* 8224A098h case   20:*/		return 0x8224A09C;
	}
	return 0x8224A09C;
} // Block from 8224A048h-8224A09Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224A09Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A09C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A09C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A09C);
		  /* 8224A09Ch */ case    0:  		/* mr R11, R20 */
		/* 8224A09Ch case    0:*/		regs.R11 = regs.R20;
		/* 8224A09Ch case    0:*/		return 0x8224A0A0;
	}
	return 0x8224A0A0;
} // Block from 8224A09Ch-8224A0A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224A0A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A0A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A0A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A0A0);
		  /* 8224A0A0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224A0A0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224A0A0h case    0:*/		return 0x8224A0A4;
		  /* 8224A0A4h */ case    1:  		/* bc 12, CR0_EQ, 184 */
		/* 8224A0A4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8224A15C;  }
		/* 8224A0A4h case    1:*/		return 0x8224A0A8;
		  /* 8224A0A8h */ case    2:  		/* lwz R11, <#[R31 + 20]> */
		/* 8224A0A8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8224A0A8h case    2:*/		return 0x8224A0AC;
		  /* 8224A0ACh */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 8224A0ACh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224A0ACh case    3:*/		return 0x8224A0B0;
		  /* 8224A0B0h */ case    4:  		/* bc 4, CR6_GT, 172 */
		/* 8224A0B0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8224A15C;  }
		/* 8224A0B0h case    4:*/		return 0x8224A0B4;
		  /* 8224A0B4h */ case    5:  		/* mr R30, R26 */
		/* 8224A0B4h case    5:*/		regs.R30 = regs.R26;
		/* 8224A0B4h case    5:*/		return 0x8224A0B8;
		  /* 8224A0B8h */ case    6:  		/* cmpwi CR6, R26, 0 */
		/* 8224A0B8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 8224A0B8h case    6:*/		return 0x8224A0BC;
		  /* 8224A0BCh */ case    7:  		/* bc 12, CR6_LT, 80 */
		/* 8224A0BCh case    7:*/		if ( regs.CR[6].lt ) { return 0x8224A10C;  }
		/* 8224A0BCh case    7:*/		return 0x8224A0C0;
		  /* 8224A0C0h */ case    8:  		/* rlwinm R29, R26, 2, 0, 29 */
		/* 8224A0C0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R26);
		/* 8224A0C0h case    8:*/		return 0x8224A0C4;
		  /* 8224A0C4h */ case    9:  		/* lwz R11, <#[R1 + 132]> */
		/* 8224A0C4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 8224A0C4h case    9:*/		return 0x8224A0C8;
		  /* 8224A0C8h */ case   10:  		/* cmplw CR6, R30, R11 */
		/* 8224A0C8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8224A0C8h case   10:*/		return 0x8224A0CC;
		  /* 8224A0CCh */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 8224A0CCh case   11:*/		if ( !regs.CR[6].lt ) { return 0x8224A0DC;  }
		/* 8224A0CCh case   11:*/		return 0x8224A0D0;
		  /* 8224A0D0h */ case   12:  		/* lwz R11, <#[R1 + 136]> */
		/* 8224A0D0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 8224A0D0h case   12:*/		return 0x8224A0D4;
		  /* 8224A0D4h */ case   13:  		/* add R3, R29, R11 */
		/* 8224A0D4h case   13:*/		cpu::op::add<0>(regs,&regs.R3,regs.R29,regs.R11);
		/* 8224A0D4h case   13:*/		return 0x8224A0D8;
		  /* 8224A0D8h */ case   14:  		/* b 16 */
		/* 8224A0D8h case   14:*/		return 0x8224A0E8;
		/* 8224A0D8h case   14:*/		return 0x8224A0DC;
	}
	return 0x8224A0DC;
} // Block from 8224A0A0h-8224A0DCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224A0DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A0DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A0DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A0DC);
		  /* 8224A0DCh */ case    0:  		/* mr R4, R30 */
		/* 8224A0DCh case    0:*/		regs.R4 = regs.R30;
		/* 8224A0DCh case    0:*/		return 0x8224A0E0;
		  /* 8224A0E0h */ case    1:  		/* addi R3, R1, 128 */
		/* 8224A0E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8224A0E0h case    1:*/		return 0x8224A0E4;
		  /* 8224A0E4h */ case    2:  		/* bl 39388 */
		/* 8224A0E4h case    2:*/		regs.LR = 0x8224A0E8; return 0x82253AC0;
		/* 8224A0E4h case    2:*/		return 0x8224A0E8;
	}
	return 0x8224A0E8;
} // Block from 8224A0DCh-8224A0E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224A0E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A0E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A0E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A0E8);
		  /* 8224A0E8h */ case    0:  		/* mr R4, R24 */
		/* 8224A0E8h case    0:*/		regs.R4 = regs.R24;
		/* 8224A0E8h case    0:*/		return 0x8224A0EC;
		  /* 8224A0ECh */ case    1:  		/* lwz R3, <#[R3]> */
		/* 8224A0ECh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 8224A0ECh case    1:*/		return 0x8224A0F0;
		  /* 8224A0F0h */ case    2:  		/* lwz R5, <#[R22 + 12]> */
		/* 8224A0F0h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R22 + 0x0000000C) );
		/* 8224A0F0h case    2:*/		return 0x8224A0F4;
		  /* 8224A0F4h */ case    3:  		/* bl -5604 */
		/* 8224A0F4h case    3:*/		regs.LR = 0x8224A0F8; return 0x82248B10;
		/* 8224A0F4h case    3:*/		return 0x8224A0F8;
		  /* 8224A0F8h */ case    4:  		/* or. R5, R3, R3 */
		/* 8224A0F8h case    4:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 8224A0F8h case    4:*/		return 0x8224A0FC;
		  /* 8224A0FCh */ case    5:  		/* bc 4, CR0_EQ, 32 */
		/* 8224A0FCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x8224A11C;  }
		/* 8224A0FCh case    5:*/		return 0x8224A100;
		  /* 8224A100h */ case    6:  		/* addic. R30, R30, -1 */
		/* 8224A100h case    6:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 8224A100h case    6:*/		return 0x8224A104;
		  /* 8224A104h */ case    7:  		/* addi R29, R29, -4 */
		/* 8224A104h case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0xFFFFFFFC);
		/* 8224A104h case    7:*/		return 0x8224A108;
		  /* 8224A108h */ case    8:  		/* bc 4, CR0_LT, -68 */
		/* 8224A108h case    8:*/		if ( !regs.CR[0].lt ) { return 0x8224A0C4;  }
		/* 8224A108h case    8:*/		return 0x8224A10C;
	}
	return 0x8224A10C;
} // Block from 8224A0E8h-8224A10Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224A10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A10C);
		  /* 8224A10Ch */ case    0:  		/* mr R4, R24 */
		/* 8224A10Ch case    0:*/		regs.R4 = regs.R24;
		/* 8224A10Ch case    0:*/		return 0x8224A110;
		  /* 8224A110h */ case    1:  		/* lwz R3, <#[R1 + 88]> */
		/* 8224A110h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 8224A110h case    1:*/		return 0x8224A114;
		  /* 8224A114h */ case    2:  		/* bl -5108 */
		/* 8224A114h case    2:*/		regs.LR = 0x8224A118; return 0x82248D20;
		/* 8224A114h case    2:*/		return 0x8224A118;
		  /* 8224A118h */ case    3:  		/* b 156 */
		/* 8224A118h case    3:*/		return 0x8224A1B4;
		/* 8224A118h case    3:*/		return 0x8224A11C;
	}
	return 0x8224A11C;
} // Block from 8224A10Ch-8224A11Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224A11Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A11C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A11C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A11C);
		  /* 8224A11Ch */ case    0:  		/* mr R3, R21 */
		/* 8224A11Ch case    0:*/		regs.R3 = regs.R21;
		/* 8224A11Ch case    0:*/		return 0x8224A120;
		  /* 8224A120h */ case    1:  		/* lwz R4, <#[R23]> */
		/* 8224A120h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000000) );
		/* 8224A120h case    1:*/		return 0x8224A124;
		  /* 8224A124h */ case    2:  		/* bl 64052 */
		/* 8224A124h case    2:*/		regs.LR = 0x8224A128; return 0x82259B58;
		/* 8224A124h case    2:*/		return 0x8224A128;
		  /* 8224A128h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 8224A128h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224A128h case    3:*/		return 0x8224A12C;
		  /* 8224A12Ch */ case    4:  		/* mr R3, R31 */
		/* 8224A12Ch case    4:*/		regs.R3 = regs.R31;
		/* 8224A12Ch case    4:*/		return 0x8224A130;
		  /* 8224A130h */ case    5:  		/* lwz R11, <#[R11 + 96]> */
		/* 8224A130h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 8224A130h case    5:*/		return 0x8224A134;
		  /* 8224A134h */ case    6:  		/* mtspr CTR, R11 */
		/* 8224A134h case    6:*/		regs.CTR = regs.R11;
		/* 8224A134h case    6:*/		return 0x8224A138;
		  /* 8224A138h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 8224A138h case    7:*/		if ( 1 ) { regs.LR = 0x8224A13C; return (uint32)regs.CTR; }
		/* 8224A138h case    7:*/		return 0x8224A13C;
		  /* 8224A13Ch */ case    8:  		/* addi R11, R28, 1 */
		/* 8224A13Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x1);
		/* 8224A13Ch case    8:*/		return 0x8224A140;
		  /* 8224A140h */ case    9:  		/* cmplwi CR6, R24, 0 */
		/* 8224A140h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8224A140h case    9:*/		return 0x8224A144;
		  /* 8224A144h */ case   10:  		/* stw R11, <#[R1 + 84]> */
		/* 8224A144h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8224A144h case   10:*/		return 0x8224A148;
		  /* 8224A148h */ case   11:  		/* bc 12, CR6_EQ, 696 */
		/* 8224A148h case   11:*/		if ( regs.CR[6].eq ) { return 0x8224A400;  }
		/* 8224A148h case   11:*/		return 0x8224A14C;
		  /* 8224A14Ch */ case   12:  		/* addi R4, R24, -4 */
		/* 8224A14Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R24,0xFFFFFFFC);
		/* 8224A14Ch case   12:*/		return 0x8224A150;
		  /* 8224A150h */ case   13:  		/* lwz R3, <#[R24 - 4]> */
		/* 8224A150h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0xFFFFFFFC) );
		/* 8224A150h case   13:*/		return 0x8224A154;
		  /* 8224A154h */ case   14:  		/* bl -187156 */
		/* 8224A154h case   14:*/		regs.LR = 0x8224A158; return 0x8221C640;
		/* 8224A154h case   14:*/		return 0x8224A158;
		  /* 8224A158h */ case   15:  		/* b 680 */
		/* 8224A158h case   15:*/		return 0x8224A400;
		/* 8224A158h case   15:*/		return 0x8224A15C;
	}
	return 0x8224A15C;
} // Block from 8224A11Ch-8224A15Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8224A15Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A15C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A15C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A15C);
		  /* 8224A15Ch */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 8224A15Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8224A15Ch case    0:*/		return 0x8224A160;
		  /* 8224A160h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 8224A160h case    1:*/		if ( regs.CR[6].eq ) { return 0x8224A1B4;  }
		/* 8224A160h case    1:*/		return 0x8224A164;
		  /* 8224A164h */ case    2:  		/* mr R11, R20 */
		/* 8224A164h case    2:*/		regs.R11 = regs.R20;
		/* 8224A164h case    2:*/		return 0x8224A168;
		  /* 8224A168h */ case    3:  		/* mr R10, R24 */
		/* 8224A168h case    3:*/		regs.R10 = regs.R24;
		/* 8224A168h case    3:*/		return 0x8224A16C;
		  /* 8224A16Ch */ case    4:  		/* lwz R9, <#[R10]> */
		/* 8224A16Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8224A16Ch case    4:*/		return 0x8224A170;
		  /* 8224A170h */ case    5:  		/* cmpwi CR6, R9, 3 */
		/* 8224A170h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000003);
		/* 8224A170h case    5:*/		return 0x8224A174;
		  /* 8224A174h */ case    6:  		/* bc 4, CR6_EQ, 316 */
		/* 8224A174h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8224A2B0;  }
		/* 8224A174h case    6:*/		return 0x8224A178;
		  /* 8224A178h */ case    7:  		/* addi R11, R11, 1 */
		/* 8224A178h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224A178h case    7:*/		return 0x8224A17C;
		  /* 8224A17Ch */ case    8:  		/* addi R10, R10, 4 */
		/* 8224A17Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8224A17Ch case    8:*/		return 0x8224A180;
		  /* 8224A180h */ case    9:  		/* cmpwi CR6, R11, 4 */
		/* 8224A180h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 8224A180h case    9:*/		return 0x8224A184;
		  /* 8224A184h */ case   10:  		/* bc 12, CR6_LT, -24 */
		/* 8224A184h case   10:*/		if ( regs.CR[6].lt ) { return 0x8224A16C;  }
		/* 8224A184h case   10:*/		return 0x8224A188;
		  /* 8224A188h */ case   11:  		/* mr R11, R20 */
		/* 8224A188h case   11:*/		regs.R11 = regs.R20;
		/* 8224A188h case   11:*/		return 0x8224A18C;
		  /* 8224A18Ch */ case   12:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224A18Ch case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224A18Ch case   12:*/		return 0x8224A190;
		  /* 8224A190h */ case   13:  		/* bc 12, CR0_EQ, 28 */
		/* 8224A190h case   13:*/		if ( regs.CR[0].eq ) { return 0x8224A1AC;  }
		/* 8224A190h case   13:*/		return 0x8224A194;
		  /* 8224A194h */ case   14:  		/* mr R6, R15 */
		/* 8224A194h case   14:*/		regs.R6 = regs.R15;
		/* 8224A194h case   14:*/		return 0x8224A198;
		  /* 8224A198h */ case   15:  		/* lwz R5, <#[R1 + 112]> */
		/* 8224A198h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000070) );
		/* 8224A198h case   15:*/		return 0x8224A19C;
		  /* 8224A19Ch */ case   16:  		/* mr R4, R16 */
		/* 8224A19Ch case   16:*/		regs.R4 = regs.R16;
		/* 8224A19Ch case   16:*/		return 0x8224A1A0;
		  /* 8224A1A0h */ case   17:  		/* li R7, 1224 */
		/* 8224A1A0h case   17:*/		cpu::op::li<0>(regs,&regs.R7,0x4C8);
		/* 8224A1A0h case   17:*/		return 0x8224A1A4;
		  /* 8224A1A4h */ case   18:  		/* li R3, 0 */
		/* 8224A1A4h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224A1A4h case   18:*/		return 0x8224A1A8;
		  /* 8224A1A8h */ case   19:  		/* bl -992672 */
		/* 8224A1A8h case   19:*/		regs.LR = 0x8224A1AC; return 0x82157C08;
		/* 8224A1A8h case   19:*/		return 0x8224A1AC;
	}
	return 0x8224A1AC;
} // Block from 8224A15Ch-8224A1ACh (20 instructions)

//////////////////////////////////////////////////////
// Block at 8224A1ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A1AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A1AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A1AC);
		  /* 8224A1ACh */ case    0:  		/* mr R3, R24 */
		/* 8224A1ACh case    0:*/		regs.R3 = regs.R24;
		/* 8224A1ACh case    0:*/		return 0x8224A1B0;
		  /* 8224A1B0h */ case    1:  		/* bl -5704 */
		/* 8224A1B0h case    1:*/		regs.LR = 0x8224A1B4; return 0x82248B68;
		/* 8224A1B0h case    1:*/		return 0x8224A1B4;
	}
	return 0x8224A1B4;
} // Block from 8224A1ACh-8224A1B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224A1B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A1B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A1B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A1B4);
		  /* 8224A1B4h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8224A1B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8224A1B4h case    0:*/		return 0x8224A1B8;
		  /* 8224A1B8h */ case    1:  		/* li R30, 1 */
		/* 8224A1B8h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8224A1B8h case    1:*/		return 0x8224A1BC;
		  /* 8224A1BCh */ case    2:  		/* cmpwi CR6, R11, 1 */
		/* 8224A1BCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224A1BCh case    2:*/		return 0x8224A1C0;
		  /* 8224A1C0h */ case    3:  		/* bc 12, CR6_LT, 440 */
		/* 8224A1C0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224A378;  }
		/* 8224A1C0h case    3:*/		return 0x8224A1C4;
		  /* 8224A1C4h */ case    4:  		/* addi R25, R1, 164 */
		/* 8224A1C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R1,0xA4);
		/* 8224A1C4h case    4:*/		return 0x8224A1C8;
		  /* 8224A1C8h */ case    5:  		/* addi R27, R31, 28 */
		/* 8224A1C8h case    5:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R31,0x1C);
		/* 8224A1C8h case    5:*/		return 0x8224A1CC;
		  /* 8224A1CCh */ case    6:  		/* lwz R11, <#[R22 + 12]> */
		/* 8224A1CCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 8224A1CCh case    6:*/		return 0x8224A1D0;
		  /* 8224A1D0h */ case    7:  		/* lwz R11, <#[R11 + 2136]> */
		/* 8224A1D0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000858) );
		/* 8224A1D0h case    7:*/		return 0x8224A1D4;
		  /* 8224A1D4h */ case    8:  		/* rlwinm. R11, R11, 29, 31, 31 */
		/* 8224A1D4h case    8:*/		cpu::op::rlwinm<1,29,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A1D4h case    8:*/		return 0x8224A1D8;
		  /* 8224A1D8h */ case    9:  		/* bc 12, CR0_EQ, 360 */
		/* 8224A1D8h case    9:*/		if ( regs.CR[0].eq ) { return 0x8224A340;  }
		/* 8224A1D8h case    9:*/		return 0x8224A1DC;
		  /* 8224A1DCh */ case   10:  		/* lwz R29, <#[R25]> */
		/* 8224A1DCh case   10:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R25 + 0x00000000) );
		/* 8224A1DCh case   10:*/		return 0x8224A1E0;
		  /* 8224A1E0h */ case   11:  		/* mr R5, R30 */
		/* 8224A1E0h case   11:*/		regs.R5 = regs.R30;
		/* 8224A1E0h case   11:*/		return 0x8224A1E4;
		  /* 8224A1E4h */ case   12:  		/* mr R3, R31 */
		/* 8224A1E4h case   12:*/		regs.R3 = regs.R31;
		/* 8224A1E4h case   12:*/		return 0x8224A1E8;
		  /* 8224A1E8h */ case   13:  		/* mr R4, R29 */
		/* 8224A1E8h case   13:*/		regs.R4 = regs.R29;
		/* 8224A1E8h case   13:*/		return 0x8224A1EC;
		  /* 8224A1ECh */ case   14:  		/* bl -5252 */
		/* 8224A1ECh case   14:*/		regs.LR = 0x8224A1F0; return 0x82248D68;
		/* 8224A1ECh case   14:*/		return 0x8224A1F0;
		  /* 8224A1F0h */ case   15:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224A1F0h case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224A1F0h case   15:*/		return 0x8224A1F4;
		  /* 8224A1F4h */ case   16:  		/* bc 12, CR0_EQ, 332 */
		/* 8224A1F4h case   16:*/		if ( regs.CR[0].eq ) { return 0x8224A340;  }
		/* 8224A1F4h case   16:*/		return 0x8224A1F8;
		  /* 8224A1F8h */ case   17:  		/* lwz R11, <#[R29 + 228]> */
		/* 8224A1F8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000E4) );
		/* 8224A1F8h case   17:*/		return 0x8224A1FC;
		  /* 8224A1FCh */ case   18:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8224A1FCh case   18:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A1FCh case   18:*/		return 0x8224A200;
		  /* 8224A200h */ case   19:  		/* bc 12, CR0_EQ, 24 */
		/* 8224A200h case   19:*/		if ( regs.CR[0].eq ) { return 0x8224A218;  }
		/* 8224A200h case   19:*/		return 0x8224A204;
		  /* 8224A204h */ case   20:  		/* mr R3, R22 */
		/* 8224A204h case   20:*/		regs.R3 = regs.R22;
		/* 8224A204h case   20:*/		return 0x8224A208;
		  /* 8224A208h */ case   21:  		/* lwz R4, <#[R29 + 56]> */
		/* 8224A208h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000038) );
		/* 8224A208h case   21:*/		return 0x8224A20C;
		  /* 8224A20Ch */ case   22:  		/* bl -11404 */
		/* 8224A20Ch case   22:*/		regs.LR = 0x8224A210; return 0x82247580;
		/* 8224A20Ch case   22:*/		return 0x8224A210;
		  /* 8224A210h */ case   23:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224A210h case   23:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224A210h case   23:*/		return 0x8224A214;
		  /* 8224A214h */ case   24:  		/* bc 12, CR0_EQ, 300 */
		/* 8224A214h case   24:*/		if ( regs.CR[0].eq ) { return 0x8224A340;  }
		/* 8224A214h case   24:*/		return 0x8224A218;
	}
	return 0x8224A218;
} // Block from 8224A1B4h-8224A218h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8224A218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A218);
		  /* 8224A218h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8224A218h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224A218h case    0:*/		return 0x8224A21C;
		  /* 8224A21Ch */ case    1:  		/* mr R3, R31 */
		/* 8224A21Ch case    1:*/		regs.R3 = regs.R31;
		/* 8224A21Ch case    1:*/		return 0x8224A220;
		  /* 8224A220h */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224A220h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224A220h case    2:*/		return 0x8224A224;
		  /* 8224A224h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224A224h case    3:*/		regs.CTR = regs.R11;
		/* 8224A224h case    3:*/		return 0x8224A228;
		  /* 8224A228h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224A228h case    4:*/		if ( 1 ) { regs.LR = 0x8224A22C; return (uint32)regs.CTR; }
		/* 8224A228h case    4:*/		return 0x8224A22C;
		  /* 8224A22Ch */ case    5:  		/* cmpw CR6, R30, R3 */
		/* 8224A22Ch case    5:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R3);
		/* 8224A22Ch case    5:*/		return 0x8224A230;
		  /* 8224A230h */ case    6:  		/* bc 12, CR6_GT, 272 */
		/* 8224A230h case    6:*/		if ( regs.CR[6].gt ) { return 0x8224A340;  }
		/* 8224A230h case    6:*/		return 0x8224A234;
		  /* 8224A234h */ case    7:  		/* lbz R11, <#[R29 + 164]> */
		/* 8224A234h case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x000000A4) );
		/* 8224A234h case    7:*/		return 0x8224A238;
		  /* 8224A238h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 8224A238h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224A238h case    8:*/		return 0x8224A23C;
		  /* 8224A23Ch */ case    9:  		/* bc 4, CR0_EQ, 260 */
		/* 8224A23Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x8224A340;  }
		/* 8224A23Ch case    9:*/		return 0x8224A240;
		  /* 8224A240h */ case   10:  		/* li R4, 1 */
		/* 8224A240h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224A240h case   10:*/		return 0x8224A244;
		  /* 8224A244h */ case   11:  		/* mr R3, R29 */
		/* 8224A244h case   11:*/		regs.R3 = regs.R29;
		/* 8224A244h case   11:*/		return 0x8224A248;
		  /* 8224A248h */ case   12:  		/* bl 49048 */
		/* 8224A248h case   12:*/		regs.LR = 0x8224A24C; return 0x822561E0;
		/* 8224A248h case   12:*/		return 0x8224A24C;
		  /* 8224A24Ch */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 8224A24Ch case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8224A24Ch case   13:*/		return 0x8224A250;
		  /* 8224A250h */ case   14:  		/* bc 4, CR0_EQ, 240 */
		/* 8224A250h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8224A340;  }
		/* 8224A250h case   14:*/		return 0x8224A254;
		  /* 8224A254h */ case   15:  		/* add R11, R30, R31 */
		/* 8224A254h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R31);
		/* 8224A254h case   15:*/		return 0x8224A258;
		  /* 8224A258h */ case   16:  		/* lbz R7, <#[R29 + 159]> */
		/* 8224A258h case   16:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R29 + 0x0000009F) );
		/* 8224A258h case   16:*/		return 0x8224A25C;
		  /* 8224A25Ch */ case   17:  		/* add R10, R30, R31 */
		/* 8224A25Ch case   17:*/		cpu::op::add<0>(regs,&regs.R10,regs.R30,regs.R31);
		/* 8224A25Ch case   17:*/		return 0x8224A260;
		  /* 8224A260h */ case   18:  		/* lbz R8, <#[R29 + 153]> */
		/* 8224A260h case   18:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000099) );
		/* 8224A260h case   18:*/		return 0x8224A264;
		  /* 8224A264h */ case   19:  		/* addi R9, R11, 158 */
		/* 8224A264h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x9E);
		/* 8224A264h case   19:*/		return 0x8224A268;
		  /* 8224A268h */ case   20:  		/* addi R9, R10, 152 */
		/* 8224A268h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x98);
		/* 8224A268h case   20:*/		return 0x8224A26C;
		  /* 8224A26Ch */ case   21:  		/* lbz R9, <#[R11 + 158]> */
		/* 8224A26Ch case   21:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000009E) );
		/* 8224A26Ch case   21:*/		return 0x8224A270;
		  /* 8224A270h */ case   22:  		/* lbz R6, <#[R10 + 152]> */
		/* 8224A270h case   22:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000098) );
		/* 8224A270h case   22:*/		return 0x8224A274;
		  /* 8224A274h */ case   23:  		/* mr R5, R9 */
		/* 8224A274h case   23:*/		regs.R5 = regs.R9;
		/* 8224A274h case   23:*/		return 0x8224A278;
		  /* 8224A278h */ case   24:  		/* or R9, R7, R9 */
		/* 8224A278h case   24:*/		cpu::op::or<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8224A278h case   24:*/		return 0x8224A27C;
		  /* 8224A27Ch */ case   25:  		/* cntlzw R5, R5 */
		/* 8224A27Ch case   25:*/		cpu::op::cntlzw<0>(regs,&regs.R5,regs.R5);
		/* 8224A27Ch case   25:*/		return 0x8224A280;
		  /* 8224A280h */ case   26:  		/* stb R9, <#[R11 + 158]> */
		/* 8224A280h case   26:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x0000009E) );
		/* 8224A280h case   26:*/		return 0x8224A284;
		  /* 8224A284h */ case   27:  		/* rlwinm R7, R5, 27, 31, 31 */
		/* 8224A284h case   27:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R7,regs.R5);
		/* 8224A284h case   27:*/		return 0x8224A288;
		  /* 8224A288h */ case   28:  		/* and R11, R7, R8 */
		/* 8224A288h case   28:*/		cpu::op::and<0>(regs,&regs.R11,regs.R7,regs.R8);
		/* 8224A288h case   28:*/		return 0x8224A28C;
		  /* 8224A28Ch */ case   29:  		/* xor R11, R11, R6 */
		/* 8224A28Ch case   29:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 8224A28Ch case   29:*/		return 0x8224A290;
		  /* 8224A290h */ case   30:  		/* stb R11, <#[R10 + 152]> */
		/* 8224A290h case   30:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000098) );
		/* 8224A290h case   30:*/		return 0x8224A294;
		  /* 8224A294h */ case   31:  		/* lwz R11, <#[R17 + 13364]> */
		/* 8224A294h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00003434) );
		/* 8224A294h case   31:*/		return 0x8224A298;
		  /* 8224A298h */ case   32:  		/* lwz R10, <#[R27 + 104]> */
		/* 8224A298h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000068) );
		/* 8224A298h case   32:*/		return 0x8224A29C;
		  /* 8224A29Ch */ case   33:  		/* cmplw CR6, R10, R11 */
		/* 8224A29Ch case   33:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8224A29Ch case   33:*/		return 0x8224A2A0;
		  /* 8224A2A0h */ case   34:  		/* bc 4, CR6_EQ, 24 */
		/* 8224A2A0h case   34:*/		if ( !regs.CR[6].eq ) { return 0x8224A2B8;  }
		/* 8224A2A0h case   34:*/		return 0x8224A2A4;
		  /* 8224A2A4h */ case   35:  		/* lwz R11, <#[R29 + 132]> */
		/* 8224A2A4h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000084) );
		/* 8224A2A4h case   35:*/		return 0x8224A2A8;
		  /* 8224A2A8h */ case   36:  		/* stw R11, <#[R27 + 104]> */
		/* 8224A2A8h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000068) );
		/* 8224A2A8h case   36:*/		return 0x8224A2AC;
		  /* 8224A2ACh */ case   37:  		/* b 116 */
		/* 8224A2ACh case   37:*/		return 0x8224A320;
		/* 8224A2ACh case   37:*/		return 0x8224A2B0;
	}
	return 0x8224A2B0;
} // Block from 8224A218h-8224A2B0h (38 instructions)

//////////////////////////////////////////////////////
// Block at 8224A2B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A2B0);
		  /* 8224A2B0h */ case    0:  		/* li R11, 1 */
		/* 8224A2B0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224A2B0h case    0:*/		return 0x8224A2B4;
		  /* 8224A2B4h */ case    1:  		/* b -296 */
		/* 8224A2B4h case    1:*/		return 0x8224A18C;
		/* 8224A2B4h case    1:*/		return 0x8224A2B8;
	}
	return 0x8224A2B8;
} // Block from 8224A2B0h-8224A2B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224A2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A2B8);
		  /* 8224A2B8h */ case    0:  		/* mr R28, R20 */
		/* 8224A2B8h case    0:*/		regs.R28 = regs.R20;
		/* 8224A2B8h case    0:*/		return 0x8224A2BC;
		  /* 8224A2BCh */ case    1:  		/* lwz R11, <#[R31]> */
		/* 8224A2BCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224A2BCh case    1:*/		return 0x8224A2C0;
		  /* 8224A2C0h */ case    2:  		/* mr R5, R28 */
		/* 8224A2C0h case    2:*/		regs.R5 = regs.R28;
		/* 8224A2C0h case    2:*/		return 0x8224A2C4;
		  /* 8224A2C4h */ case    3:  		/* mr R4, R30 */
		/* 8224A2C4h case    3:*/		regs.R4 = regs.R30;
		/* 8224A2C4h case    3:*/		return 0x8224A2C8;
		  /* 8224A2C8h */ case    4:  		/* mr R3, R31 */
		/* 8224A2C8h case    4:*/		regs.R3 = regs.R31;
		/* 8224A2C8h case    4:*/		return 0x8224A2CC;
		  /* 8224A2CCh */ case    5:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224A2CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224A2CCh case    5:*/		return 0x8224A2D0;
		  /* 8224A2D0h */ case    6:  		/* mtspr CTR, R11 */
		/* 8224A2D0h case    6:*/		regs.CTR = regs.R11;
		/* 8224A2D0h case    6:*/		return 0x8224A2D4;
		  /* 8224A2D4h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 8224A2D4h case    7:*/		if ( 1 ) { regs.LR = 0x8224A2D8; return (uint32)regs.CTR; }
		/* 8224A2D4h case    7:*/		return 0x8224A2D8;
		  /* 8224A2D8h */ case    8:  		/* lwz R11, <#[R29]> */
		/* 8224A2D8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8224A2D8h case    8:*/		return 0x8224A2DC;
		  /* 8224A2DCh */ case    9:  		/* mr R5, R3 */
		/* 8224A2DCh case    9:*/		regs.R5 = regs.R3;
		/* 8224A2DCh case    9:*/		return 0x8224A2E0;
		  /* 8224A2E0h */ case   10:  		/* li R4, 1 */
		/* 8224A2E0h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224A2E0h case   10:*/		return 0x8224A2E4;
		  /* 8224A2E4h */ case   11:  		/* lwz R26, <#[R31]> */
		/* 8224A2E4h case   11:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x00000000) );
		/* 8224A2E4h case   11:*/		return 0x8224A2E8;
		  /* 8224A2E8h */ case   12:  		/* mr R3, R29 */
		/* 8224A2E8h case   12:*/		regs.R3 = regs.R29;
		/* 8224A2E8h case   12:*/		return 0x8224A2EC;
		  /* 8224A2ECh */ case   13:  		/* lwz R11, <#[R11 + 80]> */
		/* 8224A2ECh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8224A2ECh case   13:*/		return 0x8224A2F0;
		  /* 8224A2F0h */ case   14:  		/* mtspr CTR, R11 */
		/* 8224A2F0h case   14:*/		regs.CTR = regs.R11;
		/* 8224A2F0h case   14:*/		return 0x8224A2F4;
		  /* 8224A2F4h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 8224A2F4h case   15:*/		if ( 1 ) { regs.LR = 0x8224A2F8; return (uint32)regs.CTR; }
		/* 8224A2F4h case   15:*/		return 0x8224A2F8;
		  /* 8224A2F8h */ case   16:  		/* lwz R11, <#[R26 + 88]> */
		/* 8224A2F8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000058) );
		/* 8224A2F8h case   16:*/		return 0x8224A2FC;
		  /* 8224A2FCh */ case   17:  		/* mr R6, R3 */
		/* 8224A2FCh case   17:*/		regs.R6 = regs.R3;
		/* 8224A2FCh case   17:*/		return 0x8224A300;
		  /* 8224A300h */ case   18:  		/* mr R5, R28 */
		/* 8224A300h case   18:*/		regs.R5 = regs.R28;
		/* 8224A300h case   18:*/		return 0x8224A304;
		  /* 8224A304h */ case   19:  		/* mr R4, R30 */
		/* 8224A304h case   19:*/		regs.R4 = regs.R30;
		/* 8224A304h case   19:*/		return 0x8224A308;
		  /* 8224A308h */ case   20:  		/* mr R3, R31 */
		/* 8224A308h case   20:*/		regs.R3 = regs.R31;
		/* 8224A308h case   20:*/		return 0x8224A30C;
		  /* 8224A30Ch */ case   21:  		/* mtspr CTR, R11 */
		/* 8224A30Ch case   21:*/		regs.CTR = regs.R11;
		/* 8224A30Ch case   21:*/		return 0x8224A310;
		  /* 8224A310h */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 8224A310h case   22:*/		if ( 1 ) { regs.LR = 0x8224A314; return (uint32)regs.CTR; }
		/* 8224A310h case   22:*/		return 0x8224A314;
		  /* 8224A314h */ case   23:  		/* addi R28, R28, 1 */
		/* 8224A314h case   23:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8224A314h case   23:*/		return 0x8224A318;
		  /* 8224A318h */ case   24:  		/* cmpwi CR6, R28, 4 */
		/* 8224A318h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000004);
		/* 8224A318h case   24:*/		return 0x8224A31C;
		  /* 8224A31Ch */ case   25:  		/* bc 12, CR6_LT, -96 */
		/* 8224A31Ch case   25:*/		if ( regs.CR[6].lt ) { return 0x8224A2BC;  }
		/* 8224A31Ch case   25:*/		return 0x8224A320;
	}
	return 0x8224A320;
} // Block from 8224A2B8h-8224A320h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8224A320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A320);
		  /* 8224A320h */ case    0:  		/* mr R4, R30 */
		/* 8224A320h case    0:*/		regs.R4 = regs.R30;
		/* 8224A320h case    0:*/		return 0x8224A324;
		  /* 8224A324h */ case    1:  		/* lwz R5, <#[R29 + 236]> */
		/* 8224A324h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x000000EC) );
		/* 8224A324h case    1:*/		return 0x8224A328;
		  /* 8224A328h */ case    2:  		/* mr R3, R31 */
		/* 8224A328h case    2:*/		regs.R3 = regs.R31;
		/* 8224A328h case    2:*/		return 0x8224A32C;
		  /* 8224A32Ch */ case    3:  		/* bl -82908 */
		/* 8224A32Ch case    3:*/		regs.LR = 0x8224A330; return 0x82235F50;
		/* 8224A32Ch case    3:*/		return 0x8224A330;
		  /* 8224A330h */ case    4:  		/* lwz R11, <#[R1 + 100]> */
		/* 8224A330h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8224A330h case    4:*/		return 0x8224A334;
		  /* 8224A334h */ case    5:  		/* addi R11, R11, 1 */
		/* 8224A334h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224A334h case    5:*/		return 0x8224A338;
		  /* 8224A338h */ case    6:  		/* stw R11, <#[R1 + 100]> */
		/* 8224A338h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8224A338h case    6:*/		return 0x8224A33C;
		  /* 8224A33Ch */ case    7:  		/* b 20 */
		/* 8224A33Ch case    7:*/		return 0x8224A350;
		/* 8224A33Ch case    7:*/		return 0x8224A340;
	}
	return 0x8224A340;
} // Block from 8224A320h-8224A340h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224A340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A340);
		  /* 8224A340h */ case    0:  		/* mr R4, R30 */
		/* 8224A340h case    0:*/		regs.R4 = regs.R30;
		/* 8224A340h case    0:*/		return 0x8224A344;
		  /* 8224A344h */ case    1:  		/* lwz R5, <#[R25]> */
		/* 8224A344h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R25 + 0x00000000) );
		/* 8224A344h case    1:*/		return 0x8224A348;
		  /* 8224A348h */ case    2:  		/* mr R3, R31 */
		/* 8224A348h case    2:*/		regs.R3 = regs.R31;
		/* 8224A348h case    2:*/		return 0x8224A34C;
		  /* 8224A34Ch */ case    3:  		/* bl -82940 */
		/* 8224A34Ch case    3:*/		regs.LR = 0x8224A350; return 0x82235F50;
		/* 8224A34Ch case    3:*/		return 0x8224A350;
	}
	return 0x8224A350;
} // Block from 8224A340h-8224A350h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224A350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A350);
		  /* 8224A350h */ case    0:  		/* li R11, 48 */
		/* 8224A350h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x30);
		/* 8224A350h case    0:*/		return 0x8224A354;
		  /* 8224A354h */ case    1:  		/* li R10, -1 */
		/* 8224A354h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8224A354h case    1:*/		return 0x8224A358;
		  /* 8224A358h */ case    2:  		/* stw R11, <#[R27 + 56]> */
		/* 8224A358h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000038) );
		/* 8224A358h case    2:*/		return 0x8224A35C;
		  /* 8224A35Ch */ case    3:  		/* addi R30, R30, 1 */
		/* 8224A35Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224A35Ch case    3:*/		return 0x8224A360;
		  /* 8224A360h */ case    4:  		/* stw R10, <#[R27 + 32]> */
		/* 8224A360h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000020) );
		/* 8224A360h case    4:*/		return 0x8224A364;
		  /* 8224A364h */ case    5:  		/* addi R25, R25, 4 */
		/* 8224A364h case    5:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 8224A364h case    5:*/		return 0x8224A368;
		  /* 8224A368h */ case    6:  		/* stwu R20, <#[R27 + 4]> */
		/* 8224A368h case    6:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R27 + 0x00000004) );
		regs.R27 = (uint32)(regs.R27 + 0x00000004);
		/* 8224A368h case    6:*/		return 0x8224A36C;
		  /* 8224A36Ch */ case    7:  		/* lwz R11, <#[R31 + 20]> */
		/* 8224A36Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8224A36Ch case    7:*/		return 0x8224A370;
		  /* 8224A370h */ case    8:  		/* cmpw CR6, R30, R11 */
		/* 8224A370h case    8:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 8224A370h case    8:*/		return 0x8224A374;
		  /* 8224A374h */ case    9:  		/* bc 4, CR6_GT, -424 */
		/* 8224A374h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8224A1CC;  }
		/* 8224A374h case    9:*/		return 0x8224A378;
	}
	return 0x8224A378;
} // Block from 8224A350h-8224A378h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224A378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A378);
		  /* 8224A378h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 8224A378h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8224A378h case    0:*/		return 0x8224A37C;
		  /* 8224A37Ch */ case    1:  		/* mr R30, R20 */
		/* 8224A37Ch case    1:*/		regs.R30 = regs.R20;
		/* 8224A37Ch case    1:*/		return 0x8224A380;
		  /* 8224A380h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8224A380h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224A380h case    2:*/		return 0x8224A384;
		  /* 8224A384h */ case    3:  		/* bc 4, CR6_GT, 40 */
		/* 8224A384h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8224A3AC;  }
		/* 8224A384h case    3:*/		return 0x8224A388;
		  /* 8224A388h */ case    4:  		/* addi R29, R23, -4 */
		/* 8224A388h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R23,0xFFFFFFFC);
		/* 8224A388h case    4:*/		return 0x8224A38C;
		  /* 8224A38Ch */ case    5:  		/* mr R5, R24 */
		/* 8224A38Ch case    5:*/		regs.R5 = regs.R24;
		/* 8224A38Ch case    5:*/		return 0x8224A390;
	}
	return 0x8224A390;
} // Block from 8224A378h-8224A390h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224A390h
// Function '?ReplacePhiNodesWithCopies@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A390);
		  /* 8224A390h */ case    0:  		/* lwzu R4, <#[R29 + 4]> */
		/* 8224A390h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000004) );
		regs.R29 = (uint32)(regs.R29 + 0x00000004);
		/* 8224A390h case    0:*/		return 0x8224A394;
		  /* 8224A394h */ case    1:  		/* mr R3, R21 */
		/* 8224A394h case    1:*/		regs.R3 = regs.R21;
		/* 8224A394h case    1:*/		return 0x8224A398;
		  /* 8224A398h */ case    2:  		/* bl 63424 */
		/* 8224A398h case    2:*/		regs.LR = 0x8224A39C; return 0x82259B58;
		/* 8224A398h case    2:*/		return 0x8224A39C;
		  /* 8224A39Ch */ case    3:  		/* lwz R11, <#[R31 + 16]> */
		/* 8224A39Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8224A39Ch case    3:*/		return 0x8224A3A0;
		  /* 8224A3A0h */ case    4:  		/* addi R30, R30, 1 */
		/* 8224A3A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8224A3A0h case    4:*/		return 0x8224A3A4;
		  /* 8224A3A4h */ case    5:  		/* cmpw CR6, R30, R11 */
		/* 8224A3A4h case    5:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 8224A3A4h case    5:*/		return 0x8224A3A8;
		  /* 8224A3A8h */ case    6:  		/* bc 12, CR6_LT, -28 */
		/* 8224A3A8h case    6:*/		if ( regs.CR[6].lt ) { return 0x8224A38C;  }
		/* 8224A3A8h case    6:*/		return 0x8224A3AC;
	}
	return 0x8224A3AC;
} // Block from 8224A390h-8224A3ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224A3ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A3AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A3AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A3AC);
		  /* 8224A3ACh */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 8224A3ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8224A3ACh case    0:*/		return 0x8224A3B0;
		  /* 8224A3B0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224A3B0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224A3B0h case    1:*/		return 0x8224A3B4;
		  /* 8224A3B4h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 8224A3B4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224A3E0;  }
		/* 8224A3B4h case    2:*/		return 0x8224A3B8;
		  /* 8224A3B8h */ case    3:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224A3B8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224A3B8h case    3:*/		return 0x8224A3BC;
		  /* 8224A3BCh */ case    4:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 8224A3BCh case    4:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A3BCh case    4:*/		return 0x8224A3C0;
		  /* 8224A3C0h */ case    5:  		/* bc 4, CR0_EQ, 32 */
		/* 8224A3C0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8224A3E0;  }
		/* 8224A3C0h case    5:*/		return 0x8224A3C4;
		  /* 8224A3C4h */ case    6:  		/* lwz R11, <#[R31 + 80]> */
		/* 8224A3C4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8224A3C4h case    6:*/		return 0x8224A3C8;
		  /* 8224A3C8h */ case    7:  		/* addi R10, R19, 4 */
		/* 8224A3C8h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R19,0x4);
		/* 8224A3C8h case    7:*/		return 0x8224A3CC;
		  /* 8224A3CCh */ case    8:  		/* mulli R11, R11, 12 */
		/* 8224A3CCh case    8:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8224A3CCh case    8:*/		return 0x8224A3D0;
		  /* 8224A3D0h */ case    9:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8224A3D0h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224A3D0h case    9:*/		return 0x8224A3D4;
		  /* 8224A3D4h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 8224A3D4h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224A3D4h case   10:*/		return 0x8224A3D8;
		  /* 8224A3D8h */ case   11:  		/* li R11, 1 */
		/* 8224A3D8h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224A3D8h case   11:*/		return 0x8224A3DC;
		  /* 8224A3DCh */ case   12:  		/* bc 4, CR0_EQ, 8 */
		/* 8224A3DCh case   12:*/		if ( !regs.CR[0].eq ) { return 0x8224A3E4;  }
		/* 8224A3DCh case   12:*/		return 0x8224A3E0;
	}
	return 0x8224A3E0;
} // Block from 8224A3ACh-8224A3E0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224A3E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A3E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A3E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A3E0);
		  /* 8224A3E0h */ case    0:  		/* mr R11, R20 */
		/* 8224A3E0h case    0:*/		regs.R11 = regs.R20;
		/* 8224A3E0h case    0:*/		return 0x8224A3E4;
	}
	return 0x8224A3E4;
} // Block from 8224A3E0h-8224A3E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224A3E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A3E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A3E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A3E4);
		  /* 8224A3E4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224A3E4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224A3E4h case    0:*/		return 0x8224A3E8;
		  /* 8224A3E8h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8224A3E8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8224A400;  }
		/* 8224A3E8h case    1:*/		return 0x8224A3EC;
		  /* 8224A3ECh */ case    2:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224A3ECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224A3ECh case    2:*/		return 0x8224A3F0;
		  /* 8224A3F0h */ case    3:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8224A3F0h case    3:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A3F0h case    3:*/		return 0x8224A3F4;
		  /* 8224A3F4h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 8224A3F4h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8224A400;  }
		/* 8224A3F4h case    4:*/		return 0x8224A3F8;
		  /* 8224A3F8h */ case    5:  		/* lwz R11, <#[R31 + 224]> */
		/* 8224A3F8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E0) );
		/* 8224A3F8h case    5:*/		return 0x8224A3FC;
		  /* 8224A3FCh */ case    6:  		/* stw R11, <#[R31 + 56]> */
		/* 8224A3FCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8224A3FCh case    6:*/		return 0x8224A400;
	}
	return 0x8224A400;
} // Block from 8224A3E4h-8224A400h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224A400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A400);
		  /* 8224A400h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8224A400h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8224A400h case    0:*/		return 0x8224A404;
		  /* 8224A404h */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224A404h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224A404h case    1:*/		return 0x8224A408;
		  /* 8224A408h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8224A408h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224A408h case    2:*/		return 0x8224A40C;
		  /* 8224A40Ch */ case    3:  		/* bc 4, CR6_EQ, -2176 */
		/* 8224A40Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82249B8C;  }
		/* 8224A40Ch case    3:*/		return 0x8224A410;
	}
	return 0x8224A410;
} // Block from 8224A400h-8224A410h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224A410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A410);
		  /* 8224A410h */ case    0:  		/* mr R27, R20 */
		/* 8224A410h case    0:*/		regs.R27 = regs.R20;
		/* 8224A410h case    0:*/		return 0x8224A414;
		  /* 8224A414h */ case    1:  		/* mr R26, R20 */
		/* 8224A414h case    1:*/		regs.R26 = regs.R20;
		/* 8224A414h case    1:*/		return 0x8224A418;
		  /* 8224A418h */ case    2:  		/* li R25, 1 */
		/* 8224A418h case    2:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8224A418h case    2:*/		return 0x8224A41C;
		  /* 8224A41Ch */ case    3:  		/* lwz R11, <#[R21 + 56]> */
		/* 8224A41Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000038) );
		/* 8224A41Ch case    3:*/		return 0x8224A420;
		  /* 8224A420h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 8224A420h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8224A420h case    4:*/		return 0x8224A424;
		  /* 8224A424h */ case    5:  		/* cmplw CR6, R25, R10 */
		/* 8224A424h case    5:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R10);
		/* 8224A424h case    5:*/		return 0x8224A428;
		  /* 8224A428h */ case    6:  		/* bc 4, CR6_GT, 12 */
		/* 8224A428h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8224A434;  }
		/* 8224A428h case    6:*/		return 0x8224A42C;
		  /* 8224A42Ch */ case    7:  		/* mr R11, R20 */
		/* 8224A42Ch case    7:*/		regs.R11 = regs.R20;
		/* 8224A42Ch case    7:*/		return 0x8224A430;
		  /* 8224A430h */ case    8:  		/* b 16 */
		/* 8224A430h case    8:*/		return 0x8224A440;
		/* 8224A430h case    8:*/		return 0x8224A434;
	}
	return 0x8224A434;
} // Block from 8224A410h-8224A434h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224A434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A434);
		  /* 8224A434h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 8224A434h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8224A434h case    0:*/		return 0x8224A438;
		  /* 8224A438h */ case    1:  		/* li R11, 1 */
		/* 8224A438h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224A438h case    1:*/		return 0x8224A43C;
		  /* 8224A43Ch */ case    2:  		/* lwzx R27, <#[R10 + R26]> */
		/* 8224A43Ch case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 8224A43Ch case    2:*/		return 0x8224A440;
	}
	return 0x8224A440;
} // Block from 8224A434h-8224A440h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224A440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A440);
		  /* 8224A440h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224A440h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224A440h case    0:*/		return 0x8224A444;
		  /* 8224A444h */ case    1:  		/* bc 12, CR0_EQ, 300 */
		/* 8224A444h case    1:*/		if ( regs.CR[0].eq ) { return 0x8224A570;  }
		/* 8224A444h case    1:*/		return 0x8224A448;
		  /* 8224A448h */ case    2:  		/* mr R4, R21 */
		/* 8224A448h case    2:*/		regs.R4 = regs.R21;
		/* 8224A448h case    2:*/		return 0x8224A44C;
		  /* 8224A44Ch */ case    3:  		/* mr R3, R27 */
		/* 8224A44Ch case    3:*/		regs.R3 = regs.R27;
		/* 8224A44Ch case    3:*/		return 0x8224A450;
		  /* 8224A450h */ case    4:  		/* bl 61296 */
		/* 8224A450h case    4:*/		regs.LR = 0x8224A454; return 0x822593C0;
		/* 8224A450h case    4:*/		return 0x8224A454;
		  /* 8224A454h */ case    5:  		/* lwz R28, <#[R27 + 28]> */
		/* 8224A454h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R27 + 0x0000001C) );
		/* 8224A454h case    5:*/		return 0x8224A458;
		  /* 8224A458h */ case    6:  		/* mr R29, R3 */
		/* 8224A458h case    6:*/		regs.R29 = regs.R3;
		/* 8224A458h case    6:*/		return 0x8224A45C;
		  /* 8224A45Ch */ case    7:  		/* b 252 */
		/* 8224A45Ch case    7:*/		return 0x8224A558;
		/* 8224A45Ch case    7:*/		return 0x8224A460;
		  /* 8224A460h */ case    8:  		/* lwz R11, <#[R28 + 228]> */
		/* 8224A460h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 8224A460h case    8:*/		return 0x8224A464;
		  /* 8224A464h */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224A464h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A464h case    9:*/		return 0x8224A468;
		  /* 8224A468h */ case   10:  		/* bc 12, CR0_EQ, 236 */
		/* 8224A468h case   10:*/		if ( regs.CR[0].eq ) { return 0x8224A554;  }
		/* 8224A468h case   10:*/		return 0x8224A46C;
		  /* 8224A46Ch */ case   11:  		/* lwz R11, <#[R28]> */
		/* 8224A46Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8224A46Ch case   11:*/		return 0x8224A470;
		  /* 8224A470h */ case   12:  		/* mr R3, R28 */
		/* 8224A470h case   12:*/		regs.R3 = regs.R28;
		/* 8224A470h case   12:*/		return 0x8224A474;
		  /* 8224A474h */ case   13:  		/* lwz R11, <#[R11 + 44]> */
		/* 8224A474h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 8224A474h case   13:*/		return 0x8224A478;
		  /* 8224A478h */ case   14:  		/* mtspr CTR, R11 */
		/* 8224A478h case   14:*/		regs.CTR = regs.R11;
		/* 8224A478h case   14:*/		return 0x8224A47C;
		  /* 8224A47Ch */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 8224A47Ch case   15:*/		if ( 1 ) { regs.LR = 0x8224A480; return (uint32)regs.CTR; }
		/* 8224A47Ch case   15:*/		return 0x8224A480;
		  /* 8224A480h */ case   16:  		/* or. R30, R3, R3 */
		/* 8224A480h case   16:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8224A480h case   16:*/		return 0x8224A484;
		  /* 8224A484h */ case   17:  		/* bc 12, CR0_EQ, 208 */
		/* 8224A484h case   17:*/		if ( regs.CR[0].eq ) { return 0x8224A554;  }
		/* 8224A484h case   17:*/		return 0x8224A488;
		  /* 8224A488h */ case   18:  		/* lwz R31, <#[R30 + 28]> */
		/* 8224A488h case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x0000001C) );
		/* 8224A488h case   18:*/		return 0x8224A48C;
		  /* 8224A48Ch */ case   19:  		/* cmplwi CR6, R31, 0 */
		/* 8224A48Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8224A48Ch case   19:*/		return 0x8224A490;
		  /* 8224A490h */ case   20:  		/* bc 4, CR6_EQ, 28 */
		/* 8224A490h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8224A4AC;  }
		/* 8224A490h case   20:*/		return 0x8224A494;
		  /* 8224A494h */ case   21:  		/* mr R6, R15 */
		/* 8224A494h case   21:*/		regs.R6 = regs.R15;
		/* 8224A494h case   21:*/		return 0x8224A498;
		  /* 8224A498h */ case   22:  		/* lwz R5, <#[R1 + 104]> */
		/* 8224A498h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 8224A498h case   22:*/		return 0x8224A49C;
		  /* 8224A49Ch */ case   23:  		/* mr R4, R16 */
		/* 8224A49Ch case   23:*/		regs.R4 = regs.R16;
		/* 8224A49Ch case   23:*/		return 0x8224A4A0;
		  /* 8224A4A0h */ case   24:  		/* li R7, 1318 */
		/* 8224A4A0h case   24:*/		cpu::op::li<0>(regs,&regs.R7,0x526);
		/* 8224A4A0h case   24:*/		return 0x8224A4A4;
		  /* 8224A4A4h */ case   25:  		/* li R3, 0 */
		/* 8224A4A4h case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224A4A4h case   25:*/		return 0x8224A4A8;
		  /* 8224A4A8h */ case   26:  		/* bl -993440 */
		/* 8224A4A8h case   26:*/		regs.LR = 0x8224A4AC; return 0x82157C08;
		/* 8224A4A8h case   26:*/		return 0x8224A4AC;
	}
	return 0x8224A4AC;
} // Block from 8224A440h-8224A4ACh (27 instructions)

//////////////////////////////////////////////////////
// Block at 8224A4ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A4AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A4AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A4AC);
		  /* 8224A4ACh */ case    0:  		/* mr R3, R31 */
		/* 8224A4ACh case    0:*/		regs.R3 = regs.R31;
		/* 8224A4ACh case    0:*/		return 0x8224A4B0;
		  /* 8224A4B0h */ case    1:  		/* lwz R5, <#[R22 + 12]> */
		/* 8224A4B0h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R22 + 0x0000000C) );
		/* 8224A4B0h case    1:*/		return 0x8224A4B4;
		  /* 8224A4B4h */ case    2:  		/* lwz R4, <#[R22 + 164]> */
		/* 8224A4B4h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x000000A4) );
		/* 8224A4B4h case    2:*/		return 0x8224A4B8;
		  /* 8224A4B8h */ case    3:  		/* bl 41088 */
		/* 8224A4B8h case    3:*/		regs.LR = 0x8224A4BC; return 0x82254538;
		/* 8224A4B8h case    3:*/		return 0x8224A4BC;
		  /* 8224A4BCh */ case    4:  		/* mr R31, R3 */
		/* 8224A4BCh case    4:*/		regs.R31 = regs.R3;
		/* 8224A4BCh case    4:*/		return 0x8224A4C0;
		  /* 8224A4C0h */ case    5:  		/* mr R4, R29 */
		/* 8224A4C0h case    5:*/		regs.R4 = regs.R29;
		/* 8224A4C0h case    5:*/		return 0x8224A4C4;
		  /* 8224A4C4h */ case    6:  		/* mr R3, R30 */
		/* 8224A4C4h case    6:*/		regs.R3 = regs.R30;
		/* 8224A4C4h case    6:*/		return 0x8224A4C8;
		  /* 8224A4C8h */ case    7:  		/* lwz R5, <#[R31 + 16]> */
		/* 8224A4C8h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 8224A4C8h case    7:*/		return 0x8224A4CC;
		  /* 8224A4CCh */ case    8:  		/* bl -83324 */
		/* 8224A4CCh case    8:*/		regs.LR = 0x8224A4D0; return 0x82235F50;
		/* 8224A4CCh case    8:*/		return 0x8224A4D0;
		  /* 8224A4D0h */ case    9:  		/* li R10, 4 */
		/* 8224A4D0h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 8224A4D0h case    9:*/		return 0x8224A4D4;
		  /* 8224A4D4h */ case   10:  		/* rlwinm R9, R29, 2, 0, 29 */
		/* 8224A4D4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R29);
		/* 8224A4D4h case   10:*/		return 0x8224A4D8;
		  /* 8224A4D8h */ case   11:  		/* mr R11, R20 */
		/* 8224A4D8h case   11:*/		regs.R11 = regs.R20;
		/* 8224A4D8h case   11:*/		return 0x8224A4DC;
		  /* 8224A4DCh */ case   12:  		/* addi R8, R9, 91 */
		/* 8224A4DCh case   12:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x5B);
		/* 8224A4DCh case   12:*/		return 0x8224A4E0;
		  /* 8224A4E0h */ case   13:  		/* addi R9, R31, -4 */
		/* 8224A4E0h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0xFFFFFFFC);
		/* 8224A4E0h case   13:*/		return 0x8224A4E4;
		  /* 8224A4E4h */ case   14:  		/* mtspr CTR, R10 */
		/* 8224A4E4h case   14:*/		regs.CTR = regs.R10;
		/* 8224A4E4h case   14:*/		return 0x8224A4E8;
		  /* 8224A4E8h */ case   15:  		/* add R7, R11, R8 */
		/* 8224A4E8h case   15:*/		cpu::op::add<0>(regs,&regs.R7,regs.R11,regs.R8);
		/* 8224A4E8h case   15:*/		return 0x8224A4EC;
		  /* 8224A4ECh */ case   16:  		/* lwzu R10, <#[R9 + 4]> */
		/* 8224A4ECh case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8224A4ECh case   16:*/		return 0x8224A4F0;
		  /* 8224A4F0h */ case   17:  		/* addi R11, R11, 1 */
		/* 8224A4F0h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224A4F0h case   17:*/		return 0x8224A4F4;
		  /* 8224A4F4h */ case   18:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8224A4F4h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8224A4F4h case   18:*/		return 0x8224A4F8;
		  /* 8224A4F8h */ case   19:  		/* stwx R10, <#[R7 + R30]> */
		/* 8224A4F8h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + regs.R30 + 0x00000000) );
		/* 8224A4F8h case   19:*/		return 0x8224A4FC;
		  /* 8224A4FCh */ case   20:  		/* bc 16, CR0_LT, -20 */
		/* 8224A4FCh case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8224A4E8;  }
		/* 8224A4FCh case   20:*/		return 0x8224A500;
		  /* 8224A500h */ case   21:  		/* lwz R11, <#[R30 + 16]> */
		/* 8224A500h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8224A500h case   21:*/		return 0x8224A504;
		  /* 8224A504h */ case   22:  		/* cmpwi CR6, R11, 0 */
		/* 8224A504h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224A504h case   22:*/		return 0x8224A508;
		  /* 8224A508h */ case   23:  		/* bc 12, CR6_EQ, 44 */
		/* 8224A508h case   23:*/		if ( regs.CR[6].eq ) { return 0x8224A534;  }
		/* 8224A508h case   23:*/		return 0x8224A50C;
		  /* 8224A50Ch */ case   24:  		/* lwz R11, <#[R30 + 228]> */
		/* 8224A50Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224A50Ch case   24:*/		return 0x8224A510;
		  /* 8224A510h */ case   25:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 8224A510h case   25:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A510h case   25:*/		return 0x8224A514;
		  /* 8224A514h */ case   26:  		/* bc 4, CR0_EQ, 32 */
		/* 8224A514h case   26:*/		if ( !regs.CR[0].eq ) { return 0x8224A534;  }
		/* 8224A514h case   26:*/		return 0x8224A518;
		  /* 8224A518h */ case   27:  		/* lwz R11, <#[R30 + 80]> */
		/* 8224A518h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000050) );
		/* 8224A518h case   27:*/		return 0x8224A51C;
		  /* 8224A51Ch */ case   28:  		/* addi R10, R19, 4 */
		/* 8224A51Ch case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R19,0x4);
		/* 8224A51Ch case   28:*/		return 0x8224A520;
		  /* 8224A520h */ case   29:  		/* mulli R11, R11, 12 */
		/* 8224A520h case   29:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8224A520h case   29:*/		return 0x8224A524;
		  /* 8224A524h */ case   30:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8224A524h case   30:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224A524h case   30:*/		return 0x8224A528;
		  /* 8224A528h */ case   31:  		/* cmplwi CR0, R11, 0 */
		/* 8224A528h case   31:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224A528h case   31:*/		return 0x8224A52C;
		  /* 8224A52Ch */ case   32:  		/* li R11, 1 */
		/* 8224A52Ch case   32:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224A52Ch case   32:*/		return 0x8224A530;
		  /* 8224A530h */ case   33:  		/* bc 4, CR0_EQ, 8 */
		/* 8224A530h case   33:*/		if ( !regs.CR[0].eq ) { return 0x8224A538;  }
		/* 8224A530h case   33:*/		return 0x8224A534;
	}
	return 0x8224A534;
} // Block from 8224A4ACh-8224A534h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8224A534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A534);
		  /* 8224A534h */ case    0:  		/* mr R11, R20 */
		/* 8224A534h case    0:*/		regs.R11 = regs.R20;
		/* 8224A534h case    0:*/		return 0x8224A538;
	}
	return 0x8224A538;
} // Block from 8224A534h-8224A538h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224A538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A538);
		  /* 8224A538h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224A538h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224A538h case    0:*/		return 0x8224A53C;
		  /* 8224A53Ch */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8224A53Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8224A554;  }
		/* 8224A53Ch case    1:*/		return 0x8224A540;
		  /* 8224A540h */ case    2:  		/* lwz R11, <#[R30 + 228]> */
		/* 8224A540h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 8224A540h case    2:*/		return 0x8224A544;
		  /* 8224A544h */ case    3:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8224A544h case    3:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A544h case    3:*/		return 0x8224A548;
		  /* 8224A548h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 8224A548h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8224A554;  }
		/* 8224A548h case    4:*/		return 0x8224A54C;
		  /* 8224A54Ch */ case    5:  		/* lwz R11, <#[R30 + 224]> */
		/* 8224A54Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E0) );
		/* 8224A54Ch case    5:*/		return 0x8224A550;
		  /* 8224A550h */ case    6:  		/* stw R11, <#[R30 + 56]> */
		/* 8224A550h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 8224A550h case    6:*/		return 0x8224A554;
	}
	return 0x8224A554;
} // Block from 8224A538h-8224A554h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224A554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A554);
		  /* 8224A554h */ case    0:  		/* lwz R28, <#[R28 + 8]> */
		/* 8224A554h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000008) );
		/* 8224A554h case    0:*/		return 0x8224A558;
	}
	return 0x8224A558;
} // Block from 8224A554h-8224A558h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224A558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A558);
		  /* 8224A558h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8224A558h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8224A558h case    0:*/		return 0x8224A55C;
		  /* 8224A55Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224A55Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224A55Ch case    1:*/		return 0x8224A560;
		  /* 8224A560h */ case    2:  		/* bc 4, CR6_EQ, -256 */
		/* 8224A560h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224A460;  }
		/* 8224A560h case    2:*/		return 0x8224A564;
		  /* 8224A564h */ case    3:  		/* addi R25, R25, 1 */
		/* 8224A564h case    3:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8224A564h case    3:*/		return 0x8224A568;
		  /* 8224A568h */ case    4:  		/* addi R26, R26, 4 */
		/* 8224A568h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8224A568h case    4:*/		return 0x8224A56C;
		  /* 8224A56Ch */ case    5:  		/* b -336 */
		/* 8224A56Ch case    5:*/		return 0x8224A41C;
		/* 8224A56Ch case    5:*/		return 0x8224A570;
	}
	return 0x8224A570;
} // Block from 8224A558h-8224A570h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224A570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A570);
		  /* 8224A570h */ case    0:  		/* mr R3, R21 */
		/* 8224A570h case    0:*/		regs.R3 = regs.R21;
		/* 8224A570h case    0:*/		return 0x8224A574;
		  /* 8224A574h */ case    1:  		/* bl 61292 */
		/* 8224A574h case    1:*/		regs.LR = 0x8224A578; return 0x822594E0;
		/* 8224A574h case    1:*/		return 0x8224A578;
		  /* 8224A578h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224A578h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224A578h case    2:*/		return 0x8224A57C;
		  /* 8224A57Ch */ case    3:  		/* bc 12, CR0_EQ, 120 */
		/* 8224A57Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8224A5F4;  }
		/* 8224A57Ch case    3:*/		return 0x8224A580;
		  /* 8224A580h */ case    4:  		/* lwz R29, <#[R21 + 88]> */
		/* 8224A580h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R21 + 0x00000058) );
		/* 8224A580h case    4:*/		return 0x8224A584;
		  /* 8224A584h */ case    5:  		/* lwz R11, <#[R29 + 4]> */
		/* 8224A584h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8224A584h case    5:*/		return 0x8224A588;
		  /* 8224A588h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8224A588h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224A588h case    6:*/		return 0x8224A58C;
		  /* 8224A58Ch */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 8224A58Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8224A598;  }
		/* 8224A58Ch case    7:*/		return 0x8224A590;
		  /* 8224A590h */ case    8:  		/* lwz R10, <#[R29 + 8]> */
		/* 8224A590h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8224A590h case    8:*/		return 0x8224A594;
		  /* 8224A594h */ case    9:  		/* b 8 */
		/* 8224A594h case    9:*/		return 0x8224A59C;
		/* 8224A594h case    9:*/		return 0x8224A598;
	}
	return 0x8224A598;
} // Block from 8224A570h-8224A598h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224A598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A598);
		  /* 8224A598h */ case    0:  		/* mr R10, R20 */
		/* 8224A598h case    0:*/		regs.R10 = regs.R20;
		/* 8224A598h case    0:*/		return 0x8224A59C;
	}
	return 0x8224A59C;
} // Block from 8224A598h-8224A59Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224A59Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A59C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A59C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A59C);
		  /* 8224A59Ch */ case    0:  		/* lwz R21, <#[R10]> */
		/* 8224A59Ch case    0:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R10 + 0x00000000) );
		/* 8224A59Ch case    0:*/		return 0x8224A5A0;
		  /* 8224A5A0h */ case    1:  		/* li R31, 1 */
		/* 8224A5A0h case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 8224A5A0h case    1:*/		return 0x8224A5A4;
		  /* 8224A5A4h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 8224A5A4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8224A5A4h case    2:*/		return 0x8224A5A8;
		  /* 8224A5A8h */ case    3:  		/* bc 4, CR6_GT, 220 */
		/* 8224A5A8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8224A684;  }
		/* 8224A5A8h case    3:*/		return 0x8224A5AC;
		  /* 8224A5ACh */ case    4:  		/* li R30, 4 */
		/* 8224A5ACh case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x4);
		/* 8224A5ACh case    4:*/		return 0x8224A5B0;
	}
	return 0x8224A5B0;
} // Block from 8224A59Ch-8224A5B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224A5B0h
// Function '?Rename@CFG@XGRAPHICS@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A5B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A5B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A5B0);
		  /* 8224A5B0h */ case    0:  		/* cmplw CR6, R31, R11 */
		/* 8224A5B0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8224A5B0h case    0:*/		return 0x8224A5B4;
		  /* 8224A5B4h */ case    1:  		/* bc 4, CR6_LT, 16 */
		/* 8224A5B4h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8224A5C4;  }
		/* 8224A5B4h case    1:*/		return 0x8224A5B8;
		  /* 8224A5B8h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 8224A5B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8224A5B8h case    2:*/		return 0x8224A5BC;
		  /* 8224A5BCh */ case    3:  		/* add R11, R11, R30 */
		/* 8224A5BCh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8224A5BCh case    3:*/		return 0x8224A5C0;
		  /* 8224A5C0h */ case    4:  		/* b 8 */
		/* 8224A5C0h case    4:*/		return 0x8224A5C8;
		/* 8224A5C0h case    4:*/		return 0x8224A5C4;
	}
	return 0x8224A5C4;
} // Block from 8224A5B0h-8224A5C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224A5C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A5C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A5C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A5C4);
		  /* 8224A5C4h */ case    0:  		/* mr R11, R20 */
		/* 8224A5C4h case    0:*/		regs.R11 = regs.R20;
		/* 8224A5C4h case    0:*/		return 0x8224A5C8;
	}
	return 0x8224A5C8;
} // Block from 8224A5C4h-8224A5C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224A5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A5C8);
		  /* 8224A5C8h */ case    0:  		/* addi R3, R1, 144 */
		/* 8224A5C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x90);
		/* 8224A5C8h case    0:*/		return 0x8224A5CC;
		  /* 8224A5CCh */ case    1:  		/* lwz R4, <#[R1 + 148]> */
		/* 8224A5CCh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000094) );
		/* 8224A5CCh case    1:*/		return 0x8224A5D0;
		  /* 8224A5D0h */ case    2:  		/* lwz R28, <#[R11]> */
		/* 8224A5D0h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 8224A5D0h case    2:*/		return 0x8224A5D4;
		  /* 8224A5D4h */ case    3:  		/* bl 38124 */
		/* 8224A5D4h case    3:*/		regs.LR = 0x8224A5D8; return 0x82253AC0;
		/* 8224A5D4h case    3:*/		return 0x8224A5D8;
		  /* 8224A5D8h */ case    4:  		/* addi R31, R31, 1 */
		/* 8224A5D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8224A5D8h case    4:*/		return 0x8224A5DC;
		  /* 8224A5DCh */ case    5:  		/* stw R28, <#[R3]> */
		/* 8224A5DCh case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 8224A5DCh case    5:*/		return 0x8224A5E0;
		  /* 8224A5E0h */ case    6:  		/* addi R30, R30, 4 */
		/* 8224A5E0h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8224A5E0h case    6:*/		return 0x8224A5E4;
		  /* 8224A5E4h */ case    7:  		/* lwz R11, <#[R29 + 4]> */
		/* 8224A5E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8224A5E4h case    7:*/		return 0x8224A5E8;
		  /* 8224A5E8h */ case    8:  		/* cmplw CR6, R31, R11 */
		/* 8224A5E8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8224A5E8h case    8:*/		return 0x8224A5EC;
		  /* 8224A5ECh */ case    9:  		/* bc 12, CR6_LT, -52 */
		/* 8224A5ECh case    9:*/		if ( regs.CR[6].lt ) { return 0x8224A5B8;  }
		/* 8224A5ECh case    9:*/		return 0x8224A5F0;
		  /* 8224A5F0h */ case   10:  		/* b 148 */
		/* 8224A5F0h case   10:*/		return 0x8224A684;
		/* 8224A5F0h case   10:*/		return 0x8224A5F4;
	}
	return 0x8224A5F4;
} // Block from 8224A5C8h-8224A5F4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224A5F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A5F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A5F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A5F4);
		  /* 8224A5F4h */ case    0:  		/* mr R3, R21 */
		/* 8224A5F4h case    0:*/		regs.R3 = regs.R21;
		/* 8224A5F4h case    0:*/		return 0x8224A5F8;
		  /* 8224A5F8h */ case    1:  		/* bl 62744 */
		/* 8224A5F8h case    1:*/		regs.LR = 0x8224A5FC; return 0x82259B10;
		/* 8224A5F8h case    1:*/		return 0x8224A5FC;
		  /* 8224A5FCh */ case    2:  		/* lwz R11, <#[R22 + 12]> */
		/* 8224A5FCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 8224A5FCh case    2:*/		return 0x8224A600;
		  /* 8224A600h */ case    3:  		/* lwz R11, <#[R11 + 2136]> */
		/* 8224A600h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000858) );
		/* 8224A600h case    3:*/		return 0x8224A604;
		  /* 8224A604h */ case    4:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 8224A604h case    4:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A604h case    4:*/		return 0x8224A608;
		  /* 8224A608h */ case    5:  		/* bc 12, CR0_EQ, 32 */
		/* 8224A608h case    5:*/		if ( regs.CR[0].eq ) { return 0x8224A628;  }
		/* 8224A608h case    5:*/		return 0x8224A60C;
		  /* 8224A60Ch */ case    6:  		/* lwz R31, <#[R1 + 80]> */
		/* 8224A60Ch case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 8224A60Ch case    6:*/		return 0x8224A610;
		  /* 8224A610h */ case    7:  		/* addi R3, R1, 128 */
		/* 8224A610h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8224A610h case    7:*/		return 0x8224A614;
		  /* 8224A614h */ case    8:  		/* mr R4, R31 */
		/* 8224A614h case    8:*/		regs.R4 = regs.R31;
		/* 8224A614h case    8:*/		return 0x8224A618;
		  /* 8224A618h */ case    9:  		/* bl 37864 */
		/* 8224A618h case    9:*/		regs.LR = 0x8224A61C; return 0x82253A00;
		/* 8224A618h case    9:*/		return 0x8224A61C;
		  /* 8224A61Ch */ case   10:  		/* addi R30, R31, -1 */
		/* 8224A61Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0xFFFFFFFF);
		/* 8224A61Ch case   10:*/		return 0x8224A620;
		  /* 8224A620h */ case   11:  		/* stw R30, <#[R1 + 80]> */
		/* 8224A620h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8224A620h case   11:*/		return 0x8224A624;
		  /* 8224A624h */ case   12:  		/* b 8 */
		/* 8224A624h case   12:*/		return 0x8224A62C;
		/* 8224A624h case   12:*/		return 0x8224A628;
	}
	return 0x8224A628;
} // Block from 8224A5F4h-8224A628h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224A628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A628);
		  /* 8224A628h */ case    0:  		/* lwz R30, <#[R1 + 80]> */
		/* 8224A628h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8224A628h case    0:*/		return 0x8224A62C;
	}
	return 0x8224A62C;
} // Block from 8224A628h-8224A62Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224A62Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A62C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A62C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A62C);
		  /* 8224A62Ch */ case    0:  		/* addi R3, R1, 144 */
		/* 8224A62Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x90);
		/* 8224A62Ch case    0:*/		return 0x8224A630;
		  /* 8224A630h */ case    1:  		/* lwz R31, <#[R21 + 84]> */
		/* 8224A630h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R21 + 0x00000054) );
		/* 8224A630h case    1:*/		return 0x8224A634;
		  /* 8224A634h */ case    2:  		/* bl 67356 */
		/* 8224A634h case    2:*/		regs.LR = 0x8224A638; return 0x8225AD50;
		/* 8224A634h case    2:*/		return 0x8224A638;
		  /* 8224A638h */ case    3:  		/* mr R21, R3 */
		/* 8224A638h case    3:*/		regs.R21 = regs.R3;
		/* 8224A638h case    3:*/		return 0x8224A63C;
		  /* 8224A63Ch */ case    4:  		/* b 64 */
		/* 8224A63Ch case    4:*/		return 0x8224A67C;
		/* 8224A63Ch case    4:*/		return 0x8224A640;
		  /* 8224A640h */ case    5:  		/* lwz R11, <#[R21 + 84]> */
		/* 8224A640h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000054) );
		/* 8224A640h case    5:*/		return 0x8224A644;
		  /* 8224A644h */ case    6:  		/* cmplw CR6, R31, R11 */
		/* 8224A644h case    6:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8224A644h case    6:*/		return 0x8224A648;
		  /* 8224A648h */ case    7:  		/* bc 12, CR6_EQ, 60 */
		/* 8224A648h case    7:*/		if ( regs.CR[6].eq ) { return 0x8224A684;  }
		/* 8224A648h case    7:*/		return 0x8224A64C;
		  /* 8224A64Ch */ case    8:  		/* mr R3, R31 */
		/* 8224A64Ch case    8:*/		regs.R3 = regs.R31;
		/* 8224A64Ch case    8:*/		return 0x8224A650;
		  /* 8224A650h */ case    9:  		/* bl 62656 */
		/* 8224A650h case    9:*/		regs.LR = 0x8224A654; return 0x82259B10;
		/* 8224A650h case    9:*/		return 0x8224A654;
		  /* 8224A654h */ case   10:  		/* lwz R11, <#[R22 + 12]> */
		/* 8224A654h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 8224A654h case   10:*/		return 0x8224A658;
		  /* 8224A658h */ case   11:  		/* lwz R11, <#[R11 + 2136]> */
		/* 8224A658h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000858) );
		/* 8224A658h case   11:*/		return 0x8224A65C;
		  /* 8224A65Ch */ case   12:  		/* lwz R31, <#[R31 + 84]> */
		/* 8224A65Ch case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000054) );
		/* 8224A65Ch case   12:*/		return 0x8224A660;
		  /* 8224A660h */ case   13:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 8224A660h case   13:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A660h case   13:*/		return 0x8224A664;
		  /* 8224A664h */ case   14:  		/* bc 12, CR0_EQ, 24 */
		/* 8224A664h case   14:*/		if ( regs.CR[0].eq ) { return 0x8224A67C;  }
		/* 8224A664h case   14:*/		return 0x8224A668;
		  /* 8224A668h */ case   15:  		/* mr R4, R30 */
		/* 8224A668h case   15:*/		regs.R4 = regs.R30;
		/* 8224A668h case   15:*/		return 0x8224A66C;
		  /* 8224A66Ch */ case   16:  		/* addi R3, R1, 128 */
		/* 8224A66Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8224A66Ch case   16:*/		return 0x8224A670;
		  /* 8224A670h */ case   17:  		/* bl 37776 */
		/* 8224A670h case   17:*/		regs.LR = 0x8224A674; return 0x82253A00;
		/* 8224A670h case   17:*/		return 0x8224A674;
		  /* 8224A674h */ case   18:  		/* addi R30, R30, -1 */
		/* 8224A674h case   18:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 8224A674h case   18:*/		return 0x8224A678;
		  /* 8224A678h */ case   19:  		/* stw R30, <#[R1 + 80]> */
		/* 8224A678h case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8224A678h case   19:*/		return 0x8224A67C;
	}
	return 0x8224A67C;
} // Block from 8224A62Ch-8224A67Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8224A67Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A67C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A67C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A67C);
		  /* 8224A67Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8224A67Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8224A67Ch case    0:*/		return 0x8224A680;
		  /* 8224A680h */ case    1:  		/* bc 4, CR6_EQ, -64 */
		/* 8224A680h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224A640;  }
		/* 8224A680h case    1:*/		return 0x8224A684;
	}
	return 0x8224A684;
} // Block from 8224A67Ch-8224A684h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224A684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A684);
		  /* 8224A684h */ case    0:  		/* lwz R11, <#[R1 + 148]> */
		/* 8224A684h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 8224A684h case    0:*/		return 0x8224A688;
		  /* 8224A688h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224A688h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224A688h case    1:*/		return 0x8224A68C;
		  /* 8224A68Ch */ case    2:  		/* bc 4, CR6_EQ, -2964 */
		/* 8224A68Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82249AF8;  }
		/* 8224A68Ch case    2:*/		return 0x8224A690;
		  /* 8224A690h */ case    3:  		/* lwz R3, <#[R22 + 12]> */
		/* 8224A690h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x0000000C) );
		/* 8224A690h case    3:*/		return 0x8224A694;
		  /* 8224A694h */ case    4:  		/* lwz R11, <#[R3 + 2136]> */
		/* 8224A694h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000858) );
		/* 8224A694h case    4:*/		return 0x8224A698;
		  /* 8224A698h */ case    5:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 8224A698h case    5:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A698h case    5:*/		return 0x8224A69C;
		  /* 8224A69Ch */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 8224A69Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x8224A6B8;  }
		/* 8224A69Ch case    6:*/		return 0x8224A6A0;
		  /* 8224A6A0h */ case    7:  		/* lwz R5, <#[R1 + 92]> */
		/* 8224A6A0h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 8224A6A0h case    7:*/		return 0x8224A6A4;
		  /* 8224A6A4h */ case    8:  		/* cmpwi CR6, R5, 0 */
		/* 8224A6A4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8224A6A4h case    8:*/		return 0x8224A6A8;
		  /* 8224A6A8h */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 8224A6A8h case    9:*/		if ( regs.CR[6].eq ) { return 0x8224A6B8;  }
		/* 8224A6A8h case    9:*/		return 0x8224A6AC;
		  /* 8224A6ACh */ case   10:  		/* lis R11, -32252 */
		/* 8224A6ACh case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224A6ACh case   10:*/		return 0x8224A6B0;
		  /* 8224A6B0h */ case   11:  		/* addi R4, R11, 13812 */
		/* 8224A6B0h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x35F4);
		/* 8224A6B0h case   11:*/		return 0x8224A6B4;
		  /* 8224A6B4h */ case   12:  		/* bl -185076 */
		/* 8224A6B4h case   12:*/		regs.LR = 0x8224A6B8; return 0x8221D3C0;
		/* 8224A6B4h case   12:*/		return 0x8224A6B8;
	}
	return 0x8224A6B8;
} // Block from 8224A684h-8224A6B8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8224A6B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A6B8);
		  /* 8224A6B8h */ case    0:  		/* lwz R3, <#[R22 + 12]> */
		/* 8224A6B8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x0000000C) );
		/* 8224A6B8h case    0:*/		return 0x8224A6BC;
		  /* 8224A6BCh */ case    1:  		/* lwz R11, <#[R3 + 2136]> */
		/* 8224A6BCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000858) );
		/* 8224A6BCh case    1:*/		return 0x8224A6C0;
		  /* 8224A6C0h */ case    2:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 8224A6C0h case    2:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8224A6C0h case    2:*/		return 0x8224A6C4;
		  /* 8224A6C4h */ case    3:  		/* bc 12, CR0_EQ, 56 */
		/* 8224A6C4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8224A6FC;  }
		/* 8224A6C4h case    3:*/		return 0x8224A6C8;
		  /* 8224A6C8h */ case    4:  		/* lwz R5, <#[R1 + 84]> */
		/* 8224A6C8h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 8224A6C8h case    4:*/		return 0x8224A6CC;
		  /* 8224A6CCh */ case    5:  		/* cmpwi CR6, R5, 0 */
		/* 8224A6CCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8224A6CCh case    5:*/		return 0x8224A6D0;
		  /* 8224A6D0h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 8224A6D0h case    6:*/		if ( regs.CR[6].eq ) { return 0x8224A6E0;  }
		/* 8224A6D0h case    6:*/		return 0x8224A6D4;
		  /* 8224A6D4h */ case    7:  		/* lis R11, -32252 */
		/* 8224A6D4h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224A6D4h case    7:*/		return 0x8224A6D8;
		  /* 8224A6D8h */ case    8:  		/* addi R4, R11, 13752 */
		/* 8224A6D8h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x35B8);
		/* 8224A6D8h case    8:*/		return 0x8224A6DC;
		  /* 8224A6DCh */ case    9:  		/* bl -185116 */
		/* 8224A6DCh case    9:*/		regs.LR = 0x8224A6E0; return 0x8221D3C0;
		/* 8224A6DCh case    9:*/		return 0x8224A6E0;
	}
	return 0x8224A6E0;
} // Block from 8224A6B8h-8224A6E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224A6E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A6E0);
		  /* 8224A6E0h */ case    0:  		/* lwz R5, <#[R1 + 96]> */
		/* 8224A6E0h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000060) );
		/* 8224A6E0h case    0:*/		return 0x8224A6E4;
		  /* 8224A6E4h */ case    1:  		/* cmpwi CR6, R5, 0 */
		/* 8224A6E4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8224A6E4h case    1:*/		return 0x8224A6E8;
		  /* 8224A6E8h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8224A6E8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224A6FC;  }
		/* 8224A6E8h case    2:*/		return 0x8224A6EC;
		  /* 8224A6ECh */ case    3:  		/* lis R11, -32252 */
		/* 8224A6ECh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224A6ECh case    3:*/		return 0x8224A6F0;
		  /* 8224A6F0h */ case    4:  		/* lwz R3, <#[R22 + 12]> */
		/* 8224A6F0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x0000000C) );
		/* 8224A6F0h case    4:*/		return 0x8224A6F4;
		  /* 8224A6F4h */ case    5:  		/* addi R4, R11, 13692 */
		/* 8224A6F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x357C);
		/* 8224A6F4h case    5:*/		return 0x8224A6F8;
		  /* 8224A6F8h */ case    6:  		/* bl -185144 */
		/* 8224A6F8h case    6:*/		regs.LR = 0x8224A6FC; return 0x8221D3C0;
		/* 8224A6F8h case    6:*/		return 0x8224A6FC;
	}
	return 0x8224A6FC;
} // Block from 8224A6E0h-8224A6FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224A6FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A6FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A6FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A6FC);
		  /* 8224A6FCh */ case    0:  		/* lwz R5, <#[R1 + 100]> */
		/* 8224A6FCh case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000064) );
		/* 8224A6FCh case    0:*/		return 0x8224A700;
		  /* 8224A700h */ case    1:  		/* cmpwi CR6, R5, 0 */
		/* 8224A700h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8224A700h case    1:*/		return 0x8224A704;
		  /* 8224A704h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8224A704h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224A718;  }
		/* 8224A704h case    2:*/		return 0x8224A708;
		  /* 8224A708h */ case    3:  		/* lis R11, -32252 */
		/* 8224A708h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224A708h case    3:*/		return 0x8224A70C;
		  /* 8224A70Ch */ case    4:  		/* lwz R3, <#[R22 + 12]> */
		/* 8224A70Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x0000000C) );
		/* 8224A70Ch case    4:*/		return 0x8224A710;
		  /* 8224A710h */ case    5:  		/* addi R4, R11, 13640 */
		/* 8224A710h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3548);
		/* 8224A710h case    5:*/		return 0x8224A714;
		  /* 8224A714h */ case    6:  		/* bl -185172 */
		/* 8224A714h case    6:*/		regs.LR = 0x8224A718; return 0x8221D3C0;
		/* 8224A714h case    6:*/		return 0x8224A718;
	}
	return 0x8224A718;
} // Block from 8224A6FCh-8224A718h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224A718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A718);
		  /* 8224A718h */ case    0:  		/* lwz R11, <#[R22 + 12]> */
		/* 8224A718h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 8224A718h case    0:*/		return 0x8224A71C;
		  /* 8224A71Ch */ case    1:  		/* li R10, 1 */
		/* 8224A71Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8224A71Ch case    1:*/		return 0x8224A720;
		  /* 8224A720h */ case    2:  		/* stb R10, <#[R11 + 1393]> */
		/* 8224A720h case    2:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000571) );
		/* 8224A720h case    2:*/		return 0x8224A724;
		  /* 8224A724h */ case    3:  		/* lwz R4, <#[R1 + 136]> */
		/* 8224A724h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 8224A724h case    3:*/		return 0x8224A728;
		  /* 8224A728h */ case    4:  		/* lwz R3, <#[R1 + 140]> */
		/* 8224A728h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000008C) );
		/* 8224A728h case    4:*/		return 0x8224A72C;
		  /* 8224A72Ch */ case    5:  		/* bl -188652 */
		/* 8224A72Ch case    5:*/		regs.LR = 0x8224A730; return 0x8221C640;
		/* 8224A72Ch case    5:*/		return 0x8224A730;
		  /* 8224A730h */ case    6:  		/* lwz R4, <#[R1 + 152]> */
		/* 8224A730h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000098) );
		/* 8224A730h case    6:*/		return 0x8224A734;
		  /* 8224A734h */ case    7:  		/* lwz R3, <#[R1 + 156]> */
		/* 8224A734h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000009C) );
		/* 8224A734h case    7:*/		return 0x8224A738;
		  /* 8224A738h */ case    8:  		/* bl -188664 */
		/* 8224A738h case    8:*/		regs.LR = 0x8224A73C; return 0x8221C640;
		/* 8224A738h case    8:*/		return 0x8224A73C;
		  /* 8224A73Ch */ case    9:  		/* addi R1, R1, 336 */
		/* 8224A73Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x150);
		/* 8224A73Ch case    9:*/		return 0x8224A740;
		  /* 8224A740h */ case   10:  		/* b -1807568 */
		/* 8224A740h case   10:*/		return 0x82091270;
		/* 8224A740h case   10:*/		return 0x8224A744;
		  /* 8224A744h */ case   11:  		/* nop */
		/* 8224A744h case   11:*/		cpu::op::nop();
		/* 8224A744h case   11:*/		return 0x8224A748;
	}
	return 0x8224A748;
} // Block from 8224A718h-8224A748h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224A748h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A748);
		  /* 8224A748h */ case    0:  		/* mfspr R12, LR */
		/* 8224A748h case    0:*/		regs.R12 = regs.LR;
		/* 8224A748h case    0:*/		return 0x8224A74C;
		  /* 8224A74Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224A74Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224A74Ch case    1:*/		return 0x8224A750;
		  /* 8224A750h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8224A750h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224A750h case    2:*/		return 0x8224A754;
		  /* 8224A754h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8224A754h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8224A754h case    3:*/		return 0x8224A758;
		  /* 8224A758h */ case    4:  		/* mr R31, R3 */
		/* 8224A758h case    4:*/		regs.R31 = regs.R3;
		/* 8224A758h case    4:*/		return 0x8224A75C;
		  /* 8224A75Ch */ case    5:  		/* bl 61412 */
		/* 8224A75Ch case    5:*/		regs.LR = 0x8224A760; return 0x82259740;
		/* 8224A75Ch case    5:*/		return 0x8224A760;
		  /* 8224A760h */ case    6:  		/* mr R3, R31 */
		/* 8224A760h case    6:*/		regs.R3 = regs.R31;
		/* 8224A760h case    6:*/		return 0x8224A764;
		  /* 8224A764h */ case    7:  		/* bl 59196 */
		/* 8224A764h case    7:*/		regs.LR = 0x8224A768; return 0x82258EA0;
		/* 8224A764h case    7:*/		return 0x8224A768;
		  /* 8224A768h */ case    8:  		/* mr R3, R31 */
		/* 8224A768h case    8:*/		regs.R3 = regs.R31;
		/* 8224A768h case    8:*/		return 0x8224A76C;
		  /* 8224A76Ch */ case    9:  		/* bl -4764 */
		/* 8224A76Ch case    9:*/		regs.LR = 0x8224A770; return 0x822494D0;
		/* 8224A76Ch case    9:*/		return 0x8224A770;
		  /* 8224A770h */ case   10:  		/* mr R3, R31 */
		/* 8224A770h case   10:*/		regs.R3 = regs.R31;
		/* 8224A770h case   10:*/		return 0x8224A774;
		  /* 8224A774h */ case   11:  		/* bl -3372 */
		/* 8224A774h case   11:*/		regs.LR = 0x8224A778; return 0x82249A48;
		/* 8224A774h case   11:*/		return 0x8224A778;
		  /* 8224A778h */ case   12:  		/* mr R3, R31 */
		/* 8224A778h case   12:*/		regs.R3 = regs.R31;
		/* 8224A778h case   12:*/		return 0x8224A77C;
		  /* 8224A77Ch */ case   13:  		/* bl -84668 */
		/* 8224A77Ch case   13:*/		regs.LR = 0x8224A780; return 0x82235CC0;
		/* 8224A77Ch case   13:*/		return 0x8224A780;
		  /* 8224A780h */ case   14:  		/* mr R3, R31 */
		/* 8224A780h case   14:*/		regs.R3 = regs.R31;
		/* 8224A780h case   14:*/		return 0x8224A784;
		  /* 8224A784h */ case   15:  		/* bl 101828 */
		/* 8224A784h case   15:*/		regs.LR = 0x8224A788; return 0x82263548;
		/* 8224A784h case   15:*/		return 0x8224A788;
		  /* 8224A788h */ case   16:  		/* mr R3, R31 */
		/* 8224A788h case   16:*/		regs.R3 = regs.R31;
		/* 8224A788h case   16:*/		return 0x8224A78C;
		  /* 8224A78Ch */ case   17:  		/* bl -81372 */
		/* 8224A78Ch case   17:*/		regs.LR = 0x8224A790; return 0x822369B0;
		/* 8224A78Ch case   17:*/		return 0x8224A790;
		  /* 8224A790h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224A790h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224A790h case   18:*/		return 0x8224A794;
		  /* 8224A794h */ case   19:  		/* bc 4, CR0_EQ, 40 */
		/* 8224A794h case   19:*/		if ( !regs.CR[0].eq ) { return 0x8224A7BC;  }
		/* 8224A794h case   19:*/		return 0x8224A798;
		  /* 8224A798h */ case   20:  		/* lis R11, -32252 */
		/* 8224A798h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224A798h case   20:*/		return 0x8224A79C;
		  /* 8224A79Ch */ case   21:  		/* lis R10, -32252 */
		/* 8224A79Ch case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224A79Ch case   21:*/		return 0x8224A7A0;
		  /* 8224A7A0h */ case   22:  		/* lis R9, -32253 */
		/* 8224A7A0h case   22:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224A7A0h case   22:*/		return 0x8224A7A4;
		  /* 8224A7A4h */ case   23:  		/* addi R6, R11, 13424 */
		/* 8224A7A4h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3470);
		/* 8224A7A4h case   23:*/		return 0x8224A7A8;
		  /* 8224A7A8h */ case   24:  		/* addi R5, R10, 13900 */
		/* 8224A7A8h case   24:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x364C);
		/* 8224A7A8h case   24:*/		return 0x8224A7AC;
		  /* 8224A7ACh */ case   25:  		/* addi R4, R9, 27460 */
		/* 8224A7ACh case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8224A7ACh case   25:*/		return 0x8224A7B0;
		  /* 8224A7B0h */ case   26:  		/* li R7, 1428 */
		/* 8224A7B0h case   26:*/		cpu::op::li<0>(regs,&regs.R7,0x594);
		/* 8224A7B0h case   26:*/		return 0x8224A7B4;
		  /* 8224A7B4h */ case   27:  		/* li R3, 0 */
		/* 8224A7B4h case   27:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224A7B4h case   27:*/		return 0x8224A7B8;
		  /* 8224A7B8h */ case   28:  		/* bl -994224 */
		/* 8224A7B8h case   28:*/		regs.LR = 0x8224A7BC; return 0x82157C08;
		/* 8224A7B8h case   28:*/		return 0x8224A7BC;
	}
	return 0x8224A7BC;
} // Block from 8224A748h-8224A7BCh (29 instructions)

//////////////////////////////////////////////////////
// Block at 8224A7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A7BC);
		  /* 8224A7BCh */ case    0:  		/* addi R1, R1, 96 */
		/* 8224A7BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8224A7BCh case    0:*/		return 0x8224A7C0;
		  /* 8224A7C0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224A7C0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224A7C0h case    1:*/		return 0x8224A7C4;
		  /* 8224A7C4h */ case    2:  		/* mtspr LR, R12 */
		/* 8224A7C4h case    2:*/		regs.LR = regs.R12;
		/* 8224A7C4h case    2:*/		return 0x8224A7C8;
		  /* 8224A7C8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8224A7C8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224A7C8h case    3:*/		return 0x8224A7CC;
		  /* 8224A7CCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 8224A7CCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224A7CCh case    4:*/		return 0x8224A7D0;
	}
	return 0x8224A7D0;
} // Block from 8224A7BCh-8224A7D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224A7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A7D0);
		  /* 8224A7D0h */ case    0:  		/* mfspr R12, LR */
		/* 8224A7D0h case    0:*/		regs.R12 = regs.LR;
		/* 8224A7D0h case    0:*/		return 0x8224A7D4;
		  /* 8224A7D4h */ case    1:  		/* bl -1807736 */
		/* 8224A7D4h case    1:*/		regs.LR = 0x8224A7D8; return 0x8209125C;
		/* 8224A7D4h case    1:*/		return 0x8224A7D8;
		  /* 8224A7D8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224A7D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224A7D8h case    2:*/		return 0x8224A7DC;
		  /* 8224A7DCh */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 8224A7DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8224A7DCh case    3:*/		return 0x8224A7E0;
		  /* 8224A7E0h */ case    4:  		/* mr R30, R3 */
		/* 8224A7E0h case    4:*/		regs.R30 = regs.R3;
		/* 8224A7E0h case    4:*/		return 0x8224A7E4;
		  /* 8224A7E4h */ case    5:  		/* lwz R10, <#[R4 + 12]> */
		/* 8224A7E4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000000C) );
		/* 8224A7E4h case    5:*/		return 0x8224A7E8;
		  /* 8224A7E8h */ case    6:  		/* mr R29, R4 */
		/* 8224A7E8h case    6:*/		regs.R29 = regs.R4;
		/* 8224A7E8h case    6:*/		return 0x8224A7EC;
		  /* 8224A7ECh */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 8224A7ECh case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224A7ECh case    7:*/		return 0x8224A7F0;
		  /* 8224A7F0h */ case    8:  		/* bc 4, CR6_GT, 12 */
		/* 8224A7F0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8224A7FC;  }
		/* 8224A7F0h case    8:*/		return 0x8224A7F4;
		  /* 8224A7F4h */ case    9:  		/* li R3, 1 */
		/* 8224A7F4h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8224A7F4h case    9:*/		return 0x8224A7F8;
		  /* 8224A7F8h */ case   10:  		/* b 220 */
		/* 8224A7F8h case   10:*/		return 0x8224A8D4;
		/* 8224A7F8h case   10:*/		return 0x8224A7FC;
	}
	return 0x8224A7FC;
} // Block from 8224A7D0h-8224A7FCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224A7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A7FC);
		  /* 8224A7FCh */ case    0:  		/* bc 4, CR6_LT, 12 */
		/* 8224A7FCh case    0:*/		if ( !regs.CR[6].lt ) { return 0x8224A808;  }
		/* 8224A7FCh case    0:*/		return 0x8224A800;
		  /* 8224A800h */ case    1:  		/* li R3, -1 */
		/* 8224A800h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8224A800h case    1:*/		return 0x8224A804;
		  /* 8224A804h */ case    2:  		/* b 208 */
		/* 8224A804h case    2:*/		return 0x8224A8D4;
		/* 8224A804h case    2:*/		return 0x8224A808;
	}
	return 0x8224A808;
} // Block from 8224A7FCh-8224A808h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224A808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A808);
		  /* 8224A808h */ case    0:  		/* lwz R3, <#[R30 + 40]> */
		/* 8224A808h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000028) );
		/* 8224A808h case    0:*/		return 0x8224A80C;
		  /* 8224A80Ch */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8224A80Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224A80Ch case    1:*/		return 0x8224A810;
		  /* 8224A810h */ case    2:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224A810h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224A810h case    2:*/		return 0x8224A814;
		  /* 8224A814h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224A814h case    3:*/		regs.CTR = regs.R11;
		/* 8224A814h case    3:*/		return 0x8224A818;
		  /* 8224A818h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224A818h case    4:*/		if ( 1 ) { regs.LR = 0x8224A81C; return (uint32)regs.CTR; }
		/* 8224A818h case    4:*/		return 0x8224A81C;
		  /* 8224A81Ch */ case    5:  		/* lwz R11, <#[R29 + 40]> */
		/* 8224A81Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000028) );
		/* 8224A81Ch case    5:*/		return 0x8224A820;
		  /* 8224A820h */ case    6:  		/* rlwinm R31, R3, 0, 24, 31 */
		/* 8224A820h case    6:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R31,regs.R3);
		/* 8224A820h case    6:*/		return 0x8224A824;
		  /* 8224A824h */ case    7:  		/* mr R3, R11 */
		/* 8224A824h case    7:*/		regs.R3 = regs.R11;
		/* 8224A824h case    7:*/		return 0x8224A828;
		  /* 8224A828h */ case    8:  		/* lwz R10, <#[R11]> */
		/* 8224A828h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8224A828h case    8:*/		return 0x8224A82C;
		  /* 8224A82Ch */ case    9:  		/* lwz R11, <#[R10 + 24]> */
		/* 8224A82Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 8224A82Ch case    9:*/		return 0x8224A830;
		  /* 8224A830h */ case   10:  		/* mtspr CTR, R11 */
		/* 8224A830h case   10:*/		regs.CTR = regs.R11;
		/* 8224A830h case   10:*/		return 0x8224A834;
		  /* 8224A834h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8224A834h case   11:*/		if ( 1 ) { regs.LR = 0x8224A838; return (uint32)regs.CTR; }
		/* 8224A834h case   11:*/		return 0x8224A838;
		  /* 8224A838h */ case   12:  		/* rlwinm R11, R3, 0, 24, 31 */
		/* 8224A838h case   12:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224A838h case   12:*/		return 0x8224A83C;
		  /* 8224A83Ch */ case   13:  		/* cmplw CR6, R31, R11 */
		/* 8224A83Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8224A83Ch case   13:*/		return 0x8224A840;
		  /* 8224A840h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 8224A840h case   14:*/		if ( regs.CR[6].eq ) { return 0x8224A858;  }
		/* 8224A840h case   14:*/		return 0x8224A844;
		  /* 8224A844h */ case   15:  		/* subfic R11, R31, 0 */
		/* 8224A844h case   15:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R31,0x0);
		/* 8224A844h case   15:*/		return 0x8224A848;
		  /* 8224A848h */ case   16:  		/* subfe R11, R11, R11 */
		/* 8224A848h case   16:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8224A848h case   16:*/		return 0x8224A84C;
		  /* 8224A84Ch */ case   17:  		/* rlwinm R11, R11, 0, 30, 30 */
		/* 8224A84Ch case   17:*/		cpu::op::rlwinm<0,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8224A84Ch case   17:*/		return 0x8224A850;
		  /* 8224A850h */ case   18:  		/* addi R3, R11, -1 */
		/* 8224A850h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 8224A850h case   18:*/		return 0x8224A854;
		  /* 8224A854h */ case   19:  		/* b 128 */
		/* 8224A854h case   19:*/		return 0x8224A8D4;
		/* 8224A854h case   19:*/		return 0x8224A858;
	}
	return 0x8224A858;
} // Block from 8224A808h-8224A858h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8224A858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A858);
		  /* 8224A858h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 8224A858h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8224A858h case    0:*/		return 0x8224A85C;
		  /* 8224A85Ch */ case    1:  		/* lwz R10, <#[R30 + 24]> */
		/* 8224A85Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 8224A85Ch case    1:*/		return 0x8224A860;
		  /* 8224A860h */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 8224A860h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224A860h case    2:*/		return 0x8224A864;
		  /* 8224A864h */ case    3:  		/* bc 4, CR6_GT, 16 */
		/* 8224A864h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8224A874;  }
		/* 8224A864h case    3:*/		return 0x8224A868;
		  /* 8224A868h */ case    4:  		/* mr R8, R11 */
		/* 8224A868h case    4:*/		regs.R8 = regs.R11;
		/* 8224A868h case    4:*/		return 0x8224A86C;
		  /* 8224A86Ch */ case    5:  		/* mr R7, R10 */
		/* 8224A86Ch case    5:*/		regs.R7 = regs.R10;
		/* 8224A86Ch case    5:*/		return 0x8224A870;
		  /* 8224A870h */ case    6:  		/* b 12 */
		/* 8224A870h case    6:*/		return 0x8224A87C;
		/* 8224A870h case    6:*/		return 0x8224A874;
	}
	return 0x8224A874;
} // Block from 8224A858h-8224A874h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224A874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A874);
		  /* 8224A874h */ case    0:  		/* mr R8, R10 */
		/* 8224A874h case    0:*/		regs.R8 = regs.R10;
		/* 8224A874h case    0:*/		return 0x8224A878;
		  /* 8224A878h */ case    1:  		/* mr R7, R11 */
		/* 8224A878h case    1:*/		regs.R7 = regs.R11;
		/* 8224A878h case    1:*/		return 0x8224A87C;
	}
	return 0x8224A87C;
} // Block from 8224A874h-8224A87Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224A87Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A87C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A87C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A87C);
		  /* 8224A87Ch */ case    0:  		/* lwz R11, <#[R29 + 20]> */
		/* 8224A87Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 8224A87Ch case    0:*/		return 0x8224A880;
		  /* 8224A880h */ case    1:  		/* lwz R10, <#[R29 + 24]> */
		/* 8224A880h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 8224A880h case    1:*/		return 0x8224A884;
		  /* 8224A884h */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 8224A884h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224A884h case    2:*/		return 0x8224A888;
		  /* 8224A888h */ case    3:  		/* bc 4, CR6_GT, 16 */
		/* 8224A888h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8224A898;  }
		/* 8224A888h case    3:*/		return 0x8224A88C;
		  /* 8224A88Ch */ case    4:  		/* mr R9, R11 */
		/* 8224A88Ch case    4:*/		regs.R9 = regs.R11;
		/* 8224A88Ch case    4:*/		return 0x8224A890;
		  /* 8224A890h */ case    5:  		/* mr R11, R10 */
		/* 8224A890h case    5:*/		regs.R11 = regs.R10;
		/* 8224A890h case    5:*/		return 0x8224A894;
		  /* 8224A894h */ case    6:  		/* b 8 */
		/* 8224A894h case    6:*/		return 0x8224A89C;
		/* 8224A894h case    6:*/		return 0x8224A898;
	}
	return 0x8224A898;
} // Block from 8224A87Ch-8224A898h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224A898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A898);
		  /* 8224A898h */ case    0:  		/* mr R9, R10 */
		/* 8224A898h case    0:*/		regs.R9 = regs.R10;
		/* 8224A898h case    0:*/		return 0x8224A89C;
	}
	return 0x8224A89C;
} // Block from 8224A898h-8224A89Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224A89Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A89C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A89C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A89C);
		  /* 8224A89Ch */ case    0:  		/* cmpw CR6, R8, R9 */
		/* 8224A89Ch case    0:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R9);
		/* 8224A89Ch case    0:*/		return 0x8224A8A0;
		  /* 8224A8A0h */ case    1:  		/* bc 12, CR6_GT, -172 */
		/* 8224A8A0h case    1:*/		if ( regs.CR[6].gt ) { return 0x8224A7F4;  }
		/* 8224A8A0h case    1:*/		return 0x8224A8A4;
		  /* 8224A8A4h */ case    2:  		/* bc 12, CR6_LT, -164 */
		/* 8224A8A4h case    2:*/		if ( regs.CR[6].lt ) { return 0x8224A800;  }
		/* 8224A8A4h case    2:*/		return 0x8224A8A8;
		  /* 8224A8A8h */ case    3:  		/* cmpw CR6, R7, R11 */
		/* 8224A8A8h case    3:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R11);
		/* 8224A8A8h case    3:*/		return 0x8224A8AC;
		  /* 8224A8ACh */ case    4:  		/* bc 12, CR6_GT, -184 */
		/* 8224A8ACh case    4:*/		if ( regs.CR[6].gt ) { return 0x8224A7F4;  }
		/* 8224A8ACh case    4:*/		return 0x8224A8B0;
		  /* 8224A8B0h */ case    5:  		/* bc 12, CR6_LT, -176 */
		/* 8224A8B0h case    5:*/		if ( regs.CR[6].lt ) { return 0x8224A800;  }
		/* 8224A8B0h case    5:*/		return 0x8224A8B4;
		  /* 8224A8B4h */ case    6:  		/* lfs FR0, <#[R30 + 16]> */
		/* 8224A8B4h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000010) );
		/* 8224A8B4h case    6:*/		return 0x8224A8B8;
		  /* 8224A8B8h */ case    7:  		/* lfs FR13, <#[R29 + 16]> */
		/* 8224A8B8h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R29 + 0x00000010) );
		/* 8224A8B8h case    7:*/		return 0x8224A8BC;
		  /* 8224A8BCh */ case    8:  		/* fcmpu CR6, FR0, FR13 */
		/* 8224A8BCh case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 8224A8BCh case    8:*/		return 0x8224A8C0;
		  /* 8224A8C0h */ case    9:  		/* bc 12, CR6_GT, -204 */
		/* 8224A8C0h case    9:*/		if ( regs.CR[6].gt ) { return 0x8224A7F4;  }
		/* 8224A8C0h case    9:*/		return 0x8224A8C4;
		  /* 8224A8C4h */ case   10:  		/* fcmpu CR6, FR0, FR13 */
		/* 8224A8C4h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 8224A8C4h case   10:*/		return 0x8224A8C8;
		  /* 8224A8C8h */ case   11:  		/* li R3, -1 */
		/* 8224A8C8h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8224A8C8h case   11:*/		return 0x8224A8CC;
		  /* 8224A8CCh */ case   12:  		/* bc 12, CR6_LT, 8 */
		/* 8224A8CCh case   12:*/		if ( regs.CR[6].lt ) { return 0x8224A8D4;  }
		/* 8224A8CCh case   12:*/		return 0x8224A8D0;
		  /* 8224A8D0h */ case   13:  		/* li R3, 0 */
		/* 8224A8D0h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224A8D0h case   13:*/		return 0x8224A8D4;
	}
	return 0x8224A8D4;
} // Block from 8224A89Ch-8224A8D4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224A8D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A8D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A8D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A8D4);
		  /* 8224A8D4h */ case    0:  		/* addi R1, R1, 112 */
		/* 8224A8D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224A8D4h case    0:*/		return 0x8224A8D8;
		  /* 8224A8D8h */ case    1:  		/* b -1807916 */
		/* 8224A8D8h case    1:*/		return 0x820912AC;
		/* 8224A8D8h case    1:*/		return 0x8224A8DC;
		  /* 8224A8DCh */ case    2:  		/* nop */
		/* 8224A8DCh case    2:*/		cpu::op::nop();
		/* 8224A8DCh case    2:*/		return 0x8224A8E0;
	}
	return 0x8224A8E0;
} // Block from 8224A8D4h-8224A8E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224A8E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A8E0);
		  /* 8224A8E0h */ case    0:  		/* mfspr R12, LR */
		/* 8224A8E0h case    0:*/		regs.R12 = regs.LR;
		/* 8224A8E0h case    0:*/		return 0x8224A8E4;
		  /* 8224A8E4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224A8E4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224A8E4h case    1:*/		return 0x8224A8E8;
		  /* 8224A8E8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8224A8E8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224A8E8h case    2:*/		return 0x8224A8EC;
		  /* 8224A8ECh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8224A8ECh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8224A8ECh case    3:*/		return 0x8224A8F0;
		  /* 8224A8F0h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224A8F0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224A8F0h case    4:*/		return 0x8224A8F4;
		  /* 8224A8F4h */ case    5:  		/* mr R31, R4 */
		/* 8224A8F4h case    5:*/		regs.R31 = regs.R4;
		/* 8224A8F4h case    5:*/		return 0x8224A8F8;
		  /* 8224A8F8h */ case    6:  		/* cmpwi CR6, R11, 3 */
		/* 8224A8F8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8224A8F8h case    6:*/		return 0x8224A8FC;
		  /* 8224A8FCh */ case    7:  		/* bc 4, CR6_EQ, 76 */
		/* 8224A8FCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x8224A948;  }
		/* 8224A8FCh case    7:*/		return 0x8224A900;
		  /* 8224A900h */ case    8:  		/* lwz R11, <#[R4]> */
		/* 8224A900h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8224A900h case    8:*/		return 0x8224A904;
		  /* 8224A904h */ case    9:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224A904h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224A904h case    9:*/		return 0x8224A908;
		  /* 8224A908h */ case   10:  		/* mr R3, R31 */
		/* 8224A908h case   10:*/		regs.R3 = regs.R31;
		/* 8224A908h case   10:*/		return 0x8224A90C;
		  /* 8224A90Ch */ case   11:  		/* mtspr CTR, R11 */
		/* 8224A90Ch case   11:*/		regs.CTR = regs.R11;
		/* 8224A90Ch case   11:*/		return 0x8224A910;
		  /* 8224A910h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 8224A910h case   12:*/		if ( 1 ) { regs.LR = 0x8224A914; return (uint32)regs.CTR; }
		/* 8224A910h case   12:*/		return 0x8224A914;
		  /* 8224A914h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224A914h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224A914h case   13:*/		return 0x8224A918;
		  /* 8224A918h */ case   14:  		/* bc 4, CR0_EQ, 36 */
		/* 8224A918h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8224A93C;  }
		/* 8224A918h case   14:*/		return 0x8224A91C;
		  /* 8224A91Ch */ case   15:  		/* lwz R11, <#[R31]> */
		/* 8224A91Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224A91Ch case   15:*/		return 0x8224A920;
		  /* 8224A920h */ case   16:  		/* mr R3, R31 */
		/* 8224A920h case   16:*/		regs.R3 = regs.R31;
		/* 8224A920h case   16:*/		return 0x8224A924;
		  /* 8224A924h */ case   17:  		/* lwz R11, <#[R11 + 56]> */
		/* 8224A924h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000038) );
		/* 8224A924h case   17:*/		return 0x8224A928;
		  /* 8224A928h */ case   18:  		/* mtspr CTR, R11 */
		/* 8224A928h case   18:*/		regs.CTR = regs.R11;
		/* 8224A928h case   18:*/		return 0x8224A92C;
		  /* 8224A92Ch */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 8224A92Ch case   19:*/		if ( 1 ) { regs.LR = 0x8224A930; return (uint32)regs.CTR; }
		/* 8224A92Ch case   19:*/		return 0x8224A930;
		  /* 8224A930h */ case   20:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224A930h case   20:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224A930h case   20:*/		return 0x8224A934;
		  /* 8224A934h */ case   21:  		/* li R11, 1 */
		/* 8224A934h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224A934h case   21:*/		return 0x8224A938;
		  /* 8224A938h */ case   22:  		/* bc 12, CR0_EQ, 8 */
		/* 8224A938h case   22:*/		if ( regs.CR[0].eq ) { return 0x8224A940;  }
		/* 8224A938h case   22:*/		return 0x8224A93C;
	}
	return 0x8224A93C;
} // Block from 8224A8E0h-8224A93Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8224A93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A93C);
		  /* 8224A93Ch */ case    0:  		/* li R11, 0 */
		/* 8224A93Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224A93Ch case    0:*/		return 0x8224A940;
	}
	return 0x8224A940;
} // Block from 8224A93Ch-8224A940h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224A940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A940);
		  /* 8224A940h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8224A940h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8224A940h case    0:*/		return 0x8224A944;
		  /* 8224A944h */ case    1:  		/* b 28 */
		/* 8224A944h case    1:*/		return 0x8224A960;
		/* 8224A944h case    1:*/		return 0x8224A948;
	}
	return 0x8224A948;
} // Block from 8224A940h-8224A948h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224A948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A948);
		  /* 8224A948h */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 8224A948h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8224A948h case    0:*/		return 0x8224A94C;
		  /* 8224A94Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8224A94Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224A95C;  }
		/* 8224A94Ch case    1:*/		return 0x8224A950;
		  /* 8224A950h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8224A950h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224A950h case    2:*/		return 0x8224A954;
		  /* 8224A954h */ case    3:  		/* lwz R11, <#[R11 + 20]> */
		/* 8224A954h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8224A954h case    3:*/		return 0x8224A958;
		  /* 8224A958h */ case    4:  		/* b -80 */
		/* 8224A958h case    4:*/		return 0x8224A908;
		/* 8224A958h case    4:*/		return 0x8224A95C;
	}
	return 0x8224A95C;
} // Block from 8224A948h-8224A95Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224A95Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A95C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A95C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A95C);
		  /* 8224A95Ch */ case    0:  		/* li R3, 1 */
		/* 8224A95Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8224A95Ch case    0:*/		return 0x8224A960;
	}
	return 0x8224A960;
} // Block from 8224A95Ch-8224A960h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224A960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A960);
		  /* 8224A960h */ case    0:  		/* addi R1, R1, 96 */
		/* 8224A960h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8224A960h case    0:*/		return 0x8224A964;
		  /* 8224A964h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224A964h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224A964h case    1:*/		return 0x8224A968;
		  /* 8224A968h */ case    2:  		/* mtspr LR, R12 */
		/* 8224A968h case    2:*/		regs.LR = regs.R12;
		/* 8224A968h case    2:*/		return 0x8224A96C;
		  /* 8224A96Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8224A96Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224A96Ch case    3:*/		return 0x8224A970;
		  /* 8224A970h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8224A970h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224A970h case    4:*/		return 0x8224A974;
	}
	return 0x8224A974;
} // Block from 8224A960h-8224A974h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224A974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A974);
		  /* 8224A974h */ case    0:  		/* nop */
		/* 8224A974h case    0:*/		cpu::op::nop();
		/* 8224A974h case    0:*/		return 0x8224A978;
	}
	return 0x8224A978;
} // Block from 8224A974h-8224A978h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224A978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A978);
		  /* 8224A978h */ case    0:  		/* mfspr R12, LR */
		/* 8224A978h case    0:*/		regs.R12 = regs.LR;
		/* 8224A978h case    0:*/		return 0x8224A97C;
		  /* 8224A97Ch */ case    1:  		/* bl -1808204 */
		/* 8224A97Ch case    1:*/		regs.LR = 0x8224A980; return 0x82091230;
		/* 8224A97Ch case    1:*/		return 0x8224A980;
		  /* 8224A980h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 8224A980h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 8224A980h case    2:*/		return 0x8224A984;
		  /* 8224A984h */ case    3:  		/* lis R11, -32253 */
		/* 8224A984h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224A984h case    3:*/		return 0x8224A988;
		  /* 8224A988h */ case    4:  		/* li R19, 0 */
		/* 8224A988h case    4:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8224A988h case    4:*/		return 0x8224A98C;
		  /* 8224A98Ch */ case    5:  		/* addi R25, R11, 27460 */
		/* 8224A98Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0x6B44);
		/* 8224A98Ch case    5:*/		return 0x8224A990;
		  /* 8224A990h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224A990h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224A990h case    6:*/		return 0x8224A994;
		  /* 8224A994h */ case    7:  		/* lis R10, -32252 */
		/* 8224A994h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224A994h case    7:*/		return 0x8224A998;
		  /* 8224A998h */ case    8:  		/* mr R28, R3 */
		/* 8224A998h case    8:*/		regs.R28 = regs.R3;
		/* 8224A998h case    8:*/		return 0x8224A99C;
		  /* 8224A99Ch */ case    9:  		/* mr R27, R4 */
		/* 8224A99Ch case    9:*/		regs.R27 = regs.R4;
		/* 8224A99Ch case    9:*/		return 0x8224A9A0;
		  /* 8224A9A0h */ case   10:  		/* li R18, 1 */
		/* 8224A9A0h case   10:*/		cpu::op::li<0>(regs,&regs.R18,0x1);
		/* 8224A9A0h case   10:*/		return 0x8224A9A4;
		  /* 8224A9A4h */ case   11:  		/* mr R26, R19 */
		/* 8224A9A4h case   11:*/		regs.R26 = regs.R19;
		/* 8224A9A4h case   11:*/		return 0x8224A9A8;
		  /* 8224A9A8h */ case   12:  		/* addi R24, R10, 14208 */
		/* 8224A9A8h case   12:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R10,0x3780);
		/* 8224A9A8h case   12:*/		return 0x8224A9AC;
		  /* 8224A9ACh */ case   13:  		/* cmpwi CR6, R11, 3 */
		/* 8224A9ACh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8224A9ACh case   13:*/		return 0x8224A9B0;
		  /* 8224A9B0h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 8224A9B0h case   14:*/		if ( regs.CR[6].eq ) { return 0x8224A9BC;  }
		/* 8224A9B0h case   14:*/		return 0x8224A9B4;
		  /* 8224A9B4h */ case   15:  		/* cmpwi CR6, R11, 2 */
		/* 8224A9B4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8224A9B4h case   15:*/		return 0x8224A9B8;
		  /* 8224A9B8h */ case   16:  		/* bc 4, CR6_EQ, 220 */
		/* 8224A9B8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8224AA94;  }
		/* 8224A9B8h case   16:*/		return 0x8224A9BC;
	}
	return 0x8224A9BC;
} // Block from 8224A978h-8224A9BCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224A9BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A9BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A9BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A9BC);
		  /* 8224A9BCh */ case    0:  		/* lwz R11, <#[R28]> */
		/* 8224A9BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8224A9BCh case    0:*/		return 0x8224A9C0;
		  /* 8224A9C0h */ case    1:  		/* mr R29, R18 */
		/* 8224A9C0h case    1:*/		regs.R29 = regs.R18;
		/* 8224A9C0h case    1:*/		return 0x8224A9C4;
		  /* 8224A9C4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8224A9C4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224A9C4h case    2:*/		return 0x8224A9C8;
		  /* 8224A9C8h */ case    3:  		/* bc 4, CR6_EQ, 32 */
		/* 8224A9C8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224A9E8;  }
		/* 8224A9C8h case    3:*/		return 0x8224A9CC;
		  /* 8224A9CCh */ case    4:  		/* lis R11, -32252 */
		/* 8224A9CCh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224A9CCh case    4:*/		return 0x8224A9D0;
		  /* 8224A9D0h */ case    5:  		/* mr R6, R24 */
		/* 8224A9D0h case    5:*/		regs.R6 = regs.R24;
		/* 8224A9D0h case    5:*/		return 0x8224A9D4;
		  /* 8224A9D4h */ case    6:  		/* addi R5, R11, 14192 */
		/* 8224A9D4h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3770);
		/* 8224A9D4h case    6:*/		return 0x8224A9D8;
		  /* 8224A9D8h */ case    7:  		/* mr R4, R25 */
		/* 8224A9D8h case    7:*/		regs.R4 = regs.R25;
		/* 8224A9D8h case    7:*/		return 0x8224A9DC;
		  /* 8224A9DCh */ case    8:  		/* li R7, 385 */
		/* 8224A9DCh case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x181);
		/* 8224A9DCh case    8:*/		return 0x8224A9E0;
		  /* 8224A9E0h */ case    9:  		/* li R3, 0 */
		/* 8224A9E0h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224A9E0h case    9:*/		return 0x8224A9E4;
		  /* 8224A9E4h */ case   10:  		/* bl -994780 */
		/* 8224A9E4h case   10:*/		regs.LR = 0x8224A9E8; return 0x82157C08;
		/* 8224A9E4h case   10:*/		return 0x8224A9E8;
	}
	return 0x8224A9E8;
} // Block from 8224A9BCh-8224A9E8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224A9E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224A9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224A9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224A9E8);
		  /* 8224A9E8h */ case    0:  		/* lis R11, -32252 */
		/* 8224A9E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224A9E8h case    0:*/		return 0x8224A9EC;
		  /* 8224A9ECh */ case    1:  		/* lwz R31, <#[R28]> */
		/* 8224A9ECh case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 8224A9ECh case    1:*/		return 0x8224A9F0;
		  /* 8224A9F0h */ case    2:  		/* addi R30, R11, 14056 */
		/* 8224A9F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x36E8);
		/* 8224A9F0h case    2:*/		return 0x8224A9F4;
		  /* 8224A9F4h */ case    3:  		/* lwz R11, <#[R28 + 4]> */
		/* 8224A9F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8224A9F4h case    3:*/		return 0x8224A9F8;
		  /* 8224A9F8h */ case    4:  		/* cmpwi CR6, R11, 2 */
		/* 8224A9F8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8224A9F8h case    4:*/		return 0x8224A9FC;
		  /* 8224A9FCh */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 8224A9FCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8224AA10;  }
		/* 8224A9FCh case    5:*/		return 0x8224AA00;
		  /* 8224AA00h */ case    6:  		/* lwz R3, <#[R31 + 40]> */
		/* 8224AA00h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8224AA00h case    6:*/		return 0x8224AA04;
		  /* 8224AA04h */ case    7:  		/* bl 115380 */
		/* 8224AA04h case    7:*/		regs.LR = 0x8224AA08; return 0x82266CB8;
		/* 8224AA04h case    7:*/		return 0x8224AA08;
		  /* 8224AA08h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224AA08h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224AA08h case    8:*/		return 0x8224AA0C;
		  /* 8224AA0Ch */ case    9:  		/* bc 4, CR0_EQ, 56 */
		/* 8224AA0Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x8224AA44;  }
		/* 8224AA0Ch case    9:*/		return 0x8224AA10;
	}
	return 0x8224AA10;
} // Block from 8224A9E8h-8224AA10h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224AA10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AA10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AA10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AA10);
		  /* 8224AA10h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 8224AA10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8224AA10h case    0:*/		return 0x8224AA14;
		  /* 8224AA14h */ case    1:  		/* cmpwi CR6, R11, 3 */
		/* 8224AA14h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8224AA14h case    1:*/		return 0x8224AA18;
		  /* 8224AA18h */ case    2:  		/* bc 4, CR6_EQ, 20 */
		/* 8224AA18h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224AA2C;  }
		/* 8224AA18h case    2:*/		return 0x8224AA1C;
		  /* 8224AA1Ch */ case    3:  		/* lwz R3, <#[R31 + 40]> */
		/* 8224AA1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8224AA1Ch case    3:*/		return 0x8224AA20;
		  /* 8224AA20h */ case    4:  		/* bl 115408 */
		/* 8224AA20h case    4:*/		regs.LR = 0x8224AA24; return 0x82266CF0;
		/* 8224AA20h case    4:*/		return 0x8224AA24;
		  /* 8224AA24h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224AA24h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224AA24h case    5:*/		return 0x8224AA28;
		  /* 8224AA28h */ case    6:  		/* bc 4, CR0_EQ, 28 */
		/* 8224AA28h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8224AA44;  }
		/* 8224AA28h case    6:*/		return 0x8224AA2C;
	}
	return 0x8224AA2C;
} // Block from 8224AA10h-8224AA2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224AA2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AA2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AA2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AA2C);
		  /* 8224AA2Ch */ case    0:  		/* mr R6, R24 */
		/* 8224AA2Ch case    0:*/		regs.R6 = regs.R24;
		/* 8224AA2Ch case    0:*/		return 0x8224AA30;
		  /* 8224AA30h */ case    1:  		/* mr R5, R30 */
		/* 8224AA30h case    1:*/		regs.R5 = regs.R30;
		/* 8224AA30h case    1:*/		return 0x8224AA34;
		  /* 8224AA34h */ case    2:  		/* mr R4, R25 */
		/* 8224AA34h case    2:*/		regs.R4 = regs.R25;
		/* 8224AA34h case    2:*/		return 0x8224AA38;
		  /* 8224AA38h */ case    3:  		/* li R7, 391 */
		/* 8224AA38h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x187);
		/* 8224AA38h case    3:*/		return 0x8224AA3C;
		  /* 8224AA3Ch */ case    4:  		/* li R3, 0 */
		/* 8224AA3Ch case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AA3Ch case    4:*/		return 0x8224AA40;
		  /* 8224AA40h */ case    5:  		/* bl -994872 */
		/* 8224AA40h case    5:*/		regs.LR = 0x8224AA44; return 0x82157C08;
		/* 8224AA40h case    5:*/		return 0x8224AA44;
	}
	return 0x8224AA44;
} // Block from 8224AA2Ch-8224AA44h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224AA44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AA44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AA44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AA44);
		  /* 8224AA44h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 8224AA44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 8224AA44h case    0:*/		return 0x8224AA48;
		  /* 8224AA48h */ case    1:  		/* mr R26, R31 */
		/* 8224AA48h case    1:*/		regs.R26 = regs.R31;
		/* 8224AA48h case    1:*/		return 0x8224AA4C;
		  /* 8224AA4Ch */ case    2:  		/* lwz R31, <#[R31 + 64]> */
		/* 8224AA4Ch case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000040) );
		/* 8224AA4Ch case    2:*/		return 0x8224AA50;
		  /* 8224AA50h */ case    3:  		/* addic R10, R11, -1 */
		/* 8224AA50h case    3:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 8224AA50h case    3:*/		return 0x8224AA54;
		  /* 8224AA54h */ case    4:  		/* rlwinm R11, R11, 1, 31, 31 */
		/* 8224AA54h case    4:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R11);
		/* 8224AA54h case    4:*/		return 0x8224AA58;
		  /* 8224AA58h */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 8224AA58h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8224AA58h case    5:*/		return 0x8224AA5C;
		  /* 8224AA5Ch */ case    6:  		/* subfze R11, R11 */
		/* 8224AA5Ch case    6:*/		cpu::op::subfze<0>(regs,&regs.R11,regs.R11);
		/* 8224AA5Ch case    6:*/		return 0x8224AA60;
		  /* 8224AA60h */ case    7:  		/* and R29, R11, R29 */
		/* 8224AA60h case    7:*/		cpu::op::and<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 8224AA60h case    7:*/		return 0x8224AA64;
		  /* 8224AA64h */ case    8:  		/* bc 4, CR6_EQ, -112 */
		/* 8224AA64h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8224A9F4;  }
		/* 8224AA64h case    8:*/		return 0x8224AA68;
		  /* 8224AA68h */ case    9:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 8224AA68h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 8224AA68h case    9:*/		return 0x8224AA6C;
		  /* 8224AA6Ch */ case   10:  		/* bc 12, CR0_EQ, 40 */
		/* 8224AA6Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x8224AA94;  }
		/* 8224AA6Ch case   10:*/		return 0x8224AA70;
		  /* 8224AA70h */ case   11:  		/* lwz R11, <#[R28 + 4]> */
		/* 8224AA70h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8224AA70h case   11:*/		return 0x8224AA74;
		  /* 8224AA74h */ case   12:  		/* stw R19, <#[R28]> */
		/* 8224AA74h case   12:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R28 + 0x00000000) );
		/* 8224AA74h case   12:*/		return 0x8224AA78;
		  /* 8224AA78h */ case   13:  		/* cmpwi CR6, R11, 3 */
		/* 8224AA78h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8224AA78h case   13:*/		return 0x8224AA7C;
		  /* 8224AA7Ch */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 8224AA7Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x8224AA88;  }
		/* 8224AA7Ch case   14:*/		return 0x8224AA80;
		  /* 8224AA80h */ case   15:  		/* stw R18, <#[R28 + 4]> */
		/* 8224AA80h case   15:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R28 + 0x00000004) );
		/* 8224AA80h case   15:*/		return 0x8224AA84;
		  /* 8224AA84h */ case   16:  		/* b 16 */
		/* 8224AA84h case   16:*/		return 0x8224AA94;
		/* 8224AA84h case   16:*/		return 0x8224AA88;
	}
	return 0x8224AA88;
} // Block from 8224AA44h-8224AA88h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224AA88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AA88);
		  /* 8224AA88h */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 8224AA88h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8224AA88h case    0:*/		return 0x8224AA8C;
		  /* 8224AA8Ch */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8224AA8Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224AA94;  }
		/* 8224AA8Ch case    1:*/		return 0x8224AA90;
		  /* 8224AA90h */ case    2:  		/* stw R19, <#[R28 + 4]> */
		/* 8224AA90h case    2:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R28 + 0x00000004) );
		/* 8224AA90h case    2:*/		return 0x8224AA94;
	}
	return 0x8224AA94;
} // Block from 8224AA88h-8224AA94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224AA94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AA94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AA94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AA94);
		  /* 8224AA94h */ case    0:  		/* lis R9, -32252 */
		/* 8224AA94h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8224AA94h case    0:*/		return 0x8224AA98;
		  /* 8224AA98h */ case    1:  		/* lis R8, -32252 */
		/* 8224AA98h case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 8224AA98h case    1:*/		return 0x8224AA9C;
		  /* 8224AA9Ch */ case    2:  		/* lis R7, -32252 */
		/* 8224AA9Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8204);
		/* 8224AA9Ch case    2:*/		return 0x8224AAA0;
		  /* 8224AAA0h */ case    3:  		/* lis R10, -32252 */
		/* 8224AAA0h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224AAA0h case    3:*/		return 0x8224AAA4;
		  /* 8224AAA4h */ case    4:  		/* lis R11, -32252 */
		/* 8224AAA4h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224AAA4h case    4:*/		return 0x8224AAA8;
		  /* 8224AAA8h */ case    5:  		/* li R20, 2 */
		/* 8224AAA8h case    5:*/		cpu::op::li<0>(regs,&regs.R20,0x2);
		/* 8224AAA8h case    5:*/		return 0x8224AAAC;
		  /* 8224AAACh */ case    6:  		/* addi R22, R9, 14028 */
		/* 8224AAACh case    6:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R9,0x36CC);
		/* 8224AAACh case    6:*/		return 0x8224AAB0;
		  /* 8224AAB0h */ case    7:  		/* addi R30, R8, 14000 */
		/* 8224AAB0h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R8,0x36B0);
		/* 8224AAB0h case    7:*/		return 0x8224AAB4;
		  /* 8224AAB4h */ case    8:  		/* addi R29, R7, 13968 */
		/* 8224AAB4h case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R7,0x3690);
		/* 8224AAB4h case    8:*/		return 0x8224AAB8;
		  /* 8224AAB8h */ case    9:  		/* addi R23, R10, 13952 */
		/* 8224AAB8h case    9:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0x3680);
		/* 8224AAB8h case    9:*/		return 0x8224AABC;
		  /* 8224AABCh */ case   10:  		/* addi R21, R11, 13928 */
		/* 8224AABCh case   10:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R11,0x3668);
		/* 8224AABCh case   10:*/		return 0x8224AAC0;
		  /* 8224AAC0h */ case   11:  		/* lwz R11, <#[R27]> */
		/* 8224AAC0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224AAC0h case   11:*/		return 0x8224AAC4;
		  /* 8224AAC4h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8224AAC4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224AAC4h case   12:*/		return 0x8224AAC8;
		  /* 8224AAC8h */ case   13:  		/* bc 12, CR6_EQ, 500 */
		/* 8224AAC8h case   13:*/		if ( regs.CR[6].eq ) { return 0x8224ACBC;  }
		/* 8224AAC8h case   13:*/		return 0x8224AACC;
		  /* 8224AACCh */ case   14:  		/* lwz R31, <#[R11 + 40]> */
		/* 8224AACCh case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 8224AACCh case   14:*/		return 0x8224AAD0;
		  /* 8224AAD0h */ case   15:  		/* mr R3, R31 */
		/* 8224AAD0h case   15:*/		regs.R3 = regs.R31;
		/* 8224AAD0h case   15:*/		return 0x8224AAD4;
		  /* 8224AAD4h */ case   16:  		/* lwz R11, <#[R31]> */
		/* 8224AAD4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224AAD4h case   16:*/		return 0x8224AAD8;
		  /* 8224AAD8h */ case   17:  		/* lwz R11, <#[R11 + 20]> */
		/* 8224AAD8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8224AAD8h case   17:*/		return 0x8224AADC;
		  /* 8224AADCh */ case   18:  		/* mtspr CTR, R11 */
		/* 8224AADCh case   18:*/		regs.CTR = regs.R11;
		/* 8224AADCh case   18:*/		return 0x8224AAE0;
		  /* 8224AAE0h */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 8224AAE0h case   19:*/		if ( 1 ) { regs.LR = 0x8224AAE4; return (uint32)regs.CTR; }
		/* 8224AAE0h case   19:*/		return 0x8224AAE4;
		  /* 8224AAE4h */ case   20:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224AAE4h case   20:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224AAE4h case   20:*/		return 0x8224AAE8;
		  /* 8224AAE8h */ case   21:  		/* bc 12, CR0_EQ, 224 */
		/* 8224AAE8h case   21:*/		if ( regs.CR[0].eq ) { return 0x8224ABC8;  }
		/* 8224AAE8h case   21:*/		return 0x8224AAEC;
		  /* 8224AAECh */ case   22:  		/* lwz R11, <#[R28 + 4]> */
		/* 8224AAECh case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8224AAECh case   22:*/		return 0x8224AAF0;
		  /* 8224AAF0h */ case   23:  		/* cmpwi CR6, R11, 2 */
		/* 8224AAF0h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8224AAF0h case   23:*/		return 0x8224AAF4;
		  /* 8224AAF4h */ case   24:  		/* bc 4, CR6_EQ, 28 */
		/* 8224AAF4h case   24:*/		if ( !regs.CR[6].eq ) { return 0x8224AB10;  }
		/* 8224AAF4h case   24:*/		return 0x8224AAF8;
		  /* 8224AAF8h */ case   25:  		/* mr R6, R24 */
		/* 8224AAF8h case   25:*/		regs.R6 = regs.R24;
		/* 8224AAF8h case   25:*/		return 0x8224AAFC;
		  /* 8224AAFCh */ case   26:  		/* mr R5, R21 */
		/* 8224AAFCh case   26:*/		regs.R5 = regs.R21;
		/* 8224AAFCh case   26:*/		return 0x8224AB00;
		  /* 8224AB00h */ case   27:  		/* mr R4, R25 */
		/* 8224AB00h case   27:*/		regs.R4 = regs.R25;
		/* 8224AB00h case   27:*/		return 0x8224AB04;
		  /* 8224AB04h */ case   28:  		/* li R7, 414 */
		/* 8224AB04h case   28:*/		cpu::op::li<0>(regs,&regs.R7,0x19E);
		/* 8224AB04h case   28:*/		return 0x8224AB08;
		  /* 8224AB08h */ case   29:  		/* li R3, 0 */
		/* 8224AB08h case   29:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AB08h case   29:*/		return 0x8224AB0C;
		  /* 8224AB0Ch */ case   30:  		/* bl -995076 */
		/* 8224AB0Ch case   30:*/		regs.LR = 0x8224AB10; return 0x82157C08;
		/* 8224AB0Ch case   30:*/		return 0x8224AB10;
	}
	return 0x8224AB10;
} // Block from 8224AA94h-8224AB10h (31 instructions)

//////////////////////////////////////////////////////
// Block at 8224AB10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AB10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AB10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AB10);
		  /* 8224AB10h */ case    0:  		/* mr R3, R31 */
		/* 8224AB10h case    0:*/		regs.R3 = regs.R31;
		/* 8224AB10h case    0:*/		return 0x8224AB14;
		  /* 8224AB14h */ case    1:  		/* bl 115164 */
		/* 8224AB14h case    1:*/		regs.LR = 0x8224AB18; return 0x82266CF0;
		/* 8224AB14h case    1:*/		return 0x8224AB18;
		  /* 8224AB18h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224AB18h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224AB18h case    2:*/		return 0x8224AB1C;
		  /* 8224AB1Ch */ case    3:  		/* lwz R11, <#[R28 + 4]> */
		/* 8224AB1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8224AB1Ch case    3:*/		return 0x8224AB20;
		  /* 8224AB20h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 8224AB20h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224AB20h case    4:*/		return 0x8224AB24;
		  /* 8224AB24h */ case    5:  		/* bc 12, CR0_EQ, 152 */
		/* 8224AB24h case    5:*/		if ( regs.CR[0].eq ) { return 0x8224ABBC;  }
		/* 8224AB24h case    5:*/		return 0x8224AB28;
		  /* 8224AB28h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 8224AB28h case    6:*/		if ( regs.CR[6].eq ) { return 0x8224AB34;  }
		/* 8224AB28h case    6:*/		return 0x8224AB2C;
		  /* 8224AB2Ch */ case    7:  		/* cmpwi CR6, R11, 1 */
		/* 8224AB2Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224AB2Ch case    7:*/		return 0x8224AB30;
		  /* 8224AB30h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 8224AB30h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8224AB3C;  }
		/* 8224AB30h case    8:*/		return 0x8224AB34;
	}
	return 0x8224AB34;
} // Block from 8224AB10h-8224AB34h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224AB34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AB34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AB34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AB34);
		  /* 8224AB34h */ case    0:  		/* li R11, 3 */
		/* 8224AB34h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8224AB34h case    0:*/		return 0x8224AB38;
		  /* 8224AB38h */ case    1:  		/* stw R11, <#[R28 + 4]> */
		/* 8224AB38h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8224AB38h case    1:*/		return 0x8224AB3C;
	}
	return 0x8224AB3C;
} // Block from 8224AB34h-8224AB3Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224AB3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AB3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AB3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AB3C);
		  /* 8224AB3Ch */ case    0:  		/* lwz R11, <#[R28]> */
		/* 8224AB3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8224AB3Ch case    0:*/		return 0x8224AB40;
		  /* 8224AB40h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8224AB40h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224AB40h case    1:*/		return 0x8224AB44;
		  /* 8224AB44h */ case    2:  		/* bc 12, CR6_EQ, 92 */
		/* 8224AB44h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224ABA0;  }
		/* 8224AB44h case    2:*/		return 0x8224AB48;
		  /* 8224AB48h */ case    3:  		/* cmplwi CR6, R26, 0 */
		/* 8224AB48h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8224AB48h case    3:*/		return 0x8224AB4C;
		  /* 8224AB4Ch */ case    4:  		/* bc 4, CR6_EQ, 28 */
		/* 8224AB4Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x8224AB68;  }
		/* 8224AB4Ch case    4:*/		return 0x8224AB50;
		  /* 8224AB50h */ case    5:  		/* mr R6, R24 */
		/* 8224AB50h case    5:*/		regs.R6 = regs.R24;
		/* 8224AB50h case    5:*/		return 0x8224AB54;
		  /* 8224AB54h */ case    6:  		/* mr R5, R23 */
		/* 8224AB54h case    6:*/		regs.R5 = regs.R23;
		/* 8224AB54h case    6:*/		return 0x8224AB58;
		  /* 8224AB58h */ case    7:  		/* mr R4, R25 */
		/* 8224AB58h case    7:*/		regs.R4 = regs.R25;
		/* 8224AB58h case    7:*/		return 0x8224AB5C;
		  /* 8224AB5Ch */ case    8:  		/* li R7, 421 */
		/* 8224AB5Ch case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x1A5);
		/* 8224AB5Ch case    8:*/		return 0x8224AB60;
		  /* 8224AB60h */ case    9:  		/* li R3, 0 */
		/* 8224AB60h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AB60h case    9:*/		return 0x8224AB64;
		  /* 8224AB64h */ case   10:  		/* bl -995164 */
		/* 8224AB64h case   10:*/		regs.LR = 0x8224AB68; return 0x82157C08;
		/* 8224AB64h case   10:*/		return 0x8224AB68;
	}
	return 0x8224AB68;
} // Block from 8224AB3Ch-8224AB68h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224AB68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AB68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AB68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AB68);
		  /* 8224AB68h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 8224AB68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224AB68h case    0:*/		return 0x8224AB6C;
		  /* 8224AB6Ch */ case    1:  		/* stw R11, <#[R26 + 64]> */
		/* 8224AB6Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000040) );
		/* 8224AB6Ch case    1:*/		return 0x8224AB70;
		  /* 8224AB70h */ case    2:  		/* lwz R11, <#[R27]> */
		/* 8224AB70h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224AB70h case    2:*/		return 0x8224AB74;
		  /* 8224AB74h */ case    3:  		/* lwz R11, <#[R11 + 64]> */
		/* 8224AB74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000040) );
		/* 8224AB74h case    3:*/		return 0x8224AB78;
		  /* 8224AB78h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8224AB78h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224AB78h case    4:*/		return 0x8224AB7C;
		  /* 8224AB7Ch */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 8224AB7Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8224AB98;  }
		/* 8224AB7Ch case    5:*/		return 0x8224AB80;
		  /* 8224AB80h */ case    6:  		/* li R7, 423 */
		/* 8224AB80h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1A7);
		/* 8224AB80h case    6:*/		return 0x8224AB84;
		  /* 8224AB84h */ case    7:  		/* mr R4, R25 */
		/* 8224AB84h case    7:*/		regs.R4 = regs.R25;
		/* 8224AB84h case    7:*/		return 0x8224AB88;
		  /* 8224AB88h */ case    8:  		/* mr R5, R29 */
		/* 8224AB88h case    8:*/		regs.R5 = regs.R29;
		/* 8224AB88h case    8:*/		return 0x8224AB8C;
		  /* 8224AB8Ch */ case    9:  		/* mr R6, R24 */
		/* 8224AB8Ch case    9:*/		regs.R6 = regs.R24;
		/* 8224AB8Ch case    9:*/		return 0x8224AB90;
		  /* 8224AB90h */ case   10:  		/* li R3, 0 */
		/* 8224AB90h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AB90h case   10:*/		return 0x8224AB94;
		  /* 8224AB94h */ case   11:  		/* bl -995212 */
		/* 8224AB94h case   11:*/		regs.LR = 0x8224AB98; return 0x82157C08;
		/* 8224AB94h case   11:*/		return 0x8224AB98;
	}
	return 0x8224AB98;
} // Block from 8224AB68h-8224AB98h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224AB98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AB98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AB98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AB98);
		  /* 8224AB98h */ case    0:  		/* lwz R26, <#[R26 + 64]> */
		/* 8224AB98h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R26 + 0x00000040) );
		/* 8224AB98h case    0:*/		return 0x8224AB9C;
		  /* 8224AB9Ch */ case    1:  		/* b 288 */
		/* 8224AB9Ch case    1:*/		return 0x8224ACBC;
		/* 8224AB9Ch case    1:*/		return 0x8224ABA0;
	}
	return 0x8224ABA0;
} // Block from 8224AB98h-8224ABA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224ABA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ABA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ABA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ABA0);
		  /* 8224ABA0h */ case    0:  		/* lwz R26, <#[R27]> */
		/* 8224ABA0h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R27 + 0x00000000) );
		/* 8224ABA0h case    0:*/		return 0x8224ABA4;
		  /* 8224ABA4h */ case    1:  		/* stw R26, <#[R28]> */
		/* 8224ABA4h case    1:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R28 + 0x00000000) );
		/* 8224ABA4h case    1:*/		return 0x8224ABA8;
		  /* 8224ABA8h */ case    2:  		/* lwz R11, <#[R26 + 64]> */
		/* 8224ABA8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000040) );
		/* 8224ABA8h case    2:*/		return 0x8224ABAC;
		  /* 8224ABACh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8224ABACh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224ABACh case    3:*/		return 0x8224ABB0;
		  /* 8224ABB0h */ case    4:  		/* bc 12, CR6_EQ, 268 */
		/* 8224ABB0h case    4:*/		if ( regs.CR[6].eq ) { return 0x8224ACBC;  }
		/* 8224ABB0h case    4:*/		return 0x8224ABB4;
		  /* 8224ABB4h */ case    5:  		/* li R7, 428 */
		/* 8224ABB4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1AC);
		/* 8224ABB4h case    5:*/		return 0x8224ABB8;
		  /* 8224ABB8h */ case    6:  		/* b 224 */
		/* 8224ABB8h case    6:*/		return 0x8224AC98;
		/* 8224ABB8h case    6:*/		return 0x8224ABBC;
	}
	return 0x8224ABBC;
} // Block from 8224ABA0h-8224ABBCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224ABBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ABBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ABBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ABBC);
		  /* 8224ABBCh */ case    0:  		/* bc 4, CR6_EQ, 256 */
		/* 8224ABBCh case    0:*/		if ( !regs.CR[6].eq ) { return 0x8224ACBC;  }
		/* 8224ABBCh case    0:*/		return 0x8224ABC0;
		  /* 8224ABC0h */ case    1:  		/* stw R18, <#[R28 + 4]> */
		/* 8224ABC0h case    1:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R28 + 0x00000004) );
		/* 8224ABC0h case    1:*/		return 0x8224ABC4;
		  /* 8224ABC4h */ case    2:  		/* b 248 */
		/* 8224ABC4h case    2:*/		return 0x8224ACBC;
		/* 8224ABC4h case    2:*/		return 0x8224ABC8;
	}
	return 0x8224ABC8;
} // Block from 8224ABBCh-8224ABC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224ABC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ABC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ABC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ABC8);
		  /* 8224ABC8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8224ABC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224ABC8h case    0:*/		return 0x8224ABCC;
		  /* 8224ABCCh */ case    1:  		/* mr R3, R31 */
		/* 8224ABCCh case    1:*/		regs.R3 = regs.R31;
		/* 8224ABCCh case    1:*/		return 0x8224ABD0;
		  /* 8224ABD0h */ case    2:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224ABD0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224ABD0h case    2:*/		return 0x8224ABD4;
		  /* 8224ABD4h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224ABD4h case    3:*/		regs.CTR = regs.R11;
		/* 8224ABD4h case    3:*/		return 0x8224ABD8;
		  /* 8224ABD8h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224ABD8h case    4:*/		if ( 1 ) { regs.LR = 0x8224ABDC; return (uint32)regs.CTR; }
		/* 8224ABD8h case    4:*/		return 0x8224ABDC;
		  /* 8224ABDCh */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224ABDCh case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224ABDCh case    5:*/		return 0x8224ABE0;
		  /* 8224ABE0h */ case    6:  		/* bc 12, CR0_EQ, 220 */
		/* 8224ABE0h case    6:*/		if ( regs.CR[0].eq ) { return 0x8224ACBC;  }
		/* 8224ABE0h case    6:*/		return 0x8224ABE4;
		  /* 8224ABE4h */ case    7:  		/* lwz R11, <#[R28 + 4]> */
		/* 8224ABE4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8224ABE4h case    7:*/		return 0x8224ABE8;
		  /* 8224ABE8h */ case    8:  		/* cmpwi CR6, R11, 3 */
		/* 8224ABE8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8224ABE8h case    8:*/		return 0x8224ABEC;
		  /* 8224ABECh */ case    9:  		/* bc 4, CR6_EQ, 28 */
		/* 8224ABECh case    9:*/		if ( !regs.CR[6].eq ) { return 0x8224AC08;  }
		/* 8224ABECh case    9:*/		return 0x8224ABF0;
		  /* 8224ABF0h */ case   10:  		/* mr R6, R24 */
		/* 8224ABF0h case   10:*/		regs.R6 = regs.R24;
		/* 8224ABF0h case   10:*/		return 0x8224ABF4;
		  /* 8224ABF4h */ case   11:  		/* mr R5, R22 */
		/* 8224ABF4h case   11:*/		regs.R5 = regs.R22;
		/* 8224ABF4h case   11:*/		return 0x8224ABF8;
		  /* 8224ABF8h */ case   12:  		/* mr R4, R25 */
		/* 8224ABF8h case   12:*/		regs.R4 = regs.R25;
		/* 8224ABF8h case   12:*/		return 0x8224ABFC;
		  /* 8224ABFCh */ case   13:  		/* li R7, 436 */
		/* 8224ABFCh case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x1B4);
		/* 8224ABFCh case   13:*/		return 0x8224AC00;
		  /* 8224AC00h */ case   14:  		/* li R3, 0 */
		/* 8224AC00h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AC00h case   14:*/		return 0x8224AC04;
		  /* 8224AC04h */ case   15:  		/* bl -995324 */
		/* 8224AC04h case   15:*/		regs.LR = 0x8224AC08; return 0x82157C08;
		/* 8224AC04h case   15:*/		return 0x8224AC08;
	}
	return 0x8224AC08;
} // Block from 8224ABC8h-8224AC08h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8224AC08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AC08);
		  /* 8224AC08h */ case    0:  		/* mr R3, R31 */
		/* 8224AC08h case    0:*/		regs.R3 = regs.R31;
		/* 8224AC08h case    0:*/		return 0x8224AC0C;
		  /* 8224AC0Ch */ case    1:  		/* bl 114860 */
		/* 8224AC0Ch case    1:*/		regs.LR = 0x8224AC10; return 0x82266CB8;
		/* 8224AC0Ch case    1:*/		return 0x8224AC10;
		  /* 8224AC10h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224AC10h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224AC10h case    2:*/		return 0x8224AC14;
		  /* 8224AC14h */ case    3:  		/* lwz R11, <#[R28 + 4]> */
		/* 8224AC14h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8224AC14h case    3:*/		return 0x8224AC18;
		  /* 8224AC18h */ case    4:  		/* bc 12, CR0_EQ, 152 */
		/* 8224AC18h case    4:*/		if ( regs.CR[0].eq ) { return 0x8224ACB0;  }
		/* 8224AC18h case    4:*/		return 0x8224AC1C;
		  /* 8224AC1Ch */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 8224AC1Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224AC1Ch case    5:*/		return 0x8224AC20;
		  /* 8224AC20h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 8224AC20h case    6:*/		if ( regs.CR[6].eq ) { return 0x8224AC2C;  }
		/* 8224AC20h case    6:*/		return 0x8224AC24;
		  /* 8224AC24h */ case    7:  		/* cmpwi CR6, R11, 1 */
		/* 8224AC24h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224AC24h case    7:*/		return 0x8224AC28;
		  /* 8224AC28h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 8224AC28h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8224AC34;  }
		/* 8224AC28h case    8:*/		return 0x8224AC2C;
	}
	return 0x8224AC2C;
} // Block from 8224AC08h-8224AC2Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224AC2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AC2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AC2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AC2C);
		  /* 8224AC2Ch */ case    0:  		/* li R11, 2 */
		/* 8224AC2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8224AC2Ch case    0:*/		return 0x8224AC30;
		  /* 8224AC30h */ case    1:  		/* stw R11, <#[R28 + 4]> */
		/* 8224AC30h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8224AC30h case    1:*/		return 0x8224AC34;
	}
	return 0x8224AC34;
} // Block from 8224AC2Ch-8224AC34h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224AC34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AC34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AC34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AC34);
		  /* 8224AC34h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 8224AC34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8224AC34h case    0:*/		return 0x8224AC38;
		  /* 8224AC38h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8224AC38h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224AC38h case    1:*/		return 0x8224AC3C;
		  /* 8224AC3Ch */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 8224AC3Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8224AC80;  }
		/* 8224AC3Ch case    2:*/		return 0x8224AC40;
		  /* 8224AC40h */ case    3:  		/* cmplwi CR6, R26, 0 */
		/* 8224AC40h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8224AC40h case    3:*/		return 0x8224AC44;
		  /* 8224AC44h */ case    4:  		/* bc 4, CR6_EQ, 28 */
		/* 8224AC44h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8224AC60;  }
		/* 8224AC44h case    4:*/		return 0x8224AC48;
		  /* 8224AC48h */ case    5:  		/* mr R6, R24 */
		/* 8224AC48h case    5:*/		regs.R6 = regs.R24;
		/* 8224AC48h case    5:*/		return 0x8224AC4C;
		  /* 8224AC4Ch */ case    6:  		/* mr R5, R23 */
		/* 8224AC4Ch case    6:*/		regs.R5 = regs.R23;
		/* 8224AC4Ch case    6:*/		return 0x8224AC50;
		  /* 8224AC50h */ case    7:  		/* mr R4, R25 */
		/* 8224AC50h case    7:*/		regs.R4 = regs.R25;
		/* 8224AC50h case    7:*/		return 0x8224AC54;
		  /* 8224AC54h */ case    8:  		/* li R7, 443 */
		/* 8224AC54h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x1BB);
		/* 8224AC54h case    8:*/		return 0x8224AC58;
		  /* 8224AC58h */ case    9:  		/* li R3, 0 */
		/* 8224AC58h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AC58h case    9:*/		return 0x8224AC5C;
		  /* 8224AC5Ch */ case   10:  		/* bl -995412 */
		/* 8224AC5Ch case   10:*/		regs.LR = 0x8224AC60; return 0x82157C08;
		/* 8224AC5Ch case   10:*/		return 0x8224AC60;
	}
	return 0x8224AC60;
} // Block from 8224AC34h-8224AC60h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224AC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AC60);
		  /* 8224AC60h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 8224AC60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224AC60h case    0:*/		return 0x8224AC64;
		  /* 8224AC64h */ case    1:  		/* stw R11, <#[R26 + 64]> */
		/* 8224AC64h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000040) );
		/* 8224AC64h case    1:*/		return 0x8224AC68;
		  /* 8224AC68h */ case    2:  		/* lwz R11, <#[R27]> */
		/* 8224AC68h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8224AC68h case    2:*/		return 0x8224AC6C;
		  /* 8224AC6Ch */ case    3:  		/* lwz R11, <#[R11 + 64]> */
		/* 8224AC6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000040) );
		/* 8224AC6Ch case    3:*/		return 0x8224AC70;
		  /* 8224AC70h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8224AC70h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224AC70h case    4:*/		return 0x8224AC74;
		  /* 8224AC74h */ case    5:  		/* bc 12, CR6_EQ, -220 */
		/* 8224AC74h case    5:*/		if ( regs.CR[6].eq ) { return 0x8224AB98;  }
		/* 8224AC74h case    5:*/		return 0x8224AC78;
		  /* 8224AC78h */ case    6:  		/* li R7, 445 */
		/* 8224AC78h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1BD);
		/* 8224AC78h case    6:*/		return 0x8224AC7C;
		  /* 8224AC7Ch */ case    7:  		/* b -248 */
		/* 8224AC7Ch case    7:*/		return 0x8224AB84;
		/* 8224AC7Ch case    7:*/		return 0x8224AC80;
	}
	return 0x8224AC80;
} // Block from 8224AC60h-8224AC80h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224AC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AC80);
		  /* 8224AC80h */ case    0:  		/* lwz R26, <#[R27]> */
		/* 8224AC80h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R27 + 0x00000000) );
		/* 8224AC80h case    0:*/		return 0x8224AC84;
		  /* 8224AC84h */ case    1:  		/* stw R26, <#[R28]> */
		/* 8224AC84h case    1:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R28 + 0x00000000) );
		/* 8224AC84h case    1:*/		return 0x8224AC88;
		  /* 8224AC88h */ case    2:  		/* lwz R11, <#[R26 + 64]> */
		/* 8224AC88h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000040) );
		/* 8224AC88h case    2:*/		return 0x8224AC8C;
		  /* 8224AC8Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8224AC8Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224AC8Ch case    3:*/		return 0x8224AC90;
		  /* 8224AC90h */ case    4:  		/* bc 12, CR6_EQ, 44 */
		/* 8224AC90h case    4:*/		if ( regs.CR[6].eq ) { return 0x8224ACBC;  }
		/* 8224AC90h case    4:*/		return 0x8224AC94;
		  /* 8224AC94h */ case    5:  		/* li R7, 450 */
		/* 8224AC94h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1C2);
		/* 8224AC94h case    5:*/		return 0x8224AC98;
	}
	return 0x8224AC98;
} // Block from 8224AC80h-8224AC98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224AC98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AC98);
		  /* 8224AC98h */ case    0:  		/* mr R4, R25 */
		/* 8224AC98h case    0:*/		regs.R4 = regs.R25;
		/* 8224AC98h case    0:*/		return 0x8224AC9C;
		  /* 8224AC9Ch */ case    1:  		/* mr R5, R30 */
		/* 8224AC9Ch case    1:*/		regs.R5 = regs.R30;
		/* 8224AC9Ch case    1:*/		return 0x8224ACA0;
		  /* 8224ACA0h */ case    2:  		/* mr R6, R24 */
		/* 8224ACA0h case    2:*/		regs.R6 = regs.R24;
		/* 8224ACA0h case    2:*/		return 0x8224ACA4;
		  /* 8224ACA4h */ case    3:  		/* li R3, 0 */
		/* 8224ACA4h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224ACA4h case    3:*/		return 0x8224ACA8;
		  /* 8224ACA8h */ case    4:  		/* bl -995488 */
		/* 8224ACA8h case    4:*/		regs.LR = 0x8224ACAC; return 0x82157C08;
		/* 8224ACA8h case    4:*/		return 0x8224ACAC;
		  /* 8224ACACh */ case    5:  		/* b 16 */
		/* 8224ACACh case    5:*/		return 0x8224ACBC;
		/* 8224ACACh case    5:*/		return 0x8224ACB0;
	}
	return 0x8224ACB0;
} // Block from 8224AC98h-8224ACB0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224ACB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ACB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ACB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ACB0);
		  /* 8224ACB0h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 8224ACB0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224ACB0h case    0:*/		return 0x8224ACB4;
		  /* 8224ACB4h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8224ACB4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224ACBC;  }
		/* 8224ACB4h case    1:*/		return 0x8224ACB8;
		  /* 8224ACB8h */ case    2:  		/* stw R19, <#[R28 + 4]> */
		/* 8224ACB8h case    2:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R28 + 0x00000004) );
		/* 8224ACB8h case    2:*/		return 0x8224ACBC;
	}
	return 0x8224ACBC;
} // Block from 8224ACB0h-8224ACBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224ACBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ACBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ACBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ACBC);
		  /* 8224ACBCh */ case    0:  		/* addic. R20, R20, -1 */
		/* 8224ACBCh case    0:*/		cpu::op::addic<1>(regs,&regs.R20,regs.R20,0xFFFFFFFF);
		/* 8224ACBCh case    0:*/		return 0x8224ACC0;
		  /* 8224ACC0h */ case    1:  		/* addi R27, R27, 4 */
		/* 8224ACC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8224ACC0h case    1:*/		return 0x8224ACC4;
		  /* 8224ACC4h */ case    2:  		/* bc 4, CR0_EQ, -516 */
		/* 8224ACC4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8224AAC0;  }
		/* 8224ACC4h case    2:*/		return 0x8224ACC8;
		  /* 8224ACC8h */ case    3:  		/* addi R1, R1, 208 */
		/* 8224ACC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 8224ACC8h case    3:*/		return 0x8224ACCC;
		  /* 8224ACCCh */ case    4:  		/* b -1808972 */
		/* 8224ACCCh case    4:*/		return 0x82091280;
		/* 8224ACCCh case    4:*/		return 0x8224ACD0;
	}
	return 0x8224ACD0;
} // Block from 8224ACBCh-8224ACD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224ACD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ACD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ACD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ACD0);
		  /* 8224ACD0h */ case    0:  		/* mfspr R12, LR */
		/* 8224ACD0h case    0:*/		regs.R12 = regs.LR;
		/* 8224ACD0h case    0:*/		return 0x8224ACD4;
		  /* 8224ACD4h */ case    1:  		/* bl -1809020 */
		/* 8224ACD4h case    1:*/		regs.LR = 0x8224ACD8; return 0x82091258;
		/* 8224ACD4h case    1:*/		return 0x8224ACD8;
		  /* 8224ACD8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8224ACD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8224ACD8h case    2:*/		return 0x8224ACDC;
		  /* 8224ACDCh */ case    3:  		/* lis R11, -32253 */
		/* 8224ACDCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224ACDCh case    3:*/		return 0x8224ACE0;
		  /* 8224ACE0h */ case    4:  		/* lis R10, -32252 */
		/* 8224ACE0h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224ACE0h case    4:*/		return 0x8224ACE4;
		  /* 8224ACE4h */ case    5:  		/* addi R30, R11, 27460 */
		/* 8224ACE4h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x6B44);
		/* 8224ACE4h case    5:*/		return 0x8224ACE8;
		  /* 8224ACE8h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224ACE8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224ACE8h case    6:*/		return 0x8224ACEC;
		  /* 8224ACECh */ case    7:  		/* mr R31, R3 */
		/* 8224ACECh case    7:*/		regs.R31 = regs.R3;
		/* 8224ACECh case    7:*/		return 0x8224ACF0;
		  /* 8224ACF0h */ case    8:  		/* mr R28, R4 */
		/* 8224ACF0h case    8:*/		regs.R28 = regs.R4;
		/* 8224ACF0h case    8:*/		return 0x8224ACF4;
		  /* 8224ACF4h */ case    9:  		/* addi R29, R10, 14208 */
		/* 8224ACF4h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0x3780);
		/* 8224ACF4h case    9:*/		return 0x8224ACF8;
		  /* 8224ACF8h */ case   10:  		/* cmpwi CR6, R11, 1 */
		/* 8224ACF8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224ACF8h case   10:*/		return 0x8224ACFC;
		  /* 8224ACFCh */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 8224ACFCh case   11:*/		if ( regs.CR[6].eq ) { return 0x8224AD24;  }
		/* 8224ACFCh case   11:*/		return 0x8224AD00;
		  /* 8224AD00h */ case   12:  		/* cmpwi CR6, R11, 3 */
		/* 8224AD00h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8224AD00h case   12:*/		return 0x8224AD04;
		  /* 8224AD04h */ case   13:  		/* bc 12, CR6_EQ, 32 */
		/* 8224AD04h case   13:*/		if ( regs.CR[6].eq ) { return 0x8224AD24;  }
		/* 8224AD04h case   13:*/		return 0x8224AD08;
		  /* 8224AD08h */ case   14:  		/* lis R11, -32252 */
		/* 8224AD08h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224AD08h case   14:*/		return 0x8224AD0C;
		  /* 8224AD0Ch */ case   15:  		/* mr R6, R29 */
		/* 8224AD0Ch case   15:*/		regs.R6 = regs.R29;
		/* 8224AD0Ch case   15:*/		return 0x8224AD10;
		  /* 8224AD10h */ case   16:  		/* addi R5, R11, 14328 */
		/* 8224AD10h case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x37F8);
		/* 8224AD10h case   16:*/		return 0x8224AD14;
		  /* 8224AD14h */ case   17:  		/* mr R4, R30 */
		/* 8224AD14h case   17:*/		regs.R4 = regs.R30;
		/* 8224AD14h case   17:*/		return 0x8224AD18;
		  /* 8224AD18h */ case   18:  		/* li R7, 466 */
		/* 8224AD18h case   18:*/		cpu::op::li<0>(regs,&regs.R7,0x1D2);
		/* 8224AD18h case   18:*/		return 0x8224AD1C;
		  /* 8224AD1Ch */ case   19:  		/* li R3, 0 */
		/* 8224AD1Ch case   19:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AD1Ch case   19:*/		return 0x8224AD20;
		  /* 8224AD20h */ case   20:  		/* bl -995608 */
		/* 8224AD20h case   20:*/		regs.LR = 0x8224AD24; return 0x82157C08;
		/* 8224AD20h case   20:*/		return 0x8224AD24;
	}
	return 0x8224AD24;
} // Block from 8224ACD0h-8224AD24h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224AD24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AD24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AD24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AD24);
		  /* 8224AD24h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8224AD24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224AD24h case    0:*/		return 0x8224AD28;
		  /* 8224AD28h */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 8224AD28h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224AD28h case    1:*/		return 0x8224AD2C;
		  /* 8224AD2Ch */ case    2:  		/* bc 4, CR6_EQ, 20 */
		/* 8224AD2Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224AD40;  }
		/* 8224AD2Ch case    2:*/		return 0x8224AD30;
		  /* 8224AD30h */ case    3:  		/* li R11, 3 */
		/* 8224AD30h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8224AD30h case    3:*/		return 0x8224AD34;
		  /* 8224AD34h */ case    4:  		/* stw R28, <#[R31]> */
		/* 8224AD34h case    4:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 8224AD34h case    4:*/		return 0x8224AD38;
		  /* 8224AD38h */ case    5:  		/* stw R11, <#[R31 + 4]> */
		/* 8224AD38h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8224AD38h case    5:*/		return 0x8224AD3C;
		  /* 8224AD3Ch */ case    6:  		/* b 68 */
		/* 8224AD3Ch case    6:*/		return 0x8224AD80;
		/* 8224AD3Ch case    6:*/		return 0x8224AD40;
	}
	return 0x8224AD40;
} // Block from 8224AD24h-8224AD40h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224AD40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AD40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AD40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AD40);
		  /* 8224AD40h */ case    0:  		/* cmpwi CR6, R11, 3 */
		/* 8224AD40h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8224AD40h case    0:*/		return 0x8224AD44;
		  /* 8224AD44h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 8224AD44h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8224AD64;  }
		/* 8224AD44h case    1:*/		return 0x8224AD48;
		  /* 8224AD48h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8224AD48h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224AD48h case    2:*/		return 0x8224AD4C;
		  /* 8224AD4Ch */ case    3:  		/* cmplw CR6, R11, R28 */
		/* 8224AD4Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 8224AD4Ch case    3:*/		return 0x8224AD50;
		  /* 8224AD50h */ case    4:  		/* bc 12, CR6_EQ, 48 */
		/* 8224AD50h case    4:*/		if ( regs.CR[6].eq ) { return 0x8224AD80;  }
		/* 8224AD50h case    4:*/		return 0x8224AD54;
		  /* 8224AD54h */ case    5:  		/* lis R11, -32252 */
		/* 8224AD54h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224AD54h case    5:*/		return 0x8224AD58;
		  /* 8224AD58h */ case    6:  		/* li R7, 472 */
		/* 8224AD58h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1D8);
		/* 8224AD58h case    6:*/		return 0x8224AD5C;
		  /* 8224AD5Ch */ case    7:  		/* addi R5, R11, 14300 */
		/* 8224AD5Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x37DC);
		/* 8224AD5Ch case    7:*/		return 0x8224AD60;
		  /* 8224AD60h */ case    8:  		/* b 16 */
		/* 8224AD60h case    8:*/		return 0x8224AD70;
		/* 8224AD60h case    8:*/		return 0x8224AD64;
	}
	return 0x8224AD64;
} // Block from 8224AD40h-8224AD64h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224AD64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AD64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AD64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AD64);
		  /* 8224AD64h */ case    0:  		/* lis R11, -32255 */
		/* 8224AD64h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8224AD64h case    0:*/		return 0x8224AD68;
		  /* 8224AD68h */ case    1:  		/* li R7, 474 */
		/* 8224AD68h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x1DA);
		/* 8224AD68h case    1:*/		return 0x8224AD6C;
		  /* 8224AD6Ch */ case    2:  		/* addi R5, R11, 5216 */
		/* 8224AD6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1460);
		/* 8224AD6Ch case    2:*/		return 0x8224AD70;
	}
	return 0x8224AD70;
} // Block from 8224AD64h-8224AD70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224AD70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AD70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AD70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AD70);
		  /* 8224AD70h */ case    0:  		/* mr R6, R29 */
		/* 8224AD70h case    0:*/		regs.R6 = regs.R29;
		/* 8224AD70h case    0:*/		return 0x8224AD74;
		  /* 8224AD74h */ case    1:  		/* mr R4, R30 */
		/* 8224AD74h case    1:*/		regs.R4 = regs.R30;
		/* 8224AD74h case    1:*/		return 0x8224AD78;
		  /* 8224AD78h */ case    2:  		/* li R3, 0 */
		/* 8224AD78h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AD78h case    2:*/		return 0x8224AD7C;
		  /* 8224AD7Ch */ case    3:  		/* bl -995700 */
		/* 8224AD7Ch case    3:*/		regs.LR = 0x8224AD80; return 0x82157C08;
		/* 8224AD7Ch case    3:*/		return 0x8224AD80;
	}
	return 0x8224AD80;
} // Block from 8224AD70h-8224AD80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224AD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AD80);
		  /* 8224AD80h */ case    0:  		/* addi R1, R1, 128 */
		/* 8224AD80h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8224AD80h case    0:*/		return 0x8224AD84;
		  /* 8224AD84h */ case    1:  		/* b -1809116 */
		/* 8224AD84h case    1:*/		return 0x820912A8;
		/* 8224AD84h case    1:*/		return 0x8224AD88;
		  /* 8224AD88h */ case    2:  		/* lwz R9, <#[R3 + 4]> */
		/* 8224AD88h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 8224AD88h case    2:*/		return 0x8224AD8C;
		  /* 8224AD8Ch */ case    3:  		/* li R11, 0 */
		/* 8224AD8Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224AD8Ch case    3:*/		return 0x8224AD90;
		  /* 8224AD90h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 8224AD90h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8224AD90h case    4:*/		return 0x8224AD94;
		  /* 8224AD94h */ case    5:  		/* bc 12, CR6_EQ, 48 */
		/* 8224AD94h case    5:*/		if ( regs.CR[6].eq ) { return 0x8224ADC4;  }
		/* 8224AD94h case    5:*/		return 0x8224AD98;
		  /* 8224AD98h */ case    6:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 8224AD98h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 8224AD98h case    6:*/		return 0x8224AD9C;
		  /* 8224AD9Ch */ case    7:  		/* rlwinm R8, R11, 0, 27, 31 */
		/* 8224AD9Ch case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R11);
		/* 8224AD9Ch case    7:*/		return 0x8224ADA0;
		  /* 8224ADA0h */ case    8:  		/* addi R10, R10, 2 */
		/* 8224ADA0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8224ADA0h case    8:*/		return 0x8224ADA4;
		  /* 8224ADA4h */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8224ADA4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8224ADA4h case    9:*/		return 0x8224ADA8;
		  /* 8224ADA8h */ case   10:  		/* lwzx R10, <#[R10 + R3]> */
		/* 8224ADA8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8224ADA8h case   10:*/		return 0x8224ADAC;
		  /* 8224ADACh */ case   11:  		/* srw R10, R10, R8 */
		/* 8224ADACh case   11:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8224ADACh case   11:*/		return 0x8224ADB0;
		  /* 8224ADB0h */ case   12:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 8224ADB0h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8224ADB0h case   12:*/		return 0x8224ADB4;
		  /* 8224ADB4h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 8224ADB4h case   13:*/		if ( regs.CR[0].eq ) { return 0x8224ADCC;  }
		/* 8224ADB4h case   13:*/		return 0x8224ADB8;
		  /* 8224ADB8h */ case   14:  		/* addi R11, R11, 1 */
		/* 8224ADB8h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224ADB8h case   14:*/		return 0x8224ADBC;
		  /* 8224ADBCh */ case   15:  		/* cmplw CR6, R11, R9 */
		/* 8224ADBCh case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8224ADBCh case   15:*/		return 0x8224ADC0;
		  /* 8224ADC0h */ case   16:  		/* bc 12, CR6_LT, -40 */
		/* 8224ADC0h case   16:*/		if ( regs.CR[6].lt ) { return 0x8224AD98;  }
		/* 8224ADC0h case   16:*/		return 0x8224ADC4;
	}
	return 0x8224ADC4;
} // Block from 8224AD80h-8224ADC4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8224ADC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ADC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ADC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ADC4);
		  /* 8224ADC4h */ case    0:  		/* li R3, -1 */
		/* 8224ADC4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8224ADC4h case    0:*/		return 0x8224ADC8;
		  /* 8224ADC8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224ADC8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224ADC8h case    1:*/		return 0x8224ADCC;
	}
	return 0x8224ADCC;
} // Block from 8224ADC4h-8224ADCCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224ADCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ADCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ADCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ADCC);
		  /* 8224ADCCh */ case    0:  		/* mr R3, R11 */
		/* 8224ADCCh case    0:*/		regs.R3 = regs.R11;
		/* 8224ADCCh case    0:*/		return 0x8224ADD0;
		  /* 8224ADD0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224ADD0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224ADD0h case    1:*/		return 0x8224ADD4;
	}
	return 0x8224ADD4;
} // Block from 8224ADCCh-8224ADD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224ADD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ADD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ADD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ADD4);
		  /* 8224ADD4h */ case    0:  		/* nop */
		/* 8224ADD4h case    0:*/		cpu::op::nop();
		/* 8224ADD4h case    0:*/		return 0x8224ADD8;
	}
	return 0x8224ADD8;
} // Block from 8224ADD4h-8224ADD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224ADD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ADD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ADD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ADD8);
		  /* 8224ADD8h */ case    0:  		/* li R11, 0 */
		/* 8224ADD8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224ADD8h case    0:*/		return 0x8224ADDC;
		  /* 8224ADDCh */ case    1:  		/* stw R11, <#[R3 + 4]> */
		/* 8224ADDCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224ADDCh case    1:*/		return 0x8224ADE0;
		  /* 8224ADE0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8224ADE0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224ADE0h case    2:*/		return 0x8224ADE4;
	}
	return 0x8224ADE4;
} // Block from 8224ADD8h-8224ADE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224ADE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ADE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ADE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ADE4);
		  /* 8224ADE4h */ case    0:  		/* nop */
		/* 8224ADE4h case    0:*/		cpu::op::nop();
		/* 8224ADE4h case    0:*/		return 0x8224ADE8;
	}
	return 0x8224ADE8;
} // Block from 8224ADE4h-8224ADE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224ADE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224ADE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224ADE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224ADE8);
		  /* 8224ADE8h */ case    0:  		/* mfspr R12, LR */
		/* 8224ADE8h case    0:*/		regs.R12 = regs.LR;
		/* 8224ADE8h case    0:*/		return 0x8224ADEC;
		  /* 8224ADECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224ADECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224ADECh case    1:*/		return 0x8224ADF0;
		  /* 8224ADF0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8224ADF0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224ADF0h case    2:*/		return 0x8224ADF4;
		  /* 8224ADF4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8224ADF4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224ADF4h case    3:*/		return 0x8224ADF8;
		  /* 8224ADF8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224ADF8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224ADF8h case    4:*/		return 0x8224ADFC;
		  /* 8224ADFCh */ case    5:  		/* addi R30, R3, 4 */
		/* 8224ADFCh case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x4);
		/* 8224ADFCh case    5:*/		return 0x8224AE00;
		  /* 8224AE00h */ case    6:  		/* li R31, 2 */
		/* 8224AE00h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x2);
		/* 8224AE00h case    6:*/		return 0x8224AE04;
		  /* 8224AE04h */ case    7:  		/* lwzu R3, <#[R30 + 4]> */
		/* 8224AE04h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8224AE04h case    7:*/		return 0x8224AE08;
		  /* 8224AE08h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 8224AE08h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224AE08h case    8:*/		return 0x8224AE0C;
		  /* 8224AE0Ch */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8224AE0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8224AE0Ch case    9:*/		return 0x8224AE10;
		  /* 8224AE10h */ case   10:  		/* mtspr CTR, R11 */
		/* 8224AE10h case   10:*/		regs.CTR = regs.R11;
		/* 8224AE10h case   10:*/		return 0x8224AE14;
		  /* 8224AE14h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8224AE14h case   11:*/		if ( 1 ) { regs.LR = 0x8224AE18; return (uint32)regs.CTR; }
		/* 8224AE14h case   11:*/		return 0x8224AE18;
		  /* 8224AE18h */ case   12:  		/* addic. R31, R31, -1 */
		/* 8224AE18h case   12:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 8224AE18h case   12:*/		return 0x8224AE1C;
		  /* 8224AE1Ch */ case   13:  		/* bc 4, CR0_EQ, -24 */
		/* 8224AE1Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x8224AE04;  }
		/* 8224AE1Ch case   13:*/		return 0x8224AE20;
		  /* 8224AE20h */ case   14:  		/* addi R1, R1, 112 */
		/* 8224AE20h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224AE20h case   14:*/		return 0x8224AE24;
		  /* 8224AE24h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224AE24h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224AE24h case   15:*/		return 0x8224AE28;
		  /* 8224AE28h */ case   16:  		/* mtspr LR, R12 */
		/* 8224AE28h case   16:*/		regs.LR = regs.R12;
		/* 8224AE28h case   16:*/		return 0x8224AE2C;
		  /* 8224AE2Ch */ case   17:  		/* ld R30, <#[R1 - 24]> */
		/* 8224AE2Ch case   17:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224AE2Ch case   17:*/		return 0x8224AE30;
		  /* 8224AE30h */ case   18:  		/* ld R31, <#[R1 - 16]> */
		/* 8224AE30h case   18:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224AE30h case   18:*/		return 0x8224AE34;
		  /* 8224AE34h */ case   19:  		/* bclr 20, CR0_LT */
		/* 8224AE34h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224AE34h case   19:*/		return 0x8224AE38;
	}
	return 0x8224AE38;
} // Block from 8224ADE8h-8224AE38h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8224AE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AE38);
		  /* 8224AE38h */ case    0:  		/* lwz R11, <#[R3 + 56]> */
		/* 8224AE38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 8224AE38h case    0:*/		return 0x8224AE3C;
		  /* 8224AE3Ch */ case    1:  		/* lwz R10, <#[R4 + 56]> */
		/* 8224AE3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000038) );
		/* 8224AE3Ch case    1:*/		return 0x8224AE40;
		  /* 8224AE40h */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 8224AE40h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224AE40h case    2:*/		return 0x8224AE44;
		  /* 8224AE44h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 8224AE44h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8224AE5C;  }
		/* 8224AE44h case    3:*/		return 0x8224AE48;
		  /* 8224AE48h */ case    4:  		/* lwz R11, <#[R3 + 80]> */
		/* 8224AE48h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 8224AE48h case    4:*/		return 0x8224AE4C;
		  /* 8224AE4Ch */ case    5:  		/* li R3, 0 */
		/* 8224AE4Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AE4Ch case    5:*/		return 0x8224AE50;
		  /* 8224AE50h */ case    6:  		/* lwz R10, <#[R4 + 80]> */
		/* 8224AE50h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000050) );
		/* 8224AE50h case    6:*/		return 0x8224AE54;
		  /* 8224AE54h */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 8224AE54h case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224AE54h case    7:*/		return 0x8224AE58;
		  /* 8224AE58h */ case    8:  		/* bclr 12, CR6_EQ */
		/* 8224AE58h case    8:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8224AE58h case    8:*/		return 0x8224AE5C;
	}
	return 0x8224AE5C;
} // Block from 8224AE38h-8224AE5Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224AE5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AE5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AE5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AE5C);
		  /* 8224AE5Ch */ case    0:  		/* li R3, -1 */
		/* 8224AE5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8224AE5Ch case    0:*/		return 0x8224AE60;
		  /* 8224AE60h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224AE60h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224AE60h case    1:*/		return 0x8224AE64;
	}
	return 0x8224AE64;
} // Block from 8224AE5Ch-8224AE64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224AE64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AE64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AE64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AE64);
		  /* 8224AE64h */ case    0:  		/* nop */
		/* 8224AE64h case    0:*/		cpu::op::nop();
		/* 8224AE64h case    0:*/		return 0x8224AE68;
	}
	return 0x8224AE68;
} // Block from 8224AE64h-8224AE68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224AE68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AE68);
		  /* 8224AE68h */ case    0:  		/* mfspr R12, LR */
		/* 8224AE68h case    0:*/		regs.R12 = regs.LR;
		/* 8224AE68h case    0:*/		return 0x8224AE6C;
		  /* 8224AE6Ch */ case    1:  		/* bl -1809428 */
		/* 8224AE6Ch case    1:*/		regs.LR = 0x8224AE70; return 0x82091258;
		/* 8224AE6Ch case    1:*/		return 0x8224AE70;
		  /* 8224AE70h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8224AE70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8224AE70h case    2:*/		return 0x8224AE74;
		  /* 8224AE74h */ case    3:  		/* lwz R31, <#[R3 + 56]> */
		/* 8224AE74h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000038) );
		/* 8224AE74h case    3:*/		return 0x8224AE78;
		  /* 8224AE78h */ case    4:  		/* lis R9, 1 */
		/* 8224AE78h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0x1);
		/* 8224AE78h case    4:*/		return 0x8224AE7C;
		  /* 8224AE7Ch */ case    5:  		/* lis R11, -32253 */
		/* 8224AE7Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224AE7Ch case    5:*/		return 0x8224AE80;
		  /* 8224AE80h */ case    6:  		/* lwz R28, <#[R3 + 80]> */
		/* 8224AE80h case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000050) );
		/* 8224AE80h case    6:*/		return 0x8224AE84;
		  /* 8224AE84h */ case    7:  		/* lis R10, -32252 */
		/* 8224AE84h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224AE84h case    7:*/		return 0x8224AE88;
		  /* 8224AE88h */ case    8:  		/* cmpw CR6, R31, R9 */
		/* 8224AE88h case    8:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R9);
		/* 8224AE88h case    8:*/		return 0x8224AE8C;
		  /* 8224AE8Ch */ case    9:  		/* addi R30, R11, 27460 */
		/* 8224AE8Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x6B44);
		/* 8224AE8Ch case    9:*/		return 0x8224AE90;
		  /* 8224AE90h */ case   10:  		/* addi R29, R10, 14208 */
		/* 8224AE90h case   10:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0x3780);
		/* 8224AE90h case   10:*/		return 0x8224AE94;
		  /* 8224AE94h */ case   11:  		/* bc 12, CR6_LT, 32 */
		/* 8224AE94h case   11:*/		if ( regs.CR[6].lt ) { return 0x8224AEB4;  }
		/* 8224AE94h case   11:*/		return 0x8224AE98;
		  /* 8224AE98h */ case   12:  		/* lis R11, -32252 */
		/* 8224AE98h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224AE98h case   12:*/		return 0x8224AE9C;
		  /* 8224AE9Ch */ case   13:  		/* mr R6, R29 */
		/* 8224AE9Ch case   13:*/		regs.R6 = regs.R29;
		/* 8224AE9Ch case   13:*/		return 0x8224AEA0;
		  /* 8224AEA0h */ case   14:  		/* addi R5, R11, 14404 */
		/* 8224AEA0h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3844);
		/* 8224AEA0h case   14:*/		return 0x8224AEA4;
		  /* 8224AEA4h */ case   15:  		/* mr R4, R30 */
		/* 8224AEA4h case   15:*/		regs.R4 = regs.R30;
		/* 8224AEA4h case   15:*/		return 0x8224AEA8;
		  /* 8224AEA8h */ case   16:  		/* li R7, 300 */
		/* 8224AEA8h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x12C);
		/* 8224AEA8h case   16:*/		return 0x8224AEAC;
		  /* 8224AEACh */ case   17:  		/* li R3, 0 */
		/* 8224AEACh case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AEACh case   17:*/		return 0x8224AEB0;
		  /* 8224AEB0h */ case   18:  		/* bl -996008 */
		/* 8224AEB0h case   18:*/		regs.LR = 0x8224AEB4; return 0x82157C08;
		/* 8224AEB0h case   18:*/		return 0x8224AEB4;
	}
	return 0x8224AEB4;
} // Block from 8224AE68h-8224AEB4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224AEB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AEB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AEB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AEB4);
		  /* 8224AEB4h */ case    0:  		/* lis R11, 0 */
		/* 8224AEB4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x0);
		/* 8224AEB4h case    0:*/		return 0x8224AEB8;
		  /* 8224AEB8h */ case    1:  		/* ori R11, R11, 32768 */
		/* 8224AEB8h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8224AEB8h case    1:*/		return 0x8224AEBC;
		  /* 8224AEBCh */ case    2:  		/* cmpw CR6, R28, R11 */
		/* 8224AEBCh case    2:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R11);
		/* 8224AEBCh case    2:*/		return 0x8224AEC0;
		  /* 8224AEC0h */ case    3:  		/* bc 12, CR6_LT, 32 */
		/* 8224AEC0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8224AEE0;  }
		/* 8224AEC0h case    3:*/		return 0x8224AEC4;
		  /* 8224AEC4h */ case    4:  		/* lis R11, -32252 */
		/* 8224AEC4h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224AEC4h case    4:*/		return 0x8224AEC8;
		  /* 8224AEC8h */ case    5:  		/* mr R6, R29 */
		/* 8224AEC8h case    5:*/		regs.R6 = regs.R29;
		/* 8224AEC8h case    5:*/		return 0x8224AECC;
		  /* 8224AECCh */ case    6:  		/* addi R5, R11, 14384 */
		/* 8224AECCh case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3830);
		/* 8224AECCh case    6:*/		return 0x8224AED0;
		  /* 8224AED0h */ case    7:  		/* mr R4, R30 */
		/* 8224AED0h case    7:*/		regs.R4 = regs.R30;
		/* 8224AED0h case    7:*/		return 0x8224AED4;
		  /* 8224AED4h */ case    8:  		/* li R7, 301 */
		/* 8224AED4h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x12D);
		/* 8224AED4h case    8:*/		return 0x8224AED8;
		  /* 8224AED8h */ case    9:  		/* li R3, 0 */
		/* 8224AED8h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AED8h case    9:*/		return 0x8224AEDC;
		  /* 8224AEDCh */ case   10:  		/* bl -996052 */
		/* 8224AEDCh case   10:*/		regs.LR = 0x8224AEE0; return 0x82157C08;
		/* 8224AEDCh case   10:*/		return 0x8224AEE0;
	}
	return 0x8224AEE0;
} // Block from 8224AEB4h-8224AEE0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8224AEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AEE0);
		  /* 8224AEE0h */ case    0:  		/* rlwinm R11, R28, 16, 0, 15 */
		/* 8224AEE0h case    0:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R11,regs.R28);
		/* 8224AEE0h case    0:*/		return 0x8224AEE4;
		  /* 8224AEE4h */ case    1:  		/* add R3, R11, R31 */
		/* 8224AEE4h case    1:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R31);
		/* 8224AEE4h case    1:*/		return 0x8224AEE8;
		  /* 8224AEE8h */ case    2:  		/* addi R1, R1, 128 */
		/* 8224AEE8h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8224AEE8h case    2:*/		return 0x8224AEEC;
		  /* 8224AEECh */ case    3:  		/* b -1809476 */
		/* 8224AEECh case    3:*/		return 0x820912A8;
		/* 8224AEECh case    3:*/		return 0x8224AEF0;
	}
	return 0x8224AEF0;
} // Block from 8224AEE0h-8224AEF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224AEF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AEF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AEF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AEF0);
		  /* 8224AEF0h */ case    0:  		/* mfspr R12, LR */
		/* 8224AEF0h case    0:*/		regs.R12 = regs.LR;
		/* 8224AEF0h case    0:*/		return 0x8224AEF4;
		  /* 8224AEF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224AEF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224AEF4h case    1:*/		return 0x8224AEF8;
		  /* 8224AEF8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8224AEF8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224AEF8h case    2:*/		return 0x8224AEFC;
		  /* 8224AEFCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8224AEFCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224AEFCh case    3:*/		return 0x8224AF00;
		  /* 8224AF00h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224AF00h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224AF00h case    4:*/		return 0x8224AF04;
		  /* 8224AF04h */ case    5:  		/* mr R30, R3 */
		/* 8224AF04h case    5:*/		regs.R30 = regs.R3;
		/* 8224AF04h case    5:*/		return 0x8224AF08;
		  /* 8224AF08h */ case    6:  		/* lwz R3, <#[R4 + 40]> */
		/* 8224AF08h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000028) );
		/* 8224AF08h case    6:*/		return 0x8224AF0C;
		  /* 8224AF0Ch */ case    7:  		/* mr R31, R4 */
		/* 8224AF0Ch case    7:*/		regs.R31 = regs.R4;
		/* 8224AF0Ch case    7:*/		return 0x8224AF10;
		  /* 8224AF10h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 8224AF10h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224AF10h case    8:*/		return 0x8224AF14;
		  /* 8224AF14h */ case    9:  		/* lwz R11, <#[R11 + 52]> */
		/* 8224AF14h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 8224AF14h case    9:*/		return 0x8224AF18;
		  /* 8224AF18h */ case   10:  		/* mtspr CTR, R11 */
		/* 8224AF18h case   10:*/		regs.CTR = regs.R11;
		/* 8224AF18h case   10:*/		return 0x8224AF1C;
		  /* 8224AF1Ch */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 8224AF1Ch case   11:*/		if ( 1 ) { regs.LR = 0x8224AF20; return (uint32)regs.CTR; }
		/* 8224AF1Ch case   11:*/		return 0x8224AF20;
		  /* 8224AF20h */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224AF20h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224AF20h case   12:*/		return 0x8224AF24;
		  /* 8224AF24h */ case   13:  		/* bc 12, CR0_EQ, 20 */
		/* 8224AF24h case   13:*/		if ( regs.CR[0].eq ) { return 0x8224AF38;  }
		/* 8224AF24h case   13:*/		return 0x8224AF28;
		  /* 8224AF28h */ case   14:  		/* mr R4, R31 */
		/* 8224AF28h case   14:*/		regs.R4 = regs.R31;
		/* 8224AF28h case   14:*/		return 0x8224AF2C;
		  /* 8224AF2Ch */ case   15:  		/* addi R3, R30, 8 */
		/* 8224AF2Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x8);
		/* 8224AF2Ch case   15:*/		return 0x8224AF30;
		  /* 8224AF30h */ case   16:  		/* bl 35200 */
		/* 8224AF30h case   16:*/		regs.LR = 0x8224AF34; return 0x822538B0;
		/* 8224AF30h case   16:*/		return 0x8224AF34;
		  /* 8224AF34h */ case   17:  		/* b 172 */
		/* 8224AF34h case   17:*/		return 0x8224AFE0;
		/* 8224AF34h case   17:*/		return 0x8224AF38;
	}
	return 0x8224AF38;
} // Block from 8224AEF0h-8224AF38h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8224AF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AF38);
		  /* 8224AF38h */ case    0:  		/* lwz R3, <#[R31 + 40]> */
		/* 8224AF38h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8224AF38h case    0:*/		return 0x8224AF3C;
		  /* 8224AF3Ch */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8224AF3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224AF3Ch case    1:*/		return 0x8224AF40;
		  /* 8224AF40h */ case    2:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224AF40h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224AF40h case    2:*/		return 0x8224AF44;
		  /* 8224AF44h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224AF44h case    3:*/		regs.CTR = regs.R11;
		/* 8224AF44h case    3:*/		return 0x8224AF48;
		  /* 8224AF48h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224AF48h case    4:*/		if ( 1 ) { regs.LR = 0x8224AF4C; return (uint32)regs.CTR; }
		/* 8224AF48h case    4:*/		return 0x8224AF4C;
		  /* 8224AF4Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224AF4Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224AF4Ch case    5:*/		return 0x8224AF50;
		  /* 8224AF50h */ case    6:  		/* bc 4, CR0_EQ, 92 */
		/* 8224AF50h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8224AFAC;  }
		/* 8224AF50h case    6:*/		return 0x8224AF54;
		  /* 8224AF54h */ case    7:  		/* lwz R11, <#[R31 + 40]> */
		/* 8224AF54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8224AF54h case    7:*/		return 0x8224AF58;
		  /* 8224AF58h */ case    8:  		/* lis R10, -32216 */
		/* 8224AF58h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8224AF58h case    8:*/		return 0x8224AF5C;
		  /* 8224AF5Ch */ case    9:  		/* addi R10, R10, 17992 */
		/* 8224AF5Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4648);
		/* 8224AF5Ch case    9:*/		return 0x8224AF60;
		  /* 8224AF60h */ case   10:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224AF60h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224AF60h case   10:*/		return 0x8224AF64;
		  /* 8224AF64h */ case   11:  		/* mulli R11, R11, 52 */
		/* 8224AF64h case   11:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 8224AF64h case   11:*/		return 0x8224AF68;
		  /* 8224AF68h */ case   12:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8224AF68h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224AF68h case   12:*/		return 0x8224AF6C;
		  /* 8224AF6Ch */ case   13:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 8224AF6Ch case   13:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8224AF6Ch case   13:*/		return 0x8224AF70;
		  /* 8224AF70h */ case   14:  		/* bc 12, CR0_EQ, 60 */
		/* 8224AF70h case   14:*/		if ( regs.CR[0].eq ) { return 0x8224AFAC;  }
		/* 8224AF70h case   14:*/		return 0x8224AF74;
		  /* 8224AF74h */ case   15:  		/* lwz R11, <#[R30 + 4]> */
		/* 8224AF74h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8224AF74h case   15:*/		return 0x8224AF78;
		  /* 8224AF78h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8224AF78h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224AF78h case   16:*/		return 0x8224AF7C;
		  /* 8224AF7Ch */ case   17:  		/* bc 12, CR6_EQ, 40 */
		/* 8224AF7Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x8224AFA4;  }
		/* 8224AF7Ch case   17:*/		return 0x8224AF80;
		  /* 8224AF80h */ case   18:  		/* lis R11, -32252 */
		/* 8224AF80h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224AF80h case   18:*/		return 0x8224AF84;
		  /* 8224AF84h */ case   19:  		/* lis R10, -32252 */
		/* 8224AF84h case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224AF84h case   19:*/		return 0x8224AF88;
		  /* 8224AF88h */ case   20:  		/* lis R9, -32253 */
		/* 8224AF88h case   20:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224AF88h case   20:*/		return 0x8224AF8C;
		  /* 8224AF8Ch */ case   21:  		/* addi R6, R11, 14208 */
		/* 8224AF8Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3780);
		/* 8224AF8Ch case   21:*/		return 0x8224AF90;
		  /* 8224AF90h */ case   22:  		/* addi R5, R10, 14440 */
		/* 8224AF90h case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x3868);
		/* 8224AF90h case   22:*/		return 0x8224AF94;
		  /* 8224AF94h */ case   23:  		/* addi R4, R9, 27460 */
		/* 8224AF94h case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8224AF94h case   23:*/		return 0x8224AF98;
		  /* 8224AF98h */ case   24:  		/* li R7, 314 */
		/* 8224AF98h case   24:*/		cpu::op::li<0>(regs,&regs.R7,0x13A);
		/* 8224AF98h case   24:*/		return 0x8224AF9C;
		  /* 8224AF9Ch */ case   25:  		/* li R3, 0 */
		/* 8224AF9Ch case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AF9Ch case   25:*/		return 0x8224AFA0;
		  /* 8224AFA0h */ case   26:  		/* bl -996248 */
		/* 8224AFA0h case   26:*/		regs.LR = 0x8224AFA4; return 0x82157C08;
		/* 8224AFA0h case   26:*/		return 0x8224AFA4;
	}
	return 0x8224AFA4;
} // Block from 8224AF38h-8224AFA4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8224AFA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AFA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AFA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AFA4);
		  /* 8224AFA4h */ case    0:  		/* stw R31, <#[R30 + 4]> */
		/* 8224AFA4h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 8224AFA4h case    0:*/		return 0x8224AFA8;
		  /* 8224AFA8h */ case    1:  		/* b 56 */
		/* 8224AFA8h case    1:*/		return 0x8224AFE0;
		/* 8224AFA8h case    1:*/		return 0x8224AFAC;
	}
	return 0x8224AFAC;
} // Block from 8224AFA4h-8224AFACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224AFACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AFAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AFAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AFAC);
		  /* 8224AFACh */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8224AFACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8224AFACh case    0:*/		return 0x8224AFB0;
		  /* 8224AFB0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8224AFB0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8224AFB0h case    1:*/		return 0x8224AFB4;
		  /* 8224AFB4h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 8224AFB4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224AFDC;  }
		/* 8224AFB4h case    2:*/		return 0x8224AFB8;
		  /* 8224AFB8h */ case    3:  		/* lis R11, -32252 */
		/* 8224AFB8h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224AFB8h case    3:*/		return 0x8224AFBC;
		  /* 8224AFBCh */ case    4:  		/* lis R10, -32252 */
		/* 8224AFBCh case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224AFBCh case    4:*/		return 0x8224AFC0;
		  /* 8224AFC0h */ case    5:  		/* lis R9, -32253 */
		/* 8224AFC0h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224AFC0h case    5:*/		return 0x8224AFC4;
		  /* 8224AFC4h */ case    6:  		/* addi R6, R11, 14208 */
		/* 8224AFC4h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3780);
		/* 8224AFC4h case    6:*/		return 0x8224AFC8;
		  /* 8224AFC8h */ case    7:  		/* addi R5, R10, 14424 */
		/* 8224AFC8h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x3858);
		/* 8224AFC8h case    7:*/		return 0x8224AFCC;
		  /* 8224AFCCh */ case    8:  		/* addi R4, R9, 27460 */
		/* 8224AFCCh case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8224AFCCh case    8:*/		return 0x8224AFD0;
		  /* 8224AFD0h */ case    9:  		/* li R7, 311 */
		/* 8224AFD0h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x137);
		/* 8224AFD0h case    9:*/		return 0x8224AFD4;
		  /* 8224AFD4h */ case   10:  		/* li R3, 0 */
		/* 8224AFD4h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224AFD4h case   10:*/		return 0x8224AFD8;
		  /* 8224AFD8h */ case   11:  		/* bl -996304 */
		/* 8224AFD8h case   11:*/		regs.LR = 0x8224AFDC; return 0x82157C08;
		/* 8224AFD8h case   11:*/		return 0x8224AFDC;
	}
	return 0x8224AFDC;
} // Block from 8224AFACh-8224AFDCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224AFDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AFDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AFDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AFDC);
		  /* 8224AFDCh */ case    0:  		/* stw R31, <#[R30]> */
		/* 8224AFDCh case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 8224AFDCh case    0:*/		return 0x8224AFE0;
	}
	return 0x8224AFE0;
} // Block from 8224AFDCh-8224AFE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224AFE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AFE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AFE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AFE0);
		  /* 8224AFE0h */ case    0:  		/* addi R1, R1, 112 */
		/* 8224AFE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224AFE0h case    0:*/		return 0x8224AFE4;
		  /* 8224AFE4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224AFE4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224AFE4h case    1:*/		return 0x8224AFE8;
		  /* 8224AFE8h */ case    2:  		/* mtspr LR, R12 */
		/* 8224AFE8h case    2:*/		regs.LR = regs.R12;
		/* 8224AFE8h case    2:*/		return 0x8224AFEC;
		  /* 8224AFECh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8224AFECh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224AFECh case    3:*/		return 0x8224AFF0;
		  /* 8224AFF0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8224AFF0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224AFF0h case    4:*/		return 0x8224AFF4;
		  /* 8224AFF4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8224AFF4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224AFF4h case    5:*/		return 0x8224AFF8;
	}
	return 0x8224AFF8;
} // Block from 8224AFE0h-8224AFF8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224AFF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224AFF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224AFF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224AFF8);
		  /* 8224AFF8h */ case    0:  		/* mfspr R12, LR */
		/* 8224AFF8h case    0:*/		regs.R12 = regs.LR;
		/* 8224AFF8h case    0:*/		return 0x8224AFFC;
		  /* 8224AFFCh */ case    1:  		/* bl -1809876 */
		/* 8224AFFCh case    1:*/		regs.LR = 0x8224B000; return 0x82091228;
		/* 8224AFFCh case    1:*/		return 0x8224B000;
		  /* 8224B000h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 8224B000h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 8224B000h case    2:*/		return 0x8224B004;
		  /* 8224B004h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224B004h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224B004h case    3:*/		return 0x8224B008;
		  /* 8224B008h */ case    4:  		/* mr R23, R3 */
		/* 8224B008h case    4:*/		regs.R23 = regs.R3;
		/* 8224B008h case    4:*/		return 0x8224B00C;
		  /* 8224B00Ch */ case    5:  		/* lwz R18, <#[R11 + 136]> */
		/* 8224B00Ch case    5:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R11 + 0x00000088) );
		/* 8224B00Ch case    5:*/		return 0x8224B010;
		  /* 8224B010h */ case    6:  		/* lwz R11, <#[R18 + 8]> */
		/* 8224B010h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000008) );
		/* 8224B010h case    6:*/		return 0x8224B014;
		  /* 8224B014h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 8224B014h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B014h case    7:*/		return 0x8224B018;
		  /* 8224B018h */ case    8:  		/* bc 12, CR6_EQ, 1000 */
		/* 8224B018h case    8:*/		if ( regs.CR[6].eq ) { return 0x8224B400;  }
		/* 8224B018h case    8:*/		return 0x8224B01C;
		  /* 8224B01Ch */ case    9:  		/* lis R5, -32252 */
		/* 8224B01Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8204);
		/* 8224B01Ch case    9:*/		return 0x8224B020;
		  /* 8224B020h */ case   10:  		/* lis R6, -32252 */
		/* 8224B020h case   10:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8204);
		/* 8224B020h case   10:*/		return 0x8224B024;
		  /* 8224B024h */ case   11:  		/* lis R7, -32252 */
		/* 8224B024h case   11:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8204);
		/* 8224B024h case   11:*/		return 0x8224B028;
		  /* 8224B028h */ case   12:  		/* lis R8, -32253 */
		/* 8224B028h case   12:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8203);
		/* 8224B028h case   12:*/		return 0x8224B02C;
		  /* 8224B02Ch */ case   13:  		/* lis R9, -32252 */
		/* 8224B02Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8224B02Ch case   13:*/		return 0x8224B030;
		  /* 8224B030h */ case   14:  		/* lis R10, -32252 */
		/* 8224B030h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224B030h case   14:*/		return 0x8224B034;
		  /* 8224B034h */ case   15:  		/* lis R11, -32251 */
		/* 8224B034h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8224B034h case   15:*/		return 0x8224B038;
		  /* 8224B038h */ case   16:  		/* li R21, 0 */
		/* 8224B038h case   16:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8224B038h case   16:*/		return 0x8224B03C;
		  /* 8224B03Ch */ case   17:  		/* addi R17, R5, 14620 */
		/* 8224B03Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R5,0x391C);
		/* 8224B03Ch case   17:*/		return 0x8224B040;
		  /* 8224B040h */ case   18:  		/* addi R20, R6, 14556 */
		/* 8224B040h case   18:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R6,0x38DC);
		/* 8224B040h case   18:*/		return 0x8224B044;
		  /* 8224B044h */ case   19:  		/* addi R19, R7, 14544 */
		/* 8224B044h case   19:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R7,0x38D0);
		/* 8224B044h case   19:*/		return 0x8224B048;
		  /* 8224B048h */ case   20:  		/* addi R25, R8, 27460 */
		/* 8224B048h case   20:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R8,0x6B44);
		/* 8224B048h case   20:*/		return 0x8224B04C;
		  /* 8224B04Ch */ case   21:  		/* addi R16, R9, 14516 */
		/* 8224B04Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R9,0x38B4);
		/* 8224B04Ch case   21:*/		return 0x8224B050;
		  /* 8224B050h */ case   22:  		/* addi R24, R10, 14208 */
		/* 8224B050h case   22:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R10,0x3780);
		/* 8224B050h case   22:*/		return 0x8224B054;
		  /* 8224B054h */ case   23:  		/* addi R22, R11, -19064 */
		/* 8224B054h case   23:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R11,0xFFFFB588);
		/* 8224B054h case   23:*/		return 0x8224B058;
		  /* 8224B058h */ case   24:  		/* lwz R31, <#[R18 + 28]> */
		/* 8224B058h case   24:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R18 + 0x0000001C) );
		/* 8224B058h case   24:*/		return 0x8224B05C;
		  /* 8224B05Ch */ case   25:  		/* b 904 */
		/* 8224B05Ch case   25:*/		return 0x8224B3E4;
		/* 8224B05Ch case   25:*/		return 0x8224B060;
		  /* 8224B060h */ case   26:  		/* lwz R11, <#[R31 + 228]> */
		/* 8224B060h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8224B060h case   26:*/		return 0x8224B064;
		  /* 8224B064h */ case   27:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8224B064h case   27:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8224B064h case   27:*/		return 0x8224B068;
		  /* 8224B068h */ case   28:  		/* bc 12, CR0_EQ, 888 */
		/* 8224B068h case   28:*/		if ( regs.CR[0].eq ) { return 0x8224B3E0;  }
		/* 8224B068h case   28:*/		return 0x8224B06C;
		  /* 8224B06Ch */ case   29:  		/* addi R4, R1, 80 */
		/* 8224B06Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8224B06Ch case   29:*/		return 0x8224B070;
		  /* 8224B070h */ case   30:  		/* mr R3, R31 */
		/* 8224B070h case   30:*/		regs.R3 = regs.R31;
		/* 8224B070h case   30:*/		return 0x8224B074;
		  /* 8224B074h */ case   31:  		/* bl 112052 */
		/* 8224B074h case   31:*/		regs.LR = 0x8224B078; return 0x82266628;
		/* 8224B074h case   31:*/		return 0x8224B078;
		  /* 8224B078h */ case   32:  		/* cmpwi CR6, R3, -1 */
		/* 8224B078h case   32:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8224B078h case   32:*/		return 0x8224B07C;
		  /* 8224B07Ch */ case   33:  		/* bc 4, CR6_EQ, 868 */
		/* 8224B07Ch case   33:*/		if ( !regs.CR[6].eq ) { return 0x8224B3E0;  }
		/* 8224B07Ch case   33:*/		return 0x8224B080;
		  /* 8224B080h */ case   34:  		/* lwz R11, <#[R23 + 140]> */
		/* 8224B080h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000008C) );
		/* 8224B080h case   34:*/		return 0x8224B084;
		  /* 8224B084h */ case   35:  		/* li R3, 49 */
		/* 8224B084h case   35:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8224B084h case   35:*/		return 0x8224B088;
		  /* 8224B088h */ case   36:  		/* lwz R4, <#[R23]> */
		/* 8224B088h case   36:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000000) );
		/* 8224B088h case   36:*/		return 0x8224B08C;
		  /* 8224B08Ch */ case   37:  		/* mr R28, R21 */
		/* 8224B08Ch case   37:*/		regs.R28 = regs.R21;
		/* 8224B08Ch case   37:*/		return 0x8224B090;
		  /* 8224B090h */ case   38:  		/* addi R11, R11, 1 */
		/* 8224B090h case   38:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224B090h case   38:*/		return 0x8224B094;
		  /* 8224B094h */ case   39:  		/* stw R11, <#[R23 + 140]> */
		/* 8224B094h case   39:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x0000008C) );
		/* 8224B094h case   39:*/		return 0x8224B098;
		  /* 8224B098h */ case   40:  		/* bl 44696 */
		/* 8224B098h case   40:*/		regs.LR = 0x8224B09C; return 0x82255F30;
		/* 8224B098h case   40:*/		return 0x8224B09C;
		  /* 8224B09Ch */ case   41:  		/* mr R30, R3 */
		/* 8224B09Ch case   41:*/		regs.R30 = regs.R3;
		/* 8224B09Ch case   41:*/		return 0x8224B0A0;
		  /* 8224B0A0h */ case   42:  		/* mr R3, R31 */
		/* 8224B0A0h case   42:*/		regs.R3 = regs.R31;
		/* 8224B0A0h case   42:*/		return 0x8224B0A4;
		  /* 8224B0A4h */ case   43:  		/* li R27, 1 */
		/* 8224B0A4h case   43:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8224B0A4h case   43:*/		return 0x8224B0A8;
		  /* 8224B0A8h */ case   44:  		/* lwz R11, <#[R30 + 224]> */
		/* 8224B0A8h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E0) );
		/* 8224B0A8h case   44:*/		return 0x8224B0AC;
		  /* 8224B0ACh */ case   45:  		/* stw R21, <#[R30 + 80]> */
		/* 8224B0ACh case   45:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R30 + 0x00000050) );
		/* 8224B0ACh case   45:*/		return 0x8224B0B0;
		  /* 8224B0B0h */ case   46:  		/* stw R11, <#[R30 + 56]> */
		/* 8224B0B0h case   46:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 8224B0B0h case   46:*/		return 0x8224B0B4;
		  /* 8224B0B4h */ case   47:  		/* lwz R11, <#[R31]> */
		/* 8224B0B4h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224B0B4h case   47:*/		return 0x8224B0B8;
		  /* 8224B0B8h */ case   48:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224B0B8h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224B0B8h case   48:*/		return 0x8224B0BC;
		  /* 8224B0BCh */ case   49:  		/* mtspr CTR, R11 */
		/* 8224B0BCh case   49:*/		regs.CTR = regs.R11;
		/* 8224B0BCh case   49:*/		return 0x8224B0C0;
		  /* 8224B0C0h */ case   50:  		/* bcctrl 20, CR0_LT */
		/* 8224B0C0h case   50:*/		if ( 1 ) { regs.LR = 0x8224B0C4; return (uint32)regs.CTR; }
		/* 8224B0C0h case   50:*/		return 0x8224B0C4;
		  /* 8224B0C4h */ case   51:  		/* cmpwi CR6, R3, 1 */
		/* 8224B0C4h case   51:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8224B0C4h case   51:*/		return 0x8224B0C8;
		  /* 8224B0C8h */ case   52:  		/* bc 12, CR6_LT, 236 */
		/* 8224B0C8h case   52:*/		if ( regs.CR[6].lt ) { return 0x8224B1B4;  }
		/* 8224B0C8h case   52:*/		return 0x8224B0CC;
		  /* 8224B0CCh */ case   53:  		/* addi R26, R31, 132 */
		/* 8224B0CCh case   53:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R31,0x84);
		/* 8224B0CCh case   53:*/		return 0x8224B0D0;
		  /* 8224B0D0h */ case   54:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 8224B0D0h case   54:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 8224B0D0h case   54:*/		return 0x8224B0D4;
		  /* 8224B0D4h */ case   55:  		/* bc 4, CR0_EQ, 224 */
		/* 8224B0D4h case   55:*/		if ( !regs.CR[0].eq ) { return 0x8224B1B4;  }
		/* 8224B0D4h case   55:*/		return 0x8224B0D8;
		  /* 8224B0D8h */ case   56:  		/* lwz R29, <#[R26 + 104]> */
		/* 8224B0D8h case   56:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R26 + 0x00000068) );
		/* 8224B0D8h case   56:*/		return 0x8224B0DC;
		  /* 8224B0DCh */ case   57:  		/* addi R11, R22, 6 */
		/* 8224B0DCh case   57:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R22,0x6);
		/* 8224B0DCh case   57:*/		return 0x8224B0E0;
		  /* 8224B0E0h */ case   58:  		/* lwz R10, <#[R29 + 80]> */
		/* 8224B0E0h case   58:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000050) );
		/* 8224B0E0h case   58:*/		return 0x8224B0E4;
		  /* 8224B0E4h */ case   59:  		/* mulli R10, R10, 12 */
		/* 8224B0E4h case   59:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 8224B0E4h case   59:*/		return 0x8224B0E8;
		  /* 8224B0E8h */ case   60:  		/* lbzx R11, <#[R10 + R11]> */
		/* 8224B0E8h case   60:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224B0E8h case   60:*/		return 0x8224B0EC;
		  /* 8224B0ECh */ case   61:  		/* cmplwi CR0, R11, 0 */
		/* 8224B0ECh case   61:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224B0ECh case   61:*/		return 0x8224B0F0;
		  /* 8224B0F0h */ case   62:  		/* bc 12, CR0_EQ, 160 */
		/* 8224B0F0h case   62:*/		if ( regs.CR[0].eq ) { return 0x8224B190;  }
		/* 8224B0F0h case   62:*/		return 0x8224B0F4;
		  /* 8224B0F4h */ case   63:  		/* mr R5, R30 */
		/* 8224B0F4h case   63:*/		regs.R5 = regs.R30;
		/* 8224B0F4h case   63:*/		return 0x8224B0F8;
		  /* 8224B0F8h */ case   64:  		/* mr R4, R27 */
		/* 8224B0F8h case   64:*/		regs.R4 = regs.R27;
		/* 8224B0F8h case   64:*/		return 0x8224B0FC;
		  /* 8224B0FCh */ case   65:  		/* mr R3, R31 */
		/* 8224B0FCh case   65:*/		regs.R3 = regs.R31;
		/* 8224B0FCh case   65:*/		return 0x8224B100;
		  /* 8224B100h */ case   66:  		/* bl -86448 */
		/* 8224B100h case   66:*/		regs.LR = 0x8224B104; return 0x82235F50;
		/* 8224B100h case   66:*/		return 0x8224B104;
		  /* 8224B104h */ case   67:  		/* addi R4, R1, 80 */
		/* 8224B104h case   67:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8224B104h case   67:*/		return 0x8224B108;
		  /* 8224B108h */ case   68:  		/* mr R3, R31 */
		/* 8224B108h case   68:*/		regs.R3 = regs.R31;
		/* 8224B108h case   68:*/		return 0x8224B10C;
		  /* 8224B10Ch */ case   69:  		/* bl 111900 */
		/* 8224B10Ch case   69:*/		regs.LR = 0x8224B110; return 0x82266628;
		/* 8224B10Ch case   69:*/		return 0x8224B110;
		  /* 8224B110h */ case   70:  		/* cmpwi CR6, R3, -1 */
		/* 8224B110h case   70:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8224B110h case   70:*/		return 0x8224B114;
		  /* 8224B114h */ case   71:  		/* mr R5, R29 */
		/* 8224B114h case   71:*/		regs.R5 = regs.R29;
		/* 8224B114h case   71:*/		return 0x8224B118;
		  /* 8224B118h */ case   72:  		/* bc 12, CR6_EQ, 108 */
		/* 8224B118h case   72:*/		if ( regs.CR[6].eq ) { return 0x8224B184;  }
		/* 8224B118h case   72:*/		return 0x8224B11C;
		  /* 8224B11Ch */ case   73:  		/* li R4, 1 */
		/* 8224B11Ch case   73:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224B11Ch case   73:*/		return 0x8224B120;
		  /* 8224B120h */ case   74:  		/* mr R3, R30 */
		/* 8224B120h case   74:*/		regs.R3 = regs.R30;
		/* 8224B120h case   74:*/		return 0x8224B124;
		  /* 8224B124h */ case   75:  		/* bl -86484 */
		/* 8224B124h case   75:*/		regs.LR = 0x8224B128; return 0x82235F50;
		/* 8224B124h case   75:*/		return 0x8224B128;
		  /* 8224B128h */ case   76:  		/* lwz R10, <#[R26]> */
		/* 8224B128h case   76:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 8224B128h case   76:*/		return 0x8224B12C;
		  /* 8224B12Ch */ case   77:  		/* stw R10, <#[R1 + 84]> */
		/* 8224B12Ch case   77:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8224B12Ch case   77:*/		return 0x8224B130;
		  /* 8224B130h */ case   78:  		/* lbz R11, <#[R1 + 85]> */
		/* 8224B130h case   78:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000055) );
		/* 8224B130h case   78:*/		return 0x8224B134;
		  /* 8224B134h */ case   79:  		/* lbz R5, <#[R1 + 84]> */
		/* 8224B134h case   79:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 8224B134h case   79:*/		return 0x8224B138;
		  /* 8224B138h */ case   80:  		/* cmplw CR6, R5, R11 */
		/* 8224B138h case   80:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 8224B138h case   80:*/		return 0x8224B13C;
		  /* 8224B13Ch */ case   81:  		/* bc 4, CR6_EQ, 48 */
		/* 8224B13Ch case   81:*/		if ( !regs.CR[6].eq ) { return 0x8224B16C;  }
		/* 8224B13Ch case   81:*/		return 0x8224B140;
		  /* 8224B140h */ case   82:  		/* lbz R9, <#[R1 + 86]> */
		/* 8224B140h case   82:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000056) );
		/* 8224B140h case   82:*/		return 0x8224B144;
		  /* 8224B144h */ case   83:  		/* cmplw CR6, R11, R9 */
		/* 8224B144h case   83:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8224B144h case   83:*/		return 0x8224B148;
		  /* 8224B148h */ case   84:  		/* bc 4, CR6_EQ, 36 */
		/* 8224B148h case   84:*/		if ( !regs.CR[6].eq ) { return 0x8224B16C;  }
		/* 8224B148h case   84:*/		return 0x8224B14C;
		  /* 8224B14Ch */ case   85:  		/* lbz R11, <#[R1 + 87]> */
		/* 8224B14Ch case   85:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000057) );
		/* 8224B14Ch case   85:*/		return 0x8224B150;
		  /* 8224B150h */ case   86:  		/* cmplw CR6, R9, R11 */
		/* 8224B150h case   86:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8224B150h case   86:*/		return 0x8224B154;
		  /* 8224B154h */ case   87:  		/* bc 4, CR6_EQ, 24 */
		/* 8224B154h case   87:*/		if ( !regs.CR[6].eq ) { return 0x8224B16C;  }
		/* 8224B154h case   87:*/		return 0x8224B158;
		  /* 8224B158h */ case   88:  		/* stw R10, <#[R30 + 132]> */
		/* 8224B158h case   88:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000084) );
		/* 8224B158h case   88:*/		return 0x8224B15C;
		  /* 8224B15Ch */ case   89:  		/* li R6, 0 */
		/* 8224B15Ch case   89:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224B15Ch case   89:*/		return 0x8224B160;
		  /* 8224B160h */ case   90:  		/* mr R4, R5 */
		/* 8224B160h case   90:*/		regs.R4 = regs.R5;
		/* 8224B160h case   90:*/		return 0x8224B164;
		  /* 8224B164h */ case   91:  		/* mr R3, R30 */
		/* 8224B164h case   91:*/		regs.R3 = regs.R30;
		/* 8224B164h case   91:*/		return 0x8224B168;
		  /* 8224B168h */ case   92:  		/* bl 47776 */
		/* 8224B168h case   92:*/		regs.LR = 0x8224B16C; return 0x82256C08;
		/* 8224B168h case   92:*/		return 0x8224B16C;
	}
	return 0x8224B16C;
} // Block from 8224AFF8h-8224B16Ch (93 instructions)

//////////////////////////////////////////////////////
// Block at 8224B16Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B16C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B16C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B16C);
		  /* 8224B16Ch */ case    0:  		/* mr R5, R30 */
		/* 8224B16Ch case    0:*/		regs.R5 = regs.R30;
		/* 8224B16Ch case    0:*/		return 0x8224B170;
		  /* 8224B170h */ case    1:  		/* mr R4, R31 */
		/* 8224B170h case    1:*/		regs.R4 = regs.R31;
		/* 8224B170h case    1:*/		return 0x8224B174;
		  /* 8224B174h */ case    2:  		/* mr R3, R18 */
		/* 8224B174h case    2:*/		regs.R3 = regs.R18;
		/* 8224B174h case    2:*/		return 0x8224B178;
		  /* 8224B178h */ case    3:  		/* bl 57000 */
		/* 8224B178h case    3:*/		regs.LR = 0x8224B17C; return 0x82259020;
		/* 8224B178h case    3:*/		return 0x8224B17C;
		  /* 8224B17Ch */ case    4:  		/* li R28, 1 */
		/* 8224B17Ch case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 8224B17Ch case    4:*/		return 0x8224B180;
		  /* 8224B180h */ case    5:  		/* b 16 */
		/* 8224B180h case    5:*/		return 0x8224B190;
		/* 8224B180h case    5:*/		return 0x8224B184;
	}
	return 0x8224B184;
} // Block from 8224B16Ch-8224B184h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224B184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B184);
		  /* 8224B184h */ case    0:  		/* mr R4, R27 */
		/* 8224B184h case    0:*/		regs.R4 = regs.R27;
		/* 8224B184h case    0:*/		return 0x8224B188;
		  /* 8224B188h */ case    1:  		/* mr R3, R31 */
		/* 8224B188h case    1:*/		regs.R3 = regs.R31;
		/* 8224B188h case    1:*/		return 0x8224B18C;
		  /* 8224B18Ch */ case    2:  		/* bl -86588 */
		/* 8224B18Ch case    2:*/		regs.LR = 0x8224B190; return 0x82235F50;
		/* 8224B18Ch case    2:*/		return 0x8224B190;
	}
	return 0x8224B190;
} // Block from 8224B184h-8224B190h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224B190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B190);
		  /* 8224B190h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8224B190h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224B190h case    0:*/		return 0x8224B194;
		  /* 8224B194h */ case    1:  		/* mr R3, R31 */
		/* 8224B194h case    1:*/		regs.R3 = regs.R31;
		/* 8224B194h case    1:*/		return 0x8224B198;
		  /* 8224B198h */ case    2:  		/* addi R27, R27, 1 */
		/* 8224B198h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8224B198h case    2:*/		return 0x8224B19C;
		  /* 8224B19Ch */ case    3:  		/* addi R26, R26, 4 */
		/* 8224B19Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8224B19Ch case    3:*/		return 0x8224B1A0;
		  /* 8224B1A0h */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224B1A0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224B1A0h case    4:*/		return 0x8224B1A4;
		  /* 8224B1A4h */ case    5:  		/* mtspr CTR, R11 */
		/* 8224B1A4h case    5:*/		regs.CTR = regs.R11;
		/* 8224B1A4h case    5:*/		return 0x8224B1A8;
		  /* 8224B1A8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8224B1A8h case    6:*/		if ( 1 ) { regs.LR = 0x8224B1AC; return (uint32)regs.CTR; }
		/* 8224B1A8h case    6:*/		return 0x8224B1AC;
		  /* 8224B1ACh */ case    7:  		/* cmpw CR6, R27, R3 */
		/* 8224B1ACh case    7:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R3);
		/* 8224B1ACh case    7:*/		return 0x8224B1B0;
		  /* 8224B1B0h */ case    8:  		/* bc 4, CR6_GT, -224 */
		/* 8224B1B0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8224B0D0;  }
		/* 8224B1B0h case    8:*/		return 0x8224B1B4;
	}
	return 0x8224B1B4;
} // Block from 8224B190h-8224B1B4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224B1B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B1B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B1B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B1B4);
		  /* 8224B1B4h */ case    0:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 8224B1B4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 8224B1B4h case    0:*/		return 0x8224B1B8;
		  /* 8224B1B8h */ case    1:  		/* lwz R11, <#[R23 + 144]> */
		/* 8224B1B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000090) );
		/* 8224B1B8h case    1:*/		return 0x8224B1BC;
		  /* 8224B1BCh */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8224B1BCh case    2:*/		if ( regs.CR[0].eq ) { return 0x8224B1CC;  }
		/* 8224B1BCh case    2:*/		return 0x8224B1C0;
		  /* 8224B1C0h */ case    3:  		/* addi R11, R11, 1 */
		/* 8224B1C0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8224B1C0h case    3:*/		return 0x8224B1C4;
		  /* 8224B1C4h */ case    4:  		/* stw R11, <#[R23 + 144]> */
		/* 8224B1C4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000090) );
		/* 8224B1C4h case    4:*/		return 0x8224B1C8;
		  /* 8224B1C8h */ case    5:  		/* b 536 */
		/* 8224B1C8h case    5:*/		return 0x8224B3E0;
		/* 8224B1C8h case    5:*/		return 0x8224B1CC;
	}
	return 0x8224B1CC;
} // Block from 8224B1B4h-8224B1CCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224B1CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B1CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B1CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B1CC);
		  /* 8224B1CCh */ case    0:  		/* addi R11, R11, 2 */
		/* 8224B1CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8224B1CCh case    0:*/		return 0x8224B1D0;
		  /* 8224B1D0h */ case    1:  		/* mr R3, R31 */
		/* 8224B1D0h case    1:*/		regs.R3 = regs.R31;
		/* 8224B1D0h case    1:*/		return 0x8224B1D4;
		  /* 8224B1D4h */ case    2:  		/* stw R11, <#[R23 + 144]> */
		/* 8224B1D4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000090) );
		/* 8224B1D4h case    2:*/		return 0x8224B1D8;
		  /* 8224B1D8h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 8224B1D8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8224B1D8h case    3:*/		return 0x8224B1DC;
		  /* 8224B1DCh */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 8224B1DCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8224B1DCh case    4:*/		return 0x8224B1E0;
		  /* 8224B1E0h */ case    5:  		/* mtspr CTR, R11 */
		/* 8224B1E0h case    5:*/		regs.CTR = regs.R11;
		/* 8224B1E0h case    5:*/		return 0x8224B1E4;
		  /* 8224B1E4h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8224B1E4h case    6:*/		if ( 1 ) { regs.LR = 0x8224B1E8; return (uint32)regs.CTR; }
		/* 8224B1E4h case    6:*/		return 0x8224B1E8;
		  /* 8224B1E8h */ case    7:  		/* cmpwi CR6, R3, 2 */
		/* 8224B1E8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 8224B1E8h case    7:*/		return 0x8224B1EC;
		  /* 8224B1ECh */ case    8:  		/* bc 12, CR6_GT, 28 */
		/* 8224B1ECh case    8:*/		if ( regs.CR[6].gt ) { return 0x8224B208;  }
		/* 8224B1ECh case    8:*/		return 0x8224B1F0;
		  /* 8224B1F0h */ case    9:  		/* mr R6, R24 */
		/* 8224B1F0h case    9:*/		regs.R6 = regs.R24;
		/* 8224B1F0h case    9:*/		return 0x8224B1F4;
		  /* 8224B1F4h */ case   10:  		/* mr R5, R16 */
		/* 8224B1F4h case   10:*/		regs.R5 = regs.R16;
		/* 8224B1F4h case   10:*/		return 0x8224B1F8;
		  /* 8224B1F8h */ case   11:  		/* mr R4, R25 */
		/* 8224B1F8h case   11:*/		regs.R4 = regs.R25;
		/* 8224B1F8h case   11:*/		return 0x8224B1FC;
		  /* 8224B1FCh */ case   12:  		/* li R7, 614 */
		/* 8224B1FCh case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x266);
		/* 8224B1FCh case   12:*/		return 0x8224B200;
		  /* 8224B200h */ case   13:  		/* li R3, 0 */
		/* 8224B200h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B200h case   13:*/		return 0x8224B204;
		  /* 8224B204h */ case   14:  		/* bl -996860 */
		/* 8224B204h case   14:*/		regs.LR = 0x8224B208; return 0x82157C08;
		/* 8224B204h case   14:*/		return 0x8224B208;
	}
	return 0x8224B208;
} // Block from 8224B1CCh-8224B208h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224B208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B208);
		  /* 8224B208h */ case    0:  		/* lwz R29, <#[R31 + 236]> */
		/* 8224B208h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x000000EC) );
		/* 8224B208h case    0:*/		return 0x8224B20C;
		  /* 8224B20Ch */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 8224B20Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8224B20Ch case    1:*/		return 0x8224B210;
		  /* 8224B210h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 8224B210h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224B22C;  }
		/* 8224B210h case    2:*/		return 0x8224B214;
		  /* 8224B214h */ case    3:  		/* mr R6, R24 */
		/* 8224B214h case    3:*/		regs.R6 = regs.R24;
		/* 8224B214h case    3:*/		return 0x8224B218;
		  /* 8224B218h */ case    4:  		/* mr R5, R19 */
		/* 8224B218h case    4:*/		regs.R5 = regs.R19;
		/* 8224B218h case    4:*/		return 0x8224B21C;
		  /* 8224B21Ch */ case    5:  		/* mr R4, R25 */
		/* 8224B21Ch case    5:*/		regs.R4 = regs.R25;
		/* 8224B21Ch case    5:*/		return 0x8224B220;
		  /* 8224B220h */ case    6:  		/* li R7, 617 */
		/* 8224B220h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x269);
		/* 8224B220h case    6:*/		return 0x8224B224;
		  /* 8224B224h */ case    7:  		/* li R3, 0 */
		/* 8224B224h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B224h case    7:*/		return 0x8224B228;
		  /* 8224B228h */ case    8:  		/* bl -996896 */
		/* 8224B228h case    8:*/		regs.LR = 0x8224B22C; return 0x82157C08;
		/* 8224B228h case    8:*/		return 0x8224B22C;
	}
	return 0x8224B22C;
} // Block from 8224B208h-8224B22Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224B22Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B22C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B22C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B22C);
		  /* 8224B22Ch */ case    0:  		/* lwz R11, <#[R29 + 80]> */
		/* 8224B22Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000050) );
		/* 8224B22Ch case    0:*/		return 0x8224B230;
		  /* 8224B230h */ case    1:  		/* addi R10, R22, 6 */
		/* 8224B230h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R22,0x6);
		/* 8224B230h case    1:*/		return 0x8224B234;
		  /* 8224B234h */ case    2:  		/* mulli R11, R11, 12 */
		/* 8224B234h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8224B234h case    2:*/		return 0x8224B238;
		  /* 8224B238h */ case    3:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8224B238h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224B238h case    3:*/		return 0x8224B23C;
		  /* 8224B23Ch */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 8224B23Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224B23Ch case    4:*/		return 0x8224B240;
		  /* 8224B240h */ case    5:  		/* bc 4, CR0_EQ, 28 */
		/* 8224B240h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8224B25C;  }
		/* 8224B240h case    5:*/		return 0x8224B244;
		  /* 8224B244h */ case    6:  		/* mr R6, R24 */
		/* 8224B244h case    6:*/		regs.R6 = regs.R24;
		/* 8224B244h case    6:*/		return 0x8224B248;
		  /* 8224B248h */ case    7:  		/* mr R5, R20 */
		/* 8224B248h case    7:*/		regs.R5 = regs.R20;
		/* 8224B248h case    7:*/		return 0x8224B24C;
		  /* 8224B24Ch */ case    8:  		/* mr R4, R25 */
		/* 8224B24Ch case    8:*/		regs.R4 = regs.R25;
		/* 8224B24Ch case    8:*/		return 0x8224B250;
		  /* 8224B250h */ case    9:  		/* li R7, 618 */
		/* 8224B250h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x26A);
		/* 8224B250h case    9:*/		return 0x8224B254;
		  /* 8224B254h */ case   10:  		/* li R3, 0 */
		/* 8224B254h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B254h case   10:*/		return 0x8224B258;
		  /* 8224B258h */ case   11:  		/* bl -996944 */
		/* 8224B258h case   11:*/		regs.LR = 0x8224B25C; return 0x82157C08;
		/* 8224B258h case   11:*/		return 0x8224B25C;
	}
	return 0x8224B25C;
} // Block from 8224B22Ch-8224B25Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8224B25Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B25C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B25C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B25C);
		  /* 8224B25Ch */ case    0:  		/* mr R5, R30 */
		/* 8224B25Ch case    0:*/		regs.R5 = regs.R30;
		/* 8224B25Ch case    0:*/		return 0x8224B260;
		  /* 8224B260h */ case    1:  		/* li R4, 1 */
		/* 8224B260h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224B260h case    1:*/		return 0x8224B264;
		  /* 8224B264h */ case    2:  		/* mr R3, R31 */
		/* 8224B264h case    2:*/		regs.R3 = regs.R31;
		/* 8224B264h case    2:*/		return 0x8224B268;
		  /* 8224B268h */ case    3:  		/* bl -86808 */
		/* 8224B268h case    3:*/		regs.LR = 0x8224B26C; return 0x82235F50;
		/* 8224B268h case    3:*/		return 0x8224B26C;
		  /* 8224B26Ch */ case    4:  		/* mr R5, R29 */
		/* 8224B26Ch case    4:*/		regs.R5 = regs.R29;
		/* 8224B26Ch case    4:*/		return 0x8224B270;
		  /* 8224B270h */ case    5:  		/* li R4, 1 */
		/* 8224B270h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224B270h case    5:*/		return 0x8224B274;
		  /* 8224B274h */ case    6:  		/* mr R3, R30 */
		/* 8224B274h case    6:*/		regs.R3 = regs.R30;
		/* 8224B274h case    6:*/		return 0x8224B278;
		  /* 8224B278h */ case    7:  		/* bl -86824 */
		/* 8224B278h case    7:*/		regs.LR = 0x8224B27C; return 0x82235F50;
		/* 8224B278h case    7:*/		return 0x8224B27C;
		  /* 8224B27Ch */ case    8:  		/* lwz R10, <#[R31 + 132]> */
		/* 8224B27Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 8224B27Ch case    8:*/		return 0x8224B280;
		  /* 8224B280h */ case    9:  		/* stw R10, <#[R1 + 84]> */
		/* 8224B280h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8224B280h case    9:*/		return 0x8224B284;
		  /* 8224B284h */ case   10:  		/* lbz R11, <#[R1 + 85]> */
		/* 8224B284h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000055) );
		/* 8224B284h case   10:*/		return 0x8224B288;
		  /* 8224B288h */ case   11:  		/* lbz R5, <#[R1 + 84]> */
		/* 8224B288h case   11:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 8224B288h case   11:*/		return 0x8224B28C;
		  /* 8224B28Ch */ case   12:  		/* cmplw CR6, R5, R11 */
		/* 8224B28Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 8224B28Ch case   12:*/		return 0x8224B290;
		  /* 8224B290h */ case   13:  		/* bc 4, CR6_EQ, 48 */
		/* 8224B290h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8224B2C0;  }
		/* 8224B290h case   13:*/		return 0x8224B294;
		  /* 8224B294h */ case   14:  		/* lbz R9, <#[R1 + 86]> */
		/* 8224B294h case   14:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000056) );
		/* 8224B294h case   14:*/		return 0x8224B298;
		  /* 8224B298h */ case   15:  		/* cmplw CR6, R11, R9 */
		/* 8224B298h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8224B298h case   15:*/		return 0x8224B29C;
		  /* 8224B29Ch */ case   16:  		/* bc 4, CR6_EQ, 36 */
		/* 8224B29Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x8224B2C0;  }
		/* 8224B29Ch case   16:*/		return 0x8224B2A0;
		  /* 8224B2A0h */ case   17:  		/* lbz R11, <#[R1 + 87]> */
		/* 8224B2A0h case   17:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000057) );
		/* 8224B2A0h case   17:*/		return 0x8224B2A4;
		  /* 8224B2A4h */ case   18:  		/* cmplw CR6, R9, R11 */
		/* 8224B2A4h case   18:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8224B2A4h case   18:*/		return 0x8224B2A8;
		  /* 8224B2A8h */ case   19:  		/* bc 4, CR6_EQ, 24 */
		/* 8224B2A8h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8224B2C0;  }
		/* 8224B2A8h case   19:*/		return 0x8224B2AC;
		  /* 8224B2ACh */ case   20:  		/* stw R10, <#[R30 + 132]> */
		/* 8224B2ACh case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000084) );
		/* 8224B2ACh case   20:*/		return 0x8224B2B0;
	}
	return 0x8224B2B0;
} // Block from 8224B25Ch-8224B2B0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224B2B0h
// Function '?BuildSSA@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B2B0);
		  /* 8224B2B0h */ case    0:  		/* li R6, 0 */
		/* 8224B2B0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224B2B0h case    0:*/		return 0x8224B2B4;
		  /* 8224B2B4h */ case    1:  		/* mr R4, R5 */
		/* 8224B2B4h case    1:*/		regs.R4 = regs.R5;
		/* 8224B2B4h case    1:*/		return 0x8224B2B8;
		  /* 8224B2B8h */ case    2:  		/* mr R3, R30 */
		/* 8224B2B8h case    2:*/		regs.R3 = regs.R30;
		/* 8224B2B8h case    2:*/		return 0x8224B2BC;
		  /* 8224B2BCh */ case    3:  		/* bl 47436 */
		/* 8224B2BCh case    3:*/		regs.LR = 0x8224B2C0; return 0x82256C08;
		/* 8224B2BCh case    3:*/		return 0x8224B2C0;
	}
	return 0x8224B2C0;
} // Block from 8224B2B0h-8224B2C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224B2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B2C0);
		  /* 8224B2C0h */ case    0:  		/* mr R5, R30 */
		/* 8224B2C0h case    0:*/		regs.R5 = regs.R30;
		/* 8224B2C0h case    0:*/		return 0x8224B2C4;
		  /* 8224B2C4h */ case    1:  		/* mr R4, R31 */
		/* 8224B2C4h case    1:*/		regs.R4 = regs.R31;
		/* 8224B2C4h case    1:*/		return 0x8224B2C8;
		  /* 8224B2C8h */ case    2:  		/* mr R3, R18 */
		/* 8224B2C8h case    2:*/		regs.R3 = regs.R18;
		/* 8224B2C8h case    2:*/		return 0x8224B2CC;
		  /* 8224B2CCh */ case    3:  		/* bl 56660 */
		/* 8224B2CCh case    3:*/		regs.LR = 0x8224B2D0; return 0x82259020;
		/* 8224B2CCh case    3:*/		return 0x8224B2D0;
		  /* 8224B2D0h */ case    4:  		/* li R3, 49 */
		/* 8224B2D0h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8224B2D0h case    4:*/		return 0x8224B2D4;
		  /* 8224B2D4h */ case    5:  		/* lwz R4, <#[R23]> */
		/* 8224B2D4h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000000) );
		/* 8224B2D4h case    5:*/		return 0x8224B2D8;
		  /* 8224B2D8h */ case    6:  		/* bl 44120 */
		/* 8224B2D8h case    6:*/		regs.LR = 0x8224B2DC; return 0x82255F30;
		/* 8224B2D8h case    6:*/		return 0x8224B2DC;
		  /* 8224B2DCh */ case    7:  		/* lwz R11, <#[R3 + 224]> */
		/* 8224B2DCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E0) );
		/* 8224B2DCh case    7:*/		return 0x8224B2E0;
		  /* 8224B2E0h */ case    8:  		/* stw R21, <#[R3 + 80]> */
		/* 8224B2E0h case    8:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000050) );
		/* 8224B2E0h case    8:*/		return 0x8224B2E4;
		  /* 8224B2E4h */ case    9:  		/* mr R30, R3 */
		/* 8224B2E4h case    9:*/		regs.R30 = regs.R3;
		/* 8224B2E4h case    9:*/		return 0x8224B2E8;
		  /* 8224B2E8h */ case   10:  		/* stw R11, <#[R3 + 56]> */
		/* 8224B2E8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 8224B2E8h case   10:*/		return 0x8224B2EC;
		  /* 8224B2ECh */ case   11:  		/* lwz R29, <#[R31 + 240]> */
		/* 8224B2ECh case   11:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x000000F0) );
		/* 8224B2ECh case   11:*/		return 0x8224B2F0;
		  /* 8224B2F0h */ case   12:  		/* cmplwi CR6, R29, 0 */
		/* 8224B2F0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8224B2F0h case   12:*/		return 0x8224B2F4;
		  /* 8224B2F4h */ case   13:  		/* bc 4, CR6_EQ, 28 */
		/* 8224B2F4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8224B310;  }
		/* 8224B2F4h case   13:*/		return 0x8224B2F8;
		  /* 8224B2F8h */ case   14:  		/* mr R6, R24 */
		/* 8224B2F8h case   14:*/		regs.R6 = regs.R24;
		/* 8224B2F8h case   14:*/		return 0x8224B2FC;
		  /* 8224B2FCh */ case   15:  		/* mr R5, R19 */
		/* 8224B2FCh case   15:*/		regs.R5 = regs.R19;
		/* 8224B2FCh case   15:*/		return 0x8224B300;
		  /* 8224B300h */ case   16:  		/* mr R4, R25 */
		/* 8224B300h case   16:*/		regs.R4 = regs.R25;
		/* 8224B300h case   16:*/		return 0x8224B304;
		  /* 8224B304h */ case   17:  		/* li R7, 634 */
		/* 8224B304h case   17:*/		cpu::op::li<0>(regs,&regs.R7,0x27A);
		/* 8224B304h case   17:*/		return 0x8224B308;
		  /* 8224B308h */ case   18:  		/* li R3, 0 */
		/* 8224B308h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B308h case   18:*/		return 0x8224B30C;
		  /* 8224B30Ch */ case   19:  		/* bl -997124 */
		/* 8224B30Ch case   19:*/		regs.LR = 0x8224B310; return 0x82157C08;
		/* 8224B30Ch case   19:*/		return 0x8224B310;
	}
	return 0x8224B310;
} // Block from 8224B2C0h-8224B310h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8224B310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B310);
		  /* 8224B310h */ case    0:  		/* lwz R11, <#[R29 + 80]> */
		/* 8224B310h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000050) );
		/* 8224B310h case    0:*/		return 0x8224B314;
		  /* 8224B314h */ case    1:  		/* addi R10, R22, 6 */
		/* 8224B314h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R22,0x6);
		/* 8224B314h case    1:*/		return 0x8224B318;
		  /* 8224B318h */ case    2:  		/* mulli R11, R11, 12 */
		/* 8224B318h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8224B318h case    2:*/		return 0x8224B31C;
		  /* 8224B31Ch */ case    3:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8224B31Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224B31Ch case    3:*/		return 0x8224B320;
		  /* 8224B320h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 8224B320h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224B320h case    4:*/		return 0x8224B324;
		  /* 8224B324h */ case    5:  		/* bc 4, CR0_EQ, 28 */
		/* 8224B324h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8224B340;  }
		/* 8224B324h case    5:*/		return 0x8224B328;
		  /* 8224B328h */ case    6:  		/* mr R6, R24 */
		/* 8224B328h case    6:*/		regs.R6 = regs.R24;
		/* 8224B328h case    6:*/		return 0x8224B32C;
		  /* 8224B32Ch */ case    7:  		/* mr R5, R20 */
		/* 8224B32Ch case    7:*/		regs.R5 = regs.R20;
		/* 8224B32Ch case    7:*/		return 0x8224B330;
		  /* 8224B330h */ case    8:  		/* mr R4, R25 */
		/* 8224B330h case    8:*/		regs.R4 = regs.R25;
		/* 8224B330h case    8:*/		return 0x8224B334;
		  /* 8224B334h */ case    9:  		/* li R7, 635 */
		/* 8224B334h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x27B);
		/* 8224B334h case    9:*/		return 0x8224B338;
	}
	return 0x8224B338;
} // Block from 8224B310h-8224B338h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224B338h
// Function '?ComparePriority@SchedNode@XGRAPHICS@@CAHPAV12@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B338);
		  /* 8224B338h */ case    0:  		/* li R3, 0 */
		/* 8224B338h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B338h case    0:*/		return 0x8224B33C;
		  /* 8224B33Ch */ case    1:  		/* bl -997172 */
		/* 8224B33Ch case    1:*/		regs.LR = 0x8224B340; return 0x82157C08;
		/* 8224B33Ch case    1:*/		return 0x8224B340;
	}
	return 0x8224B340;
} // Block from 8224B338h-8224B340h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224B340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B340);
		  /* 8224B340h */ case    0:  		/* mr R5, R30 */
		/* 8224B340h case    0:*/		regs.R5 = regs.R30;
		/* 8224B340h case    0:*/		return 0x8224B344;
		  /* 8224B344h */ case    1:  		/* li R4, 2 */
		/* 8224B344h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8224B344h case    1:*/		return 0x8224B348;
		  /* 8224B348h */ case    2:  		/* mr R3, R31 */
		/* 8224B348h case    2:*/		regs.R3 = regs.R31;
		/* 8224B348h case    2:*/		return 0x8224B34C;
		  /* 8224B34Ch */ case    3:  		/* bl -87036 */
		/* 8224B34Ch case    3:*/		regs.LR = 0x8224B350; return 0x82235F50;
		/* 8224B34Ch case    3:*/		return 0x8224B350;
		  /* 8224B350h */ case    4:  		/* mr R5, R29 */
		/* 8224B350h case    4:*/		regs.R5 = regs.R29;
		/* 8224B350h case    4:*/		return 0x8224B354;
		  /* 8224B354h */ case    5:  		/* li R4, 1 */
		/* 8224B354h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8224B354h case    5:*/		return 0x8224B358;
		  /* 8224B358h */ case    6:  		/* mr R3, R30 */
		/* 8224B358h case    6:*/		regs.R3 = regs.R30;
		/* 8224B358h case    6:*/		return 0x8224B35C;
		  /* 8224B35Ch */ case    7:  		/* bl -87052 */
		/* 8224B35Ch case    7:*/		regs.LR = 0x8224B360; return 0x82235F50;
		/* 8224B35Ch case    7:*/		return 0x8224B360;
		  /* 8224B360h */ case    8:  		/* lwz R11, <#[R31 + 136]> */
		/* 8224B360h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 8224B360h case    8:*/		return 0x8224B364;
		  /* 8224B364h */ case    9:  		/* stw R11, <#[R1 + 84]> */
		/* 8224B364h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8224B364h case    9:*/		return 0x8224B368;
		  /* 8224B368h */ case   10:  		/* lbz R10, <#[R1 + 85]> */
		/* 8224B368h case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000055) );
		/* 8224B368h case   10:*/		return 0x8224B36C;
		  /* 8224B36Ch */ case   11:  		/* lbz R5, <#[R1 + 84]> */
		/* 8224B36Ch case   11:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 8224B36Ch case   11:*/		return 0x8224B370;
		  /* 8224B370h */ case   12:  		/* cmplw CR6, R5, R10 */
		/* 8224B370h case   12:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 8224B370h case   12:*/		return 0x8224B374;
		  /* 8224B374h */ case   13:  		/* bc 4, CR6_EQ, 48 */
		/* 8224B374h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8224B3A4;  }
		/* 8224B374h case   13:*/		return 0x8224B378;
		  /* 8224B378h */ case   14:  		/* lbz R10, <#[R1 + 86]> */
		/* 8224B378h case   14:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000056) );
		/* 8224B378h case   14:*/		return 0x8224B37C;
		  /* 8224B37Ch */ case   15:  		/* cmplw CR6, R5, R10 */
		/* 8224B37Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 8224B37Ch case   15:*/		return 0x8224B380;
		  /* 8224B380h */ case   16:  		/* bc 4, CR6_EQ, 36 */
		/* 8224B380h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8224B3A4;  }
		/* 8224B380h case   16:*/		return 0x8224B384;
		  /* 8224B384h */ case   17:  		/* lbz R10, <#[R1 + 87]> */
		/* 8224B384h case   17:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000057) );
		/* 8224B384h case   17:*/		return 0x8224B388;
		  /* 8224B388h */ case   18:  		/* cmplw CR6, R5, R10 */
		/* 8224B388h case   18:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 8224B388h case   18:*/		return 0x8224B38C;
		  /* 8224B38Ch */ case   19:  		/* bc 4, CR6_EQ, 24 */
		/* 8224B38Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x8224B3A4;  }
		/* 8224B38Ch case   19:*/		return 0x8224B390;
		  /* 8224B390h */ case   20:  		/* stw R11, <#[R30 + 132]> */
		/* 8224B390h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8224B390h case   20:*/		return 0x8224B394;
		  /* 8224B394h */ case   21:  		/* li R6, 0 */
		/* 8224B394h case   21:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8224B394h case   21:*/		return 0x8224B398;
		  /* 8224B398h */ case   22:  		/* mr R4, R5 */
		/* 8224B398h case   22:*/		regs.R4 = regs.R5;
		/* 8224B398h case   22:*/		return 0x8224B39C;
		  /* 8224B39Ch */ case   23:  		/* mr R3, R30 */
		/* 8224B39Ch case   23:*/		regs.R3 = regs.R30;
		/* 8224B39Ch case   23:*/		return 0x8224B3A0;
		  /* 8224B3A0h */ case   24:  		/* bl 47208 */
		/* 8224B3A0h case   24:*/		regs.LR = 0x8224B3A4; return 0x82256C08;
		/* 8224B3A0h case   24:*/		return 0x8224B3A4;
	}
	return 0x8224B3A4;
} // Block from 8224B340h-8224B3A4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8224B3A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B3A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B3A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B3A4);
		  /* 8224B3A4h */ case    0:  		/* mr R5, R30 */
		/* 8224B3A4h case    0:*/		regs.R5 = regs.R30;
		/* 8224B3A4h case    0:*/		return 0x8224B3A8;
		  /* 8224B3A8h */ case    1:  		/* mr R4, R31 */
		/* 8224B3A8h case    1:*/		regs.R4 = regs.R31;
		/* 8224B3A8h case    1:*/		return 0x8224B3AC;
		  /* 8224B3ACh */ case    2:  		/* mr R3, R18 */
		/* 8224B3ACh case    2:*/		regs.R3 = regs.R18;
		/* 8224B3ACh case    2:*/		return 0x8224B3B0;
		  /* 8224B3B0h */ case    3:  		/* bl 56432 */
		/* 8224B3B0h case    3:*/		regs.LR = 0x8224B3B4; return 0x82259020;
		/* 8224B3B0h case    3:*/		return 0x8224B3B4;
		  /* 8224B3B4h */ case    4:  		/* addi R4, R1, 80 */
		/* 8224B3B4h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8224B3B4h case    4:*/		return 0x8224B3B8;
		  /* 8224B3B8h */ case    5:  		/* mr R3, R31 */
		/* 8224B3B8h case    5:*/		regs.R3 = regs.R31;
		/* 8224B3B8h case    5:*/		return 0x8224B3BC;
		  /* 8224B3BCh */ case    6:  		/* bl 111212 */
		/* 8224B3BCh case    6:*/		regs.LR = 0x8224B3C0; return 0x82266628;
		/* 8224B3BCh case    6:*/		return 0x8224B3C0;
		  /* 8224B3C0h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 8224B3C0h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8224B3C0h case    7:*/		return 0x8224B3C4;
		  /* 8224B3C4h */ case    8:  		/* bc 4, CR6_EQ, 28 */
		/* 8224B3C4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8224B3E0;  }
		/* 8224B3C4h case    8:*/		return 0x8224B3C8;
		  /* 8224B3C8h */ case    9:  		/* mr R6, R24 */
		/* 8224B3C8h case    9:*/		regs.R6 = regs.R24;
		/* 8224B3C8h case    9:*/		return 0x8224B3CC;
		  /* 8224B3CCh */ case   10:  		/* mr R5, R17 */
		/* 8224B3CCh case   10:*/		regs.R5 = regs.R17;
		/* 8224B3CCh case   10:*/		return 0x8224B3D0;
		  /* 8224B3D0h */ case   11:  		/* mr R4, R25 */
		/* 8224B3D0h case   11:*/		regs.R4 = regs.R25;
		/* 8224B3D0h case   11:*/		return 0x8224B3D4;
		  /* 8224B3D4h */ case   12:  		/* li R7, 645 */
		/* 8224B3D4h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x285);
		/* 8224B3D4h case   12:*/		return 0x8224B3D8;
		  /* 8224B3D8h */ case   13:  		/* li R3, 0 */
		/* 8224B3D8h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B3D8h case   13:*/		return 0x8224B3DC;
		  /* 8224B3DCh */ case   14:  		/* bl -997332 */
		/* 8224B3DCh case   14:*/		regs.LR = 0x8224B3E0; return 0x82157C08;
		/* 8224B3DCh case   14:*/		return 0x8224B3E0;
	}
	return 0x8224B3E0;
} // Block from 8224B3A4h-8224B3E0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224B3E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B3E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B3E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B3E0);
		  /* 8224B3E0h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8224B3E0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B3E0h case    0:*/		return 0x8224B3E4;
	}
	return 0x8224B3E4;
} // Block from 8224B3E0h-8224B3E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B3E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B3E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B3E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B3E4);
		  /* 8224B3E4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224B3E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B3E4h case    0:*/		return 0x8224B3E8;
		  /* 8224B3E8h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224B3E8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B3E8h case    1:*/		return 0x8224B3EC;
		  /* 8224B3ECh */ case    2:  		/* bc 4, CR6_EQ, -908 */
		/* 8224B3ECh case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224B060;  }
		/* 8224B3ECh case    2:*/		return 0x8224B3F0;
		  /* 8224B3F0h */ case    3:  		/* lwz R18, <#[R18 + 8]> */
		/* 8224B3F0h case    3:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R18 + 0x00000008) );
		/* 8224B3F0h case    3:*/		return 0x8224B3F4;
		  /* 8224B3F4h */ case    4:  		/* lwz R11, <#[R18 + 8]> */
		/* 8224B3F4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000008) );
		/* 8224B3F4h case    4:*/		return 0x8224B3F8;
		  /* 8224B3F8h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 8224B3F8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B3F8h case    5:*/		return 0x8224B3FC;
		  /* 8224B3FCh */ case    6:  		/* bc 4, CR6_EQ, -932 */
		/* 8224B3FCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x8224B058;  }
		/* 8224B3FCh case    6:*/		return 0x8224B400;
	}
	return 0x8224B400;
} // Block from 8224B3E4h-8224B400h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224B400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B400);
		  /* 8224B400h */ case    0:  		/* lis R11, -32252 */
		/* 8224B400h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224B400h case    0:*/		return 0x8224B404;
		  /* 8224B404h */ case    1:  		/* lwz R6, <#[R23 + 144]> */
		/* 8224B404h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R23 + 0x00000090) );
		/* 8224B404h case    1:*/		return 0x8224B408;
		  /* 8224B408h */ case    2:  		/* lwz R5, <#[R23 + 140]> */
		/* 8224B408h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R23 + 0x0000008C) );
		/* 8224B408h case    2:*/		return 0x8224B40C;
		  /* 8224B40Ch */ case    3:  		/* addi R4, R11, 14456 */
		/* 8224B40Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3878);
		/* 8224B40Ch case    3:*/		return 0x8224B410;
		  /* 8224B410h */ case    4:  		/* lwz R3, <#[R23]> */
		/* 8224B410h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000000) );
		/* 8224B410h case    4:*/		return 0x8224B414;
		  /* 8224B414h */ case    5:  		/* bl -188500 */
		/* 8224B414h case    5:*/		regs.LR = 0x8224B418; return 0x8221D3C0;
		/* 8224B414h case    5:*/		return 0x8224B418;
		  /* 8224B418h */ case    6:  		/* addi R1, R1, 224 */
		/* 8224B418h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 8224B418h case    6:*/		return 0x8224B41C;
		  /* 8224B41Ch */ case    7:  		/* b -1810852 */
		/* 8224B41Ch case    7:*/		return 0x82091278;
		/* 8224B41Ch case    7:*/		return 0x8224B420;
	}
	return 0x8224B420;
} // Block from 8224B400h-8224B420h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224B420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B420);
		  /* 8224B420h */ case    0:  		/* mfspr R12, LR */
		/* 8224B420h case    0:*/		regs.R12 = regs.LR;
		/* 8224B420h case    0:*/		return 0x8224B424;
		  /* 8224B424h */ case    1:  		/* bl -1810888 */
		/* 8224B424h case    1:*/		regs.LR = 0x8224B428; return 0x8209125C;
		/* 8224B424h case    1:*/		return 0x8224B428;
		  /* 8224B428h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224B428h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224B428h case    2:*/		return 0x8224B42C;
		  /* 8224B42Ch */ case    3:  		/* lwz R31, <#[R3 + 44]> */
		/* 8224B42Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x0000002C) );
		/* 8224B42Ch case    3:*/		return 0x8224B430;
		  /* 8224B430h */ case    4:  		/* mr R29, R3 */
		/* 8224B430h case    4:*/		regs.R29 = regs.R3;
		/* 8224B430h case    4:*/		return 0x8224B434;
		  /* 8224B434h */ case    5:  		/* mr R30, R4 */
		/* 8224B434h case    5:*/		regs.R30 = regs.R4;
		/* 8224B434h case    5:*/		return 0x8224B438;
		  /* 8224B438h */ case    6:  		/* b 28 */
		/* 8224B438h case    6:*/		return 0x8224B454;
		/* 8224B438h case    6:*/		return 0x8224B43C;
		  /* 8224B43Ch */ case    7:  		/* mr R4, R31 */
		/* 8224B43Ch case    7:*/		regs.R4 = regs.R31;
		/* 8224B43Ch case    7:*/		return 0x8224B440;
		  /* 8224B440h */ case    8:  		/* mr R3, R30 */
		/* 8224B440h case    8:*/		regs.R3 = regs.R30;
		/* 8224B440h case    8:*/		return 0x8224B444;
		  /* 8224B444h */ case    9:  		/* bl -3188 */
		/* 8224B444h case    9:*/		regs.LR = 0x8224B448; return 0x8224A7D0;
		/* 8224B444h case    9:*/		return 0x8224B448;
	}
	return 0x8224B448;
} // Block from 8224B420h-8224B448h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224B448h
// Function '?Check@R400ThreadModel@XGRAPHICS@@QAA_NPBVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B448);
		  /* 8224B448h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 8224B448h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8224B448h case    0:*/		return 0x8224B44C;
		  /* 8224B44Ch */ case    1:  		/* bc 12, CR0_GT, 40 */
		/* 8224B44Ch case    1:*/		if ( regs.CR[0].gt ) { return 0x8224B474;  }
		/* 8224B44Ch case    1:*/		return 0x8224B450;
		  /* 8224B450h */ case    2:  		/* lwz R31, <#[R31 + 8]> */
		/* 8224B450h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B450h case    2:*/		return 0x8224B454;
	}
	return 0x8224B454;
} // Block from 8224B448h-8224B454h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224B454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B454);
		  /* 8224B454h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224B454h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B454h case    0:*/		return 0x8224B458;
		  /* 8224B458h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224B458h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B458h case    1:*/		return 0x8224B45C;
		  /* 8224B45Ch */ case    2:  		/* bc 4, CR6_EQ, -32 */
		/* 8224B45Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224B43C;  }
		/* 8224B45Ch case    2:*/		return 0x8224B460;
		  /* 8224B460h */ case    3:  		/* mr R4, R30 */
		/* 8224B460h case    3:*/		regs.R4 = regs.R30;
		/* 8224B460h case    3:*/		return 0x8224B464;
		  /* 8224B464h */ case    4:  		/* addi R3, R29, 36 */
		/* 8224B464h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R29,0x24);
		/* 8224B464h case    4:*/		return 0x8224B468;
		  /* 8224B468h */ case    5:  		/* bl 33824 */
		/* 8224B468h case    5:*/		regs.LR = 0x8224B46C; return 0x82253888;
		/* 8224B468h case    5:*/		return 0x8224B46C;
		  /* 8224B46Ch */ case    6:  		/* addi R1, R1, 112 */
		/* 8224B46Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224B46Ch case    6:*/		return 0x8224B470;
		  /* 8224B470h */ case    7:  		/* b -1810884 */
		/* 8224B470h case    7:*/		return 0x820912AC;
		/* 8224B470h case    7:*/		return 0x8224B474;
	}
	return 0x8224B474;
} // Block from 8224B454h-8224B474h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8224B474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B474);
		  /* 8224B474h */ case    0:  		/* mr R4, R31 */
		/* 8224B474h case    0:*/		regs.R4 = regs.R31;
		/* 8224B474h case    0:*/		return 0x8224B478;
		  /* 8224B478h */ case    1:  		/* mr R3, R30 */
		/* 8224B478h case    1:*/		regs.R3 = regs.R30;
		/* 8224B478h case    1:*/		return 0x8224B47C;
		  /* 8224B47Ch */ case    2:  		/* bl 33612 */
		/* 8224B47Ch case    2:*/		regs.LR = 0x8224B480; return 0x822537C8;
		/* 8224B47Ch case    2:*/		return 0x8224B480;
		  /* 8224B480h */ case    3:  		/* b -20 */
		/* 8224B480h case    3:*/		return 0x8224B46C;
		/* 8224B480h case    3:*/		return 0x8224B484;
		  /* 8224B484h */ case    4:  		/* nop */
		/* 8224B484h case    4:*/		cpu::op::nop();
		/* 8224B484h case    4:*/		return 0x8224B488;
	}
	return 0x8224B488;
} // Block from 8224B474h-8224B488h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224B488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B488);
		  /* 8224B488h */ case    0:  		/* mfspr R12, LR */
		/* 8224B488h case    0:*/		regs.R12 = regs.LR;
		/* 8224B488h case    0:*/		return 0x8224B48C;
		  /* 8224B48Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8224B48Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224B48Ch case    1:*/		return 0x8224B490;
		  /* 8224B490h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8224B490h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224B490h case    2:*/		return 0x8224B494;
		  /* 8224B494h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8224B494h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224B494h case    3:*/		return 0x8224B498;
		  /* 8224B498h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224B498h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224B498h case    4:*/		return 0x8224B49C;
		  /* 8224B49Ch */ case    5:  		/* lwz R11, <#[R4 + 36]> */
		/* 8224B49Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000024) );
		/* 8224B49Ch case    5:*/		return 0x8224B4A0;
		  /* 8224B4A0h */ case    6:  		/* mr R30, R3 */
		/* 8224B4A0h case    6:*/		regs.R30 = regs.R3;
		/* 8224B4A0h case    6:*/		return 0x8224B4A4;
		  /* 8224B4A4h */ case    7:  		/* mr R31, R4 */
		/* 8224B4A4h case    7:*/		regs.R31 = regs.R4;
		/* 8224B4A4h case    7:*/		return 0x8224B4A8;
		  /* 8224B4A8h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 8224B4A8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B4A8h case    8:*/		return 0x8224B4AC;
		  /* 8224B4ACh */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 8224B4ACh case    9:*/		if ( regs.CR[6].eq ) { return 0x8224B4D4;  }
		/* 8224B4ACh case    9:*/		return 0x8224B4B0;
		  /* 8224B4B0h */ case   10:  		/* lis R11, -32252 */
		/* 8224B4B0h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224B4B0h case   10:*/		return 0x8224B4B4;
		  /* 8224B4B4h */ case   11:  		/* lis R10, -32252 */
		/* 8224B4B4h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224B4B4h case   11:*/		return 0x8224B4B8;
		  /* 8224B4B8h */ case   12:  		/* lis R9, -32253 */
		/* 8224B4B8h case   12:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8224B4B8h case   12:*/		return 0x8224B4BC;
		  /* 8224B4BCh */ case   13:  		/* addi R6, R11, 14208 */
		/* 8224B4BCh case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3780);
		/* 8224B4BCh case   13:*/		return 0x8224B4C0;
		  /* 8224B4C0h */ case   14:  		/* addi R5, R10, 14684 */
		/* 8224B4C0h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x395C);
		/* 8224B4C0h case   14:*/		return 0x8224B4C4;
		  /* 8224B4C4h */ case   15:  		/* addi R4, R9, 27460 */
		/* 8224B4C4h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8224B4C4h case   15:*/		return 0x8224B4C8;
		  /* 8224B4C8h */ case   16:  		/* li R7, 1388 */
		/* 8224B4C8h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x56C);
		/* 8224B4C8h case   16:*/		return 0x8224B4CC;
		  /* 8224B4CCh */ case   17:  		/* li R3, 0 */
		/* 8224B4CCh case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B4CCh case   17:*/		return 0x8224B4D0;
		  /* 8224B4D0h */ case   18:  		/* bl -997576 */
		/* 8224B4D0h case   18:*/		regs.LR = 0x8224B4D4; return 0x82157C08;
		/* 8224B4D0h case   18:*/		return 0x8224B4D4;
	}
	return 0x8224B4D4;
} // Block from 8224B488h-8224B4D4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224B4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B4D4);
		  /* 8224B4D4h */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 8224B4D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8224B4D4h case    0:*/		return 0x8224B4D8;
		  /* 8224B4D8h */ case    1:  		/* lwz R10, <#[R30 + 28]> */
		/* 8224B4D8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 8224B4D8h case    1:*/		return 0x8224B4DC;
		  /* 8224B4DCh */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 8224B4DCh case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224B4DCh case    2:*/		return 0x8224B4E0;
	}
	return 0x8224B4E0;
} // Block from 8224B4D4h-8224B4E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224B4E0h
// Function '?AdvanceCycle@R400ThreadModel@XGRAPHICS@@QAAXPBUParallelGroup@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B4E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B4E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B4E0);
		  /* 8224B4E0h */ case    0:  		/* bc 4, CR6_GT, 12 */
		/* 8224B4E0h case    0:*/		if ( !regs.CR[6].gt ) { return 0x8224B4EC;  }
		/* 8224B4E0h case    0:*/		return 0x8224B4E4;
		  /* 8224B4E4h */ case    1:  		/* li R3, 0 */
		/* 8224B4E4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B4E4h case    1:*/		return 0x8224B4E8;
		  /* 8224B4E8h */ case    2:  		/* b 208 */
		/* 8224B4E8h case    2:*/		return 0x8224B5B8;
		/* 8224B4E8h case    2:*/		return 0x8224B4EC;
	}
	return 0x8224B4EC;
} // Block from 8224B4E0h-8224B4ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224B4ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B4EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B4EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B4EC);
		  /* 8224B4ECh */ case    0:  		/* lwz R3, <#[R31 + 40]> */
		/* 8224B4ECh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8224B4ECh case    0:*/		return 0x8224B4F0;
		  /* 8224B4F0h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8224B4F0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224B4F0h case    1:*/		return 0x8224B4F4;
		  /* 8224B4F4h */ case    2:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224B4F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224B4F4h case    2:*/		return 0x8224B4F8;
		  /* 8224B4F8h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224B4F8h case    3:*/		regs.CTR = regs.R11;
		/* 8224B4F8h case    3:*/		return 0x8224B4FC;
		  /* 8224B4FCh */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224B4FCh case    4:*/		if ( 1 ) { regs.LR = 0x8224B500; return (uint32)regs.CTR; }
		/* 8224B4FCh case    4:*/		return 0x8224B500;
		  /* 8224B500h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224B500h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224B500h case    5:*/		return 0x8224B504;
		  /* 8224B504h */ case    6:  		/* bc 4, CR0_EQ, 176 */
		/* 8224B504h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8224B5B4;  }
		/* 8224B504h case    6:*/		return 0x8224B508;
		  /* 8224B508h */ case    7:  		/* lwz R11, <#[R31 + 60]> */
		/* 8224B508h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 8224B508h case    7:*/		return 0x8224B50C;
		  /* 8224B50Ch */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 8224B50Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B50Ch case    8:*/		return 0x8224B510;
		  /* 8224B510h */ case    9:  		/* bc 4, CR6_GT, 164 */
		/* 8224B510h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8224B5B4;  }
		/* 8224B510h case    9:*/		return 0x8224B514;
		  /* 8224B514h */ case   10:  		/* lwz R11, <#[R31 + 12]> */
		/* 8224B514h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8224B514h case   10:*/		return 0x8224B518;
		  /* 8224B518h */ case   11:  		/* lwz R10, <#[R30 + 112]> */
		/* 8224B518h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000070) );
		/* 8224B518h case   11:*/		return 0x8224B51C;
		  /* 8224B51Ch */ case   12:  		/* cmpw CR6, R11, R10 */
		/* 8224B51Ch case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224B51Ch case   12:*/		return 0x8224B520;
		  /* 8224B520h */ case   13:  		/* bc 12, CR6_GT, 148 */
		/* 8224B520h case   13:*/		if ( regs.CR[6].gt ) { return 0x8224B5B4;  }
		/* 8224B520h case   13:*/		return 0x8224B524;
		  /* 8224B524h */ case   14:  		/* lwz R11, <#[R30 + 8]> */
		/* 8224B524h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8224B524h case   14:*/		return 0x8224B528;
		  /* 8224B528h */ case   15:  		/* lwz R10, <#[R11 + 16]> */
		/* 8224B528h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8224B528h case   15:*/		return 0x8224B52C;
		  /* 8224B52Ch */ case   16:  		/* lwz R9, <#[R11 + 20]> */
		/* 8224B52Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 8224B52Ch case   16:*/		return 0x8224B530;
		  /* 8224B530h */ case   17:  		/* cmpw CR6, R10, R9 */
		/* 8224B530h case   17:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 8224B530h case   17:*/		return 0x8224B534;
		  /* 8224B534h */ case   18:  		/* bc 4, CR6_GT, 12 */
		/* 8224B534h case   18:*/		if ( !regs.CR[6].gt ) { return 0x8224B540;  }
		/* 8224B534h case   18:*/		return 0x8224B538;
		  /* 8224B538h */ case   19:  		/* lwz R9, <#[R11 + 24]> */
		/* 8224B538h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000018) );
		/* 8224B538h case   19:*/		return 0x8224B53C;
		  /* 8224B53Ch */ case   20:  		/* b 20 */
		/* 8224B53Ch case   20:*/		return 0x8224B550;
		/* 8224B53Ch case   20:*/		return 0x8224B540;
	}
	return 0x8224B540;
} // Block from 8224B4ECh-8224B540h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224B540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B540);
		  /* 8224B540h */ case    0:  		/* add R9, R9, R10 */
		/* 8224B540h case    0:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8224B540h case    0:*/		return 0x8224B544;
		  /* 8224B544h */ case    1:  		/* lwz R10, <#[R11 + 24]> */
		/* 8224B544h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 8224B544h case    1:*/		return 0x8224B548;
		  /* 8224B548h */ case    2:  		/* srawi R9, R9, 1 */
		/* 8224B548h case    2:*/		cpu::op::srawi<0,1>(regs,&regs.R9,regs.R9);
		/* 8224B548h case    2:*/		return 0x8224B54C;
		  /* 8224B54Ch */ case    3:  		/* addze R9, R9 */
		/* 8224B54Ch case    3:*/		cpu::op::addze<0>(regs,&regs.R9,regs.R9);
		/* 8224B54Ch case    3:*/		return 0x8224B550;
	}
	return 0x8224B550;
} // Block from 8224B540h-8224B550h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224B550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B550);
		  /* 8224B550h */ case    0:  		/* add R10, R9, R10 */
		/* 8224B550h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8224B550h case    0:*/		return 0x8224B554;
		  /* 8224B554h */ case    1:  		/* lwz R9, <#[R30 + 108]> */
		/* 8224B554h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000006C) );
		/* 8224B554h case    1:*/		return 0x8224B558;
		  /* 8224B558h */ case    2:  		/* cmpw CR6, R10, R9 */
		/* 8224B558h case    2:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 8224B558h case    2:*/		return 0x8224B55C;
		  /* 8224B55Ch */ case    3:  		/* bc 4, CR6_GT, 60 */
		/* 8224B55Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8224B598;  }
		/* 8224B55Ch case    3:*/		return 0x8224B560;
		  /* 8224B560h */ case    4:  		/* lwz R10, <#[R11 + 16]> */
		/* 8224B560h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8224B560h case    4:*/		return 0x8224B564;
		  /* 8224B564h */ case    5:  		/* lwz R9, <#[R11 + 20]> */
		/* 8224B564h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 8224B564h case    5:*/		return 0x8224B568;
		  /* 8224B568h */ case    6:  		/* cmpw CR6, R10, R9 */
		/* 8224B568h case    6:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 8224B568h case    6:*/		return 0x8224B56C;
		  /* 8224B56Ch */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 8224B56Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x8224B578;  }
		/* 8224B56Ch case    7:*/		return 0x8224B570;
		  /* 8224B570h */ case    8:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224B570h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224B570h case    8:*/		return 0x8224B574;
		  /* 8224B574h */ case    9:  		/* b 20 */
		/* 8224B574h case    9:*/		return 0x8224B588;
		/* 8224B574h case    9:*/		return 0x8224B578;
	}
	return 0x8224B578;
} // Block from 8224B550h-8224B578h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224B578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B578);
		  /* 8224B578h */ case    0:  		/* add R9, R9, R10 */
		/* 8224B578h case    0:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8224B578h case    0:*/		return 0x8224B57C;
		  /* 8224B57Ch */ case    1:  		/* lwz R10, <#[R11 + 24]> */
		/* 8224B57Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 8224B57Ch case    1:*/		return 0x8224B580;
		  /* 8224B580h */ case    2:  		/* srawi R11, R9, 1 */
		/* 8224B580h case    2:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R9);
		/* 8224B580h case    2:*/		return 0x8224B584;
		  /* 8224B584h */ case    3:  		/* addze R11, R11 */
		/* 8224B584h case    3:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 8224B584h case    3:*/		return 0x8224B588;
	}
	return 0x8224B588;
} // Block from 8224B578h-8224B588h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224B588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B588);
		  /* 8224B588h */ case    0:  		/* add R11, R11, R10 */
		/* 8224B588h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8224B588h case    0:*/		return 0x8224B58C;
		  /* 8224B58Ch */ case    1:  		/* lwz R10, <#[R31 + 24]> */
		/* 8224B58Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8224B58Ch case    1:*/		return 0x8224B590;
		  /* 8224B590h */ case    2:  		/* subf R11, R10, R11 */
		/* 8224B590h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8224B590h case    2:*/		return 0x8224B594;
		  /* 8224B594h */ case    3:  		/* b 12 */
		/* 8224B594h case    3:*/		return 0x8224B5A0;
		/* 8224B594h case    3:*/		return 0x8224B598;
	}
	return 0x8224B598;
} // Block from 8224B588h-8224B598h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224B598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B598);
		  /* 8224B598h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8224B598h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8224B598h case    0:*/		return 0x8224B59C;
		  /* 8224B59Ch */ case    1:  		/* subf R11, R11, R9 */
		/* 8224B59Ch case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8224B59Ch case    1:*/		return 0x8224B5A0;
	}
	return 0x8224B5A0;
} // Block from 8224B598h-8224B5A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224B5A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B5A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B5A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B5A0);
		  /* 8224B5A0h */ case    0:  		/* lwz R10, <#[R30]> */
		/* 8224B5A0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8224B5A0h case    0:*/		return 0x8224B5A4;
		  /* 8224B5A4h */ case    1:  		/* li R3, 0 */
		/* 8224B5A4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B5A4h case    1:*/		return 0x8224B5A8;
		  /* 8224B5A8h */ case    2:  		/* lwz R10, <#[R10 + 2728]> */
		/* 8224B5A8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000AA8) );
		/* 8224B5A8h case    2:*/		return 0x8224B5AC;
		  /* 8224B5ACh */ case    3:  		/* cmpw CR6, R11, R10 */
		/* 8224B5ACh case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8224B5ACh case    3:*/		return 0x8224B5B0;
		  /* 8224B5B0h */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 8224B5B0h case    4:*/		if ( regs.CR[6].gt ) { return 0x8224B5B8;  }
		/* 8224B5B0h case    4:*/		return 0x8224B5B4;
	}
	return 0x8224B5B4;
} // Block from 8224B5A0h-8224B5B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224B5B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B5B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B5B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B5B4);
		  /* 8224B5B4h */ case    0:  		/* li R3, 1 */
		/* 8224B5B4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8224B5B4h case    0:*/		return 0x8224B5B8;
	}
	return 0x8224B5B8;
} // Block from 8224B5B4h-8224B5B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B5B8);
		  /* 8224B5B8h */ case    0:  		/* addi R1, R1, 112 */
		/* 8224B5B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8224B5B8h case    0:*/		return 0x8224B5BC;
		  /* 8224B5BCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8224B5BCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8224B5BCh case    1:*/		return 0x8224B5C0;
		  /* 8224B5C0h */ case    2:  		/* mtspr LR, R12 */
		/* 8224B5C0h case    2:*/		regs.LR = regs.R12;
		/* 8224B5C0h case    2:*/		return 0x8224B5C4;
		  /* 8224B5C4h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8224B5C4h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8224B5C4h case    3:*/		return 0x8224B5C8;
		  /* 8224B5C8h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8224B5C8h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8224B5C8h case    4:*/		return 0x8224B5CC;
		  /* 8224B5CCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 8224B5CCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224B5CCh case    5:*/		return 0x8224B5D0;
	}
	return 0x8224B5D0;
} // Block from 8224B5B8h-8224B5D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224B5D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B5D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B5D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B5D0);
		  /* 8224B5D0h */ case    0:  		/* mfspr R12, LR */
		/* 8224B5D0h case    0:*/		regs.R12 = regs.LR;
		/* 8224B5D0h case    0:*/		return 0x8224B5D4;
		  /* 8224B5D4h */ case    1:  		/* bl -1811324 */
		/* 8224B5D4h case    1:*/		regs.LR = 0x8224B5D8; return 0x82091258;
		/* 8224B5D4h case    1:*/		return 0x8224B5D8;
		  /* 8224B5D8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8224B5D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8224B5D8h case    2:*/		return 0x8224B5DC;
		  /* 8224B5DCh */ case    3:  		/* lwz R9, <#[R4 + 28]> */
		/* 8224B5DCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x0000001C) );
		/* 8224B5DCh case    3:*/		return 0x8224B5E0;
		  /* 8224B5E0h */ case    4:  		/* lis R11, -32253 */
		/* 8224B5E0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8224B5E0h case    4:*/		return 0x8224B5E4;
		  /* 8224B5E4h */ case    5:  		/* lis R10, -32252 */
		/* 8224B5E4h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224B5E4h case    5:*/		return 0x8224B5E8;
		  /* 8224B5E8h */ case    6:  		/* mr R28, R3 */
		/* 8224B5E8h case    6:*/		regs.R28 = regs.R3;
		/* 8224B5E8h case    6:*/		return 0x8224B5EC;
		  /* 8224B5ECh */ case    7:  		/* mr R31, R4 */
		/* 8224B5ECh case    7:*/		regs.R31 = regs.R4;
		/* 8224B5ECh case    7:*/		return 0x8224B5F0;
		  /* 8224B5F0h */ case    8:  		/* cmpwi CR6, R9, -1 */
		/* 8224B5F0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8224B5F0h case    8:*/		return 0x8224B5F4;
		  /* 8224B5F4h */ case    9:  		/* addi R30, R11, 27460 */
		/* 8224B5F4h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x6B44);
		/* 8224B5F4h case    9:*/		return 0x8224B5F8;
		  /* 8224B5F8h */ case   10:  		/* addi R29, R10, 14208 */
		/* 8224B5F8h case   10:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0x3780);
		/* 8224B5F8h case   10:*/		return 0x8224B5FC;
		  /* 8224B5FCh */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 8224B5FCh case   11:*/		if ( regs.CR[6].eq ) { return 0x8224B61C;  }
		/* 8224B5FCh case   11:*/		return 0x8224B600;
		  /* 8224B600h */ case   12:  		/* lis R11, -32252 */
		/* 8224B600h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224B600h case   12:*/		return 0x8224B604;
		  /* 8224B604h */ case   13:  		/* mr R6, R29 */
		/* 8224B604h case   13:*/		regs.R6 = regs.R29;
		/* 8224B604h case   13:*/		return 0x8224B608;
		  /* 8224B608h */ case   14:  		/* addi R5, R11, 14708 */
		/* 8224B608h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3974);
		/* 8224B608h case   14:*/		return 0x8224B60C;
		  /* 8224B60Ch */ case   15:  		/* mr R4, R30 */
		/* 8224B60Ch case   15:*/		regs.R4 = regs.R30;
		/* 8224B60Ch case   15:*/		return 0x8224B610;
		  /* 8224B610h */ case   16:  		/* li R7, 1418 */
		/* 8224B610h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x58A);
		/* 8224B610h case   16:*/		return 0x8224B614;
		  /* 8224B614h */ case   17:  		/* li R3, 0 */
		/* 8224B614h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B614h case   17:*/		return 0x8224B618;
		  /* 8224B618h */ case   18:  		/* bl -997904 */
		/* 8224B618h case   18:*/		regs.LR = 0x8224B61C; return 0x82157C08;
		/* 8224B618h case   18:*/		return 0x8224B61C;
	}
	return 0x8224B61C;
} // Block from 8224B5D0h-8224B61Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8224B61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B61C);
		  /* 8224B61Ch */ case    0:  		/* lwz R11, <#[R31 + 36]> */
		/* 8224B61Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8224B61Ch case    0:*/		return 0x8224B620;
		  /* 8224B620h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224B620h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B620h case    1:*/		return 0x8224B624;
		  /* 8224B624h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 8224B624h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224B644;  }
		/* 8224B624h case    2:*/		return 0x8224B628;
		  /* 8224B628h */ case    3:  		/* lis R11, -32252 */
		/* 8224B628h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224B628h case    3:*/		return 0x8224B62C;
		  /* 8224B62Ch */ case    4:  		/* mr R6, R29 */
		/* 8224B62Ch case    4:*/		regs.R6 = regs.R29;
		/* 8224B62Ch case    4:*/		return 0x8224B630;
		  /* 8224B630h */ case    5:  		/* addi R5, R11, 14684 */
		/* 8224B630h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x395C);
		/* 8224B630h case    5:*/		return 0x8224B634;
		  /* 8224B634h */ case    6:  		/* mr R4, R30 */
		/* 8224B634h case    6:*/		regs.R4 = regs.R30;
		/* 8224B634h case    6:*/		return 0x8224B638;
		  /* 8224B638h */ case    7:  		/* li R7, 1419 */
		/* 8224B638h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x58B);
		/* 8224B638h case    7:*/		return 0x8224B63C;
		  /* 8224B63Ch */ case    8:  		/* li R3, 0 */
		/* 8224B63Ch case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B63Ch case    8:*/		return 0x8224B640;
		  /* 8224B640h */ case    9:  		/* bl -997944 */
		/* 8224B640h case    9:*/		regs.LR = 0x8224B644; return 0x82157C08;
		/* 8224B640h case    9:*/		return 0x8224B644;
	}
	return 0x8224B644;
} // Block from 8224B61Ch-8224B644h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8224B644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B644);
		  /* 8224B644h */ case    0:  		/* mr R4, R31 */
		/* 8224B644h case    0:*/		regs.R4 = regs.R31;
		/* 8224B644h case    0:*/		return 0x8224B648;
		  /* 8224B648h */ case    1:  		/* mr R3, R28 */
		/* 8224B648h case    1:*/		regs.R3 = regs.R28;
		/* 8224B648h case    1:*/		return 0x8224B64C;
		  /* 8224B64Ch */ case    2:  		/* bl -452 */
		/* 8224B64Ch case    2:*/		regs.LR = 0x8224B650; return 0x8224B488;
		/* 8224B64Ch case    2:*/		return 0x8224B650;
		  /* 8224B650h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224B650h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224B650h case    3:*/		return 0x8224B654;
		  /* 8224B654h */ case    4:  		/* mr R4, R31 */
		/* 8224B654h case    4:*/		regs.R4 = regs.R31;
		/* 8224B654h case    4:*/		return 0x8224B658;
		  /* 8224B658h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 8224B658h case    5:*/		if ( regs.CR[0].eq ) { return 0x8224B668;  }
		/* 8224B658h case    5:*/		return 0x8224B65C;
		  /* 8224B65Ch */ case    6:  		/* mr R3, R28 */
		/* 8224B65Ch case    6:*/		regs.R3 = regs.R28;
		/* 8224B65Ch case    6:*/		return 0x8224B660;
		  /* 8224B660h */ case    7:  		/* bl -576 */
		/* 8224B660h case    7:*/		regs.LR = 0x8224B664; return 0x8224B420;
		/* 8224B660h case    7:*/		return 0x8224B664;
		  /* 8224B664h */ case    8:  		/* b 12 */
		/* 8224B664h case    8:*/		return 0x8224B670;
		/* 8224B664h case    8:*/		return 0x8224B668;
	}
	return 0x8224B668;
} // Block from 8224B644h-8224B668h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8224B668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B668);
		  /* 8224B668h */ case    0:  		/* addi R3, R28, 60 */
		/* 8224B668h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R28,0x3C);
		/* 8224B668h case    0:*/		return 0x8224B66C;
		  /* 8224B66Ch */ case    1:  		/* bl 33308 */
		/* 8224B66Ch case    1:*/		regs.LR = 0x8224B670; return 0x82253888;
		/* 8224B66Ch case    1:*/		return 0x8224B670;
	}
	return 0x8224B670;
} // Block from 8224B668h-8224B670h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224B670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B670);
		  /* 8224B670h */ case    0:  		/* addi R1, R1, 128 */
		/* 8224B670h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8224B670h case    0:*/		return 0x8224B674;
		  /* 8224B674h */ case    1:  		/* b -1811404 */
		/* 8224B674h case    1:*/		return 0x820912A8;
		/* 8224B674h case    1:*/		return 0x8224B678;
	}
	return 0x8224B678;
} // Block from 8224B670h-8224B678h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224B678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B678);
		  /* 8224B678h */ case    0:  		/* mfspr R12, LR */
		/* 8224B678h case    0:*/		regs.R12 = regs.LR;
		/* 8224B678h case    0:*/		return 0x8224B67C;
		  /* 8224B67Ch */ case    1:  		/* bl -1811492 */
		/* 8224B67Ch case    1:*/		regs.LR = 0x8224B680; return 0x82091258;
		/* 8224B67Ch case    1:*/		return 0x8224B680;
		  /* 8224B680h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8224B680h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8224B680h case    2:*/		return 0x8224B684;
		  /* 8224B684h */ case    3:  		/* mr R30, R3 */
		/* 8224B684h case    3:*/		regs.R30 = regs.R3;
		/* 8224B684h case    3:*/		return 0x8224B688;
		  /* 8224B688h */ case    4:  		/* lwz R3, <#[R3 + 8]> */
		/* 8224B688h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 8224B688h case    4:*/		return 0x8224B68C;
		  /* 8224B68Ch */ case    5:  		/* mr R28, R4 */
		/* 8224B68Ch case    5:*/		regs.R28 = regs.R4;
		/* 8224B68Ch case    5:*/		return 0x8224B690;
		  /* 8224B690h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 8224B690h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224B690h case    6:*/		return 0x8224B694;
		  /* 8224B694h */ case    7:  		/* lwz R11, <#[R11 + 20]> */
		/* 8224B694h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8224B694h case    7:*/		return 0x8224B698;
		  /* 8224B698h */ case    8:  		/* mtspr CTR, R11 */
		/* 8224B698h case    8:*/		regs.CTR = regs.R11;
		/* 8224B698h case    8:*/		return 0x8224B69C;
		  /* 8224B69Ch */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 8224B69Ch case    9:*/		if ( 1 ) { regs.LR = 0x8224B6A0; return (uint32)regs.CTR; }
		/* 8224B69Ch case    9:*/		return 0x8224B6A0;
		  /* 8224B6A0h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224B6A0h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224B6A0h case   10:*/		return 0x8224B6A4;
		  /* 8224B6A4h */ case   11:  		/* bc 12, CR0_EQ, 120 */
		/* 8224B6A4h case   11:*/		if ( regs.CR[0].eq ) { return 0x8224B71C;  }
		/* 8224B6A4h case   11:*/		return 0x8224B6A8;
		  /* 8224B6A8h */ case   12:  		/* lwz R31, <#[R30 + 44]> */
		/* 8224B6A8h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x0000002C) );
		/* 8224B6A8h case   12:*/		return 0x8224B6AC;
		  /* 8224B6ACh */ case   13:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224B6ACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B6ACh case   13:*/		return 0x8224B6B0;
		  /* 8224B6B0h */ case   14:  		/* cmpwi CR6, R11, 0 */
		/* 8224B6B0h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B6B0h case   14:*/		return 0x8224B6B4;
		  /* 8224B6B4h */ case   15:  		/* bc 12, CR6_EQ, 64 */
		/* 8224B6B4h case   15:*/		if ( regs.CR[6].eq ) { return 0x8224B6F4;  }
		/* 8224B6B4h case   15:*/		return 0x8224B6B8;
		  /* 8224B6B8h */ case   16:  		/* lis R11, -32216 */
		/* 8224B6B8h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8224B6B8h case   16:*/		return 0x8224B6BC;
		  /* 8224B6BCh */ case   17:  		/* addi R29, R11, 17992 */
		/* 8224B6BCh case   17:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x4648);
		/* 8224B6BCh case   17:*/		return 0x8224B6C0;
		  /* 8224B6C0h */ case   18:  		/* lwz R3, <#[R31 + 40]> */
		/* 8224B6C0h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8224B6C0h case   18:*/		return 0x8224B6C4;
		  /* 8224B6C4h */ case   19:  		/* lwz R11, <#[R3 + 24]> */
		/* 8224B6C4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8224B6C4h case   19:*/		return 0x8224B6C8;
		  /* 8224B6C8h */ case   20:  		/* mulli R11, R11, 52 */
		/* 8224B6C8h case   20:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 8224B6C8h case   20:*/		return 0x8224B6CC;
		  /* 8224B6CCh */ case   21:  		/* lwzx R11, <#[R11 + R29]> */
		/* 8224B6CCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8224B6CCh case   21:*/		return 0x8224B6D0;
		  /* 8224B6D0h */ case   22:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 8224B6D0h case   22:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8224B6D0h case   22:*/		return 0x8224B6D4;
		  /* 8224B6D4h */ case   23:  		/* bc 4, CR0_EQ, 48 */
		/* 8224B6D4h case   23:*/		if ( !regs.CR[0].eq ) { return 0x8224B704;  }
		/* 8224B6D4h case   23:*/		return 0x8224B6D8;
		  /* 8224B6D8h */ case   24:  		/* bl 42824 */
		/* 8224B6D8h case   24:*/		regs.LR = 0x8224B6DC; return 0x82255E20;
		/* 8224B6D8h case   24:*/		return 0x8224B6DC;
		  /* 8224B6DCh */ case   25:  		/* cmpwi CR6, R3, 3 */
		/* 8224B6DCh case   25:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 8224B6DCh case   25:*/		return 0x8224B6E0;
		  /* 8224B6E0h */ case   26:  		/* bc 4, CR6_LT, 52 */
		/* 8224B6E0h case   26:*/		if ( !regs.CR[6].lt ) { return 0x8224B714;  }
		/* 8224B6E0h case   26:*/		return 0x8224B6E4;
		  /* 8224B6E4h */ case   27:  		/* lwz R31, <#[R31 + 8]> */
		/* 8224B6E4h case   27:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B6E4h case   27:*/		return 0x8224B6E8;
		  /* 8224B6E8h */ case   28:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224B6E8h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B6E8h case   28:*/		return 0x8224B6EC;
		  /* 8224B6ECh */ case   29:  		/* cmpwi CR6, R11, 0 */
		/* 8224B6ECh case   29:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B6ECh case   29:*/		return 0x8224B6F0;
		  /* 8224B6F0h */ case   30:  		/* bc 4, CR6_EQ, -48 */
		/* 8224B6F0h case   30:*/		if ( !regs.CR[6].eq ) { return 0x8224B6C0;  }
		/* 8224B6F0h case   30:*/		return 0x8224B6F4;
	}
	return 0x8224B6F4;
} // Block from 8224B678h-8224B6F4h (31 instructions)

//////////////////////////////////////////////////////
// Block at 8224B6F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B6F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B6F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B6F4);
		  /* 8224B6F4h */ case    0:  		/* li R11, 0 */
		/* 8224B6F4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224B6F4h case    0:*/		return 0x8224B6F8;
		  /* 8224B6F8h */ case    1:  		/* stb R11, <#[R28]> */
		/* 8224B6F8h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8224B6F8h case    1:*/		return 0x8224B6FC;
		  /* 8224B6FCh */ case    2:  		/* lwz R3, <#[R30 + 44]> */
		/* 8224B6FCh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 8224B6FCh case    2:*/		return 0x8224B700;
		  /* 8224B700h */ case    3:  		/* b 192 */
		/* 8224B700h case    3:*/		return 0x8224B7C0;
		/* 8224B700h case    3:*/		return 0x8224B704;
	}
	return 0x8224B704;
} // Block from 8224B6F4h-8224B704h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224B704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B704);
		  /* 8224B704h */ case    0:  		/* li R11, 0 */
		/* 8224B704h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224B704h case    0:*/		return 0x8224B708;
		  /* 8224B708h */ case    1:  		/* mr R3, R31 */
		/* 8224B708h case    1:*/		regs.R3 = regs.R31;
		/* 8224B708h case    1:*/		return 0x8224B70C;
		  /* 8224B70Ch */ case    2:  		/* stb R11, <#[R28]> */
		/* 8224B70Ch case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8224B70Ch case    2:*/		return 0x8224B710;
		  /* 8224B710h */ case    3:  		/* b 176 */
		/* 8224B710h case    3:*/		return 0x8224B7C0;
		/* 8224B710h case    3:*/		return 0x8224B714;
	}
	return 0x8224B714;
} // Block from 8224B704h-8224B714h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224B714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B714);
		  /* 8224B714h */ case    0:  		/* li R11, 1 */
		/* 8224B714h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224B714h case    0:*/		return 0x8224B718;
		  /* 8224B718h */ case    1:  		/* b -16 */
		/* 8224B718h case    1:*/		return 0x8224B708;
		/* 8224B718h case    1:*/		return 0x8224B71C;
	}
	return 0x8224B71C;
} // Block from 8224B714h-8224B71Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224B71Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B71C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B71C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B71C);
		  /* 8224B71Ch */ case    0:  		/* lwz R3, <#[R30 + 8]> */
		/* 8224B71Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 8224B71Ch case    0:*/		return 0x8224B720;
		  /* 8224B720h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8224B720h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224B720h case    1:*/		return 0x8224B724;
		  /* 8224B724h */ case    2:  		/* lwz R11, <#[R11 + 24]> */
		/* 8224B724h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8224B724h case    2:*/		return 0x8224B728;
		  /* 8224B728h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224B728h case    3:*/		regs.CTR = regs.R11;
		/* 8224B728h case    3:*/		return 0x8224B72C;
		  /* 8224B72Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224B72Ch case    4:*/		if ( 1 ) { regs.LR = 0x8224B730; return (uint32)regs.CTR; }
		/* 8224B72Ch case    4:*/		return 0x8224B730;
		  /* 8224B730h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224B730h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224B730h case    5:*/		return 0x8224B734;
		  /* 8224B734h */ case    6:  		/* bc 12, CR0_EQ, 56 */
		/* 8224B734h case    6:*/		if ( regs.CR[0].eq ) { return 0x8224B76C;  }
		/* 8224B734h case    6:*/		return 0x8224B738;
		  /* 8224B738h */ case    7:  		/* lwz R31, <#[R30 + 44]> */
		/* 8224B738h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x0000002C) );
		/* 8224B738h case    7:*/		return 0x8224B73C;
		  /* 8224B73Ch */ case    8:  		/* b 24 */
		/* 8224B73Ch case    8:*/		return 0x8224B754;
		/* 8224B73Ch case    8:*/		return 0x8224B740;
		  /* 8224B740h */ case    9:  		/* lwz R3, <#[R31 + 40]> */
		/* 8224B740h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8224B740h case    9:*/		return 0x8224B744;
		  /* 8224B744h */ case   10:  		/* bl 42716 */
		/* 8224B744h case   10:*/		regs.LR = 0x8224B748; return 0x82255E20;
		/* 8224B744h case   10:*/		return 0x8224B748;
		  /* 8224B748h */ case   11:  		/* cmpwi CR6, R3, 3 */
		/* 8224B748h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 8224B748h case   11:*/		return 0x8224B74C;
		  /* 8224B74Ch */ case   12:  		/* bc 4, CR6_LT, -56 */
		/* 8224B74Ch case   12:*/		if ( !regs.CR[6].lt ) { return 0x8224B714;  }
		/* 8224B74Ch case   12:*/		return 0x8224B750;
		  /* 8224B750h */ case   13:  		/* lwz R31, <#[R31 + 8]> */
		/* 8224B750h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B750h case   13:*/		return 0x8224B754;
	}
	return 0x8224B754;
} // Block from 8224B71Ch-8224B754h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224B754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B754);
		  /* 8224B754h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224B754h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B754h case    0:*/		return 0x8224B758;
		  /* 8224B758h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224B758h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B758h case    1:*/		return 0x8224B75C;
		  /* 8224B75Ch */ case    2:  		/* bc 4, CR6_EQ, -28 */
		/* 8224B75Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224B740;  }
		/* 8224B75Ch case    2:*/		return 0x8224B760;
		  /* 8224B760h */ case    3:  		/* li R3, 0 */
		/* 8224B760h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B760h case    3:*/		return 0x8224B764;
		  /* 8224B764h */ case    4:  		/* li R11, 0 */
		/* 8224B764h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224B764h case    4:*/		return 0x8224B768;
		  /* 8224B768h */ case    5:  		/* b -92 */
		/* 8224B768h case    5:*/		return 0x8224B70C;
		/* 8224B768h case    5:*/		return 0x8224B76C;
	}
	return 0x8224B76C;
} // Block from 8224B754h-8224B76Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224B76Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B76C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B76C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B76C);
		  /* 8224B76Ch */ case    0:  		/* lwz R3, <#[R30 + 8]> */
		/* 8224B76Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 8224B76Ch case    0:*/		return 0x8224B770;
		  /* 8224B770h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8224B770h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224B770h case    1:*/		return 0x8224B774;
		  /* 8224B774h */ case    2:  		/* lwz R11, <#[R11 + 28]> */
		/* 8224B774h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8224B774h case    2:*/		return 0x8224B778;
		  /* 8224B778h */ case    3:  		/* mtspr CTR, R11 */
		/* 8224B778h case    3:*/		regs.CTR = regs.R11;
		/* 8224B778h case    3:*/		return 0x8224B77C;
		  /* 8224B77Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8224B77Ch case    4:*/		if ( 1 ) { regs.LR = 0x8224B780; return (uint32)regs.CTR; }
		/* 8224B77Ch case    4:*/		return 0x8224B780;
		  /* 8224B780h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8224B780h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8224B780h case    5:*/		return 0x8224B784;
		  /* 8224B784h */ case    6:  		/* bc 12, CR0_EQ, 56 */
		/* 8224B784h case    6:*/		if ( regs.CR[0].eq ) { return 0x8224B7BC;  }
		/* 8224B784h case    6:*/		return 0x8224B788;
		  /* 8224B788h */ case    7:  		/* lwz R31, <#[R30 + 44]> */
		/* 8224B788h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x0000002C) );
		/* 8224B788h case    7:*/		return 0x8224B78C;
		  /* 8224B78Ch */ case    8:  		/* b 24 */
		/* 8224B78Ch case    8:*/		return 0x8224B7A4;
		/* 8224B78Ch case    8:*/		return 0x8224B790;
		  /* 8224B790h */ case    9:  		/* lwz R3, <#[R31 + 40]> */
		/* 8224B790h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8224B790h case    9:*/		return 0x8224B794;
		  /* 8224B794h */ case   10:  		/* bl 42636 */
		/* 8224B794h case   10:*/		regs.LR = 0x8224B798; return 0x82255E20;
		/* 8224B794h case   10:*/		return 0x8224B798;
		  /* 8224B798h */ case   11:  		/* cmpwi CR6, R3, 3 */
		/* 8224B798h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 8224B798h case   11:*/		return 0x8224B79C;
		  /* 8224B79Ch */ case   12:  		/* bc 12, CR6_LT, 24 */
		/* 8224B79Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x8224B7B4;  }
		/* 8224B79Ch case   12:*/		return 0x8224B7A0;
		  /* 8224B7A0h */ case   13:  		/* lwz R31, <#[R31 + 8]> */
		/* 8224B7A0h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B7A0h case   13:*/		return 0x8224B7A4;
	}
	return 0x8224B7A4;
} // Block from 8224B76Ch-8224B7A4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8224B7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B7A4);
		  /* 8224B7A4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8224B7A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B7A4h case    0:*/		return 0x8224B7A8;
		  /* 8224B7A8h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224B7A8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B7A8h case    1:*/		return 0x8224B7AC;
		  /* 8224B7ACh */ case    2:  		/* bc 4, CR6_EQ, -28 */
		/* 8224B7ACh case    2:*/		if ( !regs.CR[6].eq ) { return 0x8224B790;  }
		/* 8224B7ACh case    2:*/		return 0x8224B7B0;
		  /* 8224B7B0h */ case    3:  		/* b -188 */
		/* 8224B7B0h case    3:*/		return 0x8224B6F4;
		/* 8224B7B0h case    3:*/		return 0x8224B7B4;
	}
	return 0x8224B7B4;
} // Block from 8224B7A4h-8224B7B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224B7B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B7B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B7B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B7B4);
		  /* 8224B7B4h */ case    0:  		/* mr R3, R31 */
		/* 8224B7B4h case    0:*/		regs.R3 = regs.R31;
		/* 8224B7B4h case    0:*/		return 0x8224B7B8;
		  /* 8224B7B8h */ case    1:  		/* b -84 */
		/* 8224B7B8h case    1:*/		return 0x8224B764;
		/* 8224B7B8h case    1:*/		return 0x8224B7BC;
	}
	return 0x8224B7BC;
} // Block from 8224B7B4h-8224B7BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224B7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B7BC);
		  /* 8224B7BCh */ case    0:  		/* li R3, 0 */
		/* 8224B7BCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8224B7BCh case    0:*/		return 0x8224B7C0;
	}
	return 0x8224B7C0;
} // Block from 8224B7BCh-8224B7C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B7C0);
		  /* 8224B7C0h */ case    0:  		/* addi R1, R1, 128 */
		/* 8224B7C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8224B7C0h case    0:*/		return 0x8224B7C4;
		  /* 8224B7C4h */ case    1:  		/* b -1811740 */
		/* 8224B7C4h case    1:*/		return 0x820912A8;
		/* 8224B7C4h case    1:*/		return 0x8224B7C8;
		  /* 8224B7C8h */ case    2:  		/* lwz R11, <#[R3 + 228]> */
		/* 8224B7C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 8224B7C8h case    2:*/		return 0x8224B7CC;
		  /* 8224B7CCh */ case    3:  		/* rlwinm. R10, R11, 27, 31, 31 */
		/* 8224B7CCh case    3:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R10,regs.R11);
		/* 8224B7CCh case    3:*/		return 0x8224B7D0;
		  /* 8224B7D0h */ case    4:  		/* bc 4, CR0_EQ, 84 */
		/* 8224B7D0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8224B824;  }
		/* 8224B7D0h case    4:*/		return 0x8224B7D4;
		  /* 8224B7D4h */ case    5:  		/* rlwinm. R10, R11, 26, 31, 31 */
		/* 8224B7D4h case    5:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R10,regs.R11);
		/* 8224B7D4h case    5:*/		return 0x8224B7D8;
		  /* 8224B7D8h */ case    6:  		/* bc 4, CR0_EQ, 76 */
		/* 8224B7D8h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8224B824;  }
		/* 8224B7D8h case    6:*/		return 0x8224B7DC;
		  /* 8224B7DCh */ case    7:  		/* lwz R10, <#[R3 + 16]> */
		/* 8224B7DCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 8224B7DCh case    7:*/		return 0x8224B7E0;
		  /* 8224B7E0h */ case    8:  		/* cmpwi CR6, R10, 0 */
		/* 8224B7E0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8224B7E0h case    8:*/		return 0x8224B7E4;
		  /* 8224B7E4h */ case    9:  		/* bc 12, CR6_EQ, 48 */
		/* 8224B7E4h case    9:*/		if ( regs.CR[6].eq ) { return 0x8224B814;  }
		/* 8224B7E4h case    9:*/		return 0x8224B7E8;
		  /* 8224B7E8h */ case   10:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 8224B7E8h case   10:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 8224B7E8h case   10:*/		return 0x8224B7EC;
		  /* 8224B7ECh */ case   11:  		/* bc 4, CR0_EQ, 40 */
		/* 8224B7ECh case   11:*/		if ( !regs.CR[0].eq ) { return 0x8224B814;  }
		/* 8224B7ECh case   11:*/		return 0x8224B7F0;
		  /* 8224B7F0h */ case   12:  		/* lis R11, -32251 */
		/* 8224B7F0h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8224B7F0h case   12:*/		return 0x8224B7F4;
		  /* 8224B7F4h */ case   13:  		/* lwz R10, <#[R3 + 80]> */
		/* 8224B7F4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000050) );
		/* 8224B7F4h case   13:*/		return 0x8224B7F8;
		  /* 8224B7F8h */ case   14:  		/* addi R11, R11, -19064 */
		/* 8224B7F8h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFB588);
		/* 8224B7F8h case   14:*/		return 0x8224B7FC;
		  /* 8224B7FCh */ case   15:  		/* mulli R10, R10, 12 */
		/* 8224B7FCh case   15:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 8224B7FCh case   15:*/		return 0x8224B800;
		  /* 8224B800h */ case   16:  		/* addi R11, R11, 4 */
		/* 8224B800h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8224B800h case   16:*/		return 0x8224B804;
		  /* 8224B804h */ case   17:  		/* lbzx R11, <#[R10 + R11]> */
		/* 8224B804h case   17:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8224B804h case   17:*/		return 0x8224B808;
		  /* 8224B808h */ case   18:  		/* cmplwi CR0, R11, 0 */
		/* 8224B808h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8224B808h case   18:*/		return 0x8224B80C;
		  /* 8224B80Ch */ case   19:  		/* li R11, 1 */
		/* 8224B80Ch case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224B80Ch case   19:*/		return 0x8224B810;
		  /* 8224B810h */ case   20:  		/* bc 4, CR0_EQ, 8 */
		/* 8224B810h case   20:*/		if ( !regs.CR[0].eq ) { return 0x8224B818;  }
		/* 8224B810h case   20:*/		return 0x8224B814;
	}
	return 0x8224B814;
} // Block from 8224B7C0h-8224B814h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8224B814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B814);
		  /* 8224B814h */ case    0:  		/* li R11, 0 */
		/* 8224B814h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224B814h case    0:*/		return 0x8224B818;
	}
	return 0x8224B818;
} // Block from 8224B814h-8224B818h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B818);
		  /* 8224B818h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8224B818h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8224B818h case    0:*/		return 0x8224B81C;
		  /* 8224B81Ch */ case    1:  		/* li R11, 1 */
		/* 8224B81Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224B81Ch case    1:*/		return 0x8224B820;
		  /* 8224B820h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 8224B820h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8224B828;  }
		/* 8224B820h case    2:*/		return 0x8224B824;
	}
	return 0x8224B824;
} // Block from 8224B818h-8224B824h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8224B824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B824);
		  /* 8224B824h */ case    0:  		/* li R11, 0 */
		/* 8224B824h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224B824h case    0:*/		return 0x8224B828;
	}
	return 0x8224B828;
} // Block from 8224B824h-8224B828h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B828);
		  /* 8224B828h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8224B828h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8224B828h case    0:*/		return 0x8224B82C;
		  /* 8224B82Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224B82Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224B82Ch case    1:*/		return 0x8224B830;
	}
	return 0x8224B830;
} // Block from 8224B828h-8224B830h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224B830h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B830);
		  /* 8224B830h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8224B830h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224B830h case    0:*/		return 0x8224B834;
		  /* 8224B834h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 8224B834h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8224B834h case    1:*/		return 0x8224B838;
	}
	return 0x8224B838;
} // Block from 8224B830h-8224B838h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224B838h
// Function '?ReactivateMova@R400ThreadModel@XGRAPHICS@@QAAXPAVSchedNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B838);
		  /* 8224B838h */ case    0:  		/* mtspr CTR, R11 */
		/* 8224B838h case    0:*/		regs.CTR = regs.R11;
		/* 8224B838h case    0:*/		return 0x8224B83C;
		  /* 8224B83Ch */ case    1:  		/* bcctr 20, CR0_LT */
		/* 8224B83Ch case    1:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 8224B83Ch case    1:*/		return 0x8224B840;
	}
	return 0x8224B840;
} // Block from 8224B838h-8224B840h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224B840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B840);
		  /* 8224B840h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224B840h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224B840h case    0:*/		return 0x8224B844;
		  /* 8224B844h */ case    1:  		/* cntlzw R11, R11 */
		/* 8224B844h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8224B844h case    1:*/		return 0x8224B848;
		  /* 8224B848h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 8224B848h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 8224B848h case    2:*/		return 0x8224B84C;
		  /* 8224B84Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 8224B84Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224B84Ch case    3:*/		return 0x8224B850;
	}
	return 0x8224B850;
} // Block from 8224B840h-8224B850h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224B850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B850);
		  /* 8224B850h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224B850h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224B850h case    0:*/		return 0x8224B854;
		  /* 8224B854h */ case    1:  		/* lis R10, -32251 */
		/* 8224B854h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8224B854h case    1:*/		return 0x8224B858;
		  /* 8224B858h */ case    2:  		/* addi R10, R10, -18088 */
		/* 8224B858h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFB958);
		/* 8224B858h case    2:*/		return 0x8224B85C;
		  /* 8224B85Ch */ case    3:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8224B85Ch case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8224B85Ch case    3:*/		return 0x8224B860;
		  /* 8224B860h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8224B860h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8224B860h case    4:*/		return 0x8224B864;
		  /* 8224B864h */ case    5:  		/* stw R11, <#[R3 + 4]> */
		/* 8224B864h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224B864h case    5:*/		return 0x8224B868;
		  /* 8224B868h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8224B868h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224B868h case    6:*/		return 0x8224B86C;
	}
	return 0x8224B86C;
} // Block from 8224B850h-8224B86Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8224B86Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B86C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B86C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B86C);
		  /* 8224B86Ch */ case    0:  		/* nop */
		/* 8224B86Ch case    0:*/		cpu::op::nop();
		/* 8224B86Ch case    0:*/		return 0x8224B870;
	}
	return 0x8224B870;
} // Block from 8224B86Ch-8224B870h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B870);
		  /* 8224B870h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224B870h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224B870h case    0:*/		return 0x8224B874;
		  /* 8224B874h */ case    1:  		/* addi R11, R11, -3 */
		/* 8224B874h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFD);
		/* 8224B874h case    1:*/		return 0x8224B878;
		  /* 8224B878h */ case    2:  		/* cntlzw R11, R11 */
		/* 8224B878h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8224B878h case    2:*/		return 0x8224B87C;
		  /* 8224B87Ch */ case    3:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 8224B87Ch case    3:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 8224B87Ch case    3:*/		return 0x8224B880;
		  /* 8224B880h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8224B880h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224B880h case    4:*/		return 0x8224B884;
	}
	return 0x8224B884;
} // Block from 8224B870h-8224B884h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8224B884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B884);
		  /* 8224B884h */ case    0:  		/* nop */
		/* 8224B884h case    0:*/		cpu::op::nop();
		/* 8224B884h case    0:*/		return 0x8224B888;
	}
	return 0x8224B888;
} // Block from 8224B884h-8224B888h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B888);
		  /* 8224B888h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224B888h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224B888h case    0:*/		return 0x8224B88C;
		  /* 8224B88Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224B88Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B88Ch case    1:*/		return 0x8224B890;
		  /* 8224B890h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8224B890h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224B8A0;  }
		/* 8224B890h case    2:*/		return 0x8224B894;
		  /* 8224B894h */ case    3:  		/* cmpwi CR6, R11, 2 */
		/* 8224B894h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8224B894h case    3:*/		return 0x8224B898;
		  /* 8224B898h */ case    4:  		/* li R11, 0 */
		/* 8224B898h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224B898h case    4:*/		return 0x8224B89C;
		  /* 8224B89Ch */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 8224B89Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8224B8A4;  }
		/* 8224B89Ch case    5:*/		return 0x8224B8A0;
	}
	return 0x8224B8A0;
} // Block from 8224B888h-8224B8A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224B8A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B8A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B8A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B8A0);
		  /* 8224B8A0h */ case    0:  		/* li R11, 1 */
		/* 8224B8A0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224B8A0h case    0:*/		return 0x8224B8A4;
	}
	return 0x8224B8A4;
} // Block from 8224B8A0h-8224B8A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B8A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B8A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B8A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B8A4);
		  /* 8224B8A4h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8224B8A4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8224B8A4h case    0:*/		return 0x8224B8A8;
		  /* 8224B8A8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224B8A8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224B8A8h case    1:*/		return 0x8224B8AC;
	}
	return 0x8224B8AC;
} // Block from 8224B8A4h-8224B8ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224B8ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B8AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B8AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B8AC);
		  /* 8224B8ACh */ case    0:  		/* nop */
		/* 8224B8ACh case    0:*/		cpu::op::nop();
		/* 8224B8ACh case    0:*/		return 0x8224B8B0;
	}
	return 0x8224B8B0;
} // Block from 8224B8ACh-8224B8B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B8B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B8B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B8B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B8B0);
		  /* 8224B8B0h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 8224B8B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8224B8B0h case    0:*/		return 0x8224B8B4;
		  /* 8224B8B4h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8224B8B4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8224B8B4h case    1:*/		return 0x8224B8B8;
		  /* 8224B8B8h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8224B8B8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8224B8C8;  }
		/* 8224B8B8h case    2:*/		return 0x8224B8BC;
		  /* 8224B8BCh */ case    3:  		/* cmpwi CR6, R11, 1 */
		/* 8224B8BCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8224B8BCh case    3:*/		return 0x8224B8C0;
		  /* 8224B8C0h */ case    4:  		/* li R11, 0 */
		/* 8224B8C0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8224B8C0h case    4:*/		return 0x8224B8C4;
		  /* 8224B8C4h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 8224B8C4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8224B8CC;  }
		/* 8224B8C4h case    5:*/		return 0x8224B8C8;
	}
	return 0x8224B8C8;
} // Block from 8224B8B0h-8224B8C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224B8C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B8C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B8C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B8C8);
		  /* 8224B8C8h */ case    0:  		/* li R11, 1 */
		/* 8224B8C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8224B8C8h case    0:*/		return 0x8224B8CC;
	}
	return 0x8224B8CC;
} // Block from 8224B8C8h-8224B8CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B8CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B8CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B8CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B8CC);
		  /* 8224B8CCh */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8224B8CCh case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8224B8CCh case    0:*/		return 0x8224B8D0;
		  /* 8224B8D0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8224B8D0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8224B8D0h case    1:*/		return 0x8224B8D4;
	}
	return 0x8224B8D4;
} // Block from 8224B8CCh-8224B8D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8224B8D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B8D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B8D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B8D4);
		  /* 8224B8D4h */ case    0:  		/* nop */
		/* 8224B8D4h case    0:*/		cpu::op::nop();
		/* 8224B8D4h case    0:*/		return 0x8224B8D8;
	}
	return 0x8224B8D8;
} // Block from 8224B8D4h-8224B8D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B8D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B8D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B8D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B8D8);
		  /* 8224B8D8h */ case    0:  		/* mfspr R12, LR */
		/* 8224B8D8h case    0:*/		regs.R12 = regs.LR;
		/* 8224B8D8h case    0:*/		return 0x8224B8DC;
		  /* 8224B8DCh */ case    1:  		/* bl -1812096 */
		/* 8224B8DCh case    1:*/		regs.LR = 0x8224B8E0; return 0x8209125C;
		/* 8224B8DCh case    1:*/		return 0x8224B8E0;
		  /* 8224B8E0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8224B8E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8224B8E0h case    2:*/		return 0x8224B8E4;
		  /* 8224B8E4h */ case    3:  		/* lis R11, -32252 */
		/* 8224B8E4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8224B8E4h case    3:*/		return 0x8224B8E8;
		  /* 8224B8E8h */ case    4:  		/* li R29, 0 */
		/* 8224B8E8h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8224B8E8h case    4:*/		return 0x8224B8EC;
		  /* 8224B8ECh */ case    5:  		/* addi R11, R11, 14796 */
		/* 8224B8ECh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x39CC);
		/* 8224B8ECh case    5:*/		return 0x8224B8F0;
	}
	return 0x8224B8F0;
} // Block from 8224B8D8h-8224B8F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8224B8F0h
// Function '?first_unset@bitset@XGRAPHICS@@QBAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B8F0);
		  /* 8224B8F0h */ case    0:  		/* stw R29, <#[R3 + 4]> */
		/* 8224B8F0h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000004) );
		/* 8224B8F0h case    0:*/		return 0x8224B8F4;
		  /* 8224B8F4h */ case    1:  		/* mr R30, R4 */
		/* 8224B8F4h case    1:*/		regs.R30 = regs.R4;
		/* 8224B8F4h case    1:*/		return 0x8224B8F8;
		  /* 8224B8F8h */ case    2:  		/* stw R11, <#[R3]> */
		/* 8224B8F8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8224B8F8h case    2:*/		return 0x8224B8FC;
		  /* 8224B8FCh */ case    3:  		/* mr R31, R3 */
		/* 8224B8FCh case    3:*/		regs.R31 = regs.R3;
		/* 8224B8FCh case    3:*/		return 0x8224B900;
		  /* 8224B900h */ case    4:  		/* li R4, 12 */
		/* 8224B900h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 8224B900h case    4:*/		return 0x8224B904;
		  /* 8224B904h */ case    5:  		/* mr R3, R30 */
		/* 8224B904h case    5:*/		regs.R3 = regs.R30;
		/* 8224B904h case    5:*/		return 0x8224B908;
		  /* 8224B908h */ case    6:  		/* bl -193616 */
		/* 8224B908h case    6:*/		regs.LR = 0x8224B90C; return 0x8221C4B8;
		/* 8224B908h case    6:*/		return 0x8224B90C;
		  /* 8224B90Ch */ case    7:  		/* addic. R11, R3, 4 */
		/* 8224B90Ch case    7:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 8224B90Ch case    7:*/		return 0x8224B910;
		  /* 8224B910h */ case    8:  		/* stw R30, <#[R3]> */
		/* 8224B910h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224B910h case    8:*/		return 0x8224B914;
		  /* 8224B914h */ case    9:  		/* bc 12, CR0_EQ, 24 */
		/* 8224B914h case    9:*/		if ( regs.CR[0].eq ) { return 0x8224B92C;  }
		/* 8224B914h case    9:*/		return 0x8224B918;
		  /* 8224B918h */ case   10:  		/* lis R10, -32252 */
		/* 8224B918h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224B918h case   10:*/		return 0x8224B91C;
		  /* 8224B91Ch */ case   11:  		/* stw R29, <#[R11 + 4]> */
		/* 8224B91Ch case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 8224B91Ch case   11:*/		return 0x8224B920;
		  /* 8224B920h */ case   12:  		/* addi R10, R10, 14732 */
		/* 8224B920h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x398C);
		/* 8224B920h case   12:*/		return 0x8224B924;
		  /* 8224B924h */ case   13:  		/* stw R10, <#[R11]> */
		/* 8224B924h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8224B924h case   13:*/		return 0x8224B928;
		  /* 8224B928h */ case   14:  		/* b 8 */
		/* 8224B928h case   14:*/		return 0x8224B930;
		/* 8224B928h case   14:*/		return 0x8224B92C;
	}
	return 0x8224B92C;
} // Block from 8224B8F0h-8224B92Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8224B92Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B92C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B92C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B92C);
		  /* 8224B92Ch */ case    0:  		/* mr R11, R29 */
		/* 8224B92Ch case    0:*/		regs.R11 = regs.R29;
		/* 8224B92Ch case    0:*/		return 0x8224B930;
	}
	return 0x8224B930;
} // Block from 8224B92Ch-8224B930h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8224B930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B930);
		  /* 8224B930h */ case    0:  		/* stw R11, <#[R31 + 8]> */
		/* 8224B930h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8224B930h case    0:*/		return 0x8224B934;
		  /* 8224B934h */ case    1:  		/* li R4, 16 */
		/* 8224B934h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 8224B934h case    1:*/		return 0x8224B938;
		  /* 8224B938h */ case    2:  		/* mr R3, R30 */
		/* 8224B938h case    2:*/		regs.R3 = regs.R30;
		/* 8224B938h case    2:*/		return 0x8224B93C;
		  /* 8224B93Ch */ case    3:  		/* bl -193668 */
		/* 8224B93Ch case    3:*/		regs.LR = 0x8224B940; return 0x8221C4B8;
		/* 8224B93Ch case    3:*/		return 0x8224B940;
	}
	return 0x8224B940;
} // Block from 8224B930h-8224B940h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224B940h
// Function '?Reset@ResourceModel@XGRAPHICS@@UAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B940);
		  /* 8224B940h */ case    0:  		/* addic. R11, R3, 4 */
		/* 8224B940h case    0:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 8224B940h case    0:*/		return 0x8224B944;
		  /* 8224B944h */ case    1:  		/* stw R30, <#[R3]> */
		/* 8224B944h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8224B944h case    1:*/		return 0x8224B948;
		  /* 8224B948h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 8224B948h case    2:*/		if ( regs.CR[0].eq ) { return 0x8224B960;  }
		/* 8224B948h case    2:*/		return 0x8224B94C;
		  /* 8224B94Ch */ case    3:  		/* lis R10, -32252 */
		/* 8224B94Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8224B94Ch case    3:*/		return 0x8224B950;
	}
	return 0x8224B950;
} // Block from 8224B940h-8224B950h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224B950h
// Function '?Reset@R400SchedModel@XGRAPHICS@@UAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B950);
		  /* 8224B950h */ case    0:  		/* stw R29, <#[R11 + 4]> */
		/* 8224B950h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 8224B950h case    0:*/		return 0x8224B954;
		  /* 8224B954h */ case    1:  		/* addi R10, R10, 14764 */
		/* 8224B954h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x39AC);
		/* 8224B954h case    1:*/		return 0x8224B958;
		  /* 8224B958h */ case    2:  		/* stw R10, <#[R11]> */
		/* 8224B958h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8224B958h case    2:*/		return 0x8224B95C;
		  /* 8224B95Ch */ case    3:  		/* b 8 */
		/* 8224B95Ch case    3:*/		return 0x8224B964;
		/* 8224B95Ch case    3:*/		return 0x8224B960;
	}
	return 0x8224B960;
} // Block from 8224B950h-8224B960h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8224B960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8224B960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8224B960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8224B960);
		  /* 8224B960h */ case    0:  		/* mr R11, R29 */
		/* 8224B960h case    0:*/		regs.R11 = regs.R29;
		/* 8224B960h case    0:*/		return 0x8224B964;
	}
	return 0x8224B964;
} // Block from 8224B960h-8224B964h (1 instructions)

